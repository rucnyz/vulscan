[
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\nnamespace _A_namespace\n{\n\n\n\n\nstatic void f_jclyipfv()\n{\n    TwoIntsClass * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = new TwoIntsClass[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n        delete [] data;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(8)\n    {\n    case 7:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        \n        \n        ; \n        break;\n    }\n}\n\n\nstatic void f_nlszjfcs()\n{\n    TwoIntsClass * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = new TwoIntsClass[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n        delete [] data;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        \n        \n        ; \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_umibkfsx()\n{\n    TwoIntsClass * data;\n    \n    data = NULL;\n    switch(5)\n    {\n    case 6:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        data = new TwoIntsClass[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printIntLine(data[0].intOne);\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_hjjslnsa()\n{\n    TwoIntsClass * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = new TwoIntsClass[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printIntLine(data[0].intOne);\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\nvoid f_lorfjunp()\n{\n    f_jclyipfv();\n    f_nlszjfcs();\n    f_umibkfsx();\n    f_hjjslnsa();\n}\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_lorfjunp();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403392,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_array_class_15.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\nnamespace _A_namespace\n{\n\n\nvoid f_hzluconn()\n{\n    TwoIntsClass * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = new TwoIntsClass[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n        delete [] data;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printIntLine(data[0].intOne);\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_hzluconn();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403393,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_array_class_15.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\nnamespace _A_namespace\n{\n\n\n\n\nstatic void f_wvrshqtp()\n{\n    twoIntsStruct * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = new twoIntsStruct[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n        delete [] data;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(8)\n    {\n    case 7:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        \n        \n        ; \n        break;\n    }\n}\n\n\nstatic void f_sdbbakhc()\n{\n    twoIntsStruct * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = new twoIntsStruct[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n        delete [] data;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        \n        \n        ; \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_pkkceefy()\n{\n    twoIntsStruct * data;\n    \n    data = NULL;\n    switch(5)\n    {\n    case 6:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        data = new twoIntsStruct[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printStructLine(&data[0]);\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_jfefqkzk()\n{\n    twoIntsStruct * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = new twoIntsStruct[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printStructLine(&data[0]);\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\nvoid f_bqxdkkoc()\n{\n    f_wvrshqtp();\n    f_sdbbakhc();\n    f_pkkceefy();\n    f_jfefqkzk();\n}\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_bqxdkkoc();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403394,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_array_struct_15.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\nnamespace _A_namespace\n{\n\n\nvoid f_eudragzx()\n{\n    twoIntsStruct * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = new twoIntsStruct[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n        delete [] data;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printStructLine(&data[0]);\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_eudragzx();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403395,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_array_struct_15.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\n\n\nstatic void f_uiquczwe()\n{\n    twoIntsStruct * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));\n        if (data == NULL) {exit(-1);}\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n        free(data);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(8)\n    {\n    case 7:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        \n        \n        ; \n        break;\n    }\n}\n\n\nstatic void f_ehujjenx()\n{\n    twoIntsStruct * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));\n        if (data == NULL) {exit(-1);}\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n        free(data);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        \n        \n        ; \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_fpeuzdxk()\n{\n    twoIntsStruct * data;\n    \n    data = NULL;\n    switch(5)\n    {\n    case 6:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));\n        if (data == NULL) {exit(-1);}\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printStructLine(&data[0]);\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_lxkqnhiv()\n{\n    twoIntsStruct * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));\n        if (data == NULL) {exit(-1);}\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printStructLine(&data[0]);\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\nvoid f_yaqafmva()\n{\n    f_uiquczwe();\n    f_ehujjenx();\n    f_fpeuzdxk();\n    f_lxkqnhiv();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_yaqafmva();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403396,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__malloc_free_struct_15.c",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nvoid f_yveqmxgg()\n{\n    twoIntsStruct * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));\n        if (data == NULL) {exit(-1);}\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n        free(data);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printStructLine(&data[0]);\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_yveqmxgg();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403397,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__malloc_free_struct_15.c",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\nnamespace _A_namespace\n{\n\n\n\n\nstatic void f_ojxrhdrd()\n{\n    int64_t * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = new int64_t[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5LL;\n            }\n        }\n        \n        delete [] data;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(8)\n    {\n    case 7:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        \n        \n        ; \n        break;\n    }\n}\n\n\nstatic void f_khtrttym()\n{\n    int64_t * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = new int64_t[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5LL;\n            }\n        }\n        \n        delete [] data;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        \n        \n        ; \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_ttafpnoz()\n{\n    int64_t * data;\n    \n    data = NULL;\n    switch(5)\n    {\n    case 6:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        data = new int64_t[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5LL;\n            }\n        }\n        \n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printLongLongLine(data[0]);\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_ehncwkjv()\n{\n    int64_t * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = new int64_t[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5LL;\n            }\n        }\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printLongLongLine(data[0]);\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\nvoid f_jqqaumvk()\n{\n    f_ojxrhdrd();\n    f_khtrttym();\n    f_ttafpnoz();\n    f_ehncwkjv();\n}\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_jqqaumvk();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403398,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_array_int64_t_15.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\nnamespace _A_namespace\n{\n\n\nvoid f_rmtehfuy()\n{\n    int64_t * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = new int64_t[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5LL;\n            }\n        }\n        \n        delete [] data;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printLongLongLine(data[0]);\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_rmtehfuy();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403399,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_array_int64_t_15.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\nnamespace _A_namespace\n{\n\n\n\n\nstatic void f_thbsbmwq()\n{\n    int * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = new int[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5;\n            }\n        }\n        \n        delete [] data;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(8)\n    {\n    case 7:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        \n        \n        ; \n        break;\n    }\n}\n\n\nstatic void f_lsxhjeoq()\n{\n    int * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = new int[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5;\n            }\n        }\n        \n        delete [] data;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        \n        \n        ; \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_fwuhjaup()\n{\n    int * data;\n    \n    data = NULL;\n    switch(5)\n    {\n    case 6:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        data = new int[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5;\n            }\n        }\n        \n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printIntLine(data[0]);\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_upryeysm()\n{\n    int * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = new int[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5;\n            }\n        }\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printIntLine(data[0]);\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\nvoid f_vssithyg()\n{\n    f_thbsbmwq();\n    f_lsxhjeoq();\n    f_fwuhjaup();\n    f_upryeysm();\n}\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_vssithyg();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403400,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_array_int_15.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\nnamespace _A_namespace\n{\n\n\nvoid f_nuewxwjx()\n{\n    int * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = new int[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5;\n            }\n        }\n        \n        delete [] data;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printIntLine(data[0]);\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_nuewxwjx();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403401,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_array_int_15.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\nnamespace _A_namespace\n{\n\n\n\n\nstatic void f_tvwwudab()\n{\n    long * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = new long[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5L;\n            }\n        }\n        \n        delete [] data;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(8)\n    {\n    case 7:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        \n        \n        ; \n        break;\n    }\n}\n\n\nstatic void f_pxdbexss()\n{\n    long * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = new long[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5L;\n            }\n        }\n        \n        delete [] data;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        \n        \n        ; \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_oyrmaylb()\n{\n    long * data;\n    \n    data = NULL;\n    switch(5)\n    {\n    case 6:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        data = new long[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5L;\n            }\n        }\n        \n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printLongLine(data[0]);\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_wlmondkp()\n{\n    long * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = new long[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5L;\n            }\n        }\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printLongLine(data[0]);\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\nvoid f_vcmxtcbd()\n{\n    f_tvwwudab();\n    f_pxdbexss();\n    f_oyrmaylb();\n    f_wlmondkp();\n}\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_vcmxtcbd();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403402,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_array_long_15.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\nnamespace _A_namespace\n{\n\n\nvoid f_ttpkcsgc()\n{\n    long * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = new long[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5L;\n            }\n        }\n        \n        delete [] data;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printLongLine(data[0]);\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ttpkcsgc();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403403,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_array_long_15.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\n\n\nstatic void f_zuhzeoxu()\n{\n    int64_t * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = (int64_t *)malloc(100*sizeof(int64_t));\n        if (data == NULL) {exit(-1);}\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5LL;\n            }\n        }\n        \n        free(data);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(8)\n    {\n    case 7:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        \n        \n        ; \n        break;\n    }\n}\n\n\nstatic void f_rfbebxbe()\n{\n    int64_t * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = (int64_t *)malloc(100*sizeof(int64_t));\n        if (data == NULL) {exit(-1);}\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5LL;\n            }\n        }\n        \n        free(data);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        \n        \n        ; \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_svmgnsrf()\n{\n    int64_t * data;\n    \n    data = NULL;\n    switch(5)\n    {\n    case 6:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        data = (int64_t *)malloc(100*sizeof(int64_t));\n        if (data == NULL) {exit(-1);}\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5LL;\n            }\n        }\n        \n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printLongLongLine(data[0]);\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_hhjytuxt()\n{\n    int64_t * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = (int64_t *)malloc(100*sizeof(int64_t));\n        if (data == NULL) {exit(-1);}\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5LL;\n            }\n        }\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printLongLongLine(data[0]);\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\nvoid f_tijnruzb()\n{\n    f_zuhzeoxu();\n    f_rfbebxbe();\n    f_svmgnsrf();\n    f_hhjytuxt();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_tijnruzb();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403404,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__malloc_free_int64_t_15.c",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nvoid f_kcpyjumy()\n{\n    int64_t * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = (int64_t *)malloc(100*sizeof(int64_t));\n        if (data == NULL) {exit(-1);}\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5LL;\n            }\n        }\n        \n        free(data);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printLongLongLine(data[0]);\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_kcpyjumy();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403405,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__malloc_free_int64_t_15.c",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\n\n\nstatic void f_jupfrcgo()\n{\n    long * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = (long *)malloc(100*sizeof(long));\n        if (data == NULL) {exit(-1);}\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5L;\n            }\n        }\n        \n        free(data);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(8)\n    {\n    case 7:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        \n        \n        ; \n        break;\n    }\n}\n\n\nstatic void f_muhhfkyy()\n{\n    long * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = (long *)malloc(100*sizeof(long));\n        if (data == NULL) {exit(-1);}\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5L;\n            }\n        }\n        \n        free(data);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        \n        \n        ; \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_ipqcgriu()\n{\n    long * data;\n    \n    data = NULL;\n    switch(5)\n    {\n    case 6:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        data = (long *)malloc(100*sizeof(long));\n        if (data == NULL) {exit(-1);}\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5L;\n            }\n        }\n        \n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printLongLine(data[0]);\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_abkjppar()\n{\n    long * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = (long *)malloc(100*sizeof(long));\n        if (data == NULL) {exit(-1);}\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5L;\n            }\n        }\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printLongLine(data[0]);\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\nvoid f_lylspmyk()\n{\n    f_jupfrcgo();\n    f_muhhfkyy();\n    f_ipqcgriu();\n    f_abkjppar();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_lylspmyk();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403406,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__malloc_free_long_15.c",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nvoid f_sjvfkqjl()\n{\n    long * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = (long *)malloc(100*sizeof(long));\n        if (data == NULL) {exit(-1);}\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5L;\n            }\n        }\n        \n        free(data);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printLongLine(data[0]);\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_sjvfkqjl();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403407,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__malloc_free_long_15.c",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\n\n\nstatic void f_zxsuqlce()\n{\n    int * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = (int *)malloc(100*sizeof(int));\n        if (data == NULL) {exit(-1);}\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5;\n            }\n        }\n        \n        free(data);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(8)\n    {\n    case 7:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        \n        \n        ; \n        break;\n    }\n}\n\n\nstatic void f_mabsptrs()\n{\n    int * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = (int *)malloc(100*sizeof(int));\n        if (data == NULL) {exit(-1);}\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5;\n            }\n        }\n        \n        free(data);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        \n        \n        ; \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_prwhksej()\n{\n    int * data;\n    \n    data = NULL;\n    switch(5)\n    {\n    case 6:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        data = (int *)malloc(100*sizeof(int));\n        if (data == NULL) {exit(-1);}\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5;\n            }\n        }\n        \n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printIntLine(data[0]);\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_bjvaqolg()\n{\n    int * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = (int *)malloc(100*sizeof(int));\n        if (data == NULL) {exit(-1);}\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5;\n            }\n        }\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printIntLine(data[0]);\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\nvoid f_bctdtyov()\n{\n    f_zxsuqlce();\n    f_mabsptrs();\n    f_prwhksej();\n    f_bjvaqolg();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_bctdtyov();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403408,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__malloc_free_int_15.c",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nvoid f_goyfokur()\n{\n    int * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = (int *)malloc(100*sizeof(int));\n        if (data == NULL) {exit(-1);}\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5;\n            }\n        }\n        \n        free(data);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printIntLine(data[0]);\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_goyfokur();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403409,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__malloc_free_int_15.c",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\nnamespace _A_namespace\n{\n\n\n\n\nstatic void f_rgbiumlh()\n{\n    char * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = new char[100];\n        memset(data, 'A', 100-1);\n        data[100-1] = '\\0';\n        \n        delete [] data;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(8)\n    {\n    case 7:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        \n        \n        ; \n        break;\n    }\n}\n\n\nstatic void f_binlvypz()\n{\n    char * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = new char[100];\n        memset(data, 'A', 100-1);\n        data[100-1] = '\\0';\n        \n        delete [] data;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        \n        \n        ; \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_ceasfwmk()\n{\n    char * data;\n    \n    data = NULL;\n    switch(5)\n    {\n    case 6:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        data = new char[100];\n        memset(data, 'A', 100-1);\n        data[100-1] = '\\0';\n        \n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printLine(data);\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_yqiddofq()\n{\n    char * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = new char[100];\n        memset(data, 'A', 100-1);\n        data[100-1] = '\\0';\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printLine(data);\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\nvoid f_gvvhwath()\n{\n    f_rgbiumlh();\n    f_binlvypz();\n    f_ceasfwmk();\n    f_yqiddofq();\n}\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_gvvhwath();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403410,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_array_char_15.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\nnamespace _A_namespace\n{\n\n\nvoid f_zagtgagw()\n{\n    char * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = new char[100];\n        memset(data, 'A', 100-1);\n        data[100-1] = '\\0';\n        \n        delete [] data;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printLine(data);\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_zagtgagw();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403411,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_array_char_15.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\nnamespace _A_namespace\n{\n\n\n\n\nstatic void f_tuhdtlyj()\n{\n    wchar_t * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = new wchar_t[100];\n        wmemset(data, L'A', 100-1);\n        data[100-1] = L'\\0';\n        \n        delete [] data;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(8)\n    {\n    case 7:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        \n        \n        ; \n        break;\n    }\n}\n\n\nstatic void f_hlmnlrjd()\n{\n    wchar_t * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = new wchar_t[100];\n        wmemset(data, L'A', 100-1);\n        data[100-1] = L'\\0';\n        \n        delete [] data;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        \n        \n        ; \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_vnncgief()\n{\n    wchar_t * data;\n    \n    data = NULL;\n    switch(5)\n    {\n    case 6:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        data = new wchar_t[100];\n        wmemset(data, L'A', 100-1);\n        data[100-1] = L'\\0';\n        \n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printWLine(data);\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_ndcmdznm()\n{\n    wchar_t * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = new wchar_t[100];\n        wmemset(data, L'A', 100-1);\n        data[100-1] = L'\\0';\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printWLine(data);\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\nvoid f_bsrzlazi()\n{\n    f_tuhdtlyj();\n    f_hlmnlrjd();\n    f_vnncgief();\n    f_ndcmdznm();\n}\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_bsrzlazi();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403412,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_array_wchar_t_15.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\nnamespace _A_namespace\n{\n\n\nvoid f_jjvcabuw()\n{\n    wchar_t * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = new wchar_t[100];\n        wmemset(data, L'A', 100-1);\n        data[100-1] = L'\\0';\n        \n        delete [] data;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printWLine(data);\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_jjvcabuw();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403413,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_array_wchar_t_15.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\nnamespace _A_namespace\n{\n\n\n\n\nstatic void f_tyjagmzi()\n{\n    TwoIntsClass * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = new TwoIntsClass;\n        data->intOne = 1;\n        data->intTwo = 2;\n        \n        delete data;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(8)\n    {\n    case 7:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        \n        \n        ; \n        break;\n    }\n}\n\n\nstatic void f_fnjbszbm()\n{\n    TwoIntsClass * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = new TwoIntsClass;\n        data->intOne = 1;\n        data->intTwo = 2;\n        \n        delete data;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        \n        \n        ; \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_gcekjrnr()\n{\n    TwoIntsClass * data;\n    \n    data = NULL;\n    switch(5)\n    {\n    case 6:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        data = new TwoIntsClass;\n        data->intOne = 1;\n        data->intTwo = 2;\n        \n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printIntLine(data->intOne);\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_msagdrhf()\n{\n    TwoIntsClass * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = new TwoIntsClass;\n        data->intOne = 1;\n        data->intTwo = 2;\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printIntLine(data->intOne);\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\nvoid f_bcgunpdd()\n{\n    f_tyjagmzi();\n    f_fnjbszbm();\n    f_gcekjrnr();\n    f_msagdrhf();\n}\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_bcgunpdd();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403414,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_class_15.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\nnamespace _A_namespace\n{\n\n\nvoid f_khunyypv()\n{\n    TwoIntsClass * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = new TwoIntsClass;\n        data->intOne = 1;\n        data->intTwo = 2;\n        \n        delete data;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printIntLine(data->intOne);\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_khunyypv();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403415,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_class_15.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\nnamespace _A_namespace\n{\n\n\n\n\nstatic void f_obrtzncz()\n{\n    twoIntsStruct * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = new twoIntsStruct;\n        data->intOne = 1;\n        data->intTwo = 2;\n        \n        delete data;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(8)\n    {\n    case 7:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        \n        \n        ; \n        break;\n    }\n}\n\n\nstatic void f_jpapggqp()\n{\n    twoIntsStruct * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = new twoIntsStruct;\n        data->intOne = 1;\n        data->intTwo = 2;\n        \n        delete data;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        \n        \n        ; \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_nyxdnspy()\n{\n    twoIntsStruct * data;\n    \n    data = NULL;\n    switch(5)\n    {\n    case 6:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        data = new twoIntsStruct;\n        data->intOne = 1;\n        data->intTwo = 2;\n        \n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printStructLine(data);\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_knjxcagm()\n{\n    twoIntsStruct * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = new twoIntsStruct;\n        data->intOne = 1;\n        data->intTwo = 2;\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printStructLine(data);\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\nvoid f_izssdlgc()\n{\n    f_obrtzncz();\n    f_jpapggqp();\n    f_nyxdnspy();\n    f_knjxcagm();\n}\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_izssdlgc();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403416,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_struct_15.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\nnamespace _A_namespace\n{\n\n\nvoid f_kpmbpzxh()\n{\n    twoIntsStruct * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = new twoIntsStruct;\n        data->intOne = 1;\n        data->intTwo = 2;\n        \n        delete data;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printStructLine(data);\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_kpmbpzxh();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403417,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_struct_15.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\n\n\nstatic void f_epqesxdq()\n{\n    char * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = (char *)malloc(100*sizeof(char));\n        if (data == NULL) {exit(-1);}\n        memset(data, 'A', 100-1);\n        data[100-1] = '\\0';\n        \n        free(data);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(8)\n    {\n    case 7:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        \n        \n        ; \n        break;\n    }\n}\n\n\nstatic void f_holyctth()\n{\n    char * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = (char *)malloc(100*sizeof(char));\n        if (data == NULL) {exit(-1);}\n        memset(data, 'A', 100-1);\n        data[100-1] = '\\0';\n        \n        free(data);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        \n        \n        ; \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_mnxrpucj()\n{\n    char * data;\n    \n    data = NULL;\n    switch(5)\n    {\n    case 6:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        data = (char *)malloc(100*sizeof(char));\n        if (data == NULL) {exit(-1);}\n        memset(data, 'A', 100-1);\n        data[100-1] = '\\0';\n        \n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printLine(data);\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_wtxnqvkc()\n{\n    char * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = (char *)malloc(100*sizeof(char));\n        if (data == NULL) {exit(-1);}\n        memset(data, 'A', 100-1);\n        data[100-1] = '\\0';\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printLine(data);\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\nvoid f_rpzttryh()\n{\n    f_epqesxdq();\n    f_holyctth();\n    f_mnxrpucj();\n    f_wtxnqvkc();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_rpzttryh();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403418,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__malloc_free_char_15.c",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nvoid f_wwgcmpae()\n{\n    char * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = (char *)malloc(100*sizeof(char));\n        if (data == NULL) {exit(-1);}\n        memset(data, 'A', 100-1);\n        data[100-1] = '\\0';\n        \n        free(data);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printLine(data);\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_wwgcmpae();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403419,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__malloc_free_char_15.c",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\n\n\nstatic void f_tptfflak()\n{\n    wchar_t * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = (wchar_t *)malloc(100*sizeof(wchar_t));\n        if (data == NULL) {exit(-1);}\n        wmemset(data, L'A', 100-1);\n        data[100-1] = L'\\0';\n        \n        free(data);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(8)\n    {\n    case 7:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        \n        \n        ; \n        break;\n    }\n}\n\n\nstatic void f_grfiznzc()\n{\n    wchar_t * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = (wchar_t *)malloc(100*sizeof(wchar_t));\n        if (data == NULL) {exit(-1);}\n        wmemset(data, L'A', 100-1);\n        data[100-1] = L'\\0';\n        \n        free(data);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        \n        \n        ; \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_gmnueqew()\n{\n    wchar_t * data;\n    \n    data = NULL;\n    switch(5)\n    {\n    case 6:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        data = (wchar_t *)malloc(100*sizeof(wchar_t));\n        if (data == NULL) {exit(-1);}\n        wmemset(data, L'A', 100-1);\n        data[100-1] = L'\\0';\n        \n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printWLine(data);\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_rarrklqk()\n{\n    wchar_t * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = (wchar_t *)malloc(100*sizeof(wchar_t));\n        if (data == NULL) {exit(-1);}\n        wmemset(data, L'A', 100-1);\n        data[100-1] = L'\\0';\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printWLine(data);\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\nvoid f_vxpnmomr()\n{\n    f_tptfflak();\n    f_grfiznzc();\n    f_gmnueqew();\n    f_rarrklqk();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_vxpnmomr();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403420,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__malloc_free_wchar_t_15.c",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nvoid f_knijgiup()\n{\n    wchar_t * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = (wchar_t *)malloc(100*sizeof(wchar_t));\n        if (data == NULL) {exit(-1);}\n        wmemset(data, L'A', 100-1);\n        data[100-1] = L'\\0';\n        \n        free(data);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printWLine(data);\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_knijgiup();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403421,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__malloc_free_wchar_t_15.c",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\nnamespace _A_namespace\n{\n\n\n\n\nstatic void f_wxnnjptf()\n{\n    wchar_t * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = new wchar_t;\n        *data = L'A';\n        \n        delete data;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(8)\n    {\n    case 7:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        \n        \n        ; \n        break;\n    }\n}\n\n\nstatic void f_klbdadqg()\n{\n    wchar_t * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = new wchar_t;\n        *data = L'A';\n        \n        delete data;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        \n        \n        ; \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_lewvhynx()\n{\n    wchar_t * data;\n    \n    data = NULL;\n    switch(5)\n    {\n    case 6:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        data = new wchar_t;\n        *data = L'A';\n        \n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printWcharLine(*data);\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_zoecgjuu()\n{\n    wchar_t * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = new wchar_t;\n        *data = L'A';\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printWcharLine(*data);\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\nvoid f_efnaulqy()\n{\n    f_wxnnjptf();\n    f_klbdadqg();\n    f_lewvhynx();\n    f_zoecgjuu();\n}\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_efnaulqy();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403422,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_wchar_t_15.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\nnamespace _A_namespace\n{\n\n\nvoid f_glazbvki()\n{\n    wchar_t * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = new wchar_t;\n        *data = L'A';\n        \n        delete data;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printWcharLine(*data);\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_glazbvki();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403423,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_wchar_t_15.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\nnamespace _A_namespace\n{\n\n\n\n\nstatic void f_yzsxpohn()\n{\n    char * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = new char;\n        *data = 'A';\n        \n        delete data;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(8)\n    {\n    case 7:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        \n        \n        ; \n        break;\n    }\n}\n\n\nstatic void f_rrvvzmxw()\n{\n    char * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = new char;\n        *data = 'A';\n        \n        delete data;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        \n        \n        ; \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_tqntqyfm()\n{\n    char * data;\n    \n    data = NULL;\n    switch(5)\n    {\n    case 6:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        data = new char;\n        *data = 'A';\n        \n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printHexCharLine(*data);\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_ehiwifit()\n{\n    char * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = new char;\n        *data = 'A';\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printHexCharLine(*data);\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\nvoid f_seikasxc()\n{\n    f_yzsxpohn();\n    f_rrvvzmxw();\n    f_tqntqyfm();\n    f_ehiwifit();\n}\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_seikasxc();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403424,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_char_15.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\nnamespace _A_namespace\n{\n\n\nvoid f_ezpxumue()\n{\n    char * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = new char;\n        *data = 'A';\n        \n        delete data;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printHexCharLine(*data);\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ezpxumue();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403425,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_char_15.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\nnamespace _A_namespace\n{\n\n\n\n\nstatic void f_laeyxlvm()\n{\n    int * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = new int;\n        *data = 5;\n        \n        delete data;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(8)\n    {\n    case 7:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        \n        \n        ; \n        break;\n    }\n}\n\n\nstatic void f_jomkdbmd()\n{\n    int * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = new int;\n        *data = 5;\n        \n        delete data;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        \n        \n        ; \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_wvpwdlah()\n{\n    int * data;\n    \n    data = NULL;\n    switch(5)\n    {\n    case 6:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        data = new int;\n        *data = 5;\n        \n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printIntLine(*data);\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_oxdqehsp()\n{\n    int * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = new int;\n        *data = 5;\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printIntLine(*data);\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\nvoid f_otfimtwb()\n{\n    f_laeyxlvm();\n    f_jomkdbmd();\n    f_wvpwdlah();\n    f_oxdqehsp();\n}\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_otfimtwb();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403426,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_int_15.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\nnamespace _A_namespace\n{\n\n\nvoid f_gxwojzik()\n{\n    int * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = new int;\n        *data = 5;\n        \n        delete data;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printIntLine(*data);\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_gxwojzik();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403427,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_int_15.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\nnamespace _A_namespace\n{\n\n\n\n\nstatic void f_qdrutrrg()\n{\n    long * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = new long;\n        *data = 5L;\n        \n        delete data;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(8)\n    {\n    case 7:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        \n        \n        ; \n        break;\n    }\n}\n\n\nstatic void f_jbfvvghl()\n{\n    long * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = new long;\n        *data = 5L;\n        \n        delete data;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        \n        \n        ; \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_ikulvtrk()\n{\n    long * data;\n    \n    data = NULL;\n    switch(5)\n    {\n    case 6:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        data = new long;\n        *data = 5L;\n        \n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printLongLine(*data);\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_uenqqevl()\n{\n    long * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = new long;\n        *data = 5L;\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printLongLine(*data);\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\nvoid f_ziduccwj()\n{\n    f_qdrutrrg();\n    f_jbfvvghl();\n    f_ikulvtrk();\n    f_uenqqevl();\n}\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ziduccwj();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403428,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_long_15.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\nnamespace _A_namespace\n{\n\n\nvoid f_jjphtmeo()\n{\n    long * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = new long;\n        *data = 5L;\n        \n        delete data;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printLongLine(*data);\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_jjphtmeo();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403429,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_long_15.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\nnamespace _A_namespace\n{\n\n\n\n\nstatic void f_atvhdtnn()\n{\n    int64_t * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = new int64_t;\n        *data = 5LL;\n        \n        delete data;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(8)\n    {\n    case 7:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        \n        \n        ; \n        break;\n    }\n}\n\n\nstatic void f_nmrbduki()\n{\n    int64_t * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = new int64_t;\n        *data = 5LL;\n        \n        delete data;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        \n        \n        ; \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_buvryxyv()\n{\n    int64_t * data;\n    \n    data = NULL;\n    switch(5)\n    {\n    case 6:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        data = new int64_t;\n        *data = 5LL;\n        \n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printLongLongLine(*data);\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_cnjbwpjs()\n{\n    int64_t * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = new int64_t;\n        *data = 5LL;\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printLongLongLine(*data);\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\nvoid f_ewzlbuzn()\n{\n    f_atvhdtnn();\n    f_nmrbduki();\n    f_buvryxyv();\n    f_cnjbwpjs();\n}\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ewzlbuzn();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403430,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_int64_t_15.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\nnamespace _A_namespace\n{\n\n\nvoid f_mewqxjfe()\n{\n    int64_t * data;\n    \n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = new int64_t;\n        *data = 5LL;\n        \n        delete data;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printLongLongLine(*data);\n        \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_mewqxjfe();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403431,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_int64_t_15.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticReturnsTrue()\n{\n    return 1;\n}\n\nstatic int staticReturnsFalse()\n{\n    return 0;\n}\n\nnamespace _A_namespace\n{\n\n\n\n\nstatic void f_cltgmhtl()\n{\n    twoIntsStruct * data;\n    \n    data = NULL;\n    if(staticReturnsTrue())\n    {\n        data = new twoIntsStruct[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n        delete [] data;\n    }\n    if(staticReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        \n        \n        ; \n    }\n}\n\n\nstatic void f_qyxezczm()\n{\n    twoIntsStruct * data;\n    \n    data = NULL;\n    if(staticReturnsTrue())\n    {\n        data = new twoIntsStruct[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n        delete [] data;\n    }\n    if(staticReturnsTrue())\n    {\n        \n        \n        \n        ; \n    }\n}\n\n\nstatic void f_hrcgivfv()\n{\n    twoIntsStruct * data;\n    \n    data = NULL;\n    if(staticReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        data = new twoIntsStruct[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n    }\n    if(staticReturnsTrue())\n    {\n        \n        printStructLine(&data[0]);\n        \n    }\n}\n\n\nstatic void f_vlustoig()\n{\n    twoIntsStruct * data;\n    \n    data = NULL;\n    if(staticReturnsTrue())\n    {\n        data = new twoIntsStruct[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n    }\n    if(staticReturnsTrue())\n    {\n        \n        printStructLine(&data[0]);\n        \n    }\n}\n\nvoid f_bkmcbccl()\n{\n    f_cltgmhtl();\n    f_qyxezczm();\n    f_hrcgivfv();\n    f_vlustoig();\n}\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_bkmcbccl();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403432,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_array_struct_08.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticReturnsTrue()\n{\n    return 1;\n}\n\nstatic int staticReturnsFalse()\n{\n    return 0;\n}\n\nnamespace _A_namespace\n{\n\n\nvoid f_adpifbct()\n{\n    twoIntsStruct * data;\n    \n    data = NULL;\n    if(staticReturnsTrue())\n    {\n        data = new twoIntsStruct[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n        delete [] data;\n    }\n    if(staticReturnsTrue())\n    {\n        \n        printStructLine(&data[0]);\n        \n    }\n}\n\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_adpifbct();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403433,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_array_struct_08.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticReturnsTrue()\n{\n    return 1;\n}\n\nstatic int staticReturnsFalse()\n{\n    return 0;\n}\n\nnamespace _A_namespace\n{\n\n\n\n\nstatic void f_vghysncd()\n{\n    TwoIntsClass * data;\n    \n    data = NULL;\n    if(staticReturnsTrue())\n    {\n        data = new TwoIntsClass[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n        delete [] data;\n    }\n    if(staticReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        \n        \n        ; \n    }\n}\n\n\nstatic void f_ffbtyget()\n{\n    TwoIntsClass * data;\n    \n    data = NULL;\n    if(staticReturnsTrue())\n    {\n        data = new TwoIntsClass[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n        delete [] data;\n    }\n    if(staticReturnsTrue())\n    {\n        \n        \n        \n        ; \n    }\n}\n\n\nstatic void f_ctwrycfi()\n{\n    TwoIntsClass * data;\n    \n    data = NULL;\n    if(staticReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        data = new TwoIntsClass[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n    }\n    if(staticReturnsTrue())\n    {\n        \n        printIntLine(data[0].intOne);\n        \n    }\n}\n\n\nstatic void f_cddxvdjp()\n{\n    TwoIntsClass * data;\n    \n    data = NULL;\n    if(staticReturnsTrue())\n    {\n        data = new TwoIntsClass[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n    }\n    if(staticReturnsTrue())\n    {\n        \n        printIntLine(data[0].intOne);\n        \n    }\n}\n\nvoid f_czcargyz()\n{\n    f_vghysncd();\n    f_ffbtyget();\n    f_ctwrycfi();\n    f_cddxvdjp();\n}\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_czcargyz();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403434,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_array_class_08.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticReturnsTrue()\n{\n    return 1;\n}\n\nstatic int staticReturnsFalse()\n{\n    return 0;\n}\n\nnamespace _A_namespace\n{\n\n\nvoid f_wsyavtkp()\n{\n    TwoIntsClass * data;\n    \n    data = NULL;\n    if(staticReturnsTrue())\n    {\n        data = new TwoIntsClass[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n        delete [] data;\n    }\n    if(staticReturnsTrue())\n    {\n        \n        printIntLine(data[0].intOne);\n        \n    }\n}\n\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_wsyavtkp();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403435,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_array_class_08.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticReturnsTrue()\n{\n    return 1;\n}\n\nstatic int staticReturnsFalse()\n{\n    return 0;\n}\n\n\n\n\nstatic void f_trjrtfnz()\n{\n    twoIntsStruct * data;\n    \n    data = NULL;\n    if(staticReturnsTrue())\n    {\n        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));\n        if (data == NULL) {exit(-1);}\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n        free(data);\n    }\n    if(staticReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        \n        \n        ; \n    }\n}\n\n\nstatic void f_tsvzedks()\n{\n    twoIntsStruct * data;\n    \n    data = NULL;\n    if(staticReturnsTrue())\n    {\n        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));\n        if (data == NULL) {exit(-1);}\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n        free(data);\n    }\n    if(staticReturnsTrue())\n    {\n        \n        \n        \n        ; \n    }\n}\n\n\nstatic void f_xjhnbwtv()\n{\n    twoIntsStruct * data;\n    \n    data = NULL;\n    if(staticReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));\n        if (data == NULL) {exit(-1);}\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n    }\n    if(staticReturnsTrue())\n    {\n        \n        printStructLine(&data[0]);\n        \n    }\n}\n\n\nstatic void f_jnirwuun()\n{\n    twoIntsStruct * data;\n    \n    data = NULL;\n    if(staticReturnsTrue())\n    {\n        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));\n        if (data == NULL) {exit(-1);}\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n    }\n    if(staticReturnsTrue())\n    {\n        \n        printStructLine(&data[0]);\n        \n    }\n}\n\nvoid f_jksjmbky()\n{\n    f_trjrtfnz();\n    f_tsvzedks();\n    f_xjhnbwtv();\n    f_jnirwuun();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_jksjmbky();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403436,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__malloc_free_struct_08.c",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticReturnsTrue()\n{\n    return 1;\n}\n\nstatic int staticReturnsFalse()\n{\n    return 0;\n}\n\n\nvoid f_csosklqh()\n{\n    twoIntsStruct * data;\n    \n    data = NULL;\n    if(staticReturnsTrue())\n    {\n        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));\n        if (data == NULL) {exit(-1);}\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n        free(data);\n    }\n    if(staticReturnsTrue())\n    {\n        \n        printStructLine(&data[0]);\n        \n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_csosklqh();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403437,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__malloc_free_struct_08.c",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticReturnsTrue()\n{\n    return 1;\n}\n\nstatic int staticReturnsFalse()\n{\n    return 0;\n}\n\nnamespace _A_namespace\n{\n\n\n\n\nstatic void f_scnsqlcy()\n{\n    int * data;\n    \n    data = NULL;\n    if(staticReturnsTrue())\n    {\n        data = new int[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5;\n            }\n        }\n        \n        delete [] data;\n    }\n    if(staticReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        \n        \n        ; \n    }\n}\n\n\nstatic void f_wafsfkqy()\n{\n    int * data;\n    \n    data = NULL;\n    if(staticReturnsTrue())\n    {\n        data = new int[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5;\n            }\n        }\n        \n        delete [] data;\n    }\n    if(staticReturnsTrue())\n    {\n        \n        \n        \n        ; \n    }\n}\n\n\nstatic void f_cjuufiyt()\n{\n    int * data;\n    \n    data = NULL;\n    if(staticReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        data = new int[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5;\n            }\n        }\n        \n    }\n    if(staticReturnsTrue())\n    {\n        \n        printIntLine(data[0]);\n        \n    }\n}\n\n\nstatic void f_easwjeoh()\n{\n    int * data;\n    \n    data = NULL;\n    if(staticReturnsTrue())\n    {\n        data = new int[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5;\n            }\n        }\n        \n    }\n    if(staticReturnsTrue())\n    {\n        \n        printIntLine(data[0]);\n        \n    }\n}\n\nvoid f_meljoxrn()\n{\n    f_scnsqlcy();\n    f_wafsfkqy();\n    f_cjuufiyt();\n    f_easwjeoh();\n}\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_meljoxrn();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403438,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_array_int_08.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticReturnsTrue()\n{\n    return 1;\n}\n\nstatic int staticReturnsFalse()\n{\n    return 0;\n}\n\nnamespace _A_namespace\n{\n\n\nvoid f_lcacqhlx()\n{\n    int * data;\n    \n    data = NULL;\n    if(staticReturnsTrue())\n    {\n        data = new int[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5;\n            }\n        }\n        \n        delete [] data;\n    }\n    if(staticReturnsTrue())\n    {\n        \n        printIntLine(data[0]);\n        \n    }\n}\n\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_lcacqhlx();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403439,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_array_int_08.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticReturnsTrue()\n{\n    return 1;\n}\n\nstatic int staticReturnsFalse()\n{\n    return 0;\n}\n\nnamespace _A_namespace\n{\n\n\n\n\nstatic void f_msjphzsj()\n{\n    int64_t * data;\n    \n    data = NULL;\n    if(staticReturnsTrue())\n    {\n        data = new int64_t[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5LL;\n            }\n        }\n        \n        delete [] data;\n    }\n    if(staticReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        \n        \n        ; \n    }\n}\n\n\nstatic void f_hiaelzxp()\n{\n    int64_t * data;\n    \n    data = NULL;\n    if(staticReturnsTrue())\n    {\n        data = new int64_t[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5LL;\n            }\n        }\n        \n        delete [] data;\n    }\n    if(staticReturnsTrue())\n    {\n        \n        \n        \n        ; \n    }\n}\n\n\nstatic void f_oxutguor()\n{\n    int64_t * data;\n    \n    data = NULL;\n    if(staticReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        data = new int64_t[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5LL;\n            }\n        }\n        \n    }\n    if(staticReturnsTrue())\n    {\n        \n        printLongLongLine(data[0]);\n        \n    }\n}\n\n\nstatic void f_vxvvqndz()\n{\n    int64_t * data;\n    \n    data = NULL;\n    if(staticReturnsTrue())\n    {\n        data = new int64_t[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5LL;\n            }\n        }\n        \n    }\n    if(staticReturnsTrue())\n    {\n        \n        printLongLongLine(data[0]);\n        \n    }\n}\n\nvoid f_gcuwbwos()\n{\n    f_msjphzsj();\n    f_hiaelzxp();\n    f_oxutguor();\n    f_vxvvqndz();\n}\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_gcuwbwos();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403440,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_array_int64_t_08.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticReturnsTrue()\n{\n    return 1;\n}\n\nstatic int staticReturnsFalse()\n{\n    return 0;\n}\n\nnamespace _A_namespace\n{\n\n\nvoid f_akwloeaz()\n{\n    int64_t * data;\n    \n    data = NULL;\n    if(staticReturnsTrue())\n    {\n        data = new int64_t[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5LL;\n            }\n        }\n        \n        delete [] data;\n    }\n    if(staticReturnsTrue())\n    {\n        \n        printLongLongLine(data[0]);\n        \n    }\n}\n\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_akwloeaz();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403441,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_array_int64_t_08.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticReturnsTrue()\n{\n    return 1;\n}\n\nstatic int staticReturnsFalse()\n{\n    return 0;\n}\n\nnamespace _A_namespace\n{\n\n\n\n\nstatic void f_euunzcwo()\n{\n    long * data;\n    \n    data = NULL;\n    if(staticReturnsTrue())\n    {\n        data = new long[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5L;\n            }\n        }\n        \n        delete [] data;\n    }\n    if(staticReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        \n        \n        ; \n    }\n}\n\n\nstatic void f_epuaetew()\n{\n    long * data;\n    \n    data = NULL;\n    if(staticReturnsTrue())\n    {\n        data = new long[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5L;\n            }\n        }\n        \n        delete [] data;\n    }\n    if(staticReturnsTrue())\n    {\n        \n        \n        \n        ; \n    }\n}\n\n\nstatic void f_mepeetrc()\n{\n    long * data;\n    \n    data = NULL;\n    if(staticReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        data = new long[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5L;\n            }\n        }\n        \n    }\n    if(staticReturnsTrue())\n    {\n        \n        printLongLine(data[0]);\n        \n    }\n}\n\n\nstatic void f_thymfczx()\n{\n    long * data;\n    \n    data = NULL;\n    if(staticReturnsTrue())\n    {\n        data = new long[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5L;\n            }\n        }\n        \n    }\n    if(staticReturnsTrue())\n    {\n        \n        printLongLine(data[0]);\n        \n    }\n}\n\nvoid f_ojiubaav()\n{\n    f_euunzcwo();\n    f_epuaetew();\n    f_mepeetrc();\n    f_thymfczx();\n}\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ojiubaav();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403442,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_array_long_08.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticReturnsTrue()\n{\n    return 1;\n}\n\nstatic int staticReturnsFalse()\n{\n    return 0;\n}\n\nnamespace _A_namespace\n{\n\n\nvoid f_mkvitmdw()\n{\n    long * data;\n    \n    data = NULL;\n    if(staticReturnsTrue())\n    {\n        data = new long[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5L;\n            }\n        }\n        \n        delete [] data;\n    }\n    if(staticReturnsTrue())\n    {\n        \n        printLongLine(data[0]);\n        \n    }\n}\n\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_mkvitmdw();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403443,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_array_long_08.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticTrue = 1; \nstatic int staticFalse = 0; \n\nnamespace _A_namespace\n{\n\n\n\n\nstatic void f_yyqmsvyr()\n{\n    TwoIntsClass * data;\n    \n    data = NULL;\n    if(staticTrue)\n    {\n        data = new TwoIntsClass[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n        delete [] data;\n    }\n    if(staticFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        \n        \n        ; \n    }\n}\n\n\nstatic void f_kyxovsju()\n{\n    TwoIntsClass * data;\n    \n    data = NULL;\n    if(staticTrue)\n    {\n        data = new TwoIntsClass[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n        delete [] data;\n    }\n    if(staticTrue)\n    {\n        \n        \n        \n        ; \n    }\n}\n\n\nstatic void f_mgwomqcz()\n{\n    TwoIntsClass * data;\n    \n    data = NULL;\n    if(staticFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        data = new TwoIntsClass[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n    }\n    if(staticTrue)\n    {\n        \n        printIntLine(data[0].intOne);\n        \n    }\n}\n\n\nstatic void f_inlzarin()\n{\n    TwoIntsClass * data;\n    \n    data = NULL;\n    if(staticTrue)\n    {\n        data = new TwoIntsClass[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n    }\n    if(staticTrue)\n    {\n        \n        printIntLine(data[0].intOne);\n        \n    }\n}\n\nvoid f_nanytxzd()\n{\n    f_yyqmsvyr();\n    f_kyxovsju();\n    f_mgwomqcz();\n    f_inlzarin();\n}\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_nanytxzd();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403444,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_array_class_05.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticTrue = 1; \nstatic int staticFalse = 0; \n\nnamespace _A_namespace\n{\n\n\nvoid f_onrozacj()\n{\n    TwoIntsClass * data;\n    \n    data = NULL;\n    if(staticTrue)\n    {\n        data = new TwoIntsClass[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n        delete [] data;\n    }\n    if(staticTrue)\n    {\n        \n        printIntLine(data[0].intOne);\n        \n    }\n}\n\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_onrozacj();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403445,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_array_class_05.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic const int STATIC_CONST_TRUE = 1; \nstatic const int STATIC_CONST_FALSE = 0; \n\nnamespace _A_namespace\n{\n\n\n\n\nstatic void f_cxgjlzxp()\n{\n    TwoIntsClass * data;\n    \n    data = NULL;\n    if(STATIC_CONST_TRUE)\n    {\n        data = new TwoIntsClass[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n        delete [] data;\n    }\n    if(STATIC_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        \n        \n        ; \n    }\n}\n\n\nstatic void f_jdkhmcyp()\n{\n    TwoIntsClass * data;\n    \n    data = NULL;\n    if(STATIC_CONST_TRUE)\n    {\n        data = new TwoIntsClass[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n        delete [] data;\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        \n        \n        \n        ; \n    }\n}\n\n\nstatic void f_afoutugq()\n{\n    TwoIntsClass * data;\n    \n    data = NULL;\n    if(STATIC_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        data = new TwoIntsClass[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n    }\n    if(STATIC_CONST_TRUE)\n    {\n        \n        printIntLine(data[0].intOne);\n        \n    }\n}\n\n\nstatic void f_jenirqyv()\n{\n    TwoIntsClass * data;\n    \n    data = NULL;\n    if(STATIC_CONST_TRUE)\n    {\n        data = new TwoIntsClass[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n    }\n    if(STATIC_CONST_TRUE)\n    {\n        \n        printIntLine(data[0].intOne);\n        \n    }\n}\n\nvoid f_vkjxivzm()\n{\n    f_cxgjlzxp();\n    f_jdkhmcyp();\n    f_afoutugq();\n    f_jenirqyv();\n}\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_vkjxivzm();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403446,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_array_class_04.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic const int STATIC_CONST_TRUE = 1; \nstatic const int STATIC_CONST_FALSE = 0; \n\nnamespace _A_namespace\n{\n\n\nvoid f_fbxxbfxo()\n{\n    TwoIntsClass * data;\n    \n    data = NULL;\n    if(STATIC_CONST_TRUE)\n    {\n        data = new TwoIntsClass[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n        delete [] data;\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        \n        printIntLine(data[0].intOne);\n        \n    }\n}\n\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_fbxxbfxo();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403447,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_array_class_04.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticReturnsTrue()\n{\n    return 1;\n}\n\nstatic int staticReturnsFalse()\n{\n    return 0;\n}\n\n\n\n\nstatic void f_fclkgyjo()\n{\n    int64_t * data;\n    \n    data = NULL;\n    if(staticReturnsTrue())\n    {\n        data = (int64_t *)malloc(100*sizeof(int64_t));\n        if (data == NULL) {exit(-1);}\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5LL;\n            }\n        }\n        \n        free(data);\n    }\n    if(staticReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        \n        \n        ; \n    }\n}\n\n\nstatic void f_fepvfflr()\n{\n    int64_t * data;\n    \n    data = NULL;\n    if(staticReturnsTrue())\n    {\n        data = (int64_t *)malloc(100*sizeof(int64_t));\n        if (data == NULL) {exit(-1);}\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5LL;\n            }\n        }\n        \n        free(data);\n    }\n    if(staticReturnsTrue())\n    {\n        \n        \n        \n        ; \n    }\n}\n\n\nstatic void f_mzxtvguw()\n{\n    int64_t * data;\n    \n    data = NULL;\n    if(staticReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        data = (int64_t *)malloc(100*sizeof(int64_t));\n        if (data == NULL) {exit(-1);}\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5LL;\n            }\n        }\n        \n    }\n    if(staticReturnsTrue())\n    {\n        \n        printLongLongLine(data[0]);\n        \n    }\n}\n\n\nstatic void f_griqnqrx()\n{\n    int64_t * data;\n    \n    data = NULL;\n    if(staticReturnsTrue())\n    {\n        data = (int64_t *)malloc(100*sizeof(int64_t));\n        if (data == NULL) {exit(-1);}\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5LL;\n            }\n        }\n        \n    }\n    if(staticReturnsTrue())\n    {\n        \n        printLongLongLine(data[0]);\n        \n    }\n}\n\nvoid f_osrubzyn()\n{\n    f_fclkgyjo();\n    f_fepvfflr();\n    f_mzxtvguw();\n    f_griqnqrx();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_osrubzyn();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403448,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__malloc_free_int64_t_08.c",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticReturnsTrue()\n{\n    return 1;\n}\n\nstatic int staticReturnsFalse()\n{\n    return 0;\n}\n\n\nvoid f_nnvciqru()\n{\n    int64_t * data;\n    \n    data = NULL;\n    if(staticReturnsTrue())\n    {\n        data = (int64_t *)malloc(100*sizeof(int64_t));\n        if (data == NULL) {exit(-1);}\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5LL;\n            }\n        }\n        \n        free(data);\n    }\n    if(staticReturnsTrue())\n    {\n        \n        printLongLongLine(data[0]);\n        \n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_nnvciqru();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403449,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__malloc_free_int64_t_08.c",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic const int STATIC_CONST_TRUE = 1; \nstatic const int STATIC_CONST_FALSE = 0; \n\nnamespace _A_namespace\n{\n\n\n\n\nstatic void f_zexdyepo()\n{\n    twoIntsStruct * data;\n    \n    data = NULL;\n    if(STATIC_CONST_TRUE)\n    {\n        data = new twoIntsStruct[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n        delete [] data;\n    }\n    if(STATIC_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        \n        \n        ; \n    }\n}\n\n\nstatic void f_hjijpyfe()\n{\n    twoIntsStruct * data;\n    \n    data = NULL;\n    if(STATIC_CONST_TRUE)\n    {\n        data = new twoIntsStruct[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n        delete [] data;\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        \n        \n        \n        ; \n    }\n}\n\n\nstatic void f_liqulyhx()\n{\n    twoIntsStruct * data;\n    \n    data = NULL;\n    if(STATIC_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        data = new twoIntsStruct[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n    }\n    if(STATIC_CONST_TRUE)\n    {\n        \n        printStructLine(&data[0]);\n        \n    }\n}\n\n\nstatic void f_mrahophe()\n{\n    twoIntsStruct * data;\n    \n    data = NULL;\n    if(STATIC_CONST_TRUE)\n    {\n        data = new twoIntsStruct[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n    }\n    if(STATIC_CONST_TRUE)\n    {\n        \n        printStructLine(&data[0]);\n        \n    }\n}\n\nvoid f_ossopmrl()\n{\n    f_zexdyepo();\n    f_hjijpyfe();\n    f_liqulyhx();\n    f_mrahophe();\n}\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ossopmrl();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403450,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_array_struct_04.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic const int STATIC_CONST_TRUE = 1; \nstatic const int STATIC_CONST_FALSE = 0; \n\nnamespace _A_namespace\n{\n\n\nvoid f_mycbziyz()\n{\n    twoIntsStruct * data;\n    \n    data = NULL;\n    if(STATIC_CONST_TRUE)\n    {\n        data = new twoIntsStruct[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n        delete [] data;\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        \n        printStructLine(&data[0]);\n        \n    }\n}\n\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_mycbziyz();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403451,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_array_struct_04.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticReturnsTrue()\n{\n    return 1;\n}\n\nstatic int staticReturnsFalse()\n{\n    return 0;\n}\n\n\n\n\nstatic void f_svjrodmp()\n{\n    int * data;\n    \n    data = NULL;\n    if(staticReturnsTrue())\n    {\n        data = (int *)malloc(100*sizeof(int));\n        if (data == NULL) {exit(-1);}\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5;\n            }\n        }\n        \n        free(data);\n    }\n    if(staticReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        \n        \n        ; \n    }\n}\n\n\nstatic void f_ifxogluf()\n{\n    int * data;\n    \n    data = NULL;\n    if(staticReturnsTrue())\n    {\n        data = (int *)malloc(100*sizeof(int));\n        if (data == NULL) {exit(-1);}\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5;\n            }\n        }\n        \n        free(data);\n    }\n    if(staticReturnsTrue())\n    {\n        \n        \n        \n        ; \n    }\n}\n\n\nstatic void f_dkzbdfwr()\n{\n    int * data;\n    \n    data = NULL;\n    if(staticReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        data = (int *)malloc(100*sizeof(int));\n        if (data == NULL) {exit(-1);}\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5;\n            }\n        }\n        \n    }\n    if(staticReturnsTrue())\n    {\n        \n        printIntLine(data[0]);\n        \n    }\n}\n\n\nstatic void f_xkaxpdmk()\n{\n    int * data;\n    \n    data = NULL;\n    if(staticReturnsTrue())\n    {\n        data = (int *)malloc(100*sizeof(int));\n        if (data == NULL) {exit(-1);}\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5;\n            }\n        }\n        \n    }\n    if(staticReturnsTrue())\n    {\n        \n        printIntLine(data[0]);\n        \n    }\n}\n\nvoid f_tgbshjyv()\n{\n    f_svjrodmp();\n    f_ifxogluf();\n    f_dkzbdfwr();\n    f_xkaxpdmk();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_tgbshjyv();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403452,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__malloc_free_int_08.c",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticReturnsTrue()\n{\n    return 1;\n}\n\nstatic int staticReturnsFalse()\n{\n    return 0;\n}\n\n\nvoid f_hesopqwg()\n{\n    int * data;\n    \n    data = NULL;\n    if(staticReturnsTrue())\n    {\n        data = (int *)malloc(100*sizeof(int));\n        if (data == NULL) {exit(-1);}\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5;\n            }\n        }\n        \n        free(data);\n    }\n    if(staticReturnsTrue())\n    {\n        \n        printIntLine(data[0]);\n        \n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_hesopqwg();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403453,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__malloc_free_int_08.c",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticTrue = 1; \nstatic int staticFalse = 0; \n\nnamespace _A_namespace\n{\n\n\n\n\nstatic void f_rryqiwou()\n{\n    twoIntsStruct * data;\n    \n    data = NULL;\n    if(staticTrue)\n    {\n        data = new twoIntsStruct[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n        delete [] data;\n    }\n    if(staticFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        \n        \n        ; \n    }\n}\n\n\nstatic void f_fwldusrj()\n{\n    twoIntsStruct * data;\n    \n    data = NULL;\n    if(staticTrue)\n    {\n        data = new twoIntsStruct[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n        delete [] data;\n    }\n    if(staticTrue)\n    {\n        \n        \n        \n        ; \n    }\n}\n\n\nstatic void f_lnilkmxd()\n{\n    twoIntsStruct * data;\n    \n    data = NULL;\n    if(staticFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        data = new twoIntsStruct[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n    }\n    if(staticTrue)\n    {\n        \n        printStructLine(&data[0]);\n        \n    }\n}\n\n\nstatic void f_zdrtxkdg()\n{\n    twoIntsStruct * data;\n    \n    data = NULL;\n    if(staticTrue)\n    {\n        data = new twoIntsStruct[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n    }\n    if(staticTrue)\n    {\n        \n        printStructLine(&data[0]);\n        \n    }\n}\n\nvoid f_pixduxtn()\n{\n    f_rryqiwou();\n    f_fwldusrj();\n    f_lnilkmxd();\n    f_zdrtxkdg();\n}\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_pixduxtn();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403454,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_array_struct_05.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticTrue = 1; \nstatic int staticFalse = 0; \n\nnamespace _A_namespace\n{\n\n\nvoid f_ksnoakss()\n{\n    twoIntsStruct * data;\n    \n    data = NULL;\n    if(staticTrue)\n    {\n        data = new twoIntsStruct[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n        delete [] data;\n    }\n    if(staticTrue)\n    {\n        \n        printStructLine(&data[0]);\n        \n    }\n}\n\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ksnoakss();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403455,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_array_struct_05.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticReturnsTrue()\n{\n    return 1;\n}\n\nstatic int staticReturnsFalse()\n{\n    return 0;\n}\n\n\n\n\nstatic void f_aufvpjmf()\n{\n    long * data;\n    \n    data = NULL;\n    if(staticReturnsTrue())\n    {\n        data = (long *)malloc(100*sizeof(long));\n        if (data == NULL) {exit(-1);}\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5L;\n            }\n        }\n        \n        free(data);\n    }\n    if(staticReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        \n        \n        ; \n    }\n}\n\n\nstatic void f_eftskybc()\n{\n    long * data;\n    \n    data = NULL;\n    if(staticReturnsTrue())\n    {\n        data = (long *)malloc(100*sizeof(long));\n        if (data == NULL) {exit(-1);}\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5L;\n            }\n        }\n        \n        free(data);\n    }\n    if(staticReturnsTrue())\n    {\n        \n        \n        \n        ; \n    }\n}\n\n\nstatic void f_uihkgrhh()\n{\n    long * data;\n    \n    data = NULL;\n    if(staticReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        data = (long *)malloc(100*sizeof(long));\n        if (data == NULL) {exit(-1);}\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5L;\n            }\n        }\n        \n    }\n    if(staticReturnsTrue())\n    {\n        \n        printLongLine(data[0]);\n        \n    }\n}\n\n\nstatic void f_bafjropl()\n{\n    long * data;\n    \n    data = NULL;\n    if(staticReturnsTrue())\n    {\n        data = (long *)malloc(100*sizeof(long));\n        if (data == NULL) {exit(-1);}\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5L;\n            }\n        }\n        \n    }\n    if(staticReturnsTrue())\n    {\n        \n        printLongLine(data[0]);\n        \n    }\n}\n\nvoid f_pnkbckly()\n{\n    f_aufvpjmf();\n    f_eftskybc();\n    f_uihkgrhh();\n    f_bafjropl();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_pnkbckly();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403456,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__malloc_free_long_08.c",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticReturnsTrue()\n{\n    return 1;\n}\n\nstatic int staticReturnsFalse()\n{\n    return 0;\n}\n\n\nvoid f_uruoqbvb()\n{\n    long * data;\n    \n    data = NULL;\n    if(staticReturnsTrue())\n    {\n        data = (long *)malloc(100*sizeof(long));\n        if (data == NULL) {exit(-1);}\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5L;\n            }\n        }\n        \n        free(data);\n    }\n    if(staticReturnsTrue())\n    {\n        \n        printLongLine(data[0]);\n        \n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_uruoqbvb();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403457,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__malloc_free_long_08.c",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticFive = 5;\n\nnamespace _A_namespace\n{\n\n\n\n\nstatic void f_pneyorhn()\n{\n    TwoIntsClass * data;\n    \n    data = NULL;\n    if(staticFive==5)\n    {\n        data = new TwoIntsClass[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n        delete [] data;\n    }\n    if(staticFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        \n        \n        ; \n    }\n}\n\n\nstatic void f_tjoogbgk()\n{\n    TwoIntsClass * data;\n    \n    data = NULL;\n    if(staticFive==5)\n    {\n        data = new TwoIntsClass[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n        delete [] data;\n    }\n    if(staticFive==5)\n    {\n        \n        \n        \n        ; \n    }\n}\n\n\nstatic void f_iwutnriu()\n{\n    TwoIntsClass * data;\n    \n    data = NULL;\n    if(staticFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        data = new TwoIntsClass[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n    }\n    if(staticFive==5)\n    {\n        \n        printIntLine(data[0].intOne);\n        \n    }\n}\n\n\nstatic void f_fkolinqo()\n{\n    TwoIntsClass * data;\n    \n    data = NULL;\n    if(staticFive==5)\n    {\n        data = new TwoIntsClass[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n    }\n    if(staticFive==5)\n    {\n        \n        printIntLine(data[0].intOne);\n        \n    }\n}\n\nvoid f_wjiswzlu()\n{\n    f_pneyorhn();\n    f_tjoogbgk();\n    f_iwutnriu();\n    f_fkolinqo();\n}\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_wjiswzlu();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403458,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_array_class_07.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticFive = 5;\n\nnamespace _A_namespace\n{\n\n\nvoid f_vodvwakj()\n{\n    TwoIntsClass * data;\n    \n    data = NULL;\n    if(staticFive==5)\n    {\n        data = new TwoIntsClass[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n        delete [] data;\n    }\n    if(staticFive==5)\n    {\n        \n        printIntLine(data[0].intOne);\n        \n    }\n}\n\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_vodvwakj();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403459,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_array_class_07.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticFive = 5;\n\nnamespace _A_namespace\n{\n\n\n\n\nstatic void f_xuikziwl()\n{\n    twoIntsStruct * data;\n    \n    data = NULL;\n    if(staticFive==5)\n    {\n        data = new twoIntsStruct[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n        delete [] data;\n    }\n    if(staticFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        \n        \n        ; \n    }\n}\n\n\nstatic void f_jpndzpuw()\n{\n    twoIntsStruct * data;\n    \n    data = NULL;\n    if(staticFive==5)\n    {\n        data = new twoIntsStruct[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n        delete [] data;\n    }\n    if(staticFive==5)\n    {\n        \n        \n        \n        ; \n    }\n}\n\n\nstatic void f_guvyjxkd()\n{\n    twoIntsStruct * data;\n    \n    data = NULL;\n    if(staticFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        data = new twoIntsStruct[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n    }\n    if(staticFive==5)\n    {\n        \n        printStructLine(&data[0]);\n        \n    }\n}\n\n\nstatic void f_gsjyhtgw()\n{\n    twoIntsStruct * data;\n    \n    data = NULL;\n    if(staticFive==5)\n    {\n        data = new twoIntsStruct[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n    }\n    if(staticFive==5)\n    {\n        \n        printStructLine(&data[0]);\n        \n    }\n}\n\nvoid f_nyivhvep()\n{\n    f_xuikziwl();\n    f_jpndzpuw();\n    f_guvyjxkd();\n    f_gsjyhtgw();\n}\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_nyivhvep();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403460,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_array_struct_07.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticFive = 5;\n\nnamespace _A_namespace\n{\n\n\nvoid f_xxhdyopr()\n{\n    twoIntsStruct * data;\n    \n    data = NULL;\n    if(staticFive==5)\n    {\n        data = new twoIntsStruct[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n        delete [] data;\n    }\n    if(staticFive==5)\n    {\n        \n        printStructLine(&data[0]);\n        \n    }\n}\n\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_xxhdyopr();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403461,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_array_struct_07.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic const int STATIC_CONST_FIVE = 5;\n\nnamespace _A_namespace\n{\n\n\n\n\nstatic void f_fnpahhrh()\n{\n    TwoIntsClass * data;\n    \n    data = NULL;\n    if(STATIC_CONST_FIVE==5)\n    {\n        data = new TwoIntsClass[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n        delete [] data;\n    }\n    if(STATIC_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        \n        \n        ; \n    }\n}\n\n\nstatic void f_yuohctdv()\n{\n    TwoIntsClass * data;\n    \n    data = NULL;\n    if(STATIC_CONST_FIVE==5)\n    {\n        data = new TwoIntsClass[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n        delete [] data;\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        \n        \n        ; \n    }\n}\n\n\nstatic void f_crutragl()\n{\n    TwoIntsClass * data;\n    \n    data = NULL;\n    if(STATIC_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        data = new TwoIntsClass[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        printIntLine(data[0].intOne);\n        \n    }\n}\n\n\nstatic void f_zuhygybi()\n{\n    TwoIntsClass * data;\n    \n    data = NULL;\n    if(STATIC_CONST_FIVE==5)\n    {\n        data = new TwoIntsClass[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        printIntLine(data[0].intOne);\n        \n    }\n}\n\nvoid f_qgfcirmd()\n{\n    f_fnpahhrh();\n    f_yuohctdv();\n    f_crutragl();\n    f_zuhygybi();\n}\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_qgfcirmd();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403462,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_array_class_06.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic const int STATIC_CONST_FIVE = 5;\n\nnamespace _A_namespace\n{\n\n\nvoid f_nsokaobm()\n{\n    TwoIntsClass * data;\n    \n    data = NULL;\n    if(STATIC_CONST_FIVE==5)\n    {\n        data = new TwoIntsClass[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n        delete [] data;\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        printIntLine(data[0].intOne);\n        \n    }\n}\n\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_nsokaobm();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403463,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_array_class_06.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic const int STATIC_CONST_FIVE = 5;\n\nnamespace _A_namespace\n{\n\n\n\n\nstatic void f_uwvdcrsx()\n{\n    twoIntsStruct * data;\n    \n    data = NULL;\n    if(STATIC_CONST_FIVE==5)\n    {\n        data = new twoIntsStruct[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n        delete [] data;\n    }\n    if(STATIC_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        \n        \n        ; \n    }\n}\n\n\nstatic void f_uzfceuwl()\n{\n    twoIntsStruct * data;\n    \n    data = NULL;\n    if(STATIC_CONST_FIVE==5)\n    {\n        data = new twoIntsStruct[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n        delete [] data;\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        \n        \n        ; \n    }\n}\n\n\nstatic void f_nnecywwo()\n{\n    twoIntsStruct * data;\n    \n    data = NULL;\n    if(STATIC_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        data = new twoIntsStruct[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        printStructLine(&data[0]);\n        \n    }\n}\n\n\nstatic void f_rvumsxtr()\n{\n    twoIntsStruct * data;\n    \n    data = NULL;\n    if(STATIC_CONST_FIVE==5)\n    {\n        data = new twoIntsStruct[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        printStructLine(&data[0]);\n        \n    }\n}\n\nvoid f_uceeqlhp()\n{\n    f_uwvdcrsx();\n    f_uzfceuwl();\n    f_nnecywwo();\n    f_rvumsxtr();\n}\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_uceeqlhp();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403464,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_array_struct_06.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic const int STATIC_CONST_FIVE = 5;\n\nnamespace _A_namespace\n{\n\n\nvoid f_hivwqlyz()\n{\n    twoIntsStruct * data;\n    \n    data = NULL;\n    if(STATIC_CONST_FIVE==5)\n    {\n        data = new twoIntsStruct[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n        delete [] data;\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        printStructLine(&data[0]);\n        \n    }\n}\n\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_hivwqlyz();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403465,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_array_struct_06.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic const int STATIC_CONST_TRUE = 1; \nstatic const int STATIC_CONST_FALSE = 0; \n\n\n\n\nstatic void f_rgaqtzah()\n{\n    twoIntsStruct * data;\n    \n    data = NULL;\n    if(STATIC_CONST_TRUE)\n    {\n        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));\n        if (data == NULL) {exit(-1);}\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n        free(data);\n    }\n    if(STATIC_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        \n        \n        ; \n    }\n}\n\n\nstatic void f_jtfoohgy()\n{\n    twoIntsStruct * data;\n    \n    data = NULL;\n    if(STATIC_CONST_TRUE)\n    {\n        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));\n        if (data == NULL) {exit(-1);}\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n        free(data);\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        \n        \n        \n        ; \n    }\n}\n\n\nstatic void f_nsdllswo()\n{\n    twoIntsStruct * data;\n    \n    data = NULL;\n    if(STATIC_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));\n        if (data == NULL) {exit(-1);}\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n    }\n    if(STATIC_CONST_TRUE)\n    {\n        \n        printStructLine(&data[0]);\n        \n    }\n}\n\n\nstatic void f_rcnnrlyj()\n{\n    twoIntsStruct * data;\n    \n    data = NULL;\n    if(STATIC_CONST_TRUE)\n    {\n        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));\n        if (data == NULL) {exit(-1);}\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n    }\n    if(STATIC_CONST_TRUE)\n    {\n        \n        printStructLine(&data[0]);\n        \n    }\n}\n\nvoid f_jaulvufp()\n{\n    f_rgaqtzah();\n    f_jtfoohgy();\n    f_nsdllswo();\n    f_rcnnrlyj();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_jaulvufp();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403466,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__malloc_free_struct_04.c",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic const int STATIC_CONST_TRUE = 1; \nstatic const int STATIC_CONST_FALSE = 0; \n\n\nvoid f_ocfqlrph()\n{\n    twoIntsStruct * data;\n    \n    data = NULL;\n    if(STATIC_CONST_TRUE)\n    {\n        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));\n        if (data == NULL) {exit(-1);}\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n        free(data);\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        \n        printStructLine(&data[0]);\n        \n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ocfqlrph();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403467,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__malloc_free_struct_04.c",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticTrue = 1; \nstatic int staticFalse = 0; \n\n\n\n\nstatic void f_bewebopk()\n{\n    twoIntsStruct * data;\n    \n    data = NULL;\n    if(staticTrue)\n    {\n        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));\n        if (data == NULL) {exit(-1);}\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n        free(data);\n    }\n    if(staticFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        \n        \n        ; \n    }\n}\n\n\nstatic void f_zrjywfhn()\n{\n    twoIntsStruct * data;\n    \n    data = NULL;\n    if(staticTrue)\n    {\n        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));\n        if (data == NULL) {exit(-1);}\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n        free(data);\n    }\n    if(staticTrue)\n    {\n        \n        \n        \n        ; \n    }\n}\n\n\nstatic void f_ldbmgdwa()\n{\n    twoIntsStruct * data;\n    \n    data = NULL;\n    if(staticFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));\n        if (data == NULL) {exit(-1);}\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n    }\n    if(staticTrue)\n    {\n        \n        printStructLine(&data[0]);\n        \n    }\n}\n\n\nstatic void f_caziltxg()\n{\n    twoIntsStruct * data;\n    \n    data = NULL;\n    if(staticTrue)\n    {\n        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));\n        if (data == NULL) {exit(-1);}\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n    }\n    if(staticTrue)\n    {\n        \n        printStructLine(&data[0]);\n        \n    }\n}\n\nvoid f_kbfrjrcr()\n{\n    f_bewebopk();\n    f_zrjywfhn();\n    f_ldbmgdwa();\n    f_caziltxg();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_kbfrjrcr();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403468,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__malloc_free_struct_05.c",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticTrue = 1; \nstatic int staticFalse = 0; \n\n\nvoid f_zqxteflu()\n{\n    twoIntsStruct * data;\n    \n    data = NULL;\n    if(staticTrue)\n    {\n        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));\n        if (data == NULL) {exit(-1);}\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n        free(data);\n    }\n    if(staticTrue)\n    {\n        \n        printStructLine(&data[0]);\n        \n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_zqxteflu();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403469,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__malloc_free_struct_05.c",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticFive = 5;\n\n\n\n\nstatic void f_rmbtrexs()\n{\n    twoIntsStruct * data;\n    \n    data = NULL;\n    if(staticFive==5)\n    {\n        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));\n        if (data == NULL) {exit(-1);}\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n        free(data);\n    }\n    if(staticFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        \n        \n        ; \n    }\n}\n\n\nstatic void f_isfvcdsw()\n{\n    twoIntsStruct * data;\n    \n    data = NULL;\n    if(staticFive==5)\n    {\n        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));\n        if (data == NULL) {exit(-1);}\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n        free(data);\n    }\n    if(staticFive==5)\n    {\n        \n        \n        \n        ; \n    }\n}\n\n\nstatic void f_ckbikxul()\n{\n    twoIntsStruct * data;\n    \n    data = NULL;\n    if(staticFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));\n        if (data == NULL) {exit(-1);}\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n    }\n    if(staticFive==5)\n    {\n        \n        printStructLine(&data[0]);\n        \n    }\n}\n\n\nstatic void f_eeibhldk()\n{\n    twoIntsStruct * data;\n    \n    data = NULL;\n    if(staticFive==5)\n    {\n        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));\n        if (data == NULL) {exit(-1);}\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n    }\n    if(staticFive==5)\n    {\n        \n        printStructLine(&data[0]);\n        \n    }\n}\n\nvoid f_nysafrha()\n{\n    f_rmbtrexs();\n    f_isfvcdsw();\n    f_ckbikxul();\n    f_eeibhldk();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_nysafrha();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403470,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__malloc_free_struct_07.c",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticFive = 5;\n\n\nvoid f_ouilkaii()\n{\n    twoIntsStruct * data;\n    \n    data = NULL;\n    if(staticFive==5)\n    {\n        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));\n        if (data == NULL) {exit(-1);}\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n        free(data);\n    }\n    if(staticFive==5)\n    {\n        \n        printStructLine(&data[0]);\n        \n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ouilkaii();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403471,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__malloc_free_struct_07.c",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic const int STATIC_CONST_FIVE = 5;\n\n\n\n\nstatic void f_wxdqoulg()\n{\n    twoIntsStruct * data;\n    \n    data = NULL;\n    if(STATIC_CONST_FIVE==5)\n    {\n        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));\n        if (data == NULL) {exit(-1);}\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n        free(data);\n    }\n    if(STATIC_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        \n        \n        ; \n    }\n}\n\n\nstatic void f_drsrstxp()\n{\n    twoIntsStruct * data;\n    \n    data = NULL;\n    if(STATIC_CONST_FIVE==5)\n    {\n        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));\n        if (data == NULL) {exit(-1);}\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n        free(data);\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        \n        \n        ; \n    }\n}\n\n\nstatic void f_hcnnejpb()\n{\n    twoIntsStruct * data;\n    \n    data = NULL;\n    if(STATIC_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));\n        if (data == NULL) {exit(-1);}\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        printStructLine(&data[0]);\n        \n    }\n}\n\n\nstatic void f_bacesoui()\n{\n    twoIntsStruct * data;\n    \n    data = NULL;\n    if(STATIC_CONST_FIVE==5)\n    {\n        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));\n        if (data == NULL) {exit(-1);}\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        printStructLine(&data[0]);\n        \n    }\n}\n\nvoid f_wiopcklk()\n{\n    f_wxdqoulg();\n    f_drsrstxp();\n    f_hcnnejpb();\n    f_bacesoui();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_wiopcklk();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403472,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__malloc_free_struct_06.c",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic const int STATIC_CONST_FIVE = 5;\n\n\nvoid f_bbtsearj()\n{\n    twoIntsStruct * data;\n    \n    data = NULL;\n    if(STATIC_CONST_FIVE==5)\n    {\n        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));\n        if (data == NULL) {exit(-1);}\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n        free(data);\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        printStructLine(&data[0]);\n        \n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_bbtsearj();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403473,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__malloc_free_struct_06.c",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticTrue = 1; \nstatic int staticFalse = 0; \n\nnamespace _A_namespace\n{\n\n\n\n\nstatic void f_yonutvcu()\n{\n    long * data;\n    \n    data = NULL;\n    if(staticTrue)\n    {\n        data = new long[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5L;\n            }\n        }\n        \n        delete [] data;\n    }\n    if(staticFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        \n        \n        ; \n    }\n}\n\n\nstatic void f_evkwldlp()\n{\n    long * data;\n    \n    data = NULL;\n    if(staticTrue)\n    {\n        data = new long[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5L;\n            }\n        }\n        \n        delete [] data;\n    }\n    if(staticTrue)\n    {\n        \n        \n        \n        ; \n    }\n}\n\n\nstatic void f_cimlkgzy()\n{\n    long * data;\n    \n    data = NULL;\n    if(staticFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        data = new long[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5L;\n            }\n        }\n        \n    }\n    if(staticTrue)\n    {\n        \n        printLongLine(data[0]);\n        \n    }\n}\n\n\nstatic void f_gppmnugs()\n{\n    long * data;\n    \n    data = NULL;\n    if(staticTrue)\n    {\n        data = new long[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5L;\n            }\n        }\n        \n    }\n    if(staticTrue)\n    {\n        \n        printLongLine(data[0]);\n        \n    }\n}\n\nvoid f_rjraaety()\n{\n    f_yonutvcu();\n    f_evkwldlp();\n    f_cimlkgzy();\n    f_gppmnugs();\n}\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_rjraaety();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403474,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_array_long_05.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticTrue = 1; \nstatic int staticFalse = 0; \n\nnamespace _A_namespace\n{\n\n\nvoid f_sroojolw()\n{\n    long * data;\n    \n    data = NULL;\n    if(staticTrue)\n    {\n        data = new long[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5L;\n            }\n        }\n        \n        delete [] data;\n    }\n    if(staticTrue)\n    {\n        \n        printLongLine(data[0]);\n        \n    }\n}\n\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_sroojolw();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403475,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_array_long_05.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic const int STATIC_CONST_TRUE = 1; \nstatic const int STATIC_CONST_FALSE = 0; \n\nnamespace _A_namespace\n{\n\n\n\n\nstatic void f_mpfhkagq()\n{\n    int64_t * data;\n    \n    data = NULL;\n    if(STATIC_CONST_TRUE)\n    {\n        data = new int64_t[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5LL;\n            }\n        }\n        \n        delete [] data;\n    }\n    if(STATIC_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        \n        \n        ; \n    }\n}\n\n\nstatic void f_oeepygnt()\n{\n    int64_t * data;\n    \n    data = NULL;\n    if(STATIC_CONST_TRUE)\n    {\n        data = new int64_t[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5LL;\n            }\n        }\n        \n        delete [] data;\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        \n        \n        \n        ; \n    }\n}\n\n\nstatic void f_dnkbzhcz()\n{\n    int64_t * data;\n    \n    data = NULL;\n    if(STATIC_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        data = new int64_t[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5LL;\n            }\n        }\n        \n    }\n    if(STATIC_CONST_TRUE)\n    {\n        \n        printLongLongLine(data[0]);\n        \n    }\n}\n\n\nstatic void f_pgkahuoh()\n{\n    int64_t * data;\n    \n    data = NULL;\n    if(STATIC_CONST_TRUE)\n    {\n        data = new int64_t[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5LL;\n            }\n        }\n        \n    }\n    if(STATIC_CONST_TRUE)\n    {\n        \n        printLongLongLine(data[0]);\n        \n    }\n}\n\nvoid f_wxdhlzij()\n{\n    f_mpfhkagq();\n    f_oeepygnt();\n    f_dnkbzhcz();\n    f_pgkahuoh();\n}\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_wxdhlzij();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403476,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_array_int64_t_04.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic const int STATIC_CONST_TRUE = 1; \nstatic const int STATIC_CONST_FALSE = 0; \n\nnamespace _A_namespace\n{\n\n\nvoid f_dfppgcgh()\n{\n    int64_t * data;\n    \n    data = NULL;\n    if(STATIC_CONST_TRUE)\n    {\n        data = new int64_t[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5LL;\n            }\n        }\n        \n        delete [] data;\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        \n        printLongLongLine(data[0]);\n        \n    }\n}\n\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_dfppgcgh();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403477,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_array_int64_t_04.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticTrue = 1; \nstatic int staticFalse = 0; \n\nnamespace _A_namespace\n{\n\n\n\n\nstatic void f_ovdlakjw()\n{\n    int64_t * data;\n    \n    data = NULL;\n    if(staticTrue)\n    {\n        data = new int64_t[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5LL;\n            }\n        }\n        \n        delete [] data;\n    }\n    if(staticFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        \n        \n        ; \n    }\n}\n\n\nstatic void f_dzakkadv()\n{\n    int64_t * data;\n    \n    data = NULL;\n    if(staticTrue)\n    {\n        data = new int64_t[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5LL;\n            }\n        }\n        \n        delete [] data;\n    }\n    if(staticTrue)\n    {\n        \n        \n        \n        ; \n    }\n}\n\n\nstatic void f_pittjzyn()\n{\n    int64_t * data;\n    \n    data = NULL;\n    if(staticFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        data = new int64_t[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5LL;\n            }\n        }\n        \n    }\n    if(staticTrue)\n    {\n        \n        printLongLongLine(data[0]);\n        \n    }\n}\n\n\nstatic void f_xnagfgrm()\n{\n    int64_t * data;\n    \n    data = NULL;\n    if(staticTrue)\n    {\n        data = new int64_t[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5LL;\n            }\n        }\n        \n    }\n    if(staticTrue)\n    {\n        \n        printLongLongLine(data[0]);\n        \n    }\n}\n\nvoid f_eguvamik()\n{\n    f_ovdlakjw();\n    f_dzakkadv();\n    f_pittjzyn();\n    f_xnagfgrm();\n}\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_eguvamik();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403478,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_array_int64_t_05.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticTrue = 1; \nstatic int staticFalse = 0; \n\nnamespace _A_namespace\n{\n\n\nvoid f_icirhszn()\n{\n    int64_t * data;\n    \n    data = NULL;\n    if(staticTrue)\n    {\n        data = new int64_t[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5LL;\n            }\n        }\n        \n        delete [] data;\n    }\n    if(staticTrue)\n    {\n        \n        printLongLongLine(data[0]);\n        \n    }\n}\n\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_icirhszn();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403479,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_array_int64_t_05.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticTrue = 1; \nstatic int staticFalse = 0; \n\nnamespace _A_namespace\n{\n\n\n\n\nstatic void f_ctiphodo()\n{\n    int * data;\n    \n    data = NULL;\n    if(staticTrue)\n    {\n        data = new int[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5;\n            }\n        }\n        \n        delete [] data;\n    }\n    if(staticFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        \n        \n        ; \n    }\n}\n\n\nstatic void f_gadhggas()\n{\n    int * data;\n    \n    data = NULL;\n    if(staticTrue)\n    {\n        data = new int[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5;\n            }\n        }\n        \n        delete [] data;\n    }\n    if(staticTrue)\n    {\n        \n        \n        \n        ; \n    }\n}\n\n\nstatic void f_rsiudmxk()\n{\n    int * data;\n    \n    data = NULL;\n    if(staticFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        data = new int[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5;\n            }\n        }\n        \n    }\n    if(staticTrue)\n    {\n        \n        printIntLine(data[0]);\n        \n    }\n}\n\n\nstatic void f_ptyukeso()\n{\n    int * data;\n    \n    data = NULL;\n    if(staticTrue)\n    {\n        data = new int[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5;\n            }\n        }\n        \n    }\n    if(staticTrue)\n    {\n        \n        printIntLine(data[0]);\n        \n    }\n}\n\nvoid f_vzqlgieb()\n{\n    f_ctiphodo();\n    f_gadhggas();\n    f_rsiudmxk();\n    f_ptyukeso();\n}\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_vzqlgieb();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403480,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_array_int_05.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticTrue = 1; \nstatic int staticFalse = 0; \n\nnamespace _A_namespace\n{\n\n\nvoid f_kwafupts()\n{\n    int * data;\n    \n    data = NULL;\n    if(staticTrue)\n    {\n        data = new int[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5;\n            }\n        }\n        \n        delete [] data;\n    }\n    if(staticTrue)\n    {\n        \n        printIntLine(data[0]);\n        \n    }\n}\n\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_kwafupts();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403481,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_array_int_05.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic const int STATIC_CONST_TRUE = 1; \nstatic const int STATIC_CONST_FALSE = 0; \n\nnamespace _A_namespace\n{\n\n\n\n\nstatic void f_ojmzccnk()\n{\n    int * data;\n    \n    data = NULL;\n    if(STATIC_CONST_TRUE)\n    {\n        data = new int[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5;\n            }\n        }\n        \n        delete [] data;\n    }\n    if(STATIC_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        \n        \n        ; \n    }\n}\n\n\nstatic void f_vbjulsex()\n{\n    int * data;\n    \n    data = NULL;\n    if(STATIC_CONST_TRUE)\n    {\n        data = new int[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5;\n            }\n        }\n        \n        delete [] data;\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        \n        \n        \n        ; \n    }\n}\n\n\nstatic void f_zoqghsfm()\n{\n    int * data;\n    \n    data = NULL;\n    if(STATIC_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        data = new int[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5;\n            }\n        }\n        \n    }\n    if(STATIC_CONST_TRUE)\n    {\n        \n        printIntLine(data[0]);\n        \n    }\n}\n\n\nstatic void f_iqlugxse()\n{\n    int * data;\n    \n    data = NULL;\n    if(STATIC_CONST_TRUE)\n    {\n        data = new int[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5;\n            }\n        }\n        \n    }\n    if(STATIC_CONST_TRUE)\n    {\n        \n        printIntLine(data[0]);\n        \n    }\n}\n\nvoid f_axkjacda()\n{\n    f_ojmzccnk();\n    f_vbjulsex();\n    f_zoqghsfm();\n    f_iqlugxse();\n}\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_axkjacda();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403482,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_array_int_04.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic const int STATIC_CONST_TRUE = 1; \nstatic const int STATIC_CONST_FALSE = 0; \n\nnamespace _A_namespace\n{\n\n\nvoid f_robhhugn()\n{\n    int * data;\n    \n    data = NULL;\n    if(STATIC_CONST_TRUE)\n    {\n        data = new int[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5;\n            }\n        }\n        \n        delete [] data;\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        \n        printIntLine(data[0]);\n        \n    }\n}\n\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_robhhugn();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403483,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_array_int_04.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic const int STATIC_CONST_TRUE = 1; \nstatic const int STATIC_CONST_FALSE = 0; \n\nnamespace _A_namespace\n{\n\n\n\n\nstatic void f_gvzwzsog()\n{\n    long * data;\n    \n    data = NULL;\n    if(STATIC_CONST_TRUE)\n    {\n        data = new long[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5L;\n            }\n        }\n        \n        delete [] data;\n    }\n    if(STATIC_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        \n        \n        ; \n    }\n}\n\n\nstatic void f_qoskaeml()\n{\n    long * data;\n    \n    data = NULL;\n    if(STATIC_CONST_TRUE)\n    {\n        data = new long[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5L;\n            }\n        }\n        \n        delete [] data;\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        \n        \n        \n        ; \n    }\n}\n\n\nstatic void f_jzzdrwmu()\n{\n    long * data;\n    \n    data = NULL;\n    if(STATIC_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        data = new long[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5L;\n            }\n        }\n        \n    }\n    if(STATIC_CONST_TRUE)\n    {\n        \n        printLongLine(data[0]);\n        \n    }\n}\n\n\nstatic void f_axoirkqh()\n{\n    long * data;\n    \n    data = NULL;\n    if(STATIC_CONST_TRUE)\n    {\n        data = new long[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5L;\n            }\n        }\n        \n    }\n    if(STATIC_CONST_TRUE)\n    {\n        \n        printLongLine(data[0]);\n        \n    }\n}\n\nvoid f_rroofszw()\n{\n    f_gvzwzsog();\n    f_qoskaeml();\n    f_jzzdrwmu();\n    f_axoirkqh();\n}\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_rroofszw();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403484,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_array_long_04.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic const int STATIC_CONST_TRUE = 1; \nstatic const int STATIC_CONST_FALSE = 0; \n\nnamespace _A_namespace\n{\n\n\nvoid f_vrqyavdp()\n{\n    long * data;\n    \n    data = NULL;\n    if(STATIC_CONST_TRUE)\n    {\n        data = new long[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5L;\n            }\n        }\n        \n        delete [] data;\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        \n        printLongLine(data[0]);\n        \n    }\n}\n\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_vrqyavdp();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403485,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_array_long_04.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticFive = 5;\n\nnamespace _A_namespace\n{\n\n\n\n\nstatic void f_tagenyhi()\n{\n    long * data;\n    \n    data = NULL;\n    if(staticFive==5)\n    {\n        data = new long[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5L;\n            }\n        }\n        \n        delete [] data;\n    }\n    if(staticFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        \n        \n        ; \n    }\n}\n\n\nstatic void f_zzohcokm()\n{\n    long * data;\n    \n    data = NULL;\n    if(staticFive==5)\n    {\n        data = new long[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5L;\n            }\n        }\n        \n        delete [] data;\n    }\n    if(staticFive==5)\n    {\n        \n        \n        \n        ; \n    }\n}\n\n\nstatic void f_fkpttnsi()\n{\n    long * data;\n    \n    data = NULL;\n    if(staticFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        data = new long[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5L;\n            }\n        }\n        \n    }\n    if(staticFive==5)\n    {\n        \n        printLongLine(data[0]);\n        \n    }\n}\n\n\nstatic void f_amlyrqdq()\n{\n    long * data;\n    \n    data = NULL;\n    if(staticFive==5)\n    {\n        data = new long[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5L;\n            }\n        }\n        \n    }\n    if(staticFive==5)\n    {\n        \n        printLongLine(data[0]);\n        \n    }\n}\n\nvoid f_nrqhmozk()\n{\n    f_tagenyhi();\n    f_zzohcokm();\n    f_fkpttnsi();\n    f_amlyrqdq();\n}\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_nrqhmozk();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403486,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_array_long_07.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticFive = 5;\n\nnamespace _A_namespace\n{\n\n\nvoid f_olhtnvzz()\n{\n    long * data;\n    \n    data = NULL;\n    if(staticFive==5)\n    {\n        data = new long[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5L;\n            }\n        }\n        \n        delete [] data;\n    }\n    if(staticFive==5)\n    {\n        \n        printLongLine(data[0]);\n        \n    }\n}\n\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_olhtnvzz();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403487,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_array_long_07.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\nnamespace _A_namespace\n{\n\n\n\n\nstatic void f_vgjyohsd()\n{\n    TwoIntsClass * data;\n    \n    data = NULL;\n    if(1)\n    {\n        data = new TwoIntsClass[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n        delete [] data;\n    }\n    if(0)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        \n        \n        ; \n    }\n}\n\n\nstatic void f_iiferwpy()\n{\n    TwoIntsClass * data;\n    \n    data = NULL;\n    if(1)\n    {\n        data = new TwoIntsClass[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n        delete [] data;\n    }\n    if(1)\n    {\n        \n        \n        \n        ; \n    }\n}\n\n\nstatic void f_xplvmnvj()\n{\n    TwoIntsClass * data;\n    \n    data = NULL;\n    if(0)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        data = new TwoIntsClass[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n    }\n    if(1)\n    {\n        \n        printIntLine(data[0].intOne);\n        \n    }\n}\n\n\nstatic void f_recrjugh()\n{\n    TwoIntsClass * data;\n    \n    data = NULL;\n    if(1)\n    {\n        data = new TwoIntsClass[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n    }\n    if(1)\n    {\n        \n        printIntLine(data[0].intOne);\n        \n    }\n}\n\nvoid f_qhnpkuci()\n{\n    f_vgjyohsd();\n    f_iiferwpy();\n    f_xplvmnvj();\n    f_recrjugh();\n}\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_qhnpkuci();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403488,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_array_class_02.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\nnamespace _A_namespace\n{\n\n\nvoid f_tyfbqrwv()\n{\n    TwoIntsClass * data;\n    \n    data = NULL;\n    if(1)\n    {\n        data = new TwoIntsClass[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n        delete [] data;\n    }\n    if(1)\n    {\n        \n        printIntLine(data[0].intOne);\n        \n    }\n}\n\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_tyfbqrwv();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403489,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_array_class_02.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\nnamespace _A_namespace\n{\n\n\n\n\nstatic void f_hgqoqdeg()\n{\n    TwoIntsClass * data;\n    \n    data = NULL;\n    if(5==5)\n    {\n        data = new TwoIntsClass[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n        delete [] data;\n    }\n    if(5!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        \n        \n        ; \n    }\n}\n\n\nstatic void f_akeudeld()\n{\n    TwoIntsClass * data;\n    \n    data = NULL;\n    if(5==5)\n    {\n        data = new TwoIntsClass[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n        delete [] data;\n    }\n    if(5==5)\n    {\n        \n        \n        \n        ; \n    }\n}\n\n\nstatic void f_dvbevnjt()\n{\n    TwoIntsClass * data;\n    \n    data = NULL;\n    if(5!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        data = new TwoIntsClass[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n    }\n    if(5==5)\n    {\n        \n        printIntLine(data[0].intOne);\n        \n    }\n}\n\n\nstatic void f_bwarxgyd()\n{\n    TwoIntsClass * data;\n    \n    data = NULL;\n    if(5==5)\n    {\n        data = new TwoIntsClass[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n    }\n    if(5==5)\n    {\n        \n        printIntLine(data[0].intOne);\n        \n    }\n}\n\nvoid f_qctojknx()\n{\n    f_hgqoqdeg();\n    f_akeudeld();\n    f_dvbevnjt();\n    f_bwarxgyd();\n}\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_qctojknx();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403490,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_array_class_03.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\nnamespace _A_namespace\n{\n\n\nvoid f_whkgoicw()\n{\n    TwoIntsClass * data;\n    \n    data = NULL;\n    if(5==5)\n    {\n        data = new TwoIntsClass[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        \n        delete [] data;\n    }\n    if(5==5)\n    {\n        \n        printIntLine(data[0].intOne);\n        \n    }\n}\n\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_whkgoicw();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 403491,
    "original_file": "testcases/CWE416_Use_After_Free/CWE416_Use_After_Free__new_delete_array_class_03.cpp",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int do_mq_notify(mqd_t mqdes, const struct sigevent *notification)\n{\n\tint ret;\n\tstruct fd f;\n\tstruct sock *sock;\n\tstruct inode *inode;\n\tstruct mqueue_inode_info *info;\n\tstruct sk_buff *nc;\n\n\taudit_mq_notify(mqdes, notification);\n\n\tnc = NULL;\n\tsock = NULL;\n\tif (notification != NULL) {\n\t\tif (unlikely(notification->sigev_notify != SIGEV_NONE &&\n\t\t\t     notification->sigev_notify != SIGEV_SIGNAL &&\n\t\t\t     notification->sigev_notify != SIGEV_THREAD))\n\t\t\treturn -EINVAL;\n\t\tif (notification->sigev_notify == SIGEV_SIGNAL &&\n\t\t\t!valid_signal(notification->sigev_signo)) {\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (notification->sigev_notify == SIGEV_THREAD) {\n\t\t\tlong timeo;\n\n\t\t\t/* create the notify skb */\n\t\t\tnc = alloc_skb(NOTIFY_COOKIE_LEN, GFP_KERNEL);\n\t\t\tif (!nc) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (copy_from_user(nc->data,\n\t\t\t\t\tnotification->sigev_value.sival_ptr,\n\t\t\t\t\tNOTIFY_COOKIE_LEN)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/* TODO: add a header? */\n\t\t\tskb_put(nc, NOTIFY_COOKIE_LEN);\n\t\t\t/* and attach it to the socket */\nretry:\n\t\t\tf = fdget(notification->sigev_signo);\n\t\t\tif (!f.file) {\n\t\t\t\tret = -EBADF;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tsock = netlink_getsockbyfilp(f.file);\n\t\t\tfdput(f);\n\t\t\tif (IS_ERR(sock)) {\n\t\t\t\tret = PTR_ERR(sock);\n\t\t\t\tsock = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\ttimeo = MAX_SCHEDULE_TIMEOUT;\n\t\t\tret = netlink_attachskb(sock, nc, &timeo, NULL);\n\t\t\tif (ret == 1)\n\t\t\t\tgoto retry;\n\t\t\tif (ret) {\n\t\t\t\tsock = NULL;\n\t\t\t\tnc = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tf = fdget(mqdes);\n\tif (!f.file) {\n\t\tret = -EBADF;\n\t\tgoto out;\n\t}\n\n\tinode = file_inode(f.file);\n\tif (unlikely(f.file->f_op != &mqueue_file_operations)) {\n\t\tret = -EBADF;\n\t\tgoto out_fput;\n\t}\n\tinfo = MQUEUE_I(inode);\n\n\tret = 0;\n\tspin_lock(&info->lock);\n\tif (notification == NULL) {\n\t\tif (info->notify_owner == task_tgid(current)) {\n\t\t\tremove_notification(info);\n\t\t\tinode->i_atime = inode->i_ctime = current_time(inode);\n\t\t}\n\t} else if (info->notify_owner != NULL) {\n\t\tret = -EBUSY;\n\t} else {\n\t\tswitch (notification->sigev_notify) {\n\t\tcase SIGEV_NONE:\n\t\t\tinfo->notify.sigev_notify = SIGEV_NONE;\n\t\t\tbreak;\n\t\tcase SIGEV_THREAD:\n\t\t\tinfo->notify_sock = sock;\n\t\t\tinfo->notify_cookie = nc;\n\t\t\tsock = NULL;\n\t\t\tnc = NULL;\n\t\t\tinfo->notify.sigev_notify = SIGEV_THREAD;\n\t\t\tbreak;\n\t\tcase SIGEV_SIGNAL:\n\t\t\tinfo->notify.sigev_signo = notification->sigev_signo;\n\t\t\tinfo->notify.sigev_value = notification->sigev_value;\n\t\t\tinfo->notify.sigev_notify = SIGEV_SIGNAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tinfo->notify_owner = get_pid(task_tgid(current));\n\t\tinfo->notify_user_ns = get_user_ns(current_user_ns());\n\t\tinode->i_atime = inode->i_ctime = current_time(inode);\n\t}\n\tspin_unlock(&info->lock);\nout_fput:\n\tfdput(f);\nout:\n\tif (sock)\n\t\tnetlink_detachskb(sock, nc);\n\telse if (nc)\n\t\tdev_kfree_skb(nc);\n\n\treturn ret;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149832,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int do_mq_notify(mqd_t mqdes, const struct sigevent *notification)\n{\n\tint ret;\n\tstruct fd f;\n\tstruct sock *sock;\n\tstruct inode *inode;\n\tstruct mqueue_inode_info *info;\n\tstruct sk_buff *nc;\n\n\taudit_mq_notify(mqdes, notification);\n\n\tnc = NULL;\n\tsock = NULL;\n\tif (notification != NULL) {\n\t\tif (unlikely(notification->sigev_notify != SIGEV_NONE &&\n\t\t\t     notification->sigev_notify != SIGEV_SIGNAL &&\n\t\t\t     notification->sigev_notify != SIGEV_THREAD))\n\t\t\treturn -EINVAL;\n\t\tif (notification->sigev_notify == SIGEV_SIGNAL &&\n\t\t\t!valid_signal(notification->sigev_signo)) {\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (notification->sigev_notify == SIGEV_THREAD) {\n\t\t\tlong timeo;\n\n\t\t\t/* create the notify skb */\n\t\t\tnc = alloc_skb(NOTIFY_COOKIE_LEN, GFP_KERNEL);\n\t\t\tif (!nc) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (copy_from_user(nc->data,\n\t\t\t\t\tnotification->sigev_value.sival_ptr,\n\t\t\t\t\tNOTIFY_COOKIE_LEN)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/* TODO: add a header? */\n\t\t\tskb_put(nc, NOTIFY_COOKIE_LEN);\n\t\t\t/* and attach it to the socket */\nretry:\n\t\t\tf = fdget(notification->sigev_signo);\n\t\t\tif (!f.file) {\n\t\t\t\tret = -EBADF;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tsock = netlink_getsockbyfilp(f.file);\n\t\t\tfdput(f);\n\t\t\tif (IS_ERR(sock)) {\n\t\t\t\tret = PTR_ERR(sock);\n\t\t\t\tsock = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\ttimeo = MAX_SCHEDULE_TIMEOUT;\n\t\t\tret = netlink_attachskb(sock, nc, &timeo, NULL);\n\t\t\tif (ret == 1) {\n\t\t\t\tsock = NULL;\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\tif (ret) {\n\t\t\t\tsock = NULL;\n\t\t\t\tnc = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tf = fdget(mqdes);\n\tif (!f.file) {\n\t\tret = -EBADF;\n\t\tgoto out;\n\t}\n\n\tinode = file_inode(f.file);\n\tif (unlikely(f.file->f_op != &mqueue_file_operations)) {\n\t\tret = -EBADF;\n\t\tgoto out_fput;\n\t}\n\tinfo = MQUEUE_I(inode);\n\n\tret = 0;\n\tspin_lock(&info->lock);\n\tif (notification == NULL) {\n\t\tif (info->notify_owner == task_tgid(current)) {\n\t\t\tremove_notification(info);\n\t\t\tinode->i_atime = inode->i_ctime = current_time(inode);\n\t\t}\n\t} else if (info->notify_owner != NULL) {\n\t\tret = -EBUSY;\n\t} else {\n\t\tswitch (notification->sigev_notify) {\n\t\tcase SIGEV_NONE:\n\t\t\tinfo->notify.sigev_notify = SIGEV_NONE;\n\t\t\tbreak;\n\t\tcase SIGEV_THREAD:\n\t\t\tinfo->notify_sock = sock;\n\t\t\tinfo->notify_cookie = nc;\n\t\t\tsock = NULL;\n\t\t\tnc = NULL;\n\t\t\tinfo->notify.sigev_notify = SIGEV_THREAD;\n\t\t\tbreak;\n\t\tcase SIGEV_SIGNAL:\n\t\t\tinfo->notify.sigev_signo = notification->sigev_signo;\n\t\t\tinfo->notify.sigev_value = notification->sigev_value;\n\t\t\tinfo->notify.sigev_notify = SIGEV_SIGNAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tinfo->notify_owner = get_pid(task_tgid(current));\n\t\tinfo->notify_user_ns = get_user_ns(current_user_ns());\n\t\tinode->i_atime = inode->i_ctime = current_time(inode);\n\t}\n\tspin_unlock(&info->lock);\nout_fput:\n\tfdput(f);\nout:\n\tif (sock)\n\t\tnetlink_detachskb(sock, nc);\n\telse if (nc)\n\t\tdev_kfree_skb(nc);\n\n\treturn ret;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149833,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int xc2028_set_config(struct dvb_frontend *fe, void *priv_cfg)\n{\n\tstruct xc2028_data *priv = fe->tuner_priv;\n\tstruct xc2028_ctrl *p    = priv_cfg;\n\tint                 rc   = 0;\n\n\ttuner_dbg(\"%s called\\n\", __func__);\n\n\tmutex_lock(&priv->lock);\n\n\t/*\n\t * Copy the config data.\n\t * For the firmware name, keep a local copy of the string,\n\t * in order to avoid troubles during device release.\n\t */\n\tkfree(priv->ctrl.fname);\n\tmemcpy(&priv->ctrl, p, sizeof(priv->ctrl));\n\tif (p->fname) {\n\t\tpriv->ctrl.fname = kstrdup(p->fname, GFP_KERNEL);\n\t\tif (priv->ctrl.fname == NULL)\n\t\t\trc = -ENOMEM;\n\t}\n\n\t/*\n\t * If firmware name changed, frees firmware. As free_firmware will\n\t * reset the status to NO_FIRMWARE, this forces a new request_firmware\n\t */\n\tif (!firmware_name[0] && p->fname &&\n\t    priv->fname && strcmp(p->fname, priv->fname))\n\t\tfree_firmware(priv);\n\n\tif (priv->ctrl.max_len < 9)\n\t\tpriv->ctrl.max_len = 13;\n\n\tif (priv->state == XC2028_NO_FIRMWARE) {\n\t\tif (!firmware_name[0])\n\t\t\tpriv->fname = priv->ctrl.fname;\n\t\telse\n\t\t\tpriv->fname = firmware_name;\n\n\t\trc = request_firmware_nowait(THIS_MODULE, 1,\n\t\t\t\t\t     priv->fname,\n\t\t\t\t\t     priv->i2c_props.adap->dev.parent,\n\t\t\t\t\t     GFP_KERNEL,\n\t\t\t\t\t     fe, load_firmware_cb);\n\t\tif (rc < 0) {\n\t\t\ttuner_err(\"Failed to request firmware %s\\n\",\n\t\t\t\t  priv->fname);\n\t\t\tpriv->state = XC2028_NODEV;\n\t\t} else\n\t\t\tpriv->state = XC2028_WAITING_FIRMWARE;\n\t}\n\tmutex_unlock(&priv->lock);\n\n\treturn rc;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149834,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int xc2028_set_config(struct dvb_frontend *fe, void *priv_cfg)\n{\n\tstruct xc2028_data *priv = fe->tuner_priv;\n\tstruct xc2028_ctrl *p    = priv_cfg;\n\tint                 rc   = 0;\n\n\ttuner_dbg(\"%s called\\n\", __func__);\n\n\tmutex_lock(&priv->lock);\n\n\t/*\n\t * Copy the config data.\n\t * For the firmware name, keep a local copy of the string,\n\t * in order to avoid troubles during device release.\n\t */\n\tkfree(priv->ctrl.fname);\n\tpriv->ctrl.fname = NULL;\n\tmemcpy(&priv->ctrl, p, sizeof(priv->ctrl));\n\tif (p->fname) {\n\t\tpriv->ctrl.fname = kstrdup(p->fname, GFP_KERNEL);\n\t\tif (priv->ctrl.fname == NULL)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/*\n\t * If firmware name changed, frees firmware. As free_firmware will\n\t * reset the status to NO_FIRMWARE, this forces a new request_firmware\n\t */\n\tif (!firmware_name[0] && p->fname &&\n\t    priv->fname && strcmp(p->fname, priv->fname))\n\t\tfree_firmware(priv);\n\n\tif (priv->ctrl.max_len < 9)\n\t\tpriv->ctrl.max_len = 13;\n\n\tif (priv->state == XC2028_NO_FIRMWARE) {\n\t\tif (!firmware_name[0])\n\t\t\tpriv->fname = priv->ctrl.fname;\n\t\telse\n\t\t\tpriv->fname = firmware_name;\n\n\t\trc = request_firmware_nowait(THIS_MODULE, 1,\n\t\t\t\t\t     priv->fname,\n\t\t\t\t\t     priv->i2c_props.adap->dev.parent,\n\t\t\t\t\t     GFP_KERNEL,\n\t\t\t\t\t     fe, load_firmware_cb);\n\t\tif (rc < 0) {\n\t\t\ttuner_err(\"Failed to request firmware %s\\n\",\n\t\t\t\t  priv->fname);\n\t\t\tpriv->state = XC2028_NODEV;\n\t\t} else\n\t\t\tpriv->state = XC2028_WAITING_FIRMWARE;\n\t}\n\tmutex_unlock(&priv->lock);\n\n\treturn rc;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149835,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "void snd_pcm_period_elapsed(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime;\n\tunsigned long flags;\n\n\tif (PCM_RUNTIME_CHECK(substream))\n\t\treturn;\n\truntime = substream->runtime;\n\n\tsnd_pcm_stream_lock_irqsave(substream, flags);\n\tif (!snd_pcm_running(substream) ||\n\t    snd_pcm_update_hw_ptr0(substream, 1) < 0)\n\t\tgoto _end;\n\n#ifdef CONFIG_SND_PCM_TIMER\n\tif (substream->timer_running)\n\t\tsnd_timer_interrupt(substream->timer, 1);\n#endif\n _end:\n\tsnd_pcm_stream_unlock_irqrestore(substream, flags);\n\tkill_fasync(&runtime->fasync, SIGIO, POLL_IN);\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149836,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "void snd_pcm_period_elapsed(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime;\n\tunsigned long flags;\n\n\tif (PCM_RUNTIME_CHECK(substream))\n\t\treturn;\n\truntime = substream->runtime;\n\n\tsnd_pcm_stream_lock_irqsave(substream, flags);\n\tif (!snd_pcm_running(substream) ||\n\t    snd_pcm_update_hw_ptr0(substream, 1) < 0)\n\t\tgoto _end;\n\n#ifdef CONFIG_SND_PCM_TIMER\n\tif (substream->timer_running)\n\t\tsnd_timer_interrupt(substream->timer, 1);\n#endif\n _end:\n\tkill_fasync(&runtime->fasync, SIGIO, POLL_IN);\n\tsnd_pcm_stream_unlock_irqrestore(substream, flags);\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149837,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "int wwunpack(uint8_t *exe, uint32_t exesz, uint8_t *wwsect, struct cli_exe_section *sects, uint16_t scount, uint32_t pe, int desc) {\n  uint8_t *structs = wwsect + 0x2a1, *compd, *ccur, *unpd, *ucur, bc;\n  uint32_t src, srcend, szd, bt, bits;\n  int error=0, i;\n\n  cli_dbgmsg(\"in wwunpack\\n\");\n  while (1) {\n    if (!CLI_ISCONTAINED(wwsect, sects[scount].rsz, structs, 17)) {\n      cli_dbgmsg(\"WWPack: Array of structs out of section\\n\");\n      break;\n    }\n    src = sects[scount].rva - cli_readint32(structs); /* src delta / dst delta - not used / dwords / end of src */\n    structs+=8;\n    szd = cli_readint32(structs) * 4;\n    structs+=4;\n    srcend = cli_readint32(structs);\n    structs+=4;\n\n    unpd = ucur = exe+src+srcend+4-szd;\n    if (!szd || !CLI_ISCONTAINED(exe, exesz, unpd, szd)) {\n      cli_dbgmsg(\"WWPack: Compressed data out of file\\n\");\n      break;\n    }\n    cli_dbgmsg(\"WWP: src: %x, szd: %x, srcend: %x - %x\\n\", src, szd, srcend, srcend+4-szd);\n    if (!(compd = cli_malloc(szd))) {\n        cli_dbgmsg(\"WWPack: Unable to allocate memory for compd\\n\");\n        break;\n    }\n    memcpy(compd, unpd, szd);\n    memset(unpd, -1, szd); /*FIXME*/\n    ccur=compd;\n    \n    RESEED;\n    while(!error) {\n      uint32_t backbytes, backsize;\n      uint8_t saved;\n\n      BIT;\n      if (!bits) { /* BYTE copy */\n\tif(ccur-compd>=szd || !CLI_ISCONTAINED(exe, exesz, ucur, 1))\n\t  error=1;\n\telse\n\t  *ucur++=*ccur++;\n\tcontinue;\n      }\n\n      BITS(2);\n      if(bits==3) { /* WORD backcopy */\n\tuint8_t shifted, subbed = 31;\n\tBITS(2);\n\tshifted = bits + 5;\n\tif(bits>=2) {\n\t  shifted++;\n\t  subbed += 0x80;\n\t}\n\tbackbytes = (1<<shifted)-subbed; /* 1h, 21h, 61h, 161h */\n\tBITS(shifted); /* 5, 6, 8, 9 */\n\tif(error || bits == 0x1ff) break;\n\tbackbytes+=bits;\n\tif(!CLI_ISCONTAINED(exe, exesz, ucur, 2) || !CLI_ISCONTAINED(exe, exesz, ucur-backbytes, 2)) {\n\t  error=1;\n\t} else {\n\t  ucur[0]=*(ucur-backbytes);\n\t  ucur[1]=*(ucur-backbytes+1);\n\t  ucur+=2;\n\t}\n\tcontinue;\n      }\n\n      /* BLOCK backcopy */\n      saved = bits; /* cmp al, 1 / pushf */\n\n      BITS(3);\n      if (bits<6) {\n\tbackbytes = bits;\n\tswitch(bits) {\n\tcase 4: /* 10,11 */\n\t  backbytes++;\n\tcase 3: /* 8,9 */\n\t  BIT;\n\t  backbytes+=bits;\n\tcase 0:\tcase 1:\tcase 2: /* 5,6,7 */\n\t  backbytes+=5;\n\t  break;\n\tcase 5: /* 12 */\n\t  backbytes=12;\n\t  break;\n\t}\n\tBITS(backbytes);\n\tbits+=(1<<backbytes)-31;\n      } else if(bits==6) {\n\tBITS(0x0e);\n\tbits+=0x1fe1;\n      } else {\n\tBITS(0x0f);\n\tbits+=0x5fe1;\n      }\n\n      backbytes = bits;\n\n      /* popf / jb */\n      if (!saved) {\n\tBIT;\n\tif(!bits) {\n\t  BIT;\n\t  bits+=5;\n\t} else {\n\t  BITS(3);\n\t  if(bits) {\n\t    bits+=6;\n\t  } else {\n\t    BITS(4);\n\t    if(bits) {\n\t      bits+=13;\n\t    } else {\n\t      uint8_t cnt = 4;\n\t      uint16_t shifted = 0x0d;\n\t      \n\t      do {\n\t\tif(cnt==7) { cnt = 0x0e; shifted = 0; break; }\n\t\tshifted=((shifted+2)<<1)-1;\n\t\tBIT;\n\t\tcnt++;\n\t      } while(!bits);\n\t      BITS(cnt);\n\t      bits+=shifted;\n\t    }\n\t  }\n\t}\n\tbacksize = bits;\n      } else {\n\tbacksize = saved+2;\n      }\n\n      if(!CLI_ISCONTAINED(exe, exesz, ucur, backsize) || !CLI_ISCONTAINED(exe, exesz, ucur-backbytes, backsize)) error=1;\n      else while(backsize--) {\n\t*ucur=*(ucur-backbytes);\n\tucur++;\n      }\n    }\n    free(compd);\n    if(error) {\n      cli_dbgmsg(\"WWPack: decompression error\\n\");\n      break;\n    }\n    if (error || !*structs++) break;\n  }\n\n  if(!error) {\n    if (pe+6 > exesz || pe+7 > exesz || pe+0x28 > exesz ||\n\t\tpe+0x50 > exesz || pe+0x14 > exesz) \n\treturn CL_EFORMAT;\n    exe[pe+6]=(uint8_t)scount;\n    exe[pe+7]=(uint8_t)(scount>>8);\n    cli_writeint32(&exe[pe+0x28], cli_readint32(wwsect+0x295)+sects[scount].rva+0x299);\n    cli_writeint32(&exe[pe+0x50], cli_readint32(&exe[pe+0x50])-sects[scount].vsz);\n\n    structs = &exe[(0xffff&cli_readint32(&exe[pe+0x14]))+pe+0x18];\n    for(i=0 ; i<scount ; i++) {\n\t  if (!CLI_ISCONTAINED(exe, exesz, structs, 0x28)) {\n\t    cli_dbgmsg(\"WWPack: structs pointer out of bounds\\n\");\n\t    return CL_EFORMAT;\n\t  }\n\n      cli_writeint32(structs+8, sects[i].vsz);\n      cli_writeint32(structs+12, sects[i].rva);\n      cli_writeint32(structs+16, sects[i].vsz);\n      cli_writeint32(structs+20, sects[i].rva);\n      structs+=0x28;\n    }\n\tif (!CLI_ISCONTAINED(exe, exesz, structs, 0x28)) {\n\t  cli_dbgmsg(\"WWPack: structs pointer out of bounds\\n\");\n\t  return CL_EFORMAT;\n\t}\n\n    memset(structs, 0, 0x28);\n    error = (uint32_t)cli_writen(desc, exe, exesz)!=exesz;\n  }\n  return error;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149838,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "int wwunpack(uint8_t *exe, uint32_t exesz, uint8_t *wwsect, struct cli_exe_section *sects, uint16_t scount, uint32_t pe, int desc) {\n  uint8_t *structs = wwsect + 0x2a1, *compd, *ccur, *unpd, *ucur, bc;\n  uint32_t src, srcend, szd, bt, bits;\n  int error=0, i;\n\n  cli_dbgmsg(\"in wwunpack\\n\");\n  while (1) {\n    if (!CLI_ISCONTAINED(wwsect, sects[scount].rsz, structs, 17)) {\n      cli_dbgmsg(\"WWPack: Array of structs out of section\\n\");\n      break;\n    }\n    src = sects[scount].rva - cli_readint32(structs); /* src delta / dst delta - not used / dwords / end of src */\n    structs+=8;\n    szd = cli_readint32(structs) * 4;\n    structs+=4;\n    srcend = cli_readint32(structs);\n    structs+=4;\n\n    unpd = ucur = exe+src+srcend+4-szd;\n    if (!szd || !CLI_ISCONTAINED(exe, exesz, unpd, szd)) {\n      cli_dbgmsg(\"WWPack: Compressed data out of file\\n\");\n      break;\n    }\n    cli_dbgmsg(\"WWP: src: %x, szd: %x, srcend: %x - %x\\n\", src, szd, srcend, srcend+4-szd);\n    if (!(compd = cli_malloc(szd))) {\n        cli_dbgmsg(\"WWPack: Unable to allocate memory for compd\\n\");\n        break;\n    }\n    memcpy(compd, unpd, szd);\n    memset(unpd, -1, szd); /*FIXME*/\n    ccur=compd;\n    \n    RESEED;\n    while(!error) {\n      uint32_t backbytes, backsize;\n      uint8_t saved;\n\n      BIT;\n      if (!bits) { /* BYTE copy */\n\tif(ccur-compd>=szd || !CLI_ISCONTAINED(exe, exesz, ucur, 1))\n\t  error=1;\n\telse\n\t  *ucur++=*ccur++;\n\tcontinue;\n      }\n\n      BITS(2);\n      if(bits==3) { /* WORD backcopy */\n\tuint8_t shifted, subbed = 31;\n\tBITS(2);\n\tshifted = bits + 5;\n\tif(bits>=2) {\n\t  shifted++;\n\t  subbed += 0x80;\n\t}\n\tbackbytes = (1<<shifted)-subbed; /* 1h, 21h, 61h, 161h */\n\tBITS(shifted); /* 5, 6, 8, 9 */\n\tif(error || bits == 0x1ff) break;\n\tbackbytes+=bits;\n\tif(!CLI_ISCONTAINED(exe, exesz, ucur, 2) || !CLI_ISCONTAINED(exe, exesz, ucur-backbytes, 2)) {\n\t  error=1;\n\t} else {\n\t  ucur[0]=*(ucur-backbytes);\n\t  ucur[1]=*(ucur-backbytes+1);\n\t  ucur+=2;\n\t}\n\tcontinue;\n      }\n\n      /* BLOCK backcopy */\n      saved = bits; /* cmp al, 1 / pushf */\n\n      BITS(3);\n      if (bits<6) {\n\tbackbytes = bits;\n\tswitch(bits) {\n\tcase 4: /* 10,11 */\n\t  backbytes++;\n\tcase 3: /* 8,9 */\n\t  BIT;\n\t  backbytes+=bits;\n\tcase 0:\tcase 1:\tcase 2: /* 5,6,7 */\n\t  backbytes+=5;\n\t  break;\n\tcase 5: /* 12 */\n\t  backbytes=12;\n\t  break;\n\t}\n\tBITS(backbytes);\n\tbits+=(1<<backbytes)-31;\n      } else if(bits==6) {\n\tBITS(0x0e);\n\tbits+=0x1fe1;\n      } else {\n\tBITS(0x0f);\n\tbits+=0x5fe1;\n      }\n\n      backbytes = bits;\n\n      /* popf / jb */\n      if (!saved) {\n\tBIT;\n\tif(!bits) {\n\t  BIT;\n\t  bits+=5;\n\t} else {\n\t  BITS(3);\n\t  if(bits) {\n\t    bits+=6;\n\t  } else {\n\t    BITS(4);\n\t    if(bits) {\n\t      bits+=13;\n\t    } else {\n\t      uint8_t cnt = 4;\n\t      uint16_t shifted = 0x0d;\n\t      \n\t      do {\n\t\tif(cnt==7) { cnt = 0x0e; shifted = 0; break; }\n\t\tshifted=((shifted+2)<<1)-1;\n\t\tBIT;\n\t\tcnt++;\n\t      } while(!bits);\n\t      BITS(cnt);\n\t      bits+=shifted;\n\t    }\n\t  }\n\t}\n\tbacksize = bits;\n      } else {\n\tbacksize = saved+2;\n      }\n\n      if(!CLI_ISCONTAINED(exe, exesz, ucur, backsize) || !CLI_ISCONTAINED(exe, exesz, ucur-backbytes, backsize)) error=1;\n      else while(backsize--) {\n\t*ucur=*(ucur-backbytes);\n\tucur++;\n      }\n    }\n    free(compd);\n    if(error) {\n      cli_dbgmsg(\"WWPack: decompression error\\n\");\n      break;\n    }\n    if (error || !*structs++) break;\n  }\n\n  if(!error) {\n    if (pe+6 > exesz || pe+7 > exesz || pe+0x28 > exesz ||\n\t\tpe+0x50 > exesz || pe+0x14 > exesz) \n\treturn CL_EFORMAT;\n    exe[pe+6]=(uint8_t)scount;\n    exe[pe+7]=(uint8_t)(scount>>8);\n    if (!CLI_ISCONTAINED(wwsect, sects[scount].rsz, wwsect+0x295, 4) ||\n        !CLI_ISCONTAINED(wwsect, sects[scount].rsz, wwsect+0x295+sects[scount].rva, 4) ||\n        !CLI_ISCONTAINED(wwsect, sects[scount].rsz, wwsect+0x295+sects[scount].rva+0x299, 4)) {\n        cli_dbgmsg(\"WWPack: unpack memory address out of bounds.\\n\");\n        return CL_EFORMAT;\n    }\n    cli_writeint32(&exe[pe+0x28], cli_readint32(wwsect+0x295)+sects[scount].rva+0x299);\n    cli_writeint32(&exe[pe+0x50], cli_readint32(&exe[pe+0x50])-sects[scount].vsz);\n\n    structs = &exe[(0xffff&cli_readint32(&exe[pe+0x14]))+pe+0x18];\n    for(i=0 ; i<scount ; i++) {\n\t  if (!CLI_ISCONTAINED(exe, exesz, structs, 0x28)) {\n\t    cli_dbgmsg(\"WWPack: structs pointer out of bounds\\n\");\n\t    return CL_EFORMAT;\n\t  }\n\n      cli_writeint32(structs+8, sects[i].vsz);\n      cli_writeint32(structs+12, sects[i].rva);\n      cli_writeint32(structs+16, sects[i].vsz);\n      cli_writeint32(structs+20, sects[i].rva);\n      structs+=0x28;\n    }\n\tif (!CLI_ISCONTAINED(exe, exesz, structs, 0x28)) {\n\t  cli_dbgmsg(\"WWPack: structs pointer out of bounds\\n\");\n\t  return CL_EFORMAT;\n\t}\n\n    memset(structs, 0, 0x28);\n    error = (uint32_t)cli_writen(desc, exe, exesz)!=exesz;\n  }\n  return error;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149839,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "int __ext4_journal_stop(const char *where, unsigned int line, handle_t *handle)\n{\n\tstruct super_block *sb;\n\tint err;\n\tint rc;\n\n\tif (!ext4_handle_valid(handle)) {\n\t\text4_put_nojournal(handle);\n\t\treturn 0;\n\t}\n\n\tif (!handle->h_transaction) {\n\t\terr = jbd2_journal_stop(handle);\n\t\treturn handle->h_err ? handle->h_err : err;\n\t}\n\n\tsb = handle->h_transaction->t_journal->j_private;\n\terr = handle->h_err;\n\trc = jbd2_journal_stop(handle);\n\n\tif (!err)\n\t\terr = rc;\n\tif (err)\n\t\t__ext4_std_error(sb, where, line, err);\n\treturn err;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149840,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "int __ext4_journal_stop(const char *where, unsigned int line, handle_t *handle)\n{\n\tstruct super_block *sb;\n\tint err;\n\tint rc;\n\n\tif (!ext4_handle_valid(handle)) {\n\t\text4_put_nojournal(handle);\n\t\treturn 0;\n\t}\n\n\terr = handle->h_err;\n\tif (!handle->h_transaction) {\n\t\trc = jbd2_journal_stop(handle);\n\t\treturn err ? err : rc;\n\t}\n\n\tsb = handle->h_transaction->t_journal->j_private;\n\trc = jbd2_journal_stop(handle);\n\n\tif (!err)\n\t\terr = rc;\n\tif (err)\n\t\t__ext4_std_error(sb, where, line, err);\n\treturn err;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149841,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "int blk_rq_map_user_iov(struct request_queue *q, struct request *rq,\n\t\t\tstruct rq_map_data *map_data,\n\t\t\tconst struct iov_iter *iter, gfp_t gfp_mask)\n{\n\tbool copy = false;\n\tunsigned long align = q->dma_pad_mask | queue_dma_alignment(q);\n\tstruct bio *bio = NULL;\n\tstruct iov_iter i;\n\tint ret;\n\n\tif (map_data)\n\t\tcopy = true;\n\telse if (iov_iter_alignment(iter) & align)\n\t\tcopy = true;\n\telse if (queue_virt_boundary(q))\n\t\tcopy = queue_virt_boundary(q) & iov_iter_gap_alignment(iter);\n\n\ti = *iter;\n\tdo {\n\t\tret =__blk_rq_map_user_iov(rq, map_data, &i, gfp_mask, copy);\n\t\tif (ret)\n\t\t\tgoto unmap_rq;\n\t\tif (!bio)\n\t\t\tbio = rq->bio;\n\t} while (iov_iter_count(&i));\n\n\tif (!bio_flagged(bio, BIO_USER_MAPPED))\n\t\trq->cmd_flags |= REQ_COPY_USER;\n\treturn 0;\n\nunmap_rq:\n\t__blk_rq_unmap_user(bio);\n\trq->bio = NULL;\n\treturn -EINVAL;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149842,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "int blk_rq_map_user_iov(struct request_queue *q, struct request *rq,\n\t\t\tstruct rq_map_data *map_data,\n\t\t\tconst struct iov_iter *iter, gfp_t gfp_mask)\n{\n\tbool copy = false;\n\tunsigned long align = q->dma_pad_mask | queue_dma_alignment(q);\n\tstruct bio *bio = NULL;\n\tstruct iov_iter i;\n\tint ret;\n\n\tif (!iter_is_iovec(iter))\n\t\tgoto fail;\n\n\tif (map_data)\n\t\tcopy = true;\n\telse if (iov_iter_alignment(iter) & align)\n\t\tcopy = true;\n\telse if (queue_virt_boundary(q))\n\t\tcopy = queue_virt_boundary(q) & iov_iter_gap_alignment(iter);\n\n\ti = *iter;\n\tdo {\n\t\tret =__blk_rq_map_user_iov(rq, map_data, &i, gfp_mask, copy);\n\t\tif (ret)\n\t\t\tgoto unmap_rq;\n\t\tif (!bio)\n\t\t\tbio = rq->bio;\n\t} while (iov_iter_count(&i));\n\n\tif (!bio_flagged(bio, BIO_USER_MAPPED))\n\t\trq->cmd_flags |= REQ_COPY_USER;\n\treturn 0;\n\nunmap_rq:\n\t__blk_rq_unmap_user(bio);\nfail:\n\trq->bio = NULL;\n\treturn -EINVAL;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149843,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int mif_process_cmpt(mif_hdr_t *hdr, char *buf)\n{\n\tjas_tvparser_t *tvp;\n\tmif_cmpt_t *cmpt;\n\tint id;\n\n\tcmpt = 0;\n\ttvp = 0;\n\n\tif (!(cmpt = mif_cmpt_create())) {\n\t\tgoto error;\n\t}\n\tcmpt->tlx = 0;\n\tcmpt->tly = 0;\n\tcmpt->sampperx = 0;\n\tcmpt->samppery = 0;\n\tcmpt->width = 0;\n\tcmpt->height = 0;\n\tcmpt->prec = 0;\n\tcmpt->sgnd = -1;\n\tcmpt->data = 0;\n\n\tif (!(tvp = jas_tvparser_create(buf))) {\n\t\tgoto error;\n\t}\n\twhile (!(id = jas_tvparser_next(tvp))) {\n\t\tswitch (jas_taginfo_nonull(jas_taginfos_lookup(mif_tags,\n\t\t  jas_tvparser_gettag(tvp)))->id) {\n\t\tcase MIF_TLX:\n\t\t\tcmpt->tlx = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_TLY:\n\t\t\tcmpt->tly = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_WIDTH:\n\t\t\tcmpt->width = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_HEIGHT:\n\t\t\tcmpt->height = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_HSAMP:\n\t\t\tcmpt->sampperx = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_VSAMP:\n\t\t\tcmpt->samppery = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_PREC:\n\t\t\tcmpt->prec = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_SGND:\n\t\t\tcmpt->sgnd = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_DATA:\n\t\t\tif (!(cmpt->data = jas_strdup(jas_tvparser_getval(tvp)))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tjas_tvparser_destroy(tvp);\n\tif (!cmpt->sampperx || !cmpt->samppery) {\n\t\tgoto error;\n\t}\n\tif (mif_hdr_addcmpt(hdr, hdr->numcmpts, cmpt)) {\n\t\tgoto error;\n\t}\n\treturn 0;\n\nerror:\n\tif (cmpt) {\n\t\tmif_cmpt_destroy(cmpt);\n\t}\n\tif (tvp) {\n\t\tjas_tvparser_destroy(tvp);\n\t}\n\treturn -1;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149844,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int mif_process_cmpt(mif_hdr_t *hdr, char *buf)\n{\n\tjas_tvparser_t *tvp;\n\tmif_cmpt_t *cmpt;\n\tint id;\n\n\tcmpt = 0;\n\ttvp = 0;\n\n\tif (!(cmpt = mif_cmpt_create())) {\n\t\tgoto error;\n\t}\n\tcmpt->tlx = 0;\n\tcmpt->tly = 0;\n\tcmpt->sampperx = 0;\n\tcmpt->samppery = 0;\n\tcmpt->width = 0;\n\tcmpt->height = 0;\n\tcmpt->prec = 0;\n\tcmpt->sgnd = -1;\n\tcmpt->data = 0;\n\n\tif (!(tvp = jas_tvparser_create(buf))) {\n\t\tgoto error;\n\t}\n\twhile (!(id = jas_tvparser_next(tvp))) {\n\t\tswitch (jas_taginfo_nonull(jas_taginfos_lookup(mif_tags,\n\t\t  jas_tvparser_gettag(tvp)))->id) {\n\t\tcase MIF_TLX:\n\t\t\tcmpt->tlx = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_TLY:\n\t\t\tcmpt->tly = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_WIDTH:\n\t\t\tcmpt->width = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_HEIGHT:\n\t\t\tcmpt->height = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_HSAMP:\n\t\t\tcmpt->sampperx = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_VSAMP:\n\t\t\tcmpt->samppery = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_PREC:\n\t\t\tcmpt->prec = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_SGND:\n\t\t\tcmpt->sgnd = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_DATA:\n\t\t\tif (!(cmpt->data = jas_strdup(jas_tvparser_getval(tvp)))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!cmpt->sampperx || !cmpt->samppery) {\n\t\tgoto error;\n\t}\n\tif (mif_hdr_addcmpt(hdr, hdr->numcmpts, cmpt)) {\n\t\tgoto error;\n\t}\n\tjas_tvparser_destroy(tvp);\n\treturn 0;\n\nerror:\n\tif (cmpt) {\n\t\tmif_cmpt_destroy(cmpt);\n\t}\n\tif (tvp) {\n\t\tjas_tvparser_destroy(tvp);\n\t}\n\treturn -1;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149845,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "onig_new_deluxe(regex_t** reg, const UChar* pattern, const UChar* pattern_end,\n                OnigCompileInfo* ci, OnigErrorInfo* einfo)\n{\n  int r;\n  UChar *cpat, *cpat_end;\n\n  if (IS_NOT_NULL(einfo)) einfo->par = (UChar* )NULL;\n\n  if (ci->pattern_enc != ci->target_enc) {\n    r = conv_encoding(ci->pattern_enc, ci->target_enc, pattern, pattern_end,\n                      &cpat, &cpat_end);\n    if (r != 0) return r;\n  }\n  else {\n    cpat     = (UChar* )pattern;\n    cpat_end = (UChar* )pattern_end;\n  }\n\n  *reg = (regex_t* )xmalloc(sizeof(regex_t));\n  if (IS_NULL(*reg)) {\n    r = ONIGERR_MEMORY;\n    goto err2;\n  }\n\n  r = onig_reg_init(*reg, ci->option, ci->case_fold_flag, ci->target_enc,\n                    ci->syntax);\n  if (r != 0) goto err;\n\n  r = onig_compile(*reg, cpat, cpat_end, einfo);\n  if (r != 0) {\n  err:\n    onig_free(*reg);\n    *reg = NULL;\n  }\n\n err2:\n  if (cpat != pattern) xfree(cpat);\n\n  return r;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149846,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "onig_new_deluxe(regex_t** reg, const UChar* pattern, const UChar* pattern_end,\n                OnigCompileInfo* ci, OnigErrorInfo* einfo)\n{\n  int r;\n  UChar *cpat, *cpat_end;\n\n  if (IS_NOT_NULL(einfo)) einfo->par = (UChar* )NULL;\n\n  if (ci->pattern_enc != ci->target_enc) {\n    return ONIGERR_NOT_SUPPORTED_ENCODING_COMBINATION;\n  }\n  else {\n    cpat     = (UChar* )pattern;\n    cpat_end = (UChar* )pattern_end;\n  }\n\n  *reg = (regex_t* )xmalloc(sizeof(regex_t));\n  if (IS_NULL(*reg)) {\n    r = ONIGERR_MEMORY;\n    goto err2;\n  }\n\n  r = onig_reg_init(*reg, ci->option, ci->case_fold_flag, ci->target_enc,\n                    ci->syntax);\n  if (r != 0) goto err;\n\n  r = onig_compile(*reg, cpat, cpat_end, einfo);\n  if (r != 0) {\n  err:\n    onig_free(*reg);\n    *reg = NULL;\n  }\n\n err2:\n  if (cpat != pattern) xfree(cpat);\n\n  return r;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149847,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "void usb_sg_cancel(struct usb_sg_request *io)\n{\n\tunsigned long flags;\n\tint i, retval;\n\n\tspin_lock_irqsave(&io->lock, flags);\n\tif (io->status) {\n\t\tspin_unlock_irqrestore(&io->lock, flags);\n\t\treturn;\n\t}\n\t/* shut everything down */\n\tio->status = -ECONNRESET;\n\tspin_unlock_irqrestore(&io->lock, flags);\n\n\tfor (i = io->entries - 1; i >= 0; --i) {\n\t\tusb_block_urb(io->urbs[i]);\n\n\t\tretval = usb_unlink_urb(io->urbs[i]);\n\t\tif (retval != -EINPROGRESS\n\t\t    && retval != -ENODEV\n\t\t    && retval != -EBUSY\n\t\t    && retval != -EIDRM)\n\t\t\tdev_warn(&io->dev->dev, \"%s, unlink --> %d\\n\",\n\t\t\t\t __func__, retval);\n\t}\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149848,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "void usb_sg_cancel(struct usb_sg_request *io)\n{\n\tunsigned long flags;\n\tint i, retval;\n\n\tspin_lock_irqsave(&io->lock, flags);\n\tif (io->status || io->count == 0) {\n\t\tspin_unlock_irqrestore(&io->lock, flags);\n\t\treturn;\n\t}\n\t/* shut everything down */\n\tio->status = -ECONNRESET;\n\tio->count++;\t\t/* Keep the request alive until we're done */\n\tspin_unlock_irqrestore(&io->lock, flags);\n\n\tfor (i = io->entries - 1; i >= 0; --i) {\n\t\tusb_block_urb(io->urbs[i]);\n\n\t\tretval = usb_unlink_urb(io->urbs[i]);\n\t\tif (retval != -EINPROGRESS\n\t\t    && retval != -ENODEV\n\t\t    && retval != -EBUSY\n\t\t    && retval != -EIDRM)\n\t\t\tdev_warn(&io->dev->dev, \"%s, unlink --> %d\\n\",\n\t\t\t\t __func__, retval);\n\t}\n\n\tspin_lock_irqsave(&io->lock, flags);\n\tio->count--;\n\tif (!io->count)\n\t\tcomplete(&io->complete);\n\tspin_unlock_irqrestore(&io->lock, flags);\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149849,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "void ip4_datagram_release_cb(struct sock *sk)\n{\n\tconst struct inet_sock *inet = inet_sk(sk);\n\tconst struct ip_options_rcu *inet_opt;\n\t__be32 daddr = inet->inet_daddr;\n\tstruct flowi4 fl4;\n\tstruct rtable *rt;\n\n\tif (! __sk_dst_get(sk) || __sk_dst_check(sk, 0))\n\t\treturn;\n\n\trcu_read_lock();\n\tinet_opt = rcu_dereference(inet->inet_opt);\n\tif (inet_opt && inet_opt->opt.srr)\n\t\tdaddr = inet_opt->opt.faddr;\n\trt = ip_route_output_ports(sock_net(sk), &fl4, sk, daddr,\n\t\t\t\t   inet->inet_saddr, inet->inet_dport,\n\t\t\t\t   inet->inet_sport, sk->sk_protocol,\n\t\t\t\t   RT_CONN_FLAGS(sk), sk->sk_bound_dev_if);\n\tif (!IS_ERR(rt))\n\t\t__sk_dst_set(sk, &rt->dst);\n\trcu_read_unlock();\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149850,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "void ip4_datagram_release_cb(struct sock *sk)\n{\n\tconst struct inet_sock *inet = inet_sk(sk);\n\tconst struct ip_options_rcu *inet_opt;\n\t__be32 daddr = inet->inet_daddr;\n\tstruct dst_entry *dst;\n\tstruct flowi4 fl4;\n\tstruct rtable *rt;\n\n\trcu_read_lock();\n\n\tdst = __sk_dst_get(sk);\n\tif (!dst || !dst->obsolete || dst->ops->check(dst, 0)) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\tinet_opt = rcu_dereference(inet->inet_opt);\n\tif (inet_opt && inet_opt->opt.srr)\n\t\tdaddr = inet_opt->opt.faddr;\n\trt = ip_route_output_ports(sock_net(sk), &fl4, sk, daddr,\n\t\t\t\t   inet->inet_saddr, inet->inet_dport,\n\t\t\t\t   inet->inet_sport, sk->sk_protocol,\n\t\t\t\t   RT_CONN_FLAGS(sk), sk->sk_bound_dev_if);\n\n\tdst = !IS_ERR(rt) ? &rt->dst : NULL;\n\tsk_dst_set(sk, dst);\n\n\trcu_read_unlock();\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149851,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "mark_context_stack(mrb_state *mrb, struct mrb_context *c)\n{\n  size_t i;\n  size_t e;\n\n  if (c->stack == NULL) return;\n  e = c->stack - c->stbase;\n  if (c->ci) e += c->ci->nregs;\n  if (c->stbase + e > c->stend) e = c->stend - c->stbase;\n  for (i=0; i<e; i++) {\n    mrb_value v = c->stbase[i];\n\n    if (!mrb_immediate_p(v)) {\n      if (mrb_basic_ptr(v)->tt == MRB_TT_FREE) {\n        c->stbase[i] = mrb_nil_value();\n      }\n      else {\n        mrb_gc_mark(mrb, mrb_basic_ptr(v));\n      }\n    }\n  }\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149852,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "mark_context_stack(mrb_state *mrb, struct mrb_context *c)\n{\n  size_t i;\n  size_t e;\n  mrb_value nil;\n\n  if (c->stack == NULL) return;\n  e = c->stack - c->stbase;\n  if (c->ci) e += c->ci->nregs;\n  if (c->stbase + e > c->stend) e = c->stend - c->stbase;\n  for (i=0; i<e; i++) {\n    mrb_value v = c->stbase[i];\n\n    if (!mrb_immediate_p(v)) {\n      mrb_gc_mark(mrb, mrb_basic_ptr(v));\n    }\n  }\n  e = c->stend - c->stbase;\n  nil = mrb_nil_value();\n  for (; i<e; i++) {\n    c->stbase[i] = nil;\n  }\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149853,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "int shadow_server_start(rdpShadowServer* server)\n{\n\tBOOL ipc;\n\tBOOL status;\n\tWSADATA wsaData;\n\n\tif (!server)\n\t\treturn -1;\n\n\tif (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0)\n\t\treturn -1;\n\n#ifndef _WIN32\n\tsignal(SIGPIPE, SIG_IGN);\n#endif\n\tserver->screen = shadow_screen_new(server);\n\n\tif (!server->screen)\n\t{\n\t\tWLog_ERR(TAG, \"screen_new failed\");\n\t\treturn -1;\n\t}\n\n\tserver->capture = shadow_capture_new(server);\n\n\tif (!server->capture)\n\t{\n\t\tWLog_ERR(TAG, \"capture_new failed\");\n\t\treturn -1;\n\t}\n\n\t/* Bind magic:\n\t *\n\t * emtpy                 ... bind TCP all\n\t * <local path>          ... bind local (IPC)\n\t * bind-socket,<address> ... bind TCP to specified interface\n\t */\n\tipc = server->ipcSocket && (strncmp(bind_address, server->ipcSocket,\n\t                                    strnlen(bind_address, sizeof(bind_address))) != 0);\n\tif (!ipc)\n\t{\n\t\tsize_t x, count;\n\t\tchar** list = CommandLineParseCommaSeparatedValuesEx(NULL, server->ipcSocket, &count);\n\t\tif (!list || (count <= 1))\n\t\t{\n\t\t\tfree(list);\n\t\t\tif (server->ipcSocket == NULL)\n\t\t\t{\n\t\t\t\tif (!open_port(server, NULL))\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tfor (x = 1; x < count; x++)\n\t\t{\n\t\t\tBOOL success = open_port(server, list[x]);\n\t\t\tif (!success)\n\t\t\t{\n\t\t\t\tfree(list);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(list);\n\t}\n\telse\n\t{\n\t\tstatus = server->listener->OpenLocal(server->listener, server->ipcSocket);\n\t\tif (!status)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Problem creating local socket listener. (Port already used or \"\n\t\t\t              \"insufficient permissions?)\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (!(server->thread = CreateThread(NULL, 0, shadow_server_thread, (void*)server, 0, NULL)))\n\t{\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149854,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "int shadow_server_start(rdpShadowServer* server)\n{\n\tBOOL ipc;\n\tBOOL status;\n\tWSADATA wsaData;\n\n\tif (!server)\n\t\treturn -1;\n\n\tif (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0)\n\t\treturn -1;\n\n#ifndef _WIN32\n\tsignal(SIGPIPE, SIG_IGN);\n#endif\n\tserver->screen = shadow_screen_new(server);\n\n\tif (!server->screen)\n\t{\n\t\tWLog_ERR(TAG, \"screen_new failed\");\n\t\treturn -1;\n\t}\n\n\tserver->capture = shadow_capture_new(server);\n\n\tif (!server->capture)\n\t{\n\t\tWLog_ERR(TAG, \"capture_new failed\");\n\t\treturn -1;\n\t}\n\n\t/* Bind magic:\n\t *\n\t * emtpy                 ... bind TCP all\n\t * <local path>          ... bind local (IPC)\n\t * bind-socket,<address> ... bind TCP to specified interface\n\t */\n\tipc = server->ipcSocket && (strncmp(bind_address, server->ipcSocket,\n\t                                    strnlen(bind_address, sizeof(bind_address))) != 0);\n\tif (!ipc)\n\t{\n\t\tsize_t x, count;\n\t\tchar** list = CommandLineParseCommaSeparatedValuesEx(NULL, server->ipcSocket, &count);\n\t\tif (!list || (count <= 1))\n\t\t{\n\t\t\tif (server->ipcSocket == NULL)\n\t\t\t{\n\t\t\t\tif (!open_port(server, NULL))\n\t\t\t\t{\n\t\t\t\t\tfree(list);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfree(list);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tfor (x = 1; x < count; x++)\n\t\t{\n\t\t\tBOOL success = open_port(server, list[x]);\n\t\t\tif (!success)\n\t\t\t{\n\t\t\t\tfree(list);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(list);\n\t}\n\telse\n\t{\n\t\tstatus = server->listener->OpenLocal(server->listener, server->ipcSocket);\n\t\tif (!status)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Problem creating local socket listener. (Port already used or \"\n\t\t\t              \"insufficient permissions?)\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (!(server->thread = CreateThread(NULL, 0, shadow_server_thread, (void*)server, 0, NULL)))\n\t{\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149855,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "CURLcode Curl_close(struct Curl_easy *data)\n{\n  struct Curl_multi *m;\n\n  if(!data)\n    return CURLE_OK;\n\n  Curl_expire_clear(data); /* shut off timers */\n\n  m = data->multi;\n  if(m)\n    /* This handle is still part of a multi handle, take care of this first\n       and detach this handle from there. */\n    curl_multi_remove_handle(data->multi, data);\n\n  if(data->multi_easy)\n    /* when curl_easy_perform() is used, it creates its own multi handle to\n       use and this is the one */\n    curl_multi_cleanup(data->multi_easy);\n\n  /* Destroy the timeout list that is held in the easy handle. It is\n     /normally/ done by curl_multi_remove_handle() but this is \"just in\n     case\" */\n  Curl_llist_destroy(&data->state.timeoutlist, NULL);\n\n  data->magic = 0; /* force a clear AFTER the possibly enforced removal from\n                      the multi handle, since that function uses the magic\n                      field! */\n\n  if(data->state.rangestringalloc)\n    free(data->state.range);\n\n  /* freed here just in case DONE wasn't called */\n  Curl_free_request_state(data);\n\n  /* Close down all open SSL info and sessions */\n  Curl_ssl_close_all(data);\n  Curl_safefree(data->state.first_host);\n  Curl_safefree(data->state.scratch);\n  Curl_ssl_free_certinfo(data);\n\n  /* Cleanup possible redirect junk */\n  free(data->req.newurl);\n  data->req.newurl = NULL;\n\n  if(data->change.referer_alloc) {\n    Curl_safefree(data->change.referer);\n    data->change.referer_alloc = FALSE;\n  }\n  data->change.referer = NULL;\n\n  Curl_up_free(data);\n  Curl_safefree(data->state.buffer);\n  Curl_safefree(data->state.headerbuff);\n  Curl_safefree(data->state.ulbuf);\n  Curl_flush_cookies(data, 1);\n  Curl_digest_cleanup(data);\n  Curl_safefree(data->info.contenttype);\n  Curl_safefree(data->info.wouldredirect);\n\n  /* this destroys the channel and we cannot use it anymore after this */\n  Curl_resolver_cleanup(data->state.resolver);\n\n  Curl_http2_cleanup_dependencies(data);\n  Curl_convert_close(data);\n\n  /* No longer a dirty share, if it exists */\n  if(data->share) {\n    Curl_share_lock(data, CURL_LOCK_DATA_SHARE, CURL_LOCK_ACCESS_SINGLE);\n    data->share->dirty--;\n    Curl_share_unlock(data, CURL_LOCK_DATA_SHARE);\n  }\n\n  /* destruct wildcard structures if it is needed */\n  Curl_wildcard_dtor(&data->wildcard);\n  Curl_freeset(data);\n  free(data);\n  return CURLE_OK;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149856,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "CURLcode Curl_close(struct Curl_easy *data)\n{\n  struct Curl_multi *m;\n\n  if(!data)\n    return CURLE_OK;\n\n  Curl_expire_clear(data); /* shut off timers */\n\n  m = data->multi;\n  if(m)\n    /* This handle is still part of a multi handle, take care of this first\n       and detach this handle from there. */\n    curl_multi_remove_handle(data->multi, data);\n\n  if(data->multi_easy) {\n    /* when curl_easy_perform() is used, it creates its own multi handle to\n       use and this is the one */\n    curl_multi_cleanup(data->multi_easy);\n    data->multi_easy = NULL;\n  }\n\n  /* Destroy the timeout list that is held in the easy handle. It is\n     /normally/ done by curl_multi_remove_handle() but this is \"just in\n     case\" */\n  Curl_llist_destroy(&data->state.timeoutlist, NULL);\n\n  data->magic = 0; /* force a clear AFTER the possibly enforced removal from\n                      the multi handle, since that function uses the magic\n                      field! */\n\n  if(data->state.rangestringalloc)\n    free(data->state.range);\n\n  /* freed here just in case DONE wasn't called */\n  Curl_free_request_state(data);\n\n  /* Close down all open SSL info and sessions */\n  Curl_ssl_close_all(data);\n  Curl_safefree(data->state.first_host);\n  Curl_safefree(data->state.scratch);\n  Curl_ssl_free_certinfo(data);\n\n  /* Cleanup possible redirect junk */\n  free(data->req.newurl);\n  data->req.newurl = NULL;\n\n  if(data->change.referer_alloc) {\n    Curl_safefree(data->change.referer);\n    data->change.referer_alloc = FALSE;\n  }\n  data->change.referer = NULL;\n\n  Curl_up_free(data);\n  Curl_safefree(data->state.buffer);\n  Curl_safefree(data->state.headerbuff);\n  Curl_safefree(data->state.ulbuf);\n  Curl_flush_cookies(data, 1);\n  Curl_digest_cleanup(data);\n  Curl_safefree(data->info.contenttype);\n  Curl_safefree(data->info.wouldredirect);\n\n  /* this destroys the channel and we cannot use it anymore after this */\n  Curl_resolver_cleanup(data->state.resolver);\n\n  Curl_http2_cleanup_dependencies(data);\n  Curl_convert_close(data);\n\n  /* No longer a dirty share, if it exists */\n  if(data->share) {\n    Curl_share_lock(data, CURL_LOCK_DATA_SHARE, CURL_LOCK_ACCESS_SINGLE);\n    data->share->dirty--;\n    Curl_share_unlock(data, CURL_LOCK_DATA_SHARE);\n  }\n\n  /* destruct wildcard structures if it is needed */\n  Curl_wildcard_dtor(&data->wildcard);\n  Curl_freeset(data);\n  free(data);\n  return CURLE_OK;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149857,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "ExprAppendMultiKeysymList(ExprDef *expr, ExprDef *append)\n{\n    unsigned nSyms = darray_size(expr->keysym_list.syms);\n    unsigned numEntries = darray_size(append->keysym_list.syms);\n\n    darray_append(expr->keysym_list.symsMapIndex, nSyms);\n    darray_append(expr->keysym_list.symsNumEntries, numEntries);\n    darray_concat(expr->keysym_list.syms, append->keysym_list.syms);\n\n    FreeStmt((ParseCommon *) &append);\n\n    return expr;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149858,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "ExprAppendMultiKeysymList(ExprDef *expr, ExprDef *append)\n{\n    unsigned nSyms = darray_size(expr->keysym_list.syms);\n    unsigned numEntries = darray_size(append->keysym_list.syms);\n\n    darray_append(expr->keysym_list.symsMapIndex, nSyms);\n    darray_append(expr->keysym_list.symsNumEntries, numEntries);\n    darray_concat(expr->keysym_list.syms, append->keysym_list.syms);\n\n    FreeStmt((ParseCommon *) append);\n\n    return expr;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149859,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static struct mm_struct *mm_init(struct mm_struct *mm, struct task_struct *p,\n\tstruct user_namespace *user_ns)\n{\n\tmm->mmap = NULL;\n\tmm->mm_rb = RB_ROOT;\n\tmm->vmacache_seqnum = 0;\n\tatomic_set(&mm->mm_users, 1);\n\tatomic_set(&mm->mm_count, 1);\n\tinit_rwsem(&mm->mmap_sem);\n\tINIT_LIST_HEAD(&mm->mmlist);\n\tmm->core_state = NULL;\n\tatomic_long_set(&mm->nr_ptes, 0);\n\tmm_nr_pmds_init(mm);\n\tmm->map_count = 0;\n\tmm->locked_vm = 0;\n\tmm->pinned_vm = 0;\n\tmemset(&mm->rss_stat, 0, sizeof(mm->rss_stat));\n\tspin_lock_init(&mm->page_table_lock);\n\tmm_init_cpumask(mm);\n\tmm_init_aio(mm);\n\tmm_init_owner(mm, p);\n\tmmu_notifier_mm_init(mm);\n\tinit_tlb_flush_pending(mm);\n#if defined(CONFIG_TRANSPARENT_HUGEPAGE) && !USE_SPLIT_PMD_PTLOCKS\n\tmm->pmd_huge_pte = NULL;\n#endif\n\n\tif (current->mm) {\n\t\tmm->flags = current->mm->flags & MMF_INIT_MASK;\n\t\tmm->def_flags = current->mm->def_flags & VM_INIT_DEF_MASK;\n\t} else {\n\t\tmm->flags = default_dump_filter;\n\t\tmm->def_flags = 0;\n\t}\n\n\tif (mm_alloc_pgd(mm))\n\t\tgoto fail_nopgd;\n\n\tif (init_new_context(p, mm))\n\t\tgoto fail_nocontext;\n\n\tmm->user_ns = get_user_ns(user_ns);\n\treturn mm;\n\nfail_nocontext:\n\tmm_free_pgd(mm);\nfail_nopgd:\n\tfree_mm(mm);\n\treturn NULL;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149860,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static struct mm_struct *mm_init(struct mm_struct *mm, struct task_struct *p,\n\tstruct user_namespace *user_ns)\n{\n\tmm->mmap = NULL;\n\tmm->mm_rb = RB_ROOT;\n\tmm->vmacache_seqnum = 0;\n\tatomic_set(&mm->mm_users, 1);\n\tatomic_set(&mm->mm_count, 1);\n\tinit_rwsem(&mm->mmap_sem);\n\tINIT_LIST_HEAD(&mm->mmlist);\n\tmm->core_state = NULL;\n\tatomic_long_set(&mm->nr_ptes, 0);\n\tmm_nr_pmds_init(mm);\n\tmm->map_count = 0;\n\tmm->locked_vm = 0;\n\tmm->pinned_vm = 0;\n\tmemset(&mm->rss_stat, 0, sizeof(mm->rss_stat));\n\tspin_lock_init(&mm->page_table_lock);\n\tmm_init_cpumask(mm);\n\tmm_init_aio(mm);\n\tmm_init_owner(mm, p);\n\tRCU_INIT_POINTER(mm->exe_file, NULL);\n\tmmu_notifier_mm_init(mm);\n\tinit_tlb_flush_pending(mm);\n#if defined(CONFIG_TRANSPARENT_HUGEPAGE) && !USE_SPLIT_PMD_PTLOCKS\n\tmm->pmd_huge_pte = NULL;\n#endif\n\n\tif (current->mm) {\n\t\tmm->flags = current->mm->flags & MMF_INIT_MASK;\n\t\tmm->def_flags = current->mm->def_flags & VM_INIT_DEF_MASK;\n\t} else {\n\t\tmm->flags = default_dump_filter;\n\t\tmm->def_flags = 0;\n\t}\n\n\tif (mm_alloc_pgd(mm))\n\t\tgoto fail_nopgd;\n\n\tif (init_new_context(p, mm))\n\t\tgoto fail_nocontext;\n\n\tmm->user_ns = get_user_ns(user_ns);\n\treturn mm;\n\nfail_nocontext:\n\tmm_free_pgd(mm);\nfail_nopgd:\n\tfree_mm(mm);\n\treturn NULL;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149861,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "PHP_MINIT_FUNCTION(spl_array)\n{\n\tREGISTER_SPL_STD_CLASS_EX(ArrayObject, spl_array_object_new, spl_funcs_ArrayObject);\n\tREGISTER_SPL_IMPLEMENTS(ArrayObject, Aggregate);\n\tREGISTER_SPL_IMPLEMENTS(ArrayObject, ArrayAccess);\n\tREGISTER_SPL_IMPLEMENTS(ArrayObject, Serializable);\n\tREGISTER_SPL_IMPLEMENTS(ArrayObject, Countable);\n\tmemcpy(&spl_handler_ArrayObject, zend_get_std_object_handlers(), sizeof(zend_object_handlers));\n\n\tspl_handler_ArrayObject.clone_obj = spl_array_object_clone;\n\tspl_handler_ArrayObject.read_dimension = spl_array_read_dimension;\n\tspl_handler_ArrayObject.write_dimension = spl_array_write_dimension;\n\tspl_handler_ArrayObject.unset_dimension = spl_array_unset_dimension;\n\tspl_handler_ArrayObject.has_dimension = spl_array_has_dimension;\n\tspl_handler_ArrayObject.count_elements = spl_array_object_count_elements;\n\n\tspl_handler_ArrayObject.get_properties = spl_array_get_properties;\n\tspl_handler_ArrayObject.get_debug_info = spl_array_get_debug_info;\n\tspl_handler_ArrayObject.get_gc = spl_array_get_gc;\n\tspl_handler_ArrayObject.read_property = spl_array_read_property;\n\tspl_handler_ArrayObject.write_property = spl_array_write_property;\n\tspl_handler_ArrayObject.get_property_ptr_ptr = spl_array_get_property_ptr_ptr;\n\tspl_handler_ArrayObject.has_property = spl_array_has_property;\n\tspl_handler_ArrayObject.unset_property = spl_array_unset_property;\n\n\tspl_handler_ArrayObject.compare_objects = spl_array_compare_objects;\n\n\tREGISTER_SPL_STD_CLASS_EX(ArrayIterator, spl_array_object_new, spl_funcs_ArrayIterator);\n\tREGISTER_SPL_IMPLEMENTS(ArrayIterator, Iterator);\n\tREGISTER_SPL_IMPLEMENTS(ArrayIterator, ArrayAccess);\n\tREGISTER_SPL_IMPLEMENTS(ArrayIterator, SeekableIterator);\n\tREGISTER_SPL_IMPLEMENTS(ArrayIterator, Serializable);\n\tREGISTER_SPL_IMPLEMENTS(ArrayIterator, Countable);\n\tmemcpy(&spl_handler_ArrayIterator, &spl_handler_ArrayObject, sizeof(zend_object_handlers));\n\tspl_ce_ArrayIterator->get_iterator = spl_array_get_iterator;\n\n\tREGISTER_SPL_SUB_CLASS_EX(RecursiveArrayIterator, ArrayIterator, spl_array_object_new, spl_funcs_RecursiveArrayIterator);\n\tREGISTER_SPL_IMPLEMENTS(RecursiveArrayIterator, RecursiveIterator);\n\tspl_ce_RecursiveArrayIterator->get_iterator = spl_array_get_iterator;\n\n\tREGISTER_SPL_CLASS_CONST_LONG(ArrayObject,   \"STD_PROP_LIST\",    SPL_ARRAY_STD_PROP_LIST);\n\tREGISTER_SPL_CLASS_CONST_LONG(ArrayObject,   \"ARRAY_AS_PROPS\",   SPL_ARRAY_ARRAY_AS_PROPS);\n\n\tREGISTER_SPL_CLASS_CONST_LONG(ArrayIterator, \"STD_PROP_LIST\",    SPL_ARRAY_STD_PROP_LIST);\n\tREGISTER_SPL_CLASS_CONST_LONG(ArrayIterator, \"ARRAY_AS_PROPS\",   SPL_ARRAY_ARRAY_AS_PROPS);\n\n\tREGISTER_SPL_CLASS_CONST_LONG(RecursiveArrayIterator, \"CHILD_ARRAYS_ONLY\", SPL_ARRAY_CHILD_ARRAYS_ONLY);\n\n\treturn SUCCESS;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149862,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static long do_get_mempolicy(int *policy, nodemask_t *nmask,\n\t\t\t     unsigned long addr, unsigned long flags)\n{\n\tint err;\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma = NULL;\n\tstruct mempolicy *pol = current->mempolicy;\n\n\tif (flags &\n\t\t~(unsigned long)(MPOL_F_NODE|MPOL_F_ADDR|MPOL_F_MEMS_ALLOWED))\n\t\treturn -EINVAL;\n\n\tif (flags & MPOL_F_MEMS_ALLOWED) {\n\t\tif (flags & (MPOL_F_NODE|MPOL_F_ADDR))\n\t\t\treturn -EINVAL;\n\t\t*policy = 0;\t/* just so it's initialized */\n\t\ttask_lock(current);\n\t\t*nmask  = cpuset_current_mems_allowed;\n\t\ttask_unlock(current);\n\t\treturn 0;\n\t}\n\n\tif (flags & MPOL_F_ADDR) {\n\t\t/*\n\t\t * Do NOT fall back to task policy if the\n\t\t * vma/shared policy at addr is NULL.  We\n\t\t * want to return MPOL_DEFAULT in this case.\n\t\t */\n\t\tdown_read(&mm->mmap_sem);\n\t\tvma = find_vma_intersection(mm, addr, addr+1);\n\t\tif (!vma) {\n\t\t\tup_read(&mm->mmap_sem);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tif (vma->vm_ops && vma->vm_ops->get_policy)\n\t\t\tpol = vma->vm_ops->get_policy(vma, addr);\n\t\telse\n\t\t\tpol = vma->vm_policy;\n\t} else if (addr)\n\t\treturn -EINVAL;\n\n\tif (!pol)\n\t\tpol = &default_policy;\t/* indicates default behavior */\n\n\tif (flags & MPOL_F_NODE) {\n\t\tif (flags & MPOL_F_ADDR) {\n\t\t\terr = lookup_node(addr);\n\t\t\tif (err < 0)\n\t\t\t\tgoto out;\n\t\t\t*policy = err;\n\t\t} else if (pol == current->mempolicy &&\n\t\t\t\tpol->mode == MPOL_INTERLEAVE) {\n\t\t\t*policy = next_node_in(current->il_prev, pol->v.nodes);\n\t\t} else {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t*policy = pol == &default_policy ? MPOL_DEFAULT :\n\t\t\t\t\t\tpol->mode;\n\t\t/*\n\t\t * Internal mempolicy flags must be masked off before exposing\n\t\t * the policy to userspace.\n\t\t */\n\t\t*policy |= (pol->flags & MPOL_MODE_FLAGS);\n\t}\n\n\tif (vma) {\n\t\tup_read(&current->mm->mmap_sem);\n\t\tvma = NULL;\n\t}\n\n\terr = 0;\n\tif (nmask) {\n\t\tif (mpol_store_user_nodemask(pol)) {\n\t\t\t*nmask = pol->w.user_nodemask;\n\t\t} else {\n\t\t\ttask_lock(current);\n\t\t\tget_policy_nodemask(pol, nmask);\n\t\t\ttask_unlock(current);\n\t\t}\n\t}\n\n out:\n\tmpol_cond_put(pol);\n\tif (vma)\n\t\tup_read(&current->mm->mmap_sem);\n\treturn err;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149864,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static long do_get_mempolicy(int *policy, nodemask_t *nmask,\n\t\t\t     unsigned long addr, unsigned long flags)\n{\n\tint err;\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma = NULL;\n\tstruct mempolicy *pol = current->mempolicy;\n\n\tif (flags &\n\t\t~(unsigned long)(MPOL_F_NODE|MPOL_F_ADDR|MPOL_F_MEMS_ALLOWED))\n\t\treturn -EINVAL;\n\n\tif (flags & MPOL_F_MEMS_ALLOWED) {\n\t\tif (flags & (MPOL_F_NODE|MPOL_F_ADDR))\n\t\t\treturn -EINVAL;\n\t\t*policy = 0;\t/* just so it's initialized */\n\t\ttask_lock(current);\n\t\t*nmask  = cpuset_current_mems_allowed;\n\t\ttask_unlock(current);\n\t\treturn 0;\n\t}\n\n\tif (flags & MPOL_F_ADDR) {\n\t\t/*\n\t\t * Do NOT fall back to task policy if the\n\t\t * vma/shared policy at addr is NULL.  We\n\t\t * want to return MPOL_DEFAULT in this case.\n\t\t */\n\t\tdown_read(&mm->mmap_sem);\n\t\tvma = find_vma_intersection(mm, addr, addr+1);\n\t\tif (!vma) {\n\t\t\tup_read(&mm->mmap_sem);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tif (vma->vm_ops && vma->vm_ops->get_policy)\n\t\t\tpol = vma->vm_ops->get_policy(vma, addr);\n\t\telse\n\t\t\tpol = vma->vm_policy;\n\t} else if (addr)\n\t\treturn -EINVAL;\n\n\tif (!pol)\n\t\tpol = &default_policy;\t/* indicates default behavior */\n\n\tif (flags & MPOL_F_NODE) {\n\t\tif (flags & MPOL_F_ADDR) {\n\t\t\terr = lookup_node(addr);\n\t\t\tif (err < 0)\n\t\t\t\tgoto out;\n\t\t\t*policy = err;\n\t\t} else if (pol == current->mempolicy &&\n\t\t\t\tpol->mode == MPOL_INTERLEAVE) {\n\t\t\t*policy = next_node_in(current->il_prev, pol->v.nodes);\n\t\t} else {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t*policy = pol == &default_policy ? MPOL_DEFAULT :\n\t\t\t\t\t\tpol->mode;\n\t\t/*\n\t\t * Internal mempolicy flags must be masked off before exposing\n\t\t * the policy to userspace.\n\t\t */\n\t\t*policy |= (pol->flags & MPOL_MODE_FLAGS);\n\t}\n\n\terr = 0;\n\tif (nmask) {\n\t\tif (mpol_store_user_nodemask(pol)) {\n\t\t\t*nmask = pol->w.user_nodemask;\n\t\t} else {\n\t\t\ttask_lock(current);\n\t\t\tget_policy_nodemask(pol, nmask);\n\t\t\ttask_unlock(current);\n\t\t}\n\t}\n\n out:\n\tmpol_cond_put(pol);\n\tif (vma)\n\t\tup_read(&current->mm->mmap_sem);\n\treturn err;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149865,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": " */\nstatic int wddx_stack_destroy(wddx_stack *stack)\n{\n\tregister int i;\n\n\tif (stack->elements) {\n\t\tfor (i = 0; i < stack->top; i++) {\n\t\t\tif (((st_entry *)stack->elements[i])->data\n\t\t\t\t\t&& ((st_entry *)stack->elements[i])->type != ST_FIELD)\t{\n\t\t\t\tzval_ptr_dtor(&((st_entry *)stack->elements[i])->data);\n\t\t\t}\n\t\t\tif (((st_entry *)stack->elements[i])->varname) {\n\t\t\t\tefree(((st_entry *)stack->elements[i])->varname);\n\t\t\t}\n\t\t\tefree(stack->elements[i]);\n\t\t}\n\t\tefree(stack->elements);\n\t}\n\treturn SUCCESS;",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149866,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static void regulator_ena_gpio_free(struct regulator_dev *rdev)\n{\n\tstruct regulator_enable_gpio *pin, *n;\n\n\tif (!rdev->ena_pin)\n\t\treturn;\n\n\t/* Free the GPIO only in case of no use */\n\tlist_for_each_entry_safe(pin, n, &regulator_ena_gpio_list, list) {\n\t\tif (pin->gpiod == rdev->ena_pin->gpiod) {\n\t\t\tif (pin->request_count <= 1) {\n\t\t\t\tpin->request_count = 0;\n\t\t\t\tgpiod_put(pin->gpiod);\n\t\t\t\tlist_del(&pin->list);\n\t\t\t\tkfree(pin);\n\t\t\t} else {\n\t\t\t\tpin->request_count--;\n\t\t\t}\n\t\t}\n\t}\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149868,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static void regulator_ena_gpio_free(struct regulator_dev *rdev)\n{\n\tstruct regulator_enable_gpio *pin, *n;\n\n\tif (!rdev->ena_pin)\n\t\treturn;\n\n\t/* Free the GPIO only in case of no use */\n\tlist_for_each_entry_safe(pin, n, &regulator_ena_gpio_list, list) {\n\t\tif (pin->gpiod == rdev->ena_pin->gpiod) {\n\t\t\tif (pin->request_count <= 1) {\n\t\t\t\tpin->request_count = 0;\n\t\t\t\tgpiod_put(pin->gpiod);\n\t\t\t\tlist_del(&pin->list);\n\t\t\t\tkfree(pin);\n\t\t\t\trdev->ena_pin = NULL;\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tpin->request_count--;\n\t\t\t}\n\t\t}\n\t}\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149869,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int usb_console_setup(struct console *co, char *options)\n{\n\tstruct usbcons_info *info = &usbcons_info;\n\tint baud = 9600;\n\tint bits = 8;\n\tint parity = 'n';\n\tint doflow = 0;\n\tint cflag = CREAD | HUPCL | CLOCAL;\n\tchar *s;\n\tstruct usb_serial *serial;\n\tstruct usb_serial_port *port;\n\tint retval;\n\tstruct tty_struct *tty = NULL;\n\tstruct ktermios dummy;\n\n\tif (options) {\n\t\tbaud = simple_strtoul(options, NULL, 10);\n\t\ts = options;\n\t\twhile (*s >= '0' && *s <= '9')\n\t\t\ts++;\n\t\tif (*s)\n\t\t\tparity = *s++;\n\t\tif (*s)\n\t\t\tbits   = *s++ - '0';\n\t\tif (*s)\n\t\t\tdoflow = (*s++ == 'r');\n\t}\n\t\n\t/* Sane default */\n\tif (baud == 0)\n\t\tbaud = 9600;\n\n\tswitch (bits) {\n\tcase 7:\n\t\tcflag |= CS7;\n\t\tbreak;\n\tdefault:\n\tcase 8:\n\t\tcflag |= CS8;\n\t\tbreak;\n\t}\n\tswitch (parity) {\n\tcase 'o': case 'O':\n\t\tcflag |= PARODD;\n\t\tbreak;\n\tcase 'e': case 'E':\n\t\tcflag |= PARENB;\n\t\tbreak;\n\t}\n\tco->cflag = cflag;\n\n\t/*\n\t * no need to check the index here: if the index is wrong, console\n\t * code won't call us\n\t */\n\tport = usb_serial_port_get_by_minor(co->index);\n\tif (port == NULL) {\n\t\t/* no device is connected yet, sorry :( */\n\t\tpr_err(\"No USB device connected to ttyUSB%i\\n\", co->index);\n\t\treturn -ENODEV;\n\t}\n\tserial = port->serial;\n\n\tretval = usb_autopm_get_interface(serial->interface);\n\tif (retval)\n\t\tgoto error_get_interface;\n\n\ttty_port_tty_set(&port->port, NULL);\n\n\tinfo->port = port;\n\n\t++port->port.count;\n\tif (!tty_port_initialized(&port->port)) {\n\t\tif (serial->type->set_termios) {\n\t\t\t/*\n\t\t\t * allocate a fake tty so the driver can initialize\n\t\t\t * the termios structure, then later call set_termios to\n\t\t\t * configure according to command line arguments\n\t\t\t */\n\t\t\ttty = kzalloc(sizeof(*tty), GFP_KERNEL);\n\t\t\tif (!tty) {\n\t\t\t\tretval = -ENOMEM;\n\t\t\t\tgoto reset_open_count;\n\t\t\t}\n\t\t\tkref_init(&tty->kref);\n\t\t\ttty->driver = usb_serial_tty_driver;\n\t\t\ttty->index = co->index;\n\t\t\tinit_ldsem(&tty->ldisc_sem);\n\t\t\tspin_lock_init(&tty->files_lock);\n\t\t\tINIT_LIST_HEAD(&tty->tty_files);\n\t\t\tkref_get(&tty->driver->kref);\n\t\t\t__module_get(tty->driver->owner);\n\t\t\ttty->ops = &usb_console_fake_tty_ops;\n\t\t\ttty_init_termios(tty);\n\t\t\ttty_port_tty_set(&port->port, tty);\n\t\t}\n\n\t\t/* only call the device specific open if this\n\t\t * is the first time the port is opened */\n\t\tretval = serial->type->open(NULL, port);\n\t\tif (retval) {\n\t\t\tdev_err(&port->dev, \"could not open USB console port\\n\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (serial->type->set_termios) {\n\t\t\ttty->termios.c_cflag = cflag;\n\t\t\ttty_termios_encode_baud_rate(&tty->termios, baud, baud);\n\t\t\tmemset(&dummy, 0, sizeof(struct ktermios));\n\t\t\tserial->type->set_termios(tty, port, &dummy);\n\n\t\t\ttty_port_tty_set(&port->port, NULL);\n\t\t\ttty_kref_put(tty);\n\t\t}\n\t\ttty_port_set_initialized(&port->port, 1);\n\t}\n\t/* Now that any required fake tty operations are completed restore\n\t * the tty port count */\n\t--port->port.count;\n\t/* The console is special in terms of closing the device so\n\t * indicate this port is now acting as a system console. */\n\tport->port.console = 1;\n\n\tmutex_unlock(&serial->disc_mutex);\n\treturn retval;\n\n fail:\n\ttty_port_tty_set(&port->port, NULL);\n\ttty_kref_put(tty);\n reset_open_count:\n\tport->port.count = 0;\n\tusb_autopm_put_interface(serial->interface);\n error_get_interface:\n\tusb_serial_put(serial);\n\tmutex_unlock(&serial->disc_mutex);\n\treturn retval;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149870,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int usb_console_setup(struct console *co, char *options)\n{\n\tstruct usbcons_info *info = &usbcons_info;\n\tint baud = 9600;\n\tint bits = 8;\n\tint parity = 'n';\n\tint doflow = 0;\n\tint cflag = CREAD | HUPCL | CLOCAL;\n\tchar *s;\n\tstruct usb_serial *serial;\n\tstruct usb_serial_port *port;\n\tint retval;\n\tstruct tty_struct *tty = NULL;\n\tstruct ktermios dummy;\n\n\tif (options) {\n\t\tbaud = simple_strtoul(options, NULL, 10);\n\t\ts = options;\n\t\twhile (*s >= '0' && *s <= '9')\n\t\t\ts++;\n\t\tif (*s)\n\t\t\tparity = *s++;\n\t\tif (*s)\n\t\t\tbits   = *s++ - '0';\n\t\tif (*s)\n\t\t\tdoflow = (*s++ == 'r');\n\t}\n\t\n\t/* Sane default */\n\tif (baud == 0)\n\t\tbaud = 9600;\n\n\tswitch (bits) {\n\tcase 7:\n\t\tcflag |= CS7;\n\t\tbreak;\n\tdefault:\n\tcase 8:\n\t\tcflag |= CS8;\n\t\tbreak;\n\t}\n\tswitch (parity) {\n\tcase 'o': case 'O':\n\t\tcflag |= PARODD;\n\t\tbreak;\n\tcase 'e': case 'E':\n\t\tcflag |= PARENB;\n\t\tbreak;\n\t}\n\tco->cflag = cflag;\n\n\t/*\n\t * no need to check the index here: if the index is wrong, console\n\t * code won't call us\n\t */\n\tport = usb_serial_port_get_by_minor(co->index);\n\tif (port == NULL) {\n\t\t/* no device is connected yet, sorry :( */\n\t\tpr_err(\"No USB device connected to ttyUSB%i\\n\", co->index);\n\t\treturn -ENODEV;\n\t}\n\tserial = port->serial;\n\n\tretval = usb_autopm_get_interface(serial->interface);\n\tif (retval)\n\t\tgoto error_get_interface;\n\n\ttty_port_tty_set(&port->port, NULL);\n\n\tinfo->port = port;\n\n\t++port->port.count;\n\tif (!tty_port_initialized(&port->port)) {\n\t\tif (serial->type->set_termios) {\n\t\t\t/*\n\t\t\t * allocate a fake tty so the driver can initialize\n\t\t\t * the termios structure, then later call set_termios to\n\t\t\t * configure according to command line arguments\n\t\t\t */\n\t\t\ttty = kzalloc(sizeof(*tty), GFP_KERNEL);\n\t\t\tif (!tty) {\n\t\t\t\tretval = -ENOMEM;\n\t\t\t\tgoto reset_open_count;\n\t\t\t}\n\t\t\tkref_init(&tty->kref);\n\t\t\ttty->driver = usb_serial_tty_driver;\n\t\t\ttty->index = co->index;\n\t\t\tinit_ldsem(&tty->ldisc_sem);\n\t\t\tspin_lock_init(&tty->files_lock);\n\t\t\tINIT_LIST_HEAD(&tty->tty_files);\n\t\t\tkref_get(&tty->driver->kref);\n\t\t\t__module_get(tty->driver->owner);\n\t\t\ttty->ops = &usb_console_fake_tty_ops;\n\t\t\ttty_init_termios(tty);\n\t\t\ttty_port_tty_set(&port->port, tty);\n\t\t}\n\n\t\t/* only call the device specific open if this\n\t\t * is the first time the port is opened */\n\t\tretval = serial->type->open(NULL, port);\n\t\tif (retval) {\n\t\t\tdev_err(&port->dev, \"could not open USB console port\\n\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (serial->type->set_termios) {\n\t\t\ttty->termios.c_cflag = cflag;\n\t\t\ttty_termios_encode_baud_rate(&tty->termios, baud, baud);\n\t\t\tmemset(&dummy, 0, sizeof(struct ktermios));\n\t\t\tserial->type->set_termios(tty, port, &dummy);\n\n\t\t\ttty_port_tty_set(&port->port, NULL);\n\t\t\ttty_kref_put(tty);\n\t\t}\n\t\ttty_port_set_initialized(&port->port, 1);\n\t}\n\t/* Now that any required fake tty operations are completed restore\n\t * the tty port count */\n\t--port->port.count;\n\t/* The console is special in terms of closing the device so\n\t * indicate this port is now acting as a system console. */\n\tport->port.console = 1;\n\n\tmutex_unlock(&serial->disc_mutex);\n\treturn retval;\n\n fail:\n\ttty_port_tty_set(&port->port, NULL);\n\ttty_kref_put(tty);\n reset_open_count:\n\tport->port.count = 0;\n\tinfo->port = NULL;\n\tusb_autopm_put_interface(serial->interface);\n error_get_interface:\n\tusb_serial_put(serial);\n\tmutex_unlock(&serial->disc_mutex);\n\treturn retval;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149871,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int ipxitf_ioctl(unsigned int cmd, void __user *arg)\n{\n\tint rc = -EINVAL;\n\tstruct ifreq ifr;\n\tint val;\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR: {\n\t\tstruct sockaddr_ipx *sipx;\n\t\tstruct ipx_interface_definition f;\n\n\t\trc = -EFAULT;\n\t\tif (copy_from_user(&ifr, arg, sizeof(ifr)))\n\t\t\tbreak;\n\t\tsipx = (struct sockaddr_ipx *)&ifr.ifr_addr;\n\t\trc = -EINVAL;\n\t\tif (sipx->sipx_family != AF_IPX)\n\t\t\tbreak;\n\t\tf.ipx_network = sipx->sipx_network;\n\t\tmemcpy(f.ipx_device, ifr.ifr_name,\n\t\t\tsizeof(f.ipx_device));\n\t\tmemcpy(f.ipx_node, sipx->sipx_node, IPX_NODE_LEN);\n\t\tf.ipx_dlink_type = sipx->sipx_type;\n\t\tf.ipx_special = sipx->sipx_special;\n\n\t\tif (sipx->sipx_action == IPX_DLTITF)\n\t\t\trc = ipxitf_delete(&f);\n\t\telse\n\t\t\trc = ipxitf_create(&f);\n\t\tbreak;\n\t}\n\tcase SIOCGIFADDR: {\n\t\tstruct sockaddr_ipx *sipx;\n\t\tstruct ipx_interface *ipxif;\n\t\tstruct net_device *dev;\n\n\t\trc = -EFAULT;\n\t\tif (copy_from_user(&ifr, arg, sizeof(ifr)))\n\t\t\tbreak;\n\t\tsipx = (struct sockaddr_ipx *)&ifr.ifr_addr;\n\t\tdev  = __dev_get_by_name(&init_net, ifr.ifr_name);\n\t\trc   = -ENODEV;\n\t\tif (!dev)\n\t\t\tbreak;\n\t\tipxif = ipxitf_find_using_phys(dev,\n\t\t\t\t\t   ipx_map_frame_type(sipx->sipx_type));\n\t\trc = -EADDRNOTAVAIL;\n\t\tif (!ipxif)\n\t\t\tbreak;\n\n\t\tsipx->sipx_family\t= AF_IPX;\n\t\tsipx->sipx_network\t= ipxif->if_netnum;\n\t\tmemcpy(sipx->sipx_node, ipxif->if_node,\n\t\t\tsizeof(sipx->sipx_node));\n\t\trc = -EFAULT;\n\t\tif (copy_to_user(arg, &ifr, sizeof(ifr)))\n\t\t\tbreak;\n\t\tipxitf_put(ipxif);\n\t\trc = 0;\n\t\tbreak;\n\t}\n\tcase SIOCAIPXITFCRT:\n\t\trc = -EFAULT;\n\t\tif (get_user(val, (unsigned char __user *) arg))\n\t\t\tbreak;\n\t\trc = 0;\n\t\tipxcfg_auto_create_interfaces = val;\n\t\tbreak;\n\tcase SIOCAIPXPRISLT:\n\t\trc = -EFAULT;\n\t\tif (get_user(val, (unsigned char __user *) arg))\n\t\t\tbreak;\n\t\trc = 0;\n\t\tipxcfg_set_auto_select(val);\n\t\tbreak;\n\t}\n\n\treturn rc;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149872,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int ipxitf_ioctl(unsigned int cmd, void __user *arg)\n{\n\tint rc = -EINVAL;\n\tstruct ifreq ifr;\n\tint val;\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR: {\n\t\tstruct sockaddr_ipx *sipx;\n\t\tstruct ipx_interface_definition f;\n\n\t\trc = -EFAULT;\n\t\tif (copy_from_user(&ifr, arg, sizeof(ifr)))\n\t\t\tbreak;\n\t\tsipx = (struct sockaddr_ipx *)&ifr.ifr_addr;\n\t\trc = -EINVAL;\n\t\tif (sipx->sipx_family != AF_IPX)\n\t\t\tbreak;\n\t\tf.ipx_network = sipx->sipx_network;\n\t\tmemcpy(f.ipx_device, ifr.ifr_name,\n\t\t\tsizeof(f.ipx_device));\n\t\tmemcpy(f.ipx_node, sipx->sipx_node, IPX_NODE_LEN);\n\t\tf.ipx_dlink_type = sipx->sipx_type;\n\t\tf.ipx_special = sipx->sipx_special;\n\n\t\tif (sipx->sipx_action == IPX_DLTITF)\n\t\t\trc = ipxitf_delete(&f);\n\t\telse\n\t\t\trc = ipxitf_create(&f);\n\t\tbreak;\n\t}\n\tcase SIOCGIFADDR: {\n\t\tstruct sockaddr_ipx *sipx;\n\t\tstruct ipx_interface *ipxif;\n\t\tstruct net_device *dev;\n\n\t\trc = -EFAULT;\n\t\tif (copy_from_user(&ifr, arg, sizeof(ifr)))\n\t\t\tbreak;\n\t\tsipx = (struct sockaddr_ipx *)&ifr.ifr_addr;\n\t\tdev  = __dev_get_by_name(&init_net, ifr.ifr_name);\n\t\trc   = -ENODEV;\n\t\tif (!dev)\n\t\t\tbreak;\n\t\tipxif = ipxitf_find_using_phys(dev,\n\t\t\t\t\t   ipx_map_frame_type(sipx->sipx_type));\n\t\trc = -EADDRNOTAVAIL;\n\t\tif (!ipxif)\n\t\t\tbreak;\n\n\t\tsipx->sipx_family\t= AF_IPX;\n\t\tsipx->sipx_network\t= ipxif->if_netnum;\n\t\tmemcpy(sipx->sipx_node, ipxif->if_node,\n\t\t\tsizeof(sipx->sipx_node));\n\t\trc = 0;\n\t\tif (copy_to_user(arg, &ifr, sizeof(ifr)))\n\t\t\trc = -EFAULT;\n\t\tipxitf_put(ipxif);\n\t\tbreak;\n\t}\n\tcase SIOCAIPXITFCRT:\n\t\trc = -EFAULT;\n\t\tif (get_user(val, (unsigned char __user *) arg))\n\t\t\tbreak;\n\t\trc = 0;\n\t\tipxcfg_auto_create_interfaces = val;\n\t\tbreak;\n\tcase SIOCAIPXPRISLT:\n\t\trc = -EFAULT;\n\t\tif (get_user(val, (unsigned char __user *) arg))\n\t\t\tbreak;\n\t\trc = 0;\n\t\tipxcfg_set_auto_select(val);\n\t\tbreak;\n\t}\n\n\treturn rc;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149873,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static PHP_MINIT_FUNCTION(zip)\n{\n#ifdef PHP_ZIP_USE_OO\n\tzend_class_entry ce;\n\n\tmemcpy(&zip_object_handlers, zend_get_std_object_handlers(), sizeof(zend_object_handlers));\n\tzip_object_handlers.clone_obj\t\t= NULL;\n\tzip_object_handlers.get_property_ptr_ptr = php_zip_get_property_ptr_ptr;\n\n\tzip_object_handlers.get_gc          = php_zip_get_gc;\n\tzip_object_handlers.get_properties = php_zip_get_properties;\n\tzip_object_handlers.read_property\t= php_zip_read_property;\n\tzip_object_handlers.has_property\t= php_zip_has_property;\n\n\tINIT_CLASS_ENTRY(ce, \"ZipArchive\", zip_class_functions);\n\tce.create_object = php_zip_object_new;\n\tzip_class_entry = zend_register_internal_class(&ce TSRMLS_CC);\n\n\tzend_hash_init(&zip_prop_handlers, 0, NULL, NULL, 1);\n\tphp_zip_register_prop_handler(&zip_prop_handlers, \"status\",    php_zip_status, NULL, NULL, IS_LONG TSRMLS_CC);\n\tphp_zip_register_prop_handler(&zip_prop_handlers, \"statusSys\", php_zip_status_sys, NULL, NULL, IS_LONG TSRMLS_CC);\n\tphp_zip_register_prop_handler(&zip_prop_handlers, \"numFiles\",  php_zip_get_num_files, NULL, NULL, IS_LONG TSRMLS_CC);\n\tphp_zip_register_prop_handler(&zip_prop_handlers, \"filename\", NULL, NULL, php_zipobj_get_filename, IS_STRING TSRMLS_CC);\n\tphp_zip_register_prop_handler(&zip_prop_handlers, \"comment\", NULL, php_zipobj_get_zip_comment, NULL, IS_STRING TSRMLS_CC);\n\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CREATE\", ZIP_CREATE);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"EXCL\", ZIP_EXCL);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CHECKCONS\", ZIP_CHECKCONS);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OVERWRITE\", ZIP_OVERWRITE);\n\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"FL_NOCASE\", ZIP_FL_NOCASE);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"FL_NODIR\", ZIP_FL_NODIR);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"FL_COMPRESSED\", ZIP_FL_COMPRESSED);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"FL_UNCHANGED\", ZIP_FL_UNCHANGED);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_DEFAULT\", ZIP_CM_DEFAULT);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_STORE\", ZIP_CM_STORE);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_SHRINK\", ZIP_CM_SHRINK);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_REDUCE_1\", ZIP_CM_REDUCE_1);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_REDUCE_2\", ZIP_CM_REDUCE_2);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_REDUCE_3\", ZIP_CM_REDUCE_3);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_REDUCE_4\", ZIP_CM_REDUCE_4);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_IMPLODE\", ZIP_CM_IMPLODE);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_DEFLATE\", ZIP_CM_DEFLATE);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_DEFLATE64\", ZIP_CM_DEFLATE64);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_PKWARE_IMPLODE\", ZIP_CM_PKWARE_IMPLODE);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_BZIP2\", ZIP_CM_BZIP2);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_LZMA\", ZIP_CM_LZMA);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_TERSE\", ZIP_CM_TERSE);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_LZ77\", ZIP_CM_LZ77);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_WAVPACK\", ZIP_CM_WAVPACK);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_PPMD\", ZIP_CM_PPMD);\n\n\t/* Error code */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_OK\",\t\t\tZIP_ER_OK);\t\t\t/* N No error */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_MULTIDISK\",\tZIP_ER_MULTIDISK);\t/* N Multi-disk zip archives not supported */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_RENAME\",\t\tZIP_ER_RENAME);\t\t/* S Renaming temporary file failed */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_CLOSE\",\t\tZIP_ER_CLOSE);\t\t/* S Closing zip archive failed */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_SEEK\",\t\tZIP_ER_SEEK);\t\t/* S Seek error */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_READ\",\t\tZIP_ER_READ);\t\t/* S Read error */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_WRITE\",\t\tZIP_ER_WRITE);\t\t/* S Write error */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_CRC\",\t\t\tZIP_ER_CRC);\t\t/* N CRC error */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_ZIPCLOSED\",\tZIP_ER_ZIPCLOSED);\t/* N Containing zip archive was closed */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_NOENT\",\t\tZIP_ER_NOENT);\t\t/* N No such file */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_EXISTS\",\t\tZIP_ER_EXISTS);\t\t/* N File already exists */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_OPEN\",\t\tZIP_ER_OPEN);\t\t/* S Can't open file */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_TMPOPEN\",\t\tZIP_ER_TMPOPEN);\t/* S Failure to create temporary file */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_ZLIB\",\t\tZIP_ER_ZLIB);\t\t/* Z Zlib error */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_MEMORY\",\t\tZIP_ER_MEMORY);\t\t/* N Malloc failure */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_CHANGED\",\t\tZIP_ER_CHANGED);\t/* N Entry has been changed */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_COMPNOTSUPP\",\tZIP_ER_COMPNOTSUPP);/* N Compression method not supported */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_EOF\",\t\t\tZIP_ER_EOF);\t\t/* N Premature EOF */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_INVAL\",\t\tZIP_ER_INVAL);\t\t/* N Invalid argument */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_NOZIP\",\t\tZIP_ER_NOZIP);\t\t/* N Not a zip archive */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_INTERNAL\",\tZIP_ER_INTERNAL);\t/* N Internal error */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_INCONS\",\t\tZIP_ER_INCONS);\t\t/* N Zip archive inconsistent */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_REMOVE\",\t\tZIP_ER_REMOVE);\t\t/* S Can't remove file */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_DELETED\",  \tZIP_ER_DELETED);\t/* N Entry has been deleted */\n\n\tphp_register_url_stream_wrapper(\"zip\", &php_stream_zip_wrapper TSRMLS_CC);\n#endif\n\n\tle_zip_dir   = zend_register_list_destructors_ex(php_zip_free_dir,   NULL, le_zip_dir_name,   module_number);\n\tle_zip_entry = zend_register_list_destructors_ex(php_zip_free_entry, NULL, le_zip_entry_name, module_number);\n\n\treturn SUCCESS;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149874,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int get_task_ioprio(struct task_struct *p)\n{\n\tint ret;\n\n\tret = security_task_getioprio(p);\n\tif (ret)\n\t\tgoto out;\n\tret = IOPRIO_PRIO_VALUE(IOPRIO_CLASS_NONE, IOPRIO_NORM);\n\tif (p->io_context)\n\t\tret = p->io_context->ioprio;\nout:\n\treturn ret;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149876,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int get_task_ioprio(struct task_struct *p)\n{\n\tint ret;\n\n\tret = security_task_getioprio(p);\n\tif (ret)\n\t\tgoto out;\n\tret = IOPRIO_PRIO_VALUE(IOPRIO_CLASS_NONE, IOPRIO_NORM);\n\ttask_lock(p);\n\tif (p->io_context)\n\t\tret = p->io_context->ioprio;\n\ttask_unlock(p);\nout:\n\treturn ret;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149877,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "MagickExport MagickBooleanType SetImageType(Image *image,const ImageType type)\n{\n  const char\n    *artifact;\n\n  ImageInfo\n    *image_info;\n\n  MagickBooleanType\n    status;\n\n  QuantizeInfo\n    *quantize_info;\n\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image->signature == MagickSignature);\n  status=MagickTrue;\n  image_info=AcquireImageInfo();\n  image_info->dither=image->dither;\n  artifact=GetImageArtifact(image,\"dither\");\n  if (artifact != (const char *) NULL)\n    (void) SetImageOption(image_info,\"dither\",artifact);\n  switch (type)\n  {\n    case BilevelType:\n    {\n      if (SetImageMonochrome(image,&image->exception) == MagickFalse)\n        {\n          status=TransformImageColorspace(image,GRAYColorspace);\n          (void) NormalizeImage(image);\n          quantize_info=AcquireQuantizeInfo(image_info);\n          quantize_info->number_colors=2;\n          quantize_info->colorspace=GRAYColorspace;\n          status=QuantizeImage(quantize_info,image);\n          quantize_info=DestroyQuantizeInfo(quantize_info);\n        }\n      image->colors=2;\n      image->matte=MagickFalse;\n      break;\n    }\n    case GrayscaleType:\n    {\n      if (SetImageGray(image,&image->exception) == MagickFalse)\n        status=TransformImageColorspace(image,GRAYColorspace);\n      image->matte=MagickFalse;\n      break;\n    }\n    case GrayscaleMatteType:\n    {\n      if (SetImageGray(image,&image->exception) == MagickFalse)\n        status=TransformImageColorspace(image,GRAYColorspace);\n      if (image->matte == MagickFalse)\n        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);\n      break;\n    }\n    case PaletteType:\n    {\n      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n        status=TransformImageColorspace(image,sRGBColorspace);\n      if ((image->storage_class == DirectClass) || (image->colors > 256))\n        {\n          quantize_info=AcquireQuantizeInfo(image_info);\n          quantize_info->number_colors=256;\n          status=QuantizeImage(quantize_info,image);\n          quantize_info=DestroyQuantizeInfo(quantize_info);\n        }\n      image->matte=MagickFalse;\n      break;\n    }\n    case PaletteBilevelMatteType:\n    {\n      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n        status=TransformImageColorspace(image,sRGBColorspace);\n      if (image->matte == MagickFalse)\n        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);\n      (void) BilevelImageChannel(image,AlphaChannel,(double) QuantumRange/2.0);\n      quantize_info=AcquireQuantizeInfo(image_info);\n      status=QuantizeImage(quantize_info,image);\n      quantize_info=DestroyQuantizeInfo(quantize_info);\n      break;\n    }\n    case PaletteMatteType:\n    {\n      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n        status=TransformImageColorspace(image,sRGBColorspace);\n      if (image->matte == MagickFalse)\n        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);\n      quantize_info=AcquireQuantizeInfo(image_info);\n      quantize_info->colorspace=TransparentColorspace;\n      status=QuantizeImage(quantize_info,image);\n      quantize_info=DestroyQuantizeInfo(quantize_info);\n      break;\n    }\n    case TrueColorType:\n    {\n      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n        status=TransformImageColorspace(image,sRGBColorspace);\n      if (image->storage_class != DirectClass)\n        status=SetImageStorageClass(image,DirectClass);\n      image->matte=MagickFalse;\n      break;\n    }\n    case TrueColorMatteType:\n    {\n      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n        status=TransformImageColorspace(image,sRGBColorspace);\n      if (image->storage_class != DirectClass)\n        status=SetImageStorageClass(image,DirectClass);\n      if (image->matte == MagickFalse)\n        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);\n      break;\n    }\n    case ColorSeparationType:\n    {\n      if (image->colorspace != CMYKColorspace)\n        {\n          if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n            (void) TransformImageColorspace(image,sRGBColorspace);\n          status=TransformImageColorspace(image,CMYKColorspace);\n        }\n      if (image->storage_class != DirectClass)\n        status=SetImageStorageClass(image,DirectClass);\n      image->matte=MagickFalse;\n      break;\n    }\n    case ColorSeparationMatteType:\n    {\n      if (image->colorspace != CMYKColorspace)\n        {\n          if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n            (void) TransformImageColorspace(image,sRGBColorspace);\n          status=TransformImageColorspace(image,CMYKColorspace);\n        }\n      if (image->storage_class != DirectClass)\n        status=SetImageStorageClass(image,DirectClass);\n      if (image->matte == MagickFalse)\n        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);\n      break;\n    }\n    case OptimizeType:\n    case UndefinedType:\n      break;\n  }\n  image_info=DestroyImageInfo(image_info);\n  if (status == MagickFalse)\n    return(MagickFalse);\n  image->type=type;\n  return(MagickTrue);\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149878,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "MagickExport MagickBooleanType SetImageType(Image *image,const ImageType type)\n{\n  const char\n    *artifact;\n\n  ImageInfo\n    *image_info;\n\n  MagickBooleanType\n    status;\n\n  QuantizeInfo\n    *quantize_info;\n\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image->signature == MagickSignature);\n  status=MagickTrue;\n  image_info=AcquireImageInfo();\n  image_info->dither=image->dither;\n  artifact=GetImageArtifact(image,\"dither\");\n  if (artifact != (const char *) NULL)\n    (void) SetImageOption(image_info,\"dither\",artifact);\n  switch (type)\n  {\n    case BilevelType:\n    {\n      if (SetImageMonochrome(image,&image->exception) == MagickFalse)\n        {\n          status=TransformImageColorspace(image,GRAYColorspace);\n          (void) NormalizeImage(image);\n          quantize_info=AcquireQuantizeInfo(image_info);\n          quantize_info->number_colors=2;\n          quantize_info->colorspace=GRAYColorspace;\n          status=QuantizeImage(quantize_info,image);\n          quantize_info=DestroyQuantizeInfo(quantize_info);\n        }\n      status=AcquireImageColormap(image,2);\n      image->matte=MagickFalse;\n      break;\n    }\n    case GrayscaleType:\n    {\n      if (SetImageGray(image,&image->exception) == MagickFalse)\n        status=TransformImageColorspace(image,GRAYColorspace);\n      image->matte=MagickFalse;\n      break;\n    }\n    case GrayscaleMatteType:\n    {\n      if (SetImageGray(image,&image->exception) == MagickFalse)\n        status=TransformImageColorspace(image,GRAYColorspace);\n      if (image->matte == MagickFalse)\n        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);\n      break;\n    }\n    case PaletteType:\n    {\n      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n        status=TransformImageColorspace(image,sRGBColorspace);\n      if ((image->storage_class == DirectClass) || (image->colors > 256))\n        {\n          quantize_info=AcquireQuantizeInfo(image_info);\n          quantize_info->number_colors=256;\n          status=QuantizeImage(quantize_info,image);\n          quantize_info=DestroyQuantizeInfo(quantize_info);\n        }\n      image->matte=MagickFalse;\n      break;\n    }\n    case PaletteBilevelMatteType:\n    {\n      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n        status=TransformImageColorspace(image,sRGBColorspace);\n      if (image->matte == MagickFalse)\n        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);\n      (void) BilevelImageChannel(image,AlphaChannel,(double) QuantumRange/2.0);\n      quantize_info=AcquireQuantizeInfo(image_info);\n      status=QuantizeImage(quantize_info,image);\n      quantize_info=DestroyQuantizeInfo(quantize_info);\n      break;\n    }\n    case PaletteMatteType:\n    {\n      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n        status=TransformImageColorspace(image,sRGBColorspace);\n      if (image->matte == MagickFalse)\n        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);\n      quantize_info=AcquireQuantizeInfo(image_info);\n      quantize_info->colorspace=TransparentColorspace;\n      status=QuantizeImage(quantize_info,image);\n      quantize_info=DestroyQuantizeInfo(quantize_info);\n      break;\n    }\n    case TrueColorType:\n    {\n      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n        status=TransformImageColorspace(image,sRGBColorspace);\n      if (image->storage_class != DirectClass)\n        status=SetImageStorageClass(image,DirectClass);\n      image->matte=MagickFalse;\n      break;\n    }\n    case TrueColorMatteType:\n    {\n      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n        status=TransformImageColorspace(image,sRGBColorspace);\n      if (image->storage_class != DirectClass)\n        status=SetImageStorageClass(image,DirectClass);\n      if (image->matte == MagickFalse)\n        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);\n      break;\n    }\n    case ColorSeparationType:\n    {\n      if (image->colorspace != CMYKColorspace)\n        {\n          if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n            (void) TransformImageColorspace(image,sRGBColorspace);\n          status=TransformImageColorspace(image,CMYKColorspace);\n        }\n      if (image->storage_class != DirectClass)\n        status=SetImageStorageClass(image,DirectClass);\n      image->matte=MagickFalse;\n      break;\n    }\n    case ColorSeparationMatteType:\n    {\n      if (image->colorspace != CMYKColorspace)\n        {\n          if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n            (void) TransformImageColorspace(image,sRGBColorspace);\n          status=TransformImageColorspace(image,CMYKColorspace);\n        }\n      if (image->storage_class != DirectClass)\n        status=SetImageStorageClass(image,DirectClass);\n      if (image->matte == MagickFalse)\n        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);\n      break;\n    }\n    case OptimizeType:\n    case UndefinedType:\n      break;\n  }\n  image_info=DestroyImageInfo(image_info);\n  if (status == MagickFalse)\n    return(MagickFalse);\n  image->type=type;\n  return(MagickTrue);\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149879,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "updateDevice(const struct header * headers, time_t t)\n{\n\tstruct device ** pp = &devlist;\n\tstruct device * p = *pp;\t/* = devlist; */\n\twhile(p)\n\t{\n\t\tif(  p->headers[HEADER_NT].l == headers[HEADER_NT].l\n\t\t  && (0==memcmp(p->headers[HEADER_NT].p, headers[HEADER_NT].p, headers[HEADER_NT].l))\n\t\t  && p->headers[HEADER_USN].l == headers[HEADER_USN].l\n\t\t  && (0==memcmp(p->headers[HEADER_USN].p, headers[HEADER_USN].p, headers[HEADER_USN].l)) )\n\t\t{\n\t\t\t/*printf(\"found! %d\\n\", (int)(t - p->t));*/\n\t\t\tsyslog(LOG_DEBUG, \"device updated : %.*s\", headers[HEADER_USN].l, headers[HEADER_USN].p);\n\t\t\tp->t = t;\n\t\t\t/* update Location ! */\n\t\t\tif(headers[HEADER_LOCATION].l > p->headers[HEADER_LOCATION].l)\n\t\t\t{\n\t\t\t\tstruct device * tmp;\n\t\t\t\ttmp = realloc(p, sizeof(struct device)\n\t\t\t\t    + headers[0].l+headers[1].l+headers[2].l);\n\t\t\t\tif(!tmp)\t/* allocation error */\n\t\t\t\t{\n\t\t\t\t\tsyslog(LOG_ERR, \"updateDevice() : memory allocation error\");\n\t\t\t\t\tfree(p);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tp = tmp;\n\t\t\t\t*pp = p;\n\t\t\t}\n\t\t\tmemcpy(p->data + p->headers[0].l + p->headers[1].l,\n\t\t\t       headers[2].p, headers[2].l);\n\t\t\t/* TODO : check p->headers[HEADER_LOCATION].l */\n\t\t\treturn 0;\n\t\t}\n\t\tpp = &p->next;\n\t\tp = *pp;\t/* p = p->next; */\n\t}\n\tsyslog(LOG_INFO, \"new device discovered : %.*s\",\n\t       headers[HEADER_USN].l, headers[HEADER_USN].p);\n\t/* add */\n\t{\n\t\tchar * pc;\n\t\tint i;\n\t\tp = malloc(  sizeof(struct device)\n\t\t           + headers[0].l+headers[1].l+headers[2].l );\n\t\tif(!p) {\n\t\t\tsyslog(LOG_ERR, \"updateDevice(): cannot allocate memory\");\n\t\t\treturn -1;\n\t\t}\n\t\tp->next = devlist;\n\t\tp->t = t;\n\t\tpc = p->data;\n\t\tfor(i = 0; i < 3; i++)\n\t\t{\n\t\t\tp->headers[i].p = pc;\n\t\t\tp->headers[i].l = headers[i].l;\n\t\t\tmemcpy(pc, headers[i].p, headers[i].l);\n\t\t\tpc += headers[i].l;\n\t\t}\n\t\tdevlist = p;\n\t\tsendNotifications(NOTIF_NEW, p, NULL);\n\t}\n\treturn 1;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149880,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "updateDevice(const struct header * headers, time_t t)\n{\n\tstruct device ** pp = &devlist;\n\tstruct device * p = *pp;\t/* = devlist; */\n\twhile(p)\n\t{\n\t\tif(  p->headers[HEADER_NT].l == headers[HEADER_NT].l\n\t\t  && (0==memcmp(p->headers[HEADER_NT].p, headers[HEADER_NT].p, headers[HEADER_NT].l))\n\t\t  && p->headers[HEADER_USN].l == headers[HEADER_USN].l\n\t\t  && (0==memcmp(p->headers[HEADER_USN].p, headers[HEADER_USN].p, headers[HEADER_USN].l)) )\n\t\t{\n\t\t\t/*printf(\"found! %d\\n\", (int)(t - p->t));*/\n\t\t\tsyslog(LOG_DEBUG, \"device updated : %.*s\", headers[HEADER_USN].l, headers[HEADER_USN].p);\n\t\t\tp->t = t;\n\t\t\t/* update Location ! */\n\t\t\tif(headers[HEADER_LOCATION].l > p->headers[HEADER_LOCATION].l)\n\t\t\t{\n\t\t\t\tstruct device * tmp;\n\t\t\t\ttmp = realloc(p, sizeof(struct device)\n\t\t\t\t    + headers[0].l+headers[1].l+headers[2].l);\n\t\t\t\tif(!tmp)\t/* allocation error */\n\t\t\t\t{\n\t\t\t\t\tsyslog(LOG_ERR, \"updateDevice() : memory allocation error\");\n\t\t\t\t\t*pp = p->next;\t/* remove \"p\" from the list */\n\t\t\t\t\tfree(p);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tp = tmp;\n\t\t\t\t*pp = p;\n\t\t\t}\n\t\t\tmemcpy(p->data + p->headers[0].l + p->headers[1].l,\n\t\t\t       headers[2].p, headers[2].l);\n\t\t\t/* TODO : check p->headers[HEADER_LOCATION].l */\n\t\t\treturn 0;\n\t\t}\n\t\tpp = &p->next;\n\t\tp = *pp;\t/* p = p->next; */\n\t}\n\tsyslog(LOG_INFO, \"new device discovered : %.*s\",\n\t       headers[HEADER_USN].l, headers[HEADER_USN].p);\n\t/* add */\n\t{\n\t\tchar * pc;\n\t\tint i;\n\t\tp = malloc(  sizeof(struct device)\n\t\t           + headers[0].l+headers[1].l+headers[2].l );\n\t\tif(!p) {\n\t\t\tsyslog(LOG_ERR, \"updateDevice(): cannot allocate memory\");\n\t\t\treturn -1;\n\t\t}\n\t\tp->next = devlist;\n\t\tp->t = t;\n\t\tpc = p->data;\n\t\tfor(i = 0; i < 3; i++)\n\t\t{\n\t\t\tp->headers[i].p = pc;\n\t\t\tp->headers[i].l = headers[i].l;\n\t\t\tmemcpy(pc, headers[i].p, headers[i].l);\n\t\t\tpc += headers[i].l;\n\t\t}\n\t\tdevlist = p;\n\t\tsendNotifications(NOTIF_NEW, p, NULL);\n\t}\n\treturn 1;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149881,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int kvm_ioctl_create_device(struct kvm *kvm,\n\t\t\t\t   struct kvm_create_device *cd)\n{\n\tstruct kvm_device_ops *ops = NULL;\n\tstruct kvm_device *dev;\n\tbool test = cd->flags & KVM_CREATE_DEVICE_TEST;\n\tint ret;\n\n\tif (cd->type >= ARRAY_SIZE(kvm_device_ops_table))\n\t\treturn -ENODEV;\n\n\tops = kvm_device_ops_table[cd->type];\n\tif (ops == NULL)\n\t\treturn -ENODEV;\n\n\tif (test)\n\t\treturn 0;\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tdev->ops = ops;\n\tdev->kvm = kvm;\n\n\tmutex_lock(&kvm->lock);\n\tret = ops->create(dev, cd->type);\n\tif (ret < 0) {\n\t\tmutex_unlock(&kvm->lock);\n\t\tkfree(dev);\n\t\treturn ret;\n\t}\n\tlist_add(&dev->vm_node, &kvm->devices);\n\tmutex_unlock(&kvm->lock);\n\n\tif (ops->init)\n\t\tops->init(dev);\n\n\tret = anon_inode_getfd(ops->name, &kvm_device_fops, dev, O_RDWR | O_CLOEXEC);\n\tif (ret < 0) {\n\t\tops->destroy(dev);\n\t\tmutex_lock(&kvm->lock);\n\t\tlist_del(&dev->vm_node);\n\t\tmutex_unlock(&kvm->lock);\n\t\treturn ret;\n\t}\n\n\tkvm_get_kvm(kvm);\n\tcd->fd = ret;\n\treturn 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149882,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int kvm_ioctl_create_device(struct kvm *kvm,\n\t\t\t\t   struct kvm_create_device *cd)\n{\n\tstruct kvm_device_ops *ops = NULL;\n\tstruct kvm_device *dev;\n\tbool test = cd->flags & KVM_CREATE_DEVICE_TEST;\n\tint ret;\n\n\tif (cd->type >= ARRAY_SIZE(kvm_device_ops_table))\n\t\treturn -ENODEV;\n\n\tops = kvm_device_ops_table[cd->type];\n\tif (ops == NULL)\n\t\treturn -ENODEV;\n\n\tif (test)\n\t\treturn 0;\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tdev->ops = ops;\n\tdev->kvm = kvm;\n\n\tmutex_lock(&kvm->lock);\n\tret = ops->create(dev, cd->type);\n\tif (ret < 0) {\n\t\tmutex_unlock(&kvm->lock);\n\t\tkfree(dev);\n\t\treturn ret;\n\t}\n\tlist_add(&dev->vm_node, &kvm->devices);\n\tmutex_unlock(&kvm->lock);\n\n\tif (ops->init)\n\t\tops->init(dev);\n\n\tret = anon_inode_getfd(ops->name, &kvm_device_fops, dev, O_RDWR | O_CLOEXEC);\n\tif (ret < 0) {\n\t\tmutex_lock(&kvm->lock);\n\t\tlist_del(&dev->vm_node);\n\t\tmutex_unlock(&kvm->lock);\n\t\tops->destroy(dev);\n\t\treturn ret;\n\t}\n\n\tkvm_get_kvm(kvm);\n\tcd->fd = ret;\n\treturn 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149883,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "SMB2_read(const unsigned int xid, struct cifs_io_parms *io_parms,\n\t  unsigned int *nbytes, char **buf, int *buf_type)\n{\n\tstruct smb_rqst rqst;\n\tint resp_buftype, rc = -EACCES;\n\tstruct smb2_read_plain_req *req = NULL;\n\tstruct smb2_read_rsp *rsp = NULL;\n\tstruct kvec iov[1];\n\tstruct kvec rsp_iov;\n\tunsigned int total_len;\n\tint flags = CIFS_LOG_ERROR;\n\tstruct cifs_ses *ses = io_parms->tcon->ses;\n\n\t*nbytes = 0;\n\trc = smb2_new_read_req((void **)&req, &total_len, io_parms, NULL, 0, 0);\n\tif (rc)\n\t\treturn rc;\n\n\tif (smb3_encryption_required(io_parms->tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\tiov[0].iov_base = (char *)req;\n\tiov[0].iov_len = total_len;\n\n\tmemset(&rqst, 0, sizeof(struct smb_rqst));\n\trqst.rq_iov = iov;\n\trqst.rq_nvec = 1;\n\n\trc = cifs_send_recv(xid, ses, &rqst, &resp_buftype, flags, &rsp_iov);\n\tcifs_small_buf_release(req);\n\n\trsp = (struct smb2_read_rsp *)rsp_iov.iov_base;\n\n\tif (rc) {\n\t\tif (rc != -ENODATA) {\n\t\t\tcifs_stats_fail_inc(io_parms->tcon, SMB2_READ_HE);\n\t\t\tcifs_dbg(VFS, \"Send error in read = %d\\n\", rc);\n\t\t\ttrace_smb3_read_err(xid, req->PersistentFileId,\n\t\t\t\t\t    io_parms->tcon->tid, ses->Suid,\n\t\t\t\t\t    io_parms->offset, io_parms->length,\n\t\t\t\t\t    rc);\n\t\t} else\n\t\t\ttrace_smb3_read_done(xid, req->PersistentFileId,\n\t\t\t\t    io_parms->tcon->tid, ses->Suid,\n\t\t\t\t    io_parms->offset, 0);\n\t\tfree_rsp_buf(resp_buftype, rsp_iov.iov_base);\n\t\treturn rc == -ENODATA ? 0 : rc;\n\t} else\n\t\ttrace_smb3_read_done(xid, req->PersistentFileId,\n\t\t\t\t    io_parms->tcon->tid, ses->Suid,\n\t\t\t\t    io_parms->offset, io_parms->length);\n\n\t*nbytes = le32_to_cpu(rsp->DataLength);\n\tif ((*nbytes > CIFS_MAX_MSGSIZE) ||\n\t    (*nbytes > io_parms->length)) {\n\t\tcifs_dbg(FYI, \"bad length %d for count %d\\n\",\n\t\t\t *nbytes, io_parms->length);\n\t\trc = -EIO;\n\t\t*nbytes = 0;\n\t}\n\n\tif (*buf) {\n\t\tmemcpy(*buf, (char *)rsp + rsp->DataOffset, *nbytes);\n\t\tfree_rsp_buf(resp_buftype, rsp_iov.iov_base);\n\t} else if (resp_buftype != CIFS_NO_BUFFER) {\n\t\t*buf = rsp_iov.iov_base;\n\t\tif (resp_buftype == CIFS_SMALL_BUFFER)\n\t\t\t*buf_type = CIFS_SMALL_BUFFER;\n\t\telse if (resp_buftype == CIFS_LARGE_BUFFER)\n\t\t\t*buf_type = CIFS_LARGE_BUFFER;\n\t}\n\treturn rc;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149884,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "SMB2_read(const unsigned int xid, struct cifs_io_parms *io_parms,\n\t  unsigned int *nbytes, char **buf, int *buf_type)\n{\n\tstruct smb_rqst rqst;\n\tint resp_buftype, rc = -EACCES;\n\tstruct smb2_read_plain_req *req = NULL;\n\tstruct smb2_read_rsp *rsp = NULL;\n\tstruct kvec iov[1];\n\tstruct kvec rsp_iov;\n\tunsigned int total_len;\n\tint flags = CIFS_LOG_ERROR;\n\tstruct cifs_ses *ses = io_parms->tcon->ses;\n\n\t*nbytes = 0;\n\trc = smb2_new_read_req((void **)&req, &total_len, io_parms, NULL, 0, 0);\n\tif (rc)\n\t\treturn rc;\n\n\tif (smb3_encryption_required(io_parms->tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\tiov[0].iov_base = (char *)req;\n\tiov[0].iov_len = total_len;\n\n\tmemset(&rqst, 0, sizeof(struct smb_rqst));\n\trqst.rq_iov = iov;\n\trqst.rq_nvec = 1;\n\n\trc = cifs_send_recv(xid, ses, &rqst, &resp_buftype, flags, &rsp_iov);\n\trsp = (struct smb2_read_rsp *)rsp_iov.iov_base;\n\n\tif (rc) {\n\t\tif (rc != -ENODATA) {\n\t\t\tcifs_stats_fail_inc(io_parms->tcon, SMB2_READ_HE);\n\t\t\tcifs_dbg(VFS, \"Send error in read = %d\\n\", rc);\n\t\t\ttrace_smb3_read_err(xid, req->PersistentFileId,\n\t\t\t\t\t    io_parms->tcon->tid, ses->Suid,\n\t\t\t\t\t    io_parms->offset, io_parms->length,\n\t\t\t\t\t    rc);\n\t\t} else\n\t\t\ttrace_smb3_read_done(xid, req->PersistentFileId,\n\t\t\t\t    io_parms->tcon->tid, ses->Suid,\n\t\t\t\t    io_parms->offset, 0);\n\t\tfree_rsp_buf(resp_buftype, rsp_iov.iov_base);\n\t\treturn rc == -ENODATA ? 0 : rc;\n\t} else\n\t\ttrace_smb3_read_done(xid, req->PersistentFileId,\n\t\t\t\t    io_parms->tcon->tid, ses->Suid,\n\t\t\t\t    io_parms->offset, io_parms->length);\n\n\tcifs_small_buf_release(req);\n\n\t*nbytes = le32_to_cpu(rsp->DataLength);\n\tif ((*nbytes > CIFS_MAX_MSGSIZE) ||\n\t    (*nbytes > io_parms->length)) {\n\t\tcifs_dbg(FYI, \"bad length %d for count %d\\n\",\n\t\t\t *nbytes, io_parms->length);\n\t\trc = -EIO;\n\t\t*nbytes = 0;\n\t}\n\n\tif (*buf) {\n\t\tmemcpy(*buf, (char *)rsp + rsp->DataOffset, *nbytes);\n\t\tfree_rsp_buf(resp_buftype, rsp_iov.iov_base);\n\t} else if (resp_buftype != CIFS_NO_BUFFER) {\n\t\t*buf = rsp_iov.iov_base;\n\t\tif (resp_buftype == CIFS_SMALL_BUFFER)\n\t\t\t*buf_type = CIFS_SMALL_BUFFER;\n\t\telse if (resp_buftype == CIFS_LARGE_BUFFER)\n\t\t\t*buf_type = CIFS_LARGE_BUFFER;\n\t}\n\treturn rc;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149885,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "archive_read_format_rar_read_data(struct archive_read *a, const void **buff,\n                                  size_t *size, int64_t *offset)\n{\n  struct rar *rar = (struct rar *)(a->format->data);\n  int ret;\n\n  if (rar->has_encrypted_entries == ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW) {\n\t  rar->has_encrypted_entries = 0;\n  }\n\n  if (rar->bytes_unconsumed > 0) {\n      /* Consume as much as the decompressor actually used. */\n      __archive_read_consume(a, rar->bytes_unconsumed);\n      rar->bytes_unconsumed = 0;\n  }\n\n  *buff = NULL;\n  if (rar->entry_eof || rar->offset_seek >= rar->unp_size) {\n    *size = 0;\n    *offset = rar->offset;\n    if (*offset < rar->unp_size)\n      *offset = rar->unp_size;\n    return (ARCHIVE_EOF);\n  }\n\n  switch (rar->compression_method)\n  {\n  case COMPRESS_METHOD_STORE:\n    ret = read_data_stored(a, buff, size, offset);\n    break;\n\n  case COMPRESS_METHOD_FASTEST:\n  case COMPRESS_METHOD_FAST:\n  case COMPRESS_METHOD_NORMAL:\n  case COMPRESS_METHOD_GOOD:\n  case COMPRESS_METHOD_BEST:\n    ret = read_data_compressed(a, buff, size, offset);\n    if (ret != ARCHIVE_OK && ret != ARCHIVE_WARN)\n      __archive_ppmd7_functions.Ppmd7_Free(&rar->ppmd7_context);\n    break;\n\n  default:\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \"Unsupported compression method for RAR file.\");\n    ret = ARCHIVE_FATAL;\n    break;\n  }\n  return (ret);\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149886,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "archive_read_format_rar_read_data(struct archive_read *a, const void **buff,\n                                  size_t *size, int64_t *offset)\n{\n  struct rar *rar = (struct rar *)(a->format->data);\n  int ret;\n\n  if (rar->has_encrypted_entries == ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW) {\n\t  rar->has_encrypted_entries = 0;\n  }\n\n  if (rar->bytes_unconsumed > 0) {\n      /* Consume as much as the decompressor actually used. */\n      __archive_read_consume(a, rar->bytes_unconsumed);\n      rar->bytes_unconsumed = 0;\n  }\n\n  *buff = NULL;\n  if (rar->entry_eof || rar->offset_seek >= rar->unp_size) {\n    *size = 0;\n    *offset = rar->offset;\n    if (*offset < rar->unp_size)\n      *offset = rar->unp_size;\n    return (ARCHIVE_EOF);\n  }\n\n  switch (rar->compression_method)\n  {\n  case COMPRESS_METHOD_STORE:\n    ret = read_data_stored(a, buff, size, offset);\n    break;\n\n  case COMPRESS_METHOD_FASTEST:\n  case COMPRESS_METHOD_FAST:\n  case COMPRESS_METHOD_NORMAL:\n  case COMPRESS_METHOD_GOOD:\n  case COMPRESS_METHOD_BEST:\n    ret = read_data_compressed(a, buff, size, offset);\n    if (ret != ARCHIVE_OK && ret != ARCHIVE_WARN) {\n      __archive_ppmd7_functions.Ppmd7_Free(&rar->ppmd7_context);\n      rar->start_new_table = 1;\n    }\n    break;\n\n  default:\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \"Unsupported compression method for RAR file.\");\n    ret = ARCHIVE_FATAL;\n    break;\n  }\n  return (ret);\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149887,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "R_API void r_anal_bb_free(RAnalBlock *bb) {\n\tif (!bb) {\n\t\treturn;\n\t}\n\tr_anal_cond_free (bb->cond);\n\tR_FREE (bb->fingerprint);\n\tr_anal_diff_free (bb->diff);\n\tbb->diff = NULL;\n\tR_FREE (bb->op_bytes);\n\tr_anal_switch_op_free (bb->switch_op);\n\tbb->switch_op = NULL;\n\tbb->fingerprint = NULL;\n\tbb->cond = NULL;\n\tR_FREE (bb->label);\n\tR_FREE (bb->op_pos);\n\tR_FREE (bb->parent_reg_arena);\n\tif (bb->prev) {\n\t\tif (bb->prev->jumpbb == bb) {\n\t\t\tbb->prev->jumpbb = NULL;\n\t\t}\n\t\tif (bb->prev->failbb == bb) {\n\t\t\tbb->prev->failbb = NULL;\n\t\t}\n\t\tbb->prev = NULL;\n\t}\n\tif (bb->jumpbb) {\n\t\tbb->jumpbb->prev = NULL;\n\t\tbb->jumpbb = NULL;\n\t}\n\tif (bb->failbb) {\n\t\tbb->failbb->prev = NULL;\n\t\tbb->failbb = NULL;\n\t}\n\tR_FREE (bb);\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149888,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "R_API void r_anal_bb_free(RAnalBlock *bb) {\n\tif (!bb) {\n\t\treturn;\n\t}\n\tr_anal_cond_free (bb->cond);\n\tR_FREE (bb->fingerprint);\n\tr_anal_diff_free (bb->diff);\n\tbb->diff = NULL;\n\tR_FREE (bb->op_bytes);\n\tr_anal_switch_op_free (bb->switch_op);\n\tbb->switch_op = NULL;\n\tbb->fingerprint = NULL;\n\tbb->cond = NULL;\n\tR_FREE (bb->label);\n\tR_FREE (bb->op_pos);\n\tR_FREE (bb->parent_reg_arena);\n\tif (bb->prev) {\n\t\tif (bb->prev->jumpbb == bb) {\n\t\t\tbb->prev->jumpbb = NULL;\n\t\t}\n\t\tif (bb->prev->failbb == bb) {\n\t\t\tbb->prev->failbb = NULL;\n\t\t}\n\t\tbb->prev = NULL;\n\t}\n\tif (bb->jumpbb) {\n\t\tbb->jumpbb->prev = NULL;\n\t\tbb->jumpbb = NULL;\n\t}\n\tif (bb->failbb) {\n\t\tbb->failbb->prev = NULL;\n\t\tbb->failbb = NULL;\n\t}\n\tif (bb->next) {\n\t\t// avoid double free\n\t\tbb->next->prev = NULL;\n\t}\n\tR_FREE (bb); // double free\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149889,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int hci_uart_set_proto(struct hci_uart *hu, int id)\n{\n\tconst struct hci_uart_proto *p;\n\tint err;\n\n\tp = hci_uart_get_proto(id);\n\tif (!p)\n\t\treturn -EPROTONOSUPPORT;\n\n\thu->proto = p;\n\tset_bit(HCI_UART_PROTO_READY, &hu->flags);\n\n\terr = hci_uart_register_dev(hu);\n\tif (err) {\n\t\tclear_bit(HCI_UART_PROTO_READY, &hu->flags);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149890,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int hci_uart_set_proto(struct hci_uart *hu, int id)\n{\n\tconst struct hci_uart_proto *p;\n\tint err;\n\n\tp = hci_uart_get_proto(id);\n\tif (!p)\n\t\treturn -EPROTONOSUPPORT;\n\n\thu->proto = p;\n\n\terr = hci_uart_register_dev(hu);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tset_bit(HCI_UART_PROTO_READY, &hu->flags);\n\treturn 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149891,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int rm_read_multi(AVFormatContext *s, AVIOContext *pb,\n                         AVStream *st, char *mime)\n{\n    int number_of_streams = avio_rb16(pb);\n    int number_of_mdpr;\n    int i, ret;\n    unsigned size2;\n    for (i = 0; i<number_of_streams; i++)\n        avio_rb16(pb);\n    number_of_mdpr = avio_rb16(pb);\n    if (number_of_mdpr != 1) {\n        avpriv_request_sample(s, \"MLTI with multiple (%d) MDPR\", number_of_mdpr);\n    }\n    for (i = 0; i < number_of_mdpr; i++) {\n        AVStream *st2;\n        if (i > 0) {\n            st2 = avformat_new_stream(s, NULL);\n            if (!st2) {\n                ret = AVERROR(ENOMEM);\n                return ret;\n            }\n            st2->id = st->id + (i<<16);\n            st2->codecpar->bit_rate = st->codecpar->bit_rate;\n            st2->start_time = st->start_time;\n            st2->duration   = st->duration;\n            st2->codecpar->codec_type = AVMEDIA_TYPE_DATA;\n            st2->priv_data = ff_rm_alloc_rmstream();\n            if (!st2->priv_data)\n                return AVERROR(ENOMEM);\n        } else\n            st2 = st;\n\n        size2 = avio_rb32(pb);\n        ret = ff_rm_read_mdpr_codecdata(s, s->pb, st2, st2->priv_data,\n                                        size2, mime);\n        if (ret < 0)\n            return ret;\n    }\n    return 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149892,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int rm_read_multi(AVFormatContext *s, AVIOContext *pb,\n                         AVStream *st, char *mime)\n{\n    int number_of_streams = avio_rb16(pb);\n    int number_of_mdpr;\n    int i, ret;\n    unsigned size2;\n    for (i = 0; i<number_of_streams; i++)\n        avio_rb16(pb);\n    number_of_mdpr = avio_rb16(pb);\n    if (number_of_mdpr != 1) {\n        avpriv_request_sample(s, \"MLTI with multiple (%d) MDPR\", number_of_mdpr);\n    }\n    for (i = 0; i < number_of_mdpr; i++) {\n        AVStream *st2;\n        if (i > 0) {\n            st2 = avformat_new_stream(s, NULL);\n            if (!st2) {\n                ret = AVERROR(ENOMEM);\n                return ret;\n            }\n            st2->id = st->id + (i<<16);\n            st2->codecpar->bit_rate = st->codecpar->bit_rate;\n            st2->start_time = st->start_time;\n            st2->duration   = st->duration;\n            st2->codecpar->codec_type = AVMEDIA_TYPE_DATA;\n            st2->priv_data = ff_rm_alloc_rmstream();\n            if (!st2->priv_data)\n                return AVERROR(ENOMEM);\n        } else\n            st2 = st;\n\n        size2 = avio_rb32(pb);\n        ret = ff_rm_read_mdpr_codecdata(s, s->pb, st2, st2->priv_data,\n                                        size2, NULL);\n        if (ret < 0)\n            return ret;\n    }\n    return 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149893,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "vips_foreign_load_gif_scan_image( VipsForeignLoadGif *gif ) \n{\n\tVipsObjectClass *class = VIPS_OBJECT_GET_CLASS( gif );\n\tGifFileType *file = gif->file;\n\tColorMapObject *map = file->Image.ColorMap ?\n\t\tfile->Image.ColorMap : file->SColorMap;\n\n\tGifByteType *extension;\n\n\tif( DGifGetImageDesc( gif->file ) == GIF_ERROR ) {\n\t\tvips_foreign_load_gif_error( gif ); \n\t\treturn( -1 );\n\t}\n\n\t/* Check that the frame looks sane. Perhaps giflib checks\n\t * this for us.\n\t */\n\tif( file->Image.Left < 0 ||\n\t\tfile->Image.Width < 1 ||\n\t\tfile->Image.Width > 10000 ||\n\t\tfile->Image.Left + file->Image.Width > file->SWidth ||\n\t\tfile->Image.Top < 0 ||\n\t\tfile->Image.Height < 1 ||\n\t\tfile->Image.Height > 10000 ||\n\t\tfile->Image.Top + file->Image.Height > file->SHeight ) {\n\t\tvips_error( class->nickname, \"%s\", _( \"bad frame size\" ) ); \n\t\treturn( -1 ); \n\t}\n\n\t/* Test for a non-greyscale colourmap for this frame.\n\t */\n\tif( !gif->has_colour &&\n\t\tmap ) {\n\t\tint i;\n\n\t\tfor( i = 0; i < map->ColorCount; i++ ) \n\t\t\tif( map->Colors[i].Red != map->Colors[i].Green ||\n\t\t\t\tmap->Colors[i].Green != map->Colors[i].Blue ) {\n\t\t\t\tgif->has_colour = TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\t/* Step over compressed image data.\n\t */\n\tdo {\n\t\tif( vips_foreign_load_gif_code_next( gif, &extension ) ) \n\t\t\treturn( -1 );\n\t} while( extension != NULL );\n\n\treturn( 0 );\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149898,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "vips_foreign_load_gif_scan_image( VipsForeignLoadGif *gif ) \n{\n\tVipsObjectClass *class = VIPS_OBJECT_GET_CLASS( gif );\n\tGifFileType *file = gif->file;\n\n\tColorMapObject *map;\n\tGifByteType *extension;\n\n\tif( DGifGetImageDesc( gif->file ) == GIF_ERROR ) {\n\t\tvips_foreign_load_gif_error( gif ); \n\t\treturn( -1 );\n\t}\n\n\t/* Check that the frame looks sane. Perhaps giflib checks\n\t * this for us.\n\t */\n\tif( file->Image.Left < 0 ||\n\t\tfile->Image.Width < 1 ||\n\t\tfile->Image.Width > 10000 ||\n\t\tfile->Image.Left + file->Image.Width > file->SWidth ||\n\t\tfile->Image.Top < 0 ||\n\t\tfile->Image.Height < 1 ||\n\t\tfile->Image.Height > 10000 ||\n\t\tfile->Image.Top + file->Image.Height > file->SHeight ) {\n\t\tvips_error( class->nickname, \"%s\", _( \"bad frame size\" ) ); \n\t\treturn( -1 ); \n\t}\n\n\t/* Test for a non-greyscale colourmap for this frame.\n\t */\n\tmap = file->Image.ColorMap ? file->Image.ColorMap : file->SColorMap;\n\tif( !gif->has_colour &&\n\t\tmap ) {\n\t\tint i;\n\n\t\tfor( i = 0; i < map->ColorCount; i++ ) \n\t\t\tif( map->Colors[i].Red != map->Colors[i].Green ||\n\t\t\t\tmap->Colors[i].Green != map->Colors[i].Blue ) {\n\t\t\t\tgif->has_colour = TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\t/* Step over compressed image data.\n\t */\n\tdo {\n\t\tif( vips_foreign_load_gif_code_next( gif, &extension ) ) \n\t\t\treturn( -1 );\n\t} while( extension != NULL );\n\n\treturn( 0 );\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149899,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  register Quantum *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n  BlobInfo *blob;\n  size_t one;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\n\n  /*\n     Open image file.\n   */\n  image = AcquireImage(image_info,exception);\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  quantum_info=(QuantumInfo *) NULL;\n  clone_info=(ImageInfo *) NULL;\n  if (ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (strncmp(MATLAB_HDR.identific,\"MATLAB\",6) != 0)\n    {\n      image2=ReadMATImageV4(image_info,image,exception);\n      if (image2  == NULL)\n        goto MATLAB_KO;\n      image=image2;\n      goto END_OF_READING;\n    }\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if (logging)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\n      MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n    goto MATLAB_KO;    /* unsupported endian */\n\n  if (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\n    {\nMATLAB_KO:\n      if ((image != image2) && (image2 != (Image *) NULL))\n        image2=DestroyImage(image2);\n      if (clone_info != (ImageInfo *) NULL)\n        clone_info=DestroyImageInfo(clone_info);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n\n  filepos = TellBlob(image);\n  while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    (void) SeekBlob(image,filepos,SEEK_SET);\n    /* printf(\"pos=%X\\n\",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) > GetBlobSize(image))\n      goto MATLAB_KO;\n    filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n\n    clone_info=CloneImageInfo(image_info);\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif\n\n    if (MATLAB_HDR.DataType!=miMATRIX)\n      {\n        clone_info=DestroyImageInfo(clone_info);\n        continue;  /* skip another objects. */\n      }\n\n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n\n\n    switch(MATLAB_HDR.DimFlag)\n    {\n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           (void) ReadBlobXXXLong(image2);\n         if(z!=3) ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         break;\n      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n         if(z!=3 && z!=1)\n            ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         Frames = ReadBlobXXXLong(image2);\n         if (Frames == 0)\n           ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n         break;\n      default:\n        if (clone_info != (ImageInfo *) NULL)\n          clone_info=DestroyImageInfo(clone_info);\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n    }\n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n\n    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */\n\n    NEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;\n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {              /* complex float type cell */\n  }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64;\n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          ThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {                         /* complex double type cell */\n  }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        if (clone_info)\n          clone_info=DestroyImageInfo(clone_info);\n        ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;\n    one=1;\n    image->colors = one << image->depth;\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n    if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)\n      goto MATLAB_KO;\n    /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        image->type=GrayscaleType;\n        SetImageColorspace(image,GRAYColorspace,exception);\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      {\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        return(DestroyImageList(image));\n      }\n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  /* ----- Load raster data ----- */\n    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n    if (BImgBuff == NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));\n\n    MinVal = 0;\n    MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n  }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n    {\nImportQuantumPixelsFailed:\n      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n      break;\n    }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n      goto ImportQuantumPixelsFailed;\n\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n      FixSignedValues(image,q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n      }\n    } while(z-- >= 2);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          InsertComplexDoubleRow(image, (double *)BImgBuff, i, MinVal, MaxVal,\n            exception);\n  }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          InsertComplexFloatRow(image,(float *)BImgBuff,i,MinVal,MaxVal,\n            exception);\n  }\n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n\n      blob = rotated_image->blob;\n      rotated_image->blob = image->blob;\n      rotated_image->colors = image->colors;\n      image->blob = blob;\n      AppendImageToList(&image,rotated_image);\n      DeleteImageFromList(&image);\n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2);\n  if(clone_info)\n  {\n          if(clone_info->file)\n    {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n    }\n        }\n      }\n\n      /* Allocate next image structure. */\n    AcquireNextImage(image_info,image,exception);\n    if (image->next == (Image *) NULL) break;\n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;\n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      goto NEXT_FRAME;\n    }\n    if ((image2!=NULL) && (image2!=image))   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n          }\n        }\n        }\n\n    if (quantum_info != (QuantumInfo *) NULL)\n      quantum_info=DestroyQuantumInfo(quantum_info);\n    if (clone_info)\n      clone_info=DestroyImageInfo(clone_info);\n  }\n\n  RelinquishMagickMemory(BImgBuff);\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\nEND_OF_READING:\n  if (clone_info)\n    clone_info=DestroyImageInfo(clone_info);\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n  if (image==NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\")\n  else\n    if ((image != image2) && (image2 != (Image *) NULL))\n      image2=DestroyImage(image2);\n  return (image);\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149900,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  register Quantum *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n  BlobInfo *blob;\n  size_t one;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\n\n  /*\n     Open image file.\n   */\n  image = AcquireImage(image_info,exception);\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  quantum_info=(QuantumInfo *) NULL;\n  clone_info=(ImageInfo *) NULL;\n  if (ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (strncmp(MATLAB_HDR.identific,\"MATLAB\",6) != 0)\n    {\n      image2=ReadMATImageV4(image_info,image,exception);\n      if (image2  == NULL)\n        goto MATLAB_KO;\n      image=image2;\n      goto END_OF_READING;\n    }\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if (logging)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\n      MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n    goto MATLAB_KO;    /* unsupported endian */\n\n  if (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\n    {\nMATLAB_KO:\n      if ((image != image2) && (image2 != (Image *) NULL))\n        image2=DestroyImage(image2);\n      if (clone_info != (ImageInfo *) NULL)\n        clone_info=DestroyImageInfo(clone_info);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n\n  filepos = TellBlob(image);\n  while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    (void) SeekBlob(image,filepos,SEEK_SET);\n    /* printf(\"pos=%X\\n\",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) > GetBlobSize(image))\n      goto MATLAB_KO;\n    filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n\n    clone_info=CloneImageInfo(image_info);\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif\n\n    if (MATLAB_HDR.DataType!=miMATRIX)\n      {\n        clone_info=DestroyImageInfo(clone_info);\n        continue;  /* skip another objects. */\n      }\n\n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n\n\n    switch(MATLAB_HDR.DimFlag)\n    {\n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           (void) ReadBlobXXXLong(image2);\n         if(z!=3) ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         break;\n      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n         if(z!=3 && z!=1)\n            ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         Frames = ReadBlobXXXLong(image2);\n         if (Frames == 0)\n           ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n         break;\n      default:\n        if (clone_info != (ImageInfo *) NULL)\n          clone_info=DestroyImageInfo(clone_info);\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n    }\n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n\n    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */\n\n    NEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;\n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {              /* complex float type cell */\n  }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64;\n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          ThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {                         /* complex double type cell */\n  }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        if (clone_info)\n          clone_info=DestroyImageInfo(clone_info);\n        ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;\n    one=1;\n    image->colors = one << image->depth;\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n    if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)\n      goto MATLAB_KO;\n    /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        image->type=GrayscaleType;\n        SetImageColorspace(image,GRAYColorspace,exception);\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      {\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        return(DestroyImageList(image));\n      }\n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  /* ----- Load raster data ----- */\n    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n    if (BImgBuff == NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));\n\n    MinVal = 0;\n    MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n  }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n    {\nImportQuantumPixelsFailed:\n      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n      break;\n    }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n      goto ImportQuantumPixelsFailed;\n\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n      FixSignedValues(image,q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n      }\n    } while(z-- >= 2);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          InsertComplexDoubleRow(image, (double *)BImgBuff, i, MinVal, MaxVal,\n            exception);\n  }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          InsertComplexFloatRow(image,(float *)BImgBuff,i,MinVal,MaxVal,\n            exception);\n  }\n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n\n      blob = rotated_image->blob;\n      rotated_image->blob = image->blob;\n      rotated_image->colors = image->colors;\n      image->blob = blob;\n      AppendImageToList(&image,rotated_image);\n      DeleteImageFromList(&image);\n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2);\n  if(clone_info)\n  {\n          if(clone_info->file)\n    {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n    }\n        }\n      }\n\n      /* Allocate next image structure. */\n    AcquireNextImage(image_info,image,exception);\n    if (image->next == (Image *) NULL) break;\n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;\n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      goto NEXT_FRAME;\n    }\n    if ((image2!=NULL) && (image2!=image))   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n          }\n        }\n        }\n\n    if (quantum_info != (QuantumInfo *) NULL)\n      quantum_info=DestroyQuantumInfo(quantum_info);\n    if (clone_info)\n      clone_info=DestroyImageInfo(clone_info);\n  }\n\n  RelinquishMagickMemory(BImgBuff);\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\nEND_OF_READING:\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          if (tmp == image2)\n            image2=(Image *) NULL;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n  if (image==NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\")\n  else\n    if ((image != image2) && (image2 != (Image *) NULL))\n      image2=DestroyImage(image2);\n  return (image);\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149901,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static OPJ_BOOL opj_j2k_write_mco(     opj_j2k_t *p_j2k,\n                                                struct opj_stream_private *p_stream,\n                                                struct opj_event_mgr * p_manager\n                                  )\n{\n        OPJ_BYTE * l_current_data = 00;\n        OPJ_UINT32 l_mco_size;\n        opj_tcp_t * l_tcp = 00;\n        opj_simple_mcc_decorrelation_data_t * l_mcc_record;\n        OPJ_UINT32 i;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_stream != 00);\n\n        l_tcp =&(p_j2k->m_cp.tcps[p_j2k->m_current_tile_number]);\n        l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;\n\n        l_mco_size = 5 + l_tcp->m_nb_mcc_records;\n        if (l_mco_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {\n\n                OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_mco_size);\n                if (! new_header_tile_data) {\n                        opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);\n                        p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;\n                        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;\n                        opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to write MCO marker\\n\");\n                        return OPJ_FALSE;\n                }\n                p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;\n                p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_mco_size;\n        }\n\n        opj_write_bytes(l_current_data,J2K_MS_MCO,2);                   /* MCO */\n        l_current_data += 2;\n\n        opj_write_bytes(l_current_data,l_mco_size-2,2);                 /* Lmco */\n        l_current_data += 2;\n\n        opj_write_bytes(l_current_data,l_tcp->m_nb_mcc_records,1);      /* Nmco : only one tranform stage*/\n        ++l_current_data;\n\n        l_mcc_record = l_tcp->m_mcc_records;\n        for     (i=0;i<l_tcp->m_nb_mcc_records;++i) {\n                opj_write_bytes(l_current_data,l_mcc_record->m_index,1);/* Imco -> use the mcc indicated by 1*/\n                ++l_current_data;\n\n                ++l_mcc_record;\n        }\n\n        if (opj_stream_write_data(p_stream,p_j2k->m_specific_param.m_encoder.m_header_tile_data,l_mco_size,p_manager) != l_mco_size) {\n                return OPJ_FALSE;\n        }\n\n        return OPJ_TRUE;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149902,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static OPJ_BOOL opj_j2k_write_mco(     opj_j2k_t *p_j2k,\n                                                struct opj_stream_private *p_stream,\n                                                struct opj_event_mgr * p_manager\n                                  )\n{\n        OPJ_BYTE * l_current_data = 00;\n        OPJ_UINT32 l_mco_size;\n        opj_tcp_t * l_tcp = 00;\n        opj_simple_mcc_decorrelation_data_t * l_mcc_record;\n        OPJ_UINT32 i;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_stream != 00);\n\n        l_tcp =&(p_j2k->m_cp.tcps[p_j2k->m_current_tile_number]);\n\t\n        l_mco_size = 5 + l_tcp->m_nb_mcc_records;\n        if (l_mco_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {\n\n                OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_mco_size);\n                if (! new_header_tile_data) {\n                        opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);\n                        p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;\n                        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;\n                        opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to write MCO marker\\n\");\n                        return OPJ_FALSE;\n                }\n                p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;\n                p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_mco_size;\n        }\n        l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;\n\n\n        opj_write_bytes(l_current_data,J2K_MS_MCO,2);                   /* MCO */\n        l_current_data += 2;\n\n        opj_write_bytes(l_current_data,l_mco_size-2,2);                 /* Lmco */\n        l_current_data += 2;\n\n        opj_write_bytes(l_current_data,l_tcp->m_nb_mcc_records,1);      /* Nmco : only one tranform stage*/\n        ++l_current_data;\n\n        l_mcc_record = l_tcp->m_mcc_records;\n        for (i=0;i<l_tcp->m_nb_mcc_records;++i) {\n                opj_write_bytes(l_current_data,l_mcc_record->m_index,1);/* Imco -> use the mcc indicated by 1*/\n                ++l_current_data;\n                ++l_mcc_record;\n        }\n\n        if (opj_stream_write_data(p_stream,p_j2k->m_specific_param.m_encoder.m_header_tile_data,l_mco_size,p_manager) != l_mco_size) {\n                return OPJ_FALSE;\n        }\n\n        return OPJ_TRUE;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149903,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "tcpmss_mangle_packet(struct sk_buff *skb,\n\t\t     const struct xt_action_param *par,\n\t\t     unsigned int family,\n\t\t     unsigned int tcphoff,\n\t\t     unsigned int minlen)\n{\n\tconst struct xt_tcpmss_info *info = par->targinfo;\n\tstruct tcphdr *tcph;\n\tint len, tcp_hdrlen;\n\tunsigned int i;\n\t__be16 oldval;\n\tu16 newmss;\n\tu8 *opt;\n\n\t/* This is a fragment, no TCP header is available */\n\tif (par->fragoff != 0)\n\t\treturn 0;\n\n\tif (!skb_make_writable(skb, skb->len))\n\t\treturn -1;\n\n\tlen = skb->len - tcphoff;\n\tif (len < (int)sizeof(struct tcphdr))\n\t\treturn -1;\n\n\ttcph = (struct tcphdr *)(skb_network_header(skb) + tcphoff);\n\ttcp_hdrlen = tcph->doff * 4;\n\n\tif (len < tcp_hdrlen)\n\t\treturn -1;\n\n\tif (info->mss == XT_TCPMSS_CLAMP_PMTU) {\n\t\tstruct net *net = xt_net(par);\n\t\tunsigned int in_mtu = tcpmss_reverse_mtu(net, skb, family);\n\t\tunsigned int min_mtu = min(dst_mtu(skb_dst(skb)), in_mtu);\n\n\t\tif (min_mtu <= minlen) {\n\t\t\tnet_err_ratelimited(\"unknown or invalid path-MTU (%u)\\n\",\n\t\t\t\t\t    min_mtu);\n\t\t\treturn -1;\n\t\t}\n\t\tnewmss = min_mtu - minlen;\n\t} else\n\t\tnewmss = info->mss;\n\n\topt = (u_int8_t *)tcph;\n\tfor (i = sizeof(struct tcphdr); i <= tcp_hdrlen - TCPOLEN_MSS; i += optlen(opt, i)) {\n\t\tif (opt[i] == TCPOPT_MSS && opt[i+1] == TCPOLEN_MSS) {\n\t\t\tu_int16_t oldmss;\n\n\t\t\toldmss = (opt[i+2] << 8) | opt[i+3];\n\n\t\t\t/* Never increase MSS, even when setting it, as\n\t\t\t * doing so results in problems for hosts that rely\n\t\t\t * on MSS being set correctly.\n\t\t\t */\n\t\t\tif (oldmss <= newmss)\n\t\t\t\treturn 0;\n\n\t\t\topt[i+2] = (newmss & 0xff00) >> 8;\n\t\t\topt[i+3] = newmss & 0x00ff;\n\n\t\t\tinet_proto_csum_replace2(&tcph->check, skb,\n\t\t\t\t\t\t htons(oldmss), htons(newmss),\n\t\t\t\t\t\t false);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* There is data after the header so the option can't be added\n\t * without moving it, and doing so may make the SYN packet\n\t * itself too large. Accept the packet unmodified instead.\n\t */\n\tif (len > tcp_hdrlen)\n\t\treturn 0;\n\n\t/*\n\t * MSS Option not found ?! add it..\n\t */\n\tif (skb_tailroom(skb) < TCPOLEN_MSS) {\n\t\tif (pskb_expand_head(skb, 0,\n\t\t\t\t     TCPOLEN_MSS - skb_tailroom(skb),\n\t\t\t\t     GFP_ATOMIC))\n\t\t\treturn -1;\n\t\ttcph = (struct tcphdr *)(skb_network_header(skb) + tcphoff);\n\t}\n\n\tskb_put(skb, TCPOLEN_MSS);\n\n\t/*\n\t * IPv4: RFC 1122 states \"If an MSS option is not received at\n\t * connection setup, TCP MUST assume a default send MSS of 536\".\n\t * IPv6: RFC 2460 states IPv6 has a minimum MTU of 1280 and a minimum\n\t * length IPv6 header of 60, ergo the default MSS value is 1220\n\t * Since no MSS was provided, we must use the default values\n\t */\n\tif (xt_family(par) == NFPROTO_IPV4)\n\t\tnewmss = min(newmss, (u16)536);\n\telse\n\t\tnewmss = min(newmss, (u16)1220);\n\n\topt = (u_int8_t *)tcph + sizeof(struct tcphdr);\n\tmemmove(opt + TCPOLEN_MSS, opt, len - sizeof(struct tcphdr));\n\n\tinet_proto_csum_replace2(&tcph->check, skb,\n\t\t\t\t htons(len), htons(len + TCPOLEN_MSS), true);\n\topt[0] = TCPOPT_MSS;\n\topt[1] = TCPOLEN_MSS;\n\topt[2] = (newmss & 0xff00) >> 8;\n\topt[3] = newmss & 0x00ff;\n\n\tinet_proto_csum_replace4(&tcph->check, skb, 0, *((__be32 *)opt), false);\n\n\toldval = ((__be16 *)tcph)[6];\n\ttcph->doff += TCPOLEN_MSS/4;\n\tinet_proto_csum_replace2(&tcph->check, skb,\n\t\t\t\t oldval, ((__be16 *)tcph)[6], false);\n\treturn TCPOLEN_MSS;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149904,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "tcpmss_mangle_packet(struct sk_buff *skb,\n\t\t     const struct xt_action_param *par,\n\t\t     unsigned int family,\n\t\t     unsigned int tcphoff,\n\t\t     unsigned int minlen)\n{\n\tconst struct xt_tcpmss_info *info = par->targinfo;\n\tstruct tcphdr *tcph;\n\tint len, tcp_hdrlen;\n\tunsigned int i;\n\t__be16 oldval;\n\tu16 newmss;\n\tu8 *opt;\n\n\t/* This is a fragment, no TCP header is available */\n\tif (par->fragoff != 0)\n\t\treturn 0;\n\n\tif (!skb_make_writable(skb, skb->len))\n\t\treturn -1;\n\n\tlen = skb->len - tcphoff;\n\tif (len < (int)sizeof(struct tcphdr))\n\t\treturn -1;\n\n\ttcph = (struct tcphdr *)(skb_network_header(skb) + tcphoff);\n\ttcp_hdrlen = tcph->doff * 4;\n\n\tif (len < tcp_hdrlen || tcp_hdrlen < sizeof(struct tcphdr))\n\t\treturn -1;\n\n\tif (info->mss == XT_TCPMSS_CLAMP_PMTU) {\n\t\tstruct net *net = xt_net(par);\n\t\tunsigned int in_mtu = tcpmss_reverse_mtu(net, skb, family);\n\t\tunsigned int min_mtu = min(dst_mtu(skb_dst(skb)), in_mtu);\n\n\t\tif (min_mtu <= minlen) {\n\t\t\tnet_err_ratelimited(\"unknown or invalid path-MTU (%u)\\n\",\n\t\t\t\t\t    min_mtu);\n\t\t\treturn -1;\n\t\t}\n\t\tnewmss = min_mtu - minlen;\n\t} else\n\t\tnewmss = info->mss;\n\n\topt = (u_int8_t *)tcph;\n\tfor (i = sizeof(struct tcphdr); i <= tcp_hdrlen - TCPOLEN_MSS; i += optlen(opt, i)) {\n\t\tif (opt[i] == TCPOPT_MSS && opt[i+1] == TCPOLEN_MSS) {\n\t\t\tu_int16_t oldmss;\n\n\t\t\toldmss = (opt[i+2] << 8) | opt[i+3];\n\n\t\t\t/* Never increase MSS, even when setting it, as\n\t\t\t * doing so results in problems for hosts that rely\n\t\t\t * on MSS being set correctly.\n\t\t\t */\n\t\t\tif (oldmss <= newmss)\n\t\t\t\treturn 0;\n\n\t\t\topt[i+2] = (newmss & 0xff00) >> 8;\n\t\t\topt[i+3] = newmss & 0x00ff;\n\n\t\t\tinet_proto_csum_replace2(&tcph->check, skb,\n\t\t\t\t\t\t htons(oldmss), htons(newmss),\n\t\t\t\t\t\t false);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* There is data after the header so the option can't be added\n\t * without moving it, and doing so may make the SYN packet\n\t * itself too large. Accept the packet unmodified instead.\n\t */\n\tif (len > tcp_hdrlen)\n\t\treturn 0;\n\n\t/* tcph->doff has 4 bits, do not wrap it to 0 */\n\tif (tcp_hdrlen >= 15 * 4)\n\t\treturn 0;\n\n\t/*\n\t * MSS Option not found ?! add it..\n\t */\n\tif (skb_tailroom(skb) < TCPOLEN_MSS) {\n\t\tif (pskb_expand_head(skb, 0,\n\t\t\t\t     TCPOLEN_MSS - skb_tailroom(skb),\n\t\t\t\t     GFP_ATOMIC))\n\t\t\treturn -1;\n\t\ttcph = (struct tcphdr *)(skb_network_header(skb) + tcphoff);\n\t}\n\n\tskb_put(skb, TCPOLEN_MSS);\n\n\t/*\n\t * IPv4: RFC 1122 states \"If an MSS option is not received at\n\t * connection setup, TCP MUST assume a default send MSS of 536\".\n\t * IPv6: RFC 2460 states IPv6 has a minimum MTU of 1280 and a minimum\n\t * length IPv6 header of 60, ergo the default MSS value is 1220\n\t * Since no MSS was provided, we must use the default values\n\t */\n\tif (xt_family(par) == NFPROTO_IPV4)\n\t\tnewmss = min(newmss, (u16)536);\n\telse\n\t\tnewmss = min(newmss, (u16)1220);\n\n\topt = (u_int8_t *)tcph + sizeof(struct tcphdr);\n\tmemmove(opt + TCPOLEN_MSS, opt, len - sizeof(struct tcphdr));\n\n\tinet_proto_csum_replace2(&tcph->check, skb,\n\t\t\t\t htons(len), htons(len + TCPOLEN_MSS), true);\n\topt[0] = TCPOPT_MSS;\n\topt[1] = TCPOLEN_MSS;\n\topt[2] = (newmss & 0xff00) >> 8;\n\topt[3] = newmss & 0x00ff;\n\n\tinet_proto_csum_replace4(&tcph->check, skb, 0, *((__be32 *)opt), false);\n\n\toldval = ((__be16 *)tcph)[6];\n\ttcph->doff += TCPOLEN_MSS/4;\n\tinet_proto_csum_replace2(&tcph->check, skb,\n\t\t\t\t oldval, ((__be16 *)tcph)[6], false);\n\treturn TCPOLEN_MSS;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149905,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "void luaD_shrinkstack (lua_State *L) {\n  int inuse = stackinuse(L);\n  int goodsize = inuse + (inuse / 8) + 2*EXTRA_STACK;\n  if (goodsize > LUAI_MAXSTACK)\n    goodsize = LUAI_MAXSTACK;  /* respect stack limit */\n  /* if thread is currently not handling a stack overflow and its\n     good size is smaller than current size, shrink its stack */\n  if (inuse <= (LUAI_MAXSTACK - EXTRA_STACK) &&\n      goodsize < L->stacksize)\n    luaD_reallocstack(L, goodsize, 0);  /* ok if that fails */\n  else  /* don't change stack */\n    condmovestack(L,{},{});  /* (change only for debugging) */\n  luaE_shrinkCI(L);  /* shrink CI list */\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149906,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "void luaD_shrinkstack (lua_State *L) {\n  int inuse = stackinuse(L);\n  int goodsize = inuse + BASIC_STACK_SIZE;\n  if (goodsize > LUAI_MAXSTACK)\n    goodsize = LUAI_MAXSTACK;  /* respect stack limit */\n  /* if thread is currently not handling a stack overflow and its\n     good size is smaller than current size, shrink its stack */\n  if (inuse <= (LUAI_MAXSTACK - EXTRA_STACK) && goodsize < L->stacksize)\n    luaD_reallocstack(L, goodsize, 0);  /* ok if that fails */\n  else  /* don't change stack */\n    condmovestack(L,{},{});  /* (change only for debugging) */\n  luaE_shrinkCI(L);  /* shrink CI list */\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149907,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "mrb_vm_exec(mrb_state *mrb, struct RProc *proc, mrb_code *pc)\n{\n  /* mrb_assert(mrb_proc_cfunc_p(proc)) */\n  mrb_irep *irep = proc->body.irep;\n  mrb_value *pool = irep->pool;\n  mrb_sym *syms = irep->syms;\n  mrb_code i;\n  int ai = mrb_gc_arena_save(mrb);\n  struct mrb_jmpbuf *prev_jmp = mrb->jmp;\n  struct mrb_jmpbuf c_jmp;\n\n#ifdef DIRECT_THREADED\n  static void *optable[] = {\n    &&L_OP_NOP, &&L_OP_MOVE,\n    &&L_OP_LOADL, &&L_OP_LOADI, &&L_OP_LOADSYM, &&L_OP_LOADNIL,\n    &&L_OP_LOADSELF, &&L_OP_LOADT, &&L_OP_LOADF,\n    &&L_OP_GETGLOBAL, &&L_OP_SETGLOBAL, &&L_OP_GETSPECIAL, &&L_OP_SETSPECIAL,\n    &&L_OP_GETIV, &&L_OP_SETIV, &&L_OP_GETCV, &&L_OP_SETCV,\n    &&L_OP_GETCONST, &&L_OP_SETCONST, &&L_OP_GETMCNST, &&L_OP_SETMCNST,\n    &&L_OP_GETUPVAR, &&L_OP_SETUPVAR,\n    &&L_OP_JMP, &&L_OP_JMPIF, &&L_OP_JMPNOT,\n    &&L_OP_ONERR, &&L_OP_RESCUE, &&L_OP_POPERR, &&L_OP_RAISE, &&L_OP_EPUSH, &&L_OP_EPOP,\n    &&L_OP_SEND, &&L_OP_SENDB, &&L_OP_FSEND,\n    &&L_OP_CALL, &&L_OP_SUPER, &&L_OP_ARGARY, &&L_OP_ENTER,\n    &&L_OP_KARG, &&L_OP_KDICT, &&L_OP_RETURN, &&L_OP_TAILCALL, &&L_OP_BLKPUSH,\n    &&L_OP_ADD, &&L_OP_ADDI, &&L_OP_SUB, &&L_OP_SUBI, &&L_OP_MUL, &&L_OP_DIV,\n    &&L_OP_EQ, &&L_OP_LT, &&L_OP_LE, &&L_OP_GT, &&L_OP_GE,\n    &&L_OP_ARRAY, &&L_OP_ARYCAT, &&L_OP_ARYPUSH, &&L_OP_AREF, &&L_OP_ASET, &&L_OP_APOST,\n    &&L_OP_STRING, &&L_OP_STRCAT, &&L_OP_HASH,\n    &&L_OP_LAMBDA, &&L_OP_RANGE, &&L_OP_OCLASS,\n    &&L_OP_CLASS, &&L_OP_MODULE, &&L_OP_EXEC,\n    &&L_OP_METHOD, &&L_OP_SCLASS, &&L_OP_TCLASS,\n    &&L_OP_DEBUG, &&L_OP_STOP, &&L_OP_ERR,\n  };\n#endif\n\n  mrb_bool exc_catched = FALSE;\nRETRY_TRY_BLOCK:\n\n  MRB_TRY(&c_jmp) {\n\n  if (exc_catched) {\n    exc_catched = FALSE;\n    if (mrb->exc && mrb->exc->tt == MRB_TT_BREAK)\n      goto L_BREAK;\n    goto L_RAISE;\n  }\n  mrb->jmp = &c_jmp;\n  mrb->c->ci->proc = proc;\n  mrb->c->ci->nregs = irep->nregs;\n\n#define regs (mrb->c->stack)\n  INIT_DISPATCH {\n    CASE(OP_NOP) {\n      /* do nothing */\n      NEXT;\n    }\n\n    CASE(OP_MOVE) {\n      /* A B    R(A) := R(B) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      regs[a] = regs[b];\n      NEXT;\n    }\n\n    CASE(OP_LOADL) {\n      /* A Bx   R(A) := Pool(Bx) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n#ifdef MRB_WORD_BOXING\n      mrb_value val = pool[bx];\n#ifndef MRB_WITHOUT_FLOAT\n      if (mrb_float_p(val)) {\n        val = mrb_float_value(mrb, mrb_float(val));\n      }\n#endif\n      regs[a] = val;\n#else\n      regs[a] = pool[bx];\n#endif\n      NEXT;\n    }\n\n    CASE(OP_LOADI) {\n      /* A sBx  R(A) := sBx */\n      int a = GETARG_A(i);\n      mrb_int bx = GETARG_sBx(i);\n      SET_INT_VALUE(regs[a], bx);\n      NEXT;\n    }\n\n    CASE(OP_LOADSYM) {\n      /* A Bx   R(A) := Syms(Bx) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      SET_SYM_VALUE(regs[a], syms[bx]);\n      NEXT;\n    }\n\n    CASE(OP_LOADSELF) {\n      /* A      R(A) := self */\n      int a = GETARG_A(i);\n      regs[a] = regs[0];\n      NEXT;\n    }\n\n    CASE(OP_LOADT) {\n      /* A      R(A) := true */\n      int a = GETARG_A(i);\n      SET_TRUE_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_LOADF) {\n      /* A      R(A) := false */\n      int a = GETARG_A(i);\n      SET_FALSE_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETGLOBAL) {\n      /* A Bx   R(A) := getglobal(Syms(Bx)) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_value val = mrb_gv_get(mrb, syms[bx]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETGLOBAL) {\n      /* A Bx   setglobal(Syms(Bx), R(A)) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_gv_set(mrb, syms[bx], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETSPECIAL) {\n      /* A Bx   R(A) := Special[Bx] */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_value val = mrb_vm_special_get(mrb, bx);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETSPECIAL) {\n      /* A Bx   Special[Bx] := R(A) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_vm_special_set(mrb, bx, regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETIV) {\n      /* A Bx   R(A) := ivget(Bx) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_value val = mrb_vm_iv_get(mrb, syms[bx]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETIV) {\n      /* A Bx   ivset(Syms(Bx),R(A)) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_vm_iv_set(mrb, syms[bx], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETCV) {\n      /* A Bx   R(A) := cvget(Syms(Bx)) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_value val;\n      ERR_PC_SET(mrb, pc);\n      val = mrb_vm_cv_get(mrb, syms[bx]);\n      ERR_PC_CLR(mrb);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETCV) {\n      /* A Bx   cvset(Syms(Bx),R(A)) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_vm_cv_set(mrb, syms[bx], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETCONST) {\n      /* A Bx    R(A) := constget(Syms(Bx)) */\n      mrb_value val;\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_sym sym = syms[bx];\n\n      ERR_PC_SET(mrb, pc);\n      val = mrb_vm_const_get(mrb, sym);\n      ERR_PC_CLR(mrb);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETCONST) {\n      /* A Bx   constset(Syms(Bx),R(A)) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_vm_const_set(mrb, syms[bx], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETMCNST) {\n      /* A Bx   R(A) := R(A)::Syms(Bx) */\n      mrb_value val;\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n\n      ERR_PC_SET(mrb, pc);\n      val = mrb_const_get(mrb, regs[a], syms[bx]);\n      ERR_PC_CLR(mrb);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETMCNST) {\n      /* A Bx    R(A+1)::Syms(Bx) := R(A) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_const_set(mrb, regs[a+1], syms[bx], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETUPVAR) {\n      /* A B C  R(A) := uvget(B,C) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n      mrb_value *regs_a = regs + a;\n      struct REnv *e = uvenv(mrb, c);\n\n      if (!e) {\n        *regs_a = mrb_nil_value();\n      }\n      else {\n        *regs_a = e->stack[b];\n      }\n      NEXT;\n    }\n\n    CASE(OP_SETUPVAR) {\n      /* A B C  uvset(B,C,R(A)) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n\n      struct REnv *e = uvenv(mrb, c);\n\n      if (e) {\n        mrb_value *regs_a = regs + a;\n\n        if (b < MRB_ENV_STACK_LEN(e)) {\n          e->stack[b] = *regs_a;\n          mrb_write_barrier(mrb, (struct RBasic*)e);\n        }\n      }\n      NEXT;\n    }\n\n    CASE(OP_JMP) {\n      /* sBx    pc+=sBx */\n      int sbx = GETARG_sBx(i);\n      pc += sbx;\n      JUMP;\n    }\n\n    CASE(OP_JMPIF) {\n      /* A sBx  if R(A) pc+=sBx */\n      int a = GETARG_A(i);\n      int sbx = GETARG_sBx(i);\n      if (mrb_test(regs[a])) {\n        pc += sbx;\n        JUMP;\n      }\n      NEXT;\n    }\n\n    CASE(OP_JMPNOT) {\n      /* A sBx  if !R(A) pc+=sBx */\n      int a = GETARG_A(i);\n      int sbx = GETARG_sBx(i);\n      if (!mrb_test(regs[a])) {\n        pc += sbx;\n        JUMP;\n      }\n      NEXT;\n    }\n\n    CASE(OP_ONERR) {\n      /* sBx    pc+=sBx on exception */\n      int sbx = GETARG_sBx(i);\n      if (mrb->c->rsize <= mrb->c->ci->ridx) {\n        if (mrb->c->rsize == 0) mrb->c->rsize = RESCUE_STACK_INIT_SIZE;\n        else mrb->c->rsize *= 2;\n        mrb->c->rescue = (mrb_code **)mrb_realloc(mrb, mrb->c->rescue, sizeof(mrb_code*) * mrb->c->rsize);\n      }\n      mrb->c->rescue[mrb->c->ci->ridx++] = pc + sbx;\n      NEXT;\n    }\n\n    CASE(OP_RESCUE) {\n      /* A B    R(A) := exc; clear(exc); R(B) := matched (bool) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n      mrb_value exc;\n\n      if (c == 0) {\n        exc = mrb_obj_value(mrb->exc);\n        mrb->exc = 0;\n      }\n      else {           /* continued; exc taken from R(A) */\n        exc = regs[a];\n      }\n      if (b != 0) {\n        mrb_value e = regs[b];\n        struct RClass *ec;\n\n        switch (mrb_type(e)) {\n        case MRB_TT_CLASS:\n        case MRB_TT_MODULE:\n          break;\n        default:\n          {\n            mrb_value exc;\n\n            exc = mrb_exc_new_str_lit(mrb, E_TYPE_ERROR,\n                  \"class or module required for rescue clause\");\n            mrb_exc_set(mrb, exc);\n            goto L_RAISE;\n          }\n        }\n        ec = mrb_class_ptr(e);\n        regs[b] = mrb_bool_value(mrb_obj_is_kind_of(mrb, exc, ec));\n      }\n      if (a != 0 && c == 0) {\n        regs[a] = exc;\n      }\n      NEXT;\n    }\n\n    CASE(OP_POPERR) {\n      /* A      A.times{rescue_pop()} */\n      int a = GETARG_A(i);\n\n      mrb->c->ci->ridx -= a;\n      NEXT;\n    }\n\n    CASE(OP_RAISE) {\n      /* A      raise(R(A)) */\n      int a = GETARG_A(i);\n\n      mrb_exc_set(mrb, regs[a]);\n      goto L_RAISE;\n    }\n\n    CASE(OP_EPUSH) {\n      /* Bx     ensure_push(SEQ[Bx]) */\n      int bx = GETARG_Bx(i);\n      struct RProc *p;\n\n      p = mrb_closure_new(mrb, irep->reps[bx]);\n      /* push ensure_stack */\n      if (mrb->c->esize <= mrb->c->eidx+1) {\n        if (mrb->c->esize == 0) mrb->c->esize = ENSURE_STACK_INIT_SIZE;\n        else mrb->c->esize *= 2;\n        mrb->c->ensure = (struct RProc **)mrb_realloc(mrb, mrb->c->ensure, sizeof(struct RProc*) * mrb->c->esize);\n      }\n      mrb->c->ensure[mrb->c->eidx++] = p;\n      mrb->c->ensure[mrb->c->eidx] = NULL;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_EPOP) {\n      /* A      A.times{ensure_pop().call} */\n      int a = GETARG_A(i);\n      mrb_callinfo *ci = mrb->c->ci;\n      int n, epos = ci->epos;\n      mrb_value self = regs[0];\n      struct RClass *target_class = ci->target_class;\n\n      if (mrb->c->eidx <= epos) {\n        NEXT;\n      }\n\n      if (a > mrb->c->eidx - epos)\n        a = mrb->c->eidx - epos;\n      pc = pc + 1;\n      for (n=0; n<a; n++) {\n        proc = mrb->c->ensure[epos+n];\n        mrb->c->ensure[epos+n] = NULL;\n        if (proc == NULL) continue;\n        irep = proc->body.irep;\n        ci = cipush(mrb);\n        ci->mid = ci[-1].mid;\n        ci->argc = 0;\n        ci->proc = proc;\n        ci->stackent = mrb->c->stack;\n        ci->nregs = irep->nregs;\n        ci->target_class = target_class;\n        ci->pc = pc;\n        ci->acc = ci[-1].nregs;\n        mrb->c->stack += ci->acc;\n        stack_extend(mrb, ci->nregs);\n        regs[0] = self;\n        pc = irep->iseq;\n      }\n      pool = irep->pool;\n      syms = irep->syms;\n      mrb->c->eidx = epos;\n      JUMP;\n    }\n\n    CASE(OP_LOADNIL) {\n      /* A     R(A) := nil */\n      int a = GETARG_A(i);\n\n      SET_NIL_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_SENDB) {\n      /* A B C  R(A) := call(R(A),Syms(B),R(A+1),...,R(A+C),&R(A+C+1))*/\n      /* fall through */\n    };\n\n  L_SEND:\n    CASE(OP_SEND) {\n      /* A B C  R(A) := call(R(A),Syms(B),R(A+1),...,R(A+C)) */\n      int a = GETARG_A(i);\n      int n = GETARG_C(i);\n      int argc = (n == CALL_MAXARGS) ? -1 : n;\n      int bidx = (argc < 0) ? a+2 : a+n+1;\n      mrb_method_t m;\n      struct RClass *c;\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_value recv, blk;\n      mrb_sym mid = syms[GETARG_B(i)];\n\n      mrb_assert(bidx < ci->nregs);\n\n      recv = regs[a];\n      if (GET_OPCODE(i) != OP_SENDB) {\n        SET_NIL_VALUE(regs[bidx]);\n        blk = regs[bidx];\n      }\n      else {\n        blk = regs[bidx];\n        if (!mrb_nil_p(blk) && mrb_type(blk) != MRB_TT_PROC) {\n          blk = mrb_convert_type(mrb, blk, MRB_TT_PROC, \"Proc\", \"to_proc\");\n          /* The stack might have been reallocated during mrb_convert_type(),\n             see #3622 */\n          regs[bidx] = blk;\n        }\n      }\n      c = mrb_class(mrb, recv);\n      m = mrb_method_search_vm(mrb, &c, mid);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        mrb_sym missing = mrb_intern_lit(mrb, \"method_missing\");\n        m = mrb_method_search_vm(mrb, &c, missing);\n        if (MRB_METHOD_UNDEF_P(m) || (missing == mrb->c->ci->mid && mrb_obj_eq(mrb, regs[0], recv))) {\n          mrb_value args = (argc < 0) ? regs[a+1] : mrb_ary_new_from_values(mrb, n, regs+a+1);\n          ERR_PC_SET(mrb, pc);\n          mrb_method_missing(mrb, mid, recv, args);\n        }\n        if (argc >= 0) {\n          if (a+2 >= irep->nregs) {\n            stack_extend(mrb, a+3);\n          }\n          regs[a+1] = mrb_ary_new_from_values(mrb, n, regs+a+1);\n          regs[a+2] = blk;\n          argc = -1;\n        }\n        mrb_ary_unshift(mrb, regs[a+1], mrb_symbol_value(mid));\n        mid = missing;\n      }\n\n      /* push callinfo */\n      ci = cipush(mrb);\n      ci->mid = mid;\n      ci->stackent = mrb->c->stack;\n      ci->target_class = c;\n      ci->argc = argc;\n\n      ci->pc = pc + 1;\n      ci->acc = a;\n\n      /* prepare stack */\n      mrb->c->stack += a;\n\n      if (MRB_METHOD_CFUNC_P(m)) {\n        ci->nregs = (argc < 0) ? 3 : n+2;\n        if (MRB_METHOD_PROC_P(m)) {\n          struct RProc *p = MRB_METHOD_PROC(m);\n\n          ci->proc = p;\n          recv = p->body.func(mrb, recv);\n        }\n        else {\n          recv = MRB_METHOD_FUNC(m)(mrb, recv);\n        }\n        mrb_gc_arena_restore(mrb, ai);\n        mrb_gc_arena_shrink(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        ci = mrb->c->ci;\n        if (GET_OPCODE(i) == OP_SENDB) {\n          if (mrb_type(blk) == MRB_TT_PROC) {\n            struct RProc *p = mrb_proc_ptr(blk);\n            if (p && !MRB_PROC_STRICT_P(p) && MRB_PROC_ENV(p) == ci[-1].env) {\n              p->flags |= MRB_PROC_ORPHAN;\n            }\n          }\n        }\n        if (!ci->target_class) { /* return from context modifying method (resume/yield) */\n          if (ci->acc == CI_ACC_RESUMED) {\n            mrb->jmp = prev_jmp;\n            return recv;\n          }\n          else {\n            mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));\n            proc = ci[-1].proc;\n            irep = proc->body.irep;\n            pool = irep->pool;\n            syms = irep->syms;\n          }\n        }\n        mrb->c->stack[0] = recv;\n        /* pop stackpos */\n        mrb->c->stack = ci->stackent;\n        pc = ci->pc;\n        cipop(mrb);\n        JUMP;\n      }\n      else {\n        /* setup environment for calling method */\n        proc = ci->proc = MRB_METHOD_PROC(m);\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        ci->nregs = irep->nregs;\n        stack_extend(mrb, (argc < 0 && ci->nregs < 3) ? 3 : ci->nregs);\n        pc = irep->iseq;\n        JUMP;\n      }\n    }\n\n    CASE(OP_FSEND) {\n      /* A B C  R(A) := fcall(R(A),Syms(B),R(A+1),... ,R(A+C-1)) */\n      /* not implemented yet */\n      NEXT;\n    }\n\n    CASE(OP_CALL) {\n      /* A      R(A) := self.call(frame.argc, frame.argv) */\n      mrb_callinfo *ci;\n      mrb_value recv = mrb->c->stack[0];\n      struct RProc *m = mrb_proc_ptr(recv);\n\n      /* replace callinfo */\n      ci = mrb->c->ci;\n      ci->target_class = MRB_PROC_TARGET_CLASS(m);\n      ci->proc = m;\n      if (MRB_PROC_ENV_P(m)) {\n        mrb_sym mid;\n        struct REnv *e = MRB_PROC_ENV(m);\n\n        mid = e->mid;\n        if (mid) ci->mid = mid;\n        if (!e->stack) {\n          e->stack = mrb->c->stack;\n        }\n      }\n\n      /* prepare stack */\n      if (MRB_PROC_CFUNC_P(m)) {\n        recv = MRB_PROC_CFUNC(m)(mrb, recv);\n        mrb_gc_arena_restore(mrb, ai);\n        mrb_gc_arena_shrink(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        /* pop stackpos */\n        ci = mrb->c->ci;\n        mrb->c->stack = ci->stackent;\n        regs[ci->acc] = recv;\n        pc = ci->pc;\n        cipop(mrb);\n        irep = mrb->c->ci->proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        JUMP;\n      }\n      else {\n        /* setup environment for calling method */\n        proc = m;\n        irep = m->body.irep;\n        if (!irep) {\n          mrb->c->stack[0] = mrb_nil_value();\n          goto L_RETURN;\n        }\n        pool = irep->pool;\n        syms = irep->syms;\n        ci->nregs = irep->nregs;\n        stack_extend(mrb, ci->nregs);\n        if (ci->argc < 0) {\n          if (irep->nregs > 3) {\n            stack_clear(regs+3, irep->nregs-3);\n          }\n        }\n        else if (ci->argc+2 < irep->nregs) {\n          stack_clear(regs+ci->argc+2, irep->nregs-ci->argc-2);\n        }\n        if (MRB_PROC_ENV_P(m)) {\n          regs[0] = MRB_PROC_ENV(m)->stack[0];\n        }\n        pc = irep->iseq;\n        JUMP;\n      }\n    }\n\n    CASE(OP_SUPER) {\n      /* A C  R(A) := super(R(A+1),... ,R(A+C+1)) */\n      int a = GETARG_A(i);\n      int n = GETARG_C(i);\n      int argc = (n == CALL_MAXARGS) ? -1 : n;\n      int bidx = (argc < 0) ? a+2 : a+n+1;\n      mrb_method_t m;\n      struct RClass *c;\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_value recv, blk;\n      mrb_sym mid = ci->mid;\n      struct RClass* target_class = MRB_PROC_TARGET_CLASS(ci->proc);\n\n      mrb_assert(bidx < ci->nregs);\n\n      if (mid == 0 || !target_class) {\n        mrb_value exc = mrb_exc_new_str_lit(mrb, E_NOMETHOD_ERROR, \"super called outside of method\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      if (target_class->tt == MRB_TT_MODULE) {\n        target_class = ci->target_class;\n        if (target_class->tt != MRB_TT_ICLASS) {\n          mrb_value exc = mrb_exc_new_str_lit(mrb, E_RUNTIME_ERROR, \"superclass info lost [mruby limitations]\");\n          mrb_exc_set(mrb, exc);\n          goto L_RAISE;\n        }\n      }\n      recv = regs[0];\n      if (!mrb_obj_is_kind_of(mrb, recv, target_class)) {\n        mrb_value exc = mrb_exc_new_str_lit(mrb, E_TYPE_ERROR,\n                                            \"self has wrong type to call super in this context\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      blk = regs[bidx];\n      if (!mrb_nil_p(blk) && mrb_type(blk) != MRB_TT_PROC) {\n        blk = mrb_convert_type(mrb, blk, MRB_TT_PROC, \"Proc\", \"to_proc\");\n        /* The stack or ci stack might have been reallocated during\n           mrb_convert_type(), see #3622 and #3784 */\n        regs[bidx] = blk;\n        ci = mrb->c->ci;\n      }\n      c = target_class->super;\n      m = mrb_method_search_vm(mrb, &c, mid);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        mrb_sym missing = mrb_intern_lit(mrb, \"method_missing\");\n\n        if (mid != missing) {\n          c = mrb_class(mrb, recv);\n        }\n        m = mrb_method_search_vm(mrb, &c, missing);\n        if (MRB_METHOD_UNDEF_P(m)) {\n          mrb_value args = (argc < 0) ? regs[a+1] : mrb_ary_new_from_values(mrb, n, regs+a+1);\n          ERR_PC_SET(mrb, pc);\n          mrb_method_missing(mrb, mid, recv, args);\n        }\n        mid = missing;\n        if (argc >= 0) {\n          if (a+2 >= ci->nregs) {\n            stack_extend(mrb, a+3);\n          }\n          regs[a+1] = mrb_ary_new_from_values(mrb, n, regs+a+1);\n          regs[a+2] = blk;\n          argc = -1;\n        }\n        mrb_ary_unshift(mrb, regs[a+1], mrb_symbol_value(ci->mid));\n      }\n\n      /* push callinfo */\n      ci = cipush(mrb);\n      ci->mid = mid;\n      ci->stackent = mrb->c->stack;\n      ci->target_class = c;\n      ci->pc = pc + 1;\n      ci->argc = argc;\n\n      /* prepare stack */\n      mrb->c->stack += a;\n      mrb->c->stack[0] = recv;\n\n      if (MRB_METHOD_CFUNC_P(m)) {\n        mrb_value v;\n        ci->nregs = (argc < 0) ? 3 : n+2;\n        if (MRB_METHOD_PROC_P(m)) {\n          ci->proc = MRB_METHOD_PROC(m);\n        }\n        v = MRB_METHOD_CFUNC(m)(mrb, recv);\n        mrb_gc_arena_restore(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        ci = mrb->c->ci;\n        if (!ci->target_class) { /* return from context modifying method (resume/yield) */\n          if (ci->acc == CI_ACC_RESUMED) {\n            mrb->jmp = prev_jmp;\n            return v;\n          }\n          else {\n            mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));\n            proc = ci[-1].proc;\n            irep = proc->body.irep;\n            pool = irep->pool;\n            syms = irep->syms;\n          }\n        }\n        mrb->c->stack[0] = v;\n        /* pop stackpos */\n        mrb->c->stack = ci->stackent;\n        pc = ci->pc;\n        cipop(mrb);\n        JUMP;\n      }\n      else {\n        /* fill callinfo */\n        ci->acc = a;\n\n        /* setup environment for calling method */\n        proc = ci->proc = MRB_METHOD_PROC(m);\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        ci->nregs = irep->nregs;\n        stack_extend(mrb, (argc < 0 && ci->nregs < 3) ? 3 : ci->nregs);\n        pc = irep->iseq;\n        JUMP;\n      }\n    }\n\n    CASE(OP_ARGARY) {\n      /* A Bx   R(A) := argument array (16=6:1:5:4) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      int m1 = (bx>>10)&0x3f;\n      int r  = (bx>>9)&0x1;\n      int m2 = (bx>>4)&0x1f;\n      int lv = (bx>>0)&0xf;\n      mrb_value *stack;\n\n      if (mrb->c->ci->mid == 0 || mrb->c->ci->target_class == NULL) {\n        mrb_value exc;\n\n      L_NOSUPER:\n        exc = mrb_exc_new_str_lit(mrb, E_NOMETHOD_ERROR, \"super called outside of method\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      if (lv == 0) stack = regs + 1;\n      else {\n        struct REnv *e = uvenv(mrb, lv-1);\n        if (!e) goto L_NOSUPER;\n        if (MRB_ENV_STACK_LEN(e) <= m1+r+m2+1)\n          goto L_NOSUPER;\n        stack = e->stack + 1;\n      }\n      if (r == 0) {\n        regs[a] = mrb_ary_new_from_values(mrb, m1+m2, stack);\n      }\n      else {\n        mrb_value *pp = NULL;\n        struct RArray *rest;\n        int len = 0;\n\n        if (mrb_array_p(stack[m1])) {\n          struct RArray *ary = mrb_ary_ptr(stack[m1]);\n\n          pp = ARY_PTR(ary);\n          len = (int)ARY_LEN(ary);\n        }\n        regs[a] = mrb_ary_new_capa(mrb, m1+len+m2);\n        rest = mrb_ary_ptr(regs[a]);\n        if (m1 > 0) {\n          stack_copy(ARY_PTR(rest), stack, m1);\n        }\n        if (len > 0) {\n          stack_copy(ARY_PTR(rest)+m1, pp, len);\n        }\n        if (m2 > 0) {\n          stack_copy(ARY_PTR(rest)+m1+len, stack+m1+1, m2);\n        }\n        ARY_SET_LEN(rest, m1+len+m2);\n      }\n      regs[a+1] = stack[m1+r+m2];\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ENTER) {\n      /* Ax             arg setup according to flags (23=5:5:1:5:5:1:1) */\n      /* number of optional arguments times OP_JMP should follow */\n      mrb_aspec ax = GETARG_Ax(i);\n      int m1 = MRB_ASPEC_REQ(ax);\n      int o  = MRB_ASPEC_OPT(ax);\n      int r  = MRB_ASPEC_REST(ax);\n      int m2 = MRB_ASPEC_POST(ax);\n      /* unused\n      int k  = MRB_ASPEC_KEY(ax);\n      int kd = MRB_ASPEC_KDICT(ax);\n      int b  = MRB_ASPEC_BLOCK(ax);\n      */\n      int argc = mrb->c->ci->argc;\n      mrb_value *argv = regs+1;\n      mrb_value *argv0 = argv;\n      int len = m1 + o + r + m2;\n      mrb_value *blk = &argv[argc < 0 ? 1 : argc];\n\n      if (argc < 0) {\n        struct RArray *ary = mrb_ary_ptr(regs[1]);\n        argv = ARY_PTR(ary);\n        argc = (int)ARY_LEN(ary);\n        mrb_gc_protect(mrb, regs[1]);\n      }\n      if (mrb->c->ci->proc && MRB_PROC_STRICT_P(mrb->c->ci->proc)) {\n        if (argc >= 0) {\n          if (argc < m1 + m2 || (r == 0 && argc > len)) {\n            argnum_error(mrb, m1+m2);\n            goto L_RAISE;\n          }\n        }\n      }\n      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {\n        mrb_gc_protect(mrb, argv[0]);\n        argc = (int)RARRAY_LEN(argv[0]);\n        argv = RARRAY_PTR(argv[0]);\n      }\n      if (argc < len) {\n        int mlen = m2;\n        if (argc < m1+m2) {\n          if (m1 < argc)\n            mlen = argc - m1;\n          else\n            mlen = 0;\n        }\n        regs[len+1] = *blk; /* move block */\n        SET_NIL_VALUE(regs[argc+1]);\n        if (argv0 != argv) {\n          value_move(&regs[1], argv, argc-mlen); /* m1 + o */\n        }\n        if (argc < m1) {\n          stack_clear(&regs[argc+1], m1-argc);\n        }\n        if (mlen) {\n          value_move(&regs[len-m2+1], &argv[argc-mlen], mlen);\n        }\n        if (mlen < m2) {\n          stack_clear(&regs[len-m2+mlen+1], m2-mlen);\n        }\n        if (r) {\n          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);\n        }\n        if (o == 0 || argc < m1+m2) pc++;\n        else\n          pc += argc - m1 - m2 + 1;\n      }\n      else {\n        int rnum = 0;\n        if (argv0 != argv) {\n          regs[len+1] = *blk; /* move block */\n          value_move(&regs[1], argv, m1+o);\n        }\n        if (r) {\n          rnum = argc-m1-o-m2;\n          regs[m1+o+1] = mrb_ary_new_from_values(mrb, rnum, argv+m1+o);\n        }\n        if (m2) {\n          if (argc-m2 > m1) {\n            value_move(&regs[m1+o+r+1], &argv[m1+o+rnum], m2);\n          }\n        }\n        if (argv0 == argv) {\n          regs[len+1] = *blk; /* move block */\n        }\n        pc += o + 1;\n      }\n      mrb->c->ci->argc = len;\n      /* clear local (but non-argument) variables */\n      if (irep->nlocals-len-2 > 0) {\n        stack_clear(&regs[len+2], irep->nlocals-len-2);\n      }\n      JUMP;\n    }\n\n    CASE(OP_KARG) {\n      /* A B C          R(A) := kdict[Syms(B)]; if C kdict.rm(Syms(B)) */\n      /* if C == 2; raise unless kdict.empty? */\n      /* OP_JMP should follow to skip init code */\n      NEXT;\n    }\n\n    CASE(OP_KDICT) {\n      /* A C            R(A) := kdict */\n      NEXT;\n    }\n\n    L_RETURN:\n      i = MKOP_AB(OP_RETURN, GETARG_A(i), OP_R_NORMAL);\n      /* fall through */\n    CASE(OP_RETURN) {\n      /* A B     return R(A) (B=normal,in-block return/break) */\n      mrb_callinfo *ci;\n\n#define ecall_adjust() do {\\\n  ptrdiff_t cioff = ci - mrb->c->cibase;\\\n  ecall(mrb);\\\n  ci = mrb->c->cibase + cioff;\\\n} while (0)\n\n      ci = mrb->c->ci;\n      if (ci->mid) {\n        mrb_value blk;\n\n        if (ci->argc < 0) {\n          blk = regs[2];\n        }\n        else {\n          blk = regs[ci->argc+1];\n        }\n        if (mrb_type(blk) == MRB_TT_PROC) {\n          struct RProc *p = mrb_proc_ptr(blk);\n\n          if (!MRB_PROC_STRICT_P(p) &&\n              ci > mrb->c->cibase && MRB_PROC_ENV(p) == ci[-1].env) {\n            p->flags |= MRB_PROC_ORPHAN;\n          }\n        }\n      }\n\n      if (mrb->exc) {\n        mrb_callinfo *ci0;\n\n      L_RAISE:\n        ci0 = ci = mrb->c->ci;\n        if (ci == mrb->c->cibase) {\n          if (ci->ridx == 0) goto L_FTOP;\n          goto L_RESCUE;\n        }\n        while (ci[0].ridx == ci[-1].ridx) {\n          cipop(mrb);\n          mrb->c->stack = ci->stackent;\n          if (ci->acc == CI_ACC_SKIP && prev_jmp) {\n            mrb->jmp = prev_jmp;\n            MRB_THROW(prev_jmp);\n          }\n          ci = mrb->c->ci;\n          if (ci == mrb->c->cibase) {\n            if (ci->ridx == 0) {\n            L_FTOP:             /* fiber top */\n              if (mrb->c == mrb->root_c) {\n                mrb->c->stack = mrb->c->stbase;\n                goto L_STOP;\n              }\n              else {\n                struct mrb_context *c = mrb->c;\n\n                while (c->eidx > ci->epos) {\n                  ecall_adjust();\n                }\n                if (c->fib) {\n                  mrb_write_barrier(mrb, (struct RBasic*)c->fib);\n                }\n                mrb->c->status = MRB_FIBER_TERMINATED;\n                mrb->c = c->prev;\n                c->prev = NULL;\n                goto L_RAISE;\n              }\n            }\n            break;\n          }\n          /* call ensure only when we skip this callinfo */\n          if (ci[0].ridx == ci[-1].ridx) {\n            while (mrb->c->eidx > ci->epos) {\n              ecall_adjust();\n            }\n          }\n        }\n      L_RESCUE:\n        if (ci->ridx == 0) goto L_STOP;\n        proc = ci->proc;\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        if (ci < ci0) {\n          mrb->c->stack = ci[1].stackent;\n        }\n        stack_extend(mrb, irep->nregs);\n        pc = mrb->c->rescue[--ci->ridx];\n      }\n      else {\n        int acc;\n        mrb_value v;\n        struct RProc *dst;\n\n        ci = mrb->c->ci;\n        v = regs[GETARG_A(i)];\n        mrb_gc_protect(mrb, v);\n        switch (GETARG_B(i)) {\n        case OP_R_RETURN:\n          /* Fall through to OP_R_NORMAL otherwise */\n          if (ci->acc >=0 && MRB_PROC_ENV_P(proc) && !MRB_PROC_STRICT_P(proc)) {\n            mrb_callinfo *cibase = mrb->c->cibase;\n            dst = top_proc(mrb, proc);\n\n            if (MRB_PROC_ENV_P(dst)) {\n              struct REnv *e = MRB_PROC_ENV(dst);\n\n              if (!MRB_ENV_STACK_SHARED_P(e) || e->cxt != mrb->c) {\n                localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n                goto L_RAISE;\n              }\n            }\n            while (cibase <= ci && ci->proc != dst) {\n              if (ci->acc < 0) {\n                localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n                goto L_RAISE;\n              }\n              ci--;\n            }\n            if (ci <= cibase) {\n              localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n              goto L_RAISE;\n            }\n            break;\n          }\n        case OP_R_NORMAL:\n        NORMAL_RETURN:\n          if (ci == mrb->c->cibase) {\n            struct mrb_context *c;\n\n            if (!mrb->c->prev) { /* toplevel return */\n              localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n              goto L_RAISE;\n            }\n            if (mrb->c->prev->ci == mrb->c->prev->cibase) {\n              mrb_value exc = mrb_exc_new_str_lit(mrb, E_FIBER_ERROR, \"double resume\");\n              mrb_exc_set(mrb, exc);\n              goto L_RAISE;\n            }\n            while (mrb->c->eidx > 0) {\n              ecall(mrb);\n            }\n            /* automatic yield at the end */\n            c = mrb->c;\n            c->status = MRB_FIBER_TERMINATED;\n            mrb->c = c->prev;\n            c->prev = NULL;\n            mrb->c->status = MRB_FIBER_RUNNING;\n            ci = mrb->c->ci;\n          }\n          break;\n        case OP_R_BREAK:\n          if (MRB_PROC_STRICT_P(proc)) goto NORMAL_RETURN;\n          if (MRB_PROC_ORPHAN_P(proc)) { \n            mrb_value exc;\n\n          L_BREAK_ERROR:\n            exc = mrb_exc_new_str_lit(mrb, E_LOCALJUMP_ERROR,\n                                      \"break from proc-closure\");\n            mrb_exc_set(mrb, exc);\n            goto L_RAISE;\n          }\n          if (!MRB_PROC_ENV_P(proc) || !MRB_ENV_STACK_SHARED_P(MRB_PROC_ENV(proc))) {\n            goto L_BREAK_ERROR;\n          }\n          else {\n            struct REnv *e = MRB_PROC_ENV(proc);\n\n            if (e == mrb->c->cibase->env && proc != mrb->c->cibase->proc) {\n              goto L_BREAK_ERROR;\n            }\n            if (e->cxt != mrb->c) {\n              goto L_BREAK_ERROR;\n            }\n          }\n          while (mrb->c->eidx > mrb->c->ci->epos) {\n            ecall_adjust();\n          }\n          /* break from fiber block */\n          if (ci == mrb->c->cibase && ci->pc) {\n            struct mrb_context *c = mrb->c;\n\n            mrb->c = c->prev;\n            c->prev = NULL;\n            ci = mrb->c->ci;\n          }\n          if (ci->acc < 0) {\n            mrb_gc_arena_restore(mrb, ai);\n            mrb->c->vmexec = FALSE;\n            mrb->exc = (struct RObject*)break_new(mrb, proc, v);\n            mrb->jmp = prev_jmp;\n            MRB_THROW(prev_jmp);\n          }\n          if (FALSE) {\n          L_BREAK:\n            v = ((struct RBreak*)mrb->exc)->val;\n            proc = ((struct RBreak*)mrb->exc)->proc;\n            mrb->exc = NULL;\n            ci = mrb->c->ci;\n          }\n          mrb->c->stack = ci->stackent;\n          proc = proc->upper;\n          while (mrb->c->cibase < ci &&  ci[-1].proc != proc) {\n            if (ci[-1].acc == CI_ACC_SKIP) {\n              while (ci < mrb->c->ci) {\n                cipop(mrb);\n              }\n              goto L_BREAK_ERROR;\n            }\n            ci--;\n          }\n          if (ci == mrb->c->cibase) {\n            goto L_BREAK_ERROR;\n          }\n          break;\n        default:\n          /* cannot happen */\n          break;\n        }\n        while (ci < mrb->c->ci) {\n          cipop(mrb);\n        }\n        ci[0].ridx = ci[-1].ridx;\n        while (mrb->c->eidx > ci->epos) {\n          ecall_adjust();\n        }\n        if (mrb->c->vmexec && !ci->target_class) {\n          mrb_gc_arena_restore(mrb, ai);\n          mrb->c->vmexec = FALSE;\n          mrb->jmp = prev_jmp;\n          return v;\n        }\n        acc = ci->acc;\n        mrb->c->stack = ci->stackent;\n        cipop(mrb);\n        if (acc == CI_ACC_SKIP || acc == CI_ACC_DIRECT) {\n          mrb_gc_arena_restore(mrb, ai);\n          mrb->jmp = prev_jmp;\n          return v;\n        }\n        pc = ci->pc;\n        ci = mrb->c->ci;\n        DEBUG(fprintf(stderr, \"from :%s\\n\", mrb_sym2name(mrb, ci->mid)));\n        proc = mrb->c->ci->proc;\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n\n        regs[acc] = v;\n        mrb_gc_arena_restore(mrb, ai);\n      }\n      JUMP;\n    }\n\n    CASE(OP_TAILCALL) {\n      /* A B C  return call(R(A),Syms(B),R(A+1),... ,R(A+C+1)) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int n = GETARG_C(i);\n      mrb_method_t m;\n      struct RClass *c;\n      mrb_callinfo *ci;\n      mrb_value recv;\n      mrb_sym mid = syms[b];\n\n      recv = regs[a];\n      c = mrb_class(mrb, recv);\n      m = mrb_method_search_vm(mrb, &c, mid);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        mrb_value sym = mrb_symbol_value(mid);\n        mrb_sym missing = mrb_intern_lit(mrb, \"method_missing\");\n        m = mrb_method_search_vm(mrb, &c, missing);\n        if (MRB_METHOD_UNDEF_P(m)) {\n          mrb_value args;\n\n          if (n == CALL_MAXARGS) {\n            args = regs[a+1];\n          }\n          else {\n            args = mrb_ary_new_from_values(mrb, n, regs+a+1);\n          }\n          ERR_PC_SET(mrb, pc);\n          mrb_method_missing(mrb, mid, recv, args);\n        }\n        mid = missing;\n        if (n == CALL_MAXARGS) {\n          mrb_ary_unshift(mrb, regs[a+1], sym);\n        }\n        else {\n          value_move(regs+a+2, regs+a+1, ++n);\n          regs[a+1] = sym;\n        }\n      }\n\n      /* replace callinfo */\n      ci = mrb->c->ci;\n      ci->mid = mid;\n      ci->target_class = c;\n      if (n == CALL_MAXARGS) {\n        ci->argc = -1;\n      }\n      else {\n        ci->argc = n;\n      }\n\n      /* move stack */\n      value_move(mrb->c->stack, &regs[a], ci->argc+1);\n\n      if (MRB_METHOD_CFUNC_P(m)) {\n        mrb_value v = MRB_METHOD_CFUNC(m)(mrb, recv);\n        mrb->c->stack[0] = v;\n        mrb_gc_arena_restore(mrb, ai);\n        goto L_RETURN;\n      }\n      else {\n        /* setup environment for calling method */\n        struct RProc *p = MRB_METHOD_PROC(m);\n        irep = p->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        if (ci->argc < 0) {\n          stack_extend(mrb, (irep->nregs < 3) ? 3 : irep->nregs);\n        }\n        else {\n          stack_extend(mrb, irep->nregs);\n        }\n        pc = irep->iseq;\n      }\n      JUMP;\n    }\n\n    CASE(OP_BLKPUSH) {\n      /* A Bx   R(A) := block (16=6:1:5:4) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      int m1 = (bx>>10)&0x3f;\n      int r  = (bx>>9)&0x1;\n      int m2 = (bx>>4)&0x1f;\n      int lv = (bx>>0)&0xf;\n      mrb_value *stack;\n\n      if (lv == 0) stack = regs + 1;\n      else {\n        struct REnv *e = uvenv(mrb, lv-1);\n        if (!e || (!MRB_ENV_STACK_SHARED_P(e) && e->mid == 0) ||\n            MRB_ENV_STACK_LEN(e) <= m1+r+m2+1) {\n          localjump_error(mrb, LOCALJUMP_ERROR_YIELD);\n          goto L_RAISE;\n        }\n        stack = e->stack + 1;\n      }\n      if (mrb_nil_p(stack[m1+r+m2])) {\n        localjump_error(mrb, LOCALJUMP_ERROR_YIELD);\n        goto L_RAISE;\n      }\n      regs[a] = stack[m1+r+m2];\n      NEXT;\n    }\n\n#define TYPES2(a,b) ((((uint16_t)(a))<<8)|(((uint16_t)(b))&0xff))\n#define OP_MATH_BODY(op,v1,v2) do {\\\n  v1(regs[a]) = v1(regs[a]) op v2(regs[a+1]);\\\n} while(0)\n\n    CASE(OP_ADD) {\n      /* A B C  R(A) := R(A)+R(A+1) (Syms[B]=:+,C=1)*/\n      int a = GETARG_A(i);\n\n      /* need to check if op is overridden */\n      switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):\n        {\n          mrb_int x, y, z;\n          mrb_value *regs_a = regs + a;\n\n          x = mrb_fixnum(regs_a[0]);\n          y = mrb_fixnum(regs_a[1]);\n          if (mrb_int_add_overflow(x, y, &z)) {\n#ifndef MRB_WITHOUT_FLOAT\n            SET_FLOAT_VALUE(mrb, regs_a[0], (mrb_float)x + (mrb_float)y);\n            break;\n#endif\n          }\n          SET_INT_VALUE(regs[a], z);\n        }\n        break;\n#ifndef MRB_WITHOUT_FLOAT\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FLOAT):\n        {\n          mrb_int x = mrb_fixnum(regs[a]);\n          mrb_float y = mrb_float(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], (mrb_float)x + y);\n        }\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FIXNUM):\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          mrb_int y = mrb_fixnum(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], x + y);\n        }\n#else\n        OP_MATH_BODY(+,mrb_float,mrb_fixnum);\n#endif\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          mrb_float y = mrb_float(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], x + y);\n        }\n#else\n        OP_MATH_BODY(+,mrb_float,mrb_float);\n#endif\n        break;\n#endif\n      case TYPES2(MRB_TT_STRING,MRB_TT_STRING):\n        regs[a] = mrb_str_plus(mrb, regs[a], regs[a+1]);\n        break;\n      default:\n        goto L_SEND;\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_SUB) {\n      /* A B C  R(A) := R(A)-R(A+1) (Syms[B]=:-,C=1)*/\n      int a = GETARG_A(i);\n\n      /* need to check if op is overridden */\n      switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):\n        {\n          mrb_int x, y, z;\n\n          x = mrb_fixnum(regs[a]);\n          y = mrb_fixnum(regs[a+1]);\n          if (mrb_int_sub_overflow(x, y, &z)) {\n#ifndef MRB_WITHOUT_FLOAT\n            SET_FLOAT_VALUE(mrb, regs[a], (mrb_float)x - (mrb_float)y);\n            break;\n#endif\n          }\n          SET_INT_VALUE(regs[a], z);\n        }\n        break;\n#ifndef MRB_WITHOUT_FLOAT\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FLOAT):\n        {\n          mrb_int x = mrb_fixnum(regs[a]);\n          mrb_float y = mrb_float(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], (mrb_float)x - y);\n        }\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FIXNUM):\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          mrb_int y = mrb_fixnum(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], x - y);\n        }\n#else\n        OP_MATH_BODY(-,mrb_float,mrb_fixnum);\n#endif\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          mrb_float y = mrb_float(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], x - y);\n        }\n#else\n        OP_MATH_BODY(-,mrb_float,mrb_float);\n#endif\n        break;\n#endif\n      default:\n        goto L_SEND;\n      }\n      NEXT;\n    }\n\n    CASE(OP_MUL) {\n      /* A B C  R(A) := R(A)*R(A+1) (Syms[B]=:*,C=1)*/\n      int a = GETARG_A(i);\n\n      /* need to check if op is overridden */\n      switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):\n        {\n          mrb_int x, y, z;\n\n          x = mrb_fixnum(regs[a]);\n          y = mrb_fixnum(regs[a+1]);\n          if (mrb_int_mul_overflow(x, y, &z)) {\n#ifndef MRB_WITHOUT_FLOAT\n            SET_FLOAT_VALUE(mrb, regs[a], (mrb_float)x * (mrb_float)y);\n            break;\n#endif\n          }\n          SET_INT_VALUE(regs[a], z);\n        }\n        break;\n#ifndef MRB_WITHOUT_FLOAT\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FLOAT):\n        {\n          mrb_int x = mrb_fixnum(regs[a]);\n          mrb_float y = mrb_float(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], (mrb_float)x * y);\n        }\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FIXNUM):\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          mrb_int y = mrb_fixnum(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], x * y);\n        }\n#else\n        OP_MATH_BODY(*,mrb_float,mrb_fixnum);\n#endif\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          mrb_float y = mrb_float(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], x * y);\n        }\n#else\n        OP_MATH_BODY(*,mrb_float,mrb_float);\n#endif\n        break;\n#endif\n      default:\n        goto L_SEND;\n      }\n      NEXT;\n    }\n\n    CASE(OP_DIV) {\n      /* A B C  R(A) := R(A)/R(A+1) (Syms[B]=:/,C=1)*/\n      int a = GETARG_A(i);\n#ifndef MRB_WITHOUT_FLOAT\n      double x, y, f;\n#endif\n\n      /* need to check if op is overridden */\n      switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):\n#ifdef MRB_WITHOUT_FLOAT\n        {\n          mrb_int x = mrb_fixnum(regs[a]);\n          mrb_int y = mrb_fixnum(regs[a+1]);\n          SET_INT_VALUE(regs[a], y ? x / y : 0);\n        }\n        break;\n#else\n        x = (mrb_float)mrb_fixnum(regs[a]);\n        y = (mrb_float)mrb_fixnum(regs[a+1]);\n        break;\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FLOAT):\n        x = (mrb_float)mrb_fixnum(regs[a]);\n        y = mrb_float(regs[a+1]);\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FIXNUM):\n        x = mrb_float(regs[a]);\n        y = (mrb_float)mrb_fixnum(regs[a+1]);\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\n        x = mrb_float(regs[a]);\n        y = mrb_float(regs[a+1]);\n        break;\n#endif\n      default:\n        goto L_SEND;\n      }\n\n#ifndef MRB_WITHOUT_FLOAT\n      if (y == 0) {\n        if (x > 0) f = INFINITY;\n        else if (x < 0) f = -INFINITY;\n        else /* if (x == 0) */ f = NAN;\n      }\n      else {\n        f = x / y;\n      }\n      SET_FLOAT_VALUE(mrb, regs[a], f);\n#endif\n      NEXT;\n    }\n\n    CASE(OP_ADDI) {\n      /* A B C  R(A) := R(A)+C (Syms[B]=:+)*/\n      int a = GETARG_A(i);\n\n      /* need to check if + is overridden */\n      switch (mrb_type(regs[a])) {\n      case MRB_TT_FIXNUM:\n        {\n          mrb_int x = mrb_fixnum(regs[a]);\n          mrb_int y = GETARG_C(i);\n          mrb_int z;\n\n          if (mrb_int_add_overflow(x, y, &z)) {\n#ifndef MRB_WITHOUT_FLOAT\n            SET_FLOAT_VALUE(mrb, regs[a], (mrb_float)x + (mrb_float)y);\n            break;\n#endif\n          }\n          SET_INT_VALUE(regs[a], z);\n        }\n        break;\n#ifndef MRB_WITHOUT_FLOAT\n      case MRB_TT_FLOAT:\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          SET_FLOAT_VALUE(mrb, regs[a], x + GETARG_C(i));\n        }\n#else\n        mrb_float(regs[a]) += GETARG_C(i);\n#endif\n        break;\n#endif\n      default:\n        SET_INT_VALUE(regs[a+1], GETARG_C(i));\n        i = MKOP_ABC(OP_SEND, a, GETARG_B(i), 1);\n        goto L_SEND;\n      }\n      NEXT;\n    }\n\n    CASE(OP_SUBI) {\n      /* A B C  R(A) := R(A)-C (Syms[B]=:-)*/\n      int a = GETARG_A(i);\n      mrb_value *regs_a = regs + a;\n\n      /* need to check if + is overridden */\n      switch (mrb_type(regs_a[0])) {\n      case MRB_TT_FIXNUM:\n        {\n          mrb_int x = mrb_fixnum(regs_a[0]);\n          mrb_int y = GETARG_C(i);\n          mrb_int z;\n\n          if (mrb_int_sub_overflow(x, y, &z)) {\n#ifndef MRB_WITHOUT_FLOAT\n            SET_FLOAT_VALUE(mrb, regs_a[0], (mrb_float)x - (mrb_float)y);\n            break;\n#endif\n          }\n          SET_INT_VALUE(regs_a[0], z);\n        }\n        break;\n#ifndef MRB_WITHOUT_FLOAT\n      case MRB_TT_FLOAT:\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          SET_FLOAT_VALUE(mrb, regs[a], x - GETARG_C(i));\n        }\n#else\n        mrb_float(regs_a[0]) -= GETARG_C(i);\n#endif\n        break;\n#endif\n      default:\n        SET_INT_VALUE(regs_a[1], GETARG_C(i));\n        i = MKOP_ABC(OP_SEND, a, GETARG_B(i), 1);\n        goto L_SEND;\n      }\n      NEXT;\n    }\n\n#define OP_CMP_BODY(op,v1,v2) (v1(regs[a]) op v2(regs[a+1]))\n\n#ifdef MRB_WITHOUT_FLOAT\n#define OP_CMP(op) do {\\\n  int result;\\\n  /* need to check if - is overridden */\\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\\\n  case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_fixnum);\\\n    break;\\\n  default:\\\n    goto L_SEND;\\\n  }\\\n  if (result) {\\\n    SET_TRUE_VALUE(regs[a]);\\\n  }\\\n  else {\\\n    SET_FALSE_VALUE(regs[a]);\\\n  }\\\n} while(0)\n#else\n#define OP_CMP(op) do {\\\n  int result;\\\n  /* need to check if - is overridden */\\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\\\n  case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_fixnum);\\\n    break;\\\n  case TYPES2(MRB_TT_FIXNUM,MRB_TT_FLOAT):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_float);\\\n    break;\\\n  case TYPES2(MRB_TT_FLOAT,MRB_TT_FIXNUM):\\\n    result = OP_CMP_BODY(op,mrb_float,mrb_fixnum);\\\n    break;\\\n  case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\\\n    result = OP_CMP_BODY(op,mrb_float,mrb_float);\\\n    break;\\\n  default:\\\n    goto L_SEND;\\\n  }\\\n  if (result) {\\\n    SET_TRUE_VALUE(regs[a]);\\\n  }\\\n  else {\\\n    SET_FALSE_VALUE(regs[a]);\\\n  }\\\n} while(0)\n#endif\n\n    CASE(OP_EQ) {\n      /* A B C  R(A) := R(A)==R(A+1) (Syms[B]=:==,C=1)*/\n      int a = GETARG_A(i);\n      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {\n        SET_TRUE_VALUE(regs[a]);\n      }\n      else {\n        OP_CMP(==);\n      }\n      NEXT;\n    }\n\n    CASE(OP_LT) {\n      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/\n      int a = GETARG_A(i);\n      OP_CMP(<);\n      NEXT;\n    }\n\n    CASE(OP_LE) {\n      /* A B C  R(A) := R(A)<=R(A+1) (Syms[B]=:<=,C=1)*/\n      int a = GETARG_A(i);\n      OP_CMP(<=);\n      NEXT;\n    }\n\n    CASE(OP_GT) {\n      /* A B C  R(A) := R(A)>R(A+1) (Syms[B]=:>,C=1)*/\n      int a = GETARG_A(i);\n      OP_CMP(>);\n      NEXT;\n    }\n\n    CASE(OP_GE) {\n      /* A B C  R(A) := R(A)>=R(A+1) (Syms[B]=:>=,C=1)*/\n      int a = GETARG_A(i);\n      OP_CMP(>=);\n      NEXT;\n    }\n\n    CASE(OP_ARRAY) {\n      /* A B C          R(A) := ary_new(R(B),R(B+1)..R(B+C)) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n      mrb_value v = mrb_ary_new_from_values(mrb, c, &regs[b]);\n      regs[a] = v;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ARYCAT) {\n      /* A B            mrb_ary_concat(R(A),R(B)) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      mrb_value splat = mrb_ary_splat(mrb, regs[b]);\n      mrb_ary_concat(mrb, regs[a], splat);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ARYPUSH) {\n      /* A B            R(A).push(R(B)) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      mrb_ary_push(mrb, regs[a], regs[b]);\n      NEXT;\n    }\n\n    CASE(OP_AREF) {\n      /* A B C          R(A) := R(B)[C] */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n      mrb_value v = regs[b];\n\n      if (!mrb_array_p(v)) {\n        if (c == 0) {\n          regs[a] = v;\n        }\n        else {\n          SET_NIL_VALUE(regs[a]);\n        }\n      }\n      else {\n        v = mrb_ary_ref(mrb, v, c);\n        regs[a] = v;\n      }\n      NEXT;\n    }\n\n    CASE(OP_ASET) {\n      /* A B C          R(B)[C] := R(A) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n      mrb_ary_set(mrb, regs[b], c, regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_APOST) {\n      /* A B C  *R(A),R(A+1)..R(A+C) := R(A) */\n      int a = GETARG_A(i);\n      mrb_value v = regs[a];\n      int pre  = GETARG_B(i);\n      int post = GETARG_C(i);\n      struct RArray *ary;\n      int len, idx;\n\n      if (!mrb_array_p(v)) {\n        v = mrb_ary_new_from_values(mrb, 1, &regs[a]);\n      }\n      ary = mrb_ary_ptr(v);\n      len = (int)ARY_LEN(ary);\n      if (len > pre + post) {\n        v = mrb_ary_new_from_values(mrb, len - pre - post, ARY_PTR(ary)+pre);\n        regs[a++] = v;\n        while (post--) {\n          regs[a++] = ARY_PTR(ary)[len-post-1];\n        }\n      }\n      else {\n        v = mrb_ary_new_capa(mrb, 0);\n        regs[a++] = v;\n        for (idx=0; idx+pre<len; idx++) {\n          regs[a+idx] = ARY_PTR(ary)[pre+idx];\n        }\n        while (idx < post) {\n          SET_NIL_VALUE(regs[a+idx]);\n          idx++;\n        }\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_STRING) {\n      /* A Bx           R(A) := str_new(Lit(Bx)) */\n      mrb_int a = GETARG_A(i);\n      mrb_int bx = GETARG_Bx(i);\n      mrb_value str = mrb_str_dup(mrb, pool[bx]);\n\n      regs[a] = str;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_STRCAT) {\n      /* A B    R(A).concat(R(B)) */\n      mrb_int a = GETARG_A(i);\n      mrb_int b = GETARG_B(i);\n\n      mrb_str_concat(mrb, regs[a], regs[b]);\n      NEXT;\n    }\n\n    CASE(OP_HASH) {\n      /* A B C   R(A) := hash_new(R(B),R(B+1)..R(B+C)) */\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n      int lim = b+c*2;\n      mrb_value hash = mrb_hash_new_capa(mrb, c);\n\n      while (b < lim) {\n        mrb_hash_set(mrb, hash, regs[b], regs[b+1]);\n        b+=2;\n      }\n      regs[GETARG_A(i)] = hash;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_LAMBDA) {\n      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */\n      struct RProc *p;\n      int a = GETARG_A(i);\n      int b = GETARG_b(i);\n      int c = GETARG_c(i);\n      mrb_irep *nirep = irep->reps[b];\n\n      if (c & OP_L_CAPTURE) {\n        p = mrb_closure_new(mrb, nirep);\n      }\n      else {\n        p = mrb_proc_new(mrb, nirep);\n        p->flags |= MRB_PROC_SCOPE;\n      }\n      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;\n      regs[a] = mrb_obj_value(p);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_OCLASS) {\n      /* A      R(A) := ::Object */\n      regs[GETARG_A(i)] = mrb_obj_value(mrb->object_class);\n      NEXT;\n    }\n\n    CASE(OP_CLASS) {\n      /* A B    R(A) := newclass(R(A),Syms(B),R(A+1)) */\n      struct RClass *c = 0, *baseclass;\n      int a = GETARG_A(i);\n      mrb_value base, super;\n      mrb_sym id = syms[GETARG_B(i)];\n\n      base = regs[a];\n      super = regs[a+1];\n      if (mrb_nil_p(base)) {\n        baseclass = MRB_PROC_TARGET_CLASS(mrb->c->ci->proc);\n        base = mrb_obj_value(baseclass);\n      }\n      c = mrb_vm_define_class(mrb, base, super, id);\n      regs[a] = mrb_obj_value(c);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_MODULE) {\n      /* A B            R(A) := newmodule(R(A),Syms(B)) */\n      struct RClass *c = 0, *baseclass;\n      int a = GETARG_A(i);\n      mrb_value base;\n      mrb_sym id = syms[GETARG_B(i)];\n\n      base = regs[a];\n      if (mrb_nil_p(base)) {\n        baseclass = MRB_PROC_TARGET_CLASS(mrb->c->ci->proc);\n        base = mrb_obj_value(baseclass);\n      }\n      c = mrb_vm_define_module(mrb, base, id);\n      regs[a] = mrb_obj_value(c);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_EXEC) {\n      /* A Bx   R(A) := blockexec(R(A),SEQ[Bx]) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_callinfo *ci;\n      mrb_value recv = regs[a];\n      struct RProc *p;\n      mrb_irep *nirep = irep->reps[bx];\n\n      /* prepare closure */\n      p = mrb_proc_new(mrb, nirep);\n      p->c = NULL;\n      mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)proc);\n      MRB_PROC_SET_TARGET_CLASS(p, mrb_class_ptr(recv));\n      p->flags |= MRB_PROC_SCOPE;\n\n      /* prepare call stack */\n      ci = cipush(mrb);\n      ci->pc = pc + 1;\n      ci->acc = a;\n      ci->mid = 0;\n      ci->stackent = mrb->c->stack;\n      ci->argc = 0;\n      ci->target_class = mrb_class_ptr(recv);\n\n      /* prepare stack */\n      mrb->c->stack += a;\n\n      /* setup block to call */\n      ci->proc = p;\n\n      irep = p->body.irep;\n      pool = irep->pool;\n      syms = irep->syms;\n      ci->nregs = irep->nregs;\n      stack_extend(mrb, ci->nregs);\n      stack_clear(regs+1, ci->nregs-1);\n      pc = irep->iseq;\n      JUMP;\n    }\n\n    CASE(OP_METHOD) {\n      /* A B            R(A).newmethod(Syms(B),R(A+1)) */\n      int a = GETARG_A(i);\n      struct RClass *c = mrb_class_ptr(regs[a]);\n      struct RProc *p = mrb_proc_ptr(regs[a+1]);\n      mrb_method_t m;\n\n      MRB_METHOD_FROM_PROC(m, p);\n      mrb_define_method_raw(mrb, c, syms[GETARG_B(i)], m);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_SCLASS) {\n      /* A B    R(A) := R(B).singleton_class */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n\n      regs[a] = mrb_singleton_class(mrb, regs[b]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_TCLASS) {\n      /* A      R(A) := target_class */\n      if (!mrb->c->ci->target_class) {\n        mrb_value exc = mrb_exc_new_str_lit(mrb, E_TYPE_ERROR, \"no target class or module\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      regs[GETARG_A(i)] = mrb_obj_value(mrb->c->ci->target_class);\n      NEXT;\n    }\n\n    CASE(OP_RANGE) {\n      /* A B C  R(A) := range_new(R(B),R(B+1),C) */\n      int b = GETARG_B(i);\n      mrb_value val = mrb_range_new(mrb, regs[b], regs[b+1], GETARG_C(i));\n      regs[GETARG_A(i)] = val;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_DEBUG) {\n      /* A B C    debug print R(A),R(B),R(C) */\n#ifdef MRB_ENABLE_DEBUG_HOOK\n      mrb->debug_op_hook(mrb, irep, pc, regs);\n#else\n#ifndef MRB_DISABLE_STDIO\n      printf(\"OP_DEBUG %d %d %d\\n\", GETARG_A(i), GETARG_B(i), GETARG_C(i));\n#else\n      abort();\n#endif\n#endif\n      NEXT;\n    }\n\n    CASE(OP_STOP) {\n      /*        stop VM */\n    L_STOP:\n      while (mrb->c->eidx > 0) {\n        ecall(mrb);\n      }\n      ERR_PC_CLR(mrb);\n      mrb->jmp = prev_jmp;\n      if (mrb->exc) {\n        return mrb_obj_value(mrb->exc);\n      }\n      return regs[irep->nlocals];\n    }\n\n    CASE(OP_ERR) {\n      /* Bx     raise RuntimeError with message Lit(Bx) */\n      mrb_value msg = mrb_str_dup(mrb, pool[GETARG_Bx(i)]);\n      mrb_value exc;\n\n      if (GETARG_A(i) == 0) {\n        exc = mrb_exc_new_str(mrb, E_RUNTIME_ERROR, msg);\n      }\n      else {\n        exc = mrb_exc_new_str(mrb, E_LOCALJUMP_ERROR, msg);\n      }\n      ERR_PC_SET(mrb, pc);\n      mrb_exc_set(mrb, exc);\n      goto L_RAISE;\n    }\n  }\n  END_DISPATCH;\n#undef regs\n\n  }\n  MRB_CATCH(&c_jmp) {\n    exc_catched = TRUE;\n    goto RETRY_TRY_BLOCK;\n  }\n  MRB_END_EXC(&c_jmp);\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149908,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "mrb_vm_exec(mrb_state *mrb, struct RProc *proc, mrb_code *pc)\n{\n  /* mrb_assert(mrb_proc_cfunc_p(proc)) */\n  mrb_irep *irep = proc->body.irep;\n  mrb_value *pool = irep->pool;\n  mrb_sym *syms = irep->syms;\n  mrb_code i;\n  int ai = mrb_gc_arena_save(mrb);\n  struct mrb_jmpbuf *prev_jmp = mrb->jmp;\n  struct mrb_jmpbuf c_jmp;\n\n#ifdef DIRECT_THREADED\n  static void *optable[] = {\n    &&L_OP_NOP, &&L_OP_MOVE,\n    &&L_OP_LOADL, &&L_OP_LOADI, &&L_OP_LOADSYM, &&L_OP_LOADNIL,\n    &&L_OP_LOADSELF, &&L_OP_LOADT, &&L_OP_LOADF,\n    &&L_OP_GETGLOBAL, &&L_OP_SETGLOBAL, &&L_OP_GETSPECIAL, &&L_OP_SETSPECIAL,\n    &&L_OP_GETIV, &&L_OP_SETIV, &&L_OP_GETCV, &&L_OP_SETCV,\n    &&L_OP_GETCONST, &&L_OP_SETCONST, &&L_OP_GETMCNST, &&L_OP_SETMCNST,\n    &&L_OP_GETUPVAR, &&L_OP_SETUPVAR,\n    &&L_OP_JMP, &&L_OP_JMPIF, &&L_OP_JMPNOT,\n    &&L_OP_ONERR, &&L_OP_RESCUE, &&L_OP_POPERR, &&L_OP_RAISE, &&L_OP_EPUSH, &&L_OP_EPOP,\n    &&L_OP_SEND, &&L_OP_SENDB, &&L_OP_FSEND,\n    &&L_OP_CALL, &&L_OP_SUPER, &&L_OP_ARGARY, &&L_OP_ENTER,\n    &&L_OP_KARG, &&L_OP_KDICT, &&L_OP_RETURN, &&L_OP_TAILCALL, &&L_OP_BLKPUSH,\n    &&L_OP_ADD, &&L_OP_ADDI, &&L_OP_SUB, &&L_OP_SUBI, &&L_OP_MUL, &&L_OP_DIV,\n    &&L_OP_EQ, &&L_OP_LT, &&L_OP_LE, &&L_OP_GT, &&L_OP_GE,\n    &&L_OP_ARRAY, &&L_OP_ARYCAT, &&L_OP_ARYPUSH, &&L_OP_AREF, &&L_OP_ASET, &&L_OP_APOST,\n    &&L_OP_STRING, &&L_OP_STRCAT, &&L_OP_HASH,\n    &&L_OP_LAMBDA, &&L_OP_RANGE, &&L_OP_OCLASS,\n    &&L_OP_CLASS, &&L_OP_MODULE, &&L_OP_EXEC,\n    &&L_OP_METHOD, &&L_OP_SCLASS, &&L_OP_TCLASS,\n    &&L_OP_DEBUG, &&L_OP_STOP, &&L_OP_ERR,\n  };\n#endif\n\n  mrb_bool exc_catched = FALSE;\nRETRY_TRY_BLOCK:\n\n  MRB_TRY(&c_jmp) {\n\n  if (exc_catched) {\n    exc_catched = FALSE;\n    if (mrb->exc && mrb->exc->tt == MRB_TT_BREAK)\n      goto L_BREAK;\n    goto L_RAISE;\n  }\n  mrb->jmp = &c_jmp;\n  mrb->c->ci->proc = proc;\n  mrb->c->ci->nregs = irep->nregs;\n\n#define regs (mrb->c->stack)\n  INIT_DISPATCH {\n    CASE(OP_NOP) {\n      /* do nothing */\n      NEXT;\n    }\n\n    CASE(OP_MOVE) {\n      /* A B    R(A) := R(B) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      regs[a] = regs[b];\n      NEXT;\n    }\n\n    CASE(OP_LOADL) {\n      /* A Bx   R(A) := Pool(Bx) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n#ifdef MRB_WORD_BOXING\n      mrb_value val = pool[bx];\n#ifndef MRB_WITHOUT_FLOAT\n      if (mrb_float_p(val)) {\n        val = mrb_float_value(mrb, mrb_float(val));\n      }\n#endif\n      regs[a] = val;\n#else\n      regs[a] = pool[bx];\n#endif\n      NEXT;\n    }\n\n    CASE(OP_LOADI) {\n      /* A sBx  R(A) := sBx */\n      int a = GETARG_A(i);\n      mrb_int bx = GETARG_sBx(i);\n      SET_INT_VALUE(regs[a], bx);\n      NEXT;\n    }\n\n    CASE(OP_LOADSYM) {\n      /* A Bx   R(A) := Syms(Bx) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      SET_SYM_VALUE(regs[a], syms[bx]);\n      NEXT;\n    }\n\n    CASE(OP_LOADSELF) {\n      /* A      R(A) := self */\n      int a = GETARG_A(i);\n      regs[a] = regs[0];\n      NEXT;\n    }\n\n    CASE(OP_LOADT) {\n      /* A      R(A) := true */\n      int a = GETARG_A(i);\n      SET_TRUE_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_LOADF) {\n      /* A      R(A) := false */\n      int a = GETARG_A(i);\n      SET_FALSE_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETGLOBAL) {\n      /* A Bx   R(A) := getglobal(Syms(Bx)) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_value val = mrb_gv_get(mrb, syms[bx]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETGLOBAL) {\n      /* A Bx   setglobal(Syms(Bx), R(A)) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_gv_set(mrb, syms[bx], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETSPECIAL) {\n      /* A Bx   R(A) := Special[Bx] */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_value val = mrb_vm_special_get(mrb, bx);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETSPECIAL) {\n      /* A Bx   Special[Bx] := R(A) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_vm_special_set(mrb, bx, regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETIV) {\n      /* A Bx   R(A) := ivget(Bx) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_value val = mrb_vm_iv_get(mrb, syms[bx]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETIV) {\n      /* A Bx   ivset(Syms(Bx),R(A)) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_vm_iv_set(mrb, syms[bx], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETCV) {\n      /* A Bx   R(A) := cvget(Syms(Bx)) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_value val;\n      ERR_PC_SET(mrb, pc);\n      val = mrb_vm_cv_get(mrb, syms[bx]);\n      ERR_PC_CLR(mrb);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETCV) {\n      /* A Bx   cvset(Syms(Bx),R(A)) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_vm_cv_set(mrb, syms[bx], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETCONST) {\n      /* A Bx    R(A) := constget(Syms(Bx)) */\n      mrb_value val;\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_sym sym = syms[bx];\n\n      ERR_PC_SET(mrb, pc);\n      val = mrb_vm_const_get(mrb, sym);\n      ERR_PC_CLR(mrb);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETCONST) {\n      /* A Bx   constset(Syms(Bx),R(A)) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_vm_const_set(mrb, syms[bx], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETMCNST) {\n      /* A Bx   R(A) := R(A)::Syms(Bx) */\n      mrb_value val;\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n\n      ERR_PC_SET(mrb, pc);\n      val = mrb_const_get(mrb, regs[a], syms[bx]);\n      ERR_PC_CLR(mrb);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETMCNST) {\n      /* A Bx    R(A+1)::Syms(Bx) := R(A) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_const_set(mrb, regs[a+1], syms[bx], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETUPVAR) {\n      /* A B C  R(A) := uvget(B,C) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n      mrb_value *regs_a = regs + a;\n      struct REnv *e = uvenv(mrb, c);\n\n      if (e && b < MRB_ENV_STACK_LEN(e)) {\n        *regs_a = e->stack[b];\n      }\n      else {\n        *regs_a = mrb_nil_value();\n      }\n      NEXT;\n    }\n\n    CASE(OP_SETUPVAR) {\n      /* A B C  uvset(B,C,R(A)) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n\n      struct REnv *e = uvenv(mrb, c);\n\n      if (e) {\n        mrb_value *regs_a = regs + a;\n\n        if (b < MRB_ENV_STACK_LEN(e)) {\n          e->stack[b] = *regs_a;\n          mrb_write_barrier(mrb, (struct RBasic*)e);\n        }\n      }\n      NEXT;\n    }\n\n    CASE(OP_JMP) {\n      /* sBx    pc+=sBx */\n      int sbx = GETARG_sBx(i);\n      pc += sbx;\n      JUMP;\n    }\n\n    CASE(OP_JMPIF) {\n      /* A sBx  if R(A) pc+=sBx */\n      int a = GETARG_A(i);\n      int sbx = GETARG_sBx(i);\n      if (mrb_test(regs[a])) {\n        pc += sbx;\n        JUMP;\n      }\n      NEXT;\n    }\n\n    CASE(OP_JMPNOT) {\n      /* A sBx  if !R(A) pc+=sBx */\n      int a = GETARG_A(i);\n      int sbx = GETARG_sBx(i);\n      if (!mrb_test(regs[a])) {\n        pc += sbx;\n        JUMP;\n      }\n      NEXT;\n    }\n\n    CASE(OP_ONERR) {\n      /* sBx    pc+=sBx on exception */\n      int sbx = GETARG_sBx(i);\n      if (mrb->c->rsize <= mrb->c->ci->ridx) {\n        if (mrb->c->rsize == 0) mrb->c->rsize = RESCUE_STACK_INIT_SIZE;\n        else mrb->c->rsize *= 2;\n        mrb->c->rescue = (mrb_code **)mrb_realloc(mrb, mrb->c->rescue, sizeof(mrb_code*) * mrb->c->rsize);\n      }\n      mrb->c->rescue[mrb->c->ci->ridx++] = pc + sbx;\n      NEXT;\n    }\n\n    CASE(OP_RESCUE) {\n      /* A B    R(A) := exc; clear(exc); R(B) := matched (bool) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n      mrb_value exc;\n\n      if (c == 0) {\n        exc = mrb_obj_value(mrb->exc);\n        mrb->exc = 0;\n      }\n      else {           /* continued; exc taken from R(A) */\n        exc = regs[a];\n      }\n      if (b != 0) {\n        mrb_value e = regs[b];\n        struct RClass *ec;\n\n        switch (mrb_type(e)) {\n        case MRB_TT_CLASS:\n        case MRB_TT_MODULE:\n          break;\n        default:\n          {\n            mrb_value exc;\n\n            exc = mrb_exc_new_str_lit(mrb, E_TYPE_ERROR,\n                  \"class or module required for rescue clause\");\n            mrb_exc_set(mrb, exc);\n            goto L_RAISE;\n          }\n        }\n        ec = mrb_class_ptr(e);\n        regs[b] = mrb_bool_value(mrb_obj_is_kind_of(mrb, exc, ec));\n      }\n      if (a != 0 && c == 0) {\n        regs[a] = exc;\n      }\n      NEXT;\n    }\n\n    CASE(OP_POPERR) {\n      /* A      A.times{rescue_pop()} */\n      int a = GETARG_A(i);\n\n      mrb->c->ci->ridx -= a;\n      NEXT;\n    }\n\n    CASE(OP_RAISE) {\n      /* A      raise(R(A)) */\n      int a = GETARG_A(i);\n\n      mrb_exc_set(mrb, regs[a]);\n      goto L_RAISE;\n    }\n\n    CASE(OP_EPUSH) {\n      /* Bx     ensure_push(SEQ[Bx]) */\n      int bx = GETARG_Bx(i);\n      struct RProc *p;\n\n      p = mrb_closure_new(mrb, irep->reps[bx]);\n      /* push ensure_stack */\n      if (mrb->c->esize <= mrb->c->eidx+1) {\n        if (mrb->c->esize == 0) mrb->c->esize = ENSURE_STACK_INIT_SIZE;\n        else mrb->c->esize *= 2;\n        mrb->c->ensure = (struct RProc **)mrb_realloc(mrb, mrb->c->ensure, sizeof(struct RProc*) * mrb->c->esize);\n      }\n      mrb->c->ensure[mrb->c->eidx++] = p;\n      mrb->c->ensure[mrb->c->eidx] = NULL;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_EPOP) {\n      /* A      A.times{ensure_pop().call} */\n      int a = GETARG_A(i);\n      mrb_callinfo *ci = mrb->c->ci;\n      int n, epos = ci->epos;\n      mrb_value self = regs[0];\n      struct RClass *target_class = ci->target_class;\n\n      if (mrb->c->eidx <= epos) {\n        NEXT;\n      }\n\n      if (a > mrb->c->eidx - epos)\n        a = mrb->c->eidx - epos;\n      pc = pc + 1;\n      for (n=0; n<a; n++) {\n        proc = mrb->c->ensure[epos+n];\n        mrb->c->ensure[epos+n] = NULL;\n        if (proc == NULL) continue;\n        irep = proc->body.irep;\n        ci = cipush(mrb);\n        ci->mid = ci[-1].mid;\n        ci->argc = 0;\n        ci->proc = proc;\n        ci->stackent = mrb->c->stack;\n        ci->nregs = irep->nregs;\n        ci->target_class = target_class;\n        ci->pc = pc;\n        ci->acc = ci[-1].nregs;\n        mrb->c->stack += ci->acc;\n        stack_extend(mrb, ci->nregs);\n        regs[0] = self;\n        pc = irep->iseq;\n      }\n      pool = irep->pool;\n      syms = irep->syms;\n      mrb->c->eidx = epos;\n      JUMP;\n    }\n\n    CASE(OP_LOADNIL) {\n      /* A     R(A) := nil */\n      int a = GETARG_A(i);\n\n      SET_NIL_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_SENDB) {\n      /* A B C  R(A) := call(R(A),Syms(B),R(A+1),...,R(A+C),&R(A+C+1))*/\n      /* fall through */\n    };\n\n  L_SEND:\n    CASE(OP_SEND) {\n      /* A B C  R(A) := call(R(A),Syms(B),R(A+1),...,R(A+C)) */\n      int a = GETARG_A(i);\n      int n = GETARG_C(i);\n      int argc = (n == CALL_MAXARGS) ? -1 : n;\n      int bidx = (argc < 0) ? a+2 : a+n+1;\n      mrb_method_t m;\n      struct RClass *c;\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_value recv, blk;\n      mrb_sym mid = syms[GETARG_B(i)];\n\n      mrb_assert(bidx < ci->nregs);\n\n      recv = regs[a];\n      if (GET_OPCODE(i) != OP_SENDB) {\n        SET_NIL_VALUE(regs[bidx]);\n        blk = regs[bidx];\n      }\n      else {\n        blk = regs[bidx];\n        if (!mrb_nil_p(blk) && mrb_type(blk) != MRB_TT_PROC) {\n          blk = mrb_convert_type(mrb, blk, MRB_TT_PROC, \"Proc\", \"to_proc\");\n          /* The stack might have been reallocated during mrb_convert_type(),\n             see #3622 */\n          regs[bidx] = blk;\n        }\n      }\n      c = mrb_class(mrb, recv);\n      m = mrb_method_search_vm(mrb, &c, mid);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        mrb_sym missing = mrb_intern_lit(mrb, \"method_missing\");\n        m = mrb_method_search_vm(mrb, &c, missing);\n        if (MRB_METHOD_UNDEF_P(m) || (missing == mrb->c->ci->mid && mrb_obj_eq(mrb, regs[0], recv))) {\n          mrb_value args = (argc < 0) ? regs[a+1] : mrb_ary_new_from_values(mrb, n, regs+a+1);\n          ERR_PC_SET(mrb, pc);\n          mrb_method_missing(mrb, mid, recv, args);\n        }\n        if (argc >= 0) {\n          if (a+2 >= irep->nregs) {\n            stack_extend(mrb, a+3);\n          }\n          regs[a+1] = mrb_ary_new_from_values(mrb, n, regs+a+1);\n          regs[a+2] = blk;\n          argc = -1;\n        }\n        mrb_ary_unshift(mrb, regs[a+1], mrb_symbol_value(mid));\n        mid = missing;\n      }\n\n      /* push callinfo */\n      ci = cipush(mrb);\n      ci->mid = mid;\n      ci->stackent = mrb->c->stack;\n      ci->target_class = c;\n      ci->argc = argc;\n\n      ci->pc = pc + 1;\n      ci->acc = a;\n\n      /* prepare stack */\n      mrb->c->stack += a;\n\n      if (MRB_METHOD_CFUNC_P(m)) {\n        ci->nregs = (argc < 0) ? 3 : n+2;\n        if (MRB_METHOD_PROC_P(m)) {\n          struct RProc *p = MRB_METHOD_PROC(m);\n\n          ci->proc = p;\n          recv = p->body.func(mrb, recv);\n        }\n        else {\n          recv = MRB_METHOD_FUNC(m)(mrb, recv);\n        }\n        mrb_gc_arena_restore(mrb, ai);\n        mrb_gc_arena_shrink(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        ci = mrb->c->ci;\n        if (GET_OPCODE(i) == OP_SENDB) {\n          if (mrb_type(blk) == MRB_TT_PROC) {\n            struct RProc *p = mrb_proc_ptr(blk);\n            if (p && !MRB_PROC_STRICT_P(p) && MRB_PROC_ENV(p) == ci[-1].env) {\n              p->flags |= MRB_PROC_ORPHAN;\n            }\n          }\n        }\n        if (!ci->target_class) { /* return from context modifying method (resume/yield) */\n          if (ci->acc == CI_ACC_RESUMED) {\n            mrb->jmp = prev_jmp;\n            return recv;\n          }\n          else {\n            mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));\n            proc = ci[-1].proc;\n            irep = proc->body.irep;\n            pool = irep->pool;\n            syms = irep->syms;\n          }\n        }\n        mrb->c->stack[0] = recv;\n        /* pop stackpos */\n        mrb->c->stack = ci->stackent;\n        pc = ci->pc;\n        cipop(mrb);\n        JUMP;\n      }\n      else {\n        /* setup environment for calling method */\n        proc = ci->proc = MRB_METHOD_PROC(m);\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        ci->nregs = irep->nregs;\n        stack_extend(mrb, (argc < 0 && ci->nregs < 3) ? 3 : ci->nregs);\n        pc = irep->iseq;\n        JUMP;\n      }\n    }\n\n    CASE(OP_FSEND) {\n      /* A B C  R(A) := fcall(R(A),Syms(B),R(A+1),... ,R(A+C-1)) */\n      /* not implemented yet */\n      NEXT;\n    }\n\n    CASE(OP_CALL) {\n      /* A      R(A) := self.call(frame.argc, frame.argv) */\n      mrb_callinfo *ci;\n      mrb_value recv = mrb->c->stack[0];\n      struct RProc *m = mrb_proc_ptr(recv);\n\n      /* replace callinfo */\n      ci = mrb->c->ci;\n      ci->target_class = MRB_PROC_TARGET_CLASS(m);\n      ci->proc = m;\n      if (MRB_PROC_ENV_P(m)) {\n        mrb_sym mid;\n        struct REnv *e = MRB_PROC_ENV(m);\n\n        mid = e->mid;\n        if (mid) ci->mid = mid;\n        if (!e->stack) {\n          e->stack = mrb->c->stack;\n        }\n      }\n\n      /* prepare stack */\n      if (MRB_PROC_CFUNC_P(m)) {\n        recv = MRB_PROC_CFUNC(m)(mrb, recv);\n        mrb_gc_arena_restore(mrb, ai);\n        mrb_gc_arena_shrink(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        /* pop stackpos */\n        ci = mrb->c->ci;\n        mrb->c->stack = ci->stackent;\n        regs[ci->acc] = recv;\n        pc = ci->pc;\n        cipop(mrb);\n        irep = mrb->c->ci->proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        JUMP;\n      }\n      else {\n        /* setup environment for calling method */\n        proc = m;\n        irep = m->body.irep;\n        if (!irep) {\n          mrb->c->stack[0] = mrb_nil_value();\n          goto L_RETURN;\n        }\n        pool = irep->pool;\n        syms = irep->syms;\n        ci->nregs = irep->nregs;\n        stack_extend(mrb, ci->nregs);\n        if (ci->argc < 0) {\n          if (irep->nregs > 3) {\n            stack_clear(regs+3, irep->nregs-3);\n          }\n        }\n        else if (ci->argc+2 < irep->nregs) {\n          stack_clear(regs+ci->argc+2, irep->nregs-ci->argc-2);\n        }\n        if (MRB_PROC_ENV_P(m)) {\n          regs[0] = MRB_PROC_ENV(m)->stack[0];\n        }\n        pc = irep->iseq;\n        JUMP;\n      }\n    }\n\n    CASE(OP_SUPER) {\n      /* A C  R(A) := super(R(A+1),... ,R(A+C+1)) */\n      int a = GETARG_A(i);\n      int n = GETARG_C(i);\n      int argc = (n == CALL_MAXARGS) ? -1 : n;\n      int bidx = (argc < 0) ? a+2 : a+n+1;\n      mrb_method_t m;\n      struct RClass *c;\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_value recv, blk;\n      mrb_sym mid = ci->mid;\n      struct RClass* target_class = MRB_PROC_TARGET_CLASS(ci->proc);\n\n      mrb_assert(bidx < ci->nregs);\n\n      if (mid == 0 || !target_class) {\n        mrb_value exc = mrb_exc_new_str_lit(mrb, E_NOMETHOD_ERROR, \"super called outside of method\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      if (target_class->tt == MRB_TT_MODULE) {\n        target_class = ci->target_class;\n        if (target_class->tt != MRB_TT_ICLASS) {\n          mrb_value exc = mrb_exc_new_str_lit(mrb, E_RUNTIME_ERROR, \"superclass info lost [mruby limitations]\");\n          mrb_exc_set(mrb, exc);\n          goto L_RAISE;\n        }\n      }\n      recv = regs[0];\n      if (!mrb_obj_is_kind_of(mrb, recv, target_class)) {\n        mrb_value exc = mrb_exc_new_str_lit(mrb, E_TYPE_ERROR,\n                                            \"self has wrong type to call super in this context\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      blk = regs[bidx];\n      if (!mrb_nil_p(blk) && mrb_type(blk) != MRB_TT_PROC) {\n        blk = mrb_convert_type(mrb, blk, MRB_TT_PROC, \"Proc\", \"to_proc\");\n        /* The stack or ci stack might have been reallocated during\n           mrb_convert_type(), see #3622 and #3784 */\n        regs[bidx] = blk;\n        ci = mrb->c->ci;\n      }\n      c = target_class->super;\n      m = mrb_method_search_vm(mrb, &c, mid);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        mrb_sym missing = mrb_intern_lit(mrb, \"method_missing\");\n\n        if (mid != missing) {\n          c = mrb_class(mrb, recv);\n        }\n        m = mrb_method_search_vm(mrb, &c, missing);\n        if (MRB_METHOD_UNDEF_P(m)) {\n          mrb_value args = (argc < 0) ? regs[a+1] : mrb_ary_new_from_values(mrb, n, regs+a+1);\n          ERR_PC_SET(mrb, pc);\n          mrb_method_missing(mrb, mid, recv, args);\n        }\n        mid = missing;\n        if (argc >= 0) {\n          if (a+2 >= ci->nregs) {\n            stack_extend(mrb, a+3);\n          }\n          regs[a+1] = mrb_ary_new_from_values(mrb, n, regs+a+1);\n          regs[a+2] = blk;\n          argc = -1;\n        }\n        mrb_ary_unshift(mrb, regs[a+1], mrb_symbol_value(ci->mid));\n      }\n\n      /* push callinfo */\n      ci = cipush(mrb);\n      ci->mid = mid;\n      ci->stackent = mrb->c->stack;\n      ci->target_class = c;\n      ci->pc = pc + 1;\n      ci->argc = argc;\n\n      /* prepare stack */\n      mrb->c->stack += a;\n      mrb->c->stack[0] = recv;\n\n      if (MRB_METHOD_CFUNC_P(m)) {\n        mrb_value v;\n        ci->nregs = (argc < 0) ? 3 : n+2;\n        if (MRB_METHOD_PROC_P(m)) {\n          ci->proc = MRB_METHOD_PROC(m);\n        }\n        v = MRB_METHOD_CFUNC(m)(mrb, recv);\n        mrb_gc_arena_restore(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        ci = mrb->c->ci;\n        if (!ci->target_class) { /* return from context modifying method (resume/yield) */\n          if (ci->acc == CI_ACC_RESUMED) {\n            mrb->jmp = prev_jmp;\n            return v;\n          }\n          else {\n            mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));\n            proc = ci[-1].proc;\n            irep = proc->body.irep;\n            pool = irep->pool;\n            syms = irep->syms;\n          }\n        }\n        mrb->c->stack[0] = v;\n        /* pop stackpos */\n        mrb->c->stack = ci->stackent;\n        pc = ci->pc;\n        cipop(mrb);\n        JUMP;\n      }\n      else {\n        /* fill callinfo */\n        ci->acc = a;\n\n        /* setup environment for calling method */\n        proc = ci->proc = MRB_METHOD_PROC(m);\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        ci->nregs = irep->nregs;\n        stack_extend(mrb, (argc < 0 && ci->nregs < 3) ? 3 : ci->nregs);\n        pc = irep->iseq;\n        JUMP;\n      }\n    }\n\n    CASE(OP_ARGARY) {\n      /* A Bx   R(A) := argument array (16=6:1:5:4) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      int m1 = (bx>>10)&0x3f;\n      int r  = (bx>>9)&0x1;\n      int m2 = (bx>>4)&0x1f;\n      int lv = (bx>>0)&0xf;\n      mrb_value *stack;\n\n      if (mrb->c->ci->mid == 0 || mrb->c->ci->target_class == NULL) {\n        mrb_value exc;\n\n      L_NOSUPER:\n        exc = mrb_exc_new_str_lit(mrb, E_NOMETHOD_ERROR, \"super called outside of method\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      if (lv == 0) stack = regs + 1;\n      else {\n        struct REnv *e = uvenv(mrb, lv-1);\n        if (!e) goto L_NOSUPER;\n        if (MRB_ENV_STACK_LEN(e) <= m1+r+m2+1)\n          goto L_NOSUPER;\n        stack = e->stack + 1;\n      }\n      if (r == 0) {\n        regs[a] = mrb_ary_new_from_values(mrb, m1+m2, stack);\n      }\n      else {\n        mrb_value *pp = NULL;\n        struct RArray *rest;\n        int len = 0;\n\n        if (mrb_array_p(stack[m1])) {\n          struct RArray *ary = mrb_ary_ptr(stack[m1]);\n\n          pp = ARY_PTR(ary);\n          len = (int)ARY_LEN(ary);\n        }\n        regs[a] = mrb_ary_new_capa(mrb, m1+len+m2);\n        rest = mrb_ary_ptr(regs[a]);\n        if (m1 > 0) {\n          stack_copy(ARY_PTR(rest), stack, m1);\n        }\n        if (len > 0) {\n          stack_copy(ARY_PTR(rest)+m1, pp, len);\n        }\n        if (m2 > 0) {\n          stack_copy(ARY_PTR(rest)+m1+len, stack+m1+1, m2);\n        }\n        ARY_SET_LEN(rest, m1+len+m2);\n      }\n      regs[a+1] = stack[m1+r+m2];\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ENTER) {\n      /* Ax             arg setup according to flags (23=5:5:1:5:5:1:1) */\n      /* number of optional arguments times OP_JMP should follow */\n      mrb_aspec ax = GETARG_Ax(i);\n      int m1 = MRB_ASPEC_REQ(ax);\n      int o  = MRB_ASPEC_OPT(ax);\n      int r  = MRB_ASPEC_REST(ax);\n      int m2 = MRB_ASPEC_POST(ax);\n      /* unused\n      int k  = MRB_ASPEC_KEY(ax);\n      int kd = MRB_ASPEC_KDICT(ax);\n      int b  = MRB_ASPEC_BLOCK(ax);\n      */\n      int argc = mrb->c->ci->argc;\n      mrb_value *argv = regs+1;\n      mrb_value *argv0 = argv;\n      int len = m1 + o + r + m2;\n      mrb_value *blk = &argv[argc < 0 ? 1 : argc];\n\n      if (argc < 0) {\n        struct RArray *ary = mrb_ary_ptr(regs[1]);\n        argv = ARY_PTR(ary);\n        argc = (int)ARY_LEN(ary);\n        mrb_gc_protect(mrb, regs[1]);\n      }\n      if (mrb->c->ci->proc && MRB_PROC_STRICT_P(mrb->c->ci->proc)) {\n        if (argc >= 0) {\n          if (argc < m1 + m2 || (r == 0 && argc > len)) {\n            argnum_error(mrb, m1+m2);\n            goto L_RAISE;\n          }\n        }\n      }\n      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {\n        mrb_gc_protect(mrb, argv[0]);\n        argc = (int)RARRAY_LEN(argv[0]);\n        argv = RARRAY_PTR(argv[0]);\n      }\n      if (argc < len) {\n        int mlen = m2;\n        if (argc < m1+m2) {\n          if (m1 < argc)\n            mlen = argc - m1;\n          else\n            mlen = 0;\n        }\n        regs[len+1] = *blk; /* move block */\n        SET_NIL_VALUE(regs[argc+1]);\n        if (argv0 != argv) {\n          value_move(&regs[1], argv, argc-mlen); /* m1 + o */\n        }\n        if (argc < m1) {\n          stack_clear(&regs[argc+1], m1-argc);\n        }\n        if (mlen) {\n          value_move(&regs[len-m2+1], &argv[argc-mlen], mlen);\n        }\n        if (mlen < m2) {\n          stack_clear(&regs[len-m2+mlen+1], m2-mlen);\n        }\n        if (r) {\n          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);\n        }\n        if (o == 0 || argc < m1+m2) pc++;\n        else\n          pc += argc - m1 - m2 + 1;\n      }\n      else {\n        int rnum = 0;\n        if (argv0 != argv) {\n          regs[len+1] = *blk; /* move block */\n          value_move(&regs[1], argv, m1+o);\n        }\n        if (r) {\n          rnum = argc-m1-o-m2;\n          regs[m1+o+1] = mrb_ary_new_from_values(mrb, rnum, argv+m1+o);\n        }\n        if (m2) {\n          if (argc-m2 > m1) {\n            value_move(&regs[m1+o+r+1], &argv[m1+o+rnum], m2);\n          }\n        }\n        if (argv0 == argv) {\n          regs[len+1] = *blk; /* move block */\n        }\n        pc += o + 1;\n      }\n      mrb->c->ci->argc = len;\n      /* clear local (but non-argument) variables */\n      if (irep->nlocals-len-2 > 0) {\n        stack_clear(&regs[len+2], irep->nlocals-len-2);\n      }\n      JUMP;\n    }\n\n    CASE(OP_KARG) {\n      /* A B C          R(A) := kdict[Syms(B)]; if C kdict.rm(Syms(B)) */\n      /* if C == 2; raise unless kdict.empty? */\n      /* OP_JMP should follow to skip init code */\n      NEXT;\n    }\n\n    CASE(OP_KDICT) {\n      /* A C            R(A) := kdict */\n      NEXT;\n    }\n\n    L_RETURN:\n      i = MKOP_AB(OP_RETURN, GETARG_A(i), OP_R_NORMAL);\n      /* fall through */\n    CASE(OP_RETURN) {\n      /* A B     return R(A) (B=normal,in-block return/break) */\n      mrb_callinfo *ci;\n\n#define ecall_adjust() do {\\\n  ptrdiff_t cioff = ci - mrb->c->cibase;\\\n  ecall(mrb);\\\n  ci = mrb->c->cibase + cioff;\\\n} while (0)\n\n      ci = mrb->c->ci;\n      if (ci->mid) {\n        mrb_value blk;\n\n        if (ci->argc < 0) {\n          blk = regs[2];\n        }\n        else {\n          blk = regs[ci->argc+1];\n        }\n        if (mrb_type(blk) == MRB_TT_PROC) {\n          struct RProc *p = mrb_proc_ptr(blk);\n\n          if (!MRB_PROC_STRICT_P(p) &&\n              ci > mrb->c->cibase && MRB_PROC_ENV(p) == ci[-1].env) {\n            p->flags |= MRB_PROC_ORPHAN;\n          }\n        }\n      }\n\n      if (mrb->exc) {\n        mrb_callinfo *ci0;\n\n      L_RAISE:\n        ci0 = ci = mrb->c->ci;\n        if (ci == mrb->c->cibase) {\n          if (ci->ridx == 0) goto L_FTOP;\n          goto L_RESCUE;\n        }\n        while (ci[0].ridx == ci[-1].ridx) {\n          cipop(mrb);\n          mrb->c->stack = ci->stackent;\n          if (ci->acc == CI_ACC_SKIP && prev_jmp) {\n            mrb->jmp = prev_jmp;\n            MRB_THROW(prev_jmp);\n          }\n          ci = mrb->c->ci;\n          if (ci == mrb->c->cibase) {\n            if (ci->ridx == 0) {\n            L_FTOP:             /* fiber top */\n              if (mrb->c == mrb->root_c) {\n                mrb->c->stack = mrb->c->stbase;\n                goto L_STOP;\n              }\n              else {\n                struct mrb_context *c = mrb->c;\n\n                while (c->eidx > ci->epos) {\n                  ecall_adjust();\n                }\n                if (c->fib) {\n                  mrb_write_barrier(mrb, (struct RBasic*)c->fib);\n                }\n                mrb->c->status = MRB_FIBER_TERMINATED;\n                mrb->c = c->prev;\n                c->prev = NULL;\n                goto L_RAISE;\n              }\n            }\n            break;\n          }\n          /* call ensure only when we skip this callinfo */\n          if (ci[0].ridx == ci[-1].ridx) {\n            while (mrb->c->eidx > ci->epos) {\n              ecall_adjust();\n            }\n          }\n        }\n      L_RESCUE:\n        if (ci->ridx == 0) goto L_STOP;\n        proc = ci->proc;\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        if (ci < ci0) {\n          mrb->c->stack = ci[1].stackent;\n        }\n        stack_extend(mrb, irep->nregs);\n        pc = mrb->c->rescue[--ci->ridx];\n      }\n      else {\n        int acc;\n        mrb_value v;\n        struct RProc *dst;\n\n        ci = mrb->c->ci;\n        v = regs[GETARG_A(i)];\n        mrb_gc_protect(mrb, v);\n        switch (GETARG_B(i)) {\n        case OP_R_RETURN:\n          /* Fall through to OP_R_NORMAL otherwise */\n          if (ci->acc >=0 && MRB_PROC_ENV_P(proc) && !MRB_PROC_STRICT_P(proc)) {\n            mrb_callinfo *cibase = mrb->c->cibase;\n            dst = top_proc(mrb, proc);\n\n            if (MRB_PROC_ENV_P(dst)) {\n              struct REnv *e = MRB_PROC_ENV(dst);\n\n              if (!MRB_ENV_STACK_SHARED_P(e) || e->cxt != mrb->c) {\n                localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n                goto L_RAISE;\n              }\n            }\n            while (cibase <= ci && ci->proc != dst) {\n              if (ci->acc < 0) {\n                localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n                goto L_RAISE;\n              }\n              ci--;\n            }\n            if (ci <= cibase) {\n              localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n              goto L_RAISE;\n            }\n            break;\n          }\n        case OP_R_NORMAL:\n        NORMAL_RETURN:\n          if (ci == mrb->c->cibase) {\n            struct mrb_context *c;\n\n            if (!mrb->c->prev) { /* toplevel return */\n              localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n              goto L_RAISE;\n            }\n            if (mrb->c->prev->ci == mrb->c->prev->cibase) {\n              mrb_value exc = mrb_exc_new_str_lit(mrb, E_FIBER_ERROR, \"double resume\");\n              mrb_exc_set(mrb, exc);\n              goto L_RAISE;\n            }\n            while (mrb->c->eidx > 0) {\n              ecall(mrb);\n            }\n            /* automatic yield at the end */\n            c = mrb->c;\n            c->status = MRB_FIBER_TERMINATED;\n            mrb->c = c->prev;\n            c->prev = NULL;\n            mrb->c->status = MRB_FIBER_RUNNING;\n            ci = mrb->c->ci;\n          }\n          break;\n        case OP_R_BREAK:\n          if (MRB_PROC_STRICT_P(proc)) goto NORMAL_RETURN;\n          if (MRB_PROC_ORPHAN_P(proc)) { \n            mrb_value exc;\n\n          L_BREAK_ERROR:\n            exc = mrb_exc_new_str_lit(mrb, E_LOCALJUMP_ERROR,\n                                      \"break from proc-closure\");\n            mrb_exc_set(mrb, exc);\n            goto L_RAISE;\n          }\n          if (!MRB_PROC_ENV_P(proc) || !MRB_ENV_STACK_SHARED_P(MRB_PROC_ENV(proc))) {\n            goto L_BREAK_ERROR;\n          }\n          else {\n            struct REnv *e = MRB_PROC_ENV(proc);\n\n            if (e == mrb->c->cibase->env && proc != mrb->c->cibase->proc) {\n              goto L_BREAK_ERROR;\n            }\n            if (e->cxt != mrb->c) {\n              goto L_BREAK_ERROR;\n            }\n          }\n          while (mrb->c->eidx > mrb->c->ci->epos) {\n            ecall_adjust();\n          }\n          /* break from fiber block */\n          if (ci == mrb->c->cibase && ci->pc) {\n            struct mrb_context *c = mrb->c;\n\n            mrb->c = c->prev;\n            c->prev = NULL;\n            ci = mrb->c->ci;\n          }\n          if (ci->acc < 0) {\n            mrb_gc_arena_restore(mrb, ai);\n            mrb->c->vmexec = FALSE;\n            mrb->exc = (struct RObject*)break_new(mrb, proc, v);\n            mrb->jmp = prev_jmp;\n            MRB_THROW(prev_jmp);\n          }\n          if (FALSE) {\n          L_BREAK:\n            v = ((struct RBreak*)mrb->exc)->val;\n            proc = ((struct RBreak*)mrb->exc)->proc;\n            mrb->exc = NULL;\n            ci = mrb->c->ci;\n          }\n          mrb->c->stack = ci->stackent;\n          proc = proc->upper;\n          while (mrb->c->cibase < ci &&  ci[-1].proc != proc) {\n            if (ci[-1].acc == CI_ACC_SKIP) {\n              while (ci < mrb->c->ci) {\n                cipop(mrb);\n              }\n              goto L_BREAK_ERROR;\n            }\n            ci--;\n          }\n          if (ci == mrb->c->cibase) {\n            goto L_BREAK_ERROR;\n          }\n          break;\n        default:\n          /* cannot happen */\n          break;\n        }\n        while (ci < mrb->c->ci) {\n          cipop(mrb);\n        }\n        ci[0].ridx = ci[-1].ridx;\n        while (mrb->c->eidx > ci->epos) {\n          ecall_adjust();\n        }\n        if (mrb->c->vmexec && !ci->target_class) {\n          mrb_gc_arena_restore(mrb, ai);\n          mrb->c->vmexec = FALSE;\n          mrb->jmp = prev_jmp;\n          return v;\n        }\n        acc = ci->acc;\n        mrb->c->stack = ci->stackent;\n        cipop(mrb);\n        if (acc == CI_ACC_SKIP || acc == CI_ACC_DIRECT) {\n          mrb_gc_arena_restore(mrb, ai);\n          mrb->jmp = prev_jmp;\n          return v;\n        }\n        pc = ci->pc;\n        ci = mrb->c->ci;\n        DEBUG(fprintf(stderr, \"from :%s\\n\", mrb_sym2name(mrb, ci->mid)));\n        proc = mrb->c->ci->proc;\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n\n        regs[acc] = v;\n        mrb_gc_arena_restore(mrb, ai);\n      }\n      JUMP;\n    }\n\n    CASE(OP_TAILCALL) {\n      /* A B C  return call(R(A),Syms(B),R(A+1),... ,R(A+C+1)) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int n = GETARG_C(i);\n      mrb_method_t m;\n      struct RClass *c;\n      mrb_callinfo *ci;\n      mrb_value recv;\n      mrb_sym mid = syms[b];\n\n      recv = regs[a];\n      c = mrb_class(mrb, recv);\n      m = mrb_method_search_vm(mrb, &c, mid);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        mrb_value sym = mrb_symbol_value(mid);\n        mrb_sym missing = mrb_intern_lit(mrb, \"method_missing\");\n        m = mrb_method_search_vm(mrb, &c, missing);\n        if (MRB_METHOD_UNDEF_P(m)) {\n          mrb_value args;\n\n          if (n == CALL_MAXARGS) {\n            args = regs[a+1];\n          }\n          else {\n            args = mrb_ary_new_from_values(mrb, n, regs+a+1);\n          }\n          ERR_PC_SET(mrb, pc);\n          mrb_method_missing(mrb, mid, recv, args);\n        }\n        mid = missing;\n        if (n == CALL_MAXARGS) {\n          mrb_ary_unshift(mrb, regs[a+1], sym);\n        }\n        else {\n          value_move(regs+a+2, regs+a+1, ++n);\n          regs[a+1] = sym;\n        }\n      }\n\n      /* replace callinfo */\n      ci = mrb->c->ci;\n      ci->mid = mid;\n      ci->target_class = c;\n      if (n == CALL_MAXARGS) {\n        ci->argc = -1;\n      }\n      else {\n        ci->argc = n;\n      }\n\n      /* move stack */\n      value_move(mrb->c->stack, &regs[a], ci->argc+1);\n\n      if (MRB_METHOD_CFUNC_P(m)) {\n        mrb_value v = MRB_METHOD_CFUNC(m)(mrb, recv);\n        mrb->c->stack[0] = v;\n        mrb_gc_arena_restore(mrb, ai);\n        goto L_RETURN;\n      }\n      else {\n        /* setup environment for calling method */\n        struct RProc *p = MRB_METHOD_PROC(m);\n        irep = p->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        if (ci->argc < 0) {\n          stack_extend(mrb, (irep->nregs < 3) ? 3 : irep->nregs);\n        }\n        else {\n          stack_extend(mrb, irep->nregs);\n        }\n        pc = irep->iseq;\n      }\n      JUMP;\n    }\n\n    CASE(OP_BLKPUSH) {\n      /* A Bx   R(A) := block (16=6:1:5:4) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      int m1 = (bx>>10)&0x3f;\n      int r  = (bx>>9)&0x1;\n      int m2 = (bx>>4)&0x1f;\n      int lv = (bx>>0)&0xf;\n      mrb_value *stack;\n\n      if (lv == 0) stack = regs + 1;\n      else {\n        struct REnv *e = uvenv(mrb, lv-1);\n        if (!e || (!MRB_ENV_STACK_SHARED_P(e) && e->mid == 0) ||\n            MRB_ENV_STACK_LEN(e) <= m1+r+m2+1) {\n          localjump_error(mrb, LOCALJUMP_ERROR_YIELD);\n          goto L_RAISE;\n        }\n        stack = e->stack + 1;\n      }\n      if (mrb_nil_p(stack[m1+r+m2])) {\n        localjump_error(mrb, LOCALJUMP_ERROR_YIELD);\n        goto L_RAISE;\n      }\n      regs[a] = stack[m1+r+m2];\n      NEXT;\n    }\n\n#define TYPES2(a,b) ((((uint16_t)(a))<<8)|(((uint16_t)(b))&0xff))\n#define OP_MATH_BODY(op,v1,v2) do {\\\n  v1(regs[a]) = v1(regs[a]) op v2(regs[a+1]);\\\n} while(0)\n\n    CASE(OP_ADD) {\n      /* A B C  R(A) := R(A)+R(A+1) (Syms[B]=:+,C=1)*/\n      int a = GETARG_A(i);\n\n      /* need to check if op is overridden */\n      switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):\n        {\n          mrb_int x, y, z;\n          mrb_value *regs_a = regs + a;\n\n          x = mrb_fixnum(regs_a[0]);\n          y = mrb_fixnum(regs_a[1]);\n          if (mrb_int_add_overflow(x, y, &z)) {\n#ifndef MRB_WITHOUT_FLOAT\n            SET_FLOAT_VALUE(mrb, regs_a[0], (mrb_float)x + (mrb_float)y);\n            break;\n#endif\n          }\n          SET_INT_VALUE(regs[a], z);\n        }\n        break;\n#ifndef MRB_WITHOUT_FLOAT\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FLOAT):\n        {\n          mrb_int x = mrb_fixnum(regs[a]);\n          mrb_float y = mrb_float(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], (mrb_float)x + y);\n        }\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FIXNUM):\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          mrb_int y = mrb_fixnum(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], x + y);\n        }\n#else\n        OP_MATH_BODY(+,mrb_float,mrb_fixnum);\n#endif\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          mrb_float y = mrb_float(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], x + y);\n        }\n#else\n        OP_MATH_BODY(+,mrb_float,mrb_float);\n#endif\n        break;\n#endif\n      case TYPES2(MRB_TT_STRING,MRB_TT_STRING):\n        regs[a] = mrb_str_plus(mrb, regs[a], regs[a+1]);\n        break;\n      default:\n        goto L_SEND;\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_SUB) {\n      /* A B C  R(A) := R(A)-R(A+1) (Syms[B]=:-,C=1)*/\n      int a = GETARG_A(i);\n\n      /* need to check if op is overridden */\n      switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):\n        {\n          mrb_int x, y, z;\n\n          x = mrb_fixnum(regs[a]);\n          y = mrb_fixnum(regs[a+1]);\n          if (mrb_int_sub_overflow(x, y, &z)) {\n#ifndef MRB_WITHOUT_FLOAT\n            SET_FLOAT_VALUE(mrb, regs[a], (mrb_float)x - (mrb_float)y);\n            break;\n#endif\n          }\n          SET_INT_VALUE(regs[a], z);\n        }\n        break;\n#ifndef MRB_WITHOUT_FLOAT\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FLOAT):\n        {\n          mrb_int x = mrb_fixnum(regs[a]);\n          mrb_float y = mrb_float(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], (mrb_float)x - y);\n        }\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FIXNUM):\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          mrb_int y = mrb_fixnum(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], x - y);\n        }\n#else\n        OP_MATH_BODY(-,mrb_float,mrb_fixnum);\n#endif\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          mrb_float y = mrb_float(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], x - y);\n        }\n#else\n        OP_MATH_BODY(-,mrb_float,mrb_float);\n#endif\n        break;\n#endif\n      default:\n        goto L_SEND;\n      }\n      NEXT;\n    }\n\n    CASE(OP_MUL) {\n      /* A B C  R(A) := R(A)*R(A+1) (Syms[B]=:*,C=1)*/\n      int a = GETARG_A(i);\n\n      /* need to check if op is overridden */\n      switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):\n        {\n          mrb_int x, y, z;\n\n          x = mrb_fixnum(regs[a]);\n          y = mrb_fixnum(regs[a+1]);\n          if (mrb_int_mul_overflow(x, y, &z)) {\n#ifndef MRB_WITHOUT_FLOAT\n            SET_FLOAT_VALUE(mrb, regs[a], (mrb_float)x * (mrb_float)y);\n            break;\n#endif\n          }\n          SET_INT_VALUE(regs[a], z);\n        }\n        break;\n#ifndef MRB_WITHOUT_FLOAT\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FLOAT):\n        {\n          mrb_int x = mrb_fixnum(regs[a]);\n          mrb_float y = mrb_float(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], (mrb_float)x * y);\n        }\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FIXNUM):\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          mrb_int y = mrb_fixnum(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], x * y);\n        }\n#else\n        OP_MATH_BODY(*,mrb_float,mrb_fixnum);\n#endif\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          mrb_float y = mrb_float(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], x * y);\n        }\n#else\n        OP_MATH_BODY(*,mrb_float,mrb_float);\n#endif\n        break;\n#endif\n      default:\n        goto L_SEND;\n      }\n      NEXT;\n    }\n\n    CASE(OP_DIV) {\n      /* A B C  R(A) := R(A)/R(A+1) (Syms[B]=:/,C=1)*/\n      int a = GETARG_A(i);\n#ifndef MRB_WITHOUT_FLOAT\n      double x, y, f;\n#endif\n\n      /* need to check if op is overridden */\n      switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):\n#ifdef MRB_WITHOUT_FLOAT\n        {\n          mrb_int x = mrb_fixnum(regs[a]);\n          mrb_int y = mrb_fixnum(regs[a+1]);\n          SET_INT_VALUE(regs[a], y ? x / y : 0);\n        }\n        break;\n#else\n        x = (mrb_float)mrb_fixnum(regs[a]);\n        y = (mrb_float)mrb_fixnum(regs[a+1]);\n        break;\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FLOAT):\n        x = (mrb_float)mrb_fixnum(regs[a]);\n        y = mrb_float(regs[a+1]);\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FIXNUM):\n        x = mrb_float(regs[a]);\n        y = (mrb_float)mrb_fixnum(regs[a+1]);\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\n        x = mrb_float(regs[a]);\n        y = mrb_float(regs[a+1]);\n        break;\n#endif\n      default:\n        goto L_SEND;\n      }\n\n#ifndef MRB_WITHOUT_FLOAT\n      if (y == 0) {\n        if (x > 0) f = INFINITY;\n        else if (x < 0) f = -INFINITY;\n        else /* if (x == 0) */ f = NAN;\n      }\n      else {\n        f = x / y;\n      }\n      SET_FLOAT_VALUE(mrb, regs[a], f);\n#endif\n      NEXT;\n    }\n\n    CASE(OP_ADDI) {\n      /* A B C  R(A) := R(A)+C (Syms[B]=:+)*/\n      int a = GETARG_A(i);\n\n      /* need to check if + is overridden */\n      switch (mrb_type(regs[a])) {\n      case MRB_TT_FIXNUM:\n        {\n          mrb_int x = mrb_fixnum(regs[a]);\n          mrb_int y = GETARG_C(i);\n          mrb_int z;\n\n          if (mrb_int_add_overflow(x, y, &z)) {\n#ifndef MRB_WITHOUT_FLOAT\n            SET_FLOAT_VALUE(mrb, regs[a], (mrb_float)x + (mrb_float)y);\n            break;\n#endif\n          }\n          SET_INT_VALUE(regs[a], z);\n        }\n        break;\n#ifndef MRB_WITHOUT_FLOAT\n      case MRB_TT_FLOAT:\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          SET_FLOAT_VALUE(mrb, regs[a], x + GETARG_C(i));\n        }\n#else\n        mrb_float(regs[a]) += GETARG_C(i);\n#endif\n        break;\n#endif\n      default:\n        SET_INT_VALUE(regs[a+1], GETARG_C(i));\n        i = MKOP_ABC(OP_SEND, a, GETARG_B(i), 1);\n        goto L_SEND;\n      }\n      NEXT;\n    }\n\n    CASE(OP_SUBI) {\n      /* A B C  R(A) := R(A)-C (Syms[B]=:-)*/\n      int a = GETARG_A(i);\n      mrb_value *regs_a = regs + a;\n\n      /* need to check if + is overridden */\n      switch (mrb_type(regs_a[0])) {\n      case MRB_TT_FIXNUM:\n        {\n          mrb_int x = mrb_fixnum(regs_a[0]);\n          mrb_int y = GETARG_C(i);\n          mrb_int z;\n\n          if (mrb_int_sub_overflow(x, y, &z)) {\n#ifndef MRB_WITHOUT_FLOAT\n            SET_FLOAT_VALUE(mrb, regs_a[0], (mrb_float)x - (mrb_float)y);\n            break;\n#endif\n          }\n          SET_INT_VALUE(regs_a[0], z);\n        }\n        break;\n#ifndef MRB_WITHOUT_FLOAT\n      case MRB_TT_FLOAT:\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          SET_FLOAT_VALUE(mrb, regs[a], x - GETARG_C(i));\n        }\n#else\n        mrb_float(regs_a[0]) -= GETARG_C(i);\n#endif\n        break;\n#endif\n      default:\n        SET_INT_VALUE(regs_a[1], GETARG_C(i));\n        i = MKOP_ABC(OP_SEND, a, GETARG_B(i), 1);\n        goto L_SEND;\n      }\n      NEXT;\n    }\n\n#define OP_CMP_BODY(op,v1,v2) (v1(regs[a]) op v2(regs[a+1]))\n\n#ifdef MRB_WITHOUT_FLOAT\n#define OP_CMP(op) do {\\\n  int result;\\\n  /* need to check if - is overridden */\\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\\\n  case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_fixnum);\\\n    break;\\\n  default:\\\n    goto L_SEND;\\\n  }\\\n  if (result) {\\\n    SET_TRUE_VALUE(regs[a]);\\\n  }\\\n  else {\\\n    SET_FALSE_VALUE(regs[a]);\\\n  }\\\n} while(0)\n#else\n#define OP_CMP(op) do {\\\n  int result;\\\n  /* need to check if - is overridden */\\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\\\n  case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_fixnum);\\\n    break;\\\n  case TYPES2(MRB_TT_FIXNUM,MRB_TT_FLOAT):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_float);\\\n    break;\\\n  case TYPES2(MRB_TT_FLOAT,MRB_TT_FIXNUM):\\\n    result = OP_CMP_BODY(op,mrb_float,mrb_fixnum);\\\n    break;\\\n  case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\\\n    result = OP_CMP_BODY(op,mrb_float,mrb_float);\\\n    break;\\\n  default:\\\n    goto L_SEND;\\\n  }\\\n  if (result) {\\\n    SET_TRUE_VALUE(regs[a]);\\\n  }\\\n  else {\\\n    SET_FALSE_VALUE(regs[a]);\\\n  }\\\n} while(0)\n#endif\n\n    CASE(OP_EQ) {\n      /* A B C  R(A) := R(A)==R(A+1) (Syms[B]=:==,C=1)*/\n      int a = GETARG_A(i);\n      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {\n        SET_TRUE_VALUE(regs[a]);\n      }\n      else {\n        OP_CMP(==);\n      }\n      NEXT;\n    }\n\n    CASE(OP_LT) {\n      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/\n      int a = GETARG_A(i);\n      OP_CMP(<);\n      NEXT;\n    }\n\n    CASE(OP_LE) {\n      /* A B C  R(A) := R(A)<=R(A+1) (Syms[B]=:<=,C=1)*/\n      int a = GETARG_A(i);\n      OP_CMP(<=);\n      NEXT;\n    }\n\n    CASE(OP_GT) {\n      /* A B C  R(A) := R(A)>R(A+1) (Syms[B]=:>,C=1)*/\n      int a = GETARG_A(i);\n      OP_CMP(>);\n      NEXT;\n    }\n\n    CASE(OP_GE) {\n      /* A B C  R(A) := R(A)>=R(A+1) (Syms[B]=:>=,C=1)*/\n      int a = GETARG_A(i);\n      OP_CMP(>=);\n      NEXT;\n    }\n\n    CASE(OP_ARRAY) {\n      /* A B C          R(A) := ary_new(R(B),R(B+1)..R(B+C)) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n      mrb_value v = mrb_ary_new_from_values(mrb, c, &regs[b]);\n      regs[a] = v;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ARYCAT) {\n      /* A B            mrb_ary_concat(R(A),R(B)) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      mrb_value splat = mrb_ary_splat(mrb, regs[b]);\n      mrb_ary_concat(mrb, regs[a], splat);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ARYPUSH) {\n      /* A B            R(A).push(R(B)) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      mrb_ary_push(mrb, regs[a], regs[b]);\n      NEXT;\n    }\n\n    CASE(OP_AREF) {\n      /* A B C          R(A) := R(B)[C] */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n      mrb_value v = regs[b];\n\n      if (!mrb_array_p(v)) {\n        if (c == 0) {\n          regs[a] = v;\n        }\n        else {\n          SET_NIL_VALUE(regs[a]);\n        }\n      }\n      else {\n        v = mrb_ary_ref(mrb, v, c);\n        regs[a] = v;\n      }\n      NEXT;\n    }\n\n    CASE(OP_ASET) {\n      /* A B C          R(B)[C] := R(A) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n      mrb_ary_set(mrb, regs[b], c, regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_APOST) {\n      /* A B C  *R(A),R(A+1)..R(A+C) := R(A) */\n      int a = GETARG_A(i);\n      mrb_value v = regs[a];\n      int pre  = GETARG_B(i);\n      int post = GETARG_C(i);\n      struct RArray *ary;\n      int len, idx;\n\n      if (!mrb_array_p(v)) {\n        v = mrb_ary_new_from_values(mrb, 1, &regs[a]);\n      }\n      ary = mrb_ary_ptr(v);\n      len = (int)ARY_LEN(ary);\n      if (len > pre + post) {\n        v = mrb_ary_new_from_values(mrb, len - pre - post, ARY_PTR(ary)+pre);\n        regs[a++] = v;\n        while (post--) {\n          regs[a++] = ARY_PTR(ary)[len-post-1];\n        }\n      }\n      else {\n        v = mrb_ary_new_capa(mrb, 0);\n        regs[a++] = v;\n        for (idx=0; idx+pre<len; idx++) {\n          regs[a+idx] = ARY_PTR(ary)[pre+idx];\n        }\n        while (idx < post) {\n          SET_NIL_VALUE(regs[a+idx]);\n          idx++;\n        }\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_STRING) {\n      /* A Bx           R(A) := str_new(Lit(Bx)) */\n      mrb_int a = GETARG_A(i);\n      mrb_int bx = GETARG_Bx(i);\n      mrb_value str = mrb_str_dup(mrb, pool[bx]);\n\n      regs[a] = str;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_STRCAT) {\n      /* A B    R(A).concat(R(B)) */\n      mrb_int a = GETARG_A(i);\n      mrb_int b = GETARG_B(i);\n\n      mrb_str_concat(mrb, regs[a], regs[b]);\n      NEXT;\n    }\n\n    CASE(OP_HASH) {\n      /* A B C   R(A) := hash_new(R(B),R(B+1)..R(B+C)) */\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n      int lim = b+c*2;\n      mrb_value hash = mrb_hash_new_capa(mrb, c);\n\n      while (b < lim) {\n        mrb_hash_set(mrb, hash, regs[b], regs[b+1]);\n        b+=2;\n      }\n      regs[GETARG_A(i)] = hash;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_LAMBDA) {\n      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */\n      struct RProc *p;\n      int a = GETARG_A(i);\n      int b = GETARG_b(i);\n      int c = GETARG_c(i);\n      mrb_irep *nirep = irep->reps[b];\n\n      if (c & OP_L_CAPTURE) {\n        p = mrb_closure_new(mrb, nirep);\n      }\n      else {\n        p = mrb_proc_new(mrb, nirep);\n        p->flags |= MRB_PROC_SCOPE;\n      }\n      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;\n      regs[a] = mrb_obj_value(p);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_OCLASS) {\n      /* A      R(A) := ::Object */\n      regs[GETARG_A(i)] = mrb_obj_value(mrb->object_class);\n      NEXT;\n    }\n\n    CASE(OP_CLASS) {\n      /* A B    R(A) := newclass(R(A),Syms(B),R(A+1)) */\n      struct RClass *c = 0, *baseclass;\n      int a = GETARG_A(i);\n      mrb_value base, super;\n      mrb_sym id = syms[GETARG_B(i)];\n\n      base = regs[a];\n      super = regs[a+1];\n      if (mrb_nil_p(base)) {\n        baseclass = MRB_PROC_TARGET_CLASS(mrb->c->ci->proc);\n        base = mrb_obj_value(baseclass);\n      }\n      c = mrb_vm_define_class(mrb, base, super, id);\n      regs[a] = mrb_obj_value(c);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_MODULE) {\n      /* A B            R(A) := newmodule(R(A),Syms(B)) */\n      struct RClass *c = 0, *baseclass;\n      int a = GETARG_A(i);\n      mrb_value base;\n      mrb_sym id = syms[GETARG_B(i)];\n\n      base = regs[a];\n      if (mrb_nil_p(base)) {\n        baseclass = MRB_PROC_TARGET_CLASS(mrb->c->ci->proc);\n        base = mrb_obj_value(baseclass);\n      }\n      c = mrb_vm_define_module(mrb, base, id);\n      regs[a] = mrb_obj_value(c);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_EXEC) {\n      /* A Bx   R(A) := blockexec(R(A),SEQ[Bx]) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_callinfo *ci;\n      mrb_value recv = regs[a];\n      struct RProc *p;\n      mrb_irep *nirep = irep->reps[bx];\n\n      /* prepare closure */\n      p = mrb_proc_new(mrb, nirep);\n      p->c = NULL;\n      mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)proc);\n      MRB_PROC_SET_TARGET_CLASS(p, mrb_class_ptr(recv));\n      p->flags |= MRB_PROC_SCOPE;\n\n      /* prepare call stack */\n      ci = cipush(mrb);\n      ci->pc = pc + 1;\n      ci->acc = a;\n      ci->mid = 0;\n      ci->stackent = mrb->c->stack;\n      ci->argc = 0;\n      ci->target_class = mrb_class_ptr(recv);\n\n      /* prepare stack */\n      mrb->c->stack += a;\n\n      /* setup block to call */\n      ci->proc = p;\n\n      irep = p->body.irep;\n      pool = irep->pool;\n      syms = irep->syms;\n      ci->nregs = irep->nregs;\n      stack_extend(mrb, ci->nregs);\n      stack_clear(regs+1, ci->nregs-1);\n      pc = irep->iseq;\n      JUMP;\n    }\n\n    CASE(OP_METHOD) {\n      /* A B            R(A).newmethod(Syms(B),R(A+1)) */\n      int a = GETARG_A(i);\n      struct RClass *c = mrb_class_ptr(regs[a]);\n      struct RProc *p = mrb_proc_ptr(regs[a+1]);\n      mrb_method_t m;\n\n      MRB_METHOD_FROM_PROC(m, p);\n      mrb_define_method_raw(mrb, c, syms[GETARG_B(i)], m);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_SCLASS) {\n      /* A B    R(A) := R(B).singleton_class */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n\n      regs[a] = mrb_singleton_class(mrb, regs[b]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_TCLASS) {\n      /* A      R(A) := target_class */\n      if (!mrb->c->ci->target_class) {\n        mrb_value exc = mrb_exc_new_str_lit(mrb, E_TYPE_ERROR, \"no target class or module\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      regs[GETARG_A(i)] = mrb_obj_value(mrb->c->ci->target_class);\n      NEXT;\n    }\n\n    CASE(OP_RANGE) {\n      /* A B C  R(A) := range_new(R(B),R(B+1),C) */\n      int b = GETARG_B(i);\n      mrb_value val = mrb_range_new(mrb, regs[b], regs[b+1], GETARG_C(i));\n      regs[GETARG_A(i)] = val;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_DEBUG) {\n      /* A B C    debug print R(A),R(B),R(C) */\n#ifdef MRB_ENABLE_DEBUG_HOOK\n      mrb->debug_op_hook(mrb, irep, pc, regs);\n#else\n#ifndef MRB_DISABLE_STDIO\n      printf(\"OP_DEBUG %d %d %d\\n\", GETARG_A(i), GETARG_B(i), GETARG_C(i));\n#else\n      abort();\n#endif\n#endif\n      NEXT;\n    }\n\n    CASE(OP_STOP) {\n      /*        stop VM */\n    L_STOP:\n      while (mrb->c->eidx > 0) {\n        ecall(mrb);\n      }\n      ERR_PC_CLR(mrb);\n      mrb->jmp = prev_jmp;\n      if (mrb->exc) {\n        return mrb_obj_value(mrb->exc);\n      }\n      return regs[irep->nlocals];\n    }\n\n    CASE(OP_ERR) {\n      /* Bx     raise RuntimeError with message Lit(Bx) */\n      mrb_value msg = mrb_str_dup(mrb, pool[GETARG_Bx(i)]);\n      mrb_value exc;\n\n      if (GETARG_A(i) == 0) {\n        exc = mrb_exc_new_str(mrb, E_RUNTIME_ERROR, msg);\n      }\n      else {\n        exc = mrb_exc_new_str(mrb, E_LOCALJUMP_ERROR, msg);\n      }\n      ERR_PC_SET(mrb, pc);\n      mrb_exc_set(mrb, exc);\n      goto L_RAISE;\n    }\n  }\n  END_DISPATCH;\n#undef regs\n\n  }\n  MRB_CATCH(&c_jmp) {\n    exc_catched = TRUE;\n    goto RETRY_TRY_BLOCK;\n  }\n  MRB_END_EXC(&c_jmp);\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149909,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static void *__ns_get_path(struct path *path, struct ns_common *ns)\n{\n\tstruct vfsmount *mnt = nsfs_mnt;\n\tstruct qstr qname = { .name = \"\", };\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tunsigned long d;\n\n\trcu_read_lock();\n\td = atomic_long_read(&ns->stashed);\n\tif (!d)\n\t\tgoto slow;\n\tdentry = (struct dentry *)d;\n\tif (!lockref_get_not_dead(&dentry->d_lockref))\n\t\tgoto slow;\n\trcu_read_unlock();\n\tns->ops->put(ns);\ngot_it:\n\tpath->mnt = mntget(mnt);\n\tpath->dentry = dentry;\n\treturn NULL;\nslow:\n\trcu_read_unlock();\n\tinode = new_inode_pseudo(mnt->mnt_sb);\n\tif (!inode) {\n\t\tns->ops->put(ns);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tinode->i_ino = ns->inum;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = current_time(inode);\n\tinode->i_flags |= S_IMMUTABLE;\n\tinode->i_mode = S_IFREG | S_IRUGO;\n\tinode->i_fop = &ns_file_operations;\n\tinode->i_private = ns;\n\n\tdentry = d_alloc_pseudo(mnt->mnt_sb, &qname);\n\tif (!dentry) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\td_instantiate(dentry, inode);\n\tdentry->d_fsdata = (void *)ns->ops;\n\td = atomic_long_cmpxchg(&ns->stashed, 0, (unsigned long)dentry);\n\tif (d) {\n\t\td_delete(dentry);\t/* make sure ->d_prune() does nothing */\n\t\tdput(dentry);\n\t\tcpu_relax();\n\t\treturn ERR_PTR(-EAGAIN);\n\t}\n\tgoto got_it;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149910,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static void *__ns_get_path(struct path *path, struct ns_common *ns)\n{\n\tstruct vfsmount *mnt = nsfs_mnt;\n\tstruct qstr qname = { .name = \"\", };\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tunsigned long d;\n\n\trcu_read_lock();\n\td = atomic_long_read(&ns->stashed);\n\tif (!d)\n\t\tgoto slow;\n\tdentry = (struct dentry *)d;\n\tif (!lockref_get_not_dead(&dentry->d_lockref))\n\t\tgoto slow;\n\trcu_read_unlock();\n\tns->ops->put(ns);\ngot_it:\n\tpath->mnt = mntget(mnt);\n\tpath->dentry = dentry;\n\treturn NULL;\nslow:\n\trcu_read_unlock();\n\tinode = new_inode_pseudo(mnt->mnt_sb);\n\tif (!inode) {\n\t\tns->ops->put(ns);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tinode->i_ino = ns->inum;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = current_time(inode);\n\tinode->i_flags |= S_IMMUTABLE;\n\tinode->i_mode = S_IFREG | S_IRUGO;\n\tinode->i_fop = &ns_file_operations;\n\tinode->i_private = ns;\n\n\tdentry = d_alloc_pseudo(mnt->mnt_sb, &qname);\n\tif (!dentry) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\td_instantiate(dentry, inode);\n\tdentry->d_flags |= DCACHE_RCUACCESS;\n\tdentry->d_fsdata = (void *)ns->ops;\n\td = atomic_long_cmpxchg(&ns->stashed, 0, (unsigned long)dentry);\n\tif (d) {\n\t\td_delete(dentry);\t/* make sure ->d_prune() does nothing */\n\t\tdput(dentry);\n\t\tcpu_relax();\n\t\treturn ERR_PTR(-EAGAIN);\n\t}\n\tgoto got_it;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149911,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "PHP_FUNCTION(unserialize)\n{\n\tchar *buf = NULL;\n\tsize_t buf_len;\n\tconst unsigned char *p;\n\tphp_unserialize_data_t var_hash;\n\tzval *options = NULL, *classes = NULL;\n\tHashTable *class_hash = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"s|a\", &buf, &buf_len, &options) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (buf_len == 0) {\n\t\tRETURN_FALSE;\n\t}\n\n\tp = (const unsigned char*) buf;\n\tPHP_VAR_UNSERIALIZE_INIT(var_hash);\n\tif(options != NULL) {\n\t\tclasses = zend_hash_str_find(Z_ARRVAL_P(options), \"allowed_classes\", sizeof(\"allowed_classes\")-1);\n\t\tif(classes && (Z_TYPE_P(classes) == IS_ARRAY || !zend_is_true(classes))) {\n\t\t\tALLOC_HASHTABLE(class_hash);\n\t\t\tzend_hash_init(class_hash, (Z_TYPE_P(classes) == IS_ARRAY)?zend_hash_num_elements(Z_ARRVAL_P(classes)):0, NULL, NULL, 0);\n\t\t}\n\t\tif(class_hash && Z_TYPE_P(classes) == IS_ARRAY) {\n\t\t\tzval *entry;\n\t\t\tzend_string *lcname;\n\n\t\t\tZEND_HASH_FOREACH_VAL(Z_ARRVAL_P(classes), entry) {\n\t\t\t\tconvert_to_string_ex(entry);\n\t\t\t\tlcname = zend_string_tolower(Z_STR_P(entry));\n\t\t\t\tzend_hash_add_empty_element(class_hash, lcname);\n\t\t        zend_string_release(lcname);\n\t\t\t} ZEND_HASH_FOREACH_END();\n\t\t}\n\t}\n\n\tif (!php_var_unserialize_ex(return_value, &p, p + buf_len, &var_hash, class_hash)) {\n\t\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\t\tif (class_hash) {\n\t\t\tzend_hash_destroy(class_hash);\n\t\t\tFREE_HASHTABLE(class_hash);\n\t\t}\n\t\tzval_ptr_dtor(return_value);\n\t\tif (!EG(exception)) {\n\t\t\tphp_error_docref(NULL, E_NOTICE, \"Error at offset \" ZEND_LONG_FMT \" of %zd bytes\",\n\t\t\t\t(zend_long)((char*)p - buf), buf_len);\n\t\t}\n\t\tRETURN_FALSE;\n\t}\n\t/* We should keep an reference to return_value to prevent it from being dtor\n\t   in case nesting calls to unserialize */\n\tvar_push_dtor(&var_hash, return_value);\n\n\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\tif (class_hash) {\n\t\tzend_hash_destroy(class_hash);\n\t\tFREE_HASHTABLE(class_hash);\n\t}\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149912,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "PHP_FUNCTION(unserialize)\n{\n\tchar *buf = NULL;\n\tsize_t buf_len;\n\tconst unsigned char *p;\n\tphp_unserialize_data_t var_hash;\n\tzval *options = NULL, *classes = NULL;\n\tzval *retval;\n\tHashTable *class_hash = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"s|a\", &buf, &buf_len, &options) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (buf_len == 0) {\n\t\tRETURN_FALSE;\n\t}\n\n\tp = (const unsigned char*) buf;\n\tPHP_VAR_UNSERIALIZE_INIT(var_hash);\n\tif(options != NULL) {\n\t\tclasses = zend_hash_str_find(Z_ARRVAL_P(options), \"allowed_classes\", sizeof(\"allowed_classes\")-1);\n\t\tif(classes && (Z_TYPE_P(classes) == IS_ARRAY || !zend_is_true(classes))) {\n\t\t\tALLOC_HASHTABLE(class_hash);\n\t\t\tzend_hash_init(class_hash, (Z_TYPE_P(classes) == IS_ARRAY)?zend_hash_num_elements(Z_ARRVAL_P(classes)):0, NULL, NULL, 0);\n\t\t}\n\t\tif(class_hash && Z_TYPE_P(classes) == IS_ARRAY) {\n\t\t\tzval *entry;\n\t\t\tzend_string *lcname;\n\n\t\t\tZEND_HASH_FOREACH_VAL(Z_ARRVAL_P(classes), entry) {\n\t\t\t\tconvert_to_string_ex(entry);\n\t\t\t\tlcname = zend_string_tolower(Z_STR_P(entry));\n\t\t\t\tzend_hash_add_empty_element(class_hash, lcname);\n\t\t        zend_string_release(lcname);\n\t\t\t} ZEND_HASH_FOREACH_END();\n\t\t}\n\t}\n\n\tretval = var_tmp_var(&var_hash);\n\tif (!php_var_unserialize_ex(retval, &p, p + buf_len, &var_hash, class_hash)) {\n\t\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\t\tif (class_hash) {\n\t\t\tzend_hash_destroy(class_hash);\n\t\t\tFREE_HASHTABLE(class_hash);\n\t\t}\n\t\tif (!EG(exception)) {\n\t\t\tphp_error_docref(NULL, E_NOTICE, \"Error at offset \" ZEND_LONG_FMT \" of %zd bytes\",\n\t\t\t\t(zend_long)((char*)p - buf), buf_len);\n\t\t}\n\t\tRETURN_FALSE;\n\t}\n\n\tZVAL_COPY(return_value, retval);\n\n\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\tif (class_hash) {\n\t\tzend_hash_destroy(class_hash);\n\t\tFREE_HASHTABLE(class_hash);\n\t}\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149913,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static MagickBooleanType TraceBezier(MVGInfo *mvg_info,\n  const size_t number_coordinates)\n{\n  double\n    alpha,\n    *coefficients,\n    weight;\n\n  PointInfo\n    end,\n    point,\n    *points;\n\n  PrimitiveInfo\n    *primitive_info;\n\n  register PrimitiveInfo\n    *p;\n\n  register ssize_t\n    i,\n    j;\n\n  size_t\n    control_points,\n    quantum;\n\n  /*\n    Allocate coefficients.\n  */\n  primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;\n  quantum=number_coordinates;\n  for (i=0; i < (ssize_t) number_coordinates; i++)\n  {\n    for (j=i+1; j < (ssize_t) number_coordinates; j++)\n    {\n      alpha=fabs(primitive_info[j].point.x-primitive_info[i].point.x);\n      if (alpha > (double) SSIZE_MAX)\n        {\n          (void) ThrowMagickException(mvg_info->exception,GetMagickModule(),\n            ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n          return(MagickFalse);\n        }\n      if (alpha > (double) quantum)\n        quantum=(size_t) alpha;\n      alpha=fabs(primitive_info[j].point.y-primitive_info[i].point.y);\n      if (alpha > (double) SSIZE_MAX)\n        {\n          (void) ThrowMagickException(mvg_info->exception,GetMagickModule(),\n            ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n          return(MagickFalse);\n        }\n      if (alpha > (double) quantum)\n        quantum=(size_t) alpha;\n    }\n  }\n  quantum=MagickMin(quantum/number_coordinates,BezierQuantum);\n  primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;\n  coefficients=(double *) AcquireQuantumMemory(number_coordinates,\n    sizeof(*coefficients));\n  points=(PointInfo *) AcquireQuantumMemory(quantum,number_coordinates*\n    sizeof(*points));\n  if ((coefficients == (double *) NULL) || (points == (PointInfo *) NULL))\n    {\n      if (points != (PointInfo *) NULL)\n        points=(PointInfo *) RelinquishMagickMemory(points);\n      if (coefficients != (double *) NULL)\n        coefficients=(double *) RelinquishMagickMemory(coefficients);\n      (void) ThrowMagickException(mvg_info->exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n      return(MagickFalse);\n    }\n  control_points=quantum*number_coordinates;\n  if (CheckPrimitiveExtent(mvg_info,control_points+1) == MagickFalse)\n    {\n      points=(PointInfo *) RelinquishMagickMemory(points);\n      coefficients=(double *) RelinquishMagickMemory(coefficients);\n      return(MagickFalse);\n    }\n  /*\n    Compute bezier points.\n  */\n  end=primitive_info[number_coordinates-1].point;\n  for (i=0; i < (ssize_t) number_coordinates; i++)\n    coefficients[i]=Permutate((ssize_t) number_coordinates-1,i);\n  weight=0.0;\n  for (i=0; i < (ssize_t) control_points; i++)\n  {\n    p=primitive_info;\n    point.x=0.0;\n    point.y=0.0;\n    alpha=pow((double) (1.0-weight),(double) number_coordinates-1.0);\n    for (j=0; j < (ssize_t) number_coordinates; j++)\n    {\n      point.x+=alpha*coefficients[j]*p->point.x;\n      point.y+=alpha*coefficients[j]*p->point.y;\n      alpha*=weight/(1.0-weight);\n      p++;\n    }\n    points[i]=point;\n    weight+=1.0/control_points;\n  }\n  /*\n    Bezier curves are just short segmented polys.\n  */\n  p=primitive_info;\n  for (i=0; i < (ssize_t) control_points; i++)\n  {\n    if (TracePoint(p,points[i]) == MagickFalse)\n      {\n        points=(PointInfo *) RelinquishMagickMemory(points);\n        coefficients=(double *) RelinquishMagickMemory(coefficients);\n        return(MagickFalse);\n      }\n    p+=p->coordinates;\n  }\n  if (TracePoint(p,end) == MagickFalse)\n    {\n      points=(PointInfo *) RelinquishMagickMemory(points);\n      coefficients=(double *) RelinquishMagickMemory(coefficients);\n      return(MagickFalse);\n    }\n  p+=p->coordinates;\n  primitive_info->coordinates=(size_t) (p-primitive_info);\n  primitive_info->closed_subpath=MagickFalse;\n  for (i=0; i < (ssize_t) primitive_info->coordinates; i++)\n  {\n    p->primitive=primitive_info->primitive;\n    p--;\n  }\n  points=(PointInfo *) RelinquishMagickMemory(points);\n  coefficients=(double *) RelinquishMagickMemory(coefficients);\n  return(MagickTrue);\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149914,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static MagickBooleanType TraceBezier(MVGInfo *mvg_info,\n  const size_t number_coordinates)\n{\n  double\n    alpha,\n    *coefficients,\n    weight;\n\n  PointInfo\n    end,\n    point,\n    *points;\n\n  PrimitiveInfo\n    *primitive_info;\n\n  register PrimitiveInfo\n    *p;\n\n  register ssize_t\n    i,\n    j;\n\n  size_t\n    control_points,\n    quantum;\n\n  /*\n    Allocate coefficients.\n  */\n  primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;\n  quantum=number_coordinates;\n  for (i=0; i < (ssize_t) number_coordinates; i++)\n  {\n    for (j=i+1; j < (ssize_t) number_coordinates; j++)\n    {\n      alpha=fabs(primitive_info[j].point.x-primitive_info[i].point.x);\n      if (alpha > (double) SSIZE_MAX)\n        {\n          (void) ThrowMagickException(mvg_info->exception,GetMagickModule(),\n            ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n          return(MagickFalse);\n        }\n      if (alpha > (double) quantum)\n        quantum=(size_t) alpha;\n      alpha=fabs(primitive_info[j].point.y-primitive_info[i].point.y);\n      if (alpha > (double) SSIZE_MAX)\n        {\n          (void) ThrowMagickException(mvg_info->exception,GetMagickModule(),\n            ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n          return(MagickFalse);\n        }\n      if (alpha > (double) quantum)\n        quantum=(size_t) alpha;\n    }\n  }\n  primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;\n  quantum=MagickMin(quantum/number_coordinates,BezierQuantum);\n  coefficients=(double *) AcquireQuantumMemory(number_coordinates,\n    sizeof(*coefficients));\n  points=(PointInfo *) AcquireQuantumMemory(quantum,number_coordinates*\n    sizeof(*points));\n  if ((coefficients == (double *) NULL) || (points == (PointInfo *) NULL))\n    {\n      if (points != (PointInfo *) NULL)\n        points=(PointInfo *) RelinquishMagickMemory(points);\n      if (coefficients != (double *) NULL)\n        coefficients=(double *) RelinquishMagickMemory(coefficients);\n      (void) ThrowMagickException(mvg_info->exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n      return(MagickFalse);\n    }\n  control_points=quantum*number_coordinates;\n  if (CheckPrimitiveExtent(mvg_info,control_points+1) == MagickFalse)\n    {\n      points=(PointInfo *) RelinquishMagickMemory(points);\n      coefficients=(double *) RelinquishMagickMemory(coefficients);\n      return(MagickFalse);\n    }\n  primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;\n  /*\n    Compute bezier points.\n  */\n  end=primitive_info[number_coordinates-1].point;\n  for (i=0; i < (ssize_t) number_coordinates; i++)\n    coefficients[i]=Permutate((ssize_t) number_coordinates-1,i);\n  weight=0.0;\n  for (i=0; i < (ssize_t) control_points; i++)\n  {\n    p=primitive_info;\n    point.x=0.0;\n    point.y=0.0;\n    alpha=pow((double) (1.0-weight),(double) number_coordinates-1.0);\n    for (j=0; j < (ssize_t) number_coordinates; j++)\n    {\n      point.x+=alpha*coefficients[j]*p->point.x;\n      point.y+=alpha*coefficients[j]*p->point.y;\n      alpha*=weight/(1.0-weight);\n      p++;\n    }\n    points[i]=point;\n    weight+=1.0/control_points;\n  }\n  /*\n    Bezier curves are just short segmented polys.\n  */\n  p=primitive_info;\n  for (i=0; i < (ssize_t) control_points; i++)\n  {\n    if (TracePoint(p,points[i]) == MagickFalse)\n      {\n        points=(PointInfo *) RelinquishMagickMemory(points);\n        coefficients=(double *) RelinquishMagickMemory(coefficients);\n        return(MagickFalse);\n      }\n    p+=p->coordinates;\n  }\n  if (TracePoint(p,end) == MagickFalse)\n    {\n      points=(PointInfo *) RelinquishMagickMemory(points);\n      coefficients=(double *) RelinquishMagickMemory(coefficients);\n      return(MagickFalse);\n    }\n  p+=p->coordinates;\n  primitive_info->coordinates=(size_t) (p-primitive_info);\n  primitive_info->closed_subpath=MagickFalse;\n  for (i=0; i < (ssize_t) primitive_info->coordinates; i++)\n  {\n    p->primitive=primitive_info->primitive;\n    p--;\n  }\n  points=(PointInfo *) RelinquishMagickMemory(points);\n  coefficients=(double *) RelinquishMagickMemory(coefficients);\n  return(MagickTrue);\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149915,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int parse_playlist(HLSContext *c, const char *url,\n                          struct playlist *pls, AVIOContext *in)\n{\n    int ret = 0, is_segment = 0, is_variant = 0;\n    int64_t duration = 0;\n    enum KeyType key_type = KEY_NONE;\n    uint8_t iv[16] = \"\";\n    int has_iv = 0;\n    char key[MAX_URL_SIZE] = \"\";\n    char line[MAX_URL_SIZE];\n    const char *ptr;\n    int close_in = 0;\n    int64_t seg_offset = 0;\n    int64_t seg_size = -1;\n    uint8_t *new_url = NULL;\n    struct variant_info variant_info;\n    char tmp_str[MAX_URL_SIZE];\n    struct segment *cur_init_section = NULL;\n\n    if (!in) {\n#if 1\n        AVDictionary *opts = NULL;\n        close_in = 1;\n        /* Some HLS servers don't like being sent the range header */\n        av_dict_set(&opts, \"seekable\", \"0\", 0);\n\n        // broker prior HTTP options that should be consistent across requests\n        av_dict_set(&opts, \"user-agent\", c->user_agent, 0);\n        av_dict_set(&opts, \"cookies\", c->cookies, 0);\n        av_dict_set(&opts, \"headers\", c->headers, 0);\n\n        ret = avio_open2(&in, url, AVIO_FLAG_READ,\n                         c->interrupt_callback, &opts);\n        av_dict_free(&opts);\n        if (ret < 0)\n            return ret;\n#else\n        ret = open_in(c, &in, url);\n        if (ret < 0)\n            return ret;\n        close_in = 1;\n#endif\n    }\n\n    if (av_opt_get(in, \"location\", AV_OPT_SEARCH_CHILDREN, &new_url) >= 0)\n        url = new_url;\n\n    read_chomp_line(in, line, sizeof(line));\n    if (strcmp(line, \"#EXTM3U\")) {\n        ret = AVERROR_INVALIDDATA;\n        goto fail;\n    }\n\n    if (pls) {\n        free_segment_list(pls);\n        pls->finished = 0;\n        pls->type = PLS_TYPE_UNSPECIFIED;\n    }\n    while (!avio_feof(in)) {\n        read_chomp_line(in, line, sizeof(line));\n        if (av_strstart(line, \"#EXT-X-STREAM-INF:\", &ptr)) {\n            is_variant = 1;\n            memset(&variant_info, 0, sizeof(variant_info));\n            ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_variant_args,\n                               &variant_info);\n        } else if (av_strstart(line, \"#EXT-X-KEY:\", &ptr)) {\n            struct key_info info = {{0}};\n            ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_key_args,\n                               &info);\n            key_type = KEY_NONE;\n            has_iv = 0;\n            if (!strcmp(info.method, \"AES-128\"))\n                key_type = KEY_AES_128;\n            if (!strcmp(info.method, \"SAMPLE-AES\"))\n                key_type = KEY_SAMPLE_AES;\n            if (!strncmp(info.iv, \"0x\", 2) || !strncmp(info.iv, \"0X\", 2)) {\n                ff_hex_to_data(iv, info.iv + 2);\n                has_iv = 1;\n            }\n            av_strlcpy(key, info.uri, sizeof(key));\n        } else if (av_strstart(line, \"#EXT-X-MEDIA:\", &ptr)) {\n            struct rendition_info info = {{0}};\n            ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_rendition_args,\n                               &info);\n            new_rendition(c, &info, url);\n        } else if (av_strstart(line, \"#EXT-X-TARGETDURATION:\", &ptr)) {\n            ret = ensure_playlist(c, &pls, url);\n            if (ret < 0)\n                goto fail;\n            pls->target_duration = atoi(ptr) * AV_TIME_BASE;\n        } else if (av_strstart(line, \"#EXT-X-MEDIA-SEQUENCE:\", &ptr)) {\n            ret = ensure_playlist(c, &pls, url);\n            if (ret < 0)\n                goto fail;\n            pls->start_seq_no = atoi(ptr);\n        } else if (av_strstart(line, \"#EXT-X-PLAYLIST-TYPE:\", &ptr)) {\n            ret = ensure_playlist(c, &pls, url);\n            if (ret < 0)\n                goto fail;\n            if (!strcmp(ptr, \"EVENT\"))\n                pls->type = PLS_TYPE_EVENT;\n            else if (!strcmp(ptr, \"VOD\"))\n                pls->type = PLS_TYPE_VOD;\n        } else if (av_strstart(line, \"#EXT-X-MAP:\", &ptr)) {\n            struct init_section_info info = {{0}};\n            ret = ensure_playlist(c, &pls, url);\n            if (ret < 0)\n                goto fail;\n            ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_init_section_args,\n                               &info);\n            cur_init_section = new_init_section(pls, &info, url);\n        } else if (av_strstart(line, \"#EXT-X-ENDLIST\", &ptr)) {\n            if (pls)\n                pls->finished = 1;\n        } else if (av_strstart(line, \"#EXTINF:\", &ptr)) {\n            is_segment = 1;\n            duration   = atof(ptr) * AV_TIME_BASE;\n        } else if (av_strstart(line, \"#EXT-X-BYTERANGE:\", &ptr)) {\n            seg_size = atoi(ptr);\n            ptr = strchr(ptr, '@');\n            if (ptr)\n                seg_offset = atoi(ptr+1);\n        } else if (av_strstart(line, \"#\", NULL)) {\n            continue;\n        } else if (line[0]) {\n            if (is_variant) {\n                if (!new_variant(c, &variant_info, line, url)) {\n                    ret = AVERROR(ENOMEM);\n                    goto fail;\n                }\n                is_variant = 0;\n            }\n            if (is_segment) {\n                struct segment *seg;\n                if (!pls) {\n                    if (!new_variant(c, 0, url, NULL)) {\n                        ret = AVERROR(ENOMEM);\n                        goto fail;\n                    }\n                    pls = c->playlists[c->n_playlists - 1];\n                }\n                seg = av_malloc(sizeof(struct segment));\n                if (!seg) {\n                    ret = AVERROR(ENOMEM);\n                    goto fail;\n                }\n                seg->duration = duration;\n                seg->key_type = key_type;\n                if (has_iv) {\n                    memcpy(seg->iv, iv, sizeof(iv));\n                } else {\n                    int seq = pls->start_seq_no + pls->n_segments;\n                    memset(seg->iv, 0, sizeof(seg->iv));\n                    AV_WB32(seg->iv + 12, seq);\n                }\n\n                if (key_type != KEY_NONE) {\n                    ff_make_absolute_url(tmp_str, sizeof(tmp_str), url, key);\n                    seg->key = av_strdup(tmp_str);\n                    if (!seg->key) {\n                        av_free(seg);\n                        ret = AVERROR(ENOMEM);\n                        goto fail;\n                    }\n                } else {\n                    seg->key = NULL;\n                }\n\n                ff_make_absolute_url(tmp_str, sizeof(tmp_str), url, line);\n                seg->url = av_strdup(tmp_str);\n                if (!seg->url) {\n                    av_free(seg->key);\n                    av_free(seg);\n                    ret = AVERROR(ENOMEM);\n                    goto fail;\n                }\n\n                dynarray_add(&pls->segments, &pls->n_segments, seg);\n                is_segment = 0;\n\n                seg->size = seg_size;\n                if (seg_size >= 0) {\n                    seg->url_offset = seg_offset;\n                    seg_offset += seg_size;\n                    seg_size = -1;\n                } else {\n                    seg->url_offset = 0;\n                    seg_offset = 0;\n                }\n\n                seg->init_section = cur_init_section;\n            }\n        }\n    }\n    if (pls)\n        pls->last_load_time = av_gettime_relative();\n\nfail:\n    av_free(new_url);\n    if (close_in)\n        avio_close(in);\n    return ret;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149916,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int parse_playlist(HLSContext *c, const char *url,\n                          struct playlist *pls, AVIOContext *in)\n{\n    int ret = 0, is_segment = 0, is_variant = 0;\n    int64_t duration = 0;\n    enum KeyType key_type = KEY_NONE;\n    uint8_t iv[16] = \"\";\n    int has_iv = 0;\n    char key[MAX_URL_SIZE] = \"\";\n    char line[MAX_URL_SIZE];\n    const char *ptr;\n    int close_in = 0;\n    int64_t seg_offset = 0;\n    int64_t seg_size = -1;\n    uint8_t *new_url = NULL;\n    struct variant_info variant_info;\n    char tmp_str[MAX_URL_SIZE];\n    struct segment *cur_init_section = NULL;\n\n    if (!in) {\n#if 1\n        AVDictionary *opts = NULL;\n        close_in = 1;\n        /* Some HLS servers don't like being sent the range header */\n        av_dict_set(&opts, \"seekable\", \"0\", 0);\n\n        // broker prior HTTP options that should be consistent across requests\n        av_dict_set(&opts, \"user-agent\", c->user_agent, 0);\n        av_dict_set(&opts, \"cookies\", c->cookies, 0);\n        av_dict_set(&opts, \"headers\", c->headers, 0);\n\n        ret = avio_open2(&in, url, AVIO_FLAG_READ,\n                         c->interrupt_callback, &opts);\n        av_dict_free(&opts);\n        if (ret < 0)\n            return ret;\n#else\n        ret = open_in(c, &in, url);\n        if (ret < 0)\n            return ret;\n        close_in = 1;\n#endif\n    }\n\n    if (av_opt_get(in, \"location\", AV_OPT_SEARCH_CHILDREN, &new_url) >= 0)\n        url = new_url;\n\n    read_chomp_line(in, line, sizeof(line));\n    if (strcmp(line, \"#EXTM3U\")) {\n        ret = AVERROR_INVALIDDATA;\n        goto fail;\n    }\n\n    if (pls) {\n        free_segment_list(pls);\n        pls->finished = 0;\n        pls->type = PLS_TYPE_UNSPECIFIED;\n    }\n    while (!avio_feof(in)) {\n        read_chomp_line(in, line, sizeof(line));\n        if (av_strstart(line, \"#EXT-X-STREAM-INF:\", &ptr)) {\n            is_variant = 1;\n            memset(&variant_info, 0, sizeof(variant_info));\n            ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_variant_args,\n                               &variant_info);\n        } else if (av_strstart(line, \"#EXT-X-KEY:\", &ptr)) {\n            struct key_info info = {{0}};\n            ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_key_args,\n                               &info);\n            key_type = KEY_NONE;\n            has_iv = 0;\n            if (!strcmp(info.method, \"AES-128\"))\n                key_type = KEY_AES_128;\n            if (!strcmp(info.method, \"SAMPLE-AES\"))\n                key_type = KEY_SAMPLE_AES;\n            if (!strncmp(info.iv, \"0x\", 2) || !strncmp(info.iv, \"0X\", 2)) {\n                ff_hex_to_data(iv, info.iv + 2);\n                has_iv = 1;\n            }\n            av_strlcpy(key, info.uri, sizeof(key));\n        } else if (av_strstart(line, \"#EXT-X-MEDIA:\", &ptr)) {\n            struct rendition_info info = {{0}};\n            ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_rendition_args,\n                               &info);\n            new_rendition(c, &info, url);\n        } else if (av_strstart(line, \"#EXT-X-TARGETDURATION:\", &ptr)) {\n            ret = ensure_playlist(c, &pls, url);\n            if (ret < 0)\n                goto fail;\n            pls->target_duration = atoi(ptr) * AV_TIME_BASE;\n        } else if (av_strstart(line, \"#EXT-X-MEDIA-SEQUENCE:\", &ptr)) {\n            ret = ensure_playlist(c, &pls, url);\n            if (ret < 0)\n                goto fail;\n            pls->start_seq_no = atoi(ptr);\n        } else if (av_strstart(line, \"#EXT-X-PLAYLIST-TYPE:\", &ptr)) {\n            ret = ensure_playlist(c, &pls, url);\n            if (ret < 0)\n                goto fail;\n            if (!strcmp(ptr, \"EVENT\"))\n                pls->type = PLS_TYPE_EVENT;\n            else if (!strcmp(ptr, \"VOD\"))\n                pls->type = PLS_TYPE_VOD;\n        } else if (av_strstart(line, \"#EXT-X-MAP:\", &ptr)) {\n            struct init_section_info info = {{0}};\n            ret = ensure_playlist(c, &pls, url);\n            if (ret < 0)\n                goto fail;\n            ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_init_section_args,\n                               &info);\n            cur_init_section = new_init_section(pls, &info, url);\n        } else if (av_strstart(line, \"#EXT-X-ENDLIST\", &ptr)) {\n            if (pls)\n                pls->finished = 1;\n        } else if (av_strstart(line, \"#EXTINF:\", &ptr)) {\n            is_segment = 1;\n            duration   = atof(ptr) * AV_TIME_BASE;\n        } else if (av_strstart(line, \"#EXT-X-BYTERANGE:\", &ptr)) {\n            seg_size = atoi(ptr);\n            ptr = strchr(ptr, '@');\n            if (ptr)\n                seg_offset = atoi(ptr+1);\n        } else if (av_strstart(line, \"#\", NULL)) {\n            continue;\n        } else if (line[0]) {\n            if (is_variant) {\n                if (!new_variant(c, &variant_info, line, url)) {\n                    ret = AVERROR(ENOMEM);\n                    goto fail;\n                }\n                is_variant = 0;\n            }\n            if (is_segment) {\n                struct segment *seg;\n                if (!pls) {\n                    if (!new_variant(c, 0, url, NULL)) {\n                        ret = AVERROR(ENOMEM);\n                        goto fail;\n                    }\n                    pls = c->playlists[c->n_playlists - 1];\n                }\n                seg = av_malloc(sizeof(struct segment));\n                if (!seg) {\n                    ret = AVERROR(ENOMEM);\n                    goto fail;\n                }\n                if (has_iv) {\n                    memcpy(seg->iv, iv, sizeof(iv));\n                } else {\n                    int seq = pls->start_seq_no + pls->n_segments;\n                    memset(seg->iv, 0, sizeof(seg->iv));\n                    AV_WB32(seg->iv + 12, seq);\n                }\n\n                if (key_type != KEY_NONE) {\n                    ff_make_absolute_url(tmp_str, sizeof(tmp_str), url, key);\n                    seg->key = av_strdup(tmp_str);\n                    if (!seg->key) {\n                        av_free(seg);\n                        ret = AVERROR(ENOMEM);\n                        goto fail;\n                    }\n                } else {\n                    seg->key = NULL;\n                }\n\n                ff_make_absolute_url(tmp_str, sizeof(tmp_str), url, line);\n                seg->url = av_strdup(tmp_str);\n                if (!seg->url) {\n                    av_free(seg->key);\n                    av_free(seg);\n                    ret = AVERROR(ENOMEM);\n                    goto fail;\n                }\n\n                if (duration < 0.001 * AV_TIME_BASE) {\n                    duration = 0.001 * AV_TIME_BASE;\n                }\n                seg->duration = duration;\n                seg->key_type = key_type;\n                dynarray_add(&pls->segments, &pls->n_segments, seg);\n                is_segment = 0;\n\n                seg->size = seg_size;\n                if (seg_size >= 0) {\n                    seg->url_offset = seg_offset;\n                    seg_offset += seg_size;\n                    seg_size = -1;\n                } else {\n                    seg->url_offset = 0;\n                    seg_offset = 0;\n                }\n\n                seg->init_section = cur_init_section;\n            }\n        }\n    }\n    if (pls)\n        pls->last_load_time = av_gettime_relative();\n\nfail:\n    av_free(new_url);\n    if (close_in)\n        avio_close(in);\n    return ret;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149917,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "struct net *get_net_ns_by_id(struct net *net, int id)\n{\n\tstruct net *peer;\n\n\tif (id < 0)\n\t\treturn NULL;\n\n\trcu_read_lock();\n\tspin_lock_bh(&net->nsid_lock);\n\tpeer = idr_find(&net->netns_ids, id);\n\tif (peer)\n\t\tget_net(peer);\n\tspin_unlock_bh(&net->nsid_lock);\n\trcu_read_unlock();\n\n\treturn peer;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149918,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "struct net *get_net_ns_by_id(struct net *net, int id)\n{\n\tstruct net *peer;\n\n\tif (id < 0)\n\t\treturn NULL;\n\n\trcu_read_lock();\n\tspin_lock_bh(&net->nsid_lock);\n\tpeer = idr_find(&net->netns_ids, id);\n\tif (peer)\n\t\tpeer = maybe_get_net(peer);\n\tspin_unlock_bh(&net->nsid_lock);\n\trcu_read_unlock();\n\n\treturn peer;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149919,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int usb_audio_probe(struct usb_interface *intf,\n\t\t\t   const struct usb_device_id *usb_id)\n{\n\tstruct usb_device *dev = interface_to_usbdev(intf);\n\tconst struct snd_usb_audio_quirk *quirk =\n\t\t(const struct snd_usb_audio_quirk *)usb_id->driver_info;\n\tstruct snd_usb_audio *chip;\n\tint i, err;\n\tstruct usb_host_interface *alts;\n\tint ifnum;\n\tu32 id;\n\n\talts = &intf->altsetting[0];\n\tifnum = get_iface_desc(alts)->bInterfaceNumber;\n\tid = USB_ID(le16_to_cpu(dev->descriptor.idVendor),\n\t\t    le16_to_cpu(dev->descriptor.idProduct));\n\tif (get_alias_id(dev, &id))\n\t\tquirk = get_alias_quirk(dev, id);\n\tif (quirk && quirk->ifnum >= 0 && ifnum != quirk->ifnum)\n\t\treturn -ENXIO;\n\n\terr = snd_usb_apply_boot_quirk(dev, intf, quirk, id);\n\tif (err < 0)\n\t\treturn err;\n\n\t/*\n\t * found a config.  now register to ALSA\n\t */\n\n\t/* check whether it's already registered */\n\tchip = NULL;\n\tmutex_lock(&register_mutex);\n\tfor (i = 0; i < SNDRV_CARDS; i++) {\n\t\tif (usb_chip[i] && usb_chip[i]->dev == dev) {\n\t\t\tif (atomic_read(&usb_chip[i]->shutdown)) {\n\t\t\t\tdev_err(&dev->dev, \"USB device is in the shutdown state, cannot create a card instance\\n\");\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto __error;\n\t\t\t}\n\t\t\tchip = usb_chip[i];\n\t\t\tatomic_inc(&chip->active); /* avoid autopm */\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (! chip) {\n\t\t/* it's a fresh one.\n\t\t * now look for an empty slot and create a new card instance\n\t\t */\n\t\tfor (i = 0; i < SNDRV_CARDS; i++)\n\t\t\tif (!usb_chip[i] &&\n\t\t\t    (vid[i] == -1 || vid[i] == USB_ID_VENDOR(id)) &&\n\t\t\t    (pid[i] == -1 || pid[i] == USB_ID_PRODUCT(id))) {\n\t\t\t\tif (enable[i]) {\n\t\t\t\t\terr = snd_usb_audio_create(intf, dev, i, quirk,\n\t\t\t\t\t\t\t\t   id, &chip);\n\t\t\t\t\tif (err < 0)\n\t\t\t\t\t\tgoto __error;\n\t\t\t\t\tchip->pm_intf = intf;\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (vid[i] != -1 || pid[i] != -1) {\n\t\t\t\t\tdev_info(&dev->dev,\n\t\t\t\t\t\t \"device (%04x:%04x) is disabled\\n\",\n\t\t\t\t\t\t USB_ID_VENDOR(id),\n\t\t\t\t\t\t USB_ID_PRODUCT(id));\n\t\t\t\t\terr = -ENOENT;\n\t\t\t\t\tgoto __error;\n\t\t\t\t}\n\t\t\t}\n\t\tif (!chip) {\n\t\t\tdev_err(&dev->dev, \"no available usb audio device\\n\");\n\t\t\terr = -ENODEV;\n\t\t\tgoto __error;\n\t\t}\n\t}\n\tdev_set_drvdata(&dev->dev, chip);\n\n\t/*\n\t * For devices with more than one control interface, we assume the\n\t * first contains the audio controls. We might need a more specific\n\t * check here in the future.\n\t */\n\tif (!chip->ctrl_intf)\n\t\tchip->ctrl_intf = alts;\n\n\tchip->txfr_quirk = 0;\n\terr = 1; /* continue */\n\tif (quirk && quirk->ifnum != QUIRK_NO_INTERFACE) {\n\t\t/* need some special handlings */\n\t\terr = snd_usb_create_quirk(chip, intf, &usb_audio_driver, quirk);\n\t\tif (err < 0)\n\t\t\tgoto __error;\n\t}\n\n\tif (err > 0) {\n\t\t/* create normal USB audio interfaces */\n\t\terr = snd_usb_create_streams(chip, ifnum);\n\t\tif (err < 0)\n\t\t\tgoto __error;\n\t\terr = snd_usb_create_mixer(chip, ifnum, ignore_ctl_error);\n\t\tif (err < 0)\n\t\t\tgoto __error;\n\t}\n\n\t/* we are allowed to call snd_card_register() many times */\n\terr = snd_card_register(chip->card);\n\tif (err < 0)\n\t\tgoto __error;\n\n\tusb_chip[chip->index] = chip;\n\tchip->num_interfaces++;\n\tusb_set_intfdata(intf, chip);\n\tatomic_dec(&chip->active);\n\tmutex_unlock(&register_mutex);\n\treturn 0;\n\n __error:\n\tif (chip) {\n\t\tif (!chip->num_interfaces)\n\t\t\tsnd_card_free(chip->card);\n\t\tatomic_dec(&chip->active);\n\t}\n\tmutex_unlock(&register_mutex);\n\treturn err;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149920,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int usb_audio_probe(struct usb_interface *intf,\n\t\t\t   const struct usb_device_id *usb_id)\n{\n\tstruct usb_device *dev = interface_to_usbdev(intf);\n\tconst struct snd_usb_audio_quirk *quirk =\n\t\t(const struct snd_usb_audio_quirk *)usb_id->driver_info;\n\tstruct snd_usb_audio *chip;\n\tint i, err;\n\tstruct usb_host_interface *alts;\n\tint ifnum;\n\tu32 id;\n\n\talts = &intf->altsetting[0];\n\tifnum = get_iface_desc(alts)->bInterfaceNumber;\n\tid = USB_ID(le16_to_cpu(dev->descriptor.idVendor),\n\t\t    le16_to_cpu(dev->descriptor.idProduct));\n\tif (get_alias_id(dev, &id))\n\t\tquirk = get_alias_quirk(dev, id);\n\tif (quirk && quirk->ifnum >= 0 && ifnum != quirk->ifnum)\n\t\treturn -ENXIO;\n\n\terr = snd_usb_apply_boot_quirk(dev, intf, quirk, id);\n\tif (err < 0)\n\t\treturn err;\n\n\t/*\n\t * found a config.  now register to ALSA\n\t */\n\n\t/* check whether it's already registered */\n\tchip = NULL;\n\tmutex_lock(&register_mutex);\n\tfor (i = 0; i < SNDRV_CARDS; i++) {\n\t\tif (usb_chip[i] && usb_chip[i]->dev == dev) {\n\t\t\tif (atomic_read(&usb_chip[i]->shutdown)) {\n\t\t\t\tdev_err(&dev->dev, \"USB device is in the shutdown state, cannot create a card instance\\n\");\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto __error;\n\t\t\t}\n\t\t\tchip = usb_chip[i];\n\t\t\tatomic_inc(&chip->active); /* avoid autopm */\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (! chip) {\n\t\t/* it's a fresh one.\n\t\t * now look for an empty slot and create a new card instance\n\t\t */\n\t\tfor (i = 0; i < SNDRV_CARDS; i++)\n\t\t\tif (!usb_chip[i] &&\n\t\t\t    (vid[i] == -1 || vid[i] == USB_ID_VENDOR(id)) &&\n\t\t\t    (pid[i] == -1 || pid[i] == USB_ID_PRODUCT(id))) {\n\t\t\t\tif (enable[i]) {\n\t\t\t\t\terr = snd_usb_audio_create(intf, dev, i, quirk,\n\t\t\t\t\t\t\t\t   id, &chip);\n\t\t\t\t\tif (err < 0)\n\t\t\t\t\t\tgoto __error;\n\t\t\t\t\tchip->pm_intf = intf;\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (vid[i] != -1 || pid[i] != -1) {\n\t\t\t\t\tdev_info(&dev->dev,\n\t\t\t\t\t\t \"device (%04x:%04x) is disabled\\n\",\n\t\t\t\t\t\t USB_ID_VENDOR(id),\n\t\t\t\t\t\t USB_ID_PRODUCT(id));\n\t\t\t\t\terr = -ENOENT;\n\t\t\t\t\tgoto __error;\n\t\t\t\t}\n\t\t\t}\n\t\tif (!chip) {\n\t\t\tdev_err(&dev->dev, \"no available usb audio device\\n\");\n\t\t\terr = -ENODEV;\n\t\t\tgoto __error;\n\t\t}\n\t}\n\tdev_set_drvdata(&dev->dev, chip);\n\n\t/*\n\t * For devices with more than one control interface, we assume the\n\t * first contains the audio controls. We might need a more specific\n\t * check here in the future.\n\t */\n\tif (!chip->ctrl_intf)\n\t\tchip->ctrl_intf = alts;\n\n\tchip->txfr_quirk = 0;\n\terr = 1; /* continue */\n\tif (quirk && quirk->ifnum != QUIRK_NO_INTERFACE) {\n\t\t/* need some special handlings */\n\t\terr = snd_usb_create_quirk(chip, intf, &usb_audio_driver, quirk);\n\t\tif (err < 0)\n\t\t\tgoto __error;\n\t}\n\n\tif (err > 0) {\n\t\t/* create normal USB audio interfaces */\n\t\terr = snd_usb_create_streams(chip, ifnum);\n\t\tif (err < 0)\n\t\t\tgoto __error;\n\t\terr = snd_usb_create_mixer(chip, ifnum, ignore_ctl_error);\n\t\tif (err < 0)\n\t\t\tgoto __error;\n\t}\n\n\t/* we are allowed to call snd_card_register() many times */\n\terr = snd_card_register(chip->card);\n\tif (err < 0)\n\t\tgoto __error;\n\n\tusb_chip[chip->index] = chip;\n\tchip->num_interfaces++;\n\tusb_set_intfdata(intf, chip);\n\tatomic_dec(&chip->active);\n\tmutex_unlock(&register_mutex);\n\treturn 0;\n\n __error:\n\tif (chip) {\n\t\t/* chip->active is inside the chip->card object,\n\t\t * decrement before memory is possibly returned.\n\t\t */\n\t\tatomic_dec(&chip->active);\n\t\tif (!chip->num_interfaces)\n\t\t\tsnd_card_free(chip->card);\n\t}\n\tmutex_unlock(&register_mutex);\n\treturn err;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149921,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "GF_Err audio_sample_entry_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MPEGAudioSampleEntryBox *ptr;\n\tchar *data;\n\tu8 a, b, c, d;\n\tu32 i, size, v, nb_alnum;\n\tGF_Err e;\n\tu64 pos, start;\n\n\tptr = (GF_MPEGAudioSampleEntryBox *)s;\n\n\tstart = gf_bs_get_position(bs);\n\tgf_bs_seek(bs, start + 8);\n\tv = gf_bs_read_u16(bs);\n\tif (v)\n\t\tptr->is_qtff = 1;\n\n\t//try to disambiguate QTFF v1 and MP4 v1 audio sample entries ...\n\tif (v==1) {\n\t\t//go to end of ISOM audio sample entry, skip 4 byte (box size field), read 4 bytes (box type) and check if this looks like a box\n\t\tgf_bs_seek(bs, start + 8 + 20  + 4);\n\t\ta = gf_bs_read_u8(bs);\n\t\tb = gf_bs_read_u8(bs);\n\t\tc = gf_bs_read_u8(bs);\n\t\td = gf_bs_read_u8(bs);\n\t\tnb_alnum = 0;\n\t\tif (isalnum(a)) nb_alnum++;\n\t\tif (isalnum(b)) nb_alnum++;\n\t\tif (isalnum(c)) nb_alnum++;\n\t\tif (isalnum(d)) nb_alnum++;\n\t\tif (nb_alnum>2) ptr->is_qtff = 0;\n\t}\n\n\tgf_bs_seek(bs, start);\n\te = gf_isom_audio_sample_entry_read((GF_AudioSampleEntryBox*)s, bs);\n\tif (e) return e;\n\tpos = gf_bs_get_position(bs);\n\tsize = (u32) s->size;\n\n\t//when cookie is set on bs, always convert qtff-style mp4a to isobmff-style\n\t//since the conversion is done in addBox and we don't have the bitstream there (arg...), flag the box\n \tif (gf_bs_get_cookie(bs)) {\n \t\tptr->is_qtff |= 1<<16;\n \t}\n\n\te = gf_isom_box_array_read(s, bs, audio_sample_entry_AddBox);\n\tif (!e) return GF_OK;\n\tif (size<8) return GF_ISOM_INVALID_FILE;\n\n\t/*hack for some weird files (possibly recorded with live.com tools, needs further investigations)*/\n\tgf_bs_seek(bs, pos);\n\tdata = (char*)gf_malloc(sizeof(char) * size);\n\tgf_bs_read_data(bs, data, size);\n\tfor (i=0; i<size-8; i++) {\n\t\tif (GF_4CC((u32)data[i+4], (u8)data[i+5], (u8)data[i+6], (u8)data[i+7]) == GF_ISOM_BOX_TYPE_ESDS) {\n\t\t\tGF_BitStream *mybs = gf_bs_new(data + i, size - i, GF_BITSTREAM_READ);\n\t\t\tif (ptr->esd) {\n\t\t\t\tgf_isom_box_del((GF_Box *)ptr->esd);\n\t\t\t\tptr->esd=NULL;\n\t\t\t}\n\n\t\t\te = gf_isom_box_parse((GF_Box **)&ptr->esd, mybs);\n\n\t\t\tif (e==GF_OK) {\n\t\t\t\tgf_isom_box_add_for_dump_mode((GF_Box*)ptr, (GF_Box*)ptr->esd);\n\t\t\t} else if (ptr->esd) {\n\t\t\t\tgf_isom_box_del((GF_Box *)ptr->esd);\n\t\t\t\tptr->esd=NULL;\n\t\t\t}\n\n\t\t\tgf_bs_del(mybs);\n\t\t\tbreak;\n\t\t}\n\t}\n\tgf_free(data);\n\treturn e;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149922,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "GF_Err audio_sample_entry_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MPEGAudioSampleEntryBox *ptr;\n\tchar *data;\n\tu8 a, b, c, d;\n\tu32 i, size, v, nb_alnum;\n\tGF_Err e;\n\tu64 pos, start;\n\n\tptr = (GF_MPEGAudioSampleEntryBox *)s;\n\n\tstart = gf_bs_get_position(bs);\n\tgf_bs_seek(bs, start + 8);\n\tv = gf_bs_read_u16(bs);\n\tif (v)\n\t\tptr->is_qtff = 1;\n\n\t//try to disambiguate QTFF v1 and MP4 v1 audio sample entries ...\n\tif (v==1) {\n\t\t//go to end of ISOM audio sample entry, skip 4 byte (box size field), read 4 bytes (box type) and check if this looks like a box\n\t\tgf_bs_seek(bs, start + 8 + 20  + 4);\n\t\ta = gf_bs_read_u8(bs);\n\t\tb = gf_bs_read_u8(bs);\n\t\tc = gf_bs_read_u8(bs);\n\t\td = gf_bs_read_u8(bs);\n\t\tnb_alnum = 0;\n\t\tif (isalnum(a)) nb_alnum++;\n\t\tif (isalnum(b)) nb_alnum++;\n\t\tif (isalnum(c)) nb_alnum++;\n\t\tif (isalnum(d)) nb_alnum++;\n\t\tif (nb_alnum>2) ptr->is_qtff = 0;\n\t}\n\n\tgf_bs_seek(bs, start);\n\te = gf_isom_audio_sample_entry_read((GF_AudioSampleEntryBox*)s, bs);\n\tif (e) return e;\n\tpos = gf_bs_get_position(bs);\n\tsize = (u32) s->size;\n\n\t//when cookie is set on bs, always convert qtff-style mp4a to isobmff-style\n\t//since the conversion is done in addBox and we don't have the bitstream there (arg...), flag the box\n \tif (gf_bs_get_cookie(bs)) {\n \t\tptr->is_qtff |= 1<<16;\n \t}\n\n\te = gf_isom_box_array_read(s, bs, audio_sample_entry_AddBox);\n\tif (!e) return GF_OK;\n\tif (size<8) return GF_ISOM_INVALID_FILE;\n\n\t/*hack for some weird files (possibly recorded with live.com tools, needs further investigations)*/\n\tgf_bs_seek(bs, pos);\n\tdata = (char*)gf_malloc(sizeof(char) * size);\n\tgf_bs_read_data(bs, data, size);\n\tfor (i=0; i<size-8; i++) {\n\t\tif (GF_4CC((u32)data[i+4], (u8)data[i+5], (u8)data[i+6], (u8)data[i+7]) == GF_ISOM_BOX_TYPE_ESDS) {\n\t\t\textern Bool use_dump_mode;\n\t\t\tGF_BitStream *mybs = gf_bs_new(data + i, size - i, GF_BITSTREAM_READ);\n\t\t\tif (ptr->esd) {\n\t\t\t\tif (!use_dump_mode) gf_isom_box_del((GF_Box *)ptr->esd);\n\t\t\t\tptr->esd=NULL;\n\t\t\t}\n\n\t\t\te = gf_isom_box_parse((GF_Box **)&ptr->esd, mybs);\n\n\t\t\tif (e==GF_OK) {\n\t\t\t\tgf_isom_box_add_for_dump_mode((GF_Box*)ptr, (GF_Box*)ptr->esd);\n\t\t\t} else if (ptr->esd) {\n\t\t\t\tgf_isom_box_del((GF_Box *)ptr->esd);\n\t\t\t\tptr->esd=NULL;\n\t\t\t}\n\n\t\t\tgf_bs_del(mybs);\n\t\t\tbreak;\n\t\t}\n\t}\n\tgf_free(data);\n\treturn e;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149923,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static void ffs_user_copy_worker(struct work_struct *work)\n{\n\tstruct ffs_io_data *io_data = container_of(work, struct ffs_io_data,\n\t\t\t\t\t\t   work);\n\tint ret = io_data->req->status ? io_data->req->status :\n\t\t\t\t\t io_data->req->actual;\n\n\tif (io_data->read && ret > 0) {\n\t\tuse_mm(io_data->mm);\n\t\tret = copy_to_iter(io_data->buf, ret, &io_data->data);\n\t\tif (iov_iter_count(&io_data->data))\n\t\t\tret = -EFAULT;\n\t\tunuse_mm(io_data->mm);\n\t}\n\n\tio_data->kiocb->ki_complete(io_data->kiocb, ret, ret);\n\n\tif (io_data->ffs->ffs_eventfd &&\n\t    !(io_data->kiocb->ki_flags & IOCB_EVENTFD))\n\t\teventfd_signal(io_data->ffs->ffs_eventfd, 1);\n\n\tusb_ep_free_request(io_data->ep, io_data->req);\n\n\tio_data->kiocb->private = NULL;\n\tif (io_data->read)\n\t\tkfree(io_data->to_free);\n\tkfree(io_data->buf);\n\tkfree(io_data);\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149924,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static void ffs_user_copy_worker(struct work_struct *work)\n{\n\tstruct ffs_io_data *io_data = container_of(work, struct ffs_io_data,\n\t\t\t\t\t\t   work);\n\tint ret = io_data->req->status ? io_data->req->status :\n\t\t\t\t\t io_data->req->actual;\n\tbool kiocb_has_eventfd = io_data->kiocb->ki_flags & IOCB_EVENTFD;\n\n\tif (io_data->read && ret > 0) {\n\t\tuse_mm(io_data->mm);\n\t\tret = copy_to_iter(io_data->buf, ret, &io_data->data);\n\t\tif (iov_iter_count(&io_data->data))\n\t\t\tret = -EFAULT;\n\t\tunuse_mm(io_data->mm);\n\t}\n\n\tio_data->kiocb->ki_complete(io_data->kiocb, ret, ret);\n\n\tif (io_data->ffs->ffs_eventfd && !kiocb_has_eventfd)\n\t\teventfd_signal(io_data->ffs->ffs_eventfd, 1);\n\n\tusb_ep_free_request(io_data->ep, io_data->req);\n\n\tif (io_data->read)\n\t\tkfree(io_data->to_free);\n\tkfree(io_data->buf);\n\tkfree(io_data);\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149925,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static void ndpi_reset_packet_line_info(struct ndpi_packet_struct *packet) {\n  packet->parsed_lines = 0, packet->empty_line_position_set = 0, packet->host_line.ptr = NULL,\n    packet->host_line.len = 0, packet->referer_line.ptr = NULL, packet->referer_line.len = 0,\n    packet->content_line.ptr = NULL, packet->content_line.len = 0, packet->accept_line.ptr = NULL,\n    packet->accept_line.len = 0, packet->user_agent_line.ptr = NULL, packet->user_agent_line.len = 0,\n    packet->http_url_name.ptr = NULL, packet->http_url_name.len = 0, packet->http_encoding.ptr = NULL,\n    packet->http_encoding.len = 0, packet->http_transfer_encoding.ptr = NULL, packet->http_transfer_encoding.len = 0,\n    packet->http_contentlen.ptr = NULL, packet->http_contentlen.len = 0, packet->http_cookie.ptr = NULL,\n    packet->http_cookie.len = 0, packet->http_origin.len = 0, packet->http_origin.ptr = NULL,\n    packet->http_x_session_type.ptr = NULL, packet->http_x_session_type.len = 0, packet->server_line.ptr = NULL,\n    packet->server_line.len = 0, packet->http_method.ptr = NULL, packet->http_method.len = 0,\n    packet->http_response.ptr = NULL, packet->http_response.len = 0, packet->http_num_headers = 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149926,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static void ndpi_reset_packet_line_info(struct ndpi_packet_struct *packet) {\n  packet->parsed_lines = 0, packet->empty_line_position_set = 0, packet->host_line.ptr = NULL,\n    packet->host_line.len = 0, packet->referer_line.ptr = NULL, packet->referer_line.len = 0,\n    packet->content_line.ptr = NULL, packet->content_line.len = 0, packet->accept_line.ptr = NULL,\n    packet->accept_line.len = 0, packet->user_agent_line.ptr = NULL, packet->user_agent_line.len = 0,\n    packet->http_url_name.ptr = NULL, packet->http_url_name.len = 0, packet->http_encoding.ptr = NULL,\n    packet->http_encoding.len = 0, packet->http_transfer_encoding.ptr = NULL, packet->http_transfer_encoding.len = 0,\n    packet->http_contentlen.ptr = NULL, packet->http_contentlen.len = 0, packet->content_disposition_line.ptr = NULL,\n    packet->content_disposition_line.len = 0, packet->http_cookie.ptr = NULL,\n    packet->http_cookie.len = 0, packet->http_origin.len = 0, packet->http_origin.ptr = NULL,\n    packet->http_x_session_type.ptr = NULL, packet->http_x_session_type.len = 0, packet->server_line.ptr = NULL,\n    packet->server_line.len = 0, packet->http_method.ptr = NULL, packet->http_method.len = 0,\n    packet->http_response.ptr = NULL, packet->http_response.len = 0, packet->http_num_headers = 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149927,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int snd_seq_device_dev_free(struct snd_device *device)\n{\n\tstruct snd_seq_device *dev = device->device_data;\n\n\tput_device(&dev->dev);\n\treturn 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149928,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int snd_seq_device_dev_free(struct snd_device *device)\n{\n\tstruct snd_seq_device *dev = device->device_data;\n\n\tcancel_autoload_drivers();\n\tput_device(&dev->dev);\n\treturn 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149929,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "int __mdiobus_register(struct mii_bus *bus, struct module *owner)\n{\n\tstruct mdio_device *mdiodev;\n\tint i, err;\n\tstruct gpio_desc *gpiod;\n\n\tif (NULL == bus || NULL == bus->name ||\n\t    NULL == bus->read || NULL == bus->write)\n\t\treturn -EINVAL;\n\n\tBUG_ON(bus->state != MDIOBUS_ALLOCATED &&\n\t       bus->state != MDIOBUS_UNREGISTERED);\n\n\tbus->owner = owner;\n\tbus->dev.parent = bus->parent;\n\tbus->dev.class = &mdio_bus_class;\n\tbus->dev.groups = NULL;\n\tdev_set_name(&bus->dev, \"%s\", bus->id);\n\n\terr = device_register(&bus->dev);\n\tif (err) {\n\t\tpr_err(\"mii_bus %s failed to register\\n\", bus->id);\n\t\tput_device(&bus->dev);\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_init(&bus->mdio_lock);\n\n\t/* de-assert bus level PHY GPIO reset */\n\tgpiod = devm_gpiod_get_optional(&bus->dev, \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(gpiod)) {\n\t\tdev_err(&bus->dev, \"mii_bus %s couldn't get reset GPIO\\n\",\n\t\t\tbus->id);\n\t\tdevice_del(&bus->dev);\n\t\treturn PTR_ERR(gpiod);\n\t} else\tif (gpiod) {\n\t\tbus->reset_gpiod = gpiod;\n\n\t\tgpiod_set_value_cansleep(gpiod, 1);\n\t\tudelay(bus->reset_delay_us);\n\t\tgpiod_set_value_cansleep(gpiod, 0);\n\t}\n\n\tif (bus->reset)\n\t\tbus->reset(bus);\n\n\tfor (i = 0; i < PHY_MAX_ADDR; i++) {\n\t\tif ((bus->phy_mask & (1 << i)) == 0) {\n\t\t\tstruct phy_device *phydev;\n\n\t\t\tphydev = mdiobus_scan(bus, i);\n\t\t\tif (IS_ERR(phydev) && (PTR_ERR(phydev) != -ENODEV)) {\n\t\t\t\terr = PTR_ERR(phydev);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\tmdiobus_setup_mdiodev_from_board_info(bus, mdiobus_create_device);\n\n\tbus->state = MDIOBUS_REGISTERED;\n\tpr_info(\"%s: probed\\n\", bus->name);\n\treturn 0;\n\nerror:\n\twhile (--i >= 0) {\n\t\tmdiodev = bus->mdio_map[i];\n\t\tif (!mdiodev)\n\t\t\tcontinue;\n\n\t\tmdiodev->device_remove(mdiodev);\n\t\tmdiodev->device_free(mdiodev);\n\t}\n\n\t/* Put PHYs in RESET to save power */\n\tif (bus->reset_gpiod)\n\t\tgpiod_set_value_cansleep(bus->reset_gpiod, 1);\n\n\tdevice_del(&bus->dev);\n\treturn err;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149930,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "int __mdiobus_register(struct mii_bus *bus, struct module *owner)\n{\n\tstruct mdio_device *mdiodev;\n\tint i, err;\n\tstruct gpio_desc *gpiod;\n\n\tif (NULL == bus || NULL == bus->name ||\n\t    NULL == bus->read || NULL == bus->write)\n\t\treturn -EINVAL;\n\n\tBUG_ON(bus->state != MDIOBUS_ALLOCATED &&\n\t       bus->state != MDIOBUS_UNREGISTERED);\n\n\tbus->owner = owner;\n\tbus->dev.parent = bus->parent;\n\tbus->dev.class = &mdio_bus_class;\n\tbus->dev.groups = NULL;\n\tdev_set_name(&bus->dev, \"%s\", bus->id);\n\n\terr = device_register(&bus->dev);\n\tif (err) {\n\t\tpr_err(\"mii_bus %s failed to register\\n\", bus->id);\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_init(&bus->mdio_lock);\n\n\t/* de-assert bus level PHY GPIO reset */\n\tgpiod = devm_gpiod_get_optional(&bus->dev, \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(gpiod)) {\n\t\tdev_err(&bus->dev, \"mii_bus %s couldn't get reset GPIO\\n\",\n\t\t\tbus->id);\n\t\tdevice_del(&bus->dev);\n\t\treturn PTR_ERR(gpiod);\n\t} else\tif (gpiod) {\n\t\tbus->reset_gpiod = gpiod;\n\n\t\tgpiod_set_value_cansleep(gpiod, 1);\n\t\tudelay(bus->reset_delay_us);\n\t\tgpiod_set_value_cansleep(gpiod, 0);\n\t}\n\n\tif (bus->reset)\n\t\tbus->reset(bus);\n\n\tfor (i = 0; i < PHY_MAX_ADDR; i++) {\n\t\tif ((bus->phy_mask & (1 << i)) == 0) {\n\t\t\tstruct phy_device *phydev;\n\n\t\t\tphydev = mdiobus_scan(bus, i);\n\t\t\tif (IS_ERR(phydev) && (PTR_ERR(phydev) != -ENODEV)) {\n\t\t\t\terr = PTR_ERR(phydev);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\tmdiobus_setup_mdiodev_from_board_info(bus, mdiobus_create_device);\n\n\tbus->state = MDIOBUS_REGISTERED;\n\tpr_info(\"%s: probed\\n\", bus->name);\n\treturn 0;\n\nerror:\n\twhile (--i >= 0) {\n\t\tmdiodev = bus->mdio_map[i];\n\t\tif (!mdiodev)\n\t\t\tcontinue;\n\n\t\tmdiodev->device_remove(mdiodev);\n\t\tmdiodev->device_free(mdiodev);\n\t}\n\n\t/* Put PHYs in RESET to save power */\n\tif (bus->reset_gpiod)\n\t\tgpiod_set_value_cansleep(bus->reset_gpiod, 1);\n\n\tdevice_del(&bus->dev);\n\treturn err;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149931,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "add_range(fz_context *ctx, pdf_cmap *cmap, unsigned int low, unsigned int high, unsigned int out, int check_for_overlap, int many)\n{\n\tint current;\n\tcmap_splay *tree;\n\n\tif (low > high)\n\t{\n\t\tfz_warn(ctx, \"range limits out of range in cmap %s\", cmap->cmap_name);\n\t\treturn;\n\t}\n\n\ttree = cmap->tree;\n\n\tif (cmap->tlen)\n\t{\n\t\tunsigned int move = cmap->ttop;\n\t\tunsigned int gt = EMPTY;\n\t\tunsigned int lt = EMPTY;\n\t\tif (check_for_overlap)\n\t\t{\n\t\t\t/* Check for collision with the current node */\n\t\t\tdo\n\t\t\t{\n\t\t\t\tcurrent = move;\n\t\t\t\t/* Cases we might meet:\n\t\t\t\t * tree[i]:        <----->\n\t\t\t\t * case 0:     <->\n\t\t\t\t * case 1:     <------->\n\t\t\t\t * case 2:     <------------->\n\t\t\t\t * case 3:           <->\n\t\t\t\t * case 4:           <------->\n\t\t\t\t * case 5:                 <->\n\t\t\t\t */\n\t\t\t\tif (low <= tree[current].low && tree[current].low <= high)\n\t\t\t\t{\n\t\t\t\t\t/* case 1, reduces to case 0 */\n\t\t\t\t\t/* or case 2, deleting the node */\n\t\t\t\t\ttree[current].out += high + 1 - tree[current].low;\n\t\t\t\t\ttree[current].low = high + 1;\n\t\t\t\t\tif (tree[current].low > tree[current].high)\n\t\t\t\t\t{\n\t\t\t\t\t\tmove = delete_node(cmap, current);\n\t\t\t\t\t\tcurrent = EMPTY;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (low <= tree[current].high && tree[current].high <= high)\n\t\t\t\t{\n\t\t\t\t\t/* case 4, reduces to case 5 */\n\t\t\t\t\ttree[current].high = low - 1;\n\t\t\t\t\tassert(tree[current].low <= tree[current].high);\n\t\t\t\t}\n\t\t\t\telse if (tree[current].low < low && high < tree[current].high)\n\t\t\t\t{\n\t\t\t\t\t/* case 3, reduces to case 5 */\n                                        int new_high = tree[current].high;\n                                        tree[current].high = low-1;\n                                        add_range(ctx, cmap, high+1, new_high, tree[current].out + high + 1 - tree[current].low, 0, tree[current].many);\n                                }\n                                /* Now look for where to move to next (left for case 0, right for case 5) */\n                                if (tree[current].low > high) {\n\t\t\t\t\tgt = current;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmove = tree[current].right;\n\t\t\t\t\tlt = current;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (move != EMPTY);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdo\n\t\t\t{\n\t\t\t\tcurrent = move;\n\t\t\t\tif (tree[current].low > high)\n\t\t\t\t{\n\t\t\t\t\tmove = tree[current].left;\n\t\t\t\t\tgt = current;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmove = tree[current].right;\n\t\t\t\t\tlt = current;\n\t\t\t\t}\n\t\t\t} while (move != EMPTY);\n\t\t}\n\t\t/* current is now the node to which we would be adding the new node */\n\t\t/* lt is the last node we traversed which is lt the new node. */\n\t\t/* gt is the last node we traversed which is gt the new node. */\n\n\t\tif (!many)\n\t\t{\n\t\t\t/* Check for the 'merge' cases. */\n\t\t\tif (lt != EMPTY && !tree[lt].many && tree[lt].high == low-1 && tree[lt].out - tree[lt].low == out - low)\n\t\t\t{\n\t\t\t\ttree[lt].high = high;\n\t\t\t\tif (gt != EMPTY && !tree[gt].many && tree[gt].low == high+1 && tree[gt].out - tree[gt].low == out - low)\n\t\t\t\t{\n\t\t\t\t\ttree[lt].high = tree[gt].high;\n\t\t\t\t\tdelete_node(cmap, gt);\n\t\t\t\t}\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tif (gt != EMPTY && !tree[gt].many && tree[gt].low == high+1 && tree[gt].out - tree[gt].low == out - low)\n\t\t\t{\n\t\t\t\ttree[gt].low = low;\n\t\t\t\ttree[gt].out = out;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t\tcurrent = EMPTY;\n\n\tif (cmap->tlen == cmap->tcap)\n\t{\n\t\tint new_cap = cmap->tcap ? cmap->tcap * 2 : 256;\n\t\ttree = cmap->tree = fz_resize_array(ctx, cmap->tree, new_cap, sizeof *cmap->tree);\n\t\tcmap->tcap = new_cap;\n\t}\n\ttree[cmap->tlen].low = low;\n\ttree[cmap->tlen].high = high;\n\ttree[cmap->tlen].out = out;\n\ttree[cmap->tlen].parent = current;\n\ttree[cmap->tlen].left = EMPTY;\n\ttree[cmap->tlen].right = EMPTY;\n\ttree[cmap->tlen].many = many;\n\tcmap->tlen++;\n\tif (current == EMPTY)\n\t\tcmap->ttop = 0;\n\telse if (tree[current].low > high)\n\t\ttree[current].left = cmap->tlen-1;\n\telse\n\t{\n\t\tassert(tree[current].high < low);\n\t\ttree[current].right = cmap->tlen-1;\n\t}\n\tmove_to_root(tree, cmap->tlen-1);\n\tcmap->ttop = cmap->tlen-1;\nexit:\n\t{}\n#ifdef CHECK_SPLAY\n\tcheck_splay(cmap->tree, cmap->ttop, 0);\n#endif\n#ifdef DUMP_SPLAY\n\tdump_splay(cmap->tree, cmap->ttop, 0, \"\");\n#endif\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141349,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "add_range(fz_context *ctx, pdf_cmap *cmap, unsigned int low, unsigned int high, unsigned int out, int check_for_overlap, int many)\n{\n\tint current;\n\tcmap_splay *tree;\n\n\tif (low > high)\n\t{\n\t\tfz_warn(ctx, \"range limits out of range in cmap %s\", cmap->cmap_name);\n\t\treturn;\n\t}\n\n\ttree = cmap->tree;\n\n\tif (cmap->tlen)\n\t{\n\t\tunsigned int move = cmap->ttop;\n\t\tunsigned int gt = EMPTY;\n\t\tunsigned int lt = EMPTY;\n\t\tif (check_for_overlap)\n\t\t{\n\t\t\t/* Check for collision with the current node */\n\t\t\tdo\n\t\t\t{\n\t\t\t\tcurrent = move;\n\t\t\t\t/* Cases we might meet:\n\t\t\t\t * tree[i]:        <----->\n\t\t\t\t * case 0:     <->\n\t\t\t\t * case 1:     <------->\n\t\t\t\t * case 2:     <------------->\n\t\t\t\t * case 3:           <->\n\t\t\t\t * case 4:           <------->\n\t\t\t\t * case 5:                 <->\n\t\t\t\t */\n\t\t\t\tif (low <= tree[current].low && tree[current].low <= high)\n\t\t\t\t{\n\t\t\t\t\t/* case 1, reduces to case 0 */\n\t\t\t\t\t/* or case 2, deleting the node */\n\t\t\t\t\ttree[current].out += high + 1 - tree[current].low;\n\t\t\t\t\ttree[current].low = high + 1;\n\t\t\t\t\tif (tree[current].low > tree[current].high)\n\t\t\t\t\t{\n\t\t\t\t\t\tmove = delete_node(cmap, current);\n\t\t\t\t\t\tcurrent = EMPTY;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (low <= tree[current].high && tree[current].high <= high)\n\t\t\t\t{\n\t\t\t\t\t/* case 4, reduces to case 5 */\n\t\t\t\t\ttree[current].high = low - 1;\n\t\t\t\t\tassert(tree[current].low <= tree[current].high);\n\t\t\t\t}\n\t\t\t\telse if (tree[current].low < low && high < tree[current].high)\n\t\t\t\t{\n\t\t\t\t\t/* case 3, reduces to case 5 */\n                                        int new_high = tree[current].high;\n                                        tree[current].high = low-1;\n                                        add_range(ctx, cmap, high+1, new_high, tree[current].out + high + 1 - tree[current].low, 0, tree[current].many);\n                                       tree = cmap->tree;\n                                }\n                                /* Now look for where to move to next (left for case 0, right for case 5) */\n                                if (tree[current].low > high) {\n\t\t\t\t\tgt = current;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmove = tree[current].right;\n\t\t\t\t\tlt = current;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (move != EMPTY);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdo\n\t\t\t{\n\t\t\t\tcurrent = move;\n\t\t\t\tif (tree[current].low > high)\n\t\t\t\t{\n\t\t\t\t\tmove = tree[current].left;\n\t\t\t\t\tgt = current;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmove = tree[current].right;\n\t\t\t\t\tlt = current;\n\t\t\t\t}\n\t\t\t} while (move != EMPTY);\n\t\t}\n\t\t/* current is now the node to which we would be adding the new node */\n\t\t/* lt is the last node we traversed which is lt the new node. */\n\t\t/* gt is the last node we traversed which is gt the new node. */\n\n\t\tif (!many)\n\t\t{\n\t\t\t/* Check for the 'merge' cases. */\n\t\t\tif (lt != EMPTY && !tree[lt].many && tree[lt].high == low-1 && tree[lt].out - tree[lt].low == out - low)\n\t\t\t{\n\t\t\t\ttree[lt].high = high;\n\t\t\t\tif (gt != EMPTY && !tree[gt].many && tree[gt].low == high+1 && tree[gt].out - tree[gt].low == out - low)\n\t\t\t\t{\n\t\t\t\t\ttree[lt].high = tree[gt].high;\n\t\t\t\t\tdelete_node(cmap, gt);\n\t\t\t\t}\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tif (gt != EMPTY && !tree[gt].many && tree[gt].low == high+1 && tree[gt].out - tree[gt].low == out - low)\n\t\t\t{\n\t\t\t\ttree[gt].low = low;\n\t\t\t\ttree[gt].out = out;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t\tcurrent = EMPTY;\n\n\tif (cmap->tlen == cmap->tcap)\n\t{\n\t\tint new_cap = cmap->tcap ? cmap->tcap * 2 : 256;\n\t\ttree = cmap->tree = fz_resize_array(ctx, cmap->tree, new_cap, sizeof *cmap->tree);\n\t\tcmap->tcap = new_cap;\n\t}\n\ttree[cmap->tlen].low = low;\n\ttree[cmap->tlen].high = high;\n\ttree[cmap->tlen].out = out;\n\ttree[cmap->tlen].parent = current;\n\ttree[cmap->tlen].left = EMPTY;\n\ttree[cmap->tlen].right = EMPTY;\n\ttree[cmap->tlen].many = many;\n\tcmap->tlen++;\n\tif (current == EMPTY)\n\t\tcmap->ttop = 0;\n\telse if (tree[current].low > high)\n\t\ttree[current].left = cmap->tlen-1;\n\telse\n\t{\n\t\tassert(tree[current].high < low);\n\t\ttree[current].right = cmap->tlen-1;\n\t}\n\tmove_to_root(tree, cmap->tlen-1);\n\tcmap->ttop = cmap->tlen-1;\nexit:\n\t{}\n#ifdef CHECK_SPLAY\n\tcheck_splay(cmap->tree, cmap->ttop, 0);\n#endif\n#ifdef DUMP_SPLAY\n\tdump_splay(cmap->tree, cmap->ttop, 0, \"\");\n#endif\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141350,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "add_range(fz_context *ctx, pdf_cmap *cmap, unsigned int low, unsigned int high, unsigned int out, int check_for_overlap, int many)\n{\n\tint current;\n\tcmap_splay *tree;\n\n\tif (low > high)\n\t{\n\t\tfz_warn(ctx, \"range limits out of range in cmap %s\", cmap->cmap_name);\n\t\treturn;\n\t}\n\n\ttree = cmap->tree;\n\n\tif (cmap->tlen)\n\t{\n\t\tunsigned int move = cmap->ttop;\n\t\tunsigned int gt = EMPTY;\n\t\tunsigned int lt = EMPTY;\n\t\tif (check_for_overlap)\n\t\t{\n\t\t\t/* Check for collision with the current node */\n\t\t\tdo\n\t\t\t{\n\t\t\t\tcurrent = move;\n\t\t\t\t/* Cases we might meet:\n\t\t\t\t * tree[i]:        <----->\n\t\t\t\t * case 0:     <->\n\t\t\t\t * case 1:     <------->\n\t\t\t\t * case 2:     <------------->\n\t\t\t\t * case 3:           <->\n\t\t\t\t * case 4:           <------->\n\t\t\t\t * case 5:                 <->\n\t\t\t\t */\n\t\t\t\tif (low <= tree[current].low && tree[current].low <= high)\n\t\t\t\t{\n\t\t\t\t\t/* case 1, reduces to case 0 */\n\t\t\t\t\t/* or case 2, deleting the node */\n\t\t\t\t\ttree[current].out += high + 1 - tree[current].low;\n\t\t\t\t\ttree[current].low = high + 1;\n\t\t\t\t\tif (tree[current].low > tree[current].high)\n\t\t\t\t\t{\n\t\t\t\t\t\tmove = delete_node(cmap, current);\n\t\t\t\t\t\tcurrent = EMPTY;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (low <= tree[current].high && tree[current].high <= high)\n\t\t\t\t{\n\t\t\t\t\t/* case 4, reduces to case 5 */\n\t\t\t\t\ttree[current].high = low - 1;\n\t\t\t\t\tassert(tree[current].low <= tree[current].high);\n\t\t\t\t}\n\t\t\t\telse if (tree[current].low < low && high < tree[current].high)\n\t\t\t\t{\n                                        /* case 3, reduces to case 5 */\n                                        int new_high = tree[current].high;\n                                        tree[current].high = low-1;\n                                       add_range(ctx, cmap, high+1, new_high, tree[current].out + high + 1 - tree[current].low, 0, many);\n                                }\n                                /* Now look for where to move to next (left for case 0, right for case 5) */\n                                if (tree[current].low > high) {\n\t\t\t\t\tmove = tree[current].left;\n\t\t\t\t\tgt = current;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmove = tree[current].right;\n\t\t\t\t\tlt = current;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (move != EMPTY);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdo\n\t\t\t{\n\t\t\t\tcurrent = move;\n\t\t\t\tif (tree[current].low > high)\n\t\t\t\t{\n\t\t\t\t\tmove = tree[current].left;\n\t\t\t\t\tgt = current;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmove = tree[current].right;\n\t\t\t\t\tlt = current;\n\t\t\t\t}\n\t\t\t} while (move != EMPTY);\n\t\t}\n\t\t/* current is now the node to which we would be adding the new node */\n\t\t/* lt is the last node we traversed which is lt the new node. */\n\t\t/* gt is the last node we traversed which is gt the new node. */\n\n\t\tif (!many)\n\t\t{\n\t\t\t/* Check for the 'merge' cases. */\n\t\t\tif (lt != EMPTY && !tree[lt].many && tree[lt].high == low-1 && tree[lt].out - tree[lt].low == out - low)\n\t\t\t{\n\t\t\t\ttree[lt].high = high;\n\t\t\t\tif (gt != EMPTY && !tree[gt].many && tree[gt].low == high+1 && tree[gt].out - tree[gt].low == out - low)\n\t\t\t\t{\n\t\t\t\t\ttree[lt].high = tree[gt].high;\n\t\t\t\t\tdelete_node(cmap, gt);\n\t\t\t\t}\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tif (gt != EMPTY && !tree[gt].many && tree[gt].low == high+1 && tree[gt].out - tree[gt].low == out - low)\n\t\t\t{\n\t\t\t\ttree[gt].low = low;\n\t\t\t\ttree[gt].out = out;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t\tcurrent = EMPTY;\n\n\tif (cmap->tlen == cmap->tcap)\n\t{\n\t\tint new_cap = cmap->tcap ? cmap->tcap * 2 : 256;\n\t\ttree = cmap->tree = fz_resize_array(ctx, cmap->tree, new_cap, sizeof *cmap->tree);\n\t\tcmap->tcap = new_cap;\n\t}\n\ttree[cmap->tlen].low = low;\n\ttree[cmap->tlen].high = high;\n\ttree[cmap->tlen].out = out;\n\ttree[cmap->tlen].parent = current;\n\ttree[cmap->tlen].left = EMPTY;\n\ttree[cmap->tlen].right = EMPTY;\n\ttree[cmap->tlen].many = many;\n\tcmap->tlen++;\n\tif (current == EMPTY)\n\t\tcmap->ttop = 0;\n\telse if (tree[current].low > high)\n\t\ttree[current].left = cmap->tlen-1;\n\telse\n\t{\n\t\tassert(tree[current].high < low);\n\t\ttree[current].right = cmap->tlen-1;\n\t}\n\tmove_to_root(tree, cmap->tlen-1);\n\tcmap->ttop = cmap->tlen-1;\nexit:\n\t{}\n#ifdef CHECK_SPLAY\n\tcheck_splay(cmap->tree, cmap->ttop, 0);\n#endif\n#ifdef DUMP_SPLAY\n\tdump_splay(cmap->tree, cmap->ttop, 0, \"\");\n#endif\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141351,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "add_range(fz_context *ctx, pdf_cmap *cmap, unsigned int low, unsigned int high, unsigned int out, int check_for_overlap, int many)\n{\n\tint current;\n\tcmap_splay *tree;\n\n\tif (low > high)\n\t{\n\t\tfz_warn(ctx, \"range limits out of range in cmap %s\", cmap->cmap_name);\n\t\treturn;\n\t}\n\n\ttree = cmap->tree;\n\n\tif (cmap->tlen)\n\t{\n\t\tunsigned int move = cmap->ttop;\n\t\tunsigned int gt = EMPTY;\n\t\tunsigned int lt = EMPTY;\n\t\tif (check_for_overlap)\n\t\t{\n\t\t\t/* Check for collision with the current node */\n\t\t\tdo\n\t\t\t{\n\t\t\t\tcurrent = move;\n\t\t\t\t/* Cases we might meet:\n\t\t\t\t * tree[i]:        <----->\n\t\t\t\t * case 0:     <->\n\t\t\t\t * case 1:     <------->\n\t\t\t\t * case 2:     <------------->\n\t\t\t\t * case 3:           <->\n\t\t\t\t * case 4:           <------->\n\t\t\t\t * case 5:                 <->\n\t\t\t\t */\n\t\t\t\tif (low <= tree[current].low && tree[current].low <= high)\n\t\t\t\t{\n\t\t\t\t\t/* case 1, reduces to case 0 */\n\t\t\t\t\t/* or case 2, deleting the node */\n\t\t\t\t\ttree[current].out += high + 1 - tree[current].low;\n\t\t\t\t\ttree[current].low = high + 1;\n\t\t\t\t\tif (tree[current].low > tree[current].high)\n\t\t\t\t\t{\n\t\t\t\t\t\tmove = delete_node(cmap, current);\n\t\t\t\t\t\tcurrent = EMPTY;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (low <= tree[current].high && tree[current].high <= high)\n\t\t\t\t{\n\t\t\t\t\t/* case 4, reduces to case 5 */\n\t\t\t\t\ttree[current].high = low - 1;\n\t\t\t\t\tassert(tree[current].low <= tree[current].high);\n\t\t\t\t}\n\t\t\t\telse if (tree[current].low < low && high < tree[current].high)\n\t\t\t\t{\n                                        /* case 3, reduces to case 5 */\n                                        int new_high = tree[current].high;\n                                        tree[current].high = low-1;\n                                       add_range(ctx, cmap, high+1, new_high, tree[current].out + high + 1 - tree[current].low, 0, tree[current].many);\n                                }\n                                /* Now look for where to move to next (left for case 0, right for case 5) */\n                                if (tree[current].low > high) {\n\t\t\t\t\tmove = tree[current].left;\n\t\t\t\t\tgt = current;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmove = tree[current].right;\n\t\t\t\t\tlt = current;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (move != EMPTY);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdo\n\t\t\t{\n\t\t\t\tcurrent = move;\n\t\t\t\tif (tree[current].low > high)\n\t\t\t\t{\n\t\t\t\t\tmove = tree[current].left;\n\t\t\t\t\tgt = current;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmove = tree[current].right;\n\t\t\t\t\tlt = current;\n\t\t\t\t}\n\t\t\t} while (move != EMPTY);\n\t\t}\n\t\t/* current is now the node to which we would be adding the new node */\n\t\t/* lt is the last node we traversed which is lt the new node. */\n\t\t/* gt is the last node we traversed which is gt the new node. */\n\n\t\tif (!many)\n\t\t{\n\t\t\t/* Check for the 'merge' cases. */\n\t\t\tif (lt != EMPTY && !tree[lt].many && tree[lt].high == low-1 && tree[lt].out - tree[lt].low == out - low)\n\t\t\t{\n\t\t\t\ttree[lt].high = high;\n\t\t\t\tif (gt != EMPTY && !tree[gt].many && tree[gt].low == high+1 && tree[gt].out - tree[gt].low == out - low)\n\t\t\t\t{\n\t\t\t\t\ttree[lt].high = tree[gt].high;\n\t\t\t\t\tdelete_node(cmap, gt);\n\t\t\t\t}\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tif (gt != EMPTY && !tree[gt].many && tree[gt].low == high+1 && tree[gt].out - tree[gt].low == out - low)\n\t\t\t{\n\t\t\t\ttree[gt].low = low;\n\t\t\t\ttree[gt].out = out;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t\tcurrent = EMPTY;\n\n\tif (cmap->tlen == cmap->tcap)\n\t{\n\t\tint new_cap = cmap->tcap ? cmap->tcap * 2 : 256;\n\t\ttree = cmap->tree = fz_resize_array(ctx, cmap->tree, new_cap, sizeof *cmap->tree);\n\t\tcmap->tcap = new_cap;\n\t}\n\ttree[cmap->tlen].low = low;\n\ttree[cmap->tlen].high = high;\n\ttree[cmap->tlen].out = out;\n\ttree[cmap->tlen].parent = current;\n\ttree[cmap->tlen].left = EMPTY;\n\ttree[cmap->tlen].right = EMPTY;\n\ttree[cmap->tlen].many = many;\n\tcmap->tlen++;\n\tif (current == EMPTY)\n\t\tcmap->ttop = 0;\n\telse if (tree[current].low > high)\n\t\ttree[current].left = cmap->tlen-1;\n\telse\n\t{\n\t\tassert(tree[current].high < low);\n\t\ttree[current].right = cmap->tlen-1;\n\t}\n\tmove_to_root(tree, cmap->tlen-1);\n\tcmap->ttop = cmap->tlen-1;\nexit:\n\t{}\n#ifdef CHECK_SPLAY\n\tcheck_splay(cmap->tree, cmap->ttop, 0);\n#endif\n#ifdef DUMP_SPLAY\n\tdump_splay(cmap->tree, cmap->ttop, 0, \"\");\n#endif\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141352,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "gs_main_finit(gs_main_instance * minst, int exit_status, int code)\n{\n    i_ctx_t *i_ctx_p = minst->i_ctx_p;\n    gs_dual_memory_t dmem = {0};\n    int exit_code;\n    ref error_object;\n    char *tempnames;\n\n    /* NB: need to free gs_name_table\n     */\n\n    /*\n     * Previous versions of this code closed the devices in the\n     * device list here.  Since these devices are now prototypes,\n     * they cannot be opened, so they do not need to be closed;\n     * alloc_restore_all will close dynamically allocated devices.\n     */\n    tempnames = gs_main_tempnames(minst);\n\n    /* by the time we get here, we *must* avoid any random redefinitions of\n     * operators etc, so we push systemdict onto the top of the dict stack.\n     * We do this in C to avoid running into any other re-defininitions in the\n     * Postscript world.\n     */\n    gs_finit_push_systemdict(i_ctx_p);\n\n    /* We have to disable BGPrint before we call interp_reclaim() to prevent the\n     * parent rendering thread initialising for the next page, whilst we are\n     * removing objects it may want to access - for example, the I/O device table.\n     * We also have to mess with the BeginPage/EndPage procs so that we don't\n     * trigger a spurious extra page to be emitted.\n     */\n    if (minst->init_done >= 2) {\n        gs_main_run_string(minst,\n            \"/BGPrint /GetDeviceParam .special_op \\\n            {{ <</BeginPage {pop} /EndPage {pop pop //false } \\\n              /BGPrint false /NumRenderingThreads 0>> setpagedevice} if} if \\\n              serverdict /.jobsavelevel get 0 eq {/quit} {/stop} ifelse \\\n              .systemvar exec\",\n            0 , &exit_code, &error_object);\n    }\n\n    /*\n     * Close the \"main\" device, because it may need to write out\n     * data before destruction. pdfwrite needs so.\n     */\n    if (minst->init_done >= 2) {\n        int code = 0;\n\n        if (idmemory->reclaim != 0) {\n            code = interp_reclaim(&minst->i_ctx_p, avm_global);\n\n            if (code < 0) {\n                ref error_name;\n                if (tempnames)\n                    free(tempnames);\n\n                if (gs_errorname(i_ctx_p, code, &error_name) >= 0) {\n                    char err_str[32] = {0};\n                    name_string_ref(imemory, &error_name, &error_name);\n                    memcpy(err_str, error_name.value.const_bytes, r_size(&error_name));\n                    emprintf2(imemory, \"ERROR: %s (%d) reclaiming the memory while the interpreter finalization.\\n\", err_str, code);\n                }\n                else {\n                    emprintf1(imemory, \"UNKNOWN ERROR %d reclaiming the memory while the interpreter finalization.\\n\", code);\n                }\n#ifdef MEMENTO_SQUEEZE_BUILD\n                if (code != gs_error_VMerror ) return gs_error_Fatal;\n#else\n                return gs_error_Fatal;\n#endif\n            }\n             i_ctx_p = minst->i_ctx_p; /* interp_reclaim could change it. */\n         }\n \n         if (i_ctx_p->pgs != NULL && i_ctx_p->pgs->device != NULL) {\n             gx_device *pdev = i_ctx_p->pgs->device;\n             const char * dname = pdev->dname;\n            if (code < 0) {\n                ref error_name;\n                if (gs_errorname(i_ctx_p, code, &error_name) >= 0) {\n                    char err_str[32] = {0};\n                    name_string_ref(imemory, &error_name, &error_name);\n                    memcpy(err_str, error_name.value.const_bytes, r_size(&error_name));\n                    emprintf3(imemory, \"ERROR: %s (%d) on closing %s device.\\n\", err_str, code, dname);\n                }\n                else {\n                    emprintf2(imemory, \"UNKNOWN ERROR %d closing %s device.\\n\", code, dname);\n               }\n            }\n            rc_decrement(pdev, \"gs_main_finit\");                /* device might be freed */\n            if (exit_status == 0 || exit_status == gs_error_Quit)\n                exit_status = code;\n        }\n\n      /* Flush stdout and stderr */\n      gs_main_run_string(minst,\n        \"(%stdout) (w) file closefile (%stderr) (w) file closefile \\\n        serverdict /.jobsavelevel get 0 eq {/quit} {/stop} ifelse .systemexec \\\n          systemdict /savedinitialgstate .forceundef\",\n        0 , &exit_code, &error_object);\n    }\n    gp_readline_finit(minst->readline_data);\n    i_ctx_p = minst->i_ctx_p;\t\t/* get current interp context */\n    if (gs_debug_c(':')) {\n        print_resource_usage(minst, &gs_imemory, \"Final\");\n        dmprintf1(minst->heap, \"%% Exiting instance 0x%p\\n\", minst);\n    }\n    /* Do the equivalent of a restore \"past the bottom\". */\n    /* This will release all memory, close all open files, etc. */\n    if (minst->init_done >= 1) {\n        gs_memory_t *mem_raw = i_ctx_p->memory.current->non_gc_memory;\n        i_plugin_holder *h = i_ctx_p->plugin_list;\n\n        dmem = *idmemory;\n        code = alloc_restore_all(i_ctx_p);\n        if (code < 0)\n            emprintf1(mem_raw,\n                      \"ERROR %d while the final restore. See gs/psi/ierrors.h for code explanation.\\n\",\n                      code);\n        i_iodev_finit(&dmem);\n        i_plugin_finit(mem_raw, h);\n    }\n\n    /* clean up redirected stdout */\n    if (minst->heap->gs_lib_ctx->fstdout2\n        && (minst->heap->gs_lib_ctx->fstdout2 != minst->heap->gs_lib_ctx->fstdout)\n        && (minst->heap->gs_lib_ctx->fstdout2 != minst->heap->gs_lib_ctx->fstderr)) {\n        fclose(minst->heap->gs_lib_ctx->fstdout2);\n        minst->heap->gs_lib_ctx->fstdout2 = (FILE *)NULL;\n    }\n\n    minst->heap->gs_lib_ctx->stdout_is_redirected = 0;\n    minst->heap->gs_lib_ctx->stdout_to_stderr = 0;\n    /* remove any temporary files, after ghostscript has closed files */\n    if (tempnames) {\n        char *p = tempnames;\n        while (*p) {\n            unlink(p);\n            p += strlen(p) + 1;\n        }\n        free(tempnames);\n    }\n    gs_lib_finit(exit_status, code, minst->heap);\n\n    gs_free_object(minst->heap, minst->lib_path.container.value.refs, \"lib_path array\");\n    ialloc_finit(&dmem);\n    return exit_status;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141403,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "gs_main_finit(gs_main_instance * minst, int exit_status, int code)\n{\n    i_ctx_t *i_ctx_p = minst->i_ctx_p;\n    gs_dual_memory_t dmem = {0};\n    int exit_code;\n    ref error_object;\n    char *tempnames;\n\n    /* NB: need to free gs_name_table\n     */\n\n    /*\n     * Previous versions of this code closed the devices in the\n     * device list here.  Since these devices are now prototypes,\n     * they cannot be opened, so they do not need to be closed;\n     * alloc_restore_all will close dynamically allocated devices.\n     */\n    tempnames = gs_main_tempnames(minst);\n\n    /* by the time we get here, we *must* avoid any random redefinitions of\n     * operators etc, so we push systemdict onto the top of the dict stack.\n     * We do this in C to avoid running into any other re-defininitions in the\n     * Postscript world.\n     */\n    gs_finit_push_systemdict(i_ctx_p);\n\n    /* We have to disable BGPrint before we call interp_reclaim() to prevent the\n     * parent rendering thread initialising for the next page, whilst we are\n     * removing objects it may want to access - for example, the I/O device table.\n     * We also have to mess with the BeginPage/EndPage procs so that we don't\n     * trigger a spurious extra page to be emitted.\n     */\n    if (minst->init_done >= 2) {\n        gs_main_run_string(minst,\n            \"/BGPrint /GetDeviceParam .special_op \\\n            {{ <</BeginPage {pop} /EndPage {pop pop //false } \\\n              /BGPrint false /NumRenderingThreads 0>> setpagedevice} if} if \\\n              serverdict /.jobsavelevel get 0 eq {/quit} {/stop} ifelse \\\n              .systemvar exec\",\n            0 , &exit_code, &error_object);\n    }\n\n    /*\n     * Close the \"main\" device, because it may need to write out\n     * data before destruction. pdfwrite needs so.\n     */\n    if (minst->init_done >= 2) {\n        int code = 0;\n\n        if (idmemory->reclaim != 0) {\n            code = interp_reclaim(&minst->i_ctx_p, avm_global);\n\n            if (code < 0) {\n                ref error_name;\n                if (tempnames)\n                    free(tempnames);\n\n                if (gs_errorname(i_ctx_p, code, &error_name) >= 0) {\n                    char err_str[32] = {0};\n                    name_string_ref(imemory, &error_name, &error_name);\n                    memcpy(err_str, error_name.value.const_bytes, r_size(&error_name));\n                    emprintf2(imemory, \"ERROR: %s (%d) reclaiming the memory while the interpreter finalization.\\n\", err_str, code);\n                }\n                else {\n                    emprintf1(imemory, \"UNKNOWN ERROR %d reclaiming the memory while the interpreter finalization.\\n\", code);\n                }\n#ifdef MEMENTO_SQUEEZE_BUILD\n                if (code != gs_error_VMerror ) return gs_error_Fatal;\n#else\n                return gs_error_Fatal;\n#endif\n            }\n             i_ctx_p = minst->i_ctx_p; /* interp_reclaim could change it. */\n         }\n \n        if (i_ctx_p->pgs != NULL && i_ctx_p->pgs->device != NULL &&\n            gx_device_is_null(i_ctx_p->pgs->device)) {\n            /* if the job replaced the device with the nulldevice, we we need to grestore\n               away that device, so the block below can properly dispense\n               with the default device.\n             */\n            int code = gs_grestoreall(i_ctx_p->pgs);\n            if (code < 0) return_error(gs_error_Fatal);\n        }\n\n         if (i_ctx_p->pgs != NULL && i_ctx_p->pgs->device != NULL) {\n             gx_device *pdev = i_ctx_p->pgs->device;\n             const char * dname = pdev->dname;\n            if (code < 0) {\n                ref error_name;\n                if (gs_errorname(i_ctx_p, code, &error_name) >= 0) {\n                    char err_str[32] = {0};\n                    name_string_ref(imemory, &error_name, &error_name);\n                    memcpy(err_str, error_name.value.const_bytes, r_size(&error_name));\n                    emprintf3(imemory, \"ERROR: %s (%d) on closing %s device.\\n\", err_str, code, dname);\n                }\n                else {\n                    emprintf2(imemory, \"UNKNOWN ERROR %d closing %s device.\\n\", code, dname);\n               }\n            }\n            rc_decrement(pdev, \"gs_main_finit\");                /* device might be freed */\n            if (exit_status == 0 || exit_status == gs_error_Quit)\n                exit_status = code;\n        }\n\n      /* Flush stdout and stderr */\n      gs_main_run_string(minst,\n        \"(%stdout) (w) file closefile (%stderr) (w) file closefile \\\n        serverdict /.jobsavelevel get 0 eq {/quit} {/stop} ifelse .systemexec \\\n          systemdict /savedinitialgstate .forceundef\",\n        0 , &exit_code, &error_object);\n    }\n    gp_readline_finit(minst->readline_data);\n    i_ctx_p = minst->i_ctx_p;\t\t/* get current interp context */\n    if (gs_debug_c(':')) {\n        print_resource_usage(minst, &gs_imemory, \"Final\");\n        dmprintf1(minst->heap, \"%% Exiting instance 0x%p\\n\", minst);\n    }\n    /* Do the equivalent of a restore \"past the bottom\". */\n    /* This will release all memory, close all open files, etc. */\n    if (minst->init_done >= 1) {\n        gs_memory_t *mem_raw = i_ctx_p->memory.current->non_gc_memory;\n        i_plugin_holder *h = i_ctx_p->plugin_list;\n\n        dmem = *idmemory;\n        code = alloc_restore_all(i_ctx_p);\n        if (code < 0)\n            emprintf1(mem_raw,\n                      \"ERROR %d while the final restore. See gs/psi/ierrors.h for code explanation.\\n\",\n                      code);\n        i_iodev_finit(&dmem);\n        i_plugin_finit(mem_raw, h);\n    }\n\n    /* clean up redirected stdout */\n    if (minst->heap->gs_lib_ctx->fstdout2\n        && (minst->heap->gs_lib_ctx->fstdout2 != minst->heap->gs_lib_ctx->fstdout)\n        && (minst->heap->gs_lib_ctx->fstdout2 != minst->heap->gs_lib_ctx->fstderr)) {\n        fclose(minst->heap->gs_lib_ctx->fstdout2);\n        minst->heap->gs_lib_ctx->fstdout2 = (FILE *)NULL;\n    }\n\n    minst->heap->gs_lib_ctx->stdout_is_redirected = 0;\n    minst->heap->gs_lib_ctx->stdout_to_stderr = 0;\n    /* remove any temporary files, after ghostscript has closed files */\n    if (tempnames) {\n        char *p = tempnames;\n        while (*p) {\n            unlink(p);\n            p += strlen(p) + 1;\n        }\n        free(tempnames);\n    }\n    gs_lib_finit(exit_status, code, minst->heap);\n\n    gs_free_object(minst->heap, minst->lib_path.container.value.refs, \"lib_path array\");\n    ialloc_finit(&dmem);\n    return exit_status;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141404,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static struct file *path_openat(int dfd, struct filename *pathname,\n\t\tstruct nameidata *nd, const struct open_flags *op, int flags)\n{\n\tstruct file *file;\n\tstruct path path;\n\tint opened = 0;\n\tint error;\n\n\tfile = get_empty_filp();\n\tif (IS_ERR(file))\n\t\treturn file;\n\n\tfile->f_flags = op->open_flag;\n \n \tif (unlikely(file->f_flags & __O_TMPFILE)) {\n \t\terror = do_tmpfile(dfd, pathname, nd, flags, op, file, &opened);\n\t\tgoto out;\n \t}\n \n \terror = path_init(dfd, pathname, flags, nd);\n\tif (unlikely(error))\n\t\tgoto out;\n\n\terror = do_last(nd, &path, file, op, &opened, pathname);\n\twhile (unlikely(error > 0)) { /* trailing symlink */\n\t\tstruct path link = path;\n\t\tvoid *cookie;\n\t\tif (!(nd->flags & LOOKUP_FOLLOW)) {\n\t\t\tpath_put_conditional(&path, nd);\n\t\t\tpath_put(&nd->path);\n\t\t\terror = -ELOOP;\n\t\t\tbreak;\n\t\t}\n\t\terror = may_follow_link(&link, nd);\n\t\tif (unlikely(error))\n\t\t\tbreak;\n\t\tnd->flags |= LOOKUP_PARENT;\n\t\tnd->flags &= ~(LOOKUP_OPEN|LOOKUP_CREATE|LOOKUP_EXCL);\n\t\terror = follow_link(&link, nd, &cookie);\n\t\tif (unlikely(error))\n\t\t\tbreak;\n\t\terror = do_last(nd, &path, file, op, &opened, pathname);\n\t\tput_link(nd, &link, cookie);\n \t}\n out:\n \tpath_cleanup(nd);\n \tif (!(opened & FILE_OPENED)) {\n \t\tBUG_ON(!error);\n \t\tput_filp(file);\n\t}\n\tif (unlikely(error)) {\n\t\tif (error == -EOPENSTALE) {\n\t\t\tif (flags & LOOKUP_RCU)\n\t\t\t\terror = -ECHILD;\n\t\t\telse\n\t\t\t\terror = -ESTALE;\n\t\t}\n\t\tfile = ERR_PTR(error);\n\t}\n\treturn file;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141969,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static struct file *path_openat(int dfd, struct filename *pathname,\n\t\tstruct nameidata *nd, const struct open_flags *op, int flags)\n{\n\tstruct file *file;\n\tstruct path path;\n\tint opened = 0;\n\tint error;\n\n\tfile = get_empty_filp();\n\tif (IS_ERR(file))\n\t\treturn file;\n\n\tfile->f_flags = op->open_flag;\n \n \tif (unlikely(file->f_flags & __O_TMPFILE)) {\n \t\terror = do_tmpfile(dfd, pathname, nd, flags, op, file, &opened);\n\t\tgoto out2;\n \t}\n \n \terror = path_init(dfd, pathname, flags, nd);\n\tif (unlikely(error))\n\t\tgoto out;\n\n\terror = do_last(nd, &path, file, op, &opened, pathname);\n\twhile (unlikely(error > 0)) { /* trailing symlink */\n\t\tstruct path link = path;\n\t\tvoid *cookie;\n\t\tif (!(nd->flags & LOOKUP_FOLLOW)) {\n\t\t\tpath_put_conditional(&path, nd);\n\t\t\tpath_put(&nd->path);\n\t\t\terror = -ELOOP;\n\t\t\tbreak;\n\t\t}\n\t\terror = may_follow_link(&link, nd);\n\t\tif (unlikely(error))\n\t\t\tbreak;\n\t\tnd->flags |= LOOKUP_PARENT;\n\t\tnd->flags &= ~(LOOKUP_OPEN|LOOKUP_CREATE|LOOKUP_EXCL);\n\t\terror = follow_link(&link, nd, &cookie);\n\t\tif (unlikely(error))\n\t\t\tbreak;\n\t\terror = do_last(nd, &path, file, op, &opened, pathname);\n\t\tput_link(nd, &link, cookie);\n \t}\n out:\n \tpath_cleanup(nd);\nout2:\n \tif (!(opened & FILE_OPENED)) {\n \t\tBUG_ON(!error);\n \t\tput_filp(file);\n\t}\n\tif (unlikely(error)) {\n\t\tif (error == -EOPENSTALE) {\n\t\t\tif (flags & LOOKUP_RCU)\n\t\t\t\terror = -ECHILD;\n\t\t\telse\n\t\t\t\terror = -ESTALE;\n\t\t}\n\t\tfile = ERR_PTR(error);\n\t}\n\treturn file;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141970,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "bsg_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct bsg_device *bd = file->private_data;\n\tssize_t bytes_written;\n\tint ret;\n \n \tdprintk(\"%s: write %Zd bytes\\n\", bd->name, count);\n \n \tbsg_set_block(bd, file);\n \n \tbytes_written = 0;\n\tret = __bsg_write(bd, buf, count, &bytes_written,\n\t\t\t  file->f_mode & FMODE_WRITE);\n\n\t*ppos = bytes_written;\n\n\t/*\n\t * return bytes written on non-fatal errors\n\t */\n\tif (!bytes_written || err_block_err(ret))\n\t\tbytes_written = ret;\n\n\tdprintk(\"%s: returning %Zd\\n\", bd->name, bytes_written);\n\treturn bytes_written;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142023,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "bsg_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct bsg_device *bd = file->private_data;\n\tssize_t bytes_written;\n\tint ret;\n \n \tdprintk(\"%s: write %Zd bytes\\n\", bd->name, count);\n \n\tif (unlikely(segment_eq(get_fs(), KERNEL_DS)))\n\t\treturn -EINVAL;\n\n \tbsg_set_block(bd, file);\n \n \tbytes_written = 0;\n\tret = __bsg_write(bd, buf, count, &bytes_written,\n\t\t\t  file->f_mode & FMODE_WRITE);\n\n\t*ppos = bytes_written;\n\n\t/*\n\t * return bytes written on non-fatal errors\n\t */\n\tif (!bytes_written || err_block_err(ret))\n\t\tbytes_written = ret;\n\n\tdprintk(\"%s: returning %Zd\\n\", bd->name, bytes_written);\n\treturn bytes_written;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142024,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "sg_write(struct file *filp, const char __user *buf, size_t count, loff_t * ppos)\n{\n\tint mxsize, cmd_size, k;\n\tint input_size, blocking;\n\tunsigned char opcode;\n\tSg_device *sdp;\n\tSg_fd *sfp;\n\tSg_request *srp;\n\tstruct sg_header old_hdr;\n \tsg_io_hdr_t *hp;\n \tunsigned char cmnd[SG_MAX_CDB_SIZE];\n \n \tif ((!(sfp = (Sg_fd *) filp->private_data)) || (!(sdp = sfp->parentdp)))\n \t\treturn -ENXIO;\n \tSCSI_LOG_TIMEOUT(3, sg_printk(KERN_INFO, sdp,\n\t\t\t\t      \"sg_write: count=%d\\n\", (int) count));\n\tif (atomic_read(&sdp->detaching))\n\t\treturn -ENODEV;\n\tif (!((filp->f_flags & O_NONBLOCK) ||\n\t      scsi_block_when_processing_errors(sdp->device)))\n\t\treturn -ENXIO;\n\n\tif (!access_ok(VERIFY_READ, buf, count))\n\t\treturn -EFAULT;\t/* protects following copy_from_user()s + get_user()s */\n\tif (count < SZ_SG_HEADER)\n\t\treturn -EIO;\n\tif (__copy_from_user(&old_hdr, buf, SZ_SG_HEADER))\n\t\treturn -EFAULT;\n\tblocking = !(filp->f_flags & O_NONBLOCK);\n\tif (old_hdr.reply_len < 0)\n\t\treturn sg_new_write(sfp, filp, buf, count,\n\t\t\t\t    blocking, 0, 0, NULL);\n\tif (count < (SZ_SG_HEADER + 6))\n\t\treturn -EIO;\t/* The minimum scsi command length is 6 bytes. */\n\n\tif (!(srp = sg_add_request(sfp))) {\n\t\tSCSI_LOG_TIMEOUT(1, sg_printk(KERN_INFO, sdp,\n\t\t\t\t\t      \"sg_write: queue full\\n\"));\n\t\treturn -EDOM;\n\t}\n\tbuf += SZ_SG_HEADER;\n\t__get_user(opcode, buf);\n\tif (sfp->next_cmd_len > 0) {\n\t\tcmd_size = sfp->next_cmd_len;\n\t\tsfp->next_cmd_len = 0;\t/* reset so only this write() effected */\n\t} else {\n\t\tcmd_size = COMMAND_SIZE(opcode);\t/* based on SCSI command group */\n\t\tif ((opcode >= 0xc0) && old_hdr.twelve_byte)\n\t\t\tcmd_size = 12;\n\t}\n\tSCSI_LOG_TIMEOUT(4, sg_printk(KERN_INFO, sdp,\n\t\t\"sg_write:   scsi opcode=0x%02x, cmd_size=%d\\n\", (int) opcode, cmd_size));\n/* Determine buffer size.  */\n\tinput_size = count - cmd_size;\n\tmxsize = (input_size > old_hdr.reply_len) ? input_size : old_hdr.reply_len;\n\tmxsize -= SZ_SG_HEADER;\n\tinput_size -= SZ_SG_HEADER;\n\tif (input_size < 0) {\n\t\tsg_remove_request(sfp, srp);\n\t\treturn -EIO;\t/* User did not pass enough bytes for this command. */\n\t}\n\thp = &srp->header;\n\thp->interface_id = '\\0';\t/* indicator of old interface tunnelled */\n\thp->cmd_len = (unsigned char) cmd_size;\n\thp->iovec_count = 0;\n\thp->mx_sb_len = 0;\n\tif (input_size > 0)\n\t\thp->dxfer_direction = (old_hdr.reply_len > SZ_SG_HEADER) ?\n\t\t    SG_DXFER_TO_FROM_DEV : SG_DXFER_TO_DEV;\n\telse\n\t\thp->dxfer_direction = (mxsize > 0) ? SG_DXFER_FROM_DEV : SG_DXFER_NONE;\n\thp->dxfer_len = mxsize;\n\tif ((hp->dxfer_direction == SG_DXFER_TO_DEV) ||\n\t    (hp->dxfer_direction == SG_DXFER_TO_FROM_DEV))\n\t\thp->dxferp = (char __user *)buf + cmd_size;\n\telse\n\t\thp->dxferp = NULL;\n\thp->sbp = NULL;\n\thp->timeout = old_hdr.reply_len;\t/* structure abuse ... */\n\thp->flags = input_size;\t/* structure abuse ... */\n\thp->pack_id = old_hdr.pack_id;\n\thp->usr_ptr = NULL;\n\tif (__copy_from_user(cmnd, buf, cmd_size))\n\t\treturn -EFAULT;\n\t/*\n\t * SG_DXFER_TO_FROM_DEV is functionally equivalent to SG_DXFER_FROM_DEV,\n\t * but is is possible that the app intended SG_DXFER_TO_DEV, because there\n\t * is a non-zero input_size, so emit a warning.\n\t */\n\tif (hp->dxfer_direction == SG_DXFER_TO_FROM_DEV) {\n\t\tstatic char cmd[TASK_COMM_LEN];\n\t\tif (strcmp(current->comm, cmd)) {\n\t\t\tprintk_ratelimited(KERN_WARNING\n\t\t\t\t\t   \"sg_write: data in/out %d/%d bytes \"\n\t\t\t\t\t   \"for SCSI command 0x%x-- guessing \"\n\t\t\t\t\t   \"data in;\\n   program %s not setting \"\n\t\t\t\t\t   \"count and/or reply_len properly\\n\",\n\t\t\t\t\t   old_hdr.reply_len - (int)SZ_SG_HEADER,\n\t\t\t\t\t   input_size, (unsigned int) cmnd[0],\n\t\t\t\t\t   current->comm);\n\t\t\tstrcpy(cmd, current->comm);\n\t\t}\n\t}\n\tk = sg_common_write(sfp, srp, cmnd, sfp->timeout, blocking);\n\treturn (k < 0) ? k : count;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142025,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "sg_write(struct file *filp, const char __user *buf, size_t count, loff_t * ppos)\n{\n\tint mxsize, cmd_size, k;\n\tint input_size, blocking;\n\tunsigned char opcode;\n\tSg_device *sdp;\n\tSg_fd *sfp;\n\tSg_request *srp;\n\tstruct sg_header old_hdr;\n \tsg_io_hdr_t *hp;\n \tunsigned char cmnd[SG_MAX_CDB_SIZE];\n \n\tif (unlikely(segment_eq(get_fs(), KERNEL_DS)))\n\t\treturn -EINVAL;\n\n \tif ((!(sfp = (Sg_fd *) filp->private_data)) || (!(sdp = sfp->parentdp)))\n \t\treturn -ENXIO;\n \tSCSI_LOG_TIMEOUT(3, sg_printk(KERN_INFO, sdp,\n\t\t\t\t      \"sg_write: count=%d\\n\", (int) count));\n\tif (atomic_read(&sdp->detaching))\n\t\treturn -ENODEV;\n\tif (!((filp->f_flags & O_NONBLOCK) ||\n\t      scsi_block_when_processing_errors(sdp->device)))\n\t\treturn -ENXIO;\n\n\tif (!access_ok(VERIFY_READ, buf, count))\n\t\treturn -EFAULT;\t/* protects following copy_from_user()s + get_user()s */\n\tif (count < SZ_SG_HEADER)\n\t\treturn -EIO;\n\tif (__copy_from_user(&old_hdr, buf, SZ_SG_HEADER))\n\t\treturn -EFAULT;\n\tblocking = !(filp->f_flags & O_NONBLOCK);\n\tif (old_hdr.reply_len < 0)\n\t\treturn sg_new_write(sfp, filp, buf, count,\n\t\t\t\t    blocking, 0, 0, NULL);\n\tif (count < (SZ_SG_HEADER + 6))\n\t\treturn -EIO;\t/* The minimum scsi command length is 6 bytes. */\n\n\tif (!(srp = sg_add_request(sfp))) {\n\t\tSCSI_LOG_TIMEOUT(1, sg_printk(KERN_INFO, sdp,\n\t\t\t\t\t      \"sg_write: queue full\\n\"));\n\t\treturn -EDOM;\n\t}\n\tbuf += SZ_SG_HEADER;\n\t__get_user(opcode, buf);\n\tif (sfp->next_cmd_len > 0) {\n\t\tcmd_size = sfp->next_cmd_len;\n\t\tsfp->next_cmd_len = 0;\t/* reset so only this write() effected */\n\t} else {\n\t\tcmd_size = COMMAND_SIZE(opcode);\t/* based on SCSI command group */\n\t\tif ((opcode >= 0xc0) && old_hdr.twelve_byte)\n\t\t\tcmd_size = 12;\n\t}\n\tSCSI_LOG_TIMEOUT(4, sg_printk(KERN_INFO, sdp,\n\t\t\"sg_write:   scsi opcode=0x%02x, cmd_size=%d\\n\", (int) opcode, cmd_size));\n/* Determine buffer size.  */\n\tinput_size = count - cmd_size;\n\tmxsize = (input_size > old_hdr.reply_len) ? input_size : old_hdr.reply_len;\n\tmxsize -= SZ_SG_HEADER;\n\tinput_size -= SZ_SG_HEADER;\n\tif (input_size < 0) {\n\t\tsg_remove_request(sfp, srp);\n\t\treturn -EIO;\t/* User did not pass enough bytes for this command. */\n\t}\n\thp = &srp->header;\n\thp->interface_id = '\\0';\t/* indicator of old interface tunnelled */\n\thp->cmd_len = (unsigned char) cmd_size;\n\thp->iovec_count = 0;\n\thp->mx_sb_len = 0;\n\tif (input_size > 0)\n\t\thp->dxfer_direction = (old_hdr.reply_len > SZ_SG_HEADER) ?\n\t\t    SG_DXFER_TO_FROM_DEV : SG_DXFER_TO_DEV;\n\telse\n\t\thp->dxfer_direction = (mxsize > 0) ? SG_DXFER_FROM_DEV : SG_DXFER_NONE;\n\thp->dxfer_len = mxsize;\n\tif ((hp->dxfer_direction == SG_DXFER_TO_DEV) ||\n\t    (hp->dxfer_direction == SG_DXFER_TO_FROM_DEV))\n\t\thp->dxferp = (char __user *)buf + cmd_size;\n\telse\n\t\thp->dxferp = NULL;\n\thp->sbp = NULL;\n\thp->timeout = old_hdr.reply_len;\t/* structure abuse ... */\n\thp->flags = input_size;\t/* structure abuse ... */\n\thp->pack_id = old_hdr.pack_id;\n\thp->usr_ptr = NULL;\n\tif (__copy_from_user(cmnd, buf, cmd_size))\n\t\treturn -EFAULT;\n\t/*\n\t * SG_DXFER_TO_FROM_DEV is functionally equivalent to SG_DXFER_FROM_DEV,\n\t * but is is possible that the app intended SG_DXFER_TO_DEV, because there\n\t * is a non-zero input_size, so emit a warning.\n\t */\n\tif (hp->dxfer_direction == SG_DXFER_TO_FROM_DEV) {\n\t\tstatic char cmd[TASK_COMM_LEN];\n\t\tif (strcmp(current->comm, cmd)) {\n\t\t\tprintk_ratelimited(KERN_WARNING\n\t\t\t\t\t   \"sg_write: data in/out %d/%d bytes \"\n\t\t\t\t\t   \"for SCSI command 0x%x-- guessing \"\n\t\t\t\t\t   \"data in;\\n   program %s not setting \"\n\t\t\t\t\t   \"count and/or reply_len properly\\n\",\n\t\t\t\t\t   old_hdr.reply_len - (int)SZ_SG_HEADER,\n\t\t\t\t\t   input_size, (unsigned int) cmnd[0],\n\t\t\t\t\t   current->comm);\n\t\t\tstrcpy(cmd, current->comm);\n\t\t}\n\t}\n\tk = sg_common_write(sfp, srp, cmnd, sfp->timeout, blocking);\n\treturn (k < 0) ? k : count;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142026,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "void snd_pcm_period_elapsed(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime;\n\tunsigned long flags;\n\n\tif (PCM_RUNTIME_CHECK(substream))\n\t\treturn;\n\truntime = substream->runtime;\n\n\tsnd_pcm_stream_lock_irqsave(substream, flags);\n\tif (!snd_pcm_running(substream) ||\n\t    snd_pcm_update_hw_ptr0(substream, 1) < 0)\n\t\tgoto _end;\n\n#ifdef CONFIG_SND_PCM_TIMER\n\tif (substream->timer_running)\n \t\tsnd_timer_interrupt(substream->timer, 1);\n #endif\n  _end:\n\tsnd_pcm_stream_unlock_irqrestore(substream, flags);\n \tkill_fasync(&runtime->fasync, SIGIO, POLL_IN);\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142033,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "void snd_pcm_period_elapsed(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime;\n\tunsigned long flags;\n\n\tif (PCM_RUNTIME_CHECK(substream))\n\t\treturn;\n\truntime = substream->runtime;\n\n\tsnd_pcm_stream_lock_irqsave(substream, flags);\n\tif (!snd_pcm_running(substream) ||\n\t    snd_pcm_update_hw_ptr0(substream, 1) < 0)\n\t\tgoto _end;\n\n#ifdef CONFIG_SND_PCM_TIMER\n\tif (substream->timer_running)\n \t\tsnd_timer_interrupt(substream->timer, 1);\n #endif\n  _end:\n \tkill_fasync(&runtime->fasync, SIGIO, POLL_IN);\n\tsnd_pcm_stream_unlock_irqrestore(substream, flags);\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142034,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "int blk_rq_map_user_iov(struct request_queue *q, struct request *rq,\n\t\t\tstruct rq_map_data *map_data,\n\t\t\tconst struct iov_iter *iter, gfp_t gfp_mask)\n{\n\tbool copy = false;\n\tunsigned long align = q->dma_pad_mask | queue_dma_alignment(q);\n\tstruct bio *bio = NULL;\n \tstruct iov_iter i;\n \tint ret;\n \n \tif (map_data)\n \t\tcopy = true;\n \telse if (iov_iter_alignment(iter) & align)\n\t\tcopy = true;\n\telse if (queue_virt_boundary(q))\n\t\tcopy = queue_virt_boundary(q) & iov_iter_gap_alignment(iter);\n\n\ti = *iter;\n\tdo {\n\t\tret =__blk_rq_map_user_iov(rq, map_data, &i, gfp_mask, copy);\n\t\tif (ret)\n\t\t\tgoto unmap_rq;\n\t\tif (!bio)\n\t\t\tbio = rq->bio;\n\t} while (iov_iter_count(&i));\n\n\tif (!bio_flagged(bio, BIO_USER_MAPPED))\n\t\trq->cmd_flags |= REQ_COPY_USER;\n\treturn 0;\n \n unmap_rq:\n \t__blk_rq_unmap_user(bio);\n \trq->bio = NULL;\n \treturn -EINVAL;\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142043,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "int blk_rq_map_user_iov(struct request_queue *q, struct request *rq,\n\t\t\tstruct rq_map_data *map_data,\n\t\t\tconst struct iov_iter *iter, gfp_t gfp_mask)\n{\n\tbool copy = false;\n\tunsigned long align = q->dma_pad_mask | queue_dma_alignment(q);\n\tstruct bio *bio = NULL;\n \tstruct iov_iter i;\n \tint ret;\n \n\tif (!iter_is_iovec(iter))\n\t\tgoto fail;\n\n \tif (map_data)\n \t\tcopy = true;\n \telse if (iov_iter_alignment(iter) & align)\n\t\tcopy = true;\n\telse if (queue_virt_boundary(q))\n\t\tcopy = queue_virt_boundary(q) & iov_iter_gap_alignment(iter);\n\n\ti = *iter;\n\tdo {\n\t\tret =__blk_rq_map_user_iov(rq, map_data, &i, gfp_mask, copy);\n\t\tif (ret)\n\t\t\tgoto unmap_rq;\n\t\tif (!bio)\n\t\t\tbio = rq->bio;\n\t} while (iov_iter_count(&i));\n\n\tif (!bio_flagged(bio, BIO_USER_MAPPED))\n\t\trq->cmd_flags |= REQ_COPY_USER;\n\treturn 0;\n \n unmap_rq:\n \t__blk_rq_unmap_user(bio);\nfail:\n \trq->bio = NULL;\n \treturn -EINVAL;\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142044,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static long ion_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct ion_client *client = filp->private_data;\n\tstruct ion_device *dev = client->dev;\n\tstruct ion_handle *cleanup_handle = NULL;\n\tint ret = 0;\n\tunsigned int dir;\n\n\tunion {\n\t\tstruct ion_fd_data fd;\n\t\tstruct ion_allocation_data allocation;\n\t\tstruct ion_handle_data handle;\n\t\tstruct ion_custom_data custom;\n\t} data;\n\n\tdir = ion_ioctl_dir(cmd);\n\n\tif (_IOC_SIZE(cmd) > sizeof(data))\n\t\treturn -EINVAL;\n\n\tif (dir & _IOC_WRITE)\n\t\tif (copy_from_user(&data, (void __user *)arg, _IOC_SIZE(cmd)))\n\t\t\treturn -EFAULT;\n\n\tswitch (cmd) {\n\tcase ION_IOC_ALLOC:\n\t{\n\t\tstruct ion_handle *handle;\n\n\t\thandle = ion_alloc(client, data.allocation.len,\n\t\t\t\t\t\tdata.allocation.align,\n\t\t\t\t\t\tdata.allocation.heap_id_mask,\n\t\t\t\t\t\tdata.allocation.flags);\n\t\tif (IS_ERR(handle))\n\t\t\treturn PTR_ERR(handle);\n\n\t\tdata.allocation.handle = handle->id;\n\n\t\tcleanup_handle = handle;\n\t\tbreak;\n\t}\n\tcase ION_IOC_FREE:\n \t{\n \t\tstruct ion_handle *handle;\n \n\t\thandle = ion_handle_get_by_id(client, data.handle.handle);\n\t\tif (IS_ERR(handle))\n \t\t\treturn PTR_ERR(handle);\n\t\tion_free(client, handle);\n\t\tion_handle_put(handle);\n \t\tbreak;\n \t}\n \tcase ION_IOC_SHARE:\n\tcase ION_IOC_MAP:\n\t{\n\t\tstruct ion_handle *handle;\n\n\t\thandle = ion_handle_get_by_id(client, data.handle.handle);\n\t\tif (IS_ERR(handle))\n\t\t\treturn PTR_ERR(handle);\n\t\tdata.fd.fd = ion_share_dma_buf_fd(client, handle);\n\t\tion_handle_put(handle);\n\t\tif (data.fd.fd < 0)\n\t\t\tret = data.fd.fd;\n\t\tbreak;\n\t}\n\tcase ION_IOC_IMPORT:\n\t{\n\t\tstruct ion_handle *handle;\n\n\t\thandle = ion_import_dma_buf_fd(client, data.fd.fd);\n\t\tif (IS_ERR(handle))\n\t\t\tret = PTR_ERR(handle);\n\t\telse\n\t\t\tdata.handle.handle = handle->id;\n\t\tbreak;\n\t}\n\tcase ION_IOC_SYNC:\n\t{\n\t\tret = ion_sync_for_device(client, data.fd.fd);\n\t\tbreak;\n\t}\n\tcase ION_IOC_CUSTOM:\n\t{\n\t\tif (!dev->custom_ioctl)\n\t\t\treturn -ENOTTY;\n\t\tret = dev->custom_ioctl(client, data.custom.cmd,\n\t\t\t\t\t\tdata.custom.arg);\n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n\n\tif (dir & _IOC_READ) {\n\t\tif (copy_to_user((void __user *)arg, &data, _IOC_SIZE(cmd))) {\n\t\t\tif (cleanup_handle)\n\t\t\t\tion_free(client, cleanup_handle);\n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\treturn ret;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142051,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static long ion_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct ion_client *client = filp->private_data;\n\tstruct ion_device *dev = client->dev;\n\tstruct ion_handle *cleanup_handle = NULL;\n\tint ret = 0;\n\tunsigned int dir;\n\n\tunion {\n\t\tstruct ion_fd_data fd;\n\t\tstruct ion_allocation_data allocation;\n\t\tstruct ion_handle_data handle;\n\t\tstruct ion_custom_data custom;\n\t} data;\n\n\tdir = ion_ioctl_dir(cmd);\n\n\tif (_IOC_SIZE(cmd) > sizeof(data))\n\t\treturn -EINVAL;\n\n\tif (dir & _IOC_WRITE)\n\t\tif (copy_from_user(&data, (void __user *)arg, _IOC_SIZE(cmd)))\n\t\t\treturn -EFAULT;\n\n\tswitch (cmd) {\n\tcase ION_IOC_ALLOC:\n\t{\n\t\tstruct ion_handle *handle;\n\n\t\thandle = ion_alloc(client, data.allocation.len,\n\t\t\t\t\t\tdata.allocation.align,\n\t\t\t\t\t\tdata.allocation.heap_id_mask,\n\t\t\t\t\t\tdata.allocation.flags);\n\t\tif (IS_ERR(handle))\n\t\t\treturn PTR_ERR(handle);\n\n\t\tdata.allocation.handle = handle->id;\n\n\t\tcleanup_handle = handle;\n\t\tbreak;\n\t}\n\tcase ION_IOC_FREE:\n \t{\n \t\tstruct ion_handle *handle;\n \n\t\tmutex_lock(&client->lock);\n\t\thandle = ion_handle_get_by_id_nolock(client, data.handle.handle);\n\t\tif (IS_ERR(handle)) {\n\t\t\tmutex_unlock(&client->lock);\n \t\t\treturn PTR_ERR(handle);\n\t\t}\n\t\tion_free_nolock(client, handle);\n\t\tion_handle_put_nolock(handle);\n\t\tmutex_unlock(&client->lock);\n \t\tbreak;\n \t}\n \tcase ION_IOC_SHARE:\n\tcase ION_IOC_MAP:\n\t{\n\t\tstruct ion_handle *handle;\n\n\t\thandle = ion_handle_get_by_id(client, data.handle.handle);\n\t\tif (IS_ERR(handle))\n\t\t\treturn PTR_ERR(handle);\n\t\tdata.fd.fd = ion_share_dma_buf_fd(client, handle);\n\t\tion_handle_put(handle);\n\t\tif (data.fd.fd < 0)\n\t\t\tret = data.fd.fd;\n\t\tbreak;\n\t}\n\tcase ION_IOC_IMPORT:\n\t{\n\t\tstruct ion_handle *handle;\n\n\t\thandle = ion_import_dma_buf_fd(client, data.fd.fd);\n\t\tif (IS_ERR(handle))\n\t\t\tret = PTR_ERR(handle);\n\t\telse\n\t\t\tdata.handle.handle = handle->id;\n\t\tbreak;\n\t}\n\tcase ION_IOC_SYNC:\n\t{\n\t\tret = ion_sync_for_device(client, data.fd.fd);\n\t\tbreak;\n\t}\n\tcase ION_IOC_CUSTOM:\n\t{\n\t\tif (!dev->custom_ioctl)\n\t\t\treturn -ENOTTY;\n\t\tret = dev->custom_ioctl(client, data.custom.cmd,\n\t\t\t\t\t\tdata.custom.arg);\n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n\n\tif (dir & _IOC_READ) {\n\t\tif (copy_to_user((void __user *)arg, &data, _IOC_SIZE(cmd))) {\n\t\t\tif (cleanup_handle)\n\t\t\t\tion_free(client, cleanup_handle);\n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\treturn ret;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142052,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static void ffs_user_copy_worker(struct work_struct *work)\n{\n\tstruct ffs_io_data *io_data = container_of(work, struct ffs_io_data,\n \t\t\t\t\t\t   work);\n \tint ret = io_data->req->status ? io_data->req->status :\n \t\t\t\t\t io_data->req->actual;\n \n \tif (io_data->read && ret > 0) {\n \t\tuse_mm(io_data->mm);\n\t\tret = copy_to_iter(io_data->buf, ret, &io_data->data);\n\t\tif (iov_iter_count(&io_data->data))\n\t\t\tret = -EFAULT;\n\t\tunuse_mm(io_data->mm);\n\t}\n \n \tio_data->kiocb->ki_complete(io_data->kiocb, ret, ret);\n \n\tif (io_data->ffs->ffs_eventfd &&\n\t    !(io_data->kiocb->ki_flags & IOCB_EVENTFD))\n \t\teventfd_signal(io_data->ffs->ffs_eventfd, 1);\n \n \tusb_ep_free_request(io_data->ep, io_data->req);\n \n\tio_data->kiocb->private = NULL;\n \tif (io_data->read)\n \t\tkfree(io_data->to_free);\n \tkfree(io_data->buf);\n\tkfree(io_data);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142067,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static void ffs_user_copy_worker(struct work_struct *work)\n{\n\tstruct ffs_io_data *io_data = container_of(work, struct ffs_io_data,\n \t\t\t\t\t\t   work);\n \tint ret = io_data->req->status ? io_data->req->status :\n \t\t\t\t\t io_data->req->actual;\n\tbool kiocb_has_eventfd = io_data->kiocb->ki_flags & IOCB_EVENTFD;\n \n \tif (io_data->read && ret > 0) {\n \t\tuse_mm(io_data->mm);\n\t\tret = copy_to_iter(io_data->buf, ret, &io_data->data);\n\t\tif (iov_iter_count(&io_data->data))\n\t\t\tret = -EFAULT;\n\t\tunuse_mm(io_data->mm);\n\t}\n \n \tio_data->kiocb->ki_complete(io_data->kiocb, ret, ret);\n \n\tif (io_data->ffs->ffs_eventfd && !kiocb_has_eventfd)\n \t\teventfd_signal(io_data->ffs->ffs_eventfd, 1);\n \n \tusb_ep_free_request(io_data->ep, io_data->req);\n \n \tif (io_data->read)\n \t\tkfree(io_data->to_free);\n \tkfree(io_data->buf);\n\tkfree(io_data);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142068,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "int ppp_register_net_channel(struct net *net, struct ppp_channel *chan)\n{\n\tstruct channel *pch;\n\tstruct ppp_net *pn;\n\n\tpch = kzalloc(sizeof(struct channel), GFP_KERNEL);\n\tif (!pch)\n\t\treturn -ENOMEM;\n\n\tpn = ppp_pernet(net);\n \n \tpch->ppp = NULL;\n \tpch->chan = chan;\n\tpch->chan_net = net;\n \tchan->ppp = pch;\n \tinit_ppp_file(&pch->file, CHANNEL);\n \tpch->file.hdrlen = chan->hdrlen;\n#ifdef CONFIG_PPP_MULTILINK\n\tpch->lastseq = -1;\n#endif /* CONFIG_PPP_MULTILINK */\n\tinit_rwsem(&pch->chan_sem);\n\tspin_lock_init(&pch->downl);\n\trwlock_init(&pch->upl);\n\n\tspin_lock_bh(&pn->all_channels_lock);\n\tpch->file.index = ++pn->last_channel_index;\n\tlist_add(&pch->list, &pn->new_channels);\n\tatomic_inc(&channel_count);\n\tspin_unlock_bh(&pn->all_channels_lock);\n\n\treturn 0;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142121,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "int ppp_register_net_channel(struct net *net, struct ppp_channel *chan)\n{\n\tstruct channel *pch;\n\tstruct ppp_net *pn;\n\n\tpch = kzalloc(sizeof(struct channel), GFP_KERNEL);\n\tif (!pch)\n\t\treturn -ENOMEM;\n\n\tpn = ppp_pernet(net);\n \n \tpch->ppp = NULL;\n \tpch->chan = chan;\n\tpch->chan_net = get_net(net);\n \tchan->ppp = pch;\n \tinit_ppp_file(&pch->file, CHANNEL);\n \tpch->file.hdrlen = chan->hdrlen;\n#ifdef CONFIG_PPP_MULTILINK\n\tpch->lastseq = -1;\n#endif /* CONFIG_PPP_MULTILINK */\n\tinit_rwsem(&pch->chan_sem);\n\tspin_lock_init(&pch->downl);\n\trwlock_init(&pch->upl);\n\n\tspin_lock_bh(&pn->all_channels_lock);\n\tpch->file.index = ++pn->last_channel_index;\n\tlist_add(&pch->list, &pn->new_channels);\n\tatomic_inc(&channel_count);\n\tspin_unlock_bh(&pn->all_channels_lock);\n\n\treturn 0;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142122,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "ppp_unregister_channel(struct ppp_channel *chan)\n{\n\tstruct channel *pch = chan->ppp;\n\tstruct ppp_net *pn;\n\n\tif (!pch)\n\t\treturn;\t\t/* should never happen */\n\n\tchan->ppp = NULL;\n\n\t/*\n\t * This ensures that we have returned from any calls into the\n\t * the channel's start_xmit or ioctl routine before we proceed.\n\t */\n\tdown_write(&pch->chan_sem);\n\tspin_lock_bh(&pch->downl);\n\tpch->chan = NULL;\n\tspin_unlock_bh(&pch->downl);\n\tup_write(&pch->chan_sem);\n\tppp_disconnect_channel(pch);\n\n\tpn = ppp_pernet(pch->chan_net);\n \tspin_lock_bh(&pn->all_channels_lock);\n \tlist_del(&pch->list);\n \tspin_unlock_bh(&pn->all_channels_lock);\n \n \tpch->file.dead = 1;\n \twake_up_interruptible(&pch->file.rwait);\n\tif (atomic_dec_and_test(&pch->file.refcnt))\n\t\tppp_destroy_channel(pch);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142123,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "ppp_unregister_channel(struct ppp_channel *chan)\n{\n\tstruct channel *pch = chan->ppp;\n\tstruct ppp_net *pn;\n\n\tif (!pch)\n\t\treturn;\t\t/* should never happen */\n\n\tchan->ppp = NULL;\n\n\t/*\n\t * This ensures that we have returned from any calls into the\n\t * the channel's start_xmit or ioctl routine before we proceed.\n\t */\n\tdown_write(&pch->chan_sem);\n\tspin_lock_bh(&pch->downl);\n\tpch->chan = NULL;\n\tspin_unlock_bh(&pch->downl);\n\tup_write(&pch->chan_sem);\n\tppp_disconnect_channel(pch);\n\n\tpn = ppp_pernet(pch->chan_net);\n \tspin_lock_bh(&pn->all_channels_lock);\n \tlist_del(&pch->list);\n \tspin_unlock_bh(&pn->all_channels_lock);\n\tput_net(pch->chan_net);\n\tpch->chan_net = NULL;\n \n \tpch->file.dead = 1;\n \twake_up_interruptible(&pch->file.rwait);\n\tif (atomic_dec_and_test(&pch->file.refcnt))\n\t\tppp_destroy_channel(pch);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142124,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "int __ext4_journal_stop(const char *where, unsigned int line, handle_t *handle)\n{\n\tstruct super_block *sb;\n\tint err;\n\tint rc;\n\n\tif (!ext4_handle_valid(handle)) {\n\t\text4_put_nojournal(handle);\n \t\treturn 0;\n \t}\n \n \tif (!handle->h_transaction) {\n\t\terr = jbd2_journal_stop(handle);\n\t\treturn handle->h_err ? handle->h_err : err;\n \t}\n \n \tsb = handle->h_transaction->t_journal->j_private;\n\terr = handle->h_err;\n \trc = jbd2_journal_stop(handle);\n \n \tif (!err)\n\t\terr = rc;\n\tif (err)\n\t\t__ext4_std_error(sb, where, line, err);\n\treturn err;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142201,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "int __ext4_journal_stop(const char *where, unsigned int line, handle_t *handle)\n{\n\tstruct super_block *sb;\n\tint err;\n\tint rc;\n\n\tif (!ext4_handle_valid(handle)) {\n\t\text4_put_nojournal(handle);\n \t\treturn 0;\n \t}\n \n\terr = handle->h_err;\n \tif (!handle->h_transaction) {\n\t\trc = jbd2_journal_stop(handle);\n\t\treturn err ? err : rc;\n \t}\n \n \tsb = handle->h_transaction->t_journal->j_private;\n \trc = jbd2_journal_stop(handle);\n \n \tif (!err)\n\t\terr = rc;\n\tif (err)\n\t\t__ext4_std_error(sb, where, line, err);\n\treturn err;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142202,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": " void HTML_put_string(HTStructured * me, const char *s)\n {\n #ifdef USE_PRETTYSRC\n     char *translated_string = NULL;\n #endif\n\n    if (s == NULL || (LYMapsOnly && me->sp[0].tag_number != HTML_OBJECT))\n\treturn;\n#ifdef USE_PRETTYSRC\n    if (psrc_convert_string) {\n\tStrAllocCopy(translated_string, s);\n\tTRANSLATE_AND_UNESCAPE_ENTITIES(&translated_string, TRUE, FALSE);\n\ts = (const char *) translated_string;\n    }\n#endif\n\n    switch (me->sp[0].tag_number) {\n\n    case HTML_COMMENT:\n \tbreak;\t\t\t/* Do Nothing */\n \n     case HTML_TITLE:\n\tHTChunkPuts(&me->title, s);\n \tbreak;\n \n     case HTML_STYLE:\n\tHTChunkPuts(&me->style_block, s);\n \tbreak;\n \n     case HTML_SCRIPT:\n\tHTChunkPuts(&me->script, s);\n \tbreak;\n \n     case HTML_PRE:\t\t/* Formatted text */\n    case HTML_LISTING:\t\t/* Literal text */\n    case HTML_XMP:\n    case HTML_PLAINTEXT:\n\t/*\n\t * We guarantee that the style is up-to-date in begin_litteral\n\t */\n\tHText_appendText(me->text, s);\n \tbreak;\n \n     case HTML_OBJECT:\n\tHTChunkPuts(&me->object, s);\n \tbreak;\n \n     case HTML_TEXTAREA:\n\tHTChunkPuts(&me->textarea, s);\n \tbreak;\n \n     case HTML_SELECT:\n     case HTML_OPTION:\n\tHTChunkPuts(&me->option, s);\n \tbreak;\n \n     case HTML_MATH:\n\tHTChunkPuts(&me->math, s);\n \tbreak;\n \n     default:\t\t\t/* Free format text? */\n\tif (!me->sp->style->freeFormat) {\n\t    /*\n\t     * If we are within a preformatted text style not caught by the\n\t     * cases above (HTML_PRE or similar may not be the last element\n\t     * pushed on the style stack).  - kw\n\t     */\n#ifdef USE_PRETTYSRC\n\t    if (psrc_view) {\n\t\t/*\n\t\t * We do this so that a raw '\\r' in the string will not be\n\t\t * interpreted as an internal request to break a line - passing\n\t\t * '\\r' to HText_appendText is treated by it as a request to\n\t\t * insert a blank line - VH\n\t\t */\n\t\tfor (; *s; ++s)\n\t\t    HTML_put_character(me, *s);\n\t    } else\n#endif\n\t\tHText_appendText(me->text, s);\n\t    break;\n\t} else {\n\t    const char *p = s;\n\t    char c;\n\n\t    if (me->style_change) {\n\t\tfor (; *p && ((*p == '\\n') || (*p == '\\r') ||\n\t\t\t      (*p == ' ') || (*p == '\\t')); p++) ;\t/* Ignore leaders */\n\t\tif (!*p)\n\t\t    break;\n\t\tUPDATE_STYLE;\n\t    }\n\t    for (; *p; p++) {\n\t\tif (*p == 13 && p[1] != 10) {\n\t\t    /*\n\t\t     * Treat any '\\r' which is not followed by '\\n' as '\\n', to\n\t\t     * account for macintosh lineend in ALT attributes etc.  -\n\t\t     * kw\n\t\t     */\n\t\t    c = '\\n';\n\t\t} else {\n\t\t    c = *p;\n\t\t}\n\t\tif (me->style_change) {\n\t\t    if ((c == '\\n') || (c == ' ') || (c == '\\t'))\n\t\t\tcontinue;\t/* Ignore it */\n\t\t    UPDATE_STYLE;\n\t\t}\n\t\tif (c == '\\n') {\n\t\t    if (!FIX_JAPANESE_SPACES) {\n\t\t\tif (me->in_word) {\n\t\t\t    if (HText_getLastChar(me->text) != ' ')\n\t\t\t\tHText_appendCharacter(me->text, ' ');\n\t\t\t    me->in_word = NO;\n\t\t\t}\n\t\t    }\n\n\t\t} else if (c == ' ' || c == '\\t') {\n\t\t    if (HText_getLastChar(me->text) != ' ')\n\t\t\tHText_appendCharacter(me->text, ' ');\n\n\t\t} else if (c == '\\r') {\n\t\t    /* ignore */\n\t\t} else {\n\t\t    HText_appendCharacter(me->text, c);\n\t\t    me->in_word = YES;\n\t\t}\n\n\t\t/* set the Last Character */\n\t\tif (c == '\\n' || c == '\\t') {\n\t\t    /* set it to a generic separator */\n\t\t    HText_setLastChar(me->text, ' ');\n\t\t} else if (c == '\\r' &&\n\t\t\t   HText_getLastChar(me->text) == ' ') {\n\t\t    /*\n\t\t     * \\r's are ignored.  In order to keep collapsing spaces\n\t\t     * correctly, we must default back to the previous\n\t\t     * separator, if there was one.  So we set LastChar to a\n\t\t     * generic separator.\n\t\t     */\n\t\t    HText_setLastChar(me->text, ' ');\n\t\t} else {\n\t\t    HText_setLastChar(me->text, c);\n\t\t}\n\n \t    }\t\t\t/* for */\n \t}\n     }\t\t\t\t/* end switch */\n #ifdef USE_PRETTYSRC\n     if (psrc_convert_string) {\n \tpsrc_convert_string = FALSE;\n\tFREE(translated_string);\n    }\n#endif\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142251,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": " void HTML_put_string(HTStructured * me, const char *s)\n {\n    HTChunk *target = NULL;\n\n #ifdef USE_PRETTYSRC\n     char *translated_string = NULL;\n #endif\n\n    if (s == NULL || (LYMapsOnly && me->sp[0].tag_number != HTML_OBJECT))\n\treturn;\n#ifdef USE_PRETTYSRC\n    if (psrc_convert_string) {\n\tStrAllocCopy(translated_string, s);\n\tTRANSLATE_AND_UNESCAPE_ENTITIES(&translated_string, TRUE, FALSE);\n\ts = (const char *) translated_string;\n    }\n#endif\n\n    switch (me->sp[0].tag_number) {\n\n    case HTML_COMMENT:\n \tbreak;\t\t\t/* Do Nothing */\n \n     case HTML_TITLE:\n\ttarget = &me->title;\n \tbreak;\n \n     case HTML_STYLE:\n\ttarget = &me->style_block;\n \tbreak;\n \n     case HTML_SCRIPT:\n\ttarget = &me->script;\n \tbreak;\n \n     case HTML_PRE:\t\t/* Formatted text */\n    case HTML_LISTING:\t\t/* Literal text */\n    case HTML_XMP:\n    case HTML_PLAINTEXT:\n\t/*\n\t * We guarantee that the style is up-to-date in begin_litteral\n\t */\n\tHText_appendText(me->text, s);\n \tbreak;\n \n     case HTML_OBJECT:\n\ttarget = &me->object;\n \tbreak;\n \n     case HTML_TEXTAREA:\n\ttarget = &me->textarea;\n \tbreak;\n \n     case HTML_SELECT:\n     case HTML_OPTION:\n\ttarget = &me->option;\n \tbreak;\n \n     case HTML_MATH:\n\ttarget = &me->math;\n \tbreak;\n \n     default:\t\t\t/* Free format text? */\n\tif (!me->sp->style->freeFormat) {\n\t    /*\n\t     * If we are within a preformatted text style not caught by the\n\t     * cases above (HTML_PRE or similar may not be the last element\n\t     * pushed on the style stack).  - kw\n\t     */\n#ifdef USE_PRETTYSRC\n\t    if (psrc_view) {\n\t\t/*\n\t\t * We do this so that a raw '\\r' in the string will not be\n\t\t * interpreted as an internal request to break a line - passing\n\t\t * '\\r' to HText_appendText is treated by it as a request to\n\t\t * insert a blank line - VH\n\t\t */\n\t\tfor (; *s; ++s)\n\t\t    HTML_put_character(me, *s);\n\t    } else\n#endif\n\t\tHText_appendText(me->text, s);\n\t    break;\n\t} else {\n\t    const char *p = s;\n\t    char c;\n\n\t    if (me->style_change) {\n\t\tfor (; *p && ((*p == '\\n') || (*p == '\\r') ||\n\t\t\t      (*p == ' ') || (*p == '\\t')); p++) ;\t/* Ignore leaders */\n\t\tif (!*p)\n\t\t    break;\n\t\tUPDATE_STYLE;\n\t    }\n\t    for (; *p; p++) {\n\t\tif (*p == 13 && p[1] != 10) {\n\t\t    /*\n\t\t     * Treat any '\\r' which is not followed by '\\n' as '\\n', to\n\t\t     * account for macintosh lineend in ALT attributes etc.  -\n\t\t     * kw\n\t\t     */\n\t\t    c = '\\n';\n\t\t} else {\n\t\t    c = *p;\n\t\t}\n\t\tif (me->style_change) {\n\t\t    if ((c == '\\n') || (c == ' ') || (c == '\\t'))\n\t\t\tcontinue;\t/* Ignore it */\n\t\t    UPDATE_STYLE;\n\t\t}\n\t\tif (c == '\\n') {\n\t\t    if (!FIX_JAPANESE_SPACES) {\n\t\t\tif (me->in_word) {\n\t\t\t    if (HText_getLastChar(me->text) != ' ')\n\t\t\t\tHText_appendCharacter(me->text, ' ');\n\t\t\t    me->in_word = NO;\n\t\t\t}\n\t\t    }\n\n\t\t} else if (c == ' ' || c == '\\t') {\n\t\t    if (HText_getLastChar(me->text) != ' ')\n\t\t\tHText_appendCharacter(me->text, ' ');\n\n\t\t} else if (c == '\\r') {\n\t\t    /* ignore */\n\t\t} else {\n\t\t    HText_appendCharacter(me->text, c);\n\t\t    me->in_word = YES;\n\t\t}\n\n\t\t/* set the Last Character */\n\t\tif (c == '\\n' || c == '\\t') {\n\t\t    /* set it to a generic separator */\n\t\t    HText_setLastChar(me->text, ' ');\n\t\t} else if (c == '\\r' &&\n\t\t\t   HText_getLastChar(me->text) == ' ') {\n\t\t    /*\n\t\t     * \\r's are ignored.  In order to keep collapsing spaces\n\t\t     * correctly, we must default back to the previous\n\t\t     * separator, if there was one.  So we set LastChar to a\n\t\t     * generic separator.\n\t\t     */\n\t\t    HText_setLastChar(me->text, ' ');\n\t\t} else {\n\t\t    HText_setLastChar(me->text, c);\n\t\t}\n\n \t    }\t\t\t/* for */\n \t}\n     }\t\t\t\t/* end switch */\n\n    if (target != NULL) {\n\tif (target->data == s) {\n\t    CTRACE((tfp, \"BUG: appending chunk to itself: `%.*s'\\n\",\n\t\t    target->size, target->data));\n\t} else {\n\t    HTChunkPuts(target, s);\n\t}\n    }\n #ifdef USE_PRETTYSRC\n     if (psrc_convert_string) {\n \tpsrc_convert_string = FALSE;\n\tFREE(translated_string);\n    }\n#endif\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142252,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int snd_seq_device_dev_free(struct snd_device *device)\n {\n \tstruct snd_seq_device *dev = device->device_data;\n \n \tput_device(&dev->dev);\n \treturn 0;\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142289,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int snd_seq_device_dev_disconnect(struct snd_device *device)\n{\n\tstruct snd_seq_device *dev = device->device_data;\n\n\tdevice_del(&dev->dev);\n\treturn 0;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142290,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int usb_console_setup(struct console *co, char *options)\n{\n\tstruct usbcons_info *info = &usbcons_info;\n\tint baud = 9600;\n\tint bits = 8;\n\tint parity = 'n';\n\tint doflow = 0;\n\tint cflag = CREAD | HUPCL | CLOCAL;\n\tchar *s;\n\tstruct usb_serial *serial;\n\tstruct usb_serial_port *port;\n\tint retval;\n\tstruct tty_struct *tty = NULL;\n\tstruct ktermios dummy;\n\n\tif (options) {\n\t\tbaud = simple_strtoul(options, NULL, 10);\n\t\ts = options;\n\t\twhile (*s >= '0' && *s <= '9')\n\t\t\ts++;\n\t\tif (*s)\n\t\t\tparity = *s++;\n\t\tif (*s)\n\t\t\tbits   = *s++ - '0';\n\t\tif (*s)\n\t\t\tdoflow = (*s++ == 'r');\n\t}\n\t\n\t/* Sane default */\n\tif (baud == 0)\n\t\tbaud = 9600;\n\n\tswitch (bits) {\n\tcase 7:\n\t\tcflag |= CS7;\n\t\tbreak;\n\tdefault:\n\tcase 8:\n\t\tcflag |= CS8;\n\t\tbreak;\n\t}\n\tswitch (parity) {\n\tcase 'o': case 'O':\n\t\tcflag |= PARODD;\n\t\tbreak;\n\tcase 'e': case 'E':\n\t\tcflag |= PARENB;\n\t\tbreak;\n\t}\n\tco->cflag = cflag;\n\n\t/*\n\t * no need to check the index here: if the index is wrong, console\n\t * code won't call us\n\t */\n\tport = usb_serial_port_get_by_minor(co->index);\n\tif (port == NULL) {\n\t\t/* no device is connected yet, sorry :( */\n\t\tpr_err(\"No USB device connected to ttyUSB%i\\n\", co->index);\n\t\treturn -ENODEV;\n\t}\n\tserial = port->serial;\n\n\tretval = usb_autopm_get_interface(serial->interface);\n\tif (retval)\n\t\tgoto error_get_interface;\n\n\ttty_port_tty_set(&port->port, NULL);\n\n\tinfo->port = port;\n\n\t++port->port.count;\n\tif (!tty_port_initialized(&port->port)) {\n\t\tif (serial->type->set_termios) {\n\t\t\t/*\n\t\t\t * allocate a fake tty so the driver can initialize\n\t\t\t * the termios structure, then later call set_termios to\n\t\t\t * configure according to command line arguments\n\t\t\t */\n\t\t\ttty = kzalloc(sizeof(*tty), GFP_KERNEL);\n\t\t\tif (!tty) {\n\t\t\t\tretval = -ENOMEM;\n\t\t\t\tgoto reset_open_count;\n\t\t\t}\n\t\t\tkref_init(&tty->kref);\n\t\t\ttty->driver = usb_serial_tty_driver;\n\t\t\ttty->index = co->index;\n\t\t\tinit_ldsem(&tty->ldisc_sem);\n\t\t\tspin_lock_init(&tty->files_lock);\n\t\t\tINIT_LIST_HEAD(&tty->tty_files);\n\t\t\tkref_get(&tty->driver->kref);\n\t\t\t__module_get(tty->driver->owner);\n\t\t\ttty->ops = &usb_console_fake_tty_ops;\n\t\t\ttty_init_termios(tty);\n\t\t\ttty_port_tty_set(&port->port, tty);\n\t\t}\n\n\t\t/* only call the device specific open if this\n\t\t * is the first time the port is opened */\n\t\tretval = serial->type->open(NULL, port);\n\t\tif (retval) {\n\t\t\tdev_err(&port->dev, \"could not open USB console port\\n\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (serial->type->set_termios) {\n\t\t\ttty->termios.c_cflag = cflag;\n\t\t\ttty_termios_encode_baud_rate(&tty->termios, baud, baud);\n\t\t\tmemset(&dummy, 0, sizeof(struct ktermios));\n\t\t\tserial->type->set_termios(tty, port, &dummy);\n\n\t\t\ttty_port_tty_set(&port->port, NULL);\n\t\t\ttty_kref_put(tty);\n\t\t}\n\t\ttty_port_set_initialized(&port->port, 1);\n\t}\n\t/* Now that any required fake tty operations are completed restore\n\t * the tty port count */\n\t--port->port.count;\n\t/* The console is special in terms of closing the device so\n\t * indicate this port is now acting as a system console. */\n\tport->port.console = 1;\n\n\tmutex_unlock(&serial->disc_mutex);\n\treturn retval;\n\n fail:\n\ttty_port_tty_set(&port->port, NULL);\n \ttty_kref_put(tty);\n  reset_open_count:\n \tport->port.count = 0;\n \tusb_autopm_put_interface(serial->interface);\n  error_get_interface:\n \tusb_serial_put(serial);\n\tmutex_unlock(&serial->disc_mutex);\n\treturn retval;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142291,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int usb_console_setup(struct console *co, char *options)\n{\n\tstruct usbcons_info *info = &usbcons_info;\n\tint baud = 9600;\n\tint bits = 8;\n\tint parity = 'n';\n\tint doflow = 0;\n\tint cflag = CREAD | HUPCL | CLOCAL;\n\tchar *s;\n\tstruct usb_serial *serial;\n\tstruct usb_serial_port *port;\n\tint retval;\n\tstruct tty_struct *tty = NULL;\n\tstruct ktermios dummy;\n\n\tif (options) {\n\t\tbaud = simple_strtoul(options, NULL, 10);\n\t\ts = options;\n\t\twhile (*s >= '0' && *s <= '9')\n\t\t\ts++;\n\t\tif (*s)\n\t\t\tparity = *s++;\n\t\tif (*s)\n\t\t\tbits   = *s++ - '0';\n\t\tif (*s)\n\t\t\tdoflow = (*s++ == 'r');\n\t}\n\t\n\t/* Sane default */\n\tif (baud == 0)\n\t\tbaud = 9600;\n\n\tswitch (bits) {\n\tcase 7:\n\t\tcflag |= CS7;\n\t\tbreak;\n\tdefault:\n\tcase 8:\n\t\tcflag |= CS8;\n\t\tbreak;\n\t}\n\tswitch (parity) {\n\tcase 'o': case 'O':\n\t\tcflag |= PARODD;\n\t\tbreak;\n\tcase 'e': case 'E':\n\t\tcflag |= PARENB;\n\t\tbreak;\n\t}\n\tco->cflag = cflag;\n\n\t/*\n\t * no need to check the index here: if the index is wrong, console\n\t * code won't call us\n\t */\n\tport = usb_serial_port_get_by_minor(co->index);\n\tif (port == NULL) {\n\t\t/* no device is connected yet, sorry :( */\n\t\tpr_err(\"No USB device connected to ttyUSB%i\\n\", co->index);\n\t\treturn -ENODEV;\n\t}\n\tserial = port->serial;\n\n\tretval = usb_autopm_get_interface(serial->interface);\n\tif (retval)\n\t\tgoto error_get_interface;\n\n\ttty_port_tty_set(&port->port, NULL);\n\n\tinfo->port = port;\n\n\t++port->port.count;\n\tif (!tty_port_initialized(&port->port)) {\n\t\tif (serial->type->set_termios) {\n\t\t\t/*\n\t\t\t * allocate a fake tty so the driver can initialize\n\t\t\t * the termios structure, then later call set_termios to\n\t\t\t * configure according to command line arguments\n\t\t\t */\n\t\t\ttty = kzalloc(sizeof(*tty), GFP_KERNEL);\n\t\t\tif (!tty) {\n\t\t\t\tretval = -ENOMEM;\n\t\t\t\tgoto reset_open_count;\n\t\t\t}\n\t\t\tkref_init(&tty->kref);\n\t\t\ttty->driver = usb_serial_tty_driver;\n\t\t\ttty->index = co->index;\n\t\t\tinit_ldsem(&tty->ldisc_sem);\n\t\t\tspin_lock_init(&tty->files_lock);\n\t\t\tINIT_LIST_HEAD(&tty->tty_files);\n\t\t\tkref_get(&tty->driver->kref);\n\t\t\t__module_get(tty->driver->owner);\n\t\t\ttty->ops = &usb_console_fake_tty_ops;\n\t\t\ttty_init_termios(tty);\n\t\t\ttty_port_tty_set(&port->port, tty);\n\t\t}\n\n\t\t/* only call the device specific open if this\n\t\t * is the first time the port is opened */\n\t\tretval = serial->type->open(NULL, port);\n\t\tif (retval) {\n\t\t\tdev_err(&port->dev, \"could not open USB console port\\n\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (serial->type->set_termios) {\n\t\t\ttty->termios.c_cflag = cflag;\n\t\t\ttty_termios_encode_baud_rate(&tty->termios, baud, baud);\n\t\t\tmemset(&dummy, 0, sizeof(struct ktermios));\n\t\t\tserial->type->set_termios(tty, port, &dummy);\n\n\t\t\ttty_port_tty_set(&port->port, NULL);\n\t\t\ttty_kref_put(tty);\n\t\t}\n\t\ttty_port_set_initialized(&port->port, 1);\n\t}\n\t/* Now that any required fake tty operations are completed restore\n\t * the tty port count */\n\t--port->port.count;\n\t/* The console is special in terms of closing the device so\n\t * indicate this port is now acting as a system console. */\n\tport->port.console = 1;\n\n\tmutex_unlock(&serial->disc_mutex);\n\treturn retval;\n\n fail:\n\ttty_port_tty_set(&port->port, NULL);\n \ttty_kref_put(tty);\n  reset_open_count:\n \tport->port.count = 0;\n\tinfo->port = NULL;\n \tusb_autopm_put_interface(serial->interface);\n  error_get_interface:\n \tusb_serial_put(serial);\n\tmutex_unlock(&serial->disc_mutex);\n\treturn retval;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142292,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int snd_seq_ioctl_create_port(struct snd_seq_client *client, void *arg)\n{\n \tstruct snd_seq_port_info *info = arg;\n \tstruct snd_seq_client_port *port;\n \tstruct snd_seq_port_callback *callback;\n \n \t/* it is not allowed to create the port for an another client */\n \tif (info->addr.client != client->number)\n\t\treturn -EPERM;\n\n\tport = snd_seq_create_port(client, (info->flags & SNDRV_SEQ_PORT_FLG_GIVEN_PORT) ? info->addr.port : -1);\n\tif (port == NULL)\n \t\treturn -ENOMEM;\n \n \tif (client->type == USER_CLIENT && info->kernel) {\n\t\tsnd_seq_delete_port(client, port->addr.port);\n \t\treturn -EINVAL;\n \t}\n \tif (client->type == KERNEL_CLIENT) {\n\t\tif ((callback = info->kernel) != NULL) {\n\t\t\tif (callback->owner)\n\t\t\t\tport->owner = callback->owner;\n\t\t\tport->private_data = callback->private_data;\n\t\t\tport->private_free = callback->private_free;\n\t\t\tport->event_input = callback->event_input;\n\t\t\tport->c_src.open = callback->subscribe;\n\t\t\tport->c_src.close = callback->unsubscribe;\n\t\t\tport->c_dest.open = callback->use;\n\t\t\tport->c_dest.close = callback->unuse;\n\t\t}\n\t}\n\n\tinfo->addr = port->addr;\n \n \tsnd_seq_set_port_info(port, info);\n \tsnd_seq_system_client_ev_port_start(port->addr.client, port->addr.port);\n \n \treturn 0;\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142311,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int snd_seq_ioctl_create_port(struct snd_seq_client *client, void *arg)\n{\n \tstruct snd_seq_port_info *info = arg;\n \tstruct snd_seq_client_port *port;\n \tstruct snd_seq_port_callback *callback;\n\tint port_idx;\n \n \t/* it is not allowed to create the port for an another client */\n \tif (info->addr.client != client->number)\n\t\treturn -EPERM;\n\n\tport = snd_seq_create_port(client, (info->flags & SNDRV_SEQ_PORT_FLG_GIVEN_PORT) ? info->addr.port : -1);\n\tif (port == NULL)\n \t\treturn -ENOMEM;\n \n \tif (client->type == USER_CLIENT && info->kernel) {\n\t\tport_idx = port->addr.port;\n\t\tsnd_seq_port_unlock(port);\n\t\tsnd_seq_delete_port(client, port_idx);\n \t\treturn -EINVAL;\n \t}\n \tif (client->type == KERNEL_CLIENT) {\n\t\tif ((callback = info->kernel) != NULL) {\n\t\t\tif (callback->owner)\n\t\t\t\tport->owner = callback->owner;\n\t\t\tport->private_data = callback->private_data;\n\t\t\tport->private_free = callback->private_free;\n\t\t\tport->event_input = callback->event_input;\n\t\t\tport->c_src.open = callback->subscribe;\n\t\t\tport->c_src.close = callback->unsubscribe;\n\t\t\tport->c_dest.open = callback->use;\n\t\t\tport->c_dest.close = callback->unuse;\n\t\t}\n\t}\n\n\tinfo->addr = port->addr;\n \n \tsnd_seq_set_port_info(port, info);\n \tsnd_seq_system_client_ev_port_start(port->addr.client, port->addr.port);\n\tsnd_seq_port_unlock(port);\n \n \treturn 0;\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142312,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": " struct snd_seq_client_port *snd_seq_create_port(struct snd_seq_client *client,\n \t\t\t\t\t\tint port)\n {\n\tunsigned long flags;\n\tstruct snd_seq_client_port *new_port, *p;\n\tint num = -1;\n\t\n\t/* sanity check */\n\tif (snd_BUG_ON(!client))\n\t\treturn NULL;\n\n\tif (client->num_ports >= SNDRV_SEQ_MAX_PORTS) {\n\t\tpr_warn(\"ALSA: seq: too many ports for client %d\\n\", client->number);\n\t\treturn NULL;\n\t}\n\n\t/* create a new port */\n\tnew_port = kzalloc(sizeof(*new_port), GFP_KERNEL);\n\tif (!new_port)\n\t\treturn NULL;\t/* failure, out of memory */\n\t/* init port data */\n\tnew_port->addr.client = client->number;\n\tnew_port->addr.port = -1;\n\tnew_port->owner = THIS_MODULE;\n\tsprintf(new_port->name, \"port-%d\", num);\n \tsnd_use_lock_init(&new_port->use_lock);\n \tport_subs_info_init(&new_port->c_src);\n \tport_subs_info_init(&new_port->c_dest);\n \n \tnum = port >= 0 ? port : 0;\n \tmutex_lock(&client->ports_mutex);\n\twrite_lock_irqsave(&client->ports_lock, flags);\n\tlist_for_each_entry(p, &client->ports_list_head, list) {\n\t\tif (p->addr.port > num)\n\t\t\tbreak;\n\t\tif (port < 0) /* auto-probe mode */\n\t\t\tnum = p->addr.port + 1;\n\t}\n\t/* insert the new port */\n \tlist_add_tail(&new_port->list, &p->list);\n \tclient->num_ports++;\n \tnew_port->addr.port = num;\t/* store the port number in the port */\n \twrite_unlock_irqrestore(&client->ports_lock, flags);\n \tmutex_unlock(&client->ports_mutex);\n\tsprintf(new_port->name, \"port-%d\", num);\n \n \treturn new_port;\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142313,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": " struct snd_seq_client_port *snd_seq_create_port(struct snd_seq_client *client,\n \t\t\t\t\t\tint port)\n {\n\tunsigned long flags;\n\tstruct snd_seq_client_port *new_port, *p;\n\tint num = -1;\n\t\n\t/* sanity check */\n\tif (snd_BUG_ON(!client))\n\t\treturn NULL;\n\n\tif (client->num_ports >= SNDRV_SEQ_MAX_PORTS) {\n\t\tpr_warn(\"ALSA: seq: too many ports for client %d\\n\", client->number);\n\t\treturn NULL;\n\t}\n\n\t/* create a new port */\n\tnew_port = kzalloc(sizeof(*new_port), GFP_KERNEL);\n\tif (!new_port)\n\t\treturn NULL;\t/* failure, out of memory */\n\t/* init port data */\n\tnew_port->addr.client = client->number;\n\tnew_port->addr.port = -1;\n\tnew_port->owner = THIS_MODULE;\n\tsprintf(new_port->name, \"port-%d\", num);\n \tsnd_use_lock_init(&new_port->use_lock);\n \tport_subs_info_init(&new_port->c_src);\n \tport_subs_info_init(&new_port->c_dest);\n\tsnd_use_lock_use(&new_port->use_lock);\n \n \tnum = port >= 0 ? port : 0;\n \tmutex_lock(&client->ports_mutex);\n\twrite_lock_irqsave(&client->ports_lock, flags);\n\tlist_for_each_entry(p, &client->ports_list_head, list) {\n\t\tif (p->addr.port > num)\n\t\t\tbreak;\n\t\tif (port < 0) /* auto-probe mode */\n\t\t\tnum = p->addr.port + 1;\n\t}\n\t/* insert the new port */\n \tlist_add_tail(&new_port->list, &p->list);\n \tclient->num_ports++;\n \tnew_port->addr.port = num;\t/* store the port number in the port */\n\tsprintf(new_port->name, \"port-%d\", num);\n \twrite_unlock_irqrestore(&client->ports_lock, flags);\n \tmutex_unlock(&client->ports_mutex);\n \n \treturn new_port;\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142314,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "int sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)\n{\n\tstruct sctp_association *asoc = sctp_id2assoc(sk, id);\n\tstruct sctp_sock *sp = sctp_sk(sk);\n \tstruct socket *sock;\n \tint err = 0;\n \n \tif (!asoc)\n \t\treturn -EINVAL;\n \n\t/* If there is a thread waiting on more sndbuf space for\n\t * sending on this asoc, it cannot be peeled.\n\t */\n\tif (waitqueue_active(&asoc->wait))\n\t\treturn -EBUSY;\n\n\t/* An association cannot be branched off from an already peeled-off\n\t * socket, nor is this supported for tcp style sockets.\n\t */\n\tif (!sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\t/* Create a new socket.  */\n\terr = sock_create(sk->sk_family, SOCK_SEQPACKET, IPPROTO_SCTP, &sock);\n\tif (err < 0)\n\t\treturn err;\n\n\tsctp_copy_sock(sock->sk, sk, asoc);\n\n\t/* Make peeled-off sockets more like 1-1 accepted sockets.\n\t * Set the daddr and initialize id to something more random\n\t */\n\tsp->pf->to_sk_daddr(&asoc->peer.primary_addr, sk);\n\n\t/* Populate the fields of the newsk from the oldsk and migrate the\n\t * asoc to the newsk.\n\t */\n\tsctp_sock_migrate(sk, sock->sk, asoc, SCTP_SOCKET_UDP_HIGH_BANDWIDTH);\n\n\t*sockp = sock;\n\n\treturn err;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142317,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "int sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)\n{\n\tstruct sctp_association *asoc = sctp_id2assoc(sk, id);\n\tstruct sctp_sock *sp = sctp_sk(sk);\n \tstruct socket *sock;\n \tint err = 0;\n \n\t/* Do not peel off from one netns to another one. */\n\tif (!net_eq(current->nsproxy->net_ns, sock_net(sk)))\n\t\treturn -EINVAL;\n\n \tif (!asoc)\n \t\treturn -EINVAL;\n \n\t/* If there is a thread waiting on more sndbuf space for\n\t * sending on this asoc, it cannot be peeled.\n\t */\n\tif (waitqueue_active(&asoc->wait))\n\t\treturn -EBUSY;\n\n\t/* An association cannot be branched off from an already peeled-off\n\t * socket, nor is this supported for tcp style sockets.\n\t */\n\tif (!sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\t/* Create a new socket.  */\n\terr = sock_create(sk->sk_family, SOCK_SEQPACKET, IPPROTO_SCTP, &sock);\n\tif (err < 0)\n\t\treturn err;\n\n\tsctp_copy_sock(sock->sk, sk, asoc);\n\n\t/* Make peeled-off sockets more like 1-1 accepted sockets.\n\t * Set the daddr and initialize id to something more random\n\t */\n\tsp->pf->to_sk_daddr(&asoc->peer.primary_addr, sk);\n\n\t/* Populate the fields of the newsk from the oldsk and migrate the\n\t * asoc to the newsk.\n\t */\n\tsctp_sock_migrate(sk, sock->sk, asoc, SCTP_SOCKET_UDP_HIGH_BANDWIDTH);\n\n\t*sockp = sock;\n\n\treturn err;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142318,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  register Quantum *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n  BlobInfo *blob;\n  size_t one;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\n\n  /*\n     Open image file.\n   */\n  image = AcquireImage(image_info,exception);\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  quantum_info=(QuantumInfo *) NULL;\n  clone_info=(ImageInfo *) NULL;\n  if (ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (strncmp(MATLAB_HDR.identific,\"MATLAB\",6) != 0)\n    {\n      image2=ReadMATImageV4(image_info,image,exception);\n      if (image2  == NULL)\n        goto MATLAB_KO;\n      image=image2;\n      goto END_OF_READING;\n    }\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if (logging)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\n      MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n    goto MATLAB_KO;    /* unsupported endian */\n\n  if (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\n    {\nMATLAB_KO:\n      if ((image != image2) && (image2 != (Image *) NULL))\n        image2=DestroyImage(image2);\n      if (clone_info != (ImageInfo *) NULL)\n        clone_info=DestroyImageInfo(clone_info);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n\n  filepos = TellBlob(image);\n  while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    (void) SeekBlob(image,filepos,SEEK_SET);\n    /* printf(\"pos=%X\\n\",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) > GetBlobSize(image))\n      goto MATLAB_KO;\n    filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n\n    clone_info=CloneImageInfo(image_info);\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif\n\n    if (MATLAB_HDR.DataType!=miMATRIX)\n      {\n        clone_info=DestroyImageInfo(clone_info);\n        continue;  /* skip another objects. */\n      }\n\n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n\n\n    switch(MATLAB_HDR.DimFlag)\n    {\n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           (void) ReadBlobXXXLong(image2);\n         if(z!=3) ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         break;\n      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n         if(z!=3 && z!=1)\n            ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         Frames = ReadBlobXXXLong(image2);\n         if (Frames == 0)\n           ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n         break;\n      default:\n        if (clone_info != (ImageInfo *) NULL)\n          clone_info=DestroyImageInfo(clone_info);\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n    }\n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n\n    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */\n\n    NEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;\n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {              /* complex float type cell */\n  }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64;\n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          ThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {                         /* complex double type cell */\n  }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        if (clone_info)\n          clone_info=DestroyImageInfo(clone_info);\n        ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;\n    one=1;\n    image->colors = one << image->depth;\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n    if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)\n      goto MATLAB_KO;\n    /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        image->type=GrayscaleType;\n        SetImageColorspace(image,GRAYColorspace,exception);\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      {\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        return(DestroyImageList(image));\n      }\n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  /* ----- Load raster data ----- */\n    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n    if (BImgBuff == NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));\n\n    MinVal = 0;\n    MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n  }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n    {\nImportQuantumPixelsFailed:\n      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n      break;\n    }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n      goto ImportQuantumPixelsFailed;\n\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n      FixSignedValues(image,q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n      }\n    } while(z-- >= 2);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          InsertComplexDoubleRow(image, (double *)BImgBuff, i, MinVal, MaxVal,\n            exception);\n  }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          InsertComplexFloatRow(image,(float *)BImgBuff,i,MinVal,MaxVal,\n            exception);\n  }\n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n\n      blob = rotated_image->blob;\n      rotated_image->blob = image->blob;\n      rotated_image->colors = image->colors;\n      image->blob = blob;\n      AppendImageToList(&image,rotated_image);\n      DeleteImageFromList(&image);\n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2);\n  if(clone_info)\n  {\n          if(clone_info->file)\n    {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n    }\n        }\n      }\n\n      /* Allocate next image structure. */\n    AcquireNextImage(image_info,image,exception);\n    if (image->next == (Image *) NULL) break;\n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;\n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      goto NEXT_FRAME;\n    }\n    if ((image2!=NULL) && (image2!=image))   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n          }\n        }\n        }\n\n    if (quantum_info != (QuantumInfo *) NULL)\n      quantum_info=DestroyQuantumInfo(quantum_info);\n    if (clone_info)\n      clone_info=DestroyImageInfo(clone_info);\n  }\n\n  RelinquishMagickMemory(BImgBuff);\n   if (quantum_info != (QuantumInfo *) NULL)\n     quantum_info=DestroyQuantumInfo(quantum_info);\n END_OF_READING:\n  if (clone_info)\n    clone_info=DestroyImageInfo(clone_info);\n   CloseBlob(image);\n \n \n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n         Image *tmp=p;\n         if ((p->rows == 0) || (p->columns == 0)) {\n           p=p->previous;\n           DeleteImageFromList(&tmp);\n         } else {\n           image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n  if (image==NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\")\n  else\n    if ((image != image2) && (image2 != (Image *) NULL))\n      image2=DestroyImage(image2);\n  return (image);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142449,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  register Quantum *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n  BlobInfo *blob;\n  size_t one;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\n\n  /*\n     Open image file.\n   */\n  image = AcquireImage(image_info,exception);\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  quantum_info=(QuantumInfo *) NULL;\n  clone_info=(ImageInfo *) NULL;\n  if (ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (strncmp(MATLAB_HDR.identific,\"MATLAB\",6) != 0)\n    {\n      image2=ReadMATImageV4(image_info,image,exception);\n      if (image2  == NULL)\n        goto MATLAB_KO;\n      image=image2;\n      goto END_OF_READING;\n    }\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if (logging)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\n      MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n    goto MATLAB_KO;    /* unsupported endian */\n\n  if (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\n    {\nMATLAB_KO:\n      if ((image != image2) && (image2 != (Image *) NULL))\n        image2=DestroyImage(image2);\n      if (clone_info != (ImageInfo *) NULL)\n        clone_info=DestroyImageInfo(clone_info);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n\n  filepos = TellBlob(image);\n  while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    (void) SeekBlob(image,filepos,SEEK_SET);\n    /* printf(\"pos=%X\\n\",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) > GetBlobSize(image))\n      goto MATLAB_KO;\n    filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n\n    clone_info=CloneImageInfo(image_info);\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif\n\n    if (MATLAB_HDR.DataType!=miMATRIX)\n      {\n        clone_info=DestroyImageInfo(clone_info);\n        continue;  /* skip another objects. */\n      }\n\n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n\n\n    switch(MATLAB_HDR.DimFlag)\n    {\n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           (void) ReadBlobXXXLong(image2);\n         if(z!=3) ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         break;\n      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n         if(z!=3 && z!=1)\n            ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         Frames = ReadBlobXXXLong(image2);\n         if (Frames == 0)\n           ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n         break;\n      default:\n        if (clone_info != (ImageInfo *) NULL)\n          clone_info=DestroyImageInfo(clone_info);\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n    }\n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n\n    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */\n\n    NEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;\n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {              /* complex float type cell */\n  }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64;\n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          ThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {                         /* complex double type cell */\n  }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        if (clone_info)\n          clone_info=DestroyImageInfo(clone_info);\n        ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;\n    one=1;\n    image->colors = one << image->depth;\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n    if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)\n      goto MATLAB_KO;\n    /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        image->type=GrayscaleType;\n        SetImageColorspace(image,GRAYColorspace,exception);\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      {\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        return(DestroyImageList(image));\n      }\n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  /* ----- Load raster data ----- */\n    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n    if (BImgBuff == NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));\n\n    MinVal = 0;\n    MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n  }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n    {\nImportQuantumPixelsFailed:\n      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n      break;\n    }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n      goto ImportQuantumPixelsFailed;\n\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n      FixSignedValues(image,q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n      }\n    } while(z-- >= 2);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          InsertComplexDoubleRow(image, (double *)BImgBuff, i, MinVal, MaxVal,\n            exception);\n  }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          InsertComplexFloatRow(image,(float *)BImgBuff,i,MinVal,MaxVal,\n            exception);\n  }\n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n\n      blob = rotated_image->blob;\n      rotated_image->blob = image->blob;\n      rotated_image->colors = image->colors;\n      image->blob = blob;\n      AppendImageToList(&image,rotated_image);\n      DeleteImageFromList(&image);\n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2);\n  if(clone_info)\n  {\n          if(clone_info->file)\n    {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n    }\n        }\n      }\n\n      /* Allocate next image structure. */\n    AcquireNextImage(image_info,image,exception);\n    if (image->next == (Image *) NULL) break;\n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;\n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      goto NEXT_FRAME;\n    }\n    if ((image2!=NULL) && (image2!=image))   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n          }\n        }\n        }\n\n    if (quantum_info != (QuantumInfo *) NULL)\n      quantum_info=DestroyQuantumInfo(quantum_info);\n    if (clone_info)\n      clone_info=DestroyImageInfo(clone_info);\n  }\n\n  RelinquishMagickMemory(BImgBuff);\n   if (quantum_info != (QuantumInfo *) NULL)\n     quantum_info=DestroyQuantumInfo(quantum_info);\n END_OF_READING:\n   CloseBlob(image);\n \n \n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n         Image *tmp=p;\n         if ((p->rows == 0) || (p->columns == 0)) {\n           p=p->previous;\n          if (tmp == image2)\n            image2=(Image *) NULL;\n           DeleteImageFromList(&tmp);\n         } else {\n           image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n  if (image==NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\")\n  else\n    if ((image != image2) && (image2 != (Image *) NULL))\n      image2=DestroyImage(image2);\n  return (image);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142450,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int do_mq_notify(mqd_t mqdes, const struct sigevent *notification)\n{\n\tint ret;\n\tstruct fd f;\n\tstruct sock *sock;\n\tstruct inode *inode;\n\tstruct mqueue_inode_info *info;\n\tstruct sk_buff *nc;\n\n\taudit_mq_notify(mqdes, notification);\n\n\tnc = NULL;\n\tsock = NULL;\n\tif (notification != NULL) {\n\t\tif (unlikely(notification->sigev_notify != SIGEV_NONE &&\n\t\t\t     notification->sigev_notify != SIGEV_SIGNAL &&\n\t\t\t     notification->sigev_notify != SIGEV_THREAD))\n\t\t\treturn -EINVAL;\n\t\tif (notification->sigev_notify == SIGEV_SIGNAL &&\n\t\t\t!valid_signal(notification->sigev_signo)) {\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (notification->sigev_notify == SIGEV_THREAD) {\n\t\t\tlong timeo;\n\n\t\t\t/* create the notify skb */\n\t\t\tnc = alloc_skb(NOTIFY_COOKIE_LEN, GFP_KERNEL);\n\t\t\tif (!nc) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (copy_from_user(nc->data,\n\t\t\t\t\tnotification->sigev_value.sival_ptr,\n\t\t\t\t\tNOTIFY_COOKIE_LEN)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/* TODO: add a header? */\n\t\t\tskb_put(nc, NOTIFY_COOKIE_LEN);\n\t\t\t/* and attach it to the socket */\nretry:\n\t\t\tf = fdget(notification->sigev_signo);\n\t\t\tif (!f.file) {\n\t\t\t\tret = -EBADF;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tsock = netlink_getsockbyfilp(f.file);\n\t\t\tfdput(f);\n\t\t\tif (IS_ERR(sock)) {\n\t\t\t\tret = PTR_ERR(sock);\n\t\t\t\tsock = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n \n \t\t\ttimeo = MAX_SCHEDULE_TIMEOUT;\n \t\t\tret = netlink_attachskb(sock, nc, &timeo, NULL);\n\t\t\tif (ret == 1)\n \t\t\t\tgoto retry;\n \t\t\tif (ret) {\n \t\t\t\tsock = NULL;\n \t\t\t\tnc = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tf = fdget(mqdes);\n\tif (!f.file) {\n\t\tret = -EBADF;\n\t\tgoto out;\n\t}\n\n\tinode = file_inode(f.file);\n\tif (unlikely(f.file->f_op != &mqueue_file_operations)) {\n\t\tret = -EBADF;\n\t\tgoto out_fput;\n\t}\n\tinfo = MQUEUE_I(inode);\n\n\tret = 0;\n\tspin_lock(&info->lock);\n\tif (notification == NULL) {\n\t\tif (info->notify_owner == task_tgid(current)) {\n\t\t\tremove_notification(info);\n\t\t\tinode->i_atime = inode->i_ctime = current_time(inode);\n\t\t}\n\t} else if (info->notify_owner != NULL) {\n\t\tret = -EBUSY;\n\t} else {\n\t\tswitch (notification->sigev_notify) {\n\t\tcase SIGEV_NONE:\n\t\t\tinfo->notify.sigev_notify = SIGEV_NONE;\n\t\t\tbreak;\n\t\tcase SIGEV_THREAD:\n\t\t\tinfo->notify_sock = sock;\n\t\t\tinfo->notify_cookie = nc;\n\t\t\tsock = NULL;\n\t\t\tnc = NULL;\n\t\t\tinfo->notify.sigev_notify = SIGEV_THREAD;\n\t\t\tbreak;\n\t\tcase SIGEV_SIGNAL:\n\t\t\tinfo->notify.sigev_signo = notification->sigev_signo;\n\t\t\tinfo->notify.sigev_value = notification->sigev_value;\n\t\t\tinfo->notify.sigev_notify = SIGEV_SIGNAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tinfo->notify_owner = get_pid(task_tgid(current));\n\t\tinfo->notify_user_ns = get_user_ns(current_user_ns());\n\t\tinode->i_atime = inode->i_ctime = current_time(inode);\n\t}\n\tspin_unlock(&info->lock);\nout_fput:\n\tfdput(f);\nout:\n\tif (sock)\n\t\tnetlink_detachskb(sock, nc);\n\telse if (nc)\n\t\tdev_kfree_skb(nc);\n\n\treturn ret;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142487,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int do_mq_notify(mqd_t mqdes, const struct sigevent *notification)\n{\n\tint ret;\n\tstruct fd f;\n\tstruct sock *sock;\n\tstruct inode *inode;\n\tstruct mqueue_inode_info *info;\n\tstruct sk_buff *nc;\n\n\taudit_mq_notify(mqdes, notification);\n\n\tnc = NULL;\n\tsock = NULL;\n\tif (notification != NULL) {\n\t\tif (unlikely(notification->sigev_notify != SIGEV_NONE &&\n\t\t\t     notification->sigev_notify != SIGEV_SIGNAL &&\n\t\t\t     notification->sigev_notify != SIGEV_THREAD))\n\t\t\treturn -EINVAL;\n\t\tif (notification->sigev_notify == SIGEV_SIGNAL &&\n\t\t\t!valid_signal(notification->sigev_signo)) {\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (notification->sigev_notify == SIGEV_THREAD) {\n\t\t\tlong timeo;\n\n\t\t\t/* create the notify skb */\n\t\t\tnc = alloc_skb(NOTIFY_COOKIE_LEN, GFP_KERNEL);\n\t\t\tif (!nc) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (copy_from_user(nc->data,\n\t\t\t\t\tnotification->sigev_value.sival_ptr,\n\t\t\t\t\tNOTIFY_COOKIE_LEN)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/* TODO: add a header? */\n\t\t\tskb_put(nc, NOTIFY_COOKIE_LEN);\n\t\t\t/* and attach it to the socket */\nretry:\n\t\t\tf = fdget(notification->sigev_signo);\n\t\t\tif (!f.file) {\n\t\t\t\tret = -EBADF;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tsock = netlink_getsockbyfilp(f.file);\n\t\t\tfdput(f);\n\t\t\tif (IS_ERR(sock)) {\n\t\t\t\tret = PTR_ERR(sock);\n\t\t\t\tsock = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n \n \t\t\ttimeo = MAX_SCHEDULE_TIMEOUT;\n \t\t\tret = netlink_attachskb(sock, nc, &timeo, NULL);\n\t\t\tif (ret == 1) {\n\t\t\t\tsock = NULL;\n \t\t\t\tgoto retry;\n\t\t\t}\n \t\t\tif (ret) {\n \t\t\t\tsock = NULL;\n \t\t\t\tnc = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tf = fdget(mqdes);\n\tif (!f.file) {\n\t\tret = -EBADF;\n\t\tgoto out;\n\t}\n\n\tinode = file_inode(f.file);\n\tif (unlikely(f.file->f_op != &mqueue_file_operations)) {\n\t\tret = -EBADF;\n\t\tgoto out_fput;\n\t}\n\tinfo = MQUEUE_I(inode);\n\n\tret = 0;\n\tspin_lock(&info->lock);\n\tif (notification == NULL) {\n\t\tif (info->notify_owner == task_tgid(current)) {\n\t\t\tremove_notification(info);\n\t\t\tinode->i_atime = inode->i_ctime = current_time(inode);\n\t\t}\n\t} else if (info->notify_owner != NULL) {\n\t\tret = -EBUSY;\n\t} else {\n\t\tswitch (notification->sigev_notify) {\n\t\tcase SIGEV_NONE:\n\t\t\tinfo->notify.sigev_notify = SIGEV_NONE;\n\t\t\tbreak;\n\t\tcase SIGEV_THREAD:\n\t\t\tinfo->notify_sock = sock;\n\t\t\tinfo->notify_cookie = nc;\n\t\t\tsock = NULL;\n\t\t\tnc = NULL;\n\t\t\tinfo->notify.sigev_notify = SIGEV_THREAD;\n\t\t\tbreak;\n\t\tcase SIGEV_SIGNAL:\n\t\t\tinfo->notify.sigev_signo = notification->sigev_signo;\n\t\t\tinfo->notify.sigev_value = notification->sigev_value;\n\t\t\tinfo->notify.sigev_notify = SIGEV_SIGNAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tinfo->notify_owner = get_pid(task_tgid(current));\n\t\tinfo->notify_user_ns = get_user_ns(current_user_ns());\n\t\tinode->i_atime = inode->i_ctime = current_time(inode);\n\t}\n\tspin_unlock(&info->lock);\nout_fput:\n\tfdput(f);\nout:\n\tif (sock)\n\t\tnetlink_detachskb(sock, nc);\n\telse if (nc)\n\t\tdev_kfree_skb(nc);\n\n\treturn ret;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142488,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "mark_context_stack(mrb_state *mrb, struct mrb_context *c)\n {\n   size_t i;\n   size_t e;\n \n   if (c->stack == NULL) return;\n   e = c->stack - c->stbase;\n  if (c->ci) e += c->ci->nregs;\n  if (c->stbase + e > c->stend) e = c->stend - c->stbase;\n  for (i=0; i<e; i++) {\n     mrb_value v = c->stbase[i];\n \n     if (!mrb_immediate_p(v)) {\n      if (mrb_basic_ptr(v)->tt == MRB_TT_FREE) {\n        c->stbase[i] = mrb_nil_value();\n      }\n      else {\n        mrb_gc_mark(mrb, mrb_basic_ptr(v));\n      }\n     }\n   }\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142519,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "mark_context_stack(mrb_state *mrb, struct mrb_context *c)\n {\n   size_t i;\n   size_t e;\n  mrb_value nil;\n \n   if (c->stack == NULL) return;\n   e = c->stack - c->stbase;\n  if (c->ci) e += c->ci->nregs;\n  if (c->stbase + e > c->stend) e = c->stend - c->stbase;\n  for (i=0; i<e; i++) {\n     mrb_value v = c->stbase[i];\n \n     if (!mrb_immediate_p(v)) {\n      mrb_gc_mark(mrb, mrb_basic_ptr(v));\n     }\n   }\n  e = c->stend - c->stbase;\n  nil = mrb_nil_value();\n  for (; i<e; i++) {\n    c->stbase[i] = nil;\n  }\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142520,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "R_API RConfigNode* r_config_set(RConfig *cfg, const char *name, const char *value) {\n\tRConfigNode *node = NULL;\n\tchar *ov = NULL;\n\tut64 oi;\n\tif (!cfg || STRNULL (name)) {\n\t\treturn NULL;\n\t}\n\tnode = r_config_node_get (cfg, name);\n\tif (node) {\n\t\tif (node->flags & CN_RO) {\n\t\t\teprintf (\"(error: '%s' config key is read only)\\n\", name);\n\t\t\treturn node;\n\t\t}\n\t\toi = node->i_value;\n\t\tif (node->value) {\n\t\t\tov = strdup (node->value);\n\t\t\tif (!ov) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t} else {\n\t\t\tfree (node->value);\n\t\t\tnode->value = strdup (\"\");\n\t\t}\n\t\tif (node->flags & CN_BOOL) {\n\t\t\tbool b = is_true (value);\n\t\t\tnode->i_value = (ut64) b? 1: 0;\n\t\t\tchar *value = strdup (r_str_bool (b));\n\t\t\tif (value) {\n\t\t\t\tfree (node->value);\n\t\t\t\tnode->value = value;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!value) {\n\t\t\t\tfree (node->value);\n\t\t\t\tnode->value = strdup (\"\");\n\t\t\t\tnode->i_value = 0;\n\t\t\t} else {\n \t\t\t\tif (node->value == value) {\n \t\t\t\t\tgoto beach;\n \t\t\t\t}\n\t\t\t\tfree (node->value);\n \t\t\t\tnode->value = strdup (value);\n \t\t\t\tif (IS_DIGIT (*value)) {\n \t\t\t\t\tif (strchr (value, '/')) {\n \t\t\t\t\t\tnode->i_value = r_num_get (cfg->num, value);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnode->i_value = r_num_math (cfg->num, value);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tnode->i_value = 0;\n\t\t\t\t}\n\t\t\t\tnode->flags |= CN_INT;\n\t\t\t}\n\t\t}\n\t} else { // Create a new RConfigNode\n\t\toi = UT64_MAX;\n\t\tif (!cfg->lock) {\n\t\t\tnode = r_config_node_new (name, value);\n\t\t\tif (node) {\n\t\t\t\tif (value && is_bool (value)) {\n\t\t\t\t\tnode->flags |= CN_BOOL;\n\t\t\t\t\tnode->i_value = is_true (value)? 1: 0;\n\t\t\t\t}\n\t\t\t\tif (cfg->ht) {\n\t\t\t\t\tht_insert (cfg->ht, node->name, node);\n\t\t\t\t\tr_list_append (cfg->nodes, node);\n\t\t\t\t\tcfg->n_nodes++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\teprintf (\"r_config_set: unable to create a new RConfigNode\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"r_config_set: variable '%s' not found\\n\", name);\n\t\t}\n\t}\n\n\tif (node && node->setter) {\n\t\tint ret = node->setter (cfg->user, node);\n\t\tif (ret == false) {\n\t\t\tif (oi != UT64_MAX) {\n\t\t\t\tnode->i_value = oi;\n\t\t\t}\n\t\t\tfree (node->value);\n\t\t\tnode->value = strdup (ov? ov: \"\");\n\t\t}\n\t}\nbeach:\n\tfree (ov);\n\treturn node;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142521,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "R_API RConfigNode* r_config_set(RConfig *cfg, const char *name, const char *value) {\n\tRConfigNode *node = NULL;\n\tchar *ov = NULL;\n\tut64 oi;\n\tif (!cfg || STRNULL (name)) {\n\t\treturn NULL;\n\t}\n\tnode = r_config_node_get (cfg, name);\n\tif (node) {\n\t\tif (node->flags & CN_RO) {\n\t\t\teprintf (\"(error: '%s' config key is read only)\\n\", name);\n\t\t\treturn node;\n\t\t}\n\t\toi = node->i_value;\n\t\tif (node->value) {\n\t\t\tov = strdup (node->value);\n\t\t\tif (!ov) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t} else {\n\t\t\tfree (node->value);\n\t\t\tnode->value = strdup (\"\");\n\t\t}\n\t\tif (node->flags & CN_BOOL) {\n\t\t\tbool b = is_true (value);\n\t\t\tnode->i_value = (ut64) b? 1: 0;\n\t\t\tchar *value = strdup (r_str_bool (b));\n\t\t\tif (value) {\n\t\t\t\tfree (node->value);\n\t\t\t\tnode->value = value;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!value) {\n\t\t\t\tfree (node->value);\n\t\t\t\tnode->value = strdup (\"\");\n\t\t\t\tnode->i_value = 0;\n\t\t\t} else {\n \t\t\t\tif (node->value == value) {\n \t\t\t\t\tgoto beach;\n \t\t\t\t}\n\t\t\t\tchar *tmp = node->value;\n \t\t\t\tnode->value = strdup (value);\n\t\t\t\tfree (tmp);\n \t\t\t\tif (IS_DIGIT (*value)) {\n \t\t\t\t\tif (strchr (value, '/')) {\n \t\t\t\t\t\tnode->i_value = r_num_get (cfg->num, value);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnode->i_value = r_num_math (cfg->num, value);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tnode->i_value = 0;\n\t\t\t\t}\n\t\t\t\tnode->flags |= CN_INT;\n\t\t\t}\n\t\t}\n\t} else { // Create a new RConfigNode\n\t\toi = UT64_MAX;\n\t\tif (!cfg->lock) {\n\t\t\tnode = r_config_node_new (name, value);\n\t\t\tif (node) {\n\t\t\t\tif (value && is_bool (value)) {\n\t\t\t\t\tnode->flags |= CN_BOOL;\n\t\t\t\t\tnode->i_value = is_true (value)? 1: 0;\n\t\t\t\t}\n\t\t\t\tif (cfg->ht) {\n\t\t\t\t\tht_insert (cfg->ht, node->name, node);\n\t\t\t\t\tr_list_append (cfg->nodes, node);\n\t\t\t\t\tcfg->n_nodes++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\teprintf (\"r_config_set: unable to create a new RConfigNode\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"r_config_set: variable '%s' not found\\n\", name);\n\t\t}\n\t}\n\n\tif (node && node->setter) {\n\t\tint ret = node->setter (cfg->user, node);\n\t\tif (ret == false) {\n\t\t\tif (oi != UT64_MAX) {\n\t\t\t\tnode->i_value = oi;\n\t\t\t}\n\t\t\tfree (node->value);\n\t\t\tnode->value = strdup (ov? ov: \"\");\n\t\t}\n\t}\nbeach:\n\tfree (ov);\n\treturn node;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142522,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int ipxitf_ioctl(unsigned int cmd, void __user *arg)\n{\n\tint rc = -EINVAL;\n\tstruct ifreq ifr;\n\tint val;\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR: {\n\t\tstruct sockaddr_ipx *sipx;\n\t\tstruct ipx_interface_definition f;\n\n\t\trc = -EFAULT;\n\t\tif (copy_from_user(&ifr, arg, sizeof(ifr)))\n\t\t\tbreak;\n\t\tsipx = (struct sockaddr_ipx *)&ifr.ifr_addr;\n\t\trc = -EINVAL;\n\t\tif (sipx->sipx_family != AF_IPX)\n\t\t\tbreak;\n\t\tf.ipx_network = sipx->sipx_network;\n\t\tmemcpy(f.ipx_device, ifr.ifr_name,\n\t\t\tsizeof(f.ipx_device));\n\t\tmemcpy(f.ipx_node, sipx->sipx_node, IPX_NODE_LEN);\n\t\tf.ipx_dlink_type = sipx->sipx_type;\n\t\tf.ipx_special = sipx->sipx_special;\n\n\t\tif (sipx->sipx_action == IPX_DLTITF)\n\t\t\trc = ipxitf_delete(&f);\n\t\telse\n\t\t\trc = ipxitf_create(&f);\n\t\tbreak;\n\t}\n\tcase SIOCGIFADDR: {\n\t\tstruct sockaddr_ipx *sipx;\n\t\tstruct ipx_interface *ipxif;\n\t\tstruct net_device *dev;\n\n\t\trc = -EFAULT;\n\t\tif (copy_from_user(&ifr, arg, sizeof(ifr)))\n\t\t\tbreak;\n\t\tsipx = (struct sockaddr_ipx *)&ifr.ifr_addr;\n\t\tdev  = __dev_get_by_name(&init_net, ifr.ifr_name);\n\t\trc   = -ENODEV;\n\t\tif (!dev)\n\t\t\tbreak;\n\t\tipxif = ipxitf_find_using_phys(dev,\n\t\t\t\t\t   ipx_map_frame_type(sipx->sipx_type));\n\t\trc = -EADDRNOTAVAIL;\n\t\tif (!ipxif)\n\t\t\tbreak;\n\n\t\tsipx->sipx_family\t= AF_IPX;\n \t\tsipx->sipx_network\t= ipxif->if_netnum;\n \t\tmemcpy(sipx->sipx_node, ipxif->if_node,\n \t\t\tsizeof(sipx->sipx_node));\n\t\trc = -EFAULT;\n \t\tif (copy_to_user(arg, &ifr, sizeof(ifr)))\n\t\t\tbreak;\n \t\tipxitf_put(ipxif);\n\t\trc = 0;\n \t\tbreak;\n \t}\n \tcase SIOCAIPXITFCRT:\n\t\trc = -EFAULT;\n\t\tif (get_user(val, (unsigned char __user *) arg))\n\t\t\tbreak;\n\t\trc = 0;\n\t\tipxcfg_auto_create_interfaces = val;\n\t\tbreak;\n\tcase SIOCAIPXPRISLT:\n\t\trc = -EFAULT;\n\t\tif (get_user(val, (unsigned char __user *) arg))\n\t\t\tbreak;\n\t\trc = 0;\n\t\tipxcfg_set_auto_select(val);\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142605,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int ipxitf_ioctl(unsigned int cmd, void __user *arg)\n{\n\tint rc = -EINVAL;\n\tstruct ifreq ifr;\n\tint val;\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR: {\n\t\tstruct sockaddr_ipx *sipx;\n\t\tstruct ipx_interface_definition f;\n\n\t\trc = -EFAULT;\n\t\tif (copy_from_user(&ifr, arg, sizeof(ifr)))\n\t\t\tbreak;\n\t\tsipx = (struct sockaddr_ipx *)&ifr.ifr_addr;\n\t\trc = -EINVAL;\n\t\tif (sipx->sipx_family != AF_IPX)\n\t\t\tbreak;\n\t\tf.ipx_network = sipx->sipx_network;\n\t\tmemcpy(f.ipx_device, ifr.ifr_name,\n\t\t\tsizeof(f.ipx_device));\n\t\tmemcpy(f.ipx_node, sipx->sipx_node, IPX_NODE_LEN);\n\t\tf.ipx_dlink_type = sipx->sipx_type;\n\t\tf.ipx_special = sipx->sipx_special;\n\n\t\tif (sipx->sipx_action == IPX_DLTITF)\n\t\t\trc = ipxitf_delete(&f);\n\t\telse\n\t\t\trc = ipxitf_create(&f);\n\t\tbreak;\n\t}\n\tcase SIOCGIFADDR: {\n\t\tstruct sockaddr_ipx *sipx;\n\t\tstruct ipx_interface *ipxif;\n\t\tstruct net_device *dev;\n\n\t\trc = -EFAULT;\n\t\tif (copy_from_user(&ifr, arg, sizeof(ifr)))\n\t\t\tbreak;\n\t\tsipx = (struct sockaddr_ipx *)&ifr.ifr_addr;\n\t\tdev  = __dev_get_by_name(&init_net, ifr.ifr_name);\n\t\trc   = -ENODEV;\n\t\tif (!dev)\n\t\t\tbreak;\n\t\tipxif = ipxitf_find_using_phys(dev,\n\t\t\t\t\t   ipx_map_frame_type(sipx->sipx_type));\n\t\trc = -EADDRNOTAVAIL;\n\t\tif (!ipxif)\n\t\t\tbreak;\n\n\t\tsipx->sipx_family\t= AF_IPX;\n \t\tsipx->sipx_network\t= ipxif->if_netnum;\n \t\tmemcpy(sipx->sipx_node, ipxif->if_node,\n \t\t\tsizeof(sipx->sipx_node));\n\t\trc = 0;\n \t\tif (copy_to_user(arg, &ifr, sizeof(ifr)))\n\t\t\trc = -EFAULT;\n \t\tipxitf_put(ipxif);\n \t\tbreak;\n \t}\n \tcase SIOCAIPXITFCRT:\n\t\trc = -EFAULT;\n\t\tif (get_user(val, (unsigned char __user *) arg))\n\t\t\tbreak;\n\t\trc = 0;\n\t\tipxcfg_auto_create_interfaces = val;\n\t\tbreak;\n\tcase SIOCAIPXPRISLT:\n\t\trc = -EFAULT;\n\t\tif (get_user(val, (unsigned char __user *) arg))\n\t\t\tbreak;\n\t\trc = 0;\n\t\tipxcfg_set_auto_select(val);\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142606,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static struct ucounts *get_ucounts(struct user_namespace *ns, kuid_t uid)\n{\n\tstruct hlist_head *hashent = ucounts_hashentry(ns, uid);\n\tstruct ucounts *ucounts, *new;\n\n\tspin_lock_irq(&ucounts_lock);\n\tucounts = find_ucounts(ns, uid, hashent);\n\tif (!ucounts) {\n\t\tspin_unlock_irq(&ucounts_lock);\n\n\t\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\t\tif (!new)\n\t\t\treturn NULL;\n \n \t\tnew->ns = ns;\n \t\tnew->uid = uid;\n\t\tatomic_set(&new->count, 0);\n \n \t\tspin_lock_irq(&ucounts_lock);\n \t\tucounts = find_ucounts(ns, uid, hashent);\n\t\tif (ucounts) {\n\t\t\tkfree(new);\n\t\t} else {\n\t\t\thlist_add_head(&new->node, hashent);\n \t\t\tucounts = new;\n \t\t}\n \t}\n\tif (!atomic_add_unless(&ucounts->count, 1, INT_MAX))\n \t\tucounts = NULL;\n \tspin_unlock_irq(&ucounts_lock);\n \treturn ucounts;\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142615,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static struct ucounts *get_ucounts(struct user_namespace *ns, kuid_t uid)\n{\n\tstruct hlist_head *hashent = ucounts_hashentry(ns, uid);\n\tstruct ucounts *ucounts, *new;\n\n\tspin_lock_irq(&ucounts_lock);\n\tucounts = find_ucounts(ns, uid, hashent);\n\tif (!ucounts) {\n\t\tspin_unlock_irq(&ucounts_lock);\n\n\t\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\t\tif (!new)\n\t\t\treturn NULL;\n \n \t\tnew->ns = ns;\n \t\tnew->uid = uid;\n\t\tnew->count = 0;\n \n \t\tspin_lock_irq(&ucounts_lock);\n \t\tucounts = find_ucounts(ns, uid, hashent);\n\t\tif (ucounts) {\n\t\t\tkfree(new);\n\t\t} else {\n\t\t\thlist_add_head(&new->node, hashent);\n \t\t\tucounts = new;\n \t\t}\n \t}\n\tif (ucounts->count == INT_MAX)\n \t\tucounts = NULL;\n\telse\n\t\tucounts->count += 1;\n \tspin_unlock_irq(&ucounts_lock);\n \treturn ucounts;\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142616,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static void put_ucounts(struct ucounts *ucounts)\n {\n \tunsigned long flags;\n \n\tif (atomic_dec_and_test(&ucounts->count)) {\n\t\tspin_lock_irqsave(&ucounts_lock, flags);\n \t\thlist_del_init(&ucounts->node);\n\t\tspin_unlock_irqrestore(&ucounts_lock, flags);\n \n\t\tkfree(ucounts);\n\t}\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142617,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static void put_ucounts(struct ucounts *ucounts)\n {\n \tunsigned long flags;\n \n\tspin_lock_irqsave(&ucounts_lock, flags);\n\tucounts->count -= 1;\n\tif (!ucounts->count)\n \t\thlist_del_init(&ucounts->node);\n\telse\n\t\tucounts = NULL;\n\tspin_unlock_irqrestore(&ucounts_lock, flags);\n \n\tkfree(ucounts);\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142618,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "yyparse (void *yyscanner, YR_COMPILER* compiler)\n{\n/* The lookahead symbol.  */\nint yychar;\n\n\n/* The semantic value of the lookahead symbol.  */\n/* Default value used for initialization, for pacifying older GCCs\n   or non-GCC compilers.  */\nYY_INITIAL_VALUE (static YYSTYPE yyval_default;)\nYYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n\n    /* Number of syntax errors so far.  */\n    int yynerrs;\n\n    int yystate;\n    /* Number of tokens to shift before error messages enabled.  */\n    int yyerrstatus;\n\n    /* The stacks and their tools:\n       'yyss': related to states.\n       'yyvs': related to semantic values.\n\n       Refer to the stacks through separate pointers, to allow yyoverflow\n       to reallocate them elsewhere.  */\n\n    /* The state stack.  */\n    yytype_int16 yyssa[YYINITDEPTH];\n    yytype_int16 *yyss;\n    yytype_int16 *yyssp;\n\n    /* The semantic value stack.  */\n    YYSTYPE yyvsa[YYINITDEPTH];\n    YYSTYPE *yyvs;\n    YYSTYPE *yyvsp;\n\n    YYSIZE_T yystacksize;\n\n  int yyn;\n  int yyresult;\n  /* Lookahead token as an internal (translated) token number.  */\n  int yytoken = 0;\n  /* The variables used to return semantic value and location from the\n     action routines.  */\n  YYSTYPE yyval;\n\n#if YYERROR_VERBOSE\n  /* Buffer for error messages, and its allocated size.  */\n  char yymsgbuf[128];\n  char *yymsg = yymsgbuf;\n  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;\n#endif\n\n#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))\n\n  /* The number of symbols on the RHS of the reduced rule.\n     Keep to zero when no symbol should be popped.  */\n  int yylen = 0;\n\n  yyssp = yyss = yyssa;\n  yyvsp = yyvs = yyvsa;\n  yystacksize = YYINITDEPTH;\n\n  YYDPRINTF ((stderr, \"Starting parse\\n\"));\n\n  yystate = 0;\n  yyerrstatus = 0;\n  yynerrs = 0;\n  yychar = YYEMPTY; /* Cause a token to be read.  */\n  goto yysetstate;\n\n/*------------------------------------------------------------.\n| yynewstate -- Push a new state, which is found in yystate.  |\n`------------------------------------------------------------*/\n yynewstate:\n  /* In all cases, when you get here, the value and location stacks\n     have just been pushed.  So pushing a state here evens the stacks.  */\n  yyssp++;\n\n yysetstate:\n  *yyssp = yystate;\n\n  if (yyss + yystacksize - 1 <= yyssp)\n    {\n      /* Get the current used size of the three stacks, in elements.  */\n      YYSIZE_T yysize = yyssp - yyss + 1;\n\n#ifdef yyoverflow\n      {\n        /* Give user a chance to reallocate the stack.  Use copies of\n           these so that the &'s don't force the real ones into\n           memory.  */\n        YYSTYPE *yyvs1 = yyvs;\n        yytype_int16 *yyss1 = yyss;\n\n        /* Each stack pointer address is followed by the size of the\n           data in use in that stack, in bytes.  This used to be a\n           conditional around just the two extra args, but that might\n           be undefined if yyoverflow is a macro.  */\n        yyoverflow (YY_(\"memory exhausted\"),\n                    &yyss1, yysize * sizeof (*yyssp),\n                    &yyvs1, yysize * sizeof (*yyvsp),\n                    &yystacksize);\n\n        yyss = yyss1;\n        yyvs = yyvs1;\n      }\n#else /* no yyoverflow */\n# ifndef YYSTACK_RELOCATE\n      goto yyexhaustedlab;\n# else\n      /* Extend the stack our own way.  */\n      if (YYMAXDEPTH <= yystacksize)\n        goto yyexhaustedlab;\n      yystacksize *= 2;\n      if (YYMAXDEPTH < yystacksize)\n        yystacksize = YYMAXDEPTH;\n\n      {\n        yytype_int16 *yyss1 = yyss;\n        union yyalloc *yyptr =\n          (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));\n        if (! yyptr)\n          goto yyexhaustedlab;\n        YYSTACK_RELOCATE (yyss_alloc, yyss);\n        YYSTACK_RELOCATE (yyvs_alloc, yyvs);\n#  undef YYSTACK_RELOCATE\n        if (yyss1 != yyssa)\n          YYSTACK_FREE (yyss1);\n      }\n# endif\n#endif /* no yyoverflow */\n\n      yyssp = yyss + yysize - 1;\n      yyvsp = yyvs + yysize - 1;\n\n      YYDPRINTF ((stderr, \"Stack size increased to %lu\\n\",\n                  (unsigned long int) yystacksize));\n\n      if (yyss + yystacksize - 1 <= yyssp)\n        YYABORT;\n    }\n\n  YYDPRINTF ((stderr, \"Entering state %d\\n\", yystate));\n\n  if (yystate == YYFINAL)\n    YYACCEPT;\n\n  goto yybackup;\n\n/*-----------.\n| yybackup.  |\n`-----------*/\nyybackup:\n\n  /* Do appropriate processing given the current state.  Read a\n     lookahead token if we need one and don't already have one.  */\n\n  /* First try to decide what to do without reference to lookahead token.  */\n  yyn = yypact[yystate];\n  if (yypact_value_is_default (yyn))\n    goto yydefault;\n\n  /* Not known => get a lookahead token if don't already have one.  */\n\n  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */\n  if (yychar == YYEMPTY)\n    {\n      YYDPRINTF ((stderr, \"Reading a token: \"));\n      yychar = yylex (&yylval, yyscanner, compiler);\n    }\n\n  if (yychar <= YYEOF)\n    {\n      yychar = yytoken = YYEOF;\n      YYDPRINTF ((stderr, \"Now at end of input.\\n\"));\n    }\n  else\n    {\n      yytoken = YYTRANSLATE (yychar);\n      YY_SYMBOL_PRINT (\"Next token is\", yytoken, &yylval, &yylloc);\n    }\n\n  /* If the proper action on seeing token YYTOKEN is to reduce or to\n     detect an error, take that action.  */\n  yyn += yytoken;\n  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)\n    goto yydefault;\n  yyn = yytable[yyn];\n  if (yyn <= 0)\n    {\n      if (yytable_value_is_error (yyn))\n        goto yyerrlab;\n      yyn = -yyn;\n      goto yyreduce;\n    }\n\n  /* Count tokens shifted since error; after three, turn off error\n     status.  */\n  if (yyerrstatus)\n    yyerrstatus--;\n\n  /* Shift the lookahead token.  */\n  YY_SYMBOL_PRINT (\"Shifting\", yytoken, &yylval, &yylloc);\n\n  /* Discard the shifted token.  */\n  yychar = YYEMPTY;\n\n  yystate = yyn;\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  *++yyvsp = yylval;\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n\n  goto yynewstate;\n\n\n/*-----------------------------------------------------------.\n| yydefault -- do the default action for the current state.  |\n`-----------------------------------------------------------*/\nyydefault:\n  yyn = yydefact[yystate];\n  if (yyn == 0)\n    goto yyerrlab;\n  goto yyreduce;\n\n\n/*-----------------------------.\n| yyreduce -- Do a reduction.  |\n`-----------------------------*/\nyyreduce:\n  /* yyn is the number of a rule to reduce with.  */\n  yylen = yyr2[yyn];\n\n  /* If YYLEN is nonzero, implement the default value of the action:\n     '$$ = $1'.\n\n     Otherwise, the following line sets YYVAL to garbage.\n     This behavior is undocumented and Bison\n     users should not rely upon it.  Assigning to YYVAL\n     unconditionally makes the parser a bit smaller, and it avoids a\n     GCC warning that YYVAL may be used uninitialized.  */\n  yyval = yyvsp[1-yylen];\n\n\n  YY_REDUCE_PRINT (yyn);\n  switch (yyn)\n    {\n        case 8:\n#line 230 \"grammar.y\" /* yacc.c:1646  */\n    {\n        int result = yr_parser_reduce_import(yyscanner, (yyvsp[0].sized_string));\n\n        yr_free((yyvsp[0].sized_string));\n\n        ERROR_IF(result != ERROR_SUCCESS);\n      }\n#line 1661 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 9:\n#line 242 \"grammar.y\" /* yacc.c:1646  */\n    {\n        YR_RULE* rule = yr_parser_reduce_rule_declaration_phase_1(\n            yyscanner, (int32_t) (yyvsp[-2].integer), (yyvsp[0].c_string));\n\n        ERROR_IF(rule == NULL);\n\n        (yyval.rule) = rule;\n      }\n#line 1674 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 10:\n#line 251 \"grammar.y\" /* yacc.c:1646  */\n    {\n        YR_RULE* rule = (yyvsp[-4].rule); // rule created in phase 1\n\n        rule->tags = (yyvsp[-3].c_string);\n        rule->metas = (yyvsp[-1].meta);\n        rule->strings = (yyvsp[0].string);\n      }\n#line 1686 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 11:\n#line 259 \"grammar.y\" /* yacc.c:1646  */\n    {\n        YR_RULE* rule = (yyvsp[-7].rule); // rule created in phase 1\n\n        compiler->last_result = yr_parser_reduce_rule_declaration_phase_2(\n            yyscanner, rule);\n\n        yr_free((yyvsp[-8].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n      }\n#line 1701 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 12:\n#line 274 \"grammar.y\" /* yacc.c:1646  */\n    {\n        (yyval.meta) = NULL;\n      }\n#line 1709 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 13:\n#line 278 \"grammar.y\" /* yacc.c:1646  */\n    {\n\n        YR_META null_meta;\n\n        memset(&null_meta, 0xFF, sizeof(YR_META));\n        null_meta.type = META_TYPE_NULL;\n\n        compiler->last_result = yr_arena_write_data(\n            compiler->metas_arena,\n            &null_meta,\n            sizeof(YR_META),\n            NULL);\n\n        (yyval.meta) = (yyvsp[0].meta);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n      }\n#line 1736 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 14:\n#line 305 \"grammar.y\" /* yacc.c:1646  */\n    {\n        (yyval.string) = NULL;\n      }\n#line 1744 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 15:\n#line 309 \"grammar.y\" /* yacc.c:1646  */\n    {\n\n        YR_STRING null_string;\n\n        memset(&null_string, 0xFF, sizeof(YR_STRING));\n        null_string.g_flags = STRING_GFLAGS_NULL;\n\n        compiler->last_result = yr_arena_write_data(\n            compiler->strings_arena,\n            &null_string,\n            sizeof(YR_STRING),\n            NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        (yyval.string) = (yyvsp[0].string);\n      }\n#line 1771 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 17:\n#line 340 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.integer) = 0;  }\n#line 1777 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 18:\n#line 341 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }\n#line 1783 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 19:\n#line 346 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.integer) = RULE_GFLAGS_PRIVATE; }\n#line 1789 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 20:\n#line 347 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.integer) = RULE_GFLAGS_GLOBAL; }\n#line 1795 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 21:\n#line 353 \"grammar.y\" /* yacc.c:1646  */\n    {\n        (yyval.c_string) = NULL;\n      }\n#line 1803 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 22:\n#line 357 \"grammar.y\" /* yacc.c:1646  */\n    {\n\n        compiler->last_result = yr_arena_write_string(\n            yyget_extra(yyscanner)->sz_arena, \"\", NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        (yyval.c_string) = (yyvsp[0].c_string);\n      }\n#line 1821 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 23:\n#line 375 \"grammar.y\" /* yacc.c:1646  */\n    {\n        char* identifier;\n\n        compiler->last_result = yr_arena_write_string(\n            yyget_extra(yyscanner)->sz_arena, (yyvsp[0].c_string), &identifier);\n\n        yr_free((yyvsp[0].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        (yyval.c_string) = identifier;\n      }\n#line 1838 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 24:\n#line 388 \"grammar.y\" /* yacc.c:1646  */\n    {\n        char* tag_name = (yyvsp[-1].c_string);\n        size_t tag_length = tag_name != NULL ? strlen(tag_name) : 0;\n\n        while (tag_length > 0)\n        {\n          if (strcmp(tag_name, (yyvsp[0].c_string)) == 0)\n          {\n            yr_compiler_set_error_extra_info(compiler, tag_name);\n            compiler->last_result = ERROR_DUPLICATED_TAG_IDENTIFIER;\n            break;\n          }\n\n          tag_name = (char*) yr_arena_next_address(\n              yyget_extra(yyscanner)->sz_arena,\n              tag_name,\n              tag_length + 1);\n\n          tag_length = tag_name != NULL ? strlen(tag_name) : 0;\n        }\n\n        if (compiler->last_result == ERROR_SUCCESS)\n          compiler->last_result = yr_arena_write_string(\n              yyget_extra(yyscanner)->sz_arena, (yyvsp[0].c_string), NULL);\n\n        yr_free((yyvsp[0].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        (yyval.c_string) = (yyvsp[-1].c_string);\n      }\n#line 1874 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 25:\n#line 424 \"grammar.y\" /* yacc.c:1646  */\n    {  (yyval.meta) = (yyvsp[0].meta); }\n#line 1880 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 26:\n#line 425 \"grammar.y\" /* yacc.c:1646  */\n    {  (yyval.meta) = (yyvsp[-1].meta); }\n#line 1886 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 27:\n#line 431 \"grammar.y\" /* yacc.c:1646  */\n    {\n        SIZED_STRING* sized_string = (yyvsp[0].sized_string);\n\n        (yyval.meta) = yr_parser_reduce_meta_declaration(\n            yyscanner,\n            META_TYPE_STRING,\n            (yyvsp[-2].c_string),\n            sized_string->c_string,\n            0);\n\n        yr_free((yyvsp[-2].c_string));\n        yr_free((yyvsp[0].sized_string));\n\n        ERROR_IF((yyval.meta) == NULL);\n      }\n#line 1906 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 28:\n#line 447 \"grammar.y\" /* yacc.c:1646  */\n    {\n        (yyval.meta) = yr_parser_reduce_meta_declaration(\n            yyscanner,\n            META_TYPE_INTEGER,\n            (yyvsp[-2].c_string),\n            NULL,\n            (yyvsp[0].integer));\n\n        yr_free((yyvsp[-2].c_string));\n\n        ERROR_IF((yyval.meta) == NULL);\n      }\n#line 1923 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 29:\n#line 460 \"grammar.y\" /* yacc.c:1646  */\n    {\n        (yyval.meta) = yr_parser_reduce_meta_declaration(\n            yyscanner,\n            META_TYPE_INTEGER,\n            (yyvsp[-3].c_string),\n            NULL,\n            -(yyvsp[0].integer));\n\n        yr_free((yyvsp[-3].c_string));\n\n        ERROR_IF((yyval.meta) == NULL);\n      }\n#line 1940 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 30:\n#line 473 \"grammar.y\" /* yacc.c:1646  */\n    {\n        (yyval.meta) = yr_parser_reduce_meta_declaration(\n            yyscanner,\n            META_TYPE_BOOLEAN,\n            (yyvsp[-2].c_string),\n            NULL,\n            TRUE);\n\n        yr_free((yyvsp[-2].c_string));\n\n        ERROR_IF((yyval.meta) == NULL);\n      }\n#line 1957 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 31:\n#line 486 \"grammar.y\" /* yacc.c:1646  */\n    {\n        (yyval.meta) = yr_parser_reduce_meta_declaration(\n            yyscanner,\n            META_TYPE_BOOLEAN,\n            (yyvsp[-2].c_string),\n            NULL,\n            FALSE);\n\n        yr_free((yyvsp[-2].c_string));\n\n        ERROR_IF((yyval.meta) == NULL);\n      }\n#line 1974 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 32:\n#line 502 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.string) = (yyvsp[0].string); }\n#line 1980 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 33:\n#line 503 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.string) = (yyvsp[-1].string); }\n#line 1986 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 34:\n#line 509 \"grammar.y\" /* yacc.c:1646  */\n    {\n        compiler->error_line = yyget_lineno(yyscanner);\n      }\n#line 1994 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 35:\n#line 513 \"grammar.y\" /* yacc.c:1646  */\n    {\n        (yyval.string) = yr_parser_reduce_string_declaration(\n            yyscanner, (int32_t) (yyvsp[0].integer), (yyvsp[-4].c_string), (yyvsp[-1].sized_string));\n\n        yr_free((yyvsp[-4].c_string));\n        yr_free((yyvsp[-1].sized_string));\n\n        ERROR_IF((yyval.string) == NULL);\n        compiler->error_line = 0;\n      }\n#line 2009 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 36:\n#line 524 \"grammar.y\" /* yacc.c:1646  */\n    {\n        compiler->error_line = yyget_lineno(yyscanner);\n      }\n#line 2017 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 37:\n#line 528 \"grammar.y\" /* yacc.c:1646  */\n    {\n        (yyval.string) = yr_parser_reduce_string_declaration(\n            yyscanner, (int32_t) (yyvsp[0].integer) | STRING_GFLAGS_REGEXP, (yyvsp[-4].c_string), (yyvsp[-1].sized_string));\n\n        yr_free((yyvsp[-4].c_string));\n        yr_free((yyvsp[-1].sized_string));\n\n        ERROR_IF((yyval.string) == NULL);\n\n        compiler->error_line = 0;\n      }\n#line 2033 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 38:\n#line 540 \"grammar.y\" /* yacc.c:1646  */\n    {\n        (yyval.string) = yr_parser_reduce_string_declaration(\n            yyscanner, STRING_GFLAGS_HEXADECIMAL, (yyvsp[-2].c_string), (yyvsp[0].sized_string));\n\n        yr_free((yyvsp[-2].c_string));\n        yr_free((yyvsp[0].sized_string));\n\n        ERROR_IF((yyval.string) == NULL);\n      }\n#line 2047 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 39:\n#line 553 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.integer) = 0; }\n#line 2053 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 40:\n#line 554 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }\n#line 2059 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 41:\n#line 559 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.integer) = STRING_GFLAGS_WIDE; }\n#line 2065 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 42:\n#line 560 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.integer) = STRING_GFLAGS_ASCII; }\n#line 2071 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 43:\n#line 561 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.integer) = STRING_GFLAGS_NO_CASE; }\n#line 2077 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 44:\n#line 562 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.integer) = STRING_GFLAGS_FULL_WORD; }\n#line 2083 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 45:\n#line 568 \"grammar.y\" /* yacc.c:1646  */\n    {\n        int var_index = yr_parser_lookup_loop_variable(yyscanner, (yyvsp[0].c_string));\n\n        if (var_index >= 0)\n        {\n          compiler->last_result = yr_parser_emit_with_arg(\n              yyscanner,\n              OP_PUSH_M,\n              LOOP_LOCAL_VARS * var_index,\n              NULL,\n              NULL);\n\n          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n          (yyval.expression).value.integer = UNDEFINED;\n          (yyval.expression).identifier = compiler->loop_identifier[var_index];\n        }\n        else\n        {\n\n          YR_OBJECT* object = (YR_OBJECT*) yr_hash_table_lookup(\n              compiler->objects_table, (yyvsp[0].c_string), NULL);\n\n          if (object == NULL)\n          {\n            char* ns = compiler->current_namespace->name;\n\n            object = (YR_OBJECT*) yr_hash_table_lookup(\n                compiler->objects_table, (yyvsp[0].c_string), ns);\n          }\n\n          if (object != NULL)\n          {\n            char* id;\n\n            compiler->last_result = yr_arena_write_string(\n                compiler->sz_arena, (yyvsp[0].c_string), &id);\n\n            if (compiler->last_result == ERROR_SUCCESS)\n              compiler->last_result = yr_parser_emit_with_arg_reloc(\n                  yyscanner,\n                  OP_OBJ_LOAD,\n                  id,\n                  NULL,\n                  NULL);\n\n            (yyval.expression).type = EXPRESSION_TYPE_OBJECT;\n            (yyval.expression).value.object = object;\n            (yyval.expression).identifier = object->identifier;\n          }\n          else\n          {\n            YR_RULE* rule = (YR_RULE*) yr_hash_table_lookup(\n                compiler->rules_table,\n                (yyvsp[0].c_string),\n                compiler->current_namespace->name);\n\n            if (rule != NULL)\n            {\n              compiler->last_result = yr_parser_emit_with_arg_reloc(\n                  yyscanner,\n                  OP_PUSH_RULE,\n                  rule,\n                  NULL,\n                  NULL);\n\n              (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n              (yyval.expression).value.integer = UNDEFINED;\n              (yyval.expression).identifier = rule->identifier;\n            }\n            else\n            {\n              yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));\n              compiler->last_result = ERROR_UNDEFINED_IDENTIFIER;\n            }\n          }\n        }\n\n        yr_free((yyvsp[0].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n      }\n#line 2172 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 46:\n#line 653 \"grammar.y\" /* yacc.c:1646  */\n    {\n        YR_OBJECT* field = NULL;\n\n        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_OBJECT &&\n            (yyvsp[-2].expression).value.object->type == OBJECT_TYPE_STRUCTURE)\n        {\n          field = yr_object_lookup_field((yyvsp[-2].expression).value.object, (yyvsp[0].c_string));\n\n          if (field != NULL)\n          {\n            char* ident;\n\n            compiler->last_result = yr_arena_write_string(\n              compiler->sz_arena, (yyvsp[0].c_string), &ident);\n\n            if (compiler->last_result == ERROR_SUCCESS)\n              compiler->last_result = yr_parser_emit_with_arg_reloc(\n                  yyscanner,\n                  OP_OBJ_FIELD,\n                  ident,\n                  NULL,\n                  NULL);\n\n            (yyval.expression).type = EXPRESSION_TYPE_OBJECT;\n            (yyval.expression).value.object = field;\n            (yyval.expression).identifier = field->identifier;\n          }\n          else\n          {\n            yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));\n            compiler->last_result = ERROR_INVALID_FIELD_NAME;\n          }\n        }\n        else\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, (yyvsp[-2].expression).identifier);\n\n          compiler->last_result = ERROR_NOT_A_STRUCTURE;\n        }\n\n        yr_free((yyvsp[0].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n      }\n#line 2222 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 47:\n#line 699 \"grammar.y\" /* yacc.c:1646  */\n    {\n        YR_OBJECT_ARRAY* array;\n        YR_OBJECT_DICTIONARY* dict;\n\n        if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&\n            (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_ARRAY)\n        {\n          if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)\n          {\n            yr_compiler_set_error_extra_info(\n                compiler, \"array indexes must be of integer type\");\n            compiler->last_result = ERROR_WRONG_TYPE;\n          }\n\n          ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n          compiler->last_result = yr_parser_emit(\n              yyscanner, OP_INDEX_ARRAY, NULL);\n\n          array = (YR_OBJECT_ARRAY*) (yyvsp[-3].expression).value.object;\n\n          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;\n          (yyval.expression).value.object = array->prototype_item;\n          (yyval.expression).identifier = array->identifier;\n        }\n        else if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&\n                 (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_DICTIONARY)\n        {\n          if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_STRING)\n          {\n            yr_compiler_set_error_extra_info(\n                compiler, \"dictionary keys must be of string type\");\n            compiler->last_result = ERROR_WRONG_TYPE;\n          }\n\n          ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n          compiler->last_result = yr_parser_emit(\n              yyscanner, OP_LOOKUP_DICT, NULL);\n\n          dict = (YR_OBJECT_DICTIONARY*) (yyvsp[-3].expression).value.object;\n\n          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;\n          (yyval.expression).value.object = dict->prototype_item;\n          (yyval.expression).identifier = dict->identifier;\n        }\n        else\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, (yyvsp[-3].expression).identifier);\n\n          compiler->last_result = ERROR_NOT_INDEXABLE;\n        }\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n      }\n#line 2283 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 48:\n#line 757 \"grammar.y\" /* yacc.c:1646  */\n    {\n        YR_OBJECT_FUNCTION* function;\n        char* args_fmt;\n\n        if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&\n            (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_FUNCTION)\n        {\n          compiler->last_result = yr_parser_check_types(\n              compiler, (YR_OBJECT_FUNCTION*) (yyvsp[-3].expression).value.object, (yyvsp[-1].c_string));\n\n          if (compiler->last_result == ERROR_SUCCESS)\n            compiler->last_result = yr_arena_write_string(\n              compiler->sz_arena, (yyvsp[-1].c_string), &args_fmt);\n\n          if (compiler->last_result == ERROR_SUCCESS)\n            compiler->last_result = yr_parser_emit_with_arg_reloc(\n                yyscanner,\n                OP_CALL,\n                args_fmt,\n                NULL,\n                NULL);\n\n          function = (YR_OBJECT_FUNCTION*) (yyvsp[-3].expression).value.object;\n\n          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;\n          (yyval.expression).value.object = function->return_obj;\n          (yyval.expression).identifier = function->identifier;\n        }\n        else\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, (yyvsp[-3].expression).identifier);\n\n          compiler->last_result = ERROR_NOT_A_FUNCTION;\n        }\n\n        yr_free((yyvsp[-1].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n      }\n#line 2328 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 49:\n#line 801 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.c_string) = yr_strdup(\"\"); }\n#line 2334 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 50:\n#line 802 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.c_string) = (yyvsp[0].c_string); }\n#line 2340 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 51:\n#line 807 \"grammar.y\" /* yacc.c:1646  */\n    {\n        (yyval.c_string) = (char*) yr_malloc(MAX_FUNCTION_ARGS + 1);\n\n        switch((yyvsp[0].expression).type)\n        {\n          case EXPRESSION_TYPE_INTEGER:\n            strlcpy((yyval.c_string), \"i\", MAX_FUNCTION_ARGS);\n            break;\n          case EXPRESSION_TYPE_FLOAT:\n            strlcpy((yyval.c_string), \"f\", MAX_FUNCTION_ARGS);\n            break;\n          case EXPRESSION_TYPE_BOOLEAN:\n            strlcpy((yyval.c_string), \"b\", MAX_FUNCTION_ARGS);\n            break;\n          case EXPRESSION_TYPE_STRING:\n            strlcpy((yyval.c_string), \"s\", MAX_FUNCTION_ARGS);\n            break;\n          case EXPRESSION_TYPE_REGEXP:\n            strlcpy((yyval.c_string), \"r\", MAX_FUNCTION_ARGS);\n            break;\n        }\n\n        ERROR_IF((yyval.c_string) == NULL);\n      }\n#line 2369 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 52:\n#line 832 \"grammar.y\" /* yacc.c:1646  */\n    {\n        if (strlen((yyvsp[-2].c_string)) == MAX_FUNCTION_ARGS)\n        {\n          compiler->last_result = ERROR_TOO_MANY_ARGUMENTS;\n        }\n        else\n        {\n          switch((yyvsp[0].expression).type)\n          {\n            case EXPRESSION_TYPE_INTEGER:\n              strlcat((yyvsp[-2].c_string), \"i\", MAX_FUNCTION_ARGS);\n              break;\n            case EXPRESSION_TYPE_FLOAT:\n              strlcat((yyvsp[-2].c_string), \"f\", MAX_FUNCTION_ARGS);\n              break;\n            case EXPRESSION_TYPE_BOOLEAN:\n              strlcat((yyvsp[-2].c_string), \"b\", MAX_FUNCTION_ARGS);\n              break;\n            case EXPRESSION_TYPE_STRING:\n              strlcat((yyvsp[-2].c_string), \"s\", MAX_FUNCTION_ARGS);\n              break;\n            case EXPRESSION_TYPE_REGEXP:\n              strlcat((yyvsp[-2].c_string), \"r\", MAX_FUNCTION_ARGS);\n              break;\n          }\n        }\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        (yyval.c_string) = (yyvsp[-2].c_string);\n      }\n#line 2405 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 53:\n#line 868 \"grammar.y\" /* yacc.c:1646  */\n    {\n        SIZED_STRING* sized_string = (yyvsp[0].sized_string);\n        RE* re;\n        RE_ERROR error;\n\n        int re_flags = 0;\n\n        if (sized_string->flags & SIZED_STRING_FLAGS_NO_CASE)\n          re_flags |= RE_FLAGS_NO_CASE;\n\n        if (sized_string->flags & SIZED_STRING_FLAGS_DOT_ALL)\n          re_flags |= RE_FLAGS_DOT_ALL;\n\n        compiler->last_result = yr_re_compile(\n            sized_string->c_string,\n            re_flags,\n            compiler->re_code_arena,\n            &re,\n            &error);\n\n        yr_free((yyvsp[0].sized_string));\n\n        if (compiler->last_result == ERROR_INVALID_REGULAR_EXPRESSION)\n          yr_compiler_set_error_extra_info(compiler, error.message);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        if (compiler->last_result == ERROR_SUCCESS)\n          compiler->last_result = yr_parser_emit_with_arg_reloc(\n              yyscanner,\n              OP_PUSH,\n              re->root_node->forward_code,\n              NULL,\n              NULL);\n\n        yr_re_destroy(re);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        (yyval.expression).type = EXPRESSION_TYPE_REGEXP;\n      }\n#line 2451 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 54:\n#line 914 \"grammar.y\" /* yacc.c:1646  */\n    {\n        if ((yyvsp[0].expression).type == EXPRESSION_TYPE_STRING)\n        {\n          if ((yyvsp[0].expression).value.sized_string != NULL)\n          {\n            yywarning(yyscanner,\n              \"Using literal string \\\"%s\\\" in a boolean operation.\",\n              (yyvsp[0].expression).value.sized_string->c_string);\n          }\n\n          compiler->last_result = yr_parser_emit(\n              yyscanner, OP_STR_TO_BOOL, NULL);\n\n          ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n        }\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 2474 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 55:\n#line 936 \"grammar.y\" /* yacc.c:1646  */\n    {\n        compiler->last_result = yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH, 1, NULL, NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 2487 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 56:\n#line 945 \"grammar.y\" /* yacc.c:1646  */\n    {\n        compiler->last_result = yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH, 0, NULL, NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 2500 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 57:\n#line 954 \"grammar.y\" /* yacc.c:1646  */\n    {\n        CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, \"matches\");\n        CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_REGEXP, \"matches\");\n\n        if (compiler->last_result == ERROR_SUCCESS)\n          compiler->last_result = yr_parser_emit(\n              yyscanner,\n              OP_MATCHES,\n              NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 2519 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 58:\n#line 969 \"grammar.y\" /* yacc.c:1646  */\n    {\n        CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, \"contains\");\n        CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_STRING, \"contains\");\n\n        compiler->last_result = yr_parser_emit(\n            yyscanner, OP_CONTAINS, NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 2535 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 59:\n#line 981 \"grammar.y\" /* yacc.c:1646  */\n    {\n        int result = yr_parser_reduce_string_identifier(\n            yyscanner,\n            (yyvsp[0].c_string),\n            OP_FOUND,\n            UNDEFINED);\n\n        yr_free((yyvsp[0].c_string));\n\n        ERROR_IF(result != ERROR_SUCCESS);\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 2553 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 60:\n#line 995 \"grammar.y\" /* yacc.c:1646  */\n    {\n        CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"at\");\n\n        compiler->last_result = yr_parser_reduce_string_identifier(\n            yyscanner, (yyvsp[-2].c_string), OP_FOUND_AT, (yyvsp[0].expression).value.integer);\n\n        yr_free((yyvsp[-2].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 2570 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 61:\n#line 1008 \"grammar.y\" /* yacc.c:1646  */\n    {\n        compiler->last_result = yr_parser_reduce_string_identifier(\n            yyscanner, (yyvsp[-2].c_string), OP_FOUND_IN, UNDEFINED);\n\n        yr_free((yyvsp[-2].c_string));\n\n        ERROR_IF(compiler->last_result!= ERROR_SUCCESS);\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 2585 \"grammar.c\" /* yacc.c:1646  */\n    break;\n \n   case 62:\n #line 1019 \"grammar.y\" /* yacc.c:1646  */\n     {\n         int var_index;\n \n        if (compiler->loop_depth == MAX_LOOP_NESTING)\n          compiler->last_result = \\\n              ERROR_LOOP_NESTING_LIMIT_EXCEEDED;\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        var_index = yr_parser_lookup_loop_variable(\n            yyscanner, (yyvsp[-1].c_string));\n\n        if (var_index >= 0)\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, (yyvsp[-1].c_string));\n\n          compiler->last_result = \\\n              ERROR_DUPLICATED_LOOP_IDENTIFIER;\n        }\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        compiler->last_result = yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n#line 2619 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 63:\n#line 1049 \"grammar.y\" /* yacc.c:1646  */\n     {\n         int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;\n         uint8_t* addr;\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);\n\n        if ((yyvsp[-1].integer) == INTEGER_SET_ENUMERATION)\n        {\n          yr_parser_emit_with_arg(\n              yyscanner, OP_POP_M, mem_offset, &addr, NULL);\n        }\n        else // INTEGER_SET_RANGE\n        {\n          yr_parser_emit_with_arg(\n              yyscanner, OP_POP_M, mem_offset + 3, &addr, NULL);\n\n          yr_parser_emit_with_arg(\n              yyscanner, OP_POP_M, mem_offset, NULL, NULL);\n        }\n\n        compiler->loop_address[compiler->loop_depth] = addr;\n         compiler->loop_identifier[compiler->loop_depth] = (yyvsp[-4].c_string);\n         compiler->loop_depth++;\n       }\n#line 2658 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 64:\n#line 1084 \"grammar.y\" /* yacc.c:1646  */\n     {\n         int mem_offset;\n \n        compiler->loop_depth--;\n        mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;\n\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);\n\n        if ((yyvsp[-5].integer) == INTEGER_SET_ENUMERATION)\n        {\n          yr_parser_emit_with_arg_reloc(\n              yyscanner,\n              OP_JNUNDEF,\n              compiler->loop_address[compiler->loop_depth],\n              NULL,\n              NULL);\n        }\n        else // INTEGER_SET_RANGE\n        {\n          yr_parser_emit_with_arg(\n              yyscanner, OP_INCR_M, mem_offset, NULL, NULL);\n\n          yr_parser_emit_with_arg(\n              yyscanner, OP_PUSH_M, mem_offset, NULL, NULL);\n\n          yr_parser_emit_with_arg(\n              yyscanner, OP_PUSH_M, mem_offset + 3, NULL, NULL);\n\n          yr_parser_emit_with_arg_reloc(\n              yyscanner,\n              OP_JLE,\n              compiler->loop_address[compiler->loop_depth],\n              NULL,\n              NULL);\n\n          yr_parser_emit(yyscanner, OP_POP, NULL);\n          yr_parser_emit(yyscanner, OP_POP, NULL);\n        }\n\n        yr_parser_emit(yyscanner, OP_POP, NULL);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);\n\n        yr_parser_emit(yyscanner, OP_INT_LE, NULL);\n\n        compiler->loop_identifier[compiler->loop_depth] = NULL;\n        yr_free((yyvsp[-8].c_string));\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 2741 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 65:\n#line 1163 \"grammar.y\" /* yacc.c:1646  */\n     {\n         int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;\n         uint8_t* addr;\n\n        if (compiler->loop_depth == MAX_LOOP_NESTING)\n          compiler->last_result = \\\n            ERROR_LOOP_NESTING_LIMIT_EXCEEDED;\n\n        if (compiler->loop_for_of_mem_offset != -1)\n          compiler->last_result = \\\n            ERROR_NESTED_FOR_OF_LOOP;\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_POP_M, mem_offset, &addr, NULL);\n\n        compiler->loop_for_of_mem_offset = mem_offset;\n        compiler->loop_address[compiler->loop_depth] = addr;\n         compiler->loop_identifier[compiler->loop_depth] = NULL;\n         compiler->loop_depth++;\n       }\n#line 2775 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 66:\n#line 1193 \"grammar.y\" /* yacc.c:1646  */\n     {\n         int mem_offset;\n \n        compiler->loop_depth--;\n        compiler->loop_for_of_mem_offset = -1;\n\n        mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;\n\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);\n\n        yr_parser_emit_with_arg_reloc(\n            yyscanner,\n            OP_JNUNDEF,\n            compiler->loop_address[compiler->loop_depth],\n            NULL,\n            NULL);\n\n        yr_parser_emit(yyscanner, OP_POP, NULL);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);\n\n        yr_parser_emit(yyscanner, OP_INT_LE, NULL);\n\n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n \n       }\n#line 2828 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 67:\n#line 1242 \"grammar.y\" /* yacc.c:1646  */\n     {\n         yr_parser_emit(yyscanner, OP_OF, NULL);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 2838 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 68:\n#line 1248 \"grammar.y\" /* yacc.c:1646  */\n     {\n         yr_parser_emit(yyscanner, OP_NOT, NULL);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 2848 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 69:\n#line 1254 \"grammar.y\" /* yacc.c:1646  */\n     {\n         YR_FIXUP* fixup;\n         void* jmp_destination_addr;\n\n        compiler->last_result = yr_parser_emit_with_arg_reloc(\n            yyscanner,\n            OP_JFALSE,\n            0,          // still don't know the jump destination\n            NULL,\n            &jmp_destination_addr);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));\n\n        if (fixup == NULL)\n          compiler->last_error = ERROR_INSUFFICIENT_MEMORY;\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        fixup->address = jmp_destination_addr;\n         fixup->next = compiler->fixup_stack_head;\n         compiler->fixup_stack_head = fixup;\n       }\n#line 2878 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 70:\n#line 1280 \"grammar.y\" /* yacc.c:1646  */\n     {\n         YR_FIXUP* fixup;\n         uint8_t* and_addr;\n\n\n        compiler->last_result = yr_arena_reserve_memory(\n            compiler->code_arena, 2);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        compiler->last_result = yr_parser_emit(yyscanner, OP_AND, &and_addr);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n\n        fixup = compiler->fixup_stack_head;\n\n\n        *(void**)(fixup->address) = (void*)(and_addr + 1);\n\n        compiler->fixup_stack_head = fixup->next;\n        yr_free(fixup);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 2918 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 71:\n#line 1316 \"grammar.y\" /* yacc.c:1646  */\n     {\n         YR_FIXUP* fixup;\n         void* jmp_destination_addr;\n\n        compiler->last_result = yr_parser_emit_with_arg_reloc(\n            yyscanner,\n            OP_JTRUE,\n            0,         // still don't know the jump destination\n            NULL,\n            &jmp_destination_addr);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));\n\n        if (fixup == NULL)\n          compiler->last_error = ERROR_INSUFFICIENT_MEMORY;\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        fixup->address = jmp_destination_addr;\n         fixup->next = compiler->fixup_stack_head;\n         compiler->fixup_stack_head = fixup;\n       }\n#line 2947 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 72:\n#line 1341 \"grammar.y\" /* yacc.c:1646  */\n     {\n         YR_FIXUP* fixup;\n         uint8_t* or_addr;\n\n\n        compiler->last_result = yr_arena_reserve_memory(\n            compiler->code_arena, 2);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        compiler->last_result = yr_parser_emit(yyscanner, OP_OR, &or_addr);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n\n        fixup = compiler->fixup_stack_head;\n\n\n        *(void**)(fixup->address) = (void*)(or_addr + 1);\n\n        compiler->fixup_stack_head = fixup->next;\n        yr_free(fixup);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 2987 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 73:\n#line 1377 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \"<\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 3000 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 74:\n#line 1386 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \">\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 3013 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 75:\n#line 1395 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \"<=\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 3026 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 76:\n#line 1404 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \">=\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 3039 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 77:\n#line 1413 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \"==\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 3052 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 78:\n#line 1422 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \"!=\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 3065 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 79:\n#line 1431 \"grammar.y\" /* yacc.c:1646  */\n     {\n         (yyval.expression) = (yyvsp[0].expression);\n       }\n#line 3073 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 80:\n#line 1435 \"grammar.y\" /* yacc.c:1646  */\n     {\n         (yyval.expression) = (yyvsp[-1].expression);\n       }\n#line 3081 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 81:\n#line 1442 \"grammar.y\" /* yacc.c:1646  */\n     { (yyval.integer) = INTEGER_SET_ENUMERATION; }\n#line 3087 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 82:\n#line 1443 \"grammar.y\" /* yacc.c:1646  */\n     { (yyval.integer) = INTEGER_SET_RANGE; }\n#line 3093 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 83:\n#line 1449 \"grammar.y\" /* yacc.c:1646  */\n     {\n         if ((yyvsp[-3].expression).type != EXPRESSION_TYPE_INTEGER)\n         {\n          yr_compiler_set_error_extra_info(\n              compiler, \"wrong type for range's lower bound\");\n          compiler->last_result = ERROR_WRONG_TYPE;\n        }\n\n        if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, \"wrong type for range's upper bound\");\n          compiler->last_result = ERROR_WRONG_TYPE;\n        }\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n#line 3115 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 84:\n#line 1471 \"grammar.y\" /* yacc.c:1646  */\n     {\n         if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)\n         {\n          yr_compiler_set_error_extra_info(\n              compiler, \"wrong type for enumeration item\");\n          compiler->last_result = ERROR_WRONG_TYPE;\n\n        }\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n#line 3131 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 85:\n#line 1483 \"grammar.y\" /* yacc.c:1646  */\n     {\n         if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)\n         {\n          yr_compiler_set_error_extra_info(\n              compiler, \"wrong type for enumeration item\");\n          compiler->last_result = ERROR_WRONG_TYPE;\n        }\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n#line 3146 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 86:\n#line 1498 \"grammar.y\" /* yacc.c:1646  */\n     {\n         yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);\n       }\n#line 3155 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 88:\n#line 1504 \"grammar.y\" /* yacc.c:1646  */\n     {\n         yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);\n         yr_parser_emit_pushes_for_strings(yyscanner, \"$*\");\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n#line 3166 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 91:\n#line 1521 \"grammar.y\" /* yacc.c:1646  */\n     {\n         yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));\n         yr_free((yyvsp[0].c_string));\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n#line 3177 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 92:\n#line 1528 \"grammar.y\" /* yacc.c:1646  */\n     {\n         yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));\n         yr_free((yyvsp[0].c_string));\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n#line 3188 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 94:\n#line 1540 \"grammar.y\" /* yacc.c:1646  */\n     {\n         yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);\n       }\n#line 3196 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 95:\n#line 1544 \"grammar.y\" /* yacc.c:1646  */\n     {\n         yr_parser_emit_with_arg(yyscanner, OP_PUSH, 1, NULL, NULL);\n       }\n#line 3204 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 96:\n#line 1552 \"grammar.y\" /* yacc.c:1646  */\n     {\n         (yyval.expression) = (yyvsp[-1].expression);\n       }\n#line 3212 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 97:\n#line 1556 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_emit(\n             yyscanner, OP_FILESIZE, NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n#line 3226 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 98:\n#line 1566 \"grammar.y\" /* yacc.c:1646  */\n     {\n         yywarning(yyscanner,\n             \"Using deprecated \\\"entrypoint\\\" keyword. Use the \\\"entry_point\\\" \"\n            \"function from PE module instead.\");\n\n        compiler->last_result = yr_parser_emit(\n            yyscanner, OP_ENTRYPOINT, NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n#line 3244 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 99:\n#line 1580 \"grammar.y\" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[-1].expression), EXPRESSION_TYPE_INTEGER, \"intXXXX or uintXXXX\");\n \n\n        compiler->last_result = yr_parser_emit(\n            yyscanner, (uint8_t) (OP_READ_INT + (yyvsp[-3].integer)), NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n#line 3264 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 100:\n#line 1596 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_emit_with_arg(\n             yyscanner, OP_PUSH, (yyvsp[0].integer), NULL, NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = (yyvsp[0].integer);\n       }\n#line 3278 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 101:\n#line 1606 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_emit_with_arg_double(\n             yyscanner, OP_PUSH, (yyvsp[0].double_), NULL, NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n \n         (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n       }\n#line 3291 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 102:\n#line 1615 \"grammar.y\" /* yacc.c:1646  */\n     {\n         SIZED_STRING* sized_string;\n \n        compiler->last_result = yr_arena_write_data(\n            compiler->sz_arena,\n            (yyvsp[0].sized_string),\n            (yyvsp[0].sized_string)->length + sizeof(SIZED_STRING),\n            (void**) &sized_string);\n\n        yr_free((yyvsp[0].sized_string));\n\n        if (compiler->last_result == ERROR_SUCCESS)\n          compiler->last_result = yr_parser_emit_with_arg_reloc(\n              yyscanner,\n              OP_PUSH,\n              sized_string,\n              NULL,\n              NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n         (yyval.expression).type = EXPRESSION_TYPE_STRING;\n         (yyval.expression).value.sized_string = sized_string;\n       }\n#line 3320 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 103:\n#line 1640 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_string_identifier(\n             yyscanner, (yyvsp[0].c_string), OP_COUNT, UNDEFINED);\n\n        yr_free((yyvsp[0].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n#line 3336 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 104:\n#line 1652 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_string_identifier(\n             yyscanner, (yyvsp[-3].c_string), OP_OFFSET, UNDEFINED);\n\n        yr_free((yyvsp[-3].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n#line 3352 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 105:\n#line 1664 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_emit_with_arg(\n             yyscanner, OP_PUSH, 1, NULL, NULL);\n\n        if (compiler->last_result == ERROR_SUCCESS)\n          compiler->last_result = yr_parser_reduce_string_identifier(\n              yyscanner, (yyvsp[0].c_string), OP_OFFSET, UNDEFINED);\n\n        yr_free((yyvsp[0].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n#line 3372 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 106:\n#line 1680 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_string_identifier(\n             yyscanner, (yyvsp[-3].c_string), OP_LENGTH, UNDEFINED);\n\n        yr_free((yyvsp[-3].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n#line 3388 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 107:\n#line 1692 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_emit_with_arg(\n             yyscanner, OP_PUSH, 1, NULL, NULL);\n\n        if (compiler->last_result == ERROR_SUCCESS)\n          compiler->last_result = yr_parser_reduce_string_identifier(\n              yyscanner, (yyvsp[0].c_string), OP_LENGTH, UNDEFINED);\n\n        yr_free((yyvsp[0].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n#line 3408 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 108:\n#line 1708 \"grammar.y\" /* yacc.c:1646  */\n     {\n         if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)  // loop identifier\n         {\n          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n          (yyval.expression).value.integer = UNDEFINED;\n        }\n        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_BOOLEAN)  // rule identifier\n        {\n          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n          (yyval.expression).value.integer = UNDEFINED;\n        }\n        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_OBJECT)\n        {\n          compiler->last_result = yr_parser_emit(\n              yyscanner, OP_OBJ_VALUE, NULL);\n\n          switch((yyvsp[0].expression).value.object->type)\n          {\n            case OBJECT_TYPE_INTEGER:\n              (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n              (yyval.expression).value.integer = UNDEFINED;\n              break;\n            case OBJECT_TYPE_FLOAT:\n              (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n              break;\n            case OBJECT_TYPE_STRING:\n              (yyval.expression).type = EXPRESSION_TYPE_STRING;\n              (yyval.expression).value.sized_string = NULL;\n              break;\n            default:\n              yr_compiler_set_error_extra_info_fmt(\n                  compiler,\n                  \"wrong usage of identifier \\\"%s\\\"\",\n                  (yyvsp[0].expression).identifier);\n              compiler->last_result = ERROR_WRONG_TYPE;\n          }\n        }\n        else\n        {\n          assert(FALSE);\n        }\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n#line 3457 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 109:\n#line 1753 \"grammar.y\" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER | EXPRESSION_TYPE_FLOAT, \"-\");\n \n        if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)\n        {\n          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n          (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?\n              UNDEFINED : -((yyvsp[0].expression).value.integer);\n          compiler->last_result = yr_parser_emit(yyscanner, OP_INT_MINUS, NULL);\n        }\n        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_FLOAT)\n        {\n          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n          compiler->last_result = yr_parser_emit(yyscanner, OP_DBL_MINUS, NULL);\n        }\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n#line 3480 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 110:\n#line 1772 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \"+\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&\n            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)\n        {\n          (yyval.expression).value.integer = OPERATION(+, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n        }\n        else\n        {\n           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n         }\n       }\n#line 3502 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 111:\n#line 1790 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \"-\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&\n            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)\n        {\n          (yyval.expression).value.integer = OPERATION(-, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n        }\n        else\n        {\n           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n         }\n       }\n#line 3524 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 112:\n#line 1808 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \"*\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&\n            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)\n        {\n          (yyval.expression).value.integer = OPERATION(*, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n        }\n        else\n        {\n           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n         }\n       }\n#line 3546 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 113:\n#line 1826 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \"\\\\\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&\n            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)\n        {\n          if ((yyvsp[0].expression).value.integer != 0)\n          {\n            (yyval.expression).value.integer = OPERATION(/, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n            (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n          }\n          else\n          {\n            compiler->last_result = ERROR_DIVISION_BY_ZERO;\n            ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n          }\n        }\n        else\n        {\n           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n         }\n       }\n#line 3576 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 114:\n#line 1852 \"grammar.y\" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"%\");\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"%\");\n\n        yr_parser_emit(yyscanner, OP_MOD, NULL);\n\n        if ((yyvsp[0].expression).value.integer != 0)\n        {\n          (yyval.expression).value.integer = OPERATION(%, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n        }\n        else\n        {\n          compiler->last_result = ERROR_DIVISION_BY_ZERO;\n           ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n         }\n       }\n#line 3598 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 115:\n#line 1870 \"grammar.y\" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"^\");\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"^\");\n\n        yr_parser_emit(yyscanner, OP_BITWISE_XOR, NULL);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = OPERATION(^, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n       }\n#line 3612 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 116:\n#line 1880 \"grammar.y\" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"^\");\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"^\");\n\n        yr_parser_emit(yyscanner, OP_BITWISE_AND, NULL);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = OPERATION(&, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n       }\n#line 3626 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 117:\n#line 1890 \"grammar.y\" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"|\");\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"|\");\n\n        yr_parser_emit(yyscanner, OP_BITWISE_OR, NULL);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = OPERATION(|, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n       }\n#line 3640 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 118:\n#line 1900 \"grammar.y\" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"~\");\n \n        yr_parser_emit(yyscanner, OP_BITWISE_NOT, NULL);\n\n        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?\n             UNDEFINED : ~((yyvsp[0].expression).value.integer);\n       }\n#line 3654 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 119:\n#line 1910 \"grammar.y\" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"<<\");\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"<<\");\n\n        yr_parser_emit(yyscanner, OP_SHL, NULL);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = OPERATION(<<, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n       }\n#line 3668 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 120:\n#line 1920 \"grammar.y\" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \">>\");\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \">>\");\n\n        yr_parser_emit(yyscanner, OP_SHR, NULL);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = OPERATION(>>, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n       }\n#line 3682 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 121:\n#line 1930 \"grammar.y\" /* yacc.c:1646  */\n     {\n         (yyval.expression) = (yyvsp[0].expression);\n       }\n#line 3690 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n \n#line 3694 \"grammar.c\" /* yacc.c:1646  */\n       default: break;\n     }\n   /* User semantic actions sometimes alter yychar, and that requires\n     that yytoken be updated with the new translation.  We take the\n     approach of translating immediately before every use of yytoken.\n     One alternative is translating here after every semantic action,\n     but that translation would be missed if the semantic action invokes\n     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or\n     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an\n     incorrect destructor might then be invoked immediately.  In the\n     case of YYERROR or YYBACKUP, subsequent parser actions might lead\n     to an incorrect destructor call or verbose syntax error message\n     before the lookahead is translated.  */\n  YY_SYMBOL_PRINT (\"-> $$ =\", yyr1[yyn], &yyval, &yyloc);\n\n  YYPOPSTACK (yylen);\n  yylen = 0;\n  YY_STACK_PRINT (yyss, yyssp);\n\n  *++yyvsp = yyval;\n\n  /* Now 'shift' the result of the reduction.  Determine what state\n     that goes to, based on the state we popped back to and the rule\n     number reduced by.  */\n\n  yyn = yyr1[yyn];\n\n  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;\n  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)\n    yystate = yytable[yystate];\n  else\n    yystate = yydefgoto[yyn - YYNTOKENS];\n\n  goto yynewstate;\n\n\n/*--------------------------------------.\n| yyerrlab -- here on detecting error.  |\n`--------------------------------------*/\nyyerrlab:\n  /* Make sure we have latest lookahead translation.  See comments at\n     user semantic actions for why this is necessary.  */\n  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);\n\n  /* If not already recovering from an error, report this error.  */\n  if (!yyerrstatus)\n    {\n      ++yynerrs;\n#if ! YYERROR_VERBOSE\n      yyerror (yyscanner, compiler, YY_(\"syntax error\"));\n#else\n# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \\\n                                        yyssp, yytoken)\n      {\n        char const *yymsgp = YY_(\"syntax error\");\n        int yysyntax_error_status;\n        yysyntax_error_status = YYSYNTAX_ERROR;\n        if (yysyntax_error_status == 0)\n          yymsgp = yymsg;\n        else if (yysyntax_error_status == 1)\n          {\n            if (yymsg != yymsgbuf)\n              YYSTACK_FREE (yymsg);\n            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);\n            if (!yymsg)\n              {\n                yymsg = yymsgbuf;\n                yymsg_alloc = sizeof yymsgbuf;\n                yysyntax_error_status = 2;\n              }\n            else\n              {\n                yysyntax_error_status = YYSYNTAX_ERROR;\n                yymsgp = yymsg;\n              }\n          }\n        yyerror (yyscanner, compiler, yymsgp);\n        if (yysyntax_error_status == 2)\n          goto yyexhaustedlab;\n      }\n# undef YYSYNTAX_ERROR\n#endif\n    }\n\n\n\n  if (yyerrstatus == 3)\n    {\n      /* If just tried and failed to reuse lookahead token after an\n         error, discard it.  */\n\n      if (yychar <= YYEOF)\n        {\n          /* Return failure if at end of input.  */\n          if (yychar == YYEOF)\n            YYABORT;\n        }\n      else\n        {\n          yydestruct (\"Error: discarding\",\n                      yytoken, &yylval, yyscanner, compiler);\n          yychar = YYEMPTY;\n        }\n    }\n\n  /* Else will try to reuse lookahead token after shifting the error\n     token.  */\n  goto yyerrlab1;\n\n\n/*---------------------------------------------------.\n| yyerrorlab -- error raised explicitly by YYERROR.  |\n`---------------------------------------------------*/\nyyerrorlab:\n\n  /* Pacify compilers like GCC when the user code never invokes\n     YYERROR and the label yyerrorlab therefore never appears in user\n     code.  */\n  if (/*CONSTCOND*/ 0)\n     goto yyerrorlab;\n\n  /* Do not reclaim the symbols of the rule whose action triggered\n     this YYERROR.  */\n  YYPOPSTACK (yylen);\n  yylen = 0;\n  YY_STACK_PRINT (yyss, yyssp);\n  yystate = *yyssp;\n  goto yyerrlab1;\n\n\n/*-------------------------------------------------------------.\n| yyerrlab1 -- common code for both syntax error and YYERROR.  |\n`-------------------------------------------------------------*/\nyyerrlab1:\n  yyerrstatus = 3;      /* Each real token shifted decrements this.  */\n\n  for (;;)\n    {\n      yyn = yypact[yystate];\n      if (!yypact_value_is_default (yyn))\n        {\n          yyn += YYTERROR;\n          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)\n            {\n              yyn = yytable[yyn];\n              if (0 < yyn)\n                break;\n            }\n        }\n\n      /* Pop the current state because it cannot handle the error token.  */\n      if (yyssp == yyss)\n        YYABORT;\n\n\n      yydestruct (\"Error: popping\",\n                  yystos[yystate], yyvsp, yyscanner, compiler);\n      YYPOPSTACK (1);\n      yystate = *yyssp;\n      YY_STACK_PRINT (yyss, yyssp);\n    }\n\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  *++yyvsp = yylval;\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n\n\n  /* Shift the error token.  */\n  YY_SYMBOL_PRINT (\"Shifting\", yystos[yyn], yyvsp, yylsp);\n\n  yystate = yyn;\n  goto yynewstate;\n\n\n/*-------------------------------------.\n| yyacceptlab -- YYACCEPT comes here.  |\n`-------------------------------------*/\nyyacceptlab:\n  yyresult = 0;\n  goto yyreturn;\n\n/*-----------------------------------.\n| yyabortlab -- YYABORT comes here.  |\n`-----------------------------------*/\nyyabortlab:\n  yyresult = 1;\n  goto yyreturn;\n\n#if !defined yyoverflow || YYERROR_VERBOSE\n/*-------------------------------------------------.\n| yyexhaustedlab -- memory exhaustion comes here.  |\n`-------------------------------------------------*/\nyyexhaustedlab:\n  yyerror (yyscanner, compiler, YY_(\"memory exhausted\"));\n  yyresult = 2;\n  /* Fall through.  */\n#endif\n\nyyreturn:\n  if (yychar != YYEMPTY)\n    {\n      /* Make sure we have latest lookahead translation.  See comments at\n         user semantic actions for why this is necessary.  */\n      yytoken = YYTRANSLATE (yychar);\n      yydestruct (\"Cleanup: discarding lookahead\",\n                  yytoken, &yylval, yyscanner, compiler);\n    }\n  /* Do not reclaim the symbols of the rule whose action triggered\n     this YYABORT or YYACCEPT.  */\n  YYPOPSTACK (yylen);\n  YY_STACK_PRINT (yyss, yyssp);\n  while (yyssp != yyss)\n    {\n      yydestruct (\"Cleanup: popping\",\n                  yystos[*yyssp], yyvsp, yyscanner, compiler);\n      YYPOPSTACK (1);\n    }\n#ifndef yyoverflow\n  if (yyss != yyssa)\n    YYSTACK_FREE (yyss);\n#endif\n#if YYERROR_VERBOSE\n  if (yymsg != yymsgbuf)\n    YYSTACK_FREE (yymsg);\n #endif\n   return yyresult;\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142701,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "yyparse (void *yyscanner, YR_COMPILER* compiler)\n{\n/* The lookahead symbol.  */\nint yychar;\n\n\n/* The semantic value of the lookahead symbol.  */\n/* Default value used for initialization, for pacifying older GCCs\n   or non-GCC compilers.  */\nYY_INITIAL_VALUE (static YYSTYPE yyval_default;)\nYYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n\n    /* Number of syntax errors so far.  */\n    int yynerrs;\n\n    int yystate;\n    /* Number of tokens to shift before error messages enabled.  */\n    int yyerrstatus;\n\n    /* The stacks and their tools:\n       'yyss': related to states.\n       'yyvs': related to semantic values.\n\n       Refer to the stacks through separate pointers, to allow yyoverflow\n       to reallocate them elsewhere.  */\n\n    /* The state stack.  */\n    yytype_int16 yyssa[YYINITDEPTH];\n    yytype_int16 *yyss;\n    yytype_int16 *yyssp;\n\n    /* The semantic value stack.  */\n    YYSTYPE yyvsa[YYINITDEPTH];\n    YYSTYPE *yyvs;\n    YYSTYPE *yyvsp;\n\n    YYSIZE_T yystacksize;\n\n  int yyn;\n  int yyresult;\n  /* Lookahead token as an internal (translated) token number.  */\n  int yytoken = 0;\n  /* The variables used to return semantic value and location from the\n     action routines.  */\n  YYSTYPE yyval;\n\n#if YYERROR_VERBOSE\n  /* Buffer for error messages, and its allocated size.  */\n  char yymsgbuf[128];\n  char *yymsg = yymsgbuf;\n  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;\n#endif\n\n#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))\n\n  /* The number of symbols on the RHS of the reduced rule.\n     Keep to zero when no symbol should be popped.  */\n  int yylen = 0;\n\n  yyssp = yyss = yyssa;\n  yyvsp = yyvs = yyvsa;\n  yystacksize = YYINITDEPTH;\n\n  YYDPRINTF ((stderr, \"Starting parse\\n\"));\n\n  yystate = 0;\n  yyerrstatus = 0;\n  yynerrs = 0;\n  yychar = YYEMPTY; /* Cause a token to be read.  */\n  goto yysetstate;\n\n/*------------------------------------------------------------.\n| yynewstate -- Push a new state, which is found in yystate.  |\n`------------------------------------------------------------*/\n yynewstate:\n  /* In all cases, when you get here, the value and location stacks\n     have just been pushed.  So pushing a state here evens the stacks.  */\n  yyssp++;\n\n yysetstate:\n  *yyssp = yystate;\n\n  if (yyss + yystacksize - 1 <= yyssp)\n    {\n      /* Get the current used size of the three stacks, in elements.  */\n      YYSIZE_T yysize = yyssp - yyss + 1;\n\n#ifdef yyoverflow\n      {\n        /* Give user a chance to reallocate the stack.  Use copies of\n           these so that the &'s don't force the real ones into\n           memory.  */\n        YYSTYPE *yyvs1 = yyvs;\n        yytype_int16 *yyss1 = yyss;\n\n        /* Each stack pointer address is followed by the size of the\n           data in use in that stack, in bytes.  This used to be a\n           conditional around just the two extra args, but that might\n           be undefined if yyoverflow is a macro.  */\n        yyoverflow (YY_(\"memory exhausted\"),\n                    &yyss1, yysize * sizeof (*yyssp),\n                    &yyvs1, yysize * sizeof (*yyvsp),\n                    &yystacksize);\n\n        yyss = yyss1;\n        yyvs = yyvs1;\n      }\n#else /* no yyoverflow */\n# ifndef YYSTACK_RELOCATE\n      goto yyexhaustedlab;\n# else\n      /* Extend the stack our own way.  */\n      if (YYMAXDEPTH <= yystacksize)\n        goto yyexhaustedlab;\n      yystacksize *= 2;\n      if (YYMAXDEPTH < yystacksize)\n        yystacksize = YYMAXDEPTH;\n\n      {\n        yytype_int16 *yyss1 = yyss;\n        union yyalloc *yyptr =\n          (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));\n        if (! yyptr)\n          goto yyexhaustedlab;\n        YYSTACK_RELOCATE (yyss_alloc, yyss);\n        YYSTACK_RELOCATE (yyvs_alloc, yyvs);\n#  undef YYSTACK_RELOCATE\n        if (yyss1 != yyssa)\n          YYSTACK_FREE (yyss1);\n      }\n# endif\n#endif /* no yyoverflow */\n\n      yyssp = yyss + yysize - 1;\n      yyvsp = yyvs + yysize - 1;\n\n      YYDPRINTF ((stderr, \"Stack size increased to %lu\\n\",\n                  (unsigned long int) yystacksize));\n\n      if (yyss + yystacksize - 1 <= yyssp)\n        YYABORT;\n    }\n\n  YYDPRINTF ((stderr, \"Entering state %d\\n\", yystate));\n\n  if (yystate == YYFINAL)\n    YYACCEPT;\n\n  goto yybackup;\n\n/*-----------.\n| yybackup.  |\n`-----------*/\nyybackup:\n\n  /* Do appropriate processing given the current state.  Read a\n     lookahead token if we need one and don't already have one.  */\n\n  /* First try to decide what to do without reference to lookahead token.  */\n  yyn = yypact[yystate];\n  if (yypact_value_is_default (yyn))\n    goto yydefault;\n\n  /* Not known => get a lookahead token if don't already have one.  */\n\n  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */\n  if (yychar == YYEMPTY)\n    {\n      YYDPRINTF ((stderr, \"Reading a token: \"));\n      yychar = yylex (&yylval, yyscanner, compiler);\n    }\n\n  if (yychar <= YYEOF)\n    {\n      yychar = yytoken = YYEOF;\n      YYDPRINTF ((stderr, \"Now at end of input.\\n\"));\n    }\n  else\n    {\n      yytoken = YYTRANSLATE (yychar);\n      YY_SYMBOL_PRINT (\"Next token is\", yytoken, &yylval, &yylloc);\n    }\n\n  /* If the proper action on seeing token YYTOKEN is to reduce or to\n     detect an error, take that action.  */\n  yyn += yytoken;\n  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)\n    goto yydefault;\n  yyn = yytable[yyn];\n  if (yyn <= 0)\n    {\n      if (yytable_value_is_error (yyn))\n        goto yyerrlab;\n      yyn = -yyn;\n      goto yyreduce;\n    }\n\n  /* Count tokens shifted since error; after three, turn off error\n     status.  */\n  if (yyerrstatus)\n    yyerrstatus--;\n\n  /* Shift the lookahead token.  */\n  YY_SYMBOL_PRINT (\"Shifting\", yytoken, &yylval, &yylloc);\n\n  /* Discard the shifted token.  */\n  yychar = YYEMPTY;\n\n  yystate = yyn;\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  *++yyvsp = yylval;\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n\n  goto yynewstate;\n\n\n/*-----------------------------------------------------------.\n| yydefault -- do the default action for the current state.  |\n`-----------------------------------------------------------*/\nyydefault:\n  yyn = yydefact[yystate];\n  if (yyn == 0)\n    goto yyerrlab;\n  goto yyreduce;\n\n\n/*-----------------------------.\n| yyreduce -- Do a reduction.  |\n`-----------------------------*/\nyyreduce:\n  /* yyn is the number of a rule to reduce with.  */\n  yylen = yyr2[yyn];\n\n  /* If YYLEN is nonzero, implement the default value of the action:\n     '$$ = $1'.\n\n     Otherwise, the following line sets YYVAL to garbage.\n     This behavior is undocumented and Bison\n     users should not rely upon it.  Assigning to YYVAL\n     unconditionally makes the parser a bit smaller, and it avoids a\n     GCC warning that YYVAL may be used uninitialized.  */\n  yyval = yyvsp[1-yylen];\n\n\n  YY_REDUCE_PRINT (yyn);\n  switch (yyn)\n    {\n        case 8:\n#line 230 \"grammar.y\" /* yacc.c:1646  */\n    {\n        int result = yr_parser_reduce_import(yyscanner, (yyvsp[0].sized_string));\n\n        yr_free((yyvsp[0].sized_string));\n\n        ERROR_IF(result != ERROR_SUCCESS);\n      }\n#line 1661 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 9:\n#line 242 \"grammar.y\" /* yacc.c:1646  */\n    {\n        YR_RULE* rule = yr_parser_reduce_rule_declaration_phase_1(\n            yyscanner, (int32_t) (yyvsp[-2].integer), (yyvsp[0].c_string));\n\n        ERROR_IF(rule == NULL);\n\n        (yyval.rule) = rule;\n      }\n#line 1674 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 10:\n#line 251 \"grammar.y\" /* yacc.c:1646  */\n    {\n        YR_RULE* rule = (yyvsp[-4].rule); // rule created in phase 1\n\n        rule->tags = (yyvsp[-3].c_string);\n        rule->metas = (yyvsp[-1].meta);\n        rule->strings = (yyvsp[0].string);\n      }\n#line 1686 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 11:\n#line 259 \"grammar.y\" /* yacc.c:1646  */\n    {\n        YR_RULE* rule = (yyvsp[-7].rule); // rule created in phase 1\n\n        compiler->last_result = yr_parser_reduce_rule_declaration_phase_2(\n            yyscanner, rule);\n\n        yr_free((yyvsp[-8].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n      }\n#line 1701 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 12:\n#line 274 \"grammar.y\" /* yacc.c:1646  */\n    {\n        (yyval.meta) = NULL;\n      }\n#line 1709 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 13:\n#line 278 \"grammar.y\" /* yacc.c:1646  */\n    {\n\n        YR_META null_meta;\n\n        memset(&null_meta, 0xFF, sizeof(YR_META));\n        null_meta.type = META_TYPE_NULL;\n\n        compiler->last_result = yr_arena_write_data(\n            compiler->metas_arena,\n            &null_meta,\n            sizeof(YR_META),\n            NULL);\n\n        (yyval.meta) = (yyvsp[0].meta);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n      }\n#line 1736 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 14:\n#line 305 \"grammar.y\" /* yacc.c:1646  */\n    {\n        (yyval.string) = NULL;\n      }\n#line 1744 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 15:\n#line 309 \"grammar.y\" /* yacc.c:1646  */\n    {\n\n        YR_STRING null_string;\n\n        memset(&null_string, 0xFF, sizeof(YR_STRING));\n        null_string.g_flags = STRING_GFLAGS_NULL;\n\n        compiler->last_result = yr_arena_write_data(\n            compiler->strings_arena,\n            &null_string,\n            sizeof(YR_STRING),\n            NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        (yyval.string) = (yyvsp[0].string);\n      }\n#line 1771 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 17:\n#line 340 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.integer) = 0;  }\n#line 1777 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 18:\n#line 341 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }\n#line 1783 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 19:\n#line 346 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.integer) = RULE_GFLAGS_PRIVATE; }\n#line 1789 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 20:\n#line 347 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.integer) = RULE_GFLAGS_GLOBAL; }\n#line 1795 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 21:\n#line 353 \"grammar.y\" /* yacc.c:1646  */\n    {\n        (yyval.c_string) = NULL;\n      }\n#line 1803 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 22:\n#line 357 \"grammar.y\" /* yacc.c:1646  */\n    {\n\n        compiler->last_result = yr_arena_write_string(\n            yyget_extra(yyscanner)->sz_arena, \"\", NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        (yyval.c_string) = (yyvsp[0].c_string);\n      }\n#line 1821 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 23:\n#line 375 \"grammar.y\" /* yacc.c:1646  */\n    {\n        char* identifier;\n\n        compiler->last_result = yr_arena_write_string(\n            yyget_extra(yyscanner)->sz_arena, (yyvsp[0].c_string), &identifier);\n\n        yr_free((yyvsp[0].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        (yyval.c_string) = identifier;\n      }\n#line 1838 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 24:\n#line 388 \"grammar.y\" /* yacc.c:1646  */\n    {\n        char* tag_name = (yyvsp[-1].c_string);\n        size_t tag_length = tag_name != NULL ? strlen(tag_name) : 0;\n\n        while (tag_length > 0)\n        {\n          if (strcmp(tag_name, (yyvsp[0].c_string)) == 0)\n          {\n            yr_compiler_set_error_extra_info(compiler, tag_name);\n            compiler->last_result = ERROR_DUPLICATED_TAG_IDENTIFIER;\n            break;\n          }\n\n          tag_name = (char*) yr_arena_next_address(\n              yyget_extra(yyscanner)->sz_arena,\n              tag_name,\n              tag_length + 1);\n\n          tag_length = tag_name != NULL ? strlen(tag_name) : 0;\n        }\n\n        if (compiler->last_result == ERROR_SUCCESS)\n          compiler->last_result = yr_arena_write_string(\n              yyget_extra(yyscanner)->sz_arena, (yyvsp[0].c_string), NULL);\n\n        yr_free((yyvsp[0].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        (yyval.c_string) = (yyvsp[-1].c_string);\n      }\n#line 1874 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 25:\n#line 424 \"grammar.y\" /* yacc.c:1646  */\n    {  (yyval.meta) = (yyvsp[0].meta); }\n#line 1880 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 26:\n#line 425 \"grammar.y\" /* yacc.c:1646  */\n    {  (yyval.meta) = (yyvsp[-1].meta); }\n#line 1886 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 27:\n#line 431 \"grammar.y\" /* yacc.c:1646  */\n    {\n        SIZED_STRING* sized_string = (yyvsp[0].sized_string);\n\n        (yyval.meta) = yr_parser_reduce_meta_declaration(\n            yyscanner,\n            META_TYPE_STRING,\n            (yyvsp[-2].c_string),\n            sized_string->c_string,\n            0);\n\n        yr_free((yyvsp[-2].c_string));\n        yr_free((yyvsp[0].sized_string));\n\n        ERROR_IF((yyval.meta) == NULL);\n      }\n#line 1906 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 28:\n#line 447 \"grammar.y\" /* yacc.c:1646  */\n    {\n        (yyval.meta) = yr_parser_reduce_meta_declaration(\n            yyscanner,\n            META_TYPE_INTEGER,\n            (yyvsp[-2].c_string),\n            NULL,\n            (yyvsp[0].integer));\n\n        yr_free((yyvsp[-2].c_string));\n\n        ERROR_IF((yyval.meta) == NULL);\n      }\n#line 1923 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 29:\n#line 460 \"grammar.y\" /* yacc.c:1646  */\n    {\n        (yyval.meta) = yr_parser_reduce_meta_declaration(\n            yyscanner,\n            META_TYPE_INTEGER,\n            (yyvsp[-3].c_string),\n            NULL,\n            -(yyvsp[0].integer));\n\n        yr_free((yyvsp[-3].c_string));\n\n        ERROR_IF((yyval.meta) == NULL);\n      }\n#line 1940 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 30:\n#line 473 \"grammar.y\" /* yacc.c:1646  */\n    {\n        (yyval.meta) = yr_parser_reduce_meta_declaration(\n            yyscanner,\n            META_TYPE_BOOLEAN,\n            (yyvsp[-2].c_string),\n            NULL,\n            TRUE);\n\n        yr_free((yyvsp[-2].c_string));\n\n        ERROR_IF((yyval.meta) == NULL);\n      }\n#line 1957 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 31:\n#line 486 \"grammar.y\" /* yacc.c:1646  */\n    {\n        (yyval.meta) = yr_parser_reduce_meta_declaration(\n            yyscanner,\n            META_TYPE_BOOLEAN,\n            (yyvsp[-2].c_string),\n            NULL,\n            FALSE);\n\n        yr_free((yyvsp[-2].c_string));\n\n        ERROR_IF((yyval.meta) == NULL);\n      }\n#line 1974 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 32:\n#line 502 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.string) = (yyvsp[0].string); }\n#line 1980 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 33:\n#line 503 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.string) = (yyvsp[-1].string); }\n#line 1986 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 34:\n#line 509 \"grammar.y\" /* yacc.c:1646  */\n    {\n        compiler->error_line = yyget_lineno(yyscanner);\n      }\n#line 1994 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 35:\n#line 513 \"grammar.y\" /* yacc.c:1646  */\n    {\n        (yyval.string) = yr_parser_reduce_string_declaration(\n            yyscanner, (int32_t) (yyvsp[0].integer), (yyvsp[-4].c_string), (yyvsp[-1].sized_string));\n\n        yr_free((yyvsp[-4].c_string));\n        yr_free((yyvsp[-1].sized_string));\n\n        ERROR_IF((yyval.string) == NULL);\n        compiler->error_line = 0;\n      }\n#line 2009 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 36:\n#line 524 \"grammar.y\" /* yacc.c:1646  */\n    {\n        compiler->error_line = yyget_lineno(yyscanner);\n      }\n#line 2017 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 37:\n#line 528 \"grammar.y\" /* yacc.c:1646  */\n    {\n        (yyval.string) = yr_parser_reduce_string_declaration(\n            yyscanner, (int32_t) (yyvsp[0].integer) | STRING_GFLAGS_REGEXP, (yyvsp[-4].c_string), (yyvsp[-1].sized_string));\n\n        yr_free((yyvsp[-4].c_string));\n        yr_free((yyvsp[-1].sized_string));\n\n        ERROR_IF((yyval.string) == NULL);\n\n        compiler->error_line = 0;\n      }\n#line 2033 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 38:\n#line 540 \"grammar.y\" /* yacc.c:1646  */\n    {\n        (yyval.string) = yr_parser_reduce_string_declaration(\n            yyscanner, STRING_GFLAGS_HEXADECIMAL, (yyvsp[-2].c_string), (yyvsp[0].sized_string));\n\n        yr_free((yyvsp[-2].c_string));\n        yr_free((yyvsp[0].sized_string));\n\n        ERROR_IF((yyval.string) == NULL);\n      }\n#line 2047 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 39:\n#line 553 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.integer) = 0; }\n#line 2053 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 40:\n#line 554 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }\n#line 2059 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 41:\n#line 559 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.integer) = STRING_GFLAGS_WIDE; }\n#line 2065 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 42:\n#line 560 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.integer) = STRING_GFLAGS_ASCII; }\n#line 2071 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 43:\n#line 561 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.integer) = STRING_GFLAGS_NO_CASE; }\n#line 2077 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 44:\n#line 562 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.integer) = STRING_GFLAGS_FULL_WORD; }\n#line 2083 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 45:\n#line 568 \"grammar.y\" /* yacc.c:1646  */\n    {\n        int var_index = yr_parser_lookup_loop_variable(yyscanner, (yyvsp[0].c_string));\n\n        if (var_index >= 0)\n        {\n          compiler->last_result = yr_parser_emit_with_arg(\n              yyscanner,\n              OP_PUSH_M,\n              LOOP_LOCAL_VARS * var_index,\n              NULL,\n              NULL);\n\n          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n          (yyval.expression).value.integer = UNDEFINED;\n          (yyval.expression).identifier = compiler->loop_identifier[var_index];\n        }\n        else\n        {\n\n          YR_OBJECT* object = (YR_OBJECT*) yr_hash_table_lookup(\n              compiler->objects_table, (yyvsp[0].c_string), NULL);\n\n          if (object == NULL)\n          {\n            char* ns = compiler->current_namespace->name;\n\n            object = (YR_OBJECT*) yr_hash_table_lookup(\n                compiler->objects_table, (yyvsp[0].c_string), ns);\n          }\n\n          if (object != NULL)\n          {\n            char* id;\n\n            compiler->last_result = yr_arena_write_string(\n                compiler->sz_arena, (yyvsp[0].c_string), &id);\n\n            if (compiler->last_result == ERROR_SUCCESS)\n              compiler->last_result = yr_parser_emit_with_arg_reloc(\n                  yyscanner,\n                  OP_OBJ_LOAD,\n                  id,\n                  NULL,\n                  NULL);\n\n            (yyval.expression).type = EXPRESSION_TYPE_OBJECT;\n            (yyval.expression).value.object = object;\n            (yyval.expression).identifier = object->identifier;\n          }\n          else\n          {\n            YR_RULE* rule = (YR_RULE*) yr_hash_table_lookup(\n                compiler->rules_table,\n                (yyvsp[0].c_string),\n                compiler->current_namespace->name);\n\n            if (rule != NULL)\n            {\n              compiler->last_result = yr_parser_emit_with_arg_reloc(\n                  yyscanner,\n                  OP_PUSH_RULE,\n                  rule,\n                  NULL,\n                  NULL);\n\n              (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n              (yyval.expression).value.integer = UNDEFINED;\n              (yyval.expression).identifier = rule->identifier;\n            }\n            else\n            {\n              yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));\n              compiler->last_result = ERROR_UNDEFINED_IDENTIFIER;\n            }\n          }\n        }\n\n        yr_free((yyvsp[0].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n      }\n#line 2172 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 46:\n#line 653 \"grammar.y\" /* yacc.c:1646  */\n    {\n        YR_OBJECT* field = NULL;\n\n        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_OBJECT &&\n            (yyvsp[-2].expression).value.object->type == OBJECT_TYPE_STRUCTURE)\n        {\n          field = yr_object_lookup_field((yyvsp[-2].expression).value.object, (yyvsp[0].c_string));\n\n          if (field != NULL)\n          {\n            char* ident;\n\n            compiler->last_result = yr_arena_write_string(\n              compiler->sz_arena, (yyvsp[0].c_string), &ident);\n\n            if (compiler->last_result == ERROR_SUCCESS)\n              compiler->last_result = yr_parser_emit_with_arg_reloc(\n                  yyscanner,\n                  OP_OBJ_FIELD,\n                  ident,\n                  NULL,\n                  NULL);\n\n            (yyval.expression).type = EXPRESSION_TYPE_OBJECT;\n            (yyval.expression).value.object = field;\n            (yyval.expression).identifier = field->identifier;\n          }\n          else\n          {\n            yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));\n            compiler->last_result = ERROR_INVALID_FIELD_NAME;\n          }\n        }\n        else\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, (yyvsp[-2].expression).identifier);\n\n          compiler->last_result = ERROR_NOT_A_STRUCTURE;\n        }\n\n        yr_free((yyvsp[0].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n      }\n#line 2222 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 47:\n#line 699 \"grammar.y\" /* yacc.c:1646  */\n    {\n        YR_OBJECT_ARRAY* array;\n        YR_OBJECT_DICTIONARY* dict;\n\n        if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&\n            (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_ARRAY)\n        {\n          if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)\n          {\n            yr_compiler_set_error_extra_info(\n                compiler, \"array indexes must be of integer type\");\n            compiler->last_result = ERROR_WRONG_TYPE;\n          }\n\n          ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n          compiler->last_result = yr_parser_emit(\n              yyscanner, OP_INDEX_ARRAY, NULL);\n\n          array = (YR_OBJECT_ARRAY*) (yyvsp[-3].expression).value.object;\n\n          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;\n          (yyval.expression).value.object = array->prototype_item;\n          (yyval.expression).identifier = array->identifier;\n        }\n        else if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&\n                 (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_DICTIONARY)\n        {\n          if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_STRING)\n          {\n            yr_compiler_set_error_extra_info(\n                compiler, \"dictionary keys must be of string type\");\n            compiler->last_result = ERROR_WRONG_TYPE;\n          }\n\n          ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n          compiler->last_result = yr_parser_emit(\n              yyscanner, OP_LOOKUP_DICT, NULL);\n\n          dict = (YR_OBJECT_DICTIONARY*) (yyvsp[-3].expression).value.object;\n\n          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;\n          (yyval.expression).value.object = dict->prototype_item;\n          (yyval.expression).identifier = dict->identifier;\n        }\n        else\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, (yyvsp[-3].expression).identifier);\n\n          compiler->last_result = ERROR_NOT_INDEXABLE;\n        }\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n      }\n#line 2283 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 48:\n#line 757 \"grammar.y\" /* yacc.c:1646  */\n    {\n        YR_OBJECT_FUNCTION* function;\n        char* args_fmt;\n\n        if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&\n            (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_FUNCTION)\n        {\n          compiler->last_result = yr_parser_check_types(\n              compiler, (YR_OBJECT_FUNCTION*) (yyvsp[-3].expression).value.object, (yyvsp[-1].c_string));\n\n          if (compiler->last_result == ERROR_SUCCESS)\n            compiler->last_result = yr_arena_write_string(\n              compiler->sz_arena, (yyvsp[-1].c_string), &args_fmt);\n\n          if (compiler->last_result == ERROR_SUCCESS)\n            compiler->last_result = yr_parser_emit_with_arg_reloc(\n                yyscanner,\n                OP_CALL,\n                args_fmt,\n                NULL,\n                NULL);\n\n          function = (YR_OBJECT_FUNCTION*) (yyvsp[-3].expression).value.object;\n\n          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;\n          (yyval.expression).value.object = function->return_obj;\n          (yyval.expression).identifier = function->identifier;\n        }\n        else\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, (yyvsp[-3].expression).identifier);\n\n          compiler->last_result = ERROR_NOT_A_FUNCTION;\n        }\n\n        yr_free((yyvsp[-1].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n      }\n#line 2328 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 49:\n#line 801 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.c_string) = yr_strdup(\"\"); }\n#line 2334 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 50:\n#line 802 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.c_string) = (yyvsp[0].c_string); }\n#line 2340 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 51:\n#line 807 \"grammar.y\" /* yacc.c:1646  */\n    {\n        (yyval.c_string) = (char*) yr_malloc(MAX_FUNCTION_ARGS + 1);\n\n        switch((yyvsp[0].expression).type)\n        {\n          case EXPRESSION_TYPE_INTEGER:\n            strlcpy((yyval.c_string), \"i\", MAX_FUNCTION_ARGS);\n            break;\n          case EXPRESSION_TYPE_FLOAT:\n            strlcpy((yyval.c_string), \"f\", MAX_FUNCTION_ARGS);\n            break;\n          case EXPRESSION_TYPE_BOOLEAN:\n            strlcpy((yyval.c_string), \"b\", MAX_FUNCTION_ARGS);\n            break;\n          case EXPRESSION_TYPE_STRING:\n            strlcpy((yyval.c_string), \"s\", MAX_FUNCTION_ARGS);\n            break;\n          case EXPRESSION_TYPE_REGEXP:\n            strlcpy((yyval.c_string), \"r\", MAX_FUNCTION_ARGS);\n            break;\n        }\n\n        ERROR_IF((yyval.c_string) == NULL);\n      }\n#line 2369 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 52:\n#line 832 \"grammar.y\" /* yacc.c:1646  */\n    {\n        if (strlen((yyvsp[-2].c_string)) == MAX_FUNCTION_ARGS)\n        {\n          compiler->last_result = ERROR_TOO_MANY_ARGUMENTS;\n        }\n        else\n        {\n          switch((yyvsp[0].expression).type)\n          {\n            case EXPRESSION_TYPE_INTEGER:\n              strlcat((yyvsp[-2].c_string), \"i\", MAX_FUNCTION_ARGS);\n              break;\n            case EXPRESSION_TYPE_FLOAT:\n              strlcat((yyvsp[-2].c_string), \"f\", MAX_FUNCTION_ARGS);\n              break;\n            case EXPRESSION_TYPE_BOOLEAN:\n              strlcat((yyvsp[-2].c_string), \"b\", MAX_FUNCTION_ARGS);\n              break;\n            case EXPRESSION_TYPE_STRING:\n              strlcat((yyvsp[-2].c_string), \"s\", MAX_FUNCTION_ARGS);\n              break;\n            case EXPRESSION_TYPE_REGEXP:\n              strlcat((yyvsp[-2].c_string), \"r\", MAX_FUNCTION_ARGS);\n              break;\n          }\n        }\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        (yyval.c_string) = (yyvsp[-2].c_string);\n      }\n#line 2405 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 53:\n#line 868 \"grammar.y\" /* yacc.c:1646  */\n    {\n        SIZED_STRING* sized_string = (yyvsp[0].sized_string);\n        RE* re;\n        RE_ERROR error;\n\n        int re_flags = 0;\n\n        if (sized_string->flags & SIZED_STRING_FLAGS_NO_CASE)\n          re_flags |= RE_FLAGS_NO_CASE;\n\n        if (sized_string->flags & SIZED_STRING_FLAGS_DOT_ALL)\n          re_flags |= RE_FLAGS_DOT_ALL;\n\n        compiler->last_result = yr_re_compile(\n            sized_string->c_string,\n            re_flags,\n            compiler->re_code_arena,\n            &re,\n            &error);\n\n        yr_free((yyvsp[0].sized_string));\n\n        if (compiler->last_result == ERROR_INVALID_REGULAR_EXPRESSION)\n          yr_compiler_set_error_extra_info(compiler, error.message);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        if (compiler->last_result == ERROR_SUCCESS)\n          compiler->last_result = yr_parser_emit_with_arg_reloc(\n              yyscanner,\n              OP_PUSH,\n              re->root_node->forward_code,\n              NULL,\n              NULL);\n\n        yr_re_destroy(re);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        (yyval.expression).type = EXPRESSION_TYPE_REGEXP;\n      }\n#line 2451 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 54:\n#line 914 \"grammar.y\" /* yacc.c:1646  */\n    {\n        if ((yyvsp[0].expression).type == EXPRESSION_TYPE_STRING)\n        {\n          if ((yyvsp[0].expression).value.sized_string != NULL)\n          {\n            yywarning(yyscanner,\n              \"Using literal string \\\"%s\\\" in a boolean operation.\",\n              (yyvsp[0].expression).value.sized_string->c_string);\n          }\n\n          compiler->last_result = yr_parser_emit(\n              yyscanner, OP_STR_TO_BOOL, NULL);\n\n          ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n        }\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 2474 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 55:\n#line 936 \"grammar.y\" /* yacc.c:1646  */\n    {\n        compiler->last_result = yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH, 1, NULL, NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 2487 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 56:\n#line 945 \"grammar.y\" /* yacc.c:1646  */\n    {\n        compiler->last_result = yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH, 0, NULL, NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 2500 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 57:\n#line 954 \"grammar.y\" /* yacc.c:1646  */\n    {\n        CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, \"matches\");\n        CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_REGEXP, \"matches\");\n\n        if (compiler->last_result == ERROR_SUCCESS)\n          compiler->last_result = yr_parser_emit(\n              yyscanner,\n              OP_MATCHES,\n              NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 2519 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 58:\n#line 969 \"grammar.y\" /* yacc.c:1646  */\n    {\n        CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, \"contains\");\n        CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_STRING, \"contains\");\n\n        compiler->last_result = yr_parser_emit(\n            yyscanner, OP_CONTAINS, NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 2535 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 59:\n#line 981 \"grammar.y\" /* yacc.c:1646  */\n    {\n        int result = yr_parser_reduce_string_identifier(\n            yyscanner,\n            (yyvsp[0].c_string),\n            OP_FOUND,\n            UNDEFINED);\n\n        yr_free((yyvsp[0].c_string));\n\n        ERROR_IF(result != ERROR_SUCCESS);\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 2553 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 60:\n#line 995 \"grammar.y\" /* yacc.c:1646  */\n    {\n        CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"at\");\n\n        compiler->last_result = yr_parser_reduce_string_identifier(\n            yyscanner, (yyvsp[-2].c_string), OP_FOUND_AT, (yyvsp[0].expression).value.integer);\n\n        yr_free((yyvsp[-2].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 2570 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 61:\n#line 1008 \"grammar.y\" /* yacc.c:1646  */\n    {\n        compiler->last_result = yr_parser_reduce_string_identifier(\n            yyscanner, (yyvsp[-2].c_string), OP_FOUND_IN, UNDEFINED);\n\n        yr_free((yyvsp[-2].c_string));\n\n        ERROR_IF(compiler->last_result!= ERROR_SUCCESS);\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 2585 \"grammar.c\" /* yacc.c:1646  */\n    break;\n \n   case 62:\n #line 1019 \"grammar.y\" /* yacc.c:1646  */\n    {\n        compiler->loop_depth--;\n        compiler->loop_identifier[compiler->loop_depth] = NULL;\n      }\n#line 2594 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 63:\n#line 1024 \"grammar.y\" /* yacc.c:1646  */\n     {\n         int var_index;\n \n        if (compiler->loop_depth == MAX_LOOP_NESTING)\n          compiler->last_result = \\\n              ERROR_LOOP_NESTING_LIMIT_EXCEEDED;\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        var_index = yr_parser_lookup_loop_variable(\n            yyscanner, (yyvsp[-1].c_string));\n\n        if (var_index >= 0)\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, (yyvsp[-1].c_string));\n\n          compiler->last_result = \\\n              ERROR_DUPLICATED_LOOP_IDENTIFIER;\n        }\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        compiler->last_result = yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n#line 2628 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 64:\n#line 1054 \"grammar.y\" /* yacc.c:1646  */\n     {\n         int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;\n         uint8_t* addr;\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);\n\n        if ((yyvsp[-1].integer) == INTEGER_SET_ENUMERATION)\n        {\n          yr_parser_emit_with_arg(\n              yyscanner, OP_POP_M, mem_offset, &addr, NULL);\n        }\n        else // INTEGER_SET_RANGE\n        {\n          yr_parser_emit_with_arg(\n              yyscanner, OP_POP_M, mem_offset + 3, &addr, NULL);\n\n          yr_parser_emit_with_arg(\n              yyscanner, OP_POP_M, mem_offset, NULL, NULL);\n        }\n\n        compiler->loop_address[compiler->loop_depth] = addr;\n         compiler->loop_identifier[compiler->loop_depth] = (yyvsp[-4].c_string);\n         compiler->loop_depth++;\n       }\n#line 2667 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 65:\n#line 1089 \"grammar.y\" /* yacc.c:1646  */\n     {\n         int mem_offset;\n \n        compiler->loop_depth--;\n        mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;\n\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);\n\n        if ((yyvsp[-5].integer) == INTEGER_SET_ENUMERATION)\n        {\n          yr_parser_emit_with_arg_reloc(\n              yyscanner,\n              OP_JNUNDEF,\n              compiler->loop_address[compiler->loop_depth],\n              NULL,\n              NULL);\n        }\n        else // INTEGER_SET_RANGE\n        {\n          yr_parser_emit_with_arg(\n              yyscanner, OP_INCR_M, mem_offset, NULL, NULL);\n\n          yr_parser_emit_with_arg(\n              yyscanner, OP_PUSH_M, mem_offset, NULL, NULL);\n\n          yr_parser_emit_with_arg(\n              yyscanner, OP_PUSH_M, mem_offset + 3, NULL, NULL);\n\n          yr_parser_emit_with_arg_reloc(\n              yyscanner,\n              OP_JLE,\n              compiler->loop_address[compiler->loop_depth],\n              NULL,\n              NULL);\n\n          yr_parser_emit(yyscanner, OP_POP, NULL);\n          yr_parser_emit(yyscanner, OP_POP, NULL);\n        }\n\n        yr_parser_emit(yyscanner, OP_POP, NULL);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);\n\n        yr_parser_emit(yyscanner, OP_INT_LE, NULL);\n\n        compiler->loop_identifier[compiler->loop_depth] = NULL;\n        yr_free((yyvsp[-8].c_string));\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 2750 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 66:\n#line 1168 \"grammar.y\" /* yacc.c:1646  */\n     {\n         int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;\n         uint8_t* addr;\n\n        if (compiler->loop_depth == MAX_LOOP_NESTING)\n          compiler->last_result = \\\n            ERROR_LOOP_NESTING_LIMIT_EXCEEDED;\n\n        if (compiler->loop_for_of_mem_offset != -1)\n          compiler->last_result = \\\n            ERROR_NESTED_FOR_OF_LOOP;\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_POP_M, mem_offset, &addr, NULL);\n\n        compiler->loop_for_of_mem_offset = mem_offset;\n        compiler->loop_address[compiler->loop_depth] = addr;\n         compiler->loop_identifier[compiler->loop_depth] = NULL;\n         compiler->loop_depth++;\n       }\n#line 2784 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 67:\n#line 1198 \"grammar.y\" /* yacc.c:1646  */\n     {\n         int mem_offset;\n \n        compiler->loop_depth--;\n        compiler->loop_for_of_mem_offset = -1;\n\n        mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;\n\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);\n\n        yr_parser_emit_with_arg_reloc(\n            yyscanner,\n            OP_JNUNDEF,\n            compiler->loop_address[compiler->loop_depth],\n            NULL,\n            NULL);\n\n        yr_parser_emit(yyscanner, OP_POP, NULL);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);\n\n        yr_parser_emit(yyscanner, OP_INT_LE, NULL);\n\n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n \n       }\n#line 2837 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 68:\n#line 1247 \"grammar.y\" /* yacc.c:1646  */\n     {\n         yr_parser_emit(yyscanner, OP_OF, NULL);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 2847 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 69:\n#line 1253 \"grammar.y\" /* yacc.c:1646  */\n     {\n         yr_parser_emit(yyscanner, OP_NOT, NULL);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 2857 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 70:\n#line 1259 \"grammar.y\" /* yacc.c:1646  */\n     {\n         YR_FIXUP* fixup;\n         void* jmp_destination_addr;\n\n        compiler->last_result = yr_parser_emit_with_arg_reloc(\n            yyscanner,\n            OP_JFALSE,\n            0,          // still don't know the jump destination\n            NULL,\n            &jmp_destination_addr);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));\n\n        if (fixup == NULL)\n          compiler->last_error = ERROR_INSUFFICIENT_MEMORY;\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        fixup->address = jmp_destination_addr;\n         fixup->next = compiler->fixup_stack_head;\n         compiler->fixup_stack_head = fixup;\n       }\n#line 2887 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 71:\n#line 1285 \"grammar.y\" /* yacc.c:1646  */\n     {\n         YR_FIXUP* fixup;\n         uint8_t* and_addr;\n\n\n        compiler->last_result = yr_arena_reserve_memory(\n            compiler->code_arena, 2);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        compiler->last_result = yr_parser_emit(yyscanner, OP_AND, &and_addr);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n\n        fixup = compiler->fixup_stack_head;\n\n\n        *(void**)(fixup->address) = (void*)(and_addr + 1);\n\n        compiler->fixup_stack_head = fixup->next;\n        yr_free(fixup);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 2927 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 72:\n#line 1321 \"grammar.y\" /* yacc.c:1646  */\n     {\n         YR_FIXUP* fixup;\n         void* jmp_destination_addr;\n\n        compiler->last_result = yr_parser_emit_with_arg_reloc(\n            yyscanner,\n            OP_JTRUE,\n            0,         // still don't know the jump destination\n            NULL,\n            &jmp_destination_addr);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));\n\n        if (fixup == NULL)\n          compiler->last_error = ERROR_INSUFFICIENT_MEMORY;\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        fixup->address = jmp_destination_addr;\n         fixup->next = compiler->fixup_stack_head;\n         compiler->fixup_stack_head = fixup;\n       }\n#line 2956 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 73:\n#line 1346 \"grammar.y\" /* yacc.c:1646  */\n     {\n         YR_FIXUP* fixup;\n         uint8_t* or_addr;\n\n\n        compiler->last_result = yr_arena_reserve_memory(\n            compiler->code_arena, 2);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        compiler->last_result = yr_parser_emit(yyscanner, OP_OR, &or_addr);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n\n        fixup = compiler->fixup_stack_head;\n\n\n        *(void**)(fixup->address) = (void*)(or_addr + 1);\n\n        compiler->fixup_stack_head = fixup->next;\n        yr_free(fixup);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 2996 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 74:\n#line 1382 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \"<\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 3009 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 75:\n#line 1391 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \">\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 3022 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 76:\n#line 1400 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \"<=\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 3035 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 77:\n#line 1409 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \">=\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 3048 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 78:\n#line 1418 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \"==\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 3061 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 79:\n#line 1427 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \"!=\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 3074 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 80:\n#line 1436 \"grammar.y\" /* yacc.c:1646  */\n     {\n         (yyval.expression) = (yyvsp[0].expression);\n       }\n#line 3082 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 81:\n#line 1440 \"grammar.y\" /* yacc.c:1646  */\n     {\n         (yyval.expression) = (yyvsp[-1].expression);\n       }\n#line 3090 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 82:\n#line 1447 \"grammar.y\" /* yacc.c:1646  */\n     { (yyval.integer) = INTEGER_SET_ENUMERATION; }\n#line 3096 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 83:\n#line 1448 \"grammar.y\" /* yacc.c:1646  */\n     { (yyval.integer) = INTEGER_SET_RANGE; }\n#line 3102 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 84:\n#line 1454 \"grammar.y\" /* yacc.c:1646  */\n     {\n         if ((yyvsp[-3].expression).type != EXPRESSION_TYPE_INTEGER)\n         {\n          yr_compiler_set_error_extra_info(\n              compiler, \"wrong type for range's lower bound\");\n          compiler->last_result = ERROR_WRONG_TYPE;\n        }\n\n        if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, \"wrong type for range's upper bound\");\n          compiler->last_result = ERROR_WRONG_TYPE;\n        }\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n#line 3124 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 85:\n#line 1476 \"grammar.y\" /* yacc.c:1646  */\n     {\n         if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)\n         {\n          yr_compiler_set_error_extra_info(\n              compiler, \"wrong type for enumeration item\");\n          compiler->last_result = ERROR_WRONG_TYPE;\n\n        }\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n#line 3140 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 86:\n#line 1488 \"grammar.y\" /* yacc.c:1646  */\n     {\n         if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)\n         {\n          yr_compiler_set_error_extra_info(\n              compiler, \"wrong type for enumeration item\");\n          compiler->last_result = ERROR_WRONG_TYPE;\n        }\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n#line 3155 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 87:\n#line 1503 \"grammar.y\" /* yacc.c:1646  */\n     {\n         yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);\n       }\n#line 3164 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 89:\n#line 1509 \"grammar.y\" /* yacc.c:1646  */\n     {\n         yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);\n         yr_parser_emit_pushes_for_strings(yyscanner, \"$*\");\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n#line 3175 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 92:\n#line 1526 \"grammar.y\" /* yacc.c:1646  */\n     {\n         yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));\n         yr_free((yyvsp[0].c_string));\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n#line 3186 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 93:\n#line 1533 \"grammar.y\" /* yacc.c:1646  */\n     {\n         yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));\n         yr_free((yyvsp[0].c_string));\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n#line 3197 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 95:\n#line 1545 \"grammar.y\" /* yacc.c:1646  */\n     {\n         yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);\n       }\n#line 3205 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 96:\n#line 1549 \"grammar.y\" /* yacc.c:1646  */\n     {\n         yr_parser_emit_with_arg(yyscanner, OP_PUSH, 1, NULL, NULL);\n       }\n#line 3213 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 97:\n#line 1557 \"grammar.y\" /* yacc.c:1646  */\n     {\n         (yyval.expression) = (yyvsp[-1].expression);\n       }\n#line 3221 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 98:\n#line 1561 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_emit(\n             yyscanner, OP_FILESIZE, NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n#line 3235 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 99:\n#line 1571 \"grammar.y\" /* yacc.c:1646  */\n     {\n         yywarning(yyscanner,\n             \"Using deprecated \\\"entrypoint\\\" keyword. Use the \\\"entry_point\\\" \"\n            \"function from PE module instead.\");\n\n        compiler->last_result = yr_parser_emit(\n            yyscanner, OP_ENTRYPOINT, NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n#line 3253 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 100:\n#line 1585 \"grammar.y\" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[-1].expression), EXPRESSION_TYPE_INTEGER, \"intXXXX or uintXXXX\");\n \n\n        compiler->last_result = yr_parser_emit(\n            yyscanner, (uint8_t) (OP_READ_INT + (yyvsp[-3].integer)), NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n#line 3273 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 101:\n#line 1601 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_emit_with_arg(\n             yyscanner, OP_PUSH, (yyvsp[0].integer), NULL, NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = (yyvsp[0].integer);\n       }\n#line 3287 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 102:\n#line 1611 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_emit_with_arg_double(\n             yyscanner, OP_PUSH, (yyvsp[0].double_), NULL, NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n \n         (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n       }\n#line 3300 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 103:\n#line 1620 \"grammar.y\" /* yacc.c:1646  */\n     {\n         SIZED_STRING* sized_string;\n \n        compiler->last_result = yr_arena_write_data(\n            compiler->sz_arena,\n            (yyvsp[0].sized_string),\n            (yyvsp[0].sized_string)->length + sizeof(SIZED_STRING),\n            (void**) &sized_string);\n\n        yr_free((yyvsp[0].sized_string));\n\n        if (compiler->last_result == ERROR_SUCCESS)\n          compiler->last_result = yr_parser_emit_with_arg_reloc(\n              yyscanner,\n              OP_PUSH,\n              sized_string,\n              NULL,\n              NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n         (yyval.expression).type = EXPRESSION_TYPE_STRING;\n         (yyval.expression).value.sized_string = sized_string;\n       }\n#line 3329 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 104:\n#line 1645 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_string_identifier(\n             yyscanner, (yyvsp[0].c_string), OP_COUNT, UNDEFINED);\n\n        yr_free((yyvsp[0].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n#line 3345 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 105:\n#line 1657 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_string_identifier(\n             yyscanner, (yyvsp[-3].c_string), OP_OFFSET, UNDEFINED);\n\n        yr_free((yyvsp[-3].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n#line 3361 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 106:\n#line 1669 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_emit_with_arg(\n             yyscanner, OP_PUSH, 1, NULL, NULL);\n\n        if (compiler->last_result == ERROR_SUCCESS)\n          compiler->last_result = yr_parser_reduce_string_identifier(\n              yyscanner, (yyvsp[0].c_string), OP_OFFSET, UNDEFINED);\n\n        yr_free((yyvsp[0].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n#line 3381 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 107:\n#line 1685 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_string_identifier(\n             yyscanner, (yyvsp[-3].c_string), OP_LENGTH, UNDEFINED);\n\n        yr_free((yyvsp[-3].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n#line 3397 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 108:\n#line 1697 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_emit_with_arg(\n             yyscanner, OP_PUSH, 1, NULL, NULL);\n\n        if (compiler->last_result == ERROR_SUCCESS)\n          compiler->last_result = yr_parser_reduce_string_identifier(\n              yyscanner, (yyvsp[0].c_string), OP_LENGTH, UNDEFINED);\n\n        yr_free((yyvsp[0].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n#line 3417 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 109:\n#line 1713 \"grammar.y\" /* yacc.c:1646  */\n     {\n         if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)  // loop identifier\n         {\n          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n          (yyval.expression).value.integer = UNDEFINED;\n        }\n        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_BOOLEAN)  // rule identifier\n        {\n          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n          (yyval.expression).value.integer = UNDEFINED;\n        }\n        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_OBJECT)\n        {\n          compiler->last_result = yr_parser_emit(\n              yyscanner, OP_OBJ_VALUE, NULL);\n\n          switch((yyvsp[0].expression).value.object->type)\n          {\n            case OBJECT_TYPE_INTEGER:\n              (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n              (yyval.expression).value.integer = UNDEFINED;\n              break;\n            case OBJECT_TYPE_FLOAT:\n              (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n              break;\n            case OBJECT_TYPE_STRING:\n              (yyval.expression).type = EXPRESSION_TYPE_STRING;\n              (yyval.expression).value.sized_string = NULL;\n              break;\n            default:\n              yr_compiler_set_error_extra_info_fmt(\n                  compiler,\n                  \"wrong usage of identifier \\\"%s\\\"\",\n                  (yyvsp[0].expression).identifier);\n              compiler->last_result = ERROR_WRONG_TYPE;\n          }\n        }\n        else\n        {\n          assert(FALSE);\n        }\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n#line 3466 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 110:\n#line 1758 \"grammar.y\" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER | EXPRESSION_TYPE_FLOAT, \"-\");\n \n        if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)\n        {\n          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n          (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?\n              UNDEFINED : -((yyvsp[0].expression).value.integer);\n          compiler->last_result = yr_parser_emit(yyscanner, OP_INT_MINUS, NULL);\n        }\n        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_FLOAT)\n        {\n          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n          compiler->last_result = yr_parser_emit(yyscanner, OP_DBL_MINUS, NULL);\n        }\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n#line 3489 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 111:\n#line 1777 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \"+\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&\n            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)\n        {\n          (yyval.expression).value.integer = OPERATION(+, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n        }\n        else\n        {\n           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n         }\n       }\n#line 3511 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 112:\n#line 1795 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \"-\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&\n            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)\n        {\n          (yyval.expression).value.integer = OPERATION(-, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n        }\n        else\n        {\n           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n         }\n       }\n#line 3533 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 113:\n#line 1813 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \"*\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&\n            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)\n        {\n          (yyval.expression).value.integer = OPERATION(*, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n        }\n        else\n        {\n           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n         }\n       }\n#line 3555 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 114:\n#line 1831 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \"\\\\\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&\n            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)\n        {\n          if ((yyvsp[0].expression).value.integer != 0)\n          {\n            (yyval.expression).value.integer = OPERATION(/, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n            (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n          }\n          else\n          {\n            compiler->last_result = ERROR_DIVISION_BY_ZERO;\n            ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n          }\n        }\n        else\n        {\n           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n         }\n       }\n#line 3585 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 115:\n#line 1857 \"grammar.y\" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"%\");\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"%\");\n\n        yr_parser_emit(yyscanner, OP_MOD, NULL);\n\n        if ((yyvsp[0].expression).value.integer != 0)\n        {\n          (yyval.expression).value.integer = OPERATION(%, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n        }\n        else\n        {\n          compiler->last_result = ERROR_DIVISION_BY_ZERO;\n           ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n         }\n       }\n#line 3607 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 116:\n#line 1875 \"grammar.y\" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"^\");\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"^\");\n\n        yr_parser_emit(yyscanner, OP_BITWISE_XOR, NULL);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = OPERATION(^, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n       }\n#line 3621 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 117:\n#line 1885 \"grammar.y\" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"^\");\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"^\");\n\n        yr_parser_emit(yyscanner, OP_BITWISE_AND, NULL);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = OPERATION(&, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n       }\n#line 3635 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 118:\n#line 1895 \"grammar.y\" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"|\");\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"|\");\n\n        yr_parser_emit(yyscanner, OP_BITWISE_OR, NULL);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = OPERATION(|, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n       }\n#line 3649 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 119:\n#line 1905 \"grammar.y\" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"~\");\n \n        yr_parser_emit(yyscanner, OP_BITWISE_NOT, NULL);\n\n        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?\n             UNDEFINED : ~((yyvsp[0].expression).value.integer);\n       }\n#line 3663 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 120:\n#line 1915 \"grammar.y\" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"<<\");\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"<<\");\n\n        yr_parser_emit(yyscanner, OP_SHL, NULL);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = OPERATION(<<, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n       }\n#line 3677 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 121:\n#line 1925 \"grammar.y\" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \">>\");\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \">>\");\n\n        yr_parser_emit(yyscanner, OP_SHR, NULL);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = OPERATION(>>, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n       }\n#line 3691 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 122:\n#line 1935 \"grammar.y\" /* yacc.c:1646  */\n     {\n         (yyval.expression) = (yyvsp[0].expression);\n       }\n#line 3699 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n \n#line 3703 \"grammar.c\" /* yacc.c:1646  */\n       default: break;\n     }\n   /* User semantic actions sometimes alter yychar, and that requires\n     that yytoken be updated with the new translation.  We take the\n     approach of translating immediately before every use of yytoken.\n     One alternative is translating here after every semantic action,\n     but that translation would be missed if the semantic action invokes\n     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or\n     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an\n     incorrect destructor might then be invoked immediately.  In the\n     case of YYERROR or YYBACKUP, subsequent parser actions might lead\n     to an incorrect destructor call or verbose syntax error message\n     before the lookahead is translated.  */\n  YY_SYMBOL_PRINT (\"-> $$ =\", yyr1[yyn], &yyval, &yyloc);\n\n  YYPOPSTACK (yylen);\n  yylen = 0;\n  YY_STACK_PRINT (yyss, yyssp);\n\n  *++yyvsp = yyval;\n\n  /* Now 'shift' the result of the reduction.  Determine what state\n     that goes to, based on the state we popped back to and the rule\n     number reduced by.  */\n\n  yyn = yyr1[yyn];\n\n  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;\n  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)\n    yystate = yytable[yystate];\n  else\n    yystate = yydefgoto[yyn - YYNTOKENS];\n\n  goto yynewstate;\n\n\n/*--------------------------------------.\n| yyerrlab -- here on detecting error.  |\n`--------------------------------------*/\nyyerrlab:\n  /* Make sure we have latest lookahead translation.  See comments at\n     user semantic actions for why this is necessary.  */\n  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);\n\n  /* If not already recovering from an error, report this error.  */\n  if (!yyerrstatus)\n    {\n      ++yynerrs;\n#if ! YYERROR_VERBOSE\n      yyerror (yyscanner, compiler, YY_(\"syntax error\"));\n#else\n# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \\\n                                        yyssp, yytoken)\n      {\n        char const *yymsgp = YY_(\"syntax error\");\n        int yysyntax_error_status;\n        yysyntax_error_status = YYSYNTAX_ERROR;\n        if (yysyntax_error_status == 0)\n          yymsgp = yymsg;\n        else if (yysyntax_error_status == 1)\n          {\n            if (yymsg != yymsgbuf)\n              YYSTACK_FREE (yymsg);\n            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);\n            if (!yymsg)\n              {\n                yymsg = yymsgbuf;\n                yymsg_alloc = sizeof yymsgbuf;\n                yysyntax_error_status = 2;\n              }\n            else\n              {\n                yysyntax_error_status = YYSYNTAX_ERROR;\n                yymsgp = yymsg;\n              }\n          }\n        yyerror (yyscanner, compiler, yymsgp);\n        if (yysyntax_error_status == 2)\n          goto yyexhaustedlab;\n      }\n# undef YYSYNTAX_ERROR\n#endif\n    }\n\n\n\n  if (yyerrstatus == 3)\n    {\n      /* If just tried and failed to reuse lookahead token after an\n         error, discard it.  */\n\n      if (yychar <= YYEOF)\n        {\n          /* Return failure if at end of input.  */\n          if (yychar == YYEOF)\n            YYABORT;\n        }\n      else\n        {\n          yydestruct (\"Error: discarding\",\n                      yytoken, &yylval, yyscanner, compiler);\n          yychar = YYEMPTY;\n        }\n    }\n\n  /* Else will try to reuse lookahead token after shifting the error\n     token.  */\n  goto yyerrlab1;\n\n\n/*---------------------------------------------------.\n| yyerrorlab -- error raised explicitly by YYERROR.  |\n`---------------------------------------------------*/\nyyerrorlab:\n\n  /* Pacify compilers like GCC when the user code never invokes\n     YYERROR and the label yyerrorlab therefore never appears in user\n     code.  */\n  if (/*CONSTCOND*/ 0)\n     goto yyerrorlab;\n\n  /* Do not reclaim the symbols of the rule whose action triggered\n     this YYERROR.  */\n  YYPOPSTACK (yylen);\n  yylen = 0;\n  YY_STACK_PRINT (yyss, yyssp);\n  yystate = *yyssp;\n  goto yyerrlab1;\n\n\n/*-------------------------------------------------------------.\n| yyerrlab1 -- common code for both syntax error and YYERROR.  |\n`-------------------------------------------------------------*/\nyyerrlab1:\n  yyerrstatus = 3;      /* Each real token shifted decrements this.  */\n\n  for (;;)\n    {\n      yyn = yypact[yystate];\n      if (!yypact_value_is_default (yyn))\n        {\n          yyn += YYTERROR;\n          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)\n            {\n              yyn = yytable[yyn];\n              if (0 < yyn)\n                break;\n            }\n        }\n\n      /* Pop the current state because it cannot handle the error token.  */\n      if (yyssp == yyss)\n        YYABORT;\n\n\n      yydestruct (\"Error: popping\",\n                  yystos[yystate], yyvsp, yyscanner, compiler);\n      YYPOPSTACK (1);\n      yystate = *yyssp;\n      YY_STACK_PRINT (yyss, yyssp);\n    }\n\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  *++yyvsp = yylval;\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n\n\n  /* Shift the error token.  */\n  YY_SYMBOL_PRINT (\"Shifting\", yystos[yyn], yyvsp, yylsp);\n\n  yystate = yyn;\n  goto yynewstate;\n\n\n/*-------------------------------------.\n| yyacceptlab -- YYACCEPT comes here.  |\n`-------------------------------------*/\nyyacceptlab:\n  yyresult = 0;\n  goto yyreturn;\n\n/*-----------------------------------.\n| yyabortlab -- YYABORT comes here.  |\n`-----------------------------------*/\nyyabortlab:\n  yyresult = 1;\n  goto yyreturn;\n\n#if !defined yyoverflow || YYERROR_VERBOSE\n/*-------------------------------------------------.\n| yyexhaustedlab -- memory exhaustion comes here.  |\n`-------------------------------------------------*/\nyyexhaustedlab:\n  yyerror (yyscanner, compiler, YY_(\"memory exhausted\"));\n  yyresult = 2;\n  /* Fall through.  */\n#endif\n\nyyreturn:\n  if (yychar != YYEMPTY)\n    {\n      /* Make sure we have latest lookahead translation.  See comments at\n         user semantic actions for why this is necessary.  */\n      yytoken = YYTRANSLATE (yychar);\n      yydestruct (\"Cleanup: discarding lookahead\",\n                  yytoken, &yylval, yyscanner, compiler);\n    }\n  /* Do not reclaim the symbols of the rule whose action triggered\n     this YYABORT or YYACCEPT.  */\n  YYPOPSTACK (yylen);\n  YY_STACK_PRINT (yyss, yyssp);\n  while (yyssp != yyss)\n    {\n      yydestruct (\"Cleanup: popping\",\n                  yystos[*yyssp], yyvsp, yyscanner, compiler);\n      YYPOPSTACK (1);\n    }\n#ifndef yyoverflow\n  if (yyss != yyssa)\n    YYSTACK_FREE (yyss);\n#endif\n#if YYERROR_VERBOSE\n  if (yymsg != yymsgbuf)\n    YYSTACK_FREE (yymsg);\n #endif\n   return yyresult;\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142702,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int l2tp_ip_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct sockaddr_l2tpip *addr = (struct sockaddr_l2tpip *) uaddr;\n\tstruct net *net = sock_net(sk);\n \tint ret;\n \tint chk_addr_ret;\n \n\tif (!sock_flag(sk, SOCK_ZAPPED))\n\t\treturn -EINVAL;\n \tif (addr_len < sizeof(struct sockaddr_l2tpip))\n \t\treturn -EINVAL;\n \tif (addr->l2tp_family != AF_INET)\n\t\treturn -EINVAL;\n\n\tret = -EADDRINUSE;\n\tread_lock_bh(&l2tp_ip_lock);\n\tif (__l2tp_ip_bind_lookup(net, addr->l2tp_addr.s_addr,\n\t\t\t\t  sk->sk_bound_dev_if, addr->l2tp_conn_id))\n\t\tgoto out_in_use;\n\n \tread_unlock_bh(&l2tp_ip_lock);\n \n \tlock_sock(sk);\n \tif (sk->sk_state != TCP_CLOSE || addr_len < sizeof(struct sockaddr_l2tpip))\n \t\tgoto out;\n \n\tchk_addr_ret = inet_addr_type(net, addr->l2tp_addr.s_addr);\n\tret = -EADDRNOTAVAIL;\n\tif (addr->l2tp_addr.s_addr && chk_addr_ret != RTN_LOCAL &&\n\t    chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST)\n\t\tgoto out;\n\n\tif (addr->l2tp_addr.s_addr)\n\t\tinet->inet_rcv_saddr = inet->inet_saddr = addr->l2tp_addr.s_addr;\n\tif (chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST)\n\t\tinet->inet_saddr = 0;  /* Use device */\n\tsk_dst_reset(sk);\n\n\tl2tp_ip_sk(sk)->conn_id = addr->l2tp_conn_id;\n\n\twrite_lock_bh(&l2tp_ip_lock);\n\tsk_add_bind_node(sk, &l2tp_ip_bind_table);\n\tsk_del_node_init(sk);\n\twrite_unlock_bh(&l2tp_ip_lock);\n\tret = 0;\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\nout:\n\trelease_sock(sk);\n\n\treturn ret;\n\nout_in_use:\n\tread_unlock_bh(&l2tp_ip_lock);\n\n\treturn ret;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142707,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int l2tp_ip_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct sockaddr_l2tpip *addr = (struct sockaddr_l2tpip *) uaddr;\n\tstruct net *net = sock_net(sk);\n \tint ret;\n \tint chk_addr_ret;\n \n \tif (addr_len < sizeof(struct sockaddr_l2tpip))\n \t\treturn -EINVAL;\n \tif (addr->l2tp_family != AF_INET)\n\t\treturn -EINVAL;\n\n\tret = -EADDRINUSE;\n\tread_lock_bh(&l2tp_ip_lock);\n\tif (__l2tp_ip_bind_lookup(net, addr->l2tp_addr.s_addr,\n\t\t\t\t  sk->sk_bound_dev_if, addr->l2tp_conn_id))\n\t\tgoto out_in_use;\n\n \tread_unlock_bh(&l2tp_ip_lock);\n \n \tlock_sock(sk);\n\tif (!sock_flag(sk, SOCK_ZAPPED))\n\t\tgoto out;\n\n \tif (sk->sk_state != TCP_CLOSE || addr_len < sizeof(struct sockaddr_l2tpip))\n \t\tgoto out;\n \n\tchk_addr_ret = inet_addr_type(net, addr->l2tp_addr.s_addr);\n\tret = -EADDRNOTAVAIL;\n\tif (addr->l2tp_addr.s_addr && chk_addr_ret != RTN_LOCAL &&\n\t    chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST)\n\t\tgoto out;\n\n\tif (addr->l2tp_addr.s_addr)\n\t\tinet->inet_rcv_saddr = inet->inet_saddr = addr->l2tp_addr.s_addr;\n\tif (chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST)\n\t\tinet->inet_saddr = 0;  /* Use device */\n\tsk_dst_reset(sk);\n\n\tl2tp_ip_sk(sk)->conn_id = addr->l2tp_conn_id;\n\n\twrite_lock_bh(&l2tp_ip_lock);\n\tsk_add_bind_node(sk, &l2tp_ip_bind_table);\n\tsk_del_node_init(sk);\n\twrite_unlock_bh(&l2tp_ip_lock);\n\tret = 0;\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\nout:\n\trelease_sock(sk);\n\n\treturn ret;\n\nout_in_use:\n\tread_unlock_bh(&l2tp_ip_lock);\n\n\treturn ret;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142708,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int l2tp_ip6_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sockaddr_l2tpip6 *addr = (struct sockaddr_l2tpip6 *) uaddr;\n\tstruct net *net = sock_net(sk);\n\t__be32 v4addr = 0;\n \tint addr_type;\n \tint err;\n \n\tif (!sock_flag(sk, SOCK_ZAPPED))\n\t\treturn -EINVAL;\n \tif (addr->l2tp_family != AF_INET6)\n \t\treturn -EINVAL;\n \tif (addr_len < sizeof(*addr))\n\t\treturn -EINVAL;\n\n\taddr_type = ipv6_addr_type(&addr->l2tp_addr);\n\n\t/* l2tp_ip6 sockets are IPv6 only */\n\tif (addr_type == IPV6_ADDR_MAPPED)\n\t\treturn -EADDRNOTAVAIL;\n\n\t/* L2TP is point-point, not multicast */\n\tif (addr_type & IPV6_ADDR_MULTICAST)\n\t\treturn -EADDRNOTAVAIL;\n\n\terr = -EADDRINUSE;\n\tread_lock_bh(&l2tp_ip6_lock);\n\tif (__l2tp_ip6_bind_lookup(net, &addr->l2tp_addr,\n\t\t\t\t   sk->sk_bound_dev_if, addr->l2tp_conn_id))\n\t\tgoto out_in_use;\n\tread_unlock_bh(&l2tp_ip6_lock);\n\n \tlock_sock(sk);\n \n \terr = -EINVAL;\n \tif (sk->sk_state != TCP_CLOSE)\n \t\tgoto out_unlock;\n \n\t/* Check if the address belongs to the host. */\n\trcu_read_lock();\n\tif (addr_type != IPV6_ADDR_ANY) {\n\t\tstruct net_device *dev = NULL;\n\n\t\tif (addr_type & IPV6_ADDR_LINKLOCAL) {\n\t\t\tif (addr_len >= sizeof(struct sockaddr_in6) &&\n\t\t\t    addr->l2tp_scope_id) {\n\t\t\t\t/* Override any existing binding, if another\n\t\t\t\t * one is supplied by user.\n\t\t\t\t */\n\t\t\t\tsk->sk_bound_dev_if = addr->l2tp_scope_id;\n\t\t\t}\n\n\t\t\t/* Binding to link-local address requires an\n\t\t\t   interface */\n\t\t\tif (!sk->sk_bound_dev_if)\n\t\t\t\tgoto out_unlock_rcu;\n\n\t\t\terr = -ENODEV;\n\t\t\tdev = dev_get_by_index_rcu(sock_net(sk),\n\t\t\t\t\t\t   sk->sk_bound_dev_if);\n\t\t\tif (!dev)\n\t\t\t\tgoto out_unlock_rcu;\n\t\t}\n\n\t\t/* ipv4 addr of the socket is invalid.  Only the\n\t\t * unspecified and mapped address have a v4 equivalent.\n\t\t */\n\t\tv4addr = LOOPBACK4_IPV6;\n\t\terr = -EADDRNOTAVAIL;\n\t\tif (!ipv6_chk_addr(sock_net(sk), &addr->l2tp_addr, dev, 0))\n\t\t\tgoto out_unlock_rcu;\n\t}\n\trcu_read_unlock();\n\n\tinet->inet_rcv_saddr = inet->inet_saddr = v4addr;\n\tsk->sk_v6_rcv_saddr = addr->l2tp_addr;\n\tnp->saddr = addr->l2tp_addr;\n\n\tl2tp_ip6_sk(sk)->conn_id = addr->l2tp_conn_id;\n\n\twrite_lock_bh(&l2tp_ip6_lock);\n\tsk_add_bind_node(sk, &l2tp_ip6_bind_table);\n\tsk_del_node_init(sk);\n\twrite_unlock_bh(&l2tp_ip6_lock);\n\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\trelease_sock(sk);\n\treturn 0;\n\nout_unlock_rcu:\n\trcu_read_unlock();\nout_unlock:\n\trelease_sock(sk);\n\treturn err;\n\nout_in_use:\n\tread_unlock_bh(&l2tp_ip6_lock);\n\treturn err;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142709,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int l2tp_ip6_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sockaddr_l2tpip6 *addr = (struct sockaddr_l2tpip6 *) uaddr;\n\tstruct net *net = sock_net(sk);\n\t__be32 v4addr = 0;\n \tint addr_type;\n \tint err;\n \n \tif (addr->l2tp_family != AF_INET6)\n \t\treturn -EINVAL;\n \tif (addr_len < sizeof(*addr))\n\t\treturn -EINVAL;\n\n\taddr_type = ipv6_addr_type(&addr->l2tp_addr);\n\n\t/* l2tp_ip6 sockets are IPv6 only */\n\tif (addr_type == IPV6_ADDR_MAPPED)\n\t\treturn -EADDRNOTAVAIL;\n\n\t/* L2TP is point-point, not multicast */\n\tif (addr_type & IPV6_ADDR_MULTICAST)\n\t\treturn -EADDRNOTAVAIL;\n\n\terr = -EADDRINUSE;\n\tread_lock_bh(&l2tp_ip6_lock);\n\tif (__l2tp_ip6_bind_lookup(net, &addr->l2tp_addr,\n\t\t\t\t   sk->sk_bound_dev_if, addr->l2tp_conn_id))\n\t\tgoto out_in_use;\n\tread_unlock_bh(&l2tp_ip6_lock);\n\n \tlock_sock(sk);\n \n \terr = -EINVAL;\n\tif (!sock_flag(sk, SOCK_ZAPPED))\n\t\tgoto out_unlock;\n\n \tif (sk->sk_state != TCP_CLOSE)\n \t\tgoto out_unlock;\n \n\t/* Check if the address belongs to the host. */\n\trcu_read_lock();\n\tif (addr_type != IPV6_ADDR_ANY) {\n\t\tstruct net_device *dev = NULL;\n\n\t\tif (addr_type & IPV6_ADDR_LINKLOCAL) {\n\t\t\tif (addr_len >= sizeof(struct sockaddr_in6) &&\n\t\t\t    addr->l2tp_scope_id) {\n\t\t\t\t/* Override any existing binding, if another\n\t\t\t\t * one is supplied by user.\n\t\t\t\t */\n\t\t\t\tsk->sk_bound_dev_if = addr->l2tp_scope_id;\n\t\t\t}\n\n\t\t\t/* Binding to link-local address requires an\n\t\t\t   interface */\n\t\t\tif (!sk->sk_bound_dev_if)\n\t\t\t\tgoto out_unlock_rcu;\n\n\t\t\terr = -ENODEV;\n\t\t\tdev = dev_get_by_index_rcu(sock_net(sk),\n\t\t\t\t\t\t   sk->sk_bound_dev_if);\n\t\t\tif (!dev)\n\t\t\t\tgoto out_unlock_rcu;\n\t\t}\n\n\t\t/* ipv4 addr of the socket is invalid.  Only the\n\t\t * unspecified and mapped address have a v4 equivalent.\n\t\t */\n\t\tv4addr = LOOPBACK4_IPV6;\n\t\terr = -EADDRNOTAVAIL;\n\t\tif (!ipv6_chk_addr(sock_net(sk), &addr->l2tp_addr, dev, 0))\n\t\t\tgoto out_unlock_rcu;\n\t}\n\trcu_read_unlock();\n\n\tinet->inet_rcv_saddr = inet->inet_saddr = v4addr;\n\tsk->sk_v6_rcv_saddr = addr->l2tp_addr;\n\tnp->saddr = addr->l2tp_addr;\n\n\tl2tp_ip6_sk(sk)->conn_id = addr->l2tp_conn_id;\n\n\twrite_lock_bh(&l2tp_ip6_lock);\n\tsk_add_bind_node(sk, &l2tp_ip6_bind_table);\n\tsk_del_node_init(sk);\n\twrite_unlock_bh(&l2tp_ip6_lock);\n\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\trelease_sock(sk);\n\treturn 0;\n\nout_unlock_rcu:\n\trcu_read_unlock();\nout_unlock:\n\trelease_sock(sk);\n\treturn err;\n\nout_in_use:\n\tread_unlock_bh(&l2tp_ip6_lock);\n\treturn err;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142710,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static Image *ReadPWPImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  FILE\n    *file;\n\n  Image\n    *image,\n    *next_image,\n    *pwp_image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    c,\n    unique_file;\n\n  MagickBooleanType\n    status;\n\n  register Image\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    filesize,\n    length;\n\n  ssize_t\n    count;\n\n  unsigned char\n    magick[MaxTextExtent];\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  pwp_image=AcquireImage(image_info);\n  image=pwp_image;\n  status=OpenBlob(image_info,pwp_image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return((Image *) NULL);\n  count=ReadBlob(pwp_image,5,magick);\n  if ((count != 5) || (LocaleNCompare((char *) magick,\"SFW95\",5) != 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  read_info=CloneImageInfo(image_info);\n  (void) SetImageInfoProgressMonitor(read_info,(MagickProgressMonitor) NULL,\n    (void *) NULL);\n  SetImageInfoBlob(read_info,(void *) NULL,0);\n  unique_file=AcquireUniqueFileResource(read_info->filename);\n  for ( ; ; )\n  {\n    for (c=ReadBlobByte(pwp_image); c != EOF; c=ReadBlobByte(pwp_image))\n    {\n      for (i=0; i < 17; i++)\n        magick[i]=magick[i+1];\n      magick[17]=(unsigned char) c;\n      if (LocaleNCompare((char *) (magick+12),\"SFW94A\",6) == 0)\n        break;\n    }\n    if (c == EOF)\n      break;\n    if (LocaleNCompare((char *) (magick+12),\"SFW94A\",6) != 0)\n      {\n        (void) RelinquishUniqueFileResource(read_info->filename);\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n    /*\n      Dump SFW image to a temporary file.\n    */\n    file=(FILE *) NULL;\n    if (unique_file != -1)\n      file=fdopen(unique_file,\"wb\");\n    if ((unique_file == -1) || (file == (FILE *) NULL))\n      {\n        (void) RelinquishUniqueFileResource(read_info->filename);\n        ThrowFileException(exception,FileOpenError,\"UnableToWriteFile\",\n          image->filename);\n        image=DestroyImageList(image);\n        return((Image *) NULL);\n      }\n    length=fwrite(\"SFW94A\",1,6,file);\n    (void) length;\n    filesize=65535UL*magick[2]+256L*magick[1]+magick[0];\n    for (i=0; i < (ssize_t) filesize; i++)\n    {\n      c=ReadBlobByte(pwp_image);\n      (void) fputc(c,file);\n    }\n    (void) fclose(file);\n    next_image=ReadImage(read_info,exception);\n    if (next_image == (Image *) NULL)\n      break;\n    (void) FormatLocaleString(next_image->filename,MaxTextExtent,\n      \"slide_%02ld.sfw\",(long) next_image->scene);\n    if (image == (Image *) NULL)\n      image=next_image;\n    else\n      {\n        /*\n          Link image into image list.\n        */\n        for (p=image; p->next != (Image *) NULL; p=GetNextImageInList(p)) ;\n        next_image->previous=p;\n        next_image->scene=p->scene+1;\n        p->next=next_image;\n      }\n    if (image_info->number_scenes != 0)\n      if (next_image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageProgress(image,LoadImagesTag,TellBlob(pwp_image),\n      GetBlobSize(pwp_image));\n    if (status == MagickFalse)\n      break;\n  }\n  if (unique_file != -1)\n     (void) close(unique_file);\n   (void) RelinquishUniqueFileResource(read_info->filename);\n   read_info=DestroyImageInfo(read_info);\n  (void) CloseBlob(pwp_image);\n  pwp_image=DestroyImage(pwp_image);\n   if (EOFBlob(image) != MagickFalse)\n     {\n       char\n        *message;\n\n      message=GetExceptionMessage(errno);\n      (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,\n        \"UnexpectedEndOfFile\",\"`%s': %s\",image->filename,message);\n      message=DestroyString(message);\n    }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142747,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static Image *ReadPWPImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  FILE\n    *file;\n\n  Image\n    *image,\n    *next_image,\n    *pwp_image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    c,\n    unique_file;\n\n  MagickBooleanType\n    status;\n\n  register Image\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    filesize,\n    length;\n\n  ssize_t\n    count;\n\n  unsigned char\n    magick[MaxTextExtent];\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  pwp_image=AcquireImage(image_info);\n  image=pwp_image;\n  status=OpenBlob(image_info,pwp_image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return((Image *) NULL);\n  count=ReadBlob(pwp_image,5,magick);\n  if ((count != 5) || (LocaleNCompare((char *) magick,\"SFW95\",5) != 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  read_info=CloneImageInfo(image_info);\n  (void) SetImageInfoProgressMonitor(read_info,(MagickProgressMonitor) NULL,\n    (void *) NULL);\n  SetImageInfoBlob(read_info,(void *) NULL,0);\n  unique_file=AcquireUniqueFileResource(read_info->filename);\n  for ( ; ; )\n  {\n    for (c=ReadBlobByte(pwp_image); c != EOF; c=ReadBlobByte(pwp_image))\n    {\n      for (i=0; i < 17; i++)\n        magick[i]=magick[i+1];\n      magick[17]=(unsigned char) c;\n      if (LocaleNCompare((char *) (magick+12),\"SFW94A\",6) == 0)\n        break;\n    }\n    if (c == EOF)\n      break;\n    if (LocaleNCompare((char *) (magick+12),\"SFW94A\",6) != 0)\n      {\n        (void) RelinquishUniqueFileResource(read_info->filename);\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n    /*\n      Dump SFW image to a temporary file.\n    */\n    file=(FILE *) NULL;\n    if (unique_file != -1)\n      file=fdopen(unique_file,\"wb\");\n    if ((unique_file == -1) || (file == (FILE *) NULL))\n      {\n        (void) RelinquishUniqueFileResource(read_info->filename);\n        ThrowFileException(exception,FileOpenError,\"UnableToWriteFile\",\n          image->filename);\n        image=DestroyImageList(image);\n        return((Image *) NULL);\n      }\n    length=fwrite(\"SFW94A\",1,6,file);\n    (void) length;\n    filesize=65535UL*magick[2]+256L*magick[1]+magick[0];\n    for (i=0; i < (ssize_t) filesize; i++)\n    {\n      c=ReadBlobByte(pwp_image);\n      (void) fputc(c,file);\n    }\n    (void) fclose(file);\n    next_image=ReadImage(read_info,exception);\n    if (next_image == (Image *) NULL)\n      break;\n    (void) FormatLocaleString(next_image->filename,MaxTextExtent,\n      \"slide_%02ld.sfw\",(long) next_image->scene);\n    if (image == (Image *) NULL)\n      image=next_image;\n    else\n      {\n        /*\n          Link image into image list.\n        */\n        for (p=image; p->next != (Image *) NULL; p=GetNextImageInList(p)) ;\n        next_image->previous=p;\n        next_image->scene=p->scene+1;\n        p->next=next_image;\n      }\n    if (image_info->number_scenes != 0)\n      if (next_image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageProgress(image,LoadImagesTag,TellBlob(pwp_image),\n      GetBlobSize(pwp_image));\n    if (status == MagickFalse)\n      break;\n  }\n  if (unique_file != -1)\n     (void) close(unique_file);\n   (void) RelinquishUniqueFileResource(read_info->filename);\n   read_info=DestroyImageInfo(read_info);\n   if (EOFBlob(image) != MagickFalse)\n     {\n       char\n        *message;\n\n      message=GetExceptionMessage(errno);\n      (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,\n        \"UnexpectedEndOfFile\",\"`%s': %s\",image->filename,message);\n      message=DestroyString(message);\n    }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142748,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "PHP_FUNCTION(unserialize)\n{\n\tchar *buf = NULL;\n\tsize_t buf_len;\n \tconst unsigned char *p;\n \tphp_unserialize_data_t var_hash;\n \tzval *options = NULL, *classes = NULL;\n \tHashTable *class_hash = NULL;\n \n \tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"s|a\", &buf, &buf_len, &options) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (buf_len == 0) {\n\t\tRETURN_FALSE;\n\t}\n\n\tp = (const unsigned char*) buf;\n\tPHP_VAR_UNSERIALIZE_INIT(var_hash);\n\tif(options != NULL) {\n\t\tclasses = zend_hash_str_find(Z_ARRVAL_P(options), \"allowed_classes\", sizeof(\"allowed_classes\")-1);\n\t\tif(classes && (Z_TYPE_P(classes) == IS_ARRAY || !zend_is_true(classes))) {\n\t\t\tALLOC_HASHTABLE(class_hash);\n\t\t\tzend_hash_init(class_hash, (Z_TYPE_P(classes) == IS_ARRAY)?zend_hash_num_elements(Z_ARRVAL_P(classes)):0, NULL, NULL, 0);\n\t\t}\n\t\tif(class_hash && Z_TYPE_P(classes) == IS_ARRAY) {\n\t\t\tzval *entry;\n\t\t\tzend_string *lcname;\n\n\t\t\tZEND_HASH_FOREACH_VAL(Z_ARRVAL_P(classes), entry) {\n\t\t\t\tconvert_to_string_ex(entry);\n\t\t\t\tlcname = zend_string_tolower(Z_STR_P(entry));\n\t\t\t\tzend_hash_add_empty_element(class_hash, lcname);\n\t\t        zend_string_release(lcname);\n\t\t\t} ZEND_HASH_FOREACH_END();\n \t\t}\n \t}\n \n\tif (!php_var_unserialize_ex(return_value, &p, p + buf_len, &var_hash, class_hash)) {\n \t\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n \t\tif (class_hash) {\n \t\t\tzend_hash_destroy(class_hash);\n \t\t\tFREE_HASHTABLE(class_hash);\n \t\t}\n\t\tzval_ptr_dtor(return_value);\n \t\tif (!EG(exception)) {\n \t\t\tphp_error_docref(NULL, E_NOTICE, \"Error at offset \" ZEND_LONG_FMT \" of %zd bytes\",\n \t\t\t\t(zend_long)((char*)p - buf), buf_len);\n \t\t}\n \t\tRETURN_FALSE;\n \t}\n\t/* We should keep an reference to return_value to prevent it from being dtor\n\t   in case nesting calls to unserialize */\n\tvar_push_dtor(&var_hash, return_value);\n \n \tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n \tif (class_hash) {\n\t\tzend_hash_destroy(class_hash);\n\t\tFREE_HASHTABLE(class_hash);\n\t}\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142757,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "PHP_FUNCTION(unserialize)\n{\n\tchar *buf = NULL;\n\tsize_t buf_len;\n \tconst unsigned char *p;\n \tphp_unserialize_data_t var_hash;\n \tzval *options = NULL, *classes = NULL;\n\tzval *retval;\n \tHashTable *class_hash = NULL;\n \n \tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"s|a\", &buf, &buf_len, &options) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (buf_len == 0) {\n\t\tRETURN_FALSE;\n\t}\n\n\tp = (const unsigned char*) buf;\n\tPHP_VAR_UNSERIALIZE_INIT(var_hash);\n\tif(options != NULL) {\n\t\tclasses = zend_hash_str_find(Z_ARRVAL_P(options), \"allowed_classes\", sizeof(\"allowed_classes\")-1);\n\t\tif(classes && (Z_TYPE_P(classes) == IS_ARRAY || !zend_is_true(classes))) {\n\t\t\tALLOC_HASHTABLE(class_hash);\n\t\t\tzend_hash_init(class_hash, (Z_TYPE_P(classes) == IS_ARRAY)?zend_hash_num_elements(Z_ARRVAL_P(classes)):0, NULL, NULL, 0);\n\t\t}\n\t\tif(class_hash && Z_TYPE_P(classes) == IS_ARRAY) {\n\t\t\tzval *entry;\n\t\t\tzend_string *lcname;\n\n\t\t\tZEND_HASH_FOREACH_VAL(Z_ARRVAL_P(classes), entry) {\n\t\t\t\tconvert_to_string_ex(entry);\n\t\t\t\tlcname = zend_string_tolower(Z_STR_P(entry));\n\t\t\t\tzend_hash_add_empty_element(class_hash, lcname);\n\t\t        zend_string_release(lcname);\n\t\t\t} ZEND_HASH_FOREACH_END();\n \t\t}\n \t}\n \n\tretval = var_tmp_var(&var_hash);\n\tif (!php_var_unserialize_ex(retval, &p, p + buf_len, &var_hash, class_hash)) {\n \t\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n \t\tif (class_hash) {\n \t\t\tzend_hash_destroy(class_hash);\n \t\t\tFREE_HASHTABLE(class_hash);\n \t\t}\n \t\tif (!EG(exception)) {\n \t\t\tphp_error_docref(NULL, E_NOTICE, \"Error at offset \" ZEND_LONG_FMT \" of %zd bytes\",\n \t\t\t\t(zend_long)((char*)p - buf), buf_len);\n \t\t}\n \t\tRETURN_FALSE;\n \t}\n\n\tZVAL_COPY(return_value, retval);\n \n \tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n \tif (class_hash) {\n\t\tzend_hash_destroy(class_hash);\n\t\tFREE_HASHTABLE(class_hash);\n\t}\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142758,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "MagickExport MagickBooleanType SetImageType(Image *image,const ImageType type)\n{\n  const char\n    *artifact;\n\n  ImageInfo\n    *image_info;\n\n  MagickBooleanType\n    status;\n\n  QuantizeInfo\n    *quantize_info;\n\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image->signature == MagickSignature);\n  status=MagickTrue;\n  image_info=AcquireImageInfo();\n  image_info->dither=image->dither;\n  artifact=GetImageArtifact(image,\"dither\");\n  if (artifact != (const char *) NULL)\n    (void) SetImageOption(image_info,\"dither\",artifact);\n  switch (type)\n  {\n    case BilevelType:\n    {\n      if (SetImageMonochrome(image,&image->exception) == MagickFalse)\n        {\n          status=TransformImageColorspace(image,GRAYColorspace);\n          (void) NormalizeImage(image);\n          quantize_info=AcquireQuantizeInfo(image_info);\n          quantize_info->number_colors=2;\n          quantize_info->colorspace=GRAYColorspace;\n           status=QuantizeImage(quantize_info,image);\n           quantize_info=DestroyQuantizeInfo(quantize_info);\n         }\n      image->colors=2;\n       image->matte=MagickFalse;\n       break;\n     }\n    case GrayscaleType:\n    {\n      if (SetImageGray(image,&image->exception) == MagickFalse)\n        status=TransformImageColorspace(image,GRAYColorspace);\n      image->matte=MagickFalse;\n      break;\n    }\n    case GrayscaleMatteType:\n    {\n      if (SetImageGray(image,&image->exception) == MagickFalse)\n        status=TransformImageColorspace(image,GRAYColorspace);\n      if (image->matte == MagickFalse)\n        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);\n      break;\n    }\n    case PaletteType:\n    {\n      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n        status=TransformImageColorspace(image,sRGBColorspace);\n      if ((image->storage_class == DirectClass) || (image->colors > 256))\n        {\n          quantize_info=AcquireQuantizeInfo(image_info);\n          quantize_info->number_colors=256;\n          status=QuantizeImage(quantize_info,image);\n          quantize_info=DestroyQuantizeInfo(quantize_info);\n        }\n      image->matte=MagickFalse;\n      break;\n    }\n    case PaletteBilevelMatteType:\n    {\n      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n        status=TransformImageColorspace(image,sRGBColorspace);\n      if (image->matte == MagickFalse)\n        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);\n      (void) BilevelImageChannel(image,AlphaChannel,(double) QuantumRange/2.0);\n      quantize_info=AcquireQuantizeInfo(image_info);\n      status=QuantizeImage(quantize_info,image);\n      quantize_info=DestroyQuantizeInfo(quantize_info);\n      break;\n    }\n    case PaletteMatteType:\n    {\n      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n        status=TransformImageColorspace(image,sRGBColorspace);\n      if (image->matte == MagickFalse)\n        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);\n      quantize_info=AcquireQuantizeInfo(image_info);\n      quantize_info->colorspace=TransparentColorspace;\n      status=QuantizeImage(quantize_info,image);\n      quantize_info=DestroyQuantizeInfo(quantize_info);\n      break;\n    }\n    case TrueColorType:\n    {\n      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n        status=TransformImageColorspace(image,sRGBColorspace);\n      if (image->storage_class != DirectClass)\n        status=SetImageStorageClass(image,DirectClass);\n      image->matte=MagickFalse;\n      break;\n    }\n    case TrueColorMatteType:\n    {\n      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n        status=TransformImageColorspace(image,sRGBColorspace);\n      if (image->storage_class != DirectClass)\n        status=SetImageStorageClass(image,DirectClass);\n      if (image->matte == MagickFalse)\n        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);\n      break;\n    }\n    case ColorSeparationType:\n    {\n      if (image->colorspace != CMYKColorspace)\n        {\n          if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n            (void) TransformImageColorspace(image,sRGBColorspace);\n          status=TransformImageColorspace(image,CMYKColorspace);\n        }\n      if (image->storage_class != DirectClass)\n        status=SetImageStorageClass(image,DirectClass);\n      image->matte=MagickFalse;\n      break;\n    }\n    case ColorSeparationMatteType:\n    {\n      if (image->colorspace != CMYKColorspace)\n        {\n          if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n            (void) TransformImageColorspace(image,sRGBColorspace);\n          status=TransformImageColorspace(image,CMYKColorspace);\n        }\n      if (image->storage_class != DirectClass)\n        status=SetImageStorageClass(image,DirectClass);\n      if (image->matte == MagickFalse)\n        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);\n      break;\n    }\n    case OptimizeType:\n    case UndefinedType:\n      break;\n  }\n  image_info=DestroyImageInfo(image_info);\n  if (status == MagickFalse)\n    return(MagickFalse);\n  image->type=type;\n  return(MagickTrue);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142785,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "MagickExport MagickBooleanType SetImageType(Image *image,const ImageType type)\n{\n  const char\n    *artifact;\n\n  ImageInfo\n    *image_info;\n\n  MagickBooleanType\n    status;\n\n  QuantizeInfo\n    *quantize_info;\n\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image->signature == MagickSignature);\n  status=MagickTrue;\n  image_info=AcquireImageInfo();\n  image_info->dither=image->dither;\n  artifact=GetImageArtifact(image,\"dither\");\n  if (artifact != (const char *) NULL)\n    (void) SetImageOption(image_info,\"dither\",artifact);\n  switch (type)\n  {\n    case BilevelType:\n    {\n      if (SetImageMonochrome(image,&image->exception) == MagickFalse)\n        {\n          status=TransformImageColorspace(image,GRAYColorspace);\n          (void) NormalizeImage(image);\n          quantize_info=AcquireQuantizeInfo(image_info);\n          quantize_info->number_colors=2;\n          quantize_info->colorspace=GRAYColorspace;\n           status=QuantizeImage(quantize_info,image);\n           quantize_info=DestroyQuantizeInfo(quantize_info);\n         }\n      status=AcquireImageColormap(image,2);\n       image->matte=MagickFalse;\n       break;\n     }\n    case GrayscaleType:\n    {\n      if (SetImageGray(image,&image->exception) == MagickFalse)\n        status=TransformImageColorspace(image,GRAYColorspace);\n      image->matte=MagickFalse;\n      break;\n    }\n    case GrayscaleMatteType:\n    {\n      if (SetImageGray(image,&image->exception) == MagickFalse)\n        status=TransformImageColorspace(image,GRAYColorspace);\n      if (image->matte == MagickFalse)\n        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);\n      break;\n    }\n    case PaletteType:\n    {\n      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n        status=TransformImageColorspace(image,sRGBColorspace);\n      if ((image->storage_class == DirectClass) || (image->colors > 256))\n        {\n          quantize_info=AcquireQuantizeInfo(image_info);\n          quantize_info->number_colors=256;\n          status=QuantizeImage(quantize_info,image);\n          quantize_info=DestroyQuantizeInfo(quantize_info);\n        }\n      image->matte=MagickFalse;\n      break;\n    }\n    case PaletteBilevelMatteType:\n    {\n      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n        status=TransformImageColorspace(image,sRGBColorspace);\n      if (image->matte == MagickFalse)\n        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);\n      (void) BilevelImageChannel(image,AlphaChannel,(double) QuantumRange/2.0);\n      quantize_info=AcquireQuantizeInfo(image_info);\n      status=QuantizeImage(quantize_info,image);\n      quantize_info=DestroyQuantizeInfo(quantize_info);\n      break;\n    }\n    case PaletteMatteType:\n    {\n      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n        status=TransformImageColorspace(image,sRGBColorspace);\n      if (image->matte == MagickFalse)\n        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);\n      quantize_info=AcquireQuantizeInfo(image_info);\n      quantize_info->colorspace=TransparentColorspace;\n      status=QuantizeImage(quantize_info,image);\n      quantize_info=DestroyQuantizeInfo(quantize_info);\n      break;\n    }\n    case TrueColorType:\n    {\n      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n        status=TransformImageColorspace(image,sRGBColorspace);\n      if (image->storage_class != DirectClass)\n        status=SetImageStorageClass(image,DirectClass);\n      image->matte=MagickFalse;\n      break;\n    }\n    case TrueColorMatteType:\n    {\n      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n        status=TransformImageColorspace(image,sRGBColorspace);\n      if (image->storage_class != DirectClass)\n        status=SetImageStorageClass(image,DirectClass);\n      if (image->matte == MagickFalse)\n        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);\n      break;\n    }\n    case ColorSeparationType:\n    {\n      if (image->colorspace != CMYKColorspace)\n        {\n          if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n            (void) TransformImageColorspace(image,sRGBColorspace);\n          status=TransformImageColorspace(image,CMYKColorspace);\n        }\n      if (image->storage_class != DirectClass)\n        status=SetImageStorageClass(image,DirectClass);\n      image->matte=MagickFalse;\n      break;\n    }\n    case ColorSeparationMatteType:\n    {\n      if (image->colorspace != CMYKColorspace)\n        {\n          if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n            (void) TransformImageColorspace(image,sRGBColorspace);\n          status=TransformImageColorspace(image,CMYKColorspace);\n        }\n      if (image->storage_class != DirectClass)\n        status=SetImageStorageClass(image,DirectClass);\n      if (image->matte == MagickFalse)\n        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);\n      break;\n    }\n    case OptimizeType:\n    case UndefinedType:\n      break;\n  }\n  image_info=DestroyImageInfo(image_info);\n  if (status == MagickFalse)\n    return(MagickFalse);\n  image->type=type;\n  return(MagickTrue);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142786,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int mif_process_cmpt(mif_hdr_t *hdr, char *buf)\n{\n\tjas_tvparser_t *tvp;\n\tmif_cmpt_t *cmpt;\n\tint id;\n\n\tcmpt = 0;\n\ttvp = 0;\n\n\tif (!(cmpt = mif_cmpt_create())) {\n\t\tgoto error;\n\t}\n\tcmpt->tlx = 0;\n\tcmpt->tly = 0;\n\tcmpt->sampperx = 0;\n\tcmpt->samppery = 0;\n\tcmpt->width = 0;\n\tcmpt->height = 0;\n\tcmpt->prec = 0;\n\tcmpt->sgnd = -1;\n\tcmpt->data = 0;\n\n\tif (!(tvp = jas_tvparser_create(buf))) {\n\t\tgoto error;\n\t}\n\twhile (!(id = jas_tvparser_next(tvp))) {\n\t\tswitch (jas_taginfo_nonull(jas_taginfos_lookup(mif_tags,\n\t\t  jas_tvparser_gettag(tvp)))->id) {\n\t\tcase MIF_TLX:\n\t\t\tcmpt->tlx = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_TLY:\n\t\t\tcmpt->tly = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_WIDTH:\n\t\t\tcmpt->width = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_HEIGHT:\n\t\t\tcmpt->height = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_HSAMP:\n\t\t\tcmpt->sampperx = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_VSAMP:\n\t\t\tcmpt->samppery = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_PREC:\n\t\t\tcmpt->prec = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_SGND:\n\t\t\tcmpt->sgnd = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_DATA:\n\t\t\tif (!(cmpt->data = jas_strdup(jas_tvparser_getval(tvp)))) {\n\t\t\t\treturn -1;\n\t\t\t}\n \t\t\tbreak;\n \t\t}\n \t}\n\tjas_tvparser_destroy(tvp);\n \tif (!cmpt->sampperx || !cmpt->samppery) {\n \t\tgoto error;\n \t}\n \tif (mif_hdr_addcmpt(hdr, hdr->numcmpts, cmpt)) {\n \t\tgoto error;\n \t}\n \treturn 0;\n \n error:\n\tif (cmpt) {\n\t\tmif_cmpt_destroy(cmpt);\n\t}\n\tif (tvp) {\n\t\tjas_tvparser_destroy(tvp);\n\t}\n\treturn -1;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142829,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int mif_process_cmpt(mif_hdr_t *hdr, char *buf)\n{\n\tjas_tvparser_t *tvp;\n\tmif_cmpt_t *cmpt;\n\tint id;\n\n\tcmpt = 0;\n\ttvp = 0;\n\n\tif (!(cmpt = mif_cmpt_create())) {\n\t\tgoto error;\n\t}\n\tcmpt->tlx = 0;\n\tcmpt->tly = 0;\n\tcmpt->sampperx = 0;\n\tcmpt->samppery = 0;\n\tcmpt->width = 0;\n\tcmpt->height = 0;\n\tcmpt->prec = 0;\n\tcmpt->sgnd = -1;\n\tcmpt->data = 0;\n\n\tif (!(tvp = jas_tvparser_create(buf))) {\n\t\tgoto error;\n\t}\n\twhile (!(id = jas_tvparser_next(tvp))) {\n\t\tswitch (jas_taginfo_nonull(jas_taginfos_lookup(mif_tags,\n\t\t  jas_tvparser_gettag(tvp)))->id) {\n\t\tcase MIF_TLX:\n\t\t\tcmpt->tlx = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_TLY:\n\t\t\tcmpt->tly = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_WIDTH:\n\t\t\tcmpt->width = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_HEIGHT:\n\t\t\tcmpt->height = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_HSAMP:\n\t\t\tcmpt->sampperx = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_VSAMP:\n\t\t\tcmpt->samppery = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_PREC:\n\t\t\tcmpt->prec = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_SGND:\n\t\t\tcmpt->sgnd = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_DATA:\n\t\t\tif (!(cmpt->data = jas_strdup(jas_tvparser_getval(tvp)))) {\n\t\t\t\treturn -1;\n\t\t\t}\n \t\t\tbreak;\n \t\t}\n \t}\n \tif (!cmpt->sampperx || !cmpt->samppery) {\n \t\tgoto error;\n \t}\n \tif (mif_hdr_addcmpt(hdr, hdr->numcmpts, cmpt)) {\n \t\tgoto error;\n \t}\n\tjas_tvparser_destroy(tvp);\n \treturn 0;\n \n error:\n\tif (cmpt) {\n\t\tmif_cmpt_destroy(cmpt);\n\t}\n\tif (tvp) {\n\t\tjas_tvparser_destroy(tvp);\n\t}\n\treturn -1;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142830,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static void regulator_ena_gpio_free(struct regulator_dev *rdev)\n{\n\tstruct regulator_enable_gpio *pin, *n;\n\n\tif (!rdev->ena_pin)\n\t\treturn;\n\n\t/* Free the GPIO only in case of no use */\n\tlist_for_each_entry_safe(pin, n, &regulator_ena_gpio_list, list) {\n\t\tif (pin->gpiod == rdev->ena_pin->gpiod) {\n\t\t\tif (pin->request_count <= 1) {\n\t\t\t\tpin->request_count = 0;\n \t\t\t\tgpiod_put(pin->gpiod);\n \t\t\t\tlist_del(&pin->list);\n \t\t\t\tkfree(pin);\n \t\t\t} else {\n \t\t\t\tpin->request_count--;\n \t\t\t}\n\t\t}\n\t}\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142833,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static void regulator_ena_gpio_free(struct regulator_dev *rdev)\n{\n\tstruct regulator_enable_gpio *pin, *n;\n\n\tif (!rdev->ena_pin)\n\t\treturn;\n\n\t/* Free the GPIO only in case of no use */\n\tlist_for_each_entry_safe(pin, n, &regulator_ena_gpio_list, list) {\n\t\tif (pin->gpiod == rdev->ena_pin->gpiod) {\n\t\t\tif (pin->request_count <= 1) {\n\t\t\t\tpin->request_count = 0;\n \t\t\t\tgpiod_put(pin->gpiod);\n \t\t\t\tlist_del(&pin->list);\n \t\t\t\tkfree(pin);\n\t\t\t\trdev->ena_pin = NULL;\n\t\t\t\treturn;\n \t\t\t} else {\n \t\t\t\tpin->request_count--;\n \t\t\t}\n\t\t}\n\t}\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142834,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": " void ip4_datagram_release_cb(struct sock *sk)\n {\n \tconst struct inet_sock *inet = inet_sk(sk);\n \tconst struct ip_options_rcu *inet_opt;\n \t__be32 daddr = inet->inet_daddr;\n \tstruct flowi4 fl4;\n \tstruct rtable *rt;\n \n\tif (! __sk_dst_get(sk) || __sk_dst_check(sk, 0))\n\t\treturn;\n \trcu_read_lock();\n \tinet_opt = rcu_dereference(inet->inet_opt);\n \tif (inet_opt && inet_opt->opt.srr)\n \t\tdaddr = inet_opt->opt.faddr;\n \trt = ip_route_output_ports(sock_net(sk), &fl4, sk, daddr,\n \t\t\t\t   inet->inet_saddr, inet->inet_dport,\n \t\t\t\t   inet->inet_sport, sk->sk_protocol,\n \t\t\t\t   RT_CONN_FLAGS(sk), sk->sk_bound_dev_if);\n\tif (!IS_ERR(rt))\n\t\t__sk_dst_set(sk, &rt->dst);\n \trcu_read_unlock();\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142835,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": " void ip4_datagram_release_cb(struct sock *sk)\n {\n \tconst struct inet_sock *inet = inet_sk(sk);\n \tconst struct ip_options_rcu *inet_opt;\n \t__be32 daddr = inet->inet_daddr;\n\tstruct dst_entry *dst;\n \tstruct flowi4 fl4;\n \tstruct rtable *rt;\n \n \trcu_read_lock();\n\n\tdst = __sk_dst_get(sk);\n\tif (!dst || !dst->obsolete || dst->ops->check(dst, 0)) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n \tinet_opt = rcu_dereference(inet->inet_opt);\n \tif (inet_opt && inet_opt->opt.srr)\n \t\tdaddr = inet_opt->opt.faddr;\n \trt = ip_route_output_ports(sock_net(sk), &fl4, sk, daddr,\n \t\t\t\t   inet->inet_saddr, inet->inet_dport,\n \t\t\t\t   inet->inet_sport, sk->sk_protocol,\n \t\t\t\t   RT_CONN_FLAGS(sk), sk->sk_bound_dev_if);\n\n\tdst = !IS_ERR(rt) ? &rt->dst : NULL;\n\tsk_dst_set(sk, dst);\n\n \trcu_read_unlock();\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142836,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int rm_read_multi(AVFormatContext *s, AVIOContext *pb,\n                         AVStream *st, char *mime)\n{\n    int number_of_streams = avio_rb16(pb);\n    int number_of_mdpr;\n    int i, ret;\n    unsigned size2;\n    for (i = 0; i<number_of_streams; i++)\n        avio_rb16(pb);\n    number_of_mdpr = avio_rb16(pb);\n    if (number_of_mdpr != 1) {\n        avpriv_request_sample(s, \"MLTI with multiple (%d) MDPR\", number_of_mdpr);\n    }\n    for (i = 0; i < number_of_mdpr; i++) {\n        AVStream *st2;\n        if (i > 0) {\n            st2 = avformat_new_stream(s, NULL);\n            if (!st2) {\n                ret = AVERROR(ENOMEM);\n                return ret;\n            }\n            st2->id = st->id + (i<<16);\n            st2->codecpar->bit_rate = st->codecpar->bit_rate;\n            st2->start_time = st->start_time;\n            st2->duration   = st->duration;\n            st2->codecpar->codec_type = AVMEDIA_TYPE_DATA;\n            st2->priv_data = ff_rm_alloc_rmstream();\n            if (!st2->priv_data)\n                return AVERROR(ENOMEM);\n        } else\n            st2 = st;\n \n         size2 = avio_rb32(pb);\n         ret = ff_rm_read_mdpr_codecdata(s, s->pb, st2, st2->priv_data,\n                                        size2, mime);\n         if (ret < 0)\n             return ret;\n     }\n    return 0;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142841,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int rm_read_multi(AVFormatContext *s, AVIOContext *pb,\n                         AVStream *st, char *mime)\n{\n    int number_of_streams = avio_rb16(pb);\n    int number_of_mdpr;\n    int i, ret;\n    unsigned size2;\n    for (i = 0; i<number_of_streams; i++)\n        avio_rb16(pb);\n    number_of_mdpr = avio_rb16(pb);\n    if (number_of_mdpr != 1) {\n        avpriv_request_sample(s, \"MLTI with multiple (%d) MDPR\", number_of_mdpr);\n    }\n    for (i = 0; i < number_of_mdpr; i++) {\n        AVStream *st2;\n        if (i > 0) {\n            st2 = avformat_new_stream(s, NULL);\n            if (!st2) {\n                ret = AVERROR(ENOMEM);\n                return ret;\n            }\n            st2->id = st->id + (i<<16);\n            st2->codecpar->bit_rate = st->codecpar->bit_rate;\n            st2->start_time = st->start_time;\n            st2->duration   = st->duration;\n            st2->codecpar->codec_type = AVMEDIA_TYPE_DATA;\n            st2->priv_data = ff_rm_alloc_rmstream();\n            if (!st2->priv_data)\n                return AVERROR(ENOMEM);\n        } else\n            st2 = st;\n \n         size2 = avio_rb32(pb);\n         ret = ff_rm_read_mdpr_codecdata(s, s->pb, st2, st2->priv_data,\n                                        size2, NULL);\n         if (ret < 0)\n             return ret;\n     }\n    return 0;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142842,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "CURLcode Curl_close(struct Curl_easy *data)\n{\n  struct Curl_multi *m;\n\n  if(!data)\n    return CURLE_OK;\n\n  Curl_expire_clear(data); /* shut off timers */\n\n  m = data->multi;\n  if(m)\n    /* This handle is still part of a multi handle, take care of this first\n        and detach this handle from there. */\n     curl_multi_remove_handle(data->multi, data);\n \n  if(data->multi_easy)\n     /* when curl_easy_perform() is used, it creates its own multi handle to\n        use and this is the one */\n     curl_multi_cleanup(data->multi_easy);\n \n   /* Destroy the timeout list that is held in the easy handle. It is\n      /normally/ done by curl_multi_remove_handle() but this is \"just in\n     case\" */\n  Curl_llist_destroy(&data->state.timeoutlist, NULL);\n\n  data->magic = 0; /* force a clear AFTER the possibly enforced removal from\n                      the multi handle, since that function uses the magic\n                      field! */\n\n  if(data->state.rangestringalloc)\n    free(data->state.range);\n\n  /* freed here just in case DONE wasn't called */\n  Curl_free_request_state(data);\n\n  /* Close down all open SSL info and sessions */\n  Curl_ssl_close_all(data);\n  Curl_safefree(data->state.first_host);\n  Curl_safefree(data->state.scratch);\n  Curl_ssl_free_certinfo(data);\n\n  /* Cleanup possible redirect junk */\n  free(data->req.newurl);\n  data->req.newurl = NULL;\n\n  if(data->change.referer_alloc) {\n    Curl_safefree(data->change.referer);\n    data->change.referer_alloc = FALSE;\n  }\n  data->change.referer = NULL;\n\n  Curl_up_free(data);\n  Curl_safefree(data->state.buffer);\n  Curl_safefree(data->state.headerbuff);\n  Curl_safefree(data->state.ulbuf);\n  Curl_flush_cookies(data, 1);\n  Curl_digest_cleanup(data);\n  Curl_safefree(data->info.contenttype);\n  Curl_safefree(data->info.wouldredirect);\n\n  /* this destroys the channel and we cannot use it anymore after this */\n  Curl_resolver_cleanup(data->state.resolver);\n\n  Curl_http2_cleanup_dependencies(data);\n  Curl_convert_close(data);\n\n  /* No longer a dirty share, if it exists */\n  if(data->share) {\n    Curl_share_lock(data, CURL_LOCK_DATA_SHARE, CURL_LOCK_ACCESS_SINGLE);\n    data->share->dirty--;\n    Curl_share_unlock(data, CURL_LOCK_DATA_SHARE);\n  }\n\n  /* destruct wildcard structures if it is needed */\n  Curl_wildcard_dtor(&data->wildcard);\n  Curl_freeset(data);\n  free(data);\n  return CURLE_OK;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142905,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "CURLcode Curl_close(struct Curl_easy *data)\n{\n  struct Curl_multi *m;\n\n  if(!data)\n    return CURLE_OK;\n\n  Curl_expire_clear(data); /* shut off timers */\n\n  m = data->multi;\n  if(m)\n    /* This handle is still part of a multi handle, take care of this first\n        and detach this handle from there. */\n     curl_multi_remove_handle(data->multi, data);\n \n  if(data->multi_easy) {\n     /* when curl_easy_perform() is used, it creates its own multi handle to\n        use and this is the one */\n     curl_multi_cleanup(data->multi_easy);\n    data->multi_easy = NULL;\n  }\n \n   /* Destroy the timeout list that is held in the easy handle. It is\n      /normally/ done by curl_multi_remove_handle() but this is \"just in\n     case\" */\n  Curl_llist_destroy(&data->state.timeoutlist, NULL);\n\n  data->magic = 0; /* force a clear AFTER the possibly enforced removal from\n                      the multi handle, since that function uses the magic\n                      field! */\n\n  if(data->state.rangestringalloc)\n    free(data->state.range);\n\n  /* freed here just in case DONE wasn't called */\n  Curl_free_request_state(data);\n\n  /* Close down all open SSL info and sessions */\n  Curl_ssl_close_all(data);\n  Curl_safefree(data->state.first_host);\n  Curl_safefree(data->state.scratch);\n  Curl_ssl_free_certinfo(data);\n\n  /* Cleanup possible redirect junk */\n  free(data->req.newurl);\n  data->req.newurl = NULL;\n\n  if(data->change.referer_alloc) {\n    Curl_safefree(data->change.referer);\n    data->change.referer_alloc = FALSE;\n  }\n  data->change.referer = NULL;\n\n  Curl_up_free(data);\n  Curl_safefree(data->state.buffer);\n  Curl_safefree(data->state.headerbuff);\n  Curl_safefree(data->state.ulbuf);\n  Curl_flush_cookies(data, 1);\n  Curl_digest_cleanup(data);\n  Curl_safefree(data->info.contenttype);\n  Curl_safefree(data->info.wouldredirect);\n\n  /* this destroys the channel and we cannot use it anymore after this */\n  Curl_resolver_cleanup(data->state.resolver);\n\n  Curl_http2_cleanup_dependencies(data);\n  Curl_convert_close(data);\n\n  /* No longer a dirty share, if it exists */\n  if(data->share) {\n    Curl_share_lock(data, CURL_LOCK_DATA_SHARE, CURL_LOCK_ACCESS_SINGLE);\n    data->share->dirty--;\n    Curl_share_unlock(data, CURL_LOCK_DATA_SHARE);\n  }\n\n  /* destruct wildcard structures if it is needed */\n  Curl_wildcard_dtor(&data->wildcard);\n  Curl_freeset(data);\n  free(data);\n  return CURLE_OK;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142906,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "ExprAppendMultiKeysymList(ExprDef *expr, ExprDef *append)\n{\n    unsigned nSyms = darray_size(expr->keysym_list.syms);\n    unsigned numEntries = darray_size(append->keysym_list.syms);\n\n    darray_append(expr->keysym_list.symsMapIndex, nSyms);\n     darray_append(expr->keysym_list.symsNumEntries, numEntries);\n     darray_concat(expr->keysym_list.syms, append->keysym_list.syms);\n \n    FreeStmt((ParseCommon *) &append);\n \n     return expr;\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142937,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "ExprAppendMultiKeysymList(ExprDef *expr, ExprDef *append)\n{\n    unsigned nSyms = darray_size(expr->keysym_list.syms);\n    unsigned numEntries = darray_size(append->keysym_list.syms);\n\n    darray_append(expr->keysym_list.symsMapIndex, nSyms);\n     darray_append(expr->keysym_list.symsNumEntries, numEntries);\n     darray_concat(expr->keysym_list.syms, append->keysym_list.syms);\n \n    FreeStmt((ParseCommon *) append);\n \n     return expr;\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142938,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "R_API void r_anal_bb_free(RAnalBlock *bb) {\n\tif (!bb) {\n\t\treturn;\n\t}\n\tr_anal_cond_free (bb->cond);\n\tR_FREE (bb->fingerprint);\n\tr_anal_diff_free (bb->diff);\n\tbb->diff = NULL;\n\tR_FREE (bb->op_bytes);\n\tr_anal_switch_op_free (bb->switch_op);\n\tbb->switch_op = NULL;\n\tbb->fingerprint = NULL;\n\tbb->cond = NULL;\n\tR_FREE (bb->label);\n\tR_FREE (bb->op_pos);\n\tR_FREE (bb->parent_reg_arena);\n\tif (bb->prev) {\n\t\tif (bb->prev->jumpbb == bb) {\n\t\t\tbb->prev->jumpbb = NULL;\n\t\t}\n\t\tif (bb->prev->failbb == bb) {\n\t\t\tbb->prev->failbb = NULL;\n\t\t}\n\t\tbb->prev = NULL;\n\t}\n\tif (bb->jumpbb) {\n\t\tbb->jumpbb->prev = NULL;\n\t\tbb->jumpbb = NULL;\n\t}\n\tif (bb->failbb) {\n \t\tbb->failbb->prev = NULL;\n \t\tbb->failbb = NULL;\n \t}\n\tR_FREE (bb);\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142997,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "R_API void r_anal_bb_free(RAnalBlock *bb) {\n\tif (!bb) {\n\t\treturn;\n\t}\n\tr_anal_cond_free (bb->cond);\n\tR_FREE (bb->fingerprint);\n\tr_anal_diff_free (bb->diff);\n\tbb->diff = NULL;\n\tR_FREE (bb->op_bytes);\n\tr_anal_switch_op_free (bb->switch_op);\n\tbb->switch_op = NULL;\n\tbb->fingerprint = NULL;\n\tbb->cond = NULL;\n\tR_FREE (bb->label);\n\tR_FREE (bb->op_pos);\n\tR_FREE (bb->parent_reg_arena);\n\tif (bb->prev) {\n\t\tif (bb->prev->jumpbb == bb) {\n\t\t\tbb->prev->jumpbb = NULL;\n\t\t}\n\t\tif (bb->prev->failbb == bb) {\n\t\t\tbb->prev->failbb = NULL;\n\t\t}\n\t\tbb->prev = NULL;\n\t}\n\tif (bb->jumpbb) {\n\t\tbb->jumpbb->prev = NULL;\n\t\tbb->jumpbb = NULL;\n\t}\n\tif (bb->failbb) {\n \t\tbb->failbb->prev = NULL;\n \t\tbb->failbb = NULL;\n \t}\n\tif (bb->next) {\n\t\t// avoid double free\n\t\tbb->next->prev = NULL;\n\t}\n\tR_FREE (bb); // double free\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142998,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static long do_get_mempolicy(int *policy, nodemask_t *nmask,\n\t\t\t     unsigned long addr, unsigned long flags)\n{\n\tint err;\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma = NULL;\n\tstruct mempolicy *pol = current->mempolicy;\n\n\tif (flags &\n\t\t~(unsigned long)(MPOL_F_NODE|MPOL_F_ADDR|MPOL_F_MEMS_ALLOWED))\n\t\treturn -EINVAL;\n\n\tif (flags & MPOL_F_MEMS_ALLOWED) {\n\t\tif (flags & (MPOL_F_NODE|MPOL_F_ADDR))\n\t\t\treturn -EINVAL;\n\t\t*policy = 0;\t/* just so it's initialized */\n\t\ttask_lock(current);\n\t\t*nmask  = cpuset_current_mems_allowed;\n\t\ttask_unlock(current);\n\t\treturn 0;\n\t}\n\n\tif (flags & MPOL_F_ADDR) {\n\t\t/*\n\t\t * Do NOT fall back to task policy if the\n\t\t * vma/shared policy at addr is NULL.  We\n\t\t * want to return MPOL_DEFAULT in this case.\n\t\t */\n\t\tdown_read(&mm->mmap_sem);\n\t\tvma = find_vma_intersection(mm, addr, addr+1);\n\t\tif (!vma) {\n\t\t\tup_read(&mm->mmap_sem);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tif (vma->vm_ops && vma->vm_ops->get_policy)\n\t\t\tpol = vma->vm_ops->get_policy(vma, addr);\n\t\telse\n\t\t\tpol = vma->vm_policy;\n\t} else if (addr)\n\t\treturn -EINVAL;\n\n\tif (!pol)\n\t\tpol = &default_policy;\t/* indicates default behavior */\n\n\tif (flags & MPOL_F_NODE) {\n\t\tif (flags & MPOL_F_ADDR) {\n\t\t\terr = lookup_node(addr);\n\t\t\tif (err < 0)\n\t\t\t\tgoto out;\n\t\t\t*policy = err;\n\t\t} else if (pol == current->mempolicy &&\n\t\t\t\tpol->mode == MPOL_INTERLEAVE) {\n\t\t\t*policy = next_node_in(current->il_prev, pol->v.nodes);\n\t\t} else {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t*policy = pol == &default_policy ? MPOL_DEFAULT :\n\t\t\t\t\t\tpol->mode;\n\t\t/*\n\t\t * Internal mempolicy flags must be masked off before exposing\n\t\t * the policy to userspace.\n\t\t */\n \t\t*policy |= (pol->flags & MPOL_MODE_FLAGS);\n \t}\n \n\tif (vma) {\n\t\tup_read(&current->mm->mmap_sem);\n\t\tvma = NULL;\n\t}\n \terr = 0;\n \tif (nmask) {\n \t\tif (mpol_store_user_nodemask(pol)) {\n\t\t\t*nmask = pol->w.user_nodemask;\n\t\t} else {\n\t\t\ttask_lock(current);\n\t\t\tget_policy_nodemask(pol, nmask);\n\t\t\ttask_unlock(current);\n\t\t}\n\t}\n\n out:\n\tmpol_cond_put(pol);\n\tif (vma)\n\t\tup_read(&current->mm->mmap_sem);\n\treturn err;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143035,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static long do_get_mempolicy(int *policy, nodemask_t *nmask,\n\t\t\t     unsigned long addr, unsigned long flags)\n{\n\tint err;\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma = NULL;\n\tstruct mempolicy *pol = current->mempolicy;\n\n\tif (flags &\n\t\t~(unsigned long)(MPOL_F_NODE|MPOL_F_ADDR|MPOL_F_MEMS_ALLOWED))\n\t\treturn -EINVAL;\n\n\tif (flags & MPOL_F_MEMS_ALLOWED) {\n\t\tif (flags & (MPOL_F_NODE|MPOL_F_ADDR))\n\t\t\treturn -EINVAL;\n\t\t*policy = 0;\t/* just so it's initialized */\n\t\ttask_lock(current);\n\t\t*nmask  = cpuset_current_mems_allowed;\n\t\ttask_unlock(current);\n\t\treturn 0;\n\t}\n\n\tif (flags & MPOL_F_ADDR) {\n\t\t/*\n\t\t * Do NOT fall back to task policy if the\n\t\t * vma/shared policy at addr is NULL.  We\n\t\t * want to return MPOL_DEFAULT in this case.\n\t\t */\n\t\tdown_read(&mm->mmap_sem);\n\t\tvma = find_vma_intersection(mm, addr, addr+1);\n\t\tif (!vma) {\n\t\t\tup_read(&mm->mmap_sem);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tif (vma->vm_ops && vma->vm_ops->get_policy)\n\t\t\tpol = vma->vm_ops->get_policy(vma, addr);\n\t\telse\n\t\t\tpol = vma->vm_policy;\n\t} else if (addr)\n\t\treturn -EINVAL;\n\n\tif (!pol)\n\t\tpol = &default_policy;\t/* indicates default behavior */\n\n\tif (flags & MPOL_F_NODE) {\n\t\tif (flags & MPOL_F_ADDR) {\n\t\t\terr = lookup_node(addr);\n\t\t\tif (err < 0)\n\t\t\t\tgoto out;\n\t\t\t*policy = err;\n\t\t} else if (pol == current->mempolicy &&\n\t\t\t\tpol->mode == MPOL_INTERLEAVE) {\n\t\t\t*policy = next_node_in(current->il_prev, pol->v.nodes);\n\t\t} else {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t*policy = pol == &default_policy ? MPOL_DEFAULT :\n\t\t\t\t\t\tpol->mode;\n\t\t/*\n\t\t * Internal mempolicy flags must be masked off before exposing\n\t\t * the policy to userspace.\n\t\t */\n \t\t*policy |= (pol->flags & MPOL_MODE_FLAGS);\n \t}\n \n \terr = 0;\n \tif (nmask) {\n \t\tif (mpol_store_user_nodemask(pol)) {\n\t\t\t*nmask = pol->w.user_nodemask;\n\t\t} else {\n\t\t\ttask_lock(current);\n\t\t\tget_policy_nodemask(pol, nmask);\n\t\t\ttask_unlock(current);\n\t\t}\n\t}\n\n out:\n\tmpol_cond_put(pol);\n\tif (vma)\n\t\tup_read(&current->mm->mmap_sem);\n\treturn err;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143036,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "mrb_io_initialize_copy(mrb_state *mrb, mrb_value copy)\n{\n  mrb_value orig;\n  mrb_value buf;\n  struct mrb_io *fptr_copy;\n  struct mrb_io *fptr_orig;\n   mrb_bool failed = TRUE;\n \n   mrb_get_args(mrb, \"o\", &orig);\n   fptr_copy = (struct mrb_io *)DATA_PTR(copy);\n   if (fptr_copy != NULL) {\n     fptr_finalize(mrb, fptr_copy, FALSE);\n     mrb_free(mrb, fptr_copy);\n   }\n   fptr_copy = (struct mrb_io *)mrb_io_alloc(mrb);\n  fptr_orig = io_get_open_fptr(mrb, orig);\n \n   DATA_TYPE(copy) = &mrb_io_type;\n   DATA_PTR(copy) = fptr_copy;\n\n  buf = mrb_iv_get(mrb, orig, mrb_intern_cstr(mrb, \"@buf\"));\n  mrb_iv_set(mrb, copy, mrb_intern_cstr(mrb, \"@buf\"), buf);\n\n  fptr_copy->fd = mrb_dup(mrb, fptr_orig->fd, &failed);\n  if (failed) {\n    mrb_sys_fail(mrb, 0);\n  }\n  mrb_fd_cloexec(mrb, fptr_copy->fd);\n\n  if (fptr_orig->fd2 != -1) {\n    fptr_copy->fd2 = mrb_dup(mrb, fptr_orig->fd2, &failed);\n    if (failed) {\n      close(fptr_copy->fd);\n      mrb_sys_fail(mrb, 0);\n    }\n    mrb_fd_cloexec(mrb, fptr_copy->fd2);\n  }\n\n  fptr_copy->pid = fptr_orig->pid;\n  fptr_copy->readable = fptr_orig->readable;\n  fptr_copy->writable = fptr_orig->writable;\n  fptr_copy->sync = fptr_orig->sync;\n  fptr_copy->is_socket = fptr_orig->is_socket;\n\n  return copy;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143039,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "mrb_io_initialize_copy(mrb_state *mrb, mrb_value copy)\n{\n  mrb_value orig;\n  mrb_value buf;\n  struct mrb_io *fptr_copy;\n  struct mrb_io *fptr_orig;\n   mrb_bool failed = TRUE;\n \n   mrb_get_args(mrb, \"o\", &orig);\n  fptr_orig = io_get_open_fptr(mrb, orig);\n   fptr_copy = (struct mrb_io *)DATA_PTR(copy);\n   if (fptr_copy != NULL) {\n     fptr_finalize(mrb, fptr_copy, FALSE);\n     mrb_free(mrb, fptr_copy);\n   }\n   fptr_copy = (struct mrb_io *)mrb_io_alloc(mrb);\n \n   DATA_TYPE(copy) = &mrb_io_type;\n   DATA_PTR(copy) = fptr_copy;\n\n  buf = mrb_iv_get(mrb, orig, mrb_intern_cstr(mrb, \"@buf\"));\n  mrb_iv_set(mrb, copy, mrb_intern_cstr(mrb, \"@buf\"), buf);\n\n  fptr_copy->fd = mrb_dup(mrb, fptr_orig->fd, &failed);\n  if (failed) {\n    mrb_sys_fail(mrb, 0);\n  }\n  mrb_fd_cloexec(mrb, fptr_copy->fd);\n\n  if (fptr_orig->fd2 != -1) {\n    fptr_copy->fd2 = mrb_dup(mrb, fptr_orig->fd2, &failed);\n    if (failed) {\n      close(fptr_copy->fd);\n      mrb_sys_fail(mrb, 0);\n    }\n    mrb_fd_cloexec(mrb, fptr_copy->fd2);\n  }\n\n  fptr_copy->pid = fptr_orig->pid;\n  fptr_copy->readable = fptr_orig->readable;\n  fptr_copy->writable = fptr_orig->writable;\n  fptr_copy->sync = fptr_orig->sync;\n  fptr_copy->is_socket = fptr_orig->is_socket;\n\n  return copy;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143040,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static void *__ns_get_path(struct path *path, struct ns_common *ns)\n{\n\tstruct vfsmount *mnt = nsfs_mnt;\n\tstruct qstr qname = { .name = \"\", };\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tunsigned long d;\n\n\trcu_read_lock();\n\td = atomic_long_read(&ns->stashed);\n\tif (!d)\n\t\tgoto slow;\n\tdentry = (struct dentry *)d;\n\tif (!lockref_get_not_dead(&dentry->d_lockref))\n\t\tgoto slow;\n\trcu_read_unlock();\n\tns->ops->put(ns);\ngot_it:\n\tpath->mnt = mntget(mnt);\n\tpath->dentry = dentry;\n\treturn NULL;\nslow:\n\trcu_read_unlock();\n\tinode = new_inode_pseudo(mnt->mnt_sb);\n\tif (!inode) {\n\t\tns->ops->put(ns);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tinode->i_ino = ns->inum;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = current_time(inode);\n\tinode->i_flags |= S_IMMUTABLE;\n\tinode->i_mode = S_IFREG | S_IRUGO;\n\tinode->i_fop = &ns_file_operations;\n\tinode->i_private = ns;\n\n\tdentry = d_alloc_pseudo(mnt->mnt_sb, &qname);\n\tif (!dentry) {\n\t\tiput(inode);\n \t\treturn ERR_PTR(-ENOMEM);\n \t}\n \td_instantiate(dentry, inode);\n \tdentry->d_fsdata = (void *)ns->ops;\n \td = atomic_long_cmpxchg(&ns->stashed, 0, (unsigned long)dentry);\n \tif (d) {\n\t\td_delete(dentry);\t/* make sure ->d_prune() does nothing */\n\t\tdput(dentry);\n\t\tcpu_relax();\n\t\treturn ERR_PTR(-EAGAIN);\n\t}\n\tgoto got_it;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143091,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static void *__ns_get_path(struct path *path, struct ns_common *ns)\n{\n\tstruct vfsmount *mnt = nsfs_mnt;\n\tstruct qstr qname = { .name = \"\", };\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tunsigned long d;\n\n\trcu_read_lock();\n\td = atomic_long_read(&ns->stashed);\n\tif (!d)\n\t\tgoto slow;\n\tdentry = (struct dentry *)d;\n\tif (!lockref_get_not_dead(&dentry->d_lockref))\n\t\tgoto slow;\n\trcu_read_unlock();\n\tns->ops->put(ns);\ngot_it:\n\tpath->mnt = mntget(mnt);\n\tpath->dentry = dentry;\n\treturn NULL;\nslow:\n\trcu_read_unlock();\n\tinode = new_inode_pseudo(mnt->mnt_sb);\n\tif (!inode) {\n\t\tns->ops->put(ns);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tinode->i_ino = ns->inum;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = current_time(inode);\n\tinode->i_flags |= S_IMMUTABLE;\n\tinode->i_mode = S_IFREG | S_IRUGO;\n\tinode->i_fop = &ns_file_operations;\n\tinode->i_private = ns;\n\n\tdentry = d_alloc_pseudo(mnt->mnt_sb, &qname);\n\tif (!dentry) {\n\t\tiput(inode);\n \t\treturn ERR_PTR(-ENOMEM);\n \t}\n \td_instantiate(dentry, inode);\n\tdentry->d_flags |= DCACHE_RCUACCESS;\n \tdentry->d_fsdata = (void *)ns->ops;\n \td = atomic_long_cmpxchg(&ns->stashed, 0, (unsigned long)dentry);\n \tif (d) {\n\t\td_delete(dentry);\t/* make sure ->d_prune() does nothing */\n\t\tdput(dentry);\n\t\tcpu_relax();\n\t\treturn ERR_PTR(-EAGAIN);\n\t}\n\tgoto got_it;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143092,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static void lo_release(struct gendisk *disk, fmode_t mode)\n {\n\tstruct loop_device *lo = disk->private_data;\n \tint err;\n \n \tif (atomic_dec_return(&lo->lo_refcnt))\n\t\treturn;\n\n\tmutex_lock(&lo->lo_ctl_mutex);\n\tif (lo->lo_flags & LO_FLAGS_AUTOCLEAR) {\n\t\t/*\n\t\t * In autoclear mode, stop the loop thread\n\t\t * and remove configuration after last close.\n\t\t */\n\t\terr = loop_clr_fd(lo);\n\t\tif (!err)\n\t\t\treturn;\n\t} else if (lo->lo_state == Lo_bound) {\n\t\t/*\n\t\t * Otherwise keep thread (if running) and config,\n\t\t * but flush possible ongoing bios in thread.\n\t\t */\n\t\tblk_mq_freeze_queue(lo->lo_queue);\n\t\tblk_mq_unfreeze_queue(lo->lo_queue);\n\t}\n\n \tmutex_unlock(&lo->lo_ctl_mutex);\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143093,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static void lo_release(struct gendisk *disk, fmode_t mode)\nstatic void __lo_release(struct loop_device *lo)\n {\n \tint err;\n \n \tif (atomic_dec_return(&lo->lo_refcnt))\n\t\treturn;\n\n\tmutex_lock(&lo->lo_ctl_mutex);\n\tif (lo->lo_flags & LO_FLAGS_AUTOCLEAR) {\n\t\t/*\n\t\t * In autoclear mode, stop the loop thread\n\t\t * and remove configuration after last close.\n\t\t */\n\t\terr = loop_clr_fd(lo);\n\t\tif (!err)\n\t\t\treturn;\n\t} else if (lo->lo_state == Lo_bound) {\n\t\t/*\n\t\t * Otherwise keep thread (if running) and config,\n\t\t * but flush possible ongoing bios in thread.\n\t\t */\n\t\tblk_mq_freeze_queue(lo->lo_queue);\n\t\tblk_mq_unfreeze_queue(lo->lo_queue);\n\t}\n\n \tmutex_unlock(&lo->lo_ctl_mutex);\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143094,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static netdev_tx_t hns_nic_net_xmit(struct sk_buff *skb,\n \t\t\t\t    struct net_device *ndev)\n {\n \tstruct hns_nic_priv *priv = netdev_priv(ndev);\n\tint ret;\n \n \tassert(skb->queue_mapping < ndev->ae_handle->q_num);\n\tret = hns_nic_net_xmit_hw(ndev, skb,\n\t\t\t\t  &tx_ring_data(priv, skb->queue_mapping));\n\tif (ret == NETDEV_TX_OK) {\n\t\tnetif_trans_update(ndev);\n\t\tndev->stats.tx_bytes += skb->len;\n\t\tndev->stats.tx_packets++;\n\t}\n\treturn (netdev_tx_t)ret;\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143119,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static netdev_tx_t hns_nic_net_xmit(struct sk_buff *skb,\n \t\t\t\t    struct net_device *ndev)\n {\n \tstruct hns_nic_priv *priv = netdev_priv(ndev);\n \n \tassert(skb->queue_mapping < ndev->ae_handle->q_num);\n\n\treturn hns_nic_net_xmit_hw(ndev, skb,\n\t\t\t\t   &tx_ring_data(priv, skb->queue_mapping));\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143120,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "int hns_nic_net_xmit_hw(struct net_device *ndev,\n\t\t\tstruct sk_buff *skb,\n\t\t\tstruct hns_nic_ring_data *ring_data)\n {\n \tstruct hns_nic_priv *priv = netdev_priv(ndev);\n \tstruct hnae_ring *ring = ring_data->ring;\n\tstruct device *dev = ring_to_dev(ring);\n\tstruct netdev_queue *dev_queue;\n\tstruct skb_frag_struct *frag;\n\tint buf_num;\n\tint seg_num;\n\tdma_addr_t dma;\n\tint size, next_to_use;\n\tint i;\n\n\tswitch (priv->ops.maybe_stop_tx(&skb, &buf_num, ring)) {\n\tcase -EBUSY:\n\t\tring->stats.tx_busy++;\n\t\tgoto out_net_tx_busy;\n\tcase -ENOMEM:\n\t\tring->stats.sw_err_cnt++;\n\t\tnetdev_err(ndev, \"no memory to xmit!\\n\");\n\t\tgoto out_err_tx_ok;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/* no. of segments (plus a header) */\n\tseg_num = skb_shinfo(skb)->nr_frags + 1;\n\tnext_to_use = ring->next_to_use;\n\n\t/* fill the first part */\n\tsize = skb_headlen(skb);\n\tdma = dma_map_single(dev, skb->data, size, DMA_TO_DEVICE);\n\tif (dma_mapping_error(dev, dma)) {\n\t\tnetdev_err(ndev, \"TX head DMA map failed\\n\");\n\t\tring->stats.sw_err_cnt++;\n\t\tgoto out_err_tx_ok;\n\t}\n\tpriv->ops.fill_desc(ring, skb, size, dma, seg_num == 1 ? 1 : 0,\n\t\t\t    buf_num, DESC_TYPE_SKB, ndev->mtu);\n\n\t/* fill the fragments */\n\tfor (i = 1; i < seg_num; i++) {\n\t\tfrag = &skb_shinfo(skb)->frags[i - 1];\n\t\tsize = skb_frag_size(frag);\n\t\tdma = skb_frag_dma_map(dev, frag, 0, size, DMA_TO_DEVICE);\n\t\tif (dma_mapping_error(dev, dma)) {\n\t\t\tnetdev_err(ndev, \"TX frag(%d) DMA map failed\\n\", i);\n\t\t\tring->stats.sw_err_cnt++;\n\t\t\tgoto out_map_frag_fail;\n\t\t}\n\t\tpriv->ops.fill_desc(ring, skb_frag_page(frag), size, dma,\n\t\t\t\t    seg_num - 1 == i ? 1 : 0, buf_num,\n\t\t\t\t    DESC_TYPE_PAGE, ndev->mtu);\n\t}\n\n\t/*complete translate all packets*/\n \tdev_queue = netdev_get_tx_queue(ndev, skb->queue_mapping);\n \tnetdev_tx_sent_queue(dev_queue, skb->len);\n \n \twmb(); /* commit all data before submit */\n \tassert(skb->queue_mapping < priv->ae_handle->q_num);\n \thnae_queue_xmit(priv->ae_handle->qs[skb->queue_mapping], buf_num);\n\tring->stats.tx_pkts++;\n\tring->stats.tx_bytes += skb->len;\n\n\treturn NETDEV_TX_OK;\n\nout_map_frag_fail:\n\n\twhile (ring->next_to_use != next_to_use) {\n\t\tunfill_desc(ring);\n\t\tif (ring->next_to_use != next_to_use)\n\t\t\tdma_unmap_page(dev,\n\t\t\t\t       ring->desc_cb[ring->next_to_use].dma,\n\t\t\t\t       ring->desc_cb[ring->next_to_use].length,\n\t\t\t\t       DMA_TO_DEVICE);\n\t\telse\n\t\t\tdma_unmap_single(dev,\n\t\t\t\t\t ring->desc_cb[next_to_use].dma,\n\t\t\t\t\t ring->desc_cb[next_to_use].length,\n\t\t\t\t\t DMA_TO_DEVICE);\n\t}\n\nout_err_tx_ok:\n\n\tdev_kfree_skb_any(skb);\n\treturn NETDEV_TX_OK;\n\nout_net_tx_busy:\n\n\tnetif_stop_subqueue(ndev, skb->queue_mapping);\n\n\t/* Herbert's original patch had:\n\t *  smp_mb__after_netif_stop_queue();\n\t * but since that doesn't exist yet, just open code it.\n\t */\n\tsmp_mb();\n\treturn NETDEV_TX_BUSY;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143121,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "int hns_nic_net_xmit_hw(struct net_device *ndev,\nnetdev_tx_t hns_nic_net_xmit_hw(struct net_device *ndev,\n\t\t\t\tstruct sk_buff *skb,\n\t\t\t\tstruct hns_nic_ring_data *ring_data)\n {\n \tstruct hns_nic_priv *priv = netdev_priv(ndev);\n \tstruct hnae_ring *ring = ring_data->ring;\n\tstruct device *dev = ring_to_dev(ring);\n\tstruct netdev_queue *dev_queue;\n\tstruct skb_frag_struct *frag;\n\tint buf_num;\n\tint seg_num;\n\tdma_addr_t dma;\n\tint size, next_to_use;\n\tint i;\n\n\tswitch (priv->ops.maybe_stop_tx(&skb, &buf_num, ring)) {\n\tcase -EBUSY:\n\t\tring->stats.tx_busy++;\n\t\tgoto out_net_tx_busy;\n\tcase -ENOMEM:\n\t\tring->stats.sw_err_cnt++;\n\t\tnetdev_err(ndev, \"no memory to xmit!\\n\");\n\t\tgoto out_err_tx_ok;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/* no. of segments (plus a header) */\n\tseg_num = skb_shinfo(skb)->nr_frags + 1;\n\tnext_to_use = ring->next_to_use;\n\n\t/* fill the first part */\n\tsize = skb_headlen(skb);\n\tdma = dma_map_single(dev, skb->data, size, DMA_TO_DEVICE);\n\tif (dma_mapping_error(dev, dma)) {\n\t\tnetdev_err(ndev, \"TX head DMA map failed\\n\");\n\t\tring->stats.sw_err_cnt++;\n\t\tgoto out_err_tx_ok;\n\t}\n\tpriv->ops.fill_desc(ring, skb, size, dma, seg_num == 1 ? 1 : 0,\n\t\t\t    buf_num, DESC_TYPE_SKB, ndev->mtu);\n\n\t/* fill the fragments */\n\tfor (i = 1; i < seg_num; i++) {\n\t\tfrag = &skb_shinfo(skb)->frags[i - 1];\n\t\tsize = skb_frag_size(frag);\n\t\tdma = skb_frag_dma_map(dev, frag, 0, size, DMA_TO_DEVICE);\n\t\tif (dma_mapping_error(dev, dma)) {\n\t\t\tnetdev_err(ndev, \"TX frag(%d) DMA map failed\\n\", i);\n\t\t\tring->stats.sw_err_cnt++;\n\t\t\tgoto out_map_frag_fail;\n\t\t}\n\t\tpriv->ops.fill_desc(ring, skb_frag_page(frag), size, dma,\n\t\t\t\t    seg_num - 1 == i ? 1 : 0, buf_num,\n\t\t\t\t    DESC_TYPE_PAGE, ndev->mtu);\n\t}\n\n\t/*complete translate all packets*/\n \tdev_queue = netdev_get_tx_queue(ndev, skb->queue_mapping);\n \tnetdev_tx_sent_queue(dev_queue, skb->len);\n \n\tnetif_trans_update(ndev);\n\tndev->stats.tx_bytes += skb->len;\n\tndev->stats.tx_packets++;\n\n \twmb(); /* commit all data before submit */\n \tassert(skb->queue_mapping < priv->ae_handle->q_num);\n \thnae_queue_xmit(priv->ae_handle->qs[skb->queue_mapping], buf_num);\n\tring->stats.tx_pkts++;\n\tring->stats.tx_bytes += skb->len;\n\n\treturn NETDEV_TX_OK;\n\nout_map_frag_fail:\n\n\twhile (ring->next_to_use != next_to_use) {\n\t\tunfill_desc(ring);\n\t\tif (ring->next_to_use != next_to_use)\n\t\t\tdma_unmap_page(dev,\n\t\t\t\t       ring->desc_cb[ring->next_to_use].dma,\n\t\t\t\t       ring->desc_cb[ring->next_to_use].length,\n\t\t\t\t       DMA_TO_DEVICE);\n\t\telse\n\t\t\tdma_unmap_single(dev,\n\t\t\t\t\t ring->desc_cb[next_to_use].dma,\n\t\t\t\t\t ring->desc_cb[next_to_use].length,\n\t\t\t\t\t DMA_TO_DEVICE);\n\t}\n\nout_err_tx_ok:\n\n\tdev_kfree_skb_any(skb);\n\treturn NETDEV_TX_OK;\n\nout_net_tx_busy:\n\n\tnetif_stop_subqueue(ndev, skb->queue_mapping);\n\n\t/* Herbert's original patch had:\n\t *  smp_mb__after_netif_stop_queue();\n\t * but since that doesn't exist yet, just open code it.\n\t */\n\tsmp_mb();\n\treturn NETDEV_TX_BUSY;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143122,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "tcpmss_mangle_packet(struct sk_buff *skb,\n\t\t     const struct xt_action_param *par,\n\t\t     unsigned int family,\n\t\t     unsigned int tcphoff,\n\t\t     unsigned int minlen)\n{\n\tconst struct xt_tcpmss_info *info = par->targinfo;\n\tstruct tcphdr *tcph;\n\tint len, tcp_hdrlen;\n\tunsigned int i;\n\t__be16 oldval;\n\tu16 newmss;\n\tu8 *opt;\n\n\t/* This is a fragment, no TCP header is available */\n\tif (par->fragoff != 0)\n\t\treturn 0;\n\n\tif (!skb_make_writable(skb, skb->len))\n\t\treturn -1;\n\n\tlen = skb->len - tcphoff;\n\tif (len < (int)sizeof(struct tcphdr))\n\t\treturn -1;\n\n \ttcph = (struct tcphdr *)(skb_network_header(skb) + tcphoff);\n \ttcp_hdrlen = tcph->doff * 4;\n \n\tif (len < tcp_hdrlen)\n \t\treturn -1;\n \n \tif (info->mss == XT_TCPMSS_CLAMP_PMTU) {\n\t\tstruct net *net = xt_net(par);\n\t\tunsigned int in_mtu = tcpmss_reverse_mtu(net, skb, family);\n\t\tunsigned int min_mtu = min(dst_mtu(skb_dst(skb)), in_mtu);\n\n\t\tif (min_mtu <= minlen) {\n\t\t\tnet_err_ratelimited(\"unknown or invalid path-MTU (%u)\\n\",\n\t\t\t\t\t    min_mtu);\n\t\t\treturn -1;\n\t\t}\n\t\tnewmss = min_mtu - minlen;\n\t} else\n\t\tnewmss = info->mss;\n\n\topt = (u_int8_t *)tcph;\n\tfor (i = sizeof(struct tcphdr); i <= tcp_hdrlen - TCPOLEN_MSS; i += optlen(opt, i)) {\n\t\tif (opt[i] == TCPOPT_MSS && opt[i+1] == TCPOLEN_MSS) {\n\t\t\tu_int16_t oldmss;\n\n\t\t\toldmss = (opt[i+2] << 8) | opt[i+3];\n\n\t\t\t/* Never increase MSS, even when setting it, as\n\t\t\t * doing so results in problems for hosts that rely\n\t\t\t * on MSS being set correctly.\n\t\t\t */\n\t\t\tif (oldmss <= newmss)\n\t\t\t\treturn 0;\n\n\t\t\topt[i+2] = (newmss & 0xff00) >> 8;\n\t\t\topt[i+3] = newmss & 0x00ff;\n\n\t\t\tinet_proto_csum_replace2(&tcph->check, skb,\n\t\t\t\t\t\t htons(oldmss), htons(newmss),\n\t\t\t\t\t\t false);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* There is data after the header so the option can't be added\n\t * without moving it, and doing so may make the SYN packet\n\t * itself too large. Accept the packet unmodified instead.\n\t */\n \tif (len > tcp_hdrlen)\n \t\treturn 0;\n \n \t/*\n \t * MSS Option not found ?! add it..\n \t */\n\tif (skb_tailroom(skb) < TCPOLEN_MSS) {\n\t\tif (pskb_expand_head(skb, 0,\n\t\t\t\t     TCPOLEN_MSS - skb_tailroom(skb),\n\t\t\t\t     GFP_ATOMIC))\n\t\t\treturn -1;\n\t\ttcph = (struct tcphdr *)(skb_network_header(skb) + tcphoff);\n\t}\n\n\tskb_put(skb, TCPOLEN_MSS);\n\n\t/*\n\t * IPv4: RFC 1122 states \"If an MSS option is not received at\n\t * connection setup, TCP MUST assume a default send MSS of 536\".\n\t * IPv6: RFC 2460 states IPv6 has a minimum MTU of 1280 and a minimum\n\t * length IPv6 header of 60, ergo the default MSS value is 1220\n\t * Since no MSS was provided, we must use the default values\n\t */\n\tif (xt_family(par) == NFPROTO_IPV4)\n\t\tnewmss = min(newmss, (u16)536);\n\telse\n\t\tnewmss = min(newmss, (u16)1220);\n\n\topt = (u_int8_t *)tcph + sizeof(struct tcphdr);\n\tmemmove(opt + TCPOLEN_MSS, opt, len - sizeof(struct tcphdr));\n\n\tinet_proto_csum_replace2(&tcph->check, skb,\n\t\t\t\t htons(len), htons(len + TCPOLEN_MSS), true);\n\topt[0] = TCPOPT_MSS;\n\topt[1] = TCPOLEN_MSS;\n\topt[2] = (newmss & 0xff00) >> 8;\n\topt[3] = newmss & 0x00ff;\n\n\tinet_proto_csum_replace4(&tcph->check, skb, 0, *((__be32 *)opt), false);\n\n\toldval = ((__be16 *)tcph)[6];\n\ttcph->doff += TCPOLEN_MSS/4;\n\tinet_proto_csum_replace2(&tcph->check, skb,\n\t\t\t\t oldval, ((__be16 *)tcph)[6], false);\n\treturn TCPOLEN_MSS;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143139,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "tcpmss_mangle_packet(struct sk_buff *skb,\n\t\t     const struct xt_action_param *par,\n\t\t     unsigned int family,\n\t\t     unsigned int tcphoff,\n\t\t     unsigned int minlen)\n{\n\tconst struct xt_tcpmss_info *info = par->targinfo;\n\tstruct tcphdr *tcph;\n\tint len, tcp_hdrlen;\n\tunsigned int i;\n\t__be16 oldval;\n\tu16 newmss;\n\tu8 *opt;\n\n\t/* This is a fragment, no TCP header is available */\n\tif (par->fragoff != 0)\n\t\treturn 0;\n\n\tif (!skb_make_writable(skb, skb->len))\n\t\treturn -1;\n\n\tlen = skb->len - tcphoff;\n\tif (len < (int)sizeof(struct tcphdr))\n\t\treturn -1;\n\n \ttcph = (struct tcphdr *)(skb_network_header(skb) + tcphoff);\n \ttcp_hdrlen = tcph->doff * 4;\n \n\tif (len < tcp_hdrlen || tcp_hdrlen < sizeof(struct tcphdr))\n \t\treturn -1;\n \n \tif (info->mss == XT_TCPMSS_CLAMP_PMTU) {\n\t\tstruct net *net = xt_net(par);\n\t\tunsigned int in_mtu = tcpmss_reverse_mtu(net, skb, family);\n\t\tunsigned int min_mtu = min(dst_mtu(skb_dst(skb)), in_mtu);\n\n\t\tif (min_mtu <= minlen) {\n\t\t\tnet_err_ratelimited(\"unknown or invalid path-MTU (%u)\\n\",\n\t\t\t\t\t    min_mtu);\n\t\t\treturn -1;\n\t\t}\n\t\tnewmss = min_mtu - minlen;\n\t} else\n\t\tnewmss = info->mss;\n\n\topt = (u_int8_t *)tcph;\n\tfor (i = sizeof(struct tcphdr); i <= tcp_hdrlen - TCPOLEN_MSS; i += optlen(opt, i)) {\n\t\tif (opt[i] == TCPOPT_MSS && opt[i+1] == TCPOLEN_MSS) {\n\t\t\tu_int16_t oldmss;\n\n\t\t\toldmss = (opt[i+2] << 8) | opt[i+3];\n\n\t\t\t/* Never increase MSS, even when setting it, as\n\t\t\t * doing so results in problems for hosts that rely\n\t\t\t * on MSS being set correctly.\n\t\t\t */\n\t\t\tif (oldmss <= newmss)\n\t\t\t\treturn 0;\n\n\t\t\topt[i+2] = (newmss & 0xff00) >> 8;\n\t\t\topt[i+3] = newmss & 0x00ff;\n\n\t\t\tinet_proto_csum_replace2(&tcph->check, skb,\n\t\t\t\t\t\t htons(oldmss), htons(newmss),\n\t\t\t\t\t\t false);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* There is data after the header so the option can't be added\n\t * without moving it, and doing so may make the SYN packet\n\t * itself too large. Accept the packet unmodified instead.\n\t */\n \tif (len > tcp_hdrlen)\n \t\treturn 0;\n \n\t/* tcph->doff has 4 bits, do not wrap it to 0 */\n\tif (tcp_hdrlen >= 15 * 4)\n\t\treturn 0;\n\n \t/*\n \t * MSS Option not found ?! add it..\n \t */\n\tif (skb_tailroom(skb) < TCPOLEN_MSS) {\n\t\tif (pskb_expand_head(skb, 0,\n\t\t\t\t     TCPOLEN_MSS - skb_tailroom(skb),\n\t\t\t\t     GFP_ATOMIC))\n\t\t\treturn -1;\n\t\ttcph = (struct tcphdr *)(skb_network_header(skb) + tcphoff);\n\t}\n\n\tskb_put(skb, TCPOLEN_MSS);\n\n\t/*\n\t * IPv4: RFC 1122 states \"If an MSS option is not received at\n\t * connection setup, TCP MUST assume a default send MSS of 536\".\n\t * IPv6: RFC 2460 states IPv6 has a minimum MTU of 1280 and a minimum\n\t * length IPv6 header of 60, ergo the default MSS value is 1220\n\t * Since no MSS was provided, we must use the default values\n\t */\n\tif (xt_family(par) == NFPROTO_IPV4)\n\t\tnewmss = min(newmss, (u16)536);\n\telse\n\t\tnewmss = min(newmss, (u16)1220);\n\n\topt = (u_int8_t *)tcph + sizeof(struct tcphdr);\n\tmemmove(opt + TCPOLEN_MSS, opt, len - sizeof(struct tcphdr));\n\n\tinet_proto_csum_replace2(&tcph->check, skb,\n\t\t\t\t htons(len), htons(len + TCPOLEN_MSS), true);\n\topt[0] = TCPOPT_MSS;\n\topt[1] = TCPOLEN_MSS;\n\topt[2] = (newmss & 0xff00) >> 8;\n\topt[3] = newmss & 0x00ff;\n\n\tinet_proto_csum_replace4(&tcph->check, skb, 0, *((__be32 *)opt), false);\n\n\toldval = ((__be16 *)tcph)[6];\n\ttcph->doff += TCPOLEN_MSS/4;\n\tinet_proto_csum_replace2(&tcph->check, skb,\n\t\t\t\t oldval, ((__be16 *)tcph)[6], false);\n\treturn TCPOLEN_MSS;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143140,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "struct net *get_net_ns_by_id(struct net *net, int id)\n{\n\tstruct net *peer;\n\n\tif (id < 0)\n\t\treturn NULL;\n\n\trcu_read_lock();\n \tspin_lock_bh(&net->nsid_lock);\n \tpeer = idr_find(&net->netns_ids, id);\n \tif (peer)\n\t\tget_net(peer);\n \tspin_unlock_bh(&net->nsid_lock);\n \trcu_read_unlock();\n \n\treturn peer;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143141,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "struct net *get_net_ns_by_id(struct net *net, int id)\n{\n\tstruct net *peer;\n\n\tif (id < 0)\n\t\treturn NULL;\n\n\trcu_read_lock();\n \tspin_lock_bh(&net->nsid_lock);\n \tpeer = idr_find(&net->netns_ids, id);\n \tif (peer)\n\t\tpeer = maybe_get_net(peer);\n \tspin_unlock_bh(&net->nsid_lock);\n \trcu_read_unlock();\n \n\treturn peer;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143142,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static MagickBooleanType TraceBezier(MVGInfo *mvg_info,\n  const size_t number_coordinates)\n{\n  double\n    alpha,\n    *coefficients,\n    weight;\n\n  PointInfo\n    end,\n    point,\n    *points;\n\n  PrimitiveInfo\n    *primitive_info;\n\n  register PrimitiveInfo\n    *p;\n\n  register ssize_t\n    i,\n    j;\n\n  size_t\n    control_points,\n    quantum;\n\n  /*\n    Allocate coefficients.\n  */\n  primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;\n  quantum=number_coordinates;\n  for (i=0; i < (ssize_t) number_coordinates; i++)\n  {\n    for (j=i+1; j < (ssize_t) number_coordinates; j++)\n    {\n      alpha=fabs(primitive_info[j].point.x-primitive_info[i].point.x);\n      if (alpha > (double) SSIZE_MAX)\n        {\n          (void) ThrowMagickException(mvg_info->exception,GetMagickModule(),\n            ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n          return(MagickFalse);\n        }\n      if (alpha > (double) quantum)\n        quantum=(size_t) alpha;\n      alpha=fabs(primitive_info[j].point.y-primitive_info[i].point.y);\n      if (alpha > (double) SSIZE_MAX)\n        {\n          (void) ThrowMagickException(mvg_info->exception,GetMagickModule(),\n            ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n          return(MagickFalse);\n        }\n      if (alpha > (double) quantum)\n         quantum=(size_t) alpha;\n     }\n   }\n  quantum=MagickMin(quantum/number_coordinates,BezierQuantum);\n   primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;\n   coefficients=(double *) AcquireQuantumMemory(number_coordinates,\n     sizeof(*coefficients));\n   points=(PointInfo *) AcquireQuantumMemory(quantum,number_coordinates*\n    sizeof(*points));\n  if ((coefficients == (double *) NULL) || (points == (PointInfo *) NULL))\n    {\n      if (points != (PointInfo *) NULL)\n        points=(PointInfo *) RelinquishMagickMemory(points);\n      if (coefficients != (double *) NULL)\n        coefficients=(double *) RelinquishMagickMemory(coefficients);\n      (void) ThrowMagickException(mvg_info->exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n      return(MagickFalse);\n    }\n  control_points=quantum*number_coordinates;\n  if (CheckPrimitiveExtent(mvg_info,control_points+1) == MagickFalse)\n    {\n      points=(PointInfo *) RelinquishMagickMemory(points);\n       coefficients=(double *) RelinquishMagickMemory(coefficients);\n       return(MagickFalse);\n     }\n   /*\n     Compute bezier points.\n   */\n  end=primitive_info[number_coordinates-1].point;\n  for (i=0; i < (ssize_t) number_coordinates; i++)\n    coefficients[i]=Permutate((ssize_t) number_coordinates-1,i);\n  weight=0.0;\n  for (i=0; i < (ssize_t) control_points; i++)\n  {\n    p=primitive_info;\n    point.x=0.0;\n    point.y=0.0;\n    alpha=pow((double) (1.0-weight),(double) number_coordinates-1.0);\n    for (j=0; j < (ssize_t) number_coordinates; j++)\n    {\n      point.x+=alpha*coefficients[j]*p->point.x;\n      point.y+=alpha*coefficients[j]*p->point.y;\n      alpha*=weight/(1.0-weight);\n      p++;\n    }\n    points[i]=point;\n    weight+=1.0/control_points;\n  }\n  /*\n    Bezier curves are just short segmented polys.\n  */\n  p=primitive_info;\n  for (i=0; i < (ssize_t) control_points; i++)\n  {\n    if (TracePoint(p,points[i]) == MagickFalse)\n      {\n        points=(PointInfo *) RelinquishMagickMemory(points);\n        coefficients=(double *) RelinquishMagickMemory(coefficients);\n        return(MagickFalse);\n      }\n    p+=p->coordinates;\n  }\n  if (TracePoint(p,end) == MagickFalse)\n    {\n      points=(PointInfo *) RelinquishMagickMemory(points);\n      coefficients=(double *) RelinquishMagickMemory(coefficients);\n      return(MagickFalse);\n    }\n  p+=p->coordinates;\n  primitive_info->coordinates=(size_t) (p-primitive_info);\n  primitive_info->closed_subpath=MagickFalse;\n  for (i=0; i < (ssize_t) primitive_info->coordinates; i++)\n  {\n    p->primitive=primitive_info->primitive;\n    p--;\n  }\n  points=(PointInfo *) RelinquishMagickMemory(points);\n  coefficients=(double *) RelinquishMagickMemory(coefficients);\n  return(MagickTrue);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143167,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static MagickBooleanType TraceBezier(MVGInfo *mvg_info,\n  const size_t number_coordinates)\n{\n  double\n    alpha,\n    *coefficients,\n    weight;\n\n  PointInfo\n    end,\n    point,\n    *points;\n\n  PrimitiveInfo\n    *primitive_info;\n\n  register PrimitiveInfo\n    *p;\n\n  register ssize_t\n    i,\n    j;\n\n  size_t\n    control_points,\n    quantum;\n\n  /*\n    Allocate coefficients.\n  */\n  primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;\n  quantum=number_coordinates;\n  for (i=0; i < (ssize_t) number_coordinates; i++)\n  {\n    for (j=i+1; j < (ssize_t) number_coordinates; j++)\n    {\n      alpha=fabs(primitive_info[j].point.x-primitive_info[i].point.x);\n      if (alpha > (double) SSIZE_MAX)\n        {\n          (void) ThrowMagickException(mvg_info->exception,GetMagickModule(),\n            ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n          return(MagickFalse);\n        }\n      if (alpha > (double) quantum)\n        quantum=(size_t) alpha;\n      alpha=fabs(primitive_info[j].point.y-primitive_info[i].point.y);\n      if (alpha > (double) SSIZE_MAX)\n        {\n          (void) ThrowMagickException(mvg_info->exception,GetMagickModule(),\n            ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n          return(MagickFalse);\n        }\n      if (alpha > (double) quantum)\n         quantum=(size_t) alpha;\n     }\n   }\n   primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;\n  quantum=MagickMin(quantum/number_coordinates,BezierQuantum);\n   coefficients=(double *) AcquireQuantumMemory(number_coordinates,\n     sizeof(*coefficients));\n   points=(PointInfo *) AcquireQuantumMemory(quantum,number_coordinates*\n    sizeof(*points));\n  if ((coefficients == (double *) NULL) || (points == (PointInfo *) NULL))\n    {\n      if (points != (PointInfo *) NULL)\n        points=(PointInfo *) RelinquishMagickMemory(points);\n      if (coefficients != (double *) NULL)\n        coefficients=(double *) RelinquishMagickMemory(coefficients);\n      (void) ThrowMagickException(mvg_info->exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n      return(MagickFalse);\n    }\n  control_points=quantum*number_coordinates;\n  if (CheckPrimitiveExtent(mvg_info,control_points+1) == MagickFalse)\n    {\n      points=(PointInfo *) RelinquishMagickMemory(points);\n       coefficients=(double *) RelinquishMagickMemory(coefficients);\n       return(MagickFalse);\n     }\n  primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;\n   /*\n     Compute bezier points.\n   */\n  end=primitive_info[number_coordinates-1].point;\n  for (i=0; i < (ssize_t) number_coordinates; i++)\n    coefficients[i]=Permutate((ssize_t) number_coordinates-1,i);\n  weight=0.0;\n  for (i=0; i < (ssize_t) control_points; i++)\n  {\n    p=primitive_info;\n    point.x=0.0;\n    point.y=0.0;\n    alpha=pow((double) (1.0-weight),(double) number_coordinates-1.0);\n    for (j=0; j < (ssize_t) number_coordinates; j++)\n    {\n      point.x+=alpha*coefficients[j]*p->point.x;\n      point.y+=alpha*coefficients[j]*p->point.y;\n      alpha*=weight/(1.0-weight);\n      p++;\n    }\n    points[i]=point;\n    weight+=1.0/control_points;\n  }\n  /*\n    Bezier curves are just short segmented polys.\n  */\n  p=primitive_info;\n  for (i=0; i < (ssize_t) control_points; i++)\n  {\n    if (TracePoint(p,points[i]) == MagickFalse)\n      {\n        points=(PointInfo *) RelinquishMagickMemory(points);\n        coefficients=(double *) RelinquishMagickMemory(coefficients);\n        return(MagickFalse);\n      }\n    p+=p->coordinates;\n  }\n  if (TracePoint(p,end) == MagickFalse)\n    {\n      points=(PointInfo *) RelinquishMagickMemory(points);\n      coefficients=(double *) RelinquishMagickMemory(coefficients);\n      return(MagickFalse);\n    }\n  p+=p->coordinates;\n  primitive_info->coordinates=(size_t) (p-primitive_info);\n  primitive_info->closed_subpath=MagickFalse;\n  for (i=0; i < (ssize_t) primitive_info->coordinates; i++)\n  {\n    p->primitive=primitive_info->primitive;\n    p--;\n  }\n  points=(PointInfo *) RelinquishMagickMemory(points);\n  coefficients=(double *) RelinquishMagickMemory(coefficients);\n  return(MagickTrue);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143168,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int hci_uart_set_proto(struct hci_uart *hu, int id)\n{\n\tconst struct hci_uart_proto *p;\n\tint err;\n\n\tp = hci_uart_get_proto(id);\n\tif (!p)\n \t\treturn -EPROTONOSUPPORT;\n \n \thu->proto = p;\n\tset_bit(HCI_UART_PROTO_READY, &hu->flags);\n \n \terr = hci_uart_register_dev(hu);\n \tif (err) {\n\t\tclear_bit(HCI_UART_PROTO_READY, &hu->flags);\n \t\treturn err;\n \t}\n \n \treturn 0;\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143187,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int hci_uart_set_proto(struct hci_uart *hu, int id)\n{\n\tconst struct hci_uart_proto *p;\n\tint err;\n\n\tp = hci_uart_get_proto(id);\n\tif (!p)\n \t\treturn -EPROTONOSUPPORT;\n \n \thu->proto = p;\n \n \terr = hci_uart_register_dev(hu);\n \tif (err) {\n \t\treturn err;\n \t}\n \n\tset_bit(HCI_UART_PROTO_READY, &hu->flags);\n \treturn 0;\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143188,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "MagickExport unsigned char *DetachBlob(BlobInfo *blob_info)\n{\n  unsigned char\n    *data;\n\n  assert(blob_info != (BlobInfo *) NULL);\n  if (blob_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n   if (blob_info->mapped != MagickFalse)\n     {\n       (void) UnmapBlob(blob_info->data,blob_info->length);\n       RelinquishMagickResource(MapResource,blob_info->length);\n     }\n   blob_info->mapped=MagickFalse;\n  blob_info->length=0;\n  blob_info->offset=0;\n  blob_info->eof=MagickFalse;\n  blob_info->error=0;\n  blob_info->exempt=MagickFalse;\n  blob_info->type=UndefinedStream;\n  blob_info->file_info.file=(FILE *) NULL;\n  data=blob_info->data;\n  blob_info->data=(unsigned char *) NULL;\n  blob_info->stream=(StreamHandler) NULL;\n  return(data);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143203,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "MagickExport unsigned char *DetachBlob(BlobInfo *blob_info)\n{\n  unsigned char\n    *data;\n\n  assert(blob_info != (BlobInfo *) NULL);\n  if (blob_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n   if (blob_info->mapped != MagickFalse)\n     {\n       (void) UnmapBlob(blob_info->data,blob_info->length);\n      blob_info->data=NULL;\n       RelinquishMagickResource(MapResource,blob_info->length);\n     }\n   blob_info->mapped=MagickFalse;\n  blob_info->length=0;\n  blob_info->offset=0;\n  blob_info->eof=MagickFalse;\n  blob_info->error=0;\n  blob_info->exempt=MagickFalse;\n  blob_info->type=UndefinedStream;\n  blob_info->file_info.file=(FILE *) NULL;\n  data=blob_info->data;\n  blob_info->data=(unsigned char *) NULL;\n  blob_info->stream=(StreamHandler) NULL;\n  return(data);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143204,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": " onig_new_deluxe(regex_t** reg, const UChar* pattern, const UChar* pattern_end,\n                OnigCompileInfo* ci, OnigErrorInfo* einfo)\n{\n  int r;\n  UChar *cpat, *cpat_end;\n\n   if (IS_NOT_NULL(einfo)) einfo->par = (UChar* )NULL;\n \n   if (ci->pattern_enc != ci->target_enc) {\n    r = conv_encoding(ci->pattern_enc, ci->target_enc, pattern, pattern_end,\n                      &cpat, &cpat_end);\n    if (r != 0) return r;\n   }\n   else {\n     cpat     = (UChar* )pattern;\n    cpat_end = (UChar* )pattern_end;\n  }\n\n  *reg = (regex_t* )xmalloc(sizeof(regex_t));\n  if (IS_NULL(*reg)) {\n    r = ONIGERR_MEMORY;\n    goto err2;\n  }\n\n  r = onig_reg_init(*reg, ci->option, ci->case_fold_flag, ci->target_enc,\n                    ci->syntax);\n  if (r != 0) goto err;\n\n  r = onig_compile(*reg, cpat, cpat_end, einfo);\n  if (r != 0) {\n  err:\n    onig_free(*reg);\n    *reg = NULL;\n  }\n\n err2:\n  if (cpat != pattern) xfree(cpat);\n\n  return r;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143231,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": " onig_new_deluxe(regex_t** reg, const UChar* pattern, const UChar* pattern_end,\n                OnigCompileInfo* ci, OnigErrorInfo* einfo)\n{\n  int r;\n  UChar *cpat, *cpat_end;\n\n   if (IS_NOT_NULL(einfo)) einfo->par = (UChar* )NULL;\n \n   if (ci->pattern_enc != ci->target_enc) {\n    return ONIGERR_NOT_SUPPORTED_ENCODING_COMBINATION;\n   }\n   else {\n     cpat     = (UChar* )pattern;\n    cpat_end = (UChar* )pattern_end;\n  }\n\n  *reg = (regex_t* )xmalloc(sizeof(regex_t));\n  if (IS_NULL(*reg)) {\n    r = ONIGERR_MEMORY;\n    goto err2;\n  }\n\n  r = onig_reg_init(*reg, ci->option, ci->case_fold_flag, ci->target_enc,\n                    ci->syntax);\n  if (r != 0) goto err;\n\n  r = onig_compile(*reg, cpat, cpat_end, einfo);\n  if (r != 0) {\n  err:\n    onig_free(*reg);\n    *reg = NULL;\n  }\n\n err2:\n  if (cpat != pattern) xfree(cpat);\n\n  return r;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143232,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "int __mdiobus_register(struct mii_bus *bus, struct module *owner)\n{\n\tstruct mdio_device *mdiodev;\n\tint i, err;\n\tstruct gpio_desc *gpiod;\n\n\tif (NULL == bus || NULL == bus->name ||\n\t    NULL == bus->read || NULL == bus->write)\n\t\treturn -EINVAL;\n\n\tBUG_ON(bus->state != MDIOBUS_ALLOCATED &&\n\t       bus->state != MDIOBUS_UNREGISTERED);\n\n\tbus->owner = owner;\n\tbus->dev.parent = bus->parent;\n\tbus->dev.class = &mdio_bus_class;\n\tbus->dev.groups = NULL;\n\tdev_set_name(&bus->dev, \"%s\", bus->id);\n\n \terr = device_register(&bus->dev);\n \tif (err) {\n \t\tpr_err(\"mii_bus %s failed to register\\n\", bus->id);\n\t\tput_device(&bus->dev);\n \t\treturn -EINVAL;\n \t}\n \n\tmutex_init(&bus->mdio_lock);\n\n\t/* de-assert bus level PHY GPIO reset */\n\tgpiod = devm_gpiod_get_optional(&bus->dev, \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(gpiod)) {\n\t\tdev_err(&bus->dev, \"mii_bus %s couldn't get reset GPIO\\n\",\n\t\t\tbus->id);\n\t\tdevice_del(&bus->dev);\n\t\treturn PTR_ERR(gpiod);\n\t} else\tif (gpiod) {\n\t\tbus->reset_gpiod = gpiod;\n\n\t\tgpiod_set_value_cansleep(gpiod, 1);\n\t\tudelay(bus->reset_delay_us);\n\t\tgpiod_set_value_cansleep(gpiod, 0);\n\t}\n\n\tif (bus->reset)\n\t\tbus->reset(bus);\n\n\tfor (i = 0; i < PHY_MAX_ADDR; i++) {\n\t\tif ((bus->phy_mask & (1 << i)) == 0) {\n\t\t\tstruct phy_device *phydev;\n\n\t\t\tphydev = mdiobus_scan(bus, i);\n\t\t\tif (IS_ERR(phydev) && (PTR_ERR(phydev) != -ENODEV)) {\n\t\t\t\terr = PTR_ERR(phydev);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\tmdiobus_setup_mdiodev_from_board_info(bus, mdiobus_create_device);\n\n\tbus->state = MDIOBUS_REGISTERED;\n\tpr_info(\"%s: probed\\n\", bus->name);\n\treturn 0;\n\nerror:\n\twhile (--i >= 0) {\n\t\tmdiodev = bus->mdio_map[i];\n\t\tif (!mdiodev)\n\t\t\tcontinue;\n\n\t\tmdiodev->device_remove(mdiodev);\n\t\tmdiodev->device_free(mdiodev);\n\t}\n\n\t/* Put PHYs in RESET to save power */\n\tif (bus->reset_gpiod)\n\t\tgpiod_set_value_cansleep(bus->reset_gpiod, 1);\n\n\tdevice_del(&bus->dev);\n\treturn err;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143243,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "int __mdiobus_register(struct mii_bus *bus, struct module *owner)\n{\n\tstruct mdio_device *mdiodev;\n\tint i, err;\n\tstruct gpio_desc *gpiod;\n\n\tif (NULL == bus || NULL == bus->name ||\n\t    NULL == bus->read || NULL == bus->write)\n\t\treturn -EINVAL;\n\n\tBUG_ON(bus->state != MDIOBUS_ALLOCATED &&\n\t       bus->state != MDIOBUS_UNREGISTERED);\n\n\tbus->owner = owner;\n\tbus->dev.parent = bus->parent;\n\tbus->dev.class = &mdio_bus_class;\n\tbus->dev.groups = NULL;\n\tdev_set_name(&bus->dev, \"%s\", bus->id);\n\n \terr = device_register(&bus->dev);\n \tif (err) {\n \t\tpr_err(\"mii_bus %s failed to register\\n\", bus->id);\n \t\treturn -EINVAL;\n \t}\n \n\tmutex_init(&bus->mdio_lock);\n\n\t/* de-assert bus level PHY GPIO reset */\n\tgpiod = devm_gpiod_get_optional(&bus->dev, \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(gpiod)) {\n\t\tdev_err(&bus->dev, \"mii_bus %s couldn't get reset GPIO\\n\",\n\t\t\tbus->id);\n\t\tdevice_del(&bus->dev);\n\t\treturn PTR_ERR(gpiod);\n\t} else\tif (gpiod) {\n\t\tbus->reset_gpiod = gpiod;\n\n\t\tgpiod_set_value_cansleep(gpiod, 1);\n\t\tudelay(bus->reset_delay_us);\n\t\tgpiod_set_value_cansleep(gpiod, 0);\n\t}\n\n\tif (bus->reset)\n\t\tbus->reset(bus);\n\n\tfor (i = 0; i < PHY_MAX_ADDR; i++) {\n\t\tif ((bus->phy_mask & (1 << i)) == 0) {\n\t\t\tstruct phy_device *phydev;\n\n\t\t\tphydev = mdiobus_scan(bus, i);\n\t\t\tif (IS_ERR(phydev) && (PTR_ERR(phydev) != -ENODEV)) {\n\t\t\t\terr = PTR_ERR(phydev);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\tmdiobus_setup_mdiodev_from_board_info(bus, mdiobus_create_device);\n\n\tbus->state = MDIOBUS_REGISTERED;\n\tpr_info(\"%s: probed\\n\", bus->name);\n\treturn 0;\n\nerror:\n\twhile (--i >= 0) {\n\t\tmdiodev = bus->mdio_map[i];\n\t\tif (!mdiodev)\n\t\t\tcontinue;\n\n\t\tmdiodev->device_remove(mdiodev);\n\t\tmdiodev->device_free(mdiodev);\n\t}\n\n\t/* Put PHYs in RESET to save power */\n\tif (bus->reset_gpiod)\n\t\tgpiod_set_value_cansleep(bus->reset_gpiod, 1);\n\n\tdevice_del(&bus->dev);\n\treturn err;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143244,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "updateDevice(const struct header * headers, time_t t)\n{\n\tstruct device ** pp = &devlist;\n\tstruct device * p = *pp;\t/* = devlist; */\n\twhile(p)\n\t{\n\t\tif(  p->headers[HEADER_NT].l == headers[HEADER_NT].l\n\t\t  && (0==memcmp(p->headers[HEADER_NT].p, headers[HEADER_NT].p, headers[HEADER_NT].l))\n\t\t  && p->headers[HEADER_USN].l == headers[HEADER_USN].l\n\t\t  && (0==memcmp(p->headers[HEADER_USN].p, headers[HEADER_USN].p, headers[HEADER_USN].l)) )\n\t\t{\n\t\t\t/*printf(\"found! %d\\n\", (int)(t - p->t));*/\n\t\t\tsyslog(LOG_DEBUG, \"device updated : %.*s\", headers[HEADER_USN].l, headers[HEADER_USN].p);\n\t\t\tp->t = t;\n\t\t\t/* update Location ! */\n\t\t\tif(headers[HEADER_LOCATION].l > p->headers[HEADER_LOCATION].l)\n\t\t\t{\n\t\t\t\tstruct device * tmp;\n\t\t\t\ttmp = realloc(p, sizeof(struct device)\n\t\t\t\t    + headers[0].l+headers[1].l+headers[2].l);\n \t\t\t\tif(!tmp)\t/* allocation error */\n \t\t\t\t{\n \t\t\t\t\tsyslog(LOG_ERR, \"updateDevice() : memory allocation error\");\n \t\t\t\t\tfree(p);\n \t\t\t\t\treturn 0;\n \t\t\t\t}\n\t\t\t\tp = tmp;\n\t\t\t\t*pp = p;\n\t\t\t}\n\t\t\tmemcpy(p->data + p->headers[0].l + p->headers[1].l,\n\t\t\t       headers[2].p, headers[2].l);\n\t\t\t/* TODO : check p->headers[HEADER_LOCATION].l */\n\t\t\treturn 0;\n\t\t}\n\t\tpp = &p->next;\n\t\tp = *pp;\t/* p = p->next; */\n\t}\n\tsyslog(LOG_INFO, \"new device discovered : %.*s\",\n\t       headers[HEADER_USN].l, headers[HEADER_USN].p);\n\t/* add */\n\t{\n\t\tchar * pc;\n\t\tint i;\n\t\tp = malloc(  sizeof(struct device)\n\t\t           + headers[0].l+headers[1].l+headers[2].l );\n\t\tif(!p) {\n\t\t\tsyslog(LOG_ERR, \"updateDevice(): cannot allocate memory\");\n\t\t\treturn -1;\n\t\t}\n\t\tp->next = devlist;\n\t\tp->t = t;\n\t\tpc = p->data;\n\t\tfor(i = 0; i < 3; i++)\n\t\t{\n\t\t\tp->headers[i].p = pc;\n\t\t\tp->headers[i].l = headers[i].l;\n\t\t\tmemcpy(pc, headers[i].p, headers[i].l);\n\t\t\tpc += headers[i].l;\n\t\t}\n\t\tdevlist = p;\n\t\tsendNotifications(NOTIF_NEW, p, NULL);\n\t}\n\treturn 1;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143253,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "updateDevice(const struct header * headers, time_t t)\n{\n\tstruct device ** pp = &devlist;\n\tstruct device * p = *pp;\t/* = devlist; */\n\twhile(p)\n\t{\n\t\tif(  p->headers[HEADER_NT].l == headers[HEADER_NT].l\n\t\t  && (0==memcmp(p->headers[HEADER_NT].p, headers[HEADER_NT].p, headers[HEADER_NT].l))\n\t\t  && p->headers[HEADER_USN].l == headers[HEADER_USN].l\n\t\t  && (0==memcmp(p->headers[HEADER_USN].p, headers[HEADER_USN].p, headers[HEADER_USN].l)) )\n\t\t{\n\t\t\t/*printf(\"found! %d\\n\", (int)(t - p->t));*/\n\t\t\tsyslog(LOG_DEBUG, \"device updated : %.*s\", headers[HEADER_USN].l, headers[HEADER_USN].p);\n\t\t\tp->t = t;\n\t\t\t/* update Location ! */\n\t\t\tif(headers[HEADER_LOCATION].l > p->headers[HEADER_LOCATION].l)\n\t\t\t{\n\t\t\t\tstruct device * tmp;\n\t\t\t\ttmp = realloc(p, sizeof(struct device)\n\t\t\t\t    + headers[0].l+headers[1].l+headers[2].l);\n \t\t\t\tif(!tmp)\t/* allocation error */\n \t\t\t\t{\n \t\t\t\t\tsyslog(LOG_ERR, \"updateDevice() : memory allocation error\");\n\t\t\t\t\t*pp = p->next;\t/* remove \"p\" from the list */\n \t\t\t\t\tfree(p);\n \t\t\t\t\treturn 0;\n \t\t\t\t}\n\t\t\t\tp = tmp;\n\t\t\t\t*pp = p;\n\t\t\t}\n\t\t\tmemcpy(p->data + p->headers[0].l + p->headers[1].l,\n\t\t\t       headers[2].p, headers[2].l);\n\t\t\t/* TODO : check p->headers[HEADER_LOCATION].l */\n\t\t\treturn 0;\n\t\t}\n\t\tpp = &p->next;\n\t\tp = *pp;\t/* p = p->next; */\n\t}\n\tsyslog(LOG_INFO, \"new device discovered : %.*s\",\n\t       headers[HEADER_USN].l, headers[HEADER_USN].p);\n\t/* add */\n\t{\n\t\tchar * pc;\n\t\tint i;\n\t\tp = malloc(  sizeof(struct device)\n\t\t           + headers[0].l+headers[1].l+headers[2].l );\n\t\tif(!p) {\n\t\t\tsyslog(LOG_ERR, \"updateDevice(): cannot allocate memory\");\n\t\t\treturn -1;\n\t\t}\n\t\tp->next = devlist;\n\t\tp->t = t;\n\t\tpc = p->data;\n\t\tfor(i = 0; i < 3; i++)\n\t\t{\n\t\t\tp->headers[i].p = pc;\n\t\t\tp->headers[i].l = headers[i].l;\n\t\t\tmemcpy(pc, headers[i].p, headers[i].l);\n\t\t\tpc += headers[i].l;\n\t\t}\n\t\tdevlist = p;\n\t\tsendNotifications(NOTIF_NEW, p, NULL);\n\t}\n\treturn 1;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143254,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int try_smi_init(struct smi_info *new_smi)\n{\n\tint rv = 0;\n\tint i;\n\tchar *init_name = NULL;\n\n\tpr_info(\"Trying %s-specified %s state machine at %s address 0x%lx, slave address 0x%x, irq %d\\n\",\n\t\tipmi_addr_src_to_str(new_smi->io.addr_source),\n\t\tsi_to_str[new_smi->io.si_type],\n\t\taddr_space_to_str[new_smi->io.addr_type],\n\t\tnew_smi->io.addr_data,\n\t\tnew_smi->io.slave_addr, new_smi->io.irq);\n\n\tswitch (new_smi->io.si_type) {\n\tcase SI_KCS:\n\t\tnew_smi->handlers = &kcs_smi_handlers;\n\t\tbreak;\n\n\tcase SI_SMIC:\n\t\tnew_smi->handlers = &smic_smi_handlers;\n\t\tbreak;\n\n\tcase SI_BT:\n\t\tnew_smi->handlers = &bt_smi_handlers;\n\t\tbreak;\n\n\tdefault:\n\t\t/* No support for anything else yet. */\n\t\trv = -EIO;\n\t\tgoto out_err;\n\t}\n\n\tnew_smi->si_num = smi_num;\n\n\t/* Do this early so it's available for logs. */\n\tif (!new_smi->io.dev) {\n\t\tinit_name = kasprintf(GFP_KERNEL, \"ipmi_si.%d\",\n\t\t\t\t      new_smi->si_num);\n\n\t\t/*\n\t\t * If we don't already have a device from something\n\t\t * else (like PCI), then register a new one.\n\t\t */\n\t\tnew_smi->pdev = platform_device_alloc(\"ipmi_si\",\n\t\t\t\t\t\t      new_smi->si_num);\n\t\tif (!new_smi->pdev) {\n\t\t\tpr_err(\"Unable to allocate platform device\\n\");\n\t\t\trv = -ENOMEM;\n\t\t\tgoto out_err;\n\t\t}\n\t\tnew_smi->io.dev = &new_smi->pdev->dev;\n\t\tnew_smi->io.dev->driver = &ipmi_platform_driver.driver;\n\t\t/* Nulled by device_add() */\n\t\tnew_smi->io.dev->init_name = init_name;\n\t}\n\n\t/* Allocate the state machine's data and initialize it. */\n\tnew_smi->si_sm = kmalloc(new_smi->handlers->size(), GFP_KERNEL);\n\tif (!new_smi->si_sm) {\n\t\trv = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\tnew_smi->io.io_size = new_smi->handlers->init_data(new_smi->si_sm,\n\t\t\t\t\t\t\t   &new_smi->io);\n\n\t/* Now that we know the I/O size, we can set up the I/O. */\n\trv = new_smi->io.io_setup(&new_smi->io);\n\tif (rv) {\n\t\tdev_err(new_smi->io.dev, \"Could not set up I/O space\\n\");\n\t\tgoto out_err;\n\t}\n\n\t/* Do low-level detection first. */\n\tif (new_smi->handlers->detect(new_smi->si_sm)) {\n\t\tif (new_smi->io.addr_source)\n\t\t\tdev_err(new_smi->io.dev,\n\t\t\t\t\"Interface detection failed\\n\");\n\t\trv = -ENODEV;\n\t\tgoto out_err;\n\t}\n\n\t/*\n\t * Attempt a get device id command.  If it fails, we probably\n\t * don't have a BMC here.\n\t */\n\trv = try_get_dev_id(new_smi);\n\tif (rv) {\n\t\tif (new_smi->io.addr_source)\n\t\t\tdev_err(new_smi->io.dev,\n\t\t\t       \"There appears to be no BMC at this location\\n\");\n\t\tgoto out_err;\n\t}\n\n\tsetup_oem_data_handler(new_smi);\n\tsetup_xaction_handlers(new_smi);\n\tcheck_for_broken_irqs(new_smi);\n\n\tnew_smi->waiting_msg = NULL;\n\tnew_smi->curr_msg = NULL;\n\tatomic_set(&new_smi->req_events, 0);\n\tnew_smi->run_to_completion = false;\n\tfor (i = 0; i < SI_NUM_STATS; i++)\n\t\tatomic_set(&new_smi->stats[i], 0);\n\n\tnew_smi->interrupt_disabled = true;\n\tatomic_set(&new_smi->need_watch, 0);\n\n\trv = try_enable_event_buffer(new_smi);\n\tif (rv == 0)\n\t\tnew_smi->has_event_buffer = true;\n\n\t/*\n\t * Start clearing the flags before we enable interrupts or the\n\t * timer to avoid racing with the timer.\n\t */\n\tstart_clear_flags(new_smi);\n\n\t/*\n\t * IRQ is defined to be set when non-zero.  req_events will\n\t * cause a global flags check that will enable interrupts.\n\t */\n\tif (new_smi->io.irq) {\n\t\tnew_smi->interrupt_disabled = false;\n\t\tatomic_set(&new_smi->req_events, 1);\n\t}\n\n\tif (new_smi->pdev && !new_smi->pdev_registered) {\n\t\trv = platform_device_add(new_smi->pdev);\n\t\tif (rv) {\n\t\t\tdev_err(new_smi->io.dev,\n\t\t\t\t\"Unable to register system interface device: %d\\n\",\n\t\t\t\trv);\n\t\t\tgoto out_err;\n\t\t}\n\t\tnew_smi->pdev_registered = true;\n\t}\n\n\tdev_set_drvdata(new_smi->io.dev, new_smi);\n\trv = device_add_group(new_smi->io.dev, &ipmi_si_dev_attr_group);\n\tif (rv) {\n\t\tdev_err(new_smi->io.dev,\n\t\t\t\"Unable to add device attributes: error %d\\n\",\n\t\t\trv);\n\t\tgoto out_err;\n\t}\n\tnew_smi->dev_group_added = true;\n\n\trv = ipmi_register_smi(&handlers,\n\t\t\t       new_smi,\n\t\t\t       new_smi->io.dev,\n\t\t\t       new_smi->io.slave_addr);\n\tif (rv) {\n\t\tdev_err(new_smi->io.dev,\n\t\t\t\"Unable to register device: error %d\\n\",\n\t\t\trv);\n\t\tgoto out_err;\n\t}\n\n\t/* Don't increment till we know we have succeeded. */\n\tsmi_num++;\n\n\tdev_info(new_smi->io.dev, \"IPMI %s interface initialized\\n\",\n\t\t si_to_str[new_smi->io.si_type]);\n\n \tWARN_ON(new_smi->io.dev->init_name != NULL);\n \n  out_err:\n \tkfree(init_name);\n \treturn rv;\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143259,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int try_smi_init(struct smi_info *new_smi)\n{\n\tint rv = 0;\n\tint i;\n\tchar *init_name = NULL;\n\n\tpr_info(\"Trying %s-specified %s state machine at %s address 0x%lx, slave address 0x%x, irq %d\\n\",\n\t\tipmi_addr_src_to_str(new_smi->io.addr_source),\n\t\tsi_to_str[new_smi->io.si_type],\n\t\taddr_space_to_str[new_smi->io.addr_type],\n\t\tnew_smi->io.addr_data,\n\t\tnew_smi->io.slave_addr, new_smi->io.irq);\n\n\tswitch (new_smi->io.si_type) {\n\tcase SI_KCS:\n\t\tnew_smi->handlers = &kcs_smi_handlers;\n\t\tbreak;\n\n\tcase SI_SMIC:\n\t\tnew_smi->handlers = &smic_smi_handlers;\n\t\tbreak;\n\n\tcase SI_BT:\n\t\tnew_smi->handlers = &bt_smi_handlers;\n\t\tbreak;\n\n\tdefault:\n\t\t/* No support for anything else yet. */\n\t\trv = -EIO;\n\t\tgoto out_err;\n\t}\n\n\tnew_smi->si_num = smi_num;\n\n\t/* Do this early so it's available for logs. */\n\tif (!new_smi->io.dev) {\n\t\tinit_name = kasprintf(GFP_KERNEL, \"ipmi_si.%d\",\n\t\t\t\t      new_smi->si_num);\n\n\t\t/*\n\t\t * If we don't already have a device from something\n\t\t * else (like PCI), then register a new one.\n\t\t */\n\t\tnew_smi->pdev = platform_device_alloc(\"ipmi_si\",\n\t\t\t\t\t\t      new_smi->si_num);\n\t\tif (!new_smi->pdev) {\n\t\t\tpr_err(\"Unable to allocate platform device\\n\");\n\t\t\trv = -ENOMEM;\n\t\t\tgoto out_err;\n\t\t}\n\t\tnew_smi->io.dev = &new_smi->pdev->dev;\n\t\tnew_smi->io.dev->driver = &ipmi_platform_driver.driver;\n\t\t/* Nulled by device_add() */\n\t\tnew_smi->io.dev->init_name = init_name;\n\t}\n\n\t/* Allocate the state machine's data and initialize it. */\n\tnew_smi->si_sm = kmalloc(new_smi->handlers->size(), GFP_KERNEL);\n\tif (!new_smi->si_sm) {\n\t\trv = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\tnew_smi->io.io_size = new_smi->handlers->init_data(new_smi->si_sm,\n\t\t\t\t\t\t\t   &new_smi->io);\n\n\t/* Now that we know the I/O size, we can set up the I/O. */\n\trv = new_smi->io.io_setup(&new_smi->io);\n\tif (rv) {\n\t\tdev_err(new_smi->io.dev, \"Could not set up I/O space\\n\");\n\t\tgoto out_err;\n\t}\n\n\t/* Do low-level detection first. */\n\tif (new_smi->handlers->detect(new_smi->si_sm)) {\n\t\tif (new_smi->io.addr_source)\n\t\t\tdev_err(new_smi->io.dev,\n\t\t\t\t\"Interface detection failed\\n\");\n\t\trv = -ENODEV;\n\t\tgoto out_err;\n\t}\n\n\t/*\n\t * Attempt a get device id command.  If it fails, we probably\n\t * don't have a BMC here.\n\t */\n\trv = try_get_dev_id(new_smi);\n\tif (rv) {\n\t\tif (new_smi->io.addr_source)\n\t\t\tdev_err(new_smi->io.dev,\n\t\t\t       \"There appears to be no BMC at this location\\n\");\n\t\tgoto out_err;\n\t}\n\n\tsetup_oem_data_handler(new_smi);\n\tsetup_xaction_handlers(new_smi);\n\tcheck_for_broken_irqs(new_smi);\n\n\tnew_smi->waiting_msg = NULL;\n\tnew_smi->curr_msg = NULL;\n\tatomic_set(&new_smi->req_events, 0);\n\tnew_smi->run_to_completion = false;\n\tfor (i = 0; i < SI_NUM_STATS; i++)\n\t\tatomic_set(&new_smi->stats[i], 0);\n\n\tnew_smi->interrupt_disabled = true;\n\tatomic_set(&new_smi->need_watch, 0);\n\n\trv = try_enable_event_buffer(new_smi);\n\tif (rv == 0)\n\t\tnew_smi->has_event_buffer = true;\n\n\t/*\n\t * Start clearing the flags before we enable interrupts or the\n\t * timer to avoid racing with the timer.\n\t */\n\tstart_clear_flags(new_smi);\n\n\t/*\n\t * IRQ is defined to be set when non-zero.  req_events will\n\t * cause a global flags check that will enable interrupts.\n\t */\n\tif (new_smi->io.irq) {\n\t\tnew_smi->interrupt_disabled = false;\n\t\tatomic_set(&new_smi->req_events, 1);\n\t}\n\n\tif (new_smi->pdev && !new_smi->pdev_registered) {\n\t\trv = platform_device_add(new_smi->pdev);\n\t\tif (rv) {\n\t\t\tdev_err(new_smi->io.dev,\n\t\t\t\t\"Unable to register system interface device: %d\\n\",\n\t\t\t\trv);\n\t\t\tgoto out_err;\n\t\t}\n\t\tnew_smi->pdev_registered = true;\n\t}\n\n\tdev_set_drvdata(new_smi->io.dev, new_smi);\n\trv = device_add_group(new_smi->io.dev, &ipmi_si_dev_attr_group);\n\tif (rv) {\n\t\tdev_err(new_smi->io.dev,\n\t\t\t\"Unable to add device attributes: error %d\\n\",\n\t\t\trv);\n\t\tgoto out_err;\n\t}\n\tnew_smi->dev_group_added = true;\n\n\trv = ipmi_register_smi(&handlers,\n\t\t\t       new_smi,\n\t\t\t       new_smi->io.dev,\n\t\t\t       new_smi->io.slave_addr);\n\tif (rv) {\n\t\tdev_err(new_smi->io.dev,\n\t\t\t\"Unable to register device: error %d\\n\",\n\t\t\trv);\n\t\tgoto out_err;\n\t}\n\n\t/* Don't increment till we know we have succeeded. */\n\tsmi_num++;\n\n\tdev_info(new_smi->io.dev, \"IPMI %s interface initialized\\n\",\n\t\t si_to_str[new_smi->io.si_type]);\n\n \tWARN_ON(new_smi->io.dev->init_name != NULL);\n \n  out_err:\n\tif (rv && new_smi->io.io_cleanup) {\n\t\tnew_smi->io.io_cleanup(&new_smi->io);\n\t\tnew_smi->io.io_cleanup = NULL;\n\t}\n\n \tkfree(init_name);\n \treturn rv;\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143260,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "int ipmi_si_mem_setup(struct si_sm_io *io)\n{\n\tunsigned long addr = io->addr_data;\n\tint           mapsize, idx;\n\n \tif (!addr)\n \t\treturn -ENODEV;\n \n\tio->io_cleanup = mem_cleanup;\n \t/*\n \t * Figure out the actual readb/readw/readl/etc routine to use based\n \t * upon the register size.\n\t */\n\tswitch (io->regsize) {\n\tcase 1:\n\t\tio->inputb = intf_mem_inb;\n\t\tio->outputb = intf_mem_outb;\n\t\tbreak;\n\tcase 2:\n\t\tio->inputb = intf_mem_inw;\n\t\tio->outputb = intf_mem_outw;\n\t\tbreak;\n\tcase 4:\n\t\tio->inputb = intf_mem_inl;\n\t\tio->outputb = intf_mem_outl;\n\t\tbreak;\n#ifdef readq\n\tcase 8:\n\t\tio->inputb = mem_inq;\n\t\tio->outputb = mem_outq;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tdev_warn(io->dev, \"Invalid register size: %d\\n\",\n\t\t\t io->regsize);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Some BIOSes reserve disjoint memory regions in their ACPI\n\t * tables.  This causes problems when trying to request the\n\t * entire region.  Therefore we must request each register\n\t * separately.\n\t */\n\tfor (idx = 0; idx < io->io_size; idx++) {\n\t\tif (request_mem_region(addr + idx * io->regspacing,\n\t\t\t\t       io->regsize, DEVICE_NAME) == NULL) {\n\t\t\t/* Undo allocations */\n\t\t\tmem_region_cleanup(io, idx);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\t/*\n\t * Calculate the total amount of memory to claim.  This is an\n\t * unusual looking calculation, but it avoids claiming any\n\t * more memory than it has to.  It will claim everything\n\t * between the first address to the end of the last full\n\t * register.\n\t */\n\tmapsize = ((io->io_size * io->regspacing)\n\t\t   - (io->regspacing - io->regsize));\n\tio->addr = ioremap(addr, mapsize);\n\tif (io->addr == NULL) {\n \t\tmem_region_cleanup(io, io->io_size);\n \t\treturn -EIO;\n \t}\n \treturn 0;\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143261,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "int ipmi_si_mem_setup(struct si_sm_io *io)\n{\n\tunsigned long addr = io->addr_data;\n\tint           mapsize, idx;\n\n \tif (!addr)\n \t\treturn -ENODEV;\n \n \t/*\n \t * Figure out the actual readb/readw/readl/etc routine to use based\n \t * upon the register size.\n\t */\n\tswitch (io->regsize) {\n\tcase 1:\n\t\tio->inputb = intf_mem_inb;\n\t\tio->outputb = intf_mem_outb;\n\t\tbreak;\n\tcase 2:\n\t\tio->inputb = intf_mem_inw;\n\t\tio->outputb = intf_mem_outw;\n\t\tbreak;\n\tcase 4:\n\t\tio->inputb = intf_mem_inl;\n\t\tio->outputb = intf_mem_outl;\n\t\tbreak;\n#ifdef readq\n\tcase 8:\n\t\tio->inputb = mem_inq;\n\t\tio->outputb = mem_outq;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tdev_warn(io->dev, \"Invalid register size: %d\\n\",\n\t\t\t io->regsize);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Some BIOSes reserve disjoint memory regions in their ACPI\n\t * tables.  This causes problems when trying to request the\n\t * entire region.  Therefore we must request each register\n\t * separately.\n\t */\n\tfor (idx = 0; idx < io->io_size; idx++) {\n\t\tif (request_mem_region(addr + idx * io->regspacing,\n\t\t\t\t       io->regsize, DEVICE_NAME) == NULL) {\n\t\t\t/* Undo allocations */\n\t\t\tmem_region_cleanup(io, idx);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\t/*\n\t * Calculate the total amount of memory to claim.  This is an\n\t * unusual looking calculation, but it avoids claiming any\n\t * more memory than it has to.  It will claim everything\n\t * between the first address to the end of the last full\n\t * register.\n\t */\n\tmapsize = ((io->io_size * io->regspacing)\n\t\t   - (io->regspacing - io->regsize));\n\tio->addr = ioremap(addr, mapsize);\n\tif (io->addr == NULL) {\n \t\tmem_region_cleanup(io, io->io_size);\n \t\treturn -EIO;\n \t}\n\n\tio->io_cleanup = mem_cleanup;\n\n \treturn 0;\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143262,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "int ipmi_si_port_setup(struct si_sm_io *io)\n{\n\tunsigned int addr = io->addr_data;\n\tint          idx;\n\n \tif (!addr)\n \t\treturn -ENODEV;\n \n\tio->io_cleanup = port_cleanup;\n \t/*\n \t * Figure out the actual inb/inw/inl/etc routine to use based\n \t * upon the register size.\n\t */\n\tswitch (io->regsize) {\n\tcase 1:\n\t\tio->inputb = port_inb;\n\t\tio->outputb = port_outb;\n\t\tbreak;\n\tcase 2:\n\t\tio->inputb = port_inw;\n\t\tio->outputb = port_outw;\n\t\tbreak;\n\tcase 4:\n\t\tio->inputb = port_inl;\n\t\tio->outputb = port_outl;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(io->dev, \"Invalid register size: %d\\n\",\n\t\t\t io->regsize);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Some BIOSes reserve disjoint I/O regions in their ACPI\n\t * tables.  This causes problems when trying to register the\n\t * entire I/O region.  Therefore we must register each I/O\n\t * port separately.\n\t */\n\tfor (idx = 0; idx < io->io_size; idx++) {\n\t\tif (request_region(addr + idx * io->regspacing,\n\t\t\t\t   io->regsize, DEVICE_NAME) == NULL) {\n\t\t\t/* Undo allocations */\n\t\t\twhile (idx--)\n\t\t\t\trelease_region(addr + idx * io->regspacing,\n\t\t\t\t\t       io->regsize);\n \t\t\treturn -EIO;\n \t\t}\n \t}\n \treturn 0;\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143263,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "int ipmi_si_port_setup(struct si_sm_io *io)\n{\n\tunsigned int addr = io->addr_data;\n\tint          idx;\n\n \tif (!addr)\n \t\treturn -ENODEV;\n \n \t/*\n \t * Figure out the actual inb/inw/inl/etc routine to use based\n \t * upon the register size.\n\t */\n\tswitch (io->regsize) {\n\tcase 1:\n\t\tio->inputb = port_inb;\n\t\tio->outputb = port_outb;\n\t\tbreak;\n\tcase 2:\n\t\tio->inputb = port_inw;\n\t\tio->outputb = port_outw;\n\t\tbreak;\n\tcase 4:\n\t\tio->inputb = port_inl;\n\t\tio->outputb = port_outl;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(io->dev, \"Invalid register size: %d\\n\",\n\t\t\t io->regsize);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Some BIOSes reserve disjoint I/O regions in their ACPI\n\t * tables.  This causes problems when trying to register the\n\t * entire I/O region.  Therefore we must register each I/O\n\t * port separately.\n\t */\n\tfor (idx = 0; idx < io->io_size; idx++) {\n\t\tif (request_region(addr + idx * io->regspacing,\n\t\t\t\t   io->regsize, DEVICE_NAME) == NULL) {\n\t\t\t/* Undo allocations */\n\t\t\twhile (idx--)\n\t\t\t\trelease_region(addr + idx * io->regspacing,\n\t\t\t\t\t       io->regsize);\n \t\t\treturn -EIO;\n \t\t}\n \t}\n\n\tio->io_cleanup = port_cleanup;\n\n \treturn 0;\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143264,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "int blk_init_allocated_queue(struct request_queue *q)\n{\n\tWARN_ON_ONCE(q->mq_ops);\n\n\tq->fq = blk_alloc_flush_queue(q, NUMA_NO_NODE, q->cmd_size);\n\tif (!q->fq)\n\t\treturn -ENOMEM;\n\n\tif (q->init_rq_fn && q->init_rq_fn(q, q->fq->flush_rq, GFP_KERNEL))\n\t\tgoto out_free_flush_queue;\n\n\tif (blk_init_rl(&q->root_rl, q, GFP_KERNEL))\n\t\tgoto out_exit_flush_rq;\n\n\tINIT_WORK(&q->timeout_work, blk_timeout_work);\n\tq->queue_flags\t\t|= QUEUE_FLAG_DEFAULT;\n\n\t/*\n\t * This also sets hw/phys segments, boundary and size\n\t */\n\tblk_queue_make_request(q, blk_queue_bio);\n\n\tq->sg_reserved_size = INT_MAX;\n\n\tif (elevator_init(q))\n\t\tgoto out_exit_flush_rq;\n\treturn 0;\n\nout_exit_flush_rq:\n\tif (q->exit_rq_fn)\n \t\tq->exit_rq_fn(q, q->fq->flush_rq);\n out_free_flush_queue:\n \tblk_free_flush_queue(q->fq);\n \treturn -ENOMEM;\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143307,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "int blk_init_allocated_queue(struct request_queue *q)\n{\n\tWARN_ON_ONCE(q->mq_ops);\n\n\tq->fq = blk_alloc_flush_queue(q, NUMA_NO_NODE, q->cmd_size);\n\tif (!q->fq)\n\t\treturn -ENOMEM;\n\n\tif (q->init_rq_fn && q->init_rq_fn(q, q->fq->flush_rq, GFP_KERNEL))\n\t\tgoto out_free_flush_queue;\n\n\tif (blk_init_rl(&q->root_rl, q, GFP_KERNEL))\n\t\tgoto out_exit_flush_rq;\n\n\tINIT_WORK(&q->timeout_work, blk_timeout_work);\n\tq->queue_flags\t\t|= QUEUE_FLAG_DEFAULT;\n\n\t/*\n\t * This also sets hw/phys segments, boundary and size\n\t */\n\tblk_queue_make_request(q, blk_queue_bio);\n\n\tq->sg_reserved_size = INT_MAX;\n\n\tif (elevator_init(q))\n\t\tgoto out_exit_flush_rq;\n\treturn 0;\n\nout_exit_flush_rq:\n\tif (q->exit_rq_fn)\n \t\tq->exit_rq_fn(q, q->fq->flush_rq);\n out_free_flush_queue:\n \tblk_free_flush_queue(q->fq);\n\tq->fq = NULL;\n \treturn -ENOMEM;\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143308,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": " static void smp_task_done(struct sas_task *task)\n {\n\tif (!del_timer(&task->slow_task->timer))\n\t\treturn;\n \tcomplete(&task->slow_task->completion);\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143323,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": " static void smp_task_done(struct sas_task *task)\n {\n\tdel_timer(&task->slow_task->timer);\n \tcomplete(&task->slow_task->completion);\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143324,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static void smp_task_timedout(struct timer_list *t)\n{\n\tstruct sas_task_slow *slow = from_timer(slow, t, timer);\n\tstruct sas_task *task = slow->task;\n \tunsigned long flags;\n \n \tspin_lock_irqsave(&task->task_state_lock, flags);\n\tif (!(task->task_state_flags & SAS_TASK_STATE_DONE))\n \t\ttask->task_state_flags |= SAS_TASK_STATE_ABORTED;\n \tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\tcomplete(&task->slow_task->completion);\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143325,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static void smp_task_timedout(struct timer_list *t)\n{\n\tstruct sas_task_slow *slow = from_timer(slow, t, timer);\n\tstruct sas_task *task = slow->task;\n \tunsigned long flags;\n \n \tspin_lock_irqsave(&task->task_state_lock, flags);\n\tif (!(task->task_state_flags & SAS_TASK_STATE_DONE)) {\n \t\ttask->task_state_flags |= SAS_TASK_STATE_ABORTED;\n\t\tcomplete(&task->slow_task->completion);\n\t}\n \tspin_unlock_irqrestore(&task->task_state_lock, flags);\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143326,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": " void usb_serial_console_disconnect(struct usb_serial *serial)\n {\n\tif (serial->port[0] == usbcons_info.port) {\n \t\tusb_serial_console_exit();\n \t\tusb_serial_put(serial);\n \t}\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143441,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": " void usb_serial_console_disconnect(struct usb_serial *serial)\n {\n\tif (serial->port[0] && serial->port[0] == usbcons_info.port) {\n \t\tusb_serial_console_exit();\n \t\tusb_serial_put(serial);\n \t}\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143442,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "void WebURLLoaderImpl::Context::OnReceivedResponse(\n    const ResourceResponseInfo& info) {\n  if (!client_)\n    return;\n\n  WebURLResponse response;\n  response.initialize();\n  PopulateURLResponse(request_.url(), info, &response);\n\n  bool show_raw_listing = (GURL(request_.url()).query() == \"raw\");\n\n  if (info.mime_type == \"text/vnd.chromium.ftp-dir\") {\n    if (show_raw_listing) {\n      response.setMIMEType(\"text/plain\");\n    } else {\n      response.setMIMEType(\"text/html\");\n     }\n   }\n \n   client_->didReceiveResponse(loader_, response);\n \n  if (!client_)\n    return;\n\n  DCHECK(!ftp_listing_delegate_.get());\n  DCHECK(!multipart_delegate_.get());\n  if (info.headers && info.mime_type == \"multipart/x-mixed-replace\") {\n    std::string content_type;\n    info.headers->EnumerateHeader(NULL, \"content-type\", &content_type);\n\n    std::string mime_type;\n    std::string charset;\n    bool had_charset = false;\n    std::string boundary;\n    net::HttpUtil::ParseContentType(content_type, &mime_type, &charset,\n                                    &had_charset, &boundary);\n    TrimString(boundary, \" \\\"\", &boundary);\n\n    if (!boundary.empty()) {\n      multipart_delegate_.reset(\n          new MultipartResponseDelegate(client_, loader_, response, boundary));\n    }\n  } else if (info.mime_type == \"text/vnd.chromium.ftp-dir\" &&\n             !show_raw_listing) {\n    ftp_listing_delegate_.reset(\n        new FtpDirectoryListingResponseDelegate(client_, loader_, response));\n  }\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143569,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "void WebURLLoaderImpl::Context::OnReceivedResponse(\n    const ResourceResponseInfo& info) {\n  if (!client_)\n    return;\n\n  WebURLResponse response;\n  response.initialize();\n  PopulateURLResponse(request_.url(), info, &response);\n\n  bool show_raw_listing = (GURL(request_.url()).query() == \"raw\");\n\n  if (info.mime_type == \"text/vnd.chromium.ftp-dir\") {\n    if (show_raw_listing) {\n      response.setMIMEType(\"text/plain\");\n    } else {\n      response.setMIMEType(\"text/html\");\n     }\n   }\n \n  scoped_refptr<Context> protect(this);\n   client_->didReceiveResponse(loader_, response);\n \n  if (!client_)\n    return;\n\n  DCHECK(!ftp_listing_delegate_.get());\n  DCHECK(!multipart_delegate_.get());\n  if (info.headers && info.mime_type == \"multipart/x-mixed-replace\") {\n    std::string content_type;\n    info.headers->EnumerateHeader(NULL, \"content-type\", &content_type);\n\n    std::string mime_type;\n    std::string charset;\n    bool had_charset = false;\n    std::string boundary;\n    net::HttpUtil::ParseContentType(content_type, &mime_type, &charset,\n                                    &had_charset, &boundary);\n    TrimString(boundary, \" \\\"\", &boundary);\n\n    if (!boundary.empty()) {\n      multipart_delegate_.reset(\n          new MultipartResponseDelegate(client_, loader_, response, boundary));\n    }\n  } else if (info.mime_type == \"text/vnd.chromium.ftp-dir\" &&\n             !show_raw_listing) {\n    ftp_listing_delegate_.reset(\n        new FtpDirectoryListingResponseDelegate(client_, loader_, response));\n  }\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143570,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "void ImageLoader::updateFromElement()\n{\n    Document* document = m_element->document();\n    if (!document->renderer())\n        return;\n\n    AtomicString attr = m_element->imageSourceURL();\n\n    if (attr == m_failedLoadURL)\n        return;\n\n    CachedResourceHandle<CachedImage> newImage = 0;\n    if (!attr.isNull() && !stripLeadingAndTrailingHTMLSpaces(attr).isEmpty()) {\n        CachedResourceRequest request(ResourceRequest(document->completeURL(sourceURI(attr))));\n        request.setInitiator(element());\n\n        String crossOriginMode = m_element->fastGetAttribute(HTMLNames::crossoriginAttr);\n        if (!crossOriginMode.isNull()) {\n            StoredCredentials allowCredentials = equalIgnoringCase(crossOriginMode, \"use-credentials\") ? AllowStoredCredentials : DoNotAllowStoredCredentials;\n            updateRequestForAccessControl(request.mutableResourceRequest(), document->securityOrigin(), allowCredentials);\n        }\n\n        if (m_loadManually) {\n            bool autoLoadOtherImages = document->cachedResourceLoader()->autoLoadImages();\n            document->cachedResourceLoader()->setAutoLoadImages(false);\n            newImage = new CachedImage(request.resourceRequest());\n            newImage->setLoading(true);\n            newImage->setOwningCachedResourceLoader(document->cachedResourceLoader());\n            document->cachedResourceLoader()->m_documentResources.set(newImage->url(), newImage.get());\n            document->cachedResourceLoader()->setAutoLoadImages(autoLoadOtherImages);\n        } else\n            newImage = document->cachedResourceLoader()->requestImage(request);\n\n        if (!newImage && !pageIsBeingDismissed(document)) {\n            m_failedLoadURL = attr;\n            m_hasPendingErrorEvent = true;\n            errorEventSender().dispatchEventSoon(this);\n        } else\n             clearFailedLoadURL();\n     } else if (!attr.isNull()) {\n        m_element->dispatchEvent(Event::create(eventNames().errorEvent, false, false));\n     }\n     \n     CachedImage* oldImage = m_image.get();\n    if (newImage != oldImage) {\n        if (m_hasPendingBeforeLoadEvent) {\n            beforeLoadEventSender().cancelEvent(this);\n            m_hasPendingBeforeLoadEvent = false;\n        }\n        if (m_hasPendingLoadEvent) {\n            loadEventSender().cancelEvent(this);\n            m_hasPendingLoadEvent = false;\n        }\n\n        if (m_hasPendingErrorEvent && newImage) {\n            errorEventSender().cancelEvent(this);\n            m_hasPendingErrorEvent = false;\n        }\n\n        m_image = newImage;\n        m_hasPendingBeforeLoadEvent = !m_element->document()->isImageDocument() && newImage;\n        m_hasPendingLoadEvent = newImage;\n        m_imageComplete = !newImage;\n\n        if (newImage) {\n            if (!m_element->document()->isImageDocument()) {\n                if (!m_element->document()->hasListenerType(Document::BEFORELOAD_LISTENER))\n                    dispatchPendingBeforeLoadEvent();\n                else\n                    beforeLoadEventSender().dispatchEventSoon(this);\n            } else\n                updateRenderer();\n\n            newImage->addClient(this);\n        }\n        if (oldImage)\n            oldImage->removeClient(this);\n    }\n\n    if (RenderImageResource* imageResource = renderImageResource())\n        imageResource->resetAnimation();\n\n    updatedHasPendingEvent();\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143573,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "void ImageLoader::updateFromElement()\n{\n    Document* document = m_element->document();\n    if (!document->renderer())\n        return;\n\n    AtomicString attr = m_element->imageSourceURL();\n\n    if (attr == m_failedLoadURL)\n        return;\n\n    CachedResourceHandle<CachedImage> newImage = 0;\n    if (!attr.isNull() && !stripLeadingAndTrailingHTMLSpaces(attr).isEmpty()) {\n        CachedResourceRequest request(ResourceRequest(document->completeURL(sourceURI(attr))));\n        request.setInitiator(element());\n\n        String crossOriginMode = m_element->fastGetAttribute(HTMLNames::crossoriginAttr);\n        if (!crossOriginMode.isNull()) {\n            StoredCredentials allowCredentials = equalIgnoringCase(crossOriginMode, \"use-credentials\") ? AllowStoredCredentials : DoNotAllowStoredCredentials;\n            updateRequestForAccessControl(request.mutableResourceRequest(), document->securityOrigin(), allowCredentials);\n        }\n\n        if (m_loadManually) {\n            bool autoLoadOtherImages = document->cachedResourceLoader()->autoLoadImages();\n            document->cachedResourceLoader()->setAutoLoadImages(false);\n            newImage = new CachedImage(request.resourceRequest());\n            newImage->setLoading(true);\n            newImage->setOwningCachedResourceLoader(document->cachedResourceLoader());\n            document->cachedResourceLoader()->m_documentResources.set(newImage->url(), newImage.get());\n            document->cachedResourceLoader()->setAutoLoadImages(autoLoadOtherImages);\n        } else\n            newImage = document->cachedResourceLoader()->requestImage(request);\n\n        if (!newImage && !pageIsBeingDismissed(document)) {\n            m_failedLoadURL = attr;\n            m_hasPendingErrorEvent = true;\n            errorEventSender().dispatchEventSoon(this);\n        } else\n             clearFailedLoadURL();\n     } else if (!attr.isNull()) {\n        m_hasPendingErrorEvent = true;\n        errorEventSender().dispatchEventSoon(this);\n     }\n     \n     CachedImage* oldImage = m_image.get();\n    if (newImage != oldImage) {\n        if (m_hasPendingBeforeLoadEvent) {\n            beforeLoadEventSender().cancelEvent(this);\n            m_hasPendingBeforeLoadEvent = false;\n        }\n        if (m_hasPendingLoadEvent) {\n            loadEventSender().cancelEvent(this);\n            m_hasPendingLoadEvent = false;\n        }\n\n        if (m_hasPendingErrorEvent && newImage) {\n            errorEventSender().cancelEvent(this);\n            m_hasPendingErrorEvent = false;\n        }\n\n        m_image = newImage;\n        m_hasPendingBeforeLoadEvent = !m_element->document()->isImageDocument() && newImage;\n        m_hasPendingLoadEvent = newImage;\n        m_imageComplete = !newImage;\n\n        if (newImage) {\n            if (!m_element->document()->isImageDocument()) {\n                if (!m_element->document()->hasListenerType(Document::BEFORELOAD_LISTENER))\n                    dispatchPendingBeforeLoadEvent();\n                else\n                    beforeLoadEventSender().dispatchEventSoon(this);\n            } else\n                updateRenderer();\n\n            newImage->addClient(this);\n        }\n        if (oldImage)\n            oldImage->removeClient(this);\n    }\n\n    if (RenderImageResource* imageResource = renderImageResource())\n        imageResource->resetAnimation();\n\n    updatedHasPendingEvent();\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143574,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": " void FrameView::updateLayoutAndStyleForPainting()\n {\n     RefPtr<FrameView> protector(this);\n \n     updateLayoutAndStyleIfNeededRecursive();\n \n     if (RenderView* view = renderView()) {\n         TRACE_EVENT_INSTANT1(TRACE_DISABLED_BY_DEFAULT(\"devtools.timeline\"), \"UpdateLayerTree\", \"frame\", m_frame.get());\n        InspectorInstrumentation::willUpdateLayerTree(m_frame.get());\n\n        view->compositor()->updateIfNeededRecursive();\n\n        if (view->compositor()->inCompositingMode() && m_frame->isLocalRoot())\n            m_frame->page()->scrollingCoordinator()->updateAfterCompositingChangeIfNeeded();\n\n        updateCompositedSelectionBoundsIfNeeded();\n\n        InspectorInstrumentation::didUpdateLayerTree(m_frame.get());\n\n        invalidateTreeIfNeededRecursive();\n    }\n\n    scrollContentsIfNeededRecursive();\n    ASSERT(lifecycle().state() == DocumentLifecycle::PaintInvalidationClean);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143597,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": " void FrameView::updateLayoutAndStyleForPainting()\n {\n     RefPtr<FrameView> protector(this);\n \n     updateLayoutAndStyleIfNeededRecursive();\n \n    updateWidgetPositionsIfNeeded();\n\n     if (RenderView* view = renderView()) {\n         TRACE_EVENT_INSTANT1(TRACE_DISABLED_BY_DEFAULT(\"devtools.timeline\"), \"UpdateLayerTree\", \"frame\", m_frame.get());\n        InspectorInstrumentation::willUpdateLayerTree(m_frame.get());\n\n        view->compositor()->updateIfNeededRecursive();\n\n        if (view->compositor()->inCompositingMode() && m_frame->isLocalRoot())\n            m_frame->page()->scrollingCoordinator()->updateAfterCompositingChangeIfNeeded();\n\n        updateCompositedSelectionBoundsIfNeeded();\n\n        InspectorInstrumentation::didUpdateLayerTree(m_frame.get());\n\n        invalidateTreeIfNeededRecursive();\n    }\n\n    scrollContentsIfNeededRecursive();\n    ASSERT(lifecycle().state() == DocumentLifecycle::PaintInvalidationClean);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143598,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "void RenderLayerScrollableArea::setScrollOffset(const IntPoint& newScrollOffset)\n{\n    if (!box().isMarquee()) {\n        if (m_scrollDimensionsDirty)\n            computeScrollDimensions();\n    }\n\n    if (scrollOffset() == toIntSize(newScrollOffset))\n        return;\n\n    setScrollOffset(toIntSize(newScrollOffset));\n\n    LocalFrame* frame = box().frame();\n    ASSERT(frame);\n\n    RefPtr<FrameView> frameView = box().frameView();\n\n    TRACE_EVENT1(TRACE_DISABLED_BY_DEFAULT(\"devtools.timeline\"), \"ScrollLayer\", \"data\", InspectorScrollLayerEvent::data(&box()));\n    InspectorInstrumentation::willScrollLayer(&box());\n\n    const RenderLayerModelObject* paintInvalidationContainer = box().containerForPaintInvalidation();\n\n    if (!frameView->isInPerformLayout()) {\n        layer()->clipper().clearClipRectsIncludingDescendants();\n         box().setPreviousPaintInvalidationRect(box().boundsRectForPaintInvalidation(paintInvalidationContainer));\n         frameView->updateAnnotatedRegions();\n        frameView->updateWidgetPositions();\n        RELEASE_ASSERT(frameView->renderView());\n         updateCompositingLayersAfterScroll();\n     }\n \n    frame->selection().setCaretRectNeedsUpdate();\n\n    FloatQuad quadForFakeMouseMoveEvent = FloatQuad(layer()->renderer()->previousPaintInvalidationRect());\n\n    quadForFakeMouseMoveEvent = paintInvalidationContainer->localToAbsoluteQuad(quadForFakeMouseMoveEvent);\n    frame->eventHandler().dispatchFakeMouseMoveEventSoonInQuad(quadForFakeMouseMoveEvent);\n\n    bool requiresPaintInvalidation = true;\n\n    if (!box().isMarquee() && box().view()->compositor()->inCompositingMode()) {\n        DisableCompositingQueryAsserts disabler;\n        bool onlyScrolledCompositedLayers = scrollsOverflow()\n            && !layer()->hasVisibleNonLayerContent()\n            && !layer()->hasNonCompositedChild()\n            && !layer()->hasBlockSelectionGapBounds()\n            && box().style()->backgroundLayers().attachment() != LocalBackgroundAttachment;\n\n        if (usesCompositedScrolling() || onlyScrolledCompositedLayers)\n            requiresPaintInvalidation = false;\n    }\n\n    if (requiresPaintInvalidation) {\n        if (box().frameView()->isInPerformLayout())\n            box().setShouldDoFullPaintInvalidation(true);\n        else\n            box().invalidatePaintUsingContainer(paintInvalidationContainer, layer()->renderer()->previousPaintInvalidationRect(), InvalidationScroll);\n    }\n\n    if (box().node())\n        box().node()->document().enqueueScrollEventForNode(box().node());\n\n    if (AXObjectCache* cache = box().document().existingAXObjectCache())\n        cache->handleScrollPositionChanged(&box());\n\n    InspectorInstrumentation::didScrollLayer(&box());\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143599,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "void RenderLayerScrollableArea::setScrollOffset(const IntPoint& newScrollOffset)\n{\n    if (!box().isMarquee()) {\n        if (m_scrollDimensionsDirty)\n            computeScrollDimensions();\n    }\n\n    if (scrollOffset() == toIntSize(newScrollOffset))\n        return;\n\n    setScrollOffset(toIntSize(newScrollOffset));\n\n    LocalFrame* frame = box().frame();\n    ASSERT(frame);\n\n    RefPtr<FrameView> frameView = box().frameView();\n\n    TRACE_EVENT1(TRACE_DISABLED_BY_DEFAULT(\"devtools.timeline\"), \"ScrollLayer\", \"data\", InspectorScrollLayerEvent::data(&box()));\n    InspectorInstrumentation::willScrollLayer(&box());\n\n    const RenderLayerModelObject* paintInvalidationContainer = box().containerForPaintInvalidation();\n\n    if (!frameView->isInPerformLayout()) {\n        layer()->clipper().clearClipRectsIncludingDescendants();\n         box().setPreviousPaintInvalidationRect(box().boundsRectForPaintInvalidation(paintInvalidationContainer));\n         frameView->updateAnnotatedRegions();\n        frameView->setNeedsUpdateWidgetPositions();\n         updateCompositingLayersAfterScroll();\n     }\n \n    frame->selection().setCaretRectNeedsUpdate();\n\n    FloatQuad quadForFakeMouseMoveEvent = FloatQuad(layer()->renderer()->previousPaintInvalidationRect());\n\n    quadForFakeMouseMoveEvent = paintInvalidationContainer->localToAbsoluteQuad(quadForFakeMouseMoveEvent);\n    frame->eventHandler().dispatchFakeMouseMoveEventSoonInQuad(quadForFakeMouseMoveEvent);\n\n    bool requiresPaintInvalidation = true;\n\n    if (!box().isMarquee() && box().view()->compositor()->inCompositingMode()) {\n        DisableCompositingQueryAsserts disabler;\n        bool onlyScrolledCompositedLayers = scrollsOverflow()\n            && !layer()->hasVisibleNonLayerContent()\n            && !layer()->hasNonCompositedChild()\n            && !layer()->hasBlockSelectionGapBounds()\n            && box().style()->backgroundLayers().attachment() != LocalBackgroundAttachment;\n\n        if (usesCompositedScrolling() || onlyScrolledCompositedLayers)\n            requiresPaintInvalidation = false;\n    }\n\n    if (requiresPaintInvalidation) {\n        if (box().frameView()->isInPerformLayout())\n            box().setShouldDoFullPaintInvalidation(true);\n        else\n            box().invalidatePaintUsingContainer(paintInvalidationContainer, layer()->renderer()->previousPaintInvalidationRect(), InvalidationScroll);\n    }\n\n    if (box().node())\n        box().node()->document().enqueueScrollEventForNode(box().node());\n\n    if (AXObjectCache* cache = box().document().existingAXObjectCache())\n        cache->handleScrollPositionChanged(&box());\n\n    InspectorInstrumentation::didScrollLayer(&box());\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143600,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "bool Document::SetFocusedElement(Element* new_focused_element,\n                                 const FocusParams& params) {\n  DCHECK(!lifecycle_.InDetach());\n\n  clear_focused_element_timer_.Stop();\n\n  if (new_focused_element && (new_focused_element->GetDocument() != this))\n    return true;\n\n  if (NodeChildRemovalTracker::IsBeingRemoved(new_focused_element))\n    return true;\n\n  if (focused_element_ == new_focused_element)\n    return true;\n\n  bool focus_change_blocked = false;\n  Element* old_focused_element = focused_element_;\n  focused_element_ = nullptr;\n\n  UpdateDistributionForFlatTreeTraversal();\n  Node* ancestor = (old_focused_element && old_focused_element->isConnected() &&\n                    new_focused_element)\n                       ? FlatTreeTraversal::CommonAncestor(*old_focused_element,\n                                                           *new_focused_element)\n                       : nullptr;\n\n  if (old_focused_element) {\n    old_focused_element->SetFocused(false, params.type);\n    old_focused_element->SetHasFocusWithinUpToAncestor(false, ancestor);\n\n    if (GetPage() && (GetPage()->GetFocusController().IsFocused())) {\n      old_focused_element->DispatchBlurEvent(new_focused_element, params.type,\n                                             params.source_capabilities);\n      if (focused_element_) {\n        focus_change_blocked = true;\n        new_focused_element = nullptr;\n      }\n\n      old_focused_element->DispatchFocusOutEvent(event_type_names::kFocusout,\n                                                 new_focused_element,\n                                                 params.source_capabilities);\n      old_focused_element->DispatchFocusOutEvent(event_type_names::kDOMFocusOut,\n                                                 new_focused_element,\n                                                 params.source_capabilities);\n\n      if (focused_element_) {\n        focus_change_blocked = true;\n        new_focused_element = nullptr;\n      }\n    }\n  }\n\n  if (new_focused_element)\n    UpdateStyleAndLayoutTreeForNode(new_focused_element);\n  if (new_focused_element && new_focused_element->IsFocusable()) {\n     if (IsRootEditableElement(*new_focused_element) &&\n         !AcceptsEditingFocus(*new_focused_element)) {\n      focus_change_blocked = true;\n      goto SetFocusedElementDone;\n     }\n     focused_element_ = new_focused_element;\n    SetSequentialFocusNavigationStartingPoint(focused_element_.Get());\n\n    if (params.type != kWebFocusTypeNone)\n      last_focus_type_ = params.type;\n\n    focused_element_->SetFocused(true, params.type);\n    focused_element_->SetHasFocusWithinUpToAncestor(true, ancestor);\n \n     if (focused_element_ != new_focused_element) {\n      focus_change_blocked = true;\n      goto SetFocusedElementDone;\n     }\n     CancelFocusAppearanceUpdate();\n     EnsurePaintLocationDataValidForNode(focused_element_);\n    if (focused_element_ != new_focused_element) {\n      focus_change_blocked = true;\n      goto SetFocusedElementDone;\n    }\n     focused_element_->UpdateFocusAppearanceWithOptions(\n         params.selection_behavior, params.options);\n \n    if (GetPage() && (GetPage()->GetFocusController().IsFocused())) {\n      focused_element_->DispatchFocusEvent(old_focused_element, params.type,\n                                           params.source_capabilities);\n \n       if (focused_element_ != new_focused_element) {\n        focus_change_blocked = true;\n        goto SetFocusedElementDone;\n       }\n       focused_element_->DispatchFocusInEvent(event_type_names::kFocusin,\n                                             old_focused_element, params.type,\n                                             params.source_capabilities);\n \n       if (focused_element_ != new_focused_element) {\n        focus_change_blocked = true;\n        goto SetFocusedElementDone;\n       }\n \n      focused_element_->DispatchFocusInEvent(event_type_names::kDOMFocusIn,\n                                             old_focused_element, params.type,\n                                             params.source_capabilities);\n \n       if (focused_element_ != new_focused_element) {\n        focus_change_blocked = true;\n        goto SetFocusedElementDone;\n       }\n     }\n   }\n\n  if (!focus_change_blocked && focused_element_) {\n    if (AXObjectCache* cache = ExistingAXObjectCache()) {\n      cache->HandleFocusedUIElementChanged(old_focused_element,\n                                           new_focused_element);\n    }\n  }\n\n  if (!focus_change_blocked && GetPage()) {\n    GetPage()->GetChromeClient().FocusedNodeChanged(old_focused_element,\n                                                     focused_element_.Get());\n   }\n \nSetFocusedElementDone:\n   UpdateStyleAndLayoutTree();\n   if (LocalFrame* frame = GetFrame())\n     frame->Selection().DidChangeFocus();\n  return !focus_change_blocked;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143617,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "bool Document::SetFocusedElement(Element* new_focused_element,\n                                 const FocusParams& params) {\n  DCHECK(!lifecycle_.InDetach());\n\n  clear_focused_element_timer_.Stop();\n\n  if (new_focused_element && (new_focused_element->GetDocument() != this))\n    return true;\n\n  if (NodeChildRemovalTracker::IsBeingRemoved(new_focused_element))\n    return true;\n\n  if (focused_element_ == new_focused_element)\n    return true;\n\n  bool focus_change_blocked = false;\n  Element* old_focused_element = focused_element_;\n  focused_element_ = nullptr;\n\n  UpdateDistributionForFlatTreeTraversal();\n  Node* ancestor = (old_focused_element && old_focused_element->isConnected() &&\n                    new_focused_element)\n                       ? FlatTreeTraversal::CommonAncestor(*old_focused_element,\n                                                           *new_focused_element)\n                       : nullptr;\n\n  if (old_focused_element) {\n    old_focused_element->SetFocused(false, params.type);\n    old_focused_element->SetHasFocusWithinUpToAncestor(false, ancestor);\n\n    if (GetPage() && (GetPage()->GetFocusController().IsFocused())) {\n      old_focused_element->DispatchBlurEvent(new_focused_element, params.type,\n                                             params.source_capabilities);\n      if (focused_element_) {\n        focus_change_blocked = true;\n        new_focused_element = nullptr;\n      }\n\n      old_focused_element->DispatchFocusOutEvent(event_type_names::kFocusout,\n                                                 new_focused_element,\n                                                 params.source_capabilities);\n      old_focused_element->DispatchFocusOutEvent(event_type_names::kDOMFocusOut,\n                                                 new_focused_element,\n                                                 params.source_capabilities);\n\n      if (focused_element_) {\n        focus_change_blocked = true;\n        new_focused_element = nullptr;\n      }\n    }\n  }\n\n  if (new_focused_element)\n    UpdateStyleAndLayoutTreeForNode(new_focused_element);\n  if (new_focused_element && new_focused_element->IsFocusable()) {\n     if (IsRootEditableElement(*new_focused_element) &&\n         !AcceptsEditingFocus(*new_focused_element)) {\n      UpdateStyleAndLayoutTree();\n      if (LocalFrame* frame = GetFrame())\n        frame->Selection().DidChangeFocus();\n      return false;\n     }\n     focused_element_ = new_focused_element;\n    SetSequentialFocusNavigationStartingPoint(focused_element_.Get());\n\n    if (params.type != kWebFocusTypeNone)\n      last_focus_type_ = params.type;\n\n    focused_element_->SetFocused(true, params.type);\n    focused_element_->SetHasFocusWithinUpToAncestor(true, ancestor);\n \n     if (focused_element_ != new_focused_element) {\n      UpdateStyleAndLayoutTree();\n      if (LocalFrame* frame = GetFrame())\n        frame->Selection().DidChangeFocus();\n      return false;\n     }\n     CancelFocusAppearanceUpdate();\n     EnsurePaintLocationDataValidForNode(focused_element_);\n     focused_element_->UpdateFocusAppearanceWithOptions(\n         params.selection_behavior, params.options);\n \n    if (GetPage() && (GetPage()->GetFocusController().IsFocused())) {\n      focused_element_->DispatchFocusEvent(old_focused_element, params.type,\n                                           params.source_capabilities);\n \n       if (focused_element_ != new_focused_element) {\n        UpdateStyleAndLayoutTree();\n        if (LocalFrame* frame = GetFrame())\n          frame->Selection().DidChangeFocus();\n        return false;\n       }\n       focused_element_->DispatchFocusInEvent(event_type_names::kFocusin,\n                                             old_focused_element, params.type,\n                                             params.source_capabilities);\n \n       if (focused_element_ != new_focused_element) {\n        UpdateStyleAndLayoutTree();\n        if (LocalFrame* frame = GetFrame())\n          frame->Selection().DidChangeFocus();\n        return false;\n       }\n \n      focused_element_->DispatchFocusInEvent(event_type_names::kDOMFocusIn,\n                                             old_focused_element, params.type,\n                                             params.source_capabilities);\n \n       if (focused_element_ != new_focused_element) {\n        UpdateStyleAndLayoutTree();\n        if (LocalFrame* frame = GetFrame())\n          frame->Selection().DidChangeFocus();\n        return false;\n       }\n     }\n   }\n\n  if (!focus_change_blocked && focused_element_) {\n    if (AXObjectCache* cache = ExistingAXObjectCache()) {\n      cache->HandleFocusedUIElementChanged(old_focused_element,\n                                           new_focused_element);\n    }\n  }\n\n  if (!focus_change_blocked && GetPage()) {\n    GetPage()->GetChromeClient().FocusedNodeChanged(old_focused_element,\n                                                     focused_element_.Get());\n   }\n \n   UpdateStyleAndLayoutTree();\n   if (LocalFrame* frame = GetFrame())\n     frame->Selection().DidChangeFocus();\n  return !focus_change_blocked;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143618,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "void EventBindings::AttachFilteredEvent(\n    const v8::FunctionCallbackInfo<v8::Value>& args) {\n  CHECK_EQ(2, args.Length());\n  CHECK(args[0]->IsString());\n  CHECK(args[1]->IsObject());\n\n  std::string event_name = *v8::String::Utf8Value(args[0]);\n  if (!context()->HasAccessOrThrowError(event_name))\n    return;\n\n  std::unique_ptr<base::DictionaryValue> filter;\n  {\n    std::unique_ptr<content::V8ValueConverter> converter(\n        content::V8ValueConverter::create());\n    std::unique_ptr<base::Value> filter_value(converter->FromV8Value(\n        v8::Local<v8::Object>::Cast(args[1]), context()->v8_context()));\n    if (!filter_value || !filter_value->IsType(base::Value::TYPE_DICTIONARY)) {\n      args.GetReturnValue().Set(static_cast<int32_t>(-1));\n      return;\n    }\n     filter = base::DictionaryValue::From(std::move(filter_value));\n   }\n \n  base::DictionaryValue* filter_weak = filter.get();\n   int id = g_event_filter.Get().AddEventMatcher(\n       event_name, ParseEventMatcher(std::move(filter)));\n   attached_matcher_ids_.insert(id);\n \n   std::string extension_id = context()->GetExtensionID();\n   if (AddFilter(event_name, extension_id, *filter_weak)) {\n     bool lazy = ExtensionFrameHelper::IsContextForEventPage(context());\n    content::RenderThread::Get()->Send(new ExtensionHostMsg_AddFilteredListener(\n        extension_id, event_name, *filter_weak, lazy));\n  }\n\n  args.GetReturnValue().Set(static_cast<int32_t>(id));\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143621,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "void EventBindings::AttachFilteredEvent(\n    const v8::FunctionCallbackInfo<v8::Value>& args) {\n  CHECK_EQ(2, args.Length());\n  CHECK(args[0]->IsString());\n  CHECK(args[1]->IsObject());\n\n  std::string event_name = *v8::String::Utf8Value(args[0]);\n  if (!context()->HasAccessOrThrowError(event_name))\n    return;\n\n  std::unique_ptr<base::DictionaryValue> filter;\n  {\n    std::unique_ptr<content::V8ValueConverter> converter(\n        content::V8ValueConverter::create());\n    std::unique_ptr<base::Value> filter_value(converter->FromV8Value(\n        v8::Local<v8::Object>::Cast(args[1]), context()->v8_context()));\n    if (!filter_value || !filter_value->IsType(base::Value::TYPE_DICTIONARY)) {\n      args.GetReturnValue().Set(static_cast<int32_t>(-1));\n      return;\n    }\n     filter = base::DictionaryValue::From(std::move(filter_value));\n   }\n \n   int id = g_event_filter.Get().AddEventMatcher(\n       event_name, ParseEventMatcher(std::move(filter)));\n  if (id == -1) {\n    args.GetReturnValue().Set(static_cast<int32_t>(-1));\n    return;\n  }\n   attached_matcher_ids_.insert(id);\n \n  const EventMatcher* matcher = g_event_filter.Get().GetEventMatcher(id);\n  DCHECK(matcher);\n  base::DictionaryValue* filter_weak = matcher->value();\n   std::string extension_id = context()->GetExtensionID();\n   if (AddFilter(event_name, extension_id, *filter_weak)) {\n     bool lazy = ExtensionFrameHelper::IsContextForEventPage(context());\n    content::RenderThread::Get()->Send(new ExtensionHostMsg_AddFilteredListener(\n        extension_id, event_name, *filter_weak, lazy));\n  }\n\n  args.GetReturnValue().Set(static_cast<int32_t>(id));\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143622,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "Node::InsertionNotificationRequest HTMLLinkElement::InsertedInto(\n    ContainerNode& insertion_point) {\n  HTMLElement::InsertedInto(insertion_point);\n  LogAddElementIfIsolatedWorldAndInDocument(\"link\", relAttr, hrefAttr);\n   if (!insertion_point.isConnected())\n     return kInsertionDone;\n   DCHECK(isConnected());\n   if (!ShouldLoadLink() && IsInShadowTree()) {\n     String message = \"HTML element <link> is ignored in shadow tree.\";\n     GetDocument().AddConsoleMessage(ConsoleMessage::Create(\n         kJSMessageSource, kWarningMessageLevel, message));\n     return kInsertionDone;\n   }\n \n  GetDocument().GetStyleEngine().AddStyleSheetCandidateNode(*this);\n   Process();\n \n   if (link_)\n    link_->OwnerInserted();\n\n  return kInsertionDone;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143673,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "Node::InsertionNotificationRequest HTMLLinkElement::InsertedInto(\n    ContainerNode& insertion_point) {\n  HTMLElement::InsertedInto(insertion_point);\n  LogAddElementIfIsolatedWorldAndInDocument(\"link\", relAttr, hrefAttr);\n   if (!insertion_point.isConnected())\n     return kInsertionDone;\n   DCHECK(isConnected());\n\n  GetDocument().GetStyleEngine().AddStyleSheetCandidateNode(*this);\n\n   if (!ShouldLoadLink() && IsInShadowTree()) {\n     String message = \"HTML element <link> is ignored in shadow tree.\";\n     GetDocument().AddConsoleMessage(ConsoleMessage::Create(\n         kJSMessageSource, kWarningMessageLevel, message));\n     return kInsertionDone;\n   }\n \n   Process();\n \n   if (link_)\n    link_->OwnerInserted();\n\n  return kInsertionDone;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143674,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "bool PDFiumEngine::HandleEvent(const pp::InputEvent& event) {\n  DCHECK(!defer_page_unload_);\n  defer_page_unload_ = true;\n  bool rv = false;\n  switch (event.GetType()) {\n    case PP_INPUTEVENT_TYPE_MOUSEDOWN:\n      rv = OnMouseDown(pp::MouseInputEvent(event));\n      break;\n    case PP_INPUTEVENT_TYPE_MOUSEUP:\n      rv = OnMouseUp(pp::MouseInputEvent(event));\n      break;\n    case PP_INPUTEVENT_TYPE_MOUSEMOVE:\n      rv = OnMouseMove(pp::MouseInputEvent(event));\n      break;\n    case PP_INPUTEVENT_TYPE_KEYDOWN:\n      rv = OnKeyDown(pp::KeyboardInputEvent(event));\n      break;\n    case PP_INPUTEVENT_TYPE_KEYUP:\n      rv = OnKeyUp(pp::KeyboardInputEvent(event));\n      break;\n    case PP_INPUTEVENT_TYPE_CHAR:\n      rv = OnChar(pp::KeyboardInputEvent(event));\n      break;\n    case PP_INPUTEVENT_TYPE_TOUCHSTART: {\n      KillTouchTimer(next_touch_timer_id_);\n\n      pp::TouchInputEvent touch_event(event);\n      if (touch_event.GetTouchCount(PP_TOUCHLIST_TYPE_TARGETTOUCHES) == 1)\n        ScheduleTouchTimer(touch_event);\n      break;\n    }\n    case PP_INPUTEVENT_TYPE_TOUCHEND:\n      KillTouchTimer(next_touch_timer_id_);\n      break;\n    case PP_INPUTEVENT_TYPE_TOUCHMOVE:\n      KillTouchTimer(next_touch_timer_id_);\n    default:\n      break;\n  }\n \n   DCHECK(defer_page_unload_);\n   defer_page_unload_ = false;\n  for (int page_index : deferred_page_unloads_)\n     pages_[page_index]->Unload();\n  deferred_page_unloads_.clear();\n   return rv;\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143701,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "bool PDFiumEngine::HandleEvent(const pp::InputEvent& event) {\n  DCHECK(!defer_page_unload_);\n  defer_page_unload_ = true;\n  bool rv = false;\n  switch (event.GetType()) {\n    case PP_INPUTEVENT_TYPE_MOUSEDOWN:\n      rv = OnMouseDown(pp::MouseInputEvent(event));\n      break;\n    case PP_INPUTEVENT_TYPE_MOUSEUP:\n      rv = OnMouseUp(pp::MouseInputEvent(event));\n      break;\n    case PP_INPUTEVENT_TYPE_MOUSEMOVE:\n      rv = OnMouseMove(pp::MouseInputEvent(event));\n      break;\n    case PP_INPUTEVENT_TYPE_KEYDOWN:\n      rv = OnKeyDown(pp::KeyboardInputEvent(event));\n      break;\n    case PP_INPUTEVENT_TYPE_KEYUP:\n      rv = OnKeyUp(pp::KeyboardInputEvent(event));\n      break;\n    case PP_INPUTEVENT_TYPE_CHAR:\n      rv = OnChar(pp::KeyboardInputEvent(event));\n      break;\n    case PP_INPUTEVENT_TYPE_TOUCHSTART: {\n      KillTouchTimer(next_touch_timer_id_);\n\n      pp::TouchInputEvent touch_event(event);\n      if (touch_event.GetTouchCount(PP_TOUCHLIST_TYPE_TARGETTOUCHES) == 1)\n        ScheduleTouchTimer(touch_event);\n      break;\n    }\n    case PP_INPUTEVENT_TYPE_TOUCHEND:\n      KillTouchTimer(next_touch_timer_id_);\n      break;\n    case PP_INPUTEVENT_TYPE_TOUCHMOVE:\n      KillTouchTimer(next_touch_timer_id_);\n    default:\n      break;\n  }\n \n   DCHECK(defer_page_unload_);\n   defer_page_unload_ = false;\n\n  // Store the pages to unload away because the act of unloading pages can cause\n  // there to be more pages to unload. We leave those extra pages to be unloaded\n  // on the next go around.\n  std::vector<int> pages_to_unload;\n  std::swap(pages_to_unload, deferred_page_unloads_);\n  for (int page_index : pages_to_unload)\n     pages_[page_index]->Unload();\n\n   return rv;\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143702,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "void WebUIExtension::Send(gin::Arguments* args) {\n  blink::WebLocalFrame* frame;\n  RenderFrame* render_frame;\n  if (!ShouldRespondToRequest(&frame, &render_frame))\n    return;\n\n  std::string message;\n  if (!args->GetNext(&message)) {\n    args->ThrowError();\n    return;\n  }\n\n  if (base::EndsWith(message, \"RequiringGesture\",\n                     base::CompareCase::SENSITIVE) &&\n      !blink::WebUserGestureIndicator::IsProcessingUserGesture(frame)) {\n    NOTREACHED();\n    return;\n  }\n\n  std::unique_ptr<base::ListValue> content;\n  if (args->PeekNext().IsEmpty() || args->PeekNext()->IsUndefined()) {\n    content.reset(new base::ListValue());\n  } else {\n    v8::Local<v8::Object> obj;\n    if (!args->GetNext(&obj)) {\n      args->ThrowError();\n      return;\n    }\n\n     content = base::ListValue::From(V8ValueConverter::Create()->FromV8Value(\n         obj, frame->MainWorldScriptContext()));\n     DCHECK(content);\n   }\n \n  render_frame->Send(new FrameHostMsg_WebUISend(render_frame->GetRoutingID(),\n                                                frame->GetDocument().Url(),\n                                                message, *content));\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143717,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "void WebUIExtension::Send(gin::Arguments* args) {\n  blink::WebLocalFrame* frame;\n  RenderFrame* render_frame;\n  if (!ShouldRespondToRequest(&frame, &render_frame))\n    return;\n\n  std::string message;\n  if (!args->GetNext(&message)) {\n    args->ThrowError();\n    return;\n  }\n\n  if (base::EndsWith(message, \"RequiringGesture\",\n                     base::CompareCase::SENSITIVE) &&\n      !blink::WebUserGestureIndicator::IsProcessingUserGesture(frame)) {\n    NOTREACHED();\n    return;\n  }\n\n  std::unique_ptr<base::ListValue> content;\n  if (args->PeekNext().IsEmpty() || args->PeekNext()->IsUndefined()) {\n    content.reset(new base::ListValue());\n  } else {\n    v8::Local<v8::Object> obj;\n    if (!args->GetNext(&obj)) {\n      args->ThrowError();\n      return;\n    }\n\n     content = base::ListValue::From(V8ValueConverter::Create()->FromV8Value(\n         obj, frame->MainWorldScriptContext()));\n     DCHECK(content);\n    // The conversion of |obj| could have triggered arbitrary JavaScript code,\n    // so check that the frame is still valid to avoid dereferencing a stale\n    // pointer.\n    if (frame != blink::WebLocalFrame::FrameForCurrentContext()) {\n      NOTREACHED();\n      return;\n    }\n   }\n \n  render_frame->Send(new FrameHostMsg_WebUISend(render_frame->GetRoutingID(),\n                                                frame->GetDocument().Url(),\n                                                message, *content));\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143718,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "void MemBackendImpl::EvictIfNeeded() {\n  if (current_size_ <= max_size_)\n    return;\n\n  int target_size = std::max(0, max_size_ - kDefaultEvictionSize);\n\n   base::LinkNode<MemEntryImpl>* entry = lru_list_.head();\n   while (current_size_ > target_size && entry != lru_list_.end()) {\n     MemEntryImpl* to_doom = entry->value();\n    entry = entry->next();\n     if (!to_doom->InUse())\n       to_doom->Doom();\n   }\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143719,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "void MemBackendImpl::EvictIfNeeded() {\n  if (current_size_ <= max_size_)\n    return;\n\n  int target_size = std::max(0, max_size_ - kDefaultEvictionSize);\n\n   base::LinkNode<MemEntryImpl>* entry = lru_list_.head();\n   while (current_size_ > target_size && entry != lru_list_.end()) {\n     MemEntryImpl* to_doom = entry->value();\n\n    do {\n      entry = entry->next();\n      // It's possible that entry now points to a child of to_doom, and the\n      // parent is about to be deleted. Skip past any child entries.\n    } while (entry != lru_list_.end() && entry->value()->parent() == to_doom);\n\n     if (!to_doom->InUse())\n       to_doom->Doom();\n   }\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143720,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "void AudioNode::Dispose() {\n  DCHECK(IsMainThread());\n#if DEBUG_AUDIONODE_REFERENCES\n  fprintf(stderr, \"[%16p]: %16p: %2d: AudioNode::dispose %16p\\n\", context(),\n          this, Handler().GetNodeType(), handler_.get());\n #endif\n   BaseAudioContext::GraphAutoLocker locker(context());\n   Handler().Dispose();\n  if (context()->HasRealtimeConstraint()) {\n     context()->GetDeferredTaskHandler().AddRenderingOrphanHandler(\n         std::move(handler_));\n  } else {\n    if (context()->ContextState() == BaseAudioContext::kRunning) {\n      context()->GetDeferredTaskHandler().AddRenderingOrphanHandler(\n          std::move(handler_));\n    }\n   }\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143731,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "void AudioNode::Dispose() {\n  DCHECK(IsMainThread());\n#if DEBUG_AUDIONODE_REFERENCES\n  fprintf(stderr, \"[%16p]: %16p: %2d: AudioNode::dispose %16p\\n\", context(),\n          this, Handler().GetNodeType(), handler_.get());\n #endif\n   BaseAudioContext::GraphAutoLocker locker(context());\n   Handler().Dispose();\n  if (context()->ContextState() == BaseAudioContext::kRunning) {\n     context()->GetDeferredTaskHandler().AddRenderingOrphanHandler(\n         std::move(handler_));\n   }\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143732,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "void ScriptProcessorHandler::Process(size_t frames_to_process) {\n\n  AudioBus* input_bus = Input(0).Bus();\n  AudioBus* output_bus = Output(0).Bus();\n\n  unsigned double_buffer_index = this->DoubleBufferIndex();\n  bool is_double_buffer_index_good =\n      double_buffer_index < 2 && double_buffer_index < input_buffers_.size() &&\n      double_buffer_index < output_buffers_.size();\n  DCHECK(is_double_buffer_index_good);\n  if (!is_double_buffer_index_good)\n    return;\n\n  AudioBuffer* input_buffer = input_buffers_[double_buffer_index].Get();\n  AudioBuffer* output_buffer = output_buffers_[double_buffer_index].Get();\n\n  unsigned number_of_input_channels = internal_input_bus_->NumberOfChannels();\n  bool buffers_are_good =\n      output_buffer && BufferSize() == output_buffer->length() &&\n      buffer_read_write_index_ + frames_to_process <= BufferSize();\n\n  if (internal_input_bus_->NumberOfChannels())\n    buffers_are_good = buffers_are_good && input_buffer &&\n                       BufferSize() == input_buffer->length();\n\n  DCHECK(buffers_are_good);\n  if (!buffers_are_good)\n    return;\n\n  bool is_frames_to_process_good = frames_to_process &&\n                                   BufferSize() >= frames_to_process &&\n                                   !(BufferSize() % frames_to_process);\n  DCHECK(is_frames_to_process_good);\n  if (!is_frames_to_process_good)\n    return;\n\n  unsigned number_of_output_channels = output_bus->NumberOfChannels();\n\n  bool channels_are_good =\n      (number_of_input_channels == number_of_input_channels_) &&\n      (number_of_output_channels == number_of_output_channels_);\n  DCHECK(channels_are_good);\n  if (!channels_are_good)\n    return;\n\n  for (unsigned i = 0; i < number_of_input_channels; ++i)\n    internal_input_bus_->SetChannelMemory(\n        i,\n        input_buffer->getChannelData(i).View()->Data() +\n            buffer_read_write_index_,\n        frames_to_process);\n\n  if (number_of_input_channels)\n    internal_input_bus_->CopyFrom(*input_bus);\n\n  for (unsigned i = 0; i < number_of_output_channels; ++i) {\n    memcpy(output_bus->Channel(i)->MutableData(),\n           output_buffer->getChannelData(i).View()->Data() +\n               buffer_read_write_index_,\n           sizeof(float) * frames_to_process);\n  }\n\n  buffer_read_write_index_ =\n      (buffer_read_write_index_ + frames_to_process) % BufferSize();\n\n  if (!buffer_read_write_index_) {\n    MutexTryLocker try_locker(process_event_lock_);\n    if (!try_locker.Locked()) {\n      output_buffer->Zero();\n    } else if (Context()->GetExecutionContext()) {\n      if (Context()->HasRealtimeConstraint()) {\n         TaskRunnerHelper::Get(TaskType::kMediaElementEvent,\n                               Context()->GetExecutionContext())\n            ->PostTask(BLINK_FROM_HERE,\n                       CrossThreadBind(\n                           &ScriptProcessorHandler::FireProcessEvent,\n                           CrossThreadUnretained(this), double_buffer_index_));\n       } else {\n        std::unique_ptr<WaitableEvent> waitable_event =\n            WTF::MakeUnique<WaitableEvent>();\n \n         TaskRunnerHelper::Get(TaskType::kMediaElementEvent,\n                               Context()->GetExecutionContext())\n            ->PostTask(BLINK_FROM_HERE,\n                       CrossThreadBind(\n                           &ScriptProcessorHandler::\n                               FireProcessEventForOfflineAudioContext,\n                           CrossThreadUnretained(this), double_buffer_index_,\n                           CrossThreadUnretained(waitable_event.get())));\n \n        waitable_event->Wait();\n      }\n    }\n\n    SwapBuffers();\n  }\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143749,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "void ScriptProcessorHandler::Process(size_t frames_to_process) {\n\n  AudioBus* input_bus = Input(0).Bus();\n  AudioBus* output_bus = Output(0).Bus();\n\n  unsigned double_buffer_index = this->DoubleBufferIndex();\n  bool is_double_buffer_index_good =\n      double_buffer_index < 2 && double_buffer_index < input_buffers_.size() &&\n      double_buffer_index < output_buffers_.size();\n  DCHECK(is_double_buffer_index_good);\n  if (!is_double_buffer_index_good)\n    return;\n\n  AudioBuffer* input_buffer = input_buffers_[double_buffer_index].Get();\n  AudioBuffer* output_buffer = output_buffers_[double_buffer_index].Get();\n\n  unsigned number_of_input_channels = internal_input_bus_->NumberOfChannels();\n  bool buffers_are_good =\n      output_buffer && BufferSize() == output_buffer->length() &&\n      buffer_read_write_index_ + frames_to_process <= BufferSize();\n\n  if (internal_input_bus_->NumberOfChannels())\n    buffers_are_good = buffers_are_good && input_buffer &&\n                       BufferSize() == input_buffer->length();\n\n  DCHECK(buffers_are_good);\n  if (!buffers_are_good)\n    return;\n\n  bool is_frames_to_process_good = frames_to_process &&\n                                   BufferSize() >= frames_to_process &&\n                                   !(BufferSize() % frames_to_process);\n  DCHECK(is_frames_to_process_good);\n  if (!is_frames_to_process_good)\n    return;\n\n  unsigned number_of_output_channels = output_bus->NumberOfChannels();\n\n  bool channels_are_good =\n      (number_of_input_channels == number_of_input_channels_) &&\n      (number_of_output_channels == number_of_output_channels_);\n  DCHECK(channels_are_good);\n  if (!channels_are_good)\n    return;\n\n  for (unsigned i = 0; i < number_of_input_channels; ++i)\n    internal_input_bus_->SetChannelMemory(\n        i,\n        input_buffer->getChannelData(i).View()->Data() +\n            buffer_read_write_index_,\n        frames_to_process);\n\n  if (number_of_input_channels)\n    internal_input_bus_->CopyFrom(*input_bus);\n\n  for (unsigned i = 0; i < number_of_output_channels; ++i) {\n    memcpy(output_bus->Channel(i)->MutableData(),\n           output_buffer->getChannelData(i).View()->Data() +\n               buffer_read_write_index_,\n           sizeof(float) * frames_to_process);\n  }\n\n  buffer_read_write_index_ =\n      (buffer_read_write_index_ + frames_to_process) % BufferSize();\n\n  if (!buffer_read_write_index_) {\n    MutexTryLocker try_locker(process_event_lock_);\n    if (!try_locker.Locked()) {\n      output_buffer->Zero();\n    } else if (Context()->GetExecutionContext()) {\n      if (Context()->HasRealtimeConstraint()) {\n         TaskRunnerHelper::Get(TaskType::kMediaElementEvent,\n                               Context()->GetExecutionContext())\n            ->PostTask(\n                BLINK_FROM_HERE,\n                CrossThreadBind(&ScriptProcessorHandler::FireProcessEvent,\n                                WrapRefPtr(this), double_buffer_index_));\n       } else {\n        std::unique_ptr<WaitableEvent> waitable_event =\n            WTF::MakeUnique<WaitableEvent>();\n \n         TaskRunnerHelper::Get(TaskType::kMediaElementEvent,\n                               Context()->GetExecutionContext())\n            ->PostTask(\n                BLINK_FROM_HERE,\n                CrossThreadBind(&ScriptProcessorHandler::\n                                    FireProcessEventForOfflineAudioContext,\n                                WrapRefPtr(this), double_buffer_index_,\n                                CrossThreadUnretained(waitable_event.get())));\n \n        waitable_event->Wait();\n      }\n    }\n\n    SwapBuffers();\n  }\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143750,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": " void ServiceWorkerPaymentInstrument::OnPaymentAppInvoked(\n     mojom::PaymentHandlerResponsePtr response) {\n  DCHECK(delegate_);\n   if (delegate_ != nullptr) {\n     delegate_->OnInstrumentDetailsReady(response->method_name,\n                                         response->stringified_details);\n    delegate_ = nullptr;\n  }\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143757,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": " void ServiceWorkerPaymentInstrument::OnPaymentAppInvoked(\n     mojom::PaymentHandlerResponsePtr response) {\n   if (delegate_ != nullptr) {\n     delegate_->OnInstrumentDetailsReady(response->method_name,\n                                         response->stringified_details);\n    delegate_ = nullptr;\n  }\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143758,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "DOMArrayBuffer* FileReaderLoader::ArrayBufferResult() {\n  DCHECK_EQ(read_type_, kReadAsArrayBuffer);\n  if (array_buffer_result_)\n    return array_buffer_result_;\n\n   if (!raw_data_ || error_code_ != FileErrorCode::kOK)\n     return nullptr;\n \n  DOMArrayBuffer* result = DOMArrayBuffer::Create(raw_data_->ToArrayBuffer());\n  if (finished_loading_) {\n    array_buffer_result_ = result;\n    AdjustReportedMemoryUsageToV8(\n        -1 * static_cast<int64_t>(raw_data_->ByteLength()));\n    raw_data_.reset();\n   }\n  return result;\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143769,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "DOMArrayBuffer* FileReaderLoader::ArrayBufferResult() {\n  DCHECK_EQ(read_type_, kReadAsArrayBuffer);\n  if (array_buffer_result_)\n    return array_buffer_result_;\n\n   if (!raw_data_ || error_code_ != FileErrorCode::kOK)\n     return nullptr;\n \n  if (!finished_loading_) {\n    return DOMArrayBuffer::Create(\n        ArrayBuffer::Create(raw_data_->Data(), raw_data_->ByteLength()));\n   }\n\n  array_buffer_result_ = DOMArrayBuffer::Create(raw_data_->ToArrayBuffer());\n  AdjustReportedMemoryUsageToV8(-1 *\n                                static_cast<int64_t>(raw_data_->ByteLength()));\n  raw_data_.reset();\n  return array_buffer_result_;\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143770,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": " ExtensionFunction::ResponseAction BluetoothSocketSendFunction::Run() {\n   DCHECK_CURRENTLY_ON(work_thread_id());\n \n  auto params = bluetooth_socket::Send::Params::Create(*args_);\n  EXTENSION_FUNCTION_VALIDATE(params.get());\n \n  io_buffer_size_ = params->data.size();\n  io_buffer_ = new net::WrappedIOBuffer(params->data.data());\n \n  BluetoothApiSocket* socket = GetSocket(params->socket_id);\n   if (!socket)\n     return RespondNow(Error(kSocketNotFoundError));\n \n  socket->Send(io_buffer_,\n               io_buffer_size_,\n               base::Bind(&BluetoothSocketSendFunction::OnSuccess, this),\n               base::Bind(&BluetoothSocketSendFunction::OnError, this));\n  return did_respond() ? AlreadyResponded() : RespondLater();\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143779,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": " ExtensionFunction::ResponseAction BluetoothSocketSendFunction::Run() {\n   DCHECK_CURRENTLY_ON(work_thread_id());\n \n  params_ = bluetooth_socket::Send::Params::Create(*args_);\n  EXTENSION_FUNCTION_VALIDATE(params_.get());\n \n  io_buffer_size_ = params_->data.size();\n  io_buffer_ = new net::WrappedIOBuffer(params_->data.data());\n \n  BluetoothApiSocket* socket = GetSocket(params_->socket_id);\n   if (!socket)\n     return RespondNow(Error(kSocketNotFoundError));\n \n  socket->Send(io_buffer_,\n               io_buffer_size_,\n               base::Bind(&BluetoothSocketSendFunction::OnSuccess, this),\n               base::Bind(&BluetoothSocketSendFunction::OnError, this));\n  return did_respond() ? AlreadyResponded() : RespondLater();\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143780,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "void BaseAudioContext::Initialize() {\n  if (IsDestinationInitialized())\n    return;\n\n  FFTFrame::Initialize();\n\n  audio_worklet_ = AudioWorklet::Create(this);\n \n   if (destination_node_) {\n     destination_node_->Handler().Initialize();\n     listener_ = AudioListener::Create(*this);\n  }\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143783,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "void BaseAudioContext::Initialize() {\n  if (IsDestinationInitialized())\n    return;\n\n  FFTFrame::Initialize();\n\n  audio_worklet_ = AudioWorklet::Create(this);\n \n   if (destination_node_) {\n     destination_node_->Handler().Initialize();\n    // TODO(crbug.com/863951).  The audio thread needs some things from the\n    // destination handler like the currentTime.  But the audio thread\n    // shouldn't access the |destination_node_| since it's an Oilpan object.\n    // Thus, get the destination handler, a non-oilpan object, so we can get\n    // the items directly from the handler instead of through the destination\n    // node.\n    destination_handler_ = &destination_node_->GetAudioDestinationHandler();\n\n     listener_ = AudioListener::Create(*this);\n  }\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143784,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "struct sk_buff *skb_segment(struct sk_buff *head_skb,\n\t\t\t    netdev_features_t features)\n{\n\tstruct sk_buff *segs = NULL;\n\tstruct sk_buff *tail = NULL;\n\tstruct sk_buff *list_skb = skb_shinfo(head_skb)->frag_list;\n \tskb_frag_t *frag = skb_shinfo(head_skb)->frags;\n \tunsigned int mss = skb_shinfo(head_skb)->gso_size;\n \tunsigned int doffset = head_skb->data - skb_mac_header(head_skb);\n \tunsigned int offset = doffset;\n \tunsigned int tnl_hlen = skb_tnl_header_len(head_skb);\n \tunsigned int headroom;\n\tunsigned int len;\n\t__be16 proto;\n\tbool csum;\n\tint sg = !!(features & NETIF_F_SG);\n\tint nfrags = skb_shinfo(head_skb)->nr_frags;\n\tint err = -ENOMEM;\n\tint i = 0;\n\tint pos;\n\n\tproto = skb_network_protocol(head_skb);\n\tif (unlikely(!proto))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tcsum = !!can_checksum_protocol(features, proto);\n\t__skb_push(head_skb, doffset);\n\theadroom = skb_headroom(head_skb);\n\tpos = skb_headlen(head_skb);\n\n\tdo {\n\t\tstruct sk_buff *nskb;\n\t\tskb_frag_t *nskb_frag;\n\t\tint hsize;\n\t\tint size;\n\n\t\tlen = head_skb->len - offset;\n\t\tif (len > mss)\n\t\t\tlen = mss;\n\n\t\thsize = skb_headlen(head_skb) - offset;\n\t\tif (hsize < 0)\n\t\t\thsize = 0;\n\t\tif (hsize > len || !sg)\n\t\t\thsize = len;\n\n\t\tif (!hsize && i >= nfrags && skb_headlen(list_skb) &&\n\t\t    (skb_headlen(list_skb) == len || sg)) {\n\t\t\tBUG_ON(skb_headlen(list_skb) > len);\n\n \t\t\ti = 0;\n \t\t\tnfrags = skb_shinfo(list_skb)->nr_frags;\n \t\t\tfrag = skb_shinfo(list_skb)->frags;\n \t\t\tpos += skb_headlen(list_skb);\n \n \t\t\twhile (pos < offset + len) {\n\t\t\t\tBUG_ON(i >= nfrags);\n\n\t\t\t\tsize = skb_frag_size(frag);\n\t\t\t\tif (pos + size > offset + len)\n\t\t\t\t\tbreak;\n\n\t\t\t\ti++;\n\t\t\t\tpos += size;\n\t\t\t\tfrag++;\n\t\t\t}\n\n\t\t\tnskb = skb_clone(list_skb, GFP_ATOMIC);\n\t\t\tlist_skb = list_skb->next;\n\n\t\t\tif (unlikely(!nskb))\n\t\t\t\tgoto err;\n\n\t\t\tif (unlikely(pskb_trim(nskb, len))) {\n\t\t\t\tkfree_skb(nskb);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\thsize = skb_end_offset(nskb);\n\t\t\tif (skb_cow_head(nskb, doffset + headroom)) {\n\t\t\t\tkfree_skb(nskb);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tnskb->truesize += skb_end_offset(nskb) - hsize;\n\t\t\tskb_release_head_state(nskb);\n\t\t\t__skb_push(nskb, doffset);\n\t\t} else {\n\t\t\tnskb = __alloc_skb(hsize + doffset + headroom,\n\t\t\t\t\t   GFP_ATOMIC, skb_alloc_rx_flag(head_skb),\n\t\t\t\t\t   NUMA_NO_NODE);\n\n\t\t\tif (unlikely(!nskb))\n\t\t\t\tgoto err;\n\n\t\t\tskb_reserve(nskb, headroom);\n\t\t\t__skb_put(nskb, doffset);\n\t\t}\n\n\t\tif (segs)\n\t\t\ttail->next = nskb;\n\t\telse\n\t\t\tsegs = nskb;\n\t\ttail = nskb;\n\n\t\t__copy_skb_header(nskb, head_skb);\n\t\tnskb->mac_len = head_skb->mac_len;\n\n\t\tskb_headers_offset_update(nskb, skb_headroom(nskb) - headroom);\n\n\t\tskb_copy_from_linear_data_offset(head_skb, -tnl_hlen,\n\t\t\t\t\t\t nskb->data - tnl_hlen,\n\t\t\t\t\t\t doffset + tnl_hlen);\n\n\t\tif (nskb->len == len + doffset)\n\t\t\tgoto perform_csum_check;\n\n\t\tif (!sg) {\n\t\t\tnskb->ip_summed = CHECKSUM_NONE;\n\t\t\tnskb->csum = skb_copy_and_csum_bits(head_skb, offset,\n\t\t\t\t\t\t\t    skb_put(nskb, len),\n\t\t\t\t\t\t\t    len, 0);\n\t\t\tcontinue;\n\t\t}\n\n\t\tnskb_frag = skb_shinfo(nskb)->frags;\n\n\t\tskb_copy_from_linear_data_offset(head_skb, offset,\n\t\t\t\t\t\t skb_put(nskb, hsize), hsize);\n\n\t\tskb_shinfo(nskb)->tx_flags = skb_shinfo(head_skb)->tx_flags &\n\t\t\tSKBTX_SHARED_FRAG;\n\n\t\twhile (pos < offset + len) {\n\t\t\tif (i >= nfrags) {\n\t\t\t\tBUG_ON(skb_headlen(list_skb));\n\n \t\t\t\ti = 0;\n \t\t\t\tnfrags = skb_shinfo(list_skb)->nr_frags;\n \t\t\t\tfrag = skb_shinfo(list_skb)->frags;\n \n \t\t\t\tBUG_ON(!nfrags);\n \n\t\t\t\tlist_skb = list_skb->next;\n\t\t\t}\n\n\t\t\tif (unlikely(skb_shinfo(nskb)->nr_frags >=\n\t\t\t\t     MAX_SKB_FRAGS)) {\n\t\t\t\tnet_warn_ratelimited(\n\t\t\t\t\t\"skb_segment: too many frags: %u %u\\n\",\n\t\t\t\t\tpos, mss);\n \t\t\t\tgoto err;\n \t\t\t}\n \n \t\t\t*nskb_frag = *frag;\n \t\t\t__skb_frag_ref(nskb_frag);\n \t\t\tsize = skb_frag_size(nskb_frag);\n\n\t\t\tif (pos < offset) {\n\t\t\t\tnskb_frag->page_offset += offset - pos;\n\t\t\t\tskb_frag_size_sub(nskb_frag, offset - pos);\n\t\t\t}\n\n\t\t\tskb_shinfo(nskb)->nr_frags++;\n\n\t\t\tif (pos + size <= offset + len) {\n\t\t\t\ti++;\n\t\t\t\tfrag++;\n\t\t\t\tpos += size;\n\t\t\t} else {\n\t\t\t\tskb_frag_size_sub(nskb_frag, pos + size - (offset + len));\n\t\t\t\tgoto skip_fraglist;\n\t\t\t}\n\n\t\t\tnskb_frag++;\n\t\t}\n\nskip_fraglist:\n\t\tnskb->data_len = len - hsize;\n\t\tnskb->len += nskb->data_len;\n\t\tnskb->truesize += nskb->data_len;\n\nperform_csum_check:\n\t\tif (!csum) {\n\t\t\tnskb->csum = skb_checksum(nskb, doffset,\n\t\t\t\t\t\t  nskb->len - doffset, 0);\n\t\t\tnskb->ip_summed = CHECKSUM_NONE;\n\t\t}\n\t} while ((offset += len) < head_skb->len);\n\n\treturn segs;\n\nerr:\n\tkfree_skb_list(segs);\n\treturn ERR_PTR(err);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144031,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "struct sk_buff *skb_segment(struct sk_buff *head_skb,\n\t\t\t    netdev_features_t features)\n{\n\tstruct sk_buff *segs = NULL;\n\tstruct sk_buff *tail = NULL;\n\tstruct sk_buff *list_skb = skb_shinfo(head_skb)->frag_list;\n \tskb_frag_t *frag = skb_shinfo(head_skb)->frags;\n \tunsigned int mss = skb_shinfo(head_skb)->gso_size;\n \tunsigned int doffset = head_skb->data - skb_mac_header(head_skb);\n\tstruct sk_buff *frag_skb = head_skb;\n \tunsigned int offset = doffset;\n \tunsigned int tnl_hlen = skb_tnl_header_len(head_skb);\n \tunsigned int headroom;\n\tunsigned int len;\n\t__be16 proto;\n\tbool csum;\n\tint sg = !!(features & NETIF_F_SG);\n\tint nfrags = skb_shinfo(head_skb)->nr_frags;\n\tint err = -ENOMEM;\n\tint i = 0;\n\tint pos;\n\n\tproto = skb_network_protocol(head_skb);\n\tif (unlikely(!proto))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tcsum = !!can_checksum_protocol(features, proto);\n\t__skb_push(head_skb, doffset);\n\theadroom = skb_headroom(head_skb);\n\tpos = skb_headlen(head_skb);\n\n\tdo {\n\t\tstruct sk_buff *nskb;\n\t\tskb_frag_t *nskb_frag;\n\t\tint hsize;\n\t\tint size;\n\n\t\tlen = head_skb->len - offset;\n\t\tif (len > mss)\n\t\t\tlen = mss;\n\n\t\thsize = skb_headlen(head_skb) - offset;\n\t\tif (hsize < 0)\n\t\t\thsize = 0;\n\t\tif (hsize > len || !sg)\n\t\t\thsize = len;\n\n\t\tif (!hsize && i >= nfrags && skb_headlen(list_skb) &&\n\t\t    (skb_headlen(list_skb) == len || sg)) {\n\t\t\tBUG_ON(skb_headlen(list_skb) > len);\n\n \t\t\ti = 0;\n \t\t\tnfrags = skb_shinfo(list_skb)->nr_frags;\n \t\t\tfrag = skb_shinfo(list_skb)->frags;\n\t\t\tfrag_skb = list_skb;\n \t\t\tpos += skb_headlen(list_skb);\n \n \t\t\twhile (pos < offset + len) {\n\t\t\t\tBUG_ON(i >= nfrags);\n\n\t\t\t\tsize = skb_frag_size(frag);\n\t\t\t\tif (pos + size > offset + len)\n\t\t\t\t\tbreak;\n\n\t\t\t\ti++;\n\t\t\t\tpos += size;\n\t\t\t\tfrag++;\n\t\t\t}\n\n\t\t\tnskb = skb_clone(list_skb, GFP_ATOMIC);\n\t\t\tlist_skb = list_skb->next;\n\n\t\t\tif (unlikely(!nskb))\n\t\t\t\tgoto err;\n\n\t\t\tif (unlikely(pskb_trim(nskb, len))) {\n\t\t\t\tkfree_skb(nskb);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\thsize = skb_end_offset(nskb);\n\t\t\tif (skb_cow_head(nskb, doffset + headroom)) {\n\t\t\t\tkfree_skb(nskb);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tnskb->truesize += skb_end_offset(nskb) - hsize;\n\t\t\tskb_release_head_state(nskb);\n\t\t\t__skb_push(nskb, doffset);\n\t\t} else {\n\t\t\tnskb = __alloc_skb(hsize + doffset + headroom,\n\t\t\t\t\t   GFP_ATOMIC, skb_alloc_rx_flag(head_skb),\n\t\t\t\t\t   NUMA_NO_NODE);\n\n\t\t\tif (unlikely(!nskb))\n\t\t\t\tgoto err;\n\n\t\t\tskb_reserve(nskb, headroom);\n\t\t\t__skb_put(nskb, doffset);\n\t\t}\n\n\t\tif (segs)\n\t\t\ttail->next = nskb;\n\t\telse\n\t\t\tsegs = nskb;\n\t\ttail = nskb;\n\n\t\t__copy_skb_header(nskb, head_skb);\n\t\tnskb->mac_len = head_skb->mac_len;\n\n\t\tskb_headers_offset_update(nskb, skb_headroom(nskb) - headroom);\n\n\t\tskb_copy_from_linear_data_offset(head_skb, -tnl_hlen,\n\t\t\t\t\t\t nskb->data - tnl_hlen,\n\t\t\t\t\t\t doffset + tnl_hlen);\n\n\t\tif (nskb->len == len + doffset)\n\t\t\tgoto perform_csum_check;\n\n\t\tif (!sg) {\n\t\t\tnskb->ip_summed = CHECKSUM_NONE;\n\t\t\tnskb->csum = skb_copy_and_csum_bits(head_skb, offset,\n\t\t\t\t\t\t\t    skb_put(nskb, len),\n\t\t\t\t\t\t\t    len, 0);\n\t\t\tcontinue;\n\t\t}\n\n\t\tnskb_frag = skb_shinfo(nskb)->frags;\n\n\t\tskb_copy_from_linear_data_offset(head_skb, offset,\n\t\t\t\t\t\t skb_put(nskb, hsize), hsize);\n\n\t\tskb_shinfo(nskb)->tx_flags = skb_shinfo(head_skb)->tx_flags &\n\t\t\tSKBTX_SHARED_FRAG;\n\n\t\twhile (pos < offset + len) {\n\t\t\tif (i >= nfrags) {\n\t\t\t\tBUG_ON(skb_headlen(list_skb));\n\n \t\t\t\ti = 0;\n \t\t\t\tnfrags = skb_shinfo(list_skb)->nr_frags;\n \t\t\t\tfrag = skb_shinfo(list_skb)->frags;\n\t\t\t\tfrag_skb = list_skb;\n \n \t\t\t\tBUG_ON(!nfrags);\n \n\t\t\t\tlist_skb = list_skb->next;\n\t\t\t}\n\n\t\t\tif (unlikely(skb_shinfo(nskb)->nr_frags >=\n\t\t\t\t     MAX_SKB_FRAGS)) {\n\t\t\t\tnet_warn_ratelimited(\n\t\t\t\t\t\"skb_segment: too many frags: %u %u\\n\",\n\t\t\t\t\tpos, mss);\n \t\t\t\tgoto err;\n \t\t\t}\n \n\t\t\tif (unlikely(skb_orphan_frags(frag_skb, GFP_ATOMIC)))\n\t\t\t\tgoto err;\n\n \t\t\t*nskb_frag = *frag;\n \t\t\t__skb_frag_ref(nskb_frag);\n \t\t\tsize = skb_frag_size(nskb_frag);\n\n\t\t\tif (pos < offset) {\n\t\t\t\tnskb_frag->page_offset += offset - pos;\n\t\t\t\tskb_frag_size_sub(nskb_frag, offset - pos);\n\t\t\t}\n\n\t\t\tskb_shinfo(nskb)->nr_frags++;\n\n\t\t\tif (pos + size <= offset + len) {\n\t\t\t\ti++;\n\t\t\t\tfrag++;\n\t\t\t\tpos += size;\n\t\t\t} else {\n\t\t\t\tskb_frag_size_sub(nskb_frag, pos + size - (offset + len));\n\t\t\t\tgoto skip_fraglist;\n\t\t\t}\n\n\t\t\tnskb_frag++;\n\t\t}\n\nskip_fraglist:\n\t\tnskb->data_len = len - hsize;\n\t\tnskb->len += nskb->data_len;\n\t\tnskb->truesize += nskb->data_len;\n\nperform_csum_check:\n\t\tif (!csum) {\n\t\t\tnskb->csum = skb_checksum(nskb, doffset,\n\t\t\t\t\t\t  nskb->len - doffset, 0);\n\t\t\tnskb->ip_summed = CHECKSUM_NONE;\n\t\t}\n\t} while ((offset += len) < head_skb->len);\n\n\treturn segs;\n\nerr:\n\tkfree_skb_list(segs);\n\treturn ERR_PTR(err);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144032,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int wddx_stack_destroy(wddx_stack *stack)\n{\n\tregister int i;\n \n \tif (stack->elements) {\n \t\tfor (i = 0; i < stack->top; i++) {\n\t\t\tif (((st_entry *)stack->elements[i])->data)\t{\n \t\t\t\tzval_ptr_dtor(&((st_entry *)stack->elements[i])->data);\n \t\t\t}\n \t\t\tif (((st_entry *)stack->elements[i])->varname) {\n\t\t\t\tefree(((st_entry *)stack->elements[i])->varname);\n\t\t\t}\n\t\t\tefree(stack->elements[i]);\n\t\t}\n\t\tefree(stack->elements);\n\t}\n\treturn SUCCESS;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144057,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int wddx_stack_destroy(wddx_stack *stack)\n{\n\tregister int i;\n \n \tif (stack->elements) {\n \t\tfor (i = 0; i < stack->top; i++) {\n\t\t\tif (((st_entry *)stack->elements[i])->data\n\t\t\t\t\t&& ((st_entry *)stack->elements[i])->type != ST_FIELD)\t{\n \t\t\t\tzval_ptr_dtor(&((st_entry *)stack->elements[i])->data);\n \t\t\t}\n \t\t\tif (((st_entry *)stack->elements[i])->varname) {\n\t\t\t\tefree(((st_entry *)stack->elements[i])->varname);\n\t\t\t}\n\t\t\tefree(stack->elements[i]);\n\t\t}\n\t\tefree(stack->elements);\n\t}\n\treturn SUCCESS;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144058,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static struct mm_struct *mm_init(struct mm_struct *mm, struct task_struct *p,\n\tstruct user_namespace *user_ns)\n{\n\tmm->mmap = NULL;\n\tmm->mm_rb = RB_ROOT;\n\tmm->vmacache_seqnum = 0;\n\tatomic_set(&mm->mm_users, 1);\n\tatomic_set(&mm->mm_count, 1);\n\tinit_rwsem(&mm->mmap_sem);\n\tINIT_LIST_HEAD(&mm->mmlist);\n\tmm->core_state = NULL;\n\tatomic_long_set(&mm->nr_ptes, 0);\n\tmm_nr_pmds_init(mm);\n\tmm->map_count = 0;\n\tmm->locked_vm = 0;\n\tmm->pinned_vm = 0;\n\tmemset(&mm->rss_stat, 0, sizeof(mm->rss_stat));\n\tspin_lock_init(&mm->page_table_lock);\n \tmm_init_cpumask(mm);\n \tmm_init_aio(mm);\n \tmm_init_owner(mm, p);\n \tmmu_notifier_mm_init(mm);\n \tinit_tlb_flush_pending(mm);\n #if defined(CONFIG_TRANSPARENT_HUGEPAGE) && !USE_SPLIT_PMD_PTLOCKS\n\tmm->pmd_huge_pte = NULL;\n#endif\n\n\tif (current->mm) {\n\t\tmm->flags = current->mm->flags & MMF_INIT_MASK;\n\t\tmm->def_flags = current->mm->def_flags & VM_INIT_DEF_MASK;\n\t} else {\n\t\tmm->flags = default_dump_filter;\n\t\tmm->def_flags = 0;\n\t}\n\n\tif (mm_alloc_pgd(mm))\n\t\tgoto fail_nopgd;\n\n\tif (init_new_context(p, mm))\n\t\tgoto fail_nocontext;\n\n\tmm->user_ns = get_user_ns(user_ns);\n\treturn mm;\n\nfail_nocontext:\n\tmm_free_pgd(mm);\nfail_nopgd:\n\tfree_mm(mm);\n\treturn NULL;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144073,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static struct mm_struct *mm_init(struct mm_struct *mm, struct task_struct *p,\n\tstruct user_namespace *user_ns)\n{\n\tmm->mmap = NULL;\n\tmm->mm_rb = RB_ROOT;\n\tmm->vmacache_seqnum = 0;\n\tatomic_set(&mm->mm_users, 1);\n\tatomic_set(&mm->mm_count, 1);\n\tinit_rwsem(&mm->mmap_sem);\n\tINIT_LIST_HEAD(&mm->mmlist);\n\tmm->core_state = NULL;\n\tatomic_long_set(&mm->nr_ptes, 0);\n\tmm_nr_pmds_init(mm);\n\tmm->map_count = 0;\n\tmm->locked_vm = 0;\n\tmm->pinned_vm = 0;\n\tmemset(&mm->rss_stat, 0, sizeof(mm->rss_stat));\n\tspin_lock_init(&mm->page_table_lock);\n \tmm_init_cpumask(mm);\n \tmm_init_aio(mm);\n \tmm_init_owner(mm, p);\n\tRCU_INIT_POINTER(mm->exe_file, NULL);\n \tmmu_notifier_mm_init(mm);\n \tinit_tlb_flush_pending(mm);\n #if defined(CONFIG_TRANSPARENT_HUGEPAGE) && !USE_SPLIT_PMD_PTLOCKS\n\tmm->pmd_huge_pte = NULL;\n#endif\n\n\tif (current->mm) {\n\t\tmm->flags = current->mm->flags & MMF_INIT_MASK;\n\t\tmm->def_flags = current->mm->def_flags & VM_INIT_DEF_MASK;\n\t} else {\n\t\tmm->flags = default_dump_filter;\n\t\tmm->def_flags = 0;\n\t}\n\n\tif (mm_alloc_pgd(mm))\n\t\tgoto fail_nopgd;\n\n\tif (init_new_context(p, mm))\n\t\tgoto fail_nocontext;\n\n\tmm->user_ns = get_user_ns(user_ns);\n\treturn mm;\n\nfail_nocontext:\n\tmm_free_pgd(mm);\nfail_nopgd:\n\tfree_mm(mm);\n\treturn NULL;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144074,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static ssize_t ucma_process_join(struct ucma_file *file,\n\t\t\t\t struct rdma_ucm_join_mcast *cmd,  int out_len)\n{\n\tstruct rdma_ucm_create_id_resp resp;\n\tstruct ucma_context *ctx;\n\tstruct ucma_multicast *mc;\n\tstruct sockaddr *addr;\n\tint ret;\n\tu8 join_state;\n\n\tif (out_len < sizeof(resp))\n\t\treturn -ENOSPC;\n\n\taddr = (struct sockaddr *) &cmd->addr;\n\tif (cmd->addr_size != rdma_addr_size(addr))\n\t\treturn -EINVAL;\n\n\tif (cmd->join_flags == RDMA_MC_JOIN_FLAG_FULLMEMBER)\n\t\tjoin_state = BIT(FULLMEMBER_JOIN);\n\telse if (cmd->join_flags == RDMA_MC_JOIN_FLAG_SENDONLY_FULLMEMBER)\n\t\tjoin_state = BIT(SENDONLY_FULLMEMBER_JOIN);\n\telse\n\t\treturn -EINVAL;\n\n\tctx = ucma_get_ctx_dev(file, cmd->id);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\n\tmutex_lock(&file->mut);\n\tmc = ucma_alloc_multicast(ctx);\n\tif (!mc) {\n\t\tret = -ENOMEM;\n\t\tgoto err1;\n\t}\n\tmc->join_state = join_state;\n\tmc->uid = cmd->uid;\n\tmemcpy(&mc->addr, addr, cmd->addr_size);\n\tret = rdma_join_multicast(ctx->cm_id, (struct sockaddr *)&mc->addr,\n\t\t\t\t  join_state, mc);\n\tif (ret)\n\t\tgoto err2;\n\n\tresp.id = mc->id;\n\tif (copy_to_user(u64_to_user_ptr(cmd->response),\n\t\t\t &resp, sizeof(resp))) {\n\t\tret = -EFAULT;\n \t\tgoto err3;\n \t}\n \n \tmutex_unlock(&file->mut);\n \tucma_put_ctx(ctx);\n \treturn 0;\n\nerr3:\n\trdma_leave_multicast(ctx->cm_id, (struct sockaddr *) &mc->addr);\n\tucma_cleanup_mc_events(mc);\nerr2:\n\tmutex_lock(&mut);\n\tidr_remove(&multicast_idr, mc->id);\n\tmutex_unlock(&mut);\n\tlist_del(&mc->list);\n\tkfree(mc);\nerr1:\n\tmutex_unlock(&file->mut);\n\tucma_put_ctx(ctx);\n\treturn ret;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144151,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static ssize_t ucma_process_join(struct ucma_file *file,\n\t\t\t\t struct rdma_ucm_join_mcast *cmd,  int out_len)\n{\n\tstruct rdma_ucm_create_id_resp resp;\n\tstruct ucma_context *ctx;\n\tstruct ucma_multicast *mc;\n\tstruct sockaddr *addr;\n\tint ret;\n\tu8 join_state;\n\n\tif (out_len < sizeof(resp))\n\t\treturn -ENOSPC;\n\n\taddr = (struct sockaddr *) &cmd->addr;\n\tif (cmd->addr_size != rdma_addr_size(addr))\n\t\treturn -EINVAL;\n\n\tif (cmd->join_flags == RDMA_MC_JOIN_FLAG_FULLMEMBER)\n\t\tjoin_state = BIT(FULLMEMBER_JOIN);\n\telse if (cmd->join_flags == RDMA_MC_JOIN_FLAG_SENDONLY_FULLMEMBER)\n\t\tjoin_state = BIT(SENDONLY_FULLMEMBER_JOIN);\n\telse\n\t\treturn -EINVAL;\n\n\tctx = ucma_get_ctx_dev(file, cmd->id);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\n\tmutex_lock(&file->mut);\n\tmc = ucma_alloc_multicast(ctx);\n\tif (!mc) {\n\t\tret = -ENOMEM;\n\t\tgoto err1;\n\t}\n\tmc->join_state = join_state;\n\tmc->uid = cmd->uid;\n\tmemcpy(&mc->addr, addr, cmd->addr_size);\n\tret = rdma_join_multicast(ctx->cm_id, (struct sockaddr *)&mc->addr,\n\t\t\t\t  join_state, mc);\n\tif (ret)\n\t\tgoto err2;\n\n\tresp.id = mc->id;\n\tif (copy_to_user(u64_to_user_ptr(cmd->response),\n\t\t\t &resp, sizeof(resp))) {\n\t\tret = -EFAULT;\n \t\tgoto err3;\n \t}\n \n\tmutex_lock(&mut);\n\tidr_replace(&multicast_idr, mc, mc->id);\n\tmutex_unlock(&mut);\n\n \tmutex_unlock(&file->mut);\n \tucma_put_ctx(ctx);\n \treturn 0;\n\nerr3:\n\trdma_leave_multicast(ctx->cm_id, (struct sockaddr *) &mc->addr);\n\tucma_cleanup_mc_events(mc);\nerr2:\n\tmutex_lock(&mut);\n\tidr_remove(&multicast_idr, mc->id);\n\tmutex_unlock(&mut);\n\tlist_del(&mc->list);\n\tkfree(mc);\nerr1:\n\tmutex_unlock(&file->mut);\n\tucma_put_ctx(ctx);\n\treturn ret;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144152,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static bool __oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)\n{\n\tstruct mmu_gather tlb;\n\tstruct vm_area_struct *vma;\n\tbool ret = true;\n\n\t/*\n\t * We have to make sure to not race with the victim exit path\n\t * and cause premature new oom victim selection:\n\t * __oom_reap_task_mm\t\texit_mm\n\t *   mmget_not_zero\n\t *\t\t\t\t  mmput\n\t *\t\t\t\t    atomic_dec_and_test\n\t *\t\t\t\t  exit_oom_victim\n\t *\t\t\t\t[...]\n\t *\t\t\t\tout_of_memory\n\t *\t\t\t\t  select_bad_process\n\t *\t\t\t\t    # no TIF_MEMDIE task selects new victim\n\t *  unmap_page_range # frees some memory\n\t */\n\tmutex_lock(&oom_lock);\n\n\tif (!down_read_trylock(&mm->mmap_sem)) {\n\t\tret = false;\n\t\ttrace_skip_task_reaping(tsk->pid);\n\t\tgoto unlock_oom;\n\t}\n\n\t/*\n\t * If the mm has notifiers then we would need to invalidate them around\n\t * unmap_page_range and that is risky because notifiers can sleep and\n\t * what they do is basically undeterministic.  So let's have a short\n\t * sleep to give the oom victim some more time.\n\t * TODO: we really want to get rid of this ugly hack and make sure that\n\t * notifiers cannot block for unbounded amount of time and add\n\t * mmu_notifier_invalidate_range_{start,end} around unmap_page_range\n\t */\n\tif (mm_has_notifiers(mm)) {\n\t\tup_read(&mm->mmap_sem);\n\t\tschedule_timeout_idle(HZ);\n\t\tgoto unlock_oom;\n\t}\n\n\t/*\n\t * MMF_OOM_SKIP is set by exit_mmap when the OOM reaper can't\n\t * work on the mm anymore. The check for MMF_OOM_SKIP must run\n\t * under mmap_sem for reading because it serializes against the\n\t * down_write();up_write() cycle in exit_mmap().\n\t */\n\tif (test_bit(MMF_OOM_SKIP, &mm->flags)) {\n\t\tup_read(&mm->mmap_sem);\n\t\ttrace_skip_task_reaping(tsk->pid);\n\t\tgoto unlock_oom;\n\t}\n\n\ttrace_start_task_reaping(tsk->pid);\n\n\t/*\n\t * Tell all users of get_user/copy_from_user etc... that the content\n\t * is no longer stable. No barriers really needed because unmapping\n\t * should imply barriers already and the reader would hit a page fault\n\t * if it stumbled over a reaped memory.\n \t */\n \tset_bit(MMF_UNSTABLE, &mm->flags);\n \n\ttlb_gather_mmu(&tlb, mm, 0, -1);\n \tfor (vma = mm->mmap ; vma; vma = vma->vm_next) {\n \t\tif (!can_madv_dontneed_vma(vma))\n \t\t\tcontinue;\n\n\t\t/*\n\t\t * Only anonymous pages have a good chance to be dropped\n\t\t * without additional steps which we cannot afford as we\n\t\t * are OOM already.\n\t\t *\n\t\t * We do not even care about fs backed pages because all\n\t\t * which are reclaimable have already been reclaimed and\n \t\t * we do not want to block exit_mmap by keeping mm ref\n \t\t * count elevated without a good reason.\n \t\t */\n\t\tif (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED))\n \t\t\tunmap_page_range(&tlb, vma, vma->vm_start, vma->vm_end,\n \t\t\t\t\t NULL);\n \t}\n\ttlb_finish_mmu(&tlb, 0, -1);\n \tpr_info(\"oom_reaper: reaped process %d (%s), now anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\\n\",\n \t\t\ttask_pid_nr(tsk), tsk->comm,\n \t\t\tK(get_mm_counter(mm, MM_ANONPAGES)),\n\t\t\tK(get_mm_counter(mm, MM_FILEPAGES)),\n\t\t\tK(get_mm_counter(mm, MM_SHMEMPAGES)));\n\tup_read(&mm->mmap_sem);\n\n\ttrace_finish_task_reaping(tsk->pid);\nunlock_oom:\n\tmutex_unlock(&oom_lock);\n\treturn ret;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144163,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static bool __oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)\n{\n\tstruct mmu_gather tlb;\n\tstruct vm_area_struct *vma;\n\tbool ret = true;\n\n\t/*\n\t * We have to make sure to not race with the victim exit path\n\t * and cause premature new oom victim selection:\n\t * __oom_reap_task_mm\t\texit_mm\n\t *   mmget_not_zero\n\t *\t\t\t\t  mmput\n\t *\t\t\t\t    atomic_dec_and_test\n\t *\t\t\t\t  exit_oom_victim\n\t *\t\t\t\t[...]\n\t *\t\t\t\tout_of_memory\n\t *\t\t\t\t  select_bad_process\n\t *\t\t\t\t    # no TIF_MEMDIE task selects new victim\n\t *  unmap_page_range # frees some memory\n\t */\n\tmutex_lock(&oom_lock);\n\n\tif (!down_read_trylock(&mm->mmap_sem)) {\n\t\tret = false;\n\t\ttrace_skip_task_reaping(tsk->pid);\n\t\tgoto unlock_oom;\n\t}\n\n\t/*\n\t * If the mm has notifiers then we would need to invalidate them around\n\t * unmap_page_range and that is risky because notifiers can sleep and\n\t * what they do is basically undeterministic.  So let's have a short\n\t * sleep to give the oom victim some more time.\n\t * TODO: we really want to get rid of this ugly hack and make sure that\n\t * notifiers cannot block for unbounded amount of time and add\n\t * mmu_notifier_invalidate_range_{start,end} around unmap_page_range\n\t */\n\tif (mm_has_notifiers(mm)) {\n\t\tup_read(&mm->mmap_sem);\n\t\tschedule_timeout_idle(HZ);\n\t\tgoto unlock_oom;\n\t}\n\n\t/*\n\t * MMF_OOM_SKIP is set by exit_mmap when the OOM reaper can't\n\t * work on the mm anymore. The check for MMF_OOM_SKIP must run\n\t * under mmap_sem for reading because it serializes against the\n\t * down_write();up_write() cycle in exit_mmap().\n\t */\n\tif (test_bit(MMF_OOM_SKIP, &mm->flags)) {\n\t\tup_read(&mm->mmap_sem);\n\t\ttrace_skip_task_reaping(tsk->pid);\n\t\tgoto unlock_oom;\n\t}\n\n\ttrace_start_task_reaping(tsk->pid);\n\n\t/*\n\t * Tell all users of get_user/copy_from_user etc... that the content\n\t * is no longer stable. No barriers really needed because unmapping\n\t * should imply barriers already and the reader would hit a page fault\n\t * if it stumbled over a reaped memory.\n \t */\n \tset_bit(MMF_UNSTABLE, &mm->flags);\n \n \tfor (vma = mm->mmap ; vma; vma = vma->vm_next) {\n \t\tif (!can_madv_dontneed_vma(vma))\n \t\t\tcontinue;\n\n\t\t/*\n\t\t * Only anonymous pages have a good chance to be dropped\n\t\t * without additional steps which we cannot afford as we\n\t\t * are OOM already.\n\t\t *\n\t\t * We do not even care about fs backed pages because all\n\t\t * which are reclaimable have already been reclaimed and\n \t\t * we do not want to block exit_mmap by keeping mm ref\n \t\t * count elevated without a good reason.\n \t\t */\n\t\tif (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED)) {\n\t\t\ttlb_gather_mmu(&tlb, mm, vma->vm_start, vma->vm_end);\n \t\t\tunmap_page_range(&tlb, vma, vma->vm_start, vma->vm_end,\n \t\t\t\t\t NULL);\n\t\t\ttlb_finish_mmu(&tlb, vma->vm_start, vma->vm_end);\n\t\t}\n \t}\n \tpr_info(\"oom_reaper: reaped process %d (%s), now anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\\n\",\n \t\t\ttask_pid_nr(tsk), tsk->comm,\n \t\t\tK(get_mm_counter(mm, MM_ANONPAGES)),\n\t\t\tK(get_mm_counter(mm, MM_FILEPAGES)),\n\t\t\tK(get_mm_counter(mm, MM_SHMEMPAGES)));\n\tup_read(&mm->mmap_sem);\n\n\ttrace_finish_task_reaping(tsk->pid);\nunlock_oom:\n\tmutex_unlock(&oom_lock);\n\treturn ret;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144164,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "vips_foreign_load_gif_scan_image( VipsForeignLoadGif *gif ) \n {\n \tVipsObjectClass *class = VIPS_OBJECT_GET_CLASS( gif );\n \tGifFileType *file = gif->file;\n\tColorMapObject *map = file->Image.ColorMap ?\n\t\tfile->Image.ColorMap : file->SColorMap;\n \n \tGifByteType *extension;\n \n \tif( DGifGetImageDesc( gif->file ) == GIF_ERROR ) {\n\t\tvips_foreign_load_gif_error( gif ); \n\t\treturn( -1 );\n\t}\n\n\t/* Check that the frame looks sane. Perhaps giflib checks\n\t * this for us.\n\t */\n\tif( file->Image.Left < 0 ||\n\t\tfile->Image.Width < 1 ||\n\t\tfile->Image.Width > 10000 ||\n\t\tfile->Image.Left + file->Image.Width > file->SWidth ||\n\t\tfile->Image.Top < 0 ||\n\t\tfile->Image.Height < 1 ||\n\t\tfile->Image.Height > 10000 ||\n\t\tfile->Image.Top + file->Image.Height > file->SHeight ) {\n\t\tvips_error( class->nickname, \"%s\", _( \"bad frame size\" ) ); \n\t\treturn( -1 ); \n\t}\n \n \t/* Test for a non-greyscale colourmap for this frame.\n \t */\n \tif( !gif->has_colour &&\n \t\tmap ) {\n \t\tint i;\n\n\t\tfor( i = 0; i < map->ColorCount; i++ ) \n\t\t\tif( map->Colors[i].Red != map->Colors[i].Green ||\n\t\t\t\tmap->Colors[i].Green != map->Colors[i].Blue ) {\n\t\t\t\tgif->has_colour = TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\t/* Step over compressed image data.\n\t */\n\tdo {\n\t\tif( vips_foreign_load_gif_code_next( gif, &extension ) ) \n\t\t\treturn( -1 );\n\t} while( extension != NULL );\n\n\treturn( 0 );\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144169,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "vips_foreign_load_gif_scan_image( VipsForeignLoadGif *gif ) \n {\n \tVipsObjectClass *class = VIPS_OBJECT_GET_CLASS( gif );\n \tGifFileType *file = gif->file;\n \n\tColorMapObject *map;\n \tGifByteType *extension;\n \n \tif( DGifGetImageDesc( gif->file ) == GIF_ERROR ) {\n\t\tvips_foreign_load_gif_error( gif ); \n\t\treturn( -1 );\n\t}\n\n\t/* Check that the frame looks sane. Perhaps giflib checks\n\t * this for us.\n\t */\n\tif( file->Image.Left < 0 ||\n\t\tfile->Image.Width < 1 ||\n\t\tfile->Image.Width > 10000 ||\n\t\tfile->Image.Left + file->Image.Width > file->SWidth ||\n\t\tfile->Image.Top < 0 ||\n\t\tfile->Image.Height < 1 ||\n\t\tfile->Image.Height > 10000 ||\n\t\tfile->Image.Top + file->Image.Height > file->SHeight ) {\n\t\tvips_error( class->nickname, \"%s\", _( \"bad frame size\" ) ); \n\t\treturn( -1 ); \n\t}\n \n \t/* Test for a non-greyscale colourmap for this frame.\n \t */\n\tmap = file->Image.ColorMap ? file->Image.ColorMap : file->SColorMap;\n \tif( !gif->has_colour &&\n \t\tmap ) {\n \t\tint i;\n\n\t\tfor( i = 0; i < map->ColorCount; i++ ) \n\t\t\tif( map->Colors[i].Red != map->Colors[i].Green ||\n\t\t\t\tmap->Colors[i].Green != map->Colors[i].Blue ) {\n\t\t\t\tgif->has_colour = TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\t/* Step over compressed image data.\n\t */\n\tdo {\n\t\tif( vips_foreign_load_gif_code_next( gif, &extension ) ) \n\t\t\treturn( -1 );\n\t} while( extension != NULL );\n\n\treturn( 0 );\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144170,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "ProfilingProcessHost::Mode ProfilingProcessHost::GetCurrentMode() {\n  const base::CommandLine* cmdline = base::CommandLine::ForCurrentProcess();\n#if BUILDFLAG(USE_ALLOCATOR_SHIM)\n  if (cmdline->HasSwitch(switches::kMemlog) ||\n      base::FeatureList::IsEnabled(kOOPHeapProfilingFeature)) {\n    if (cmdline->HasSwitch(switches::kEnableHeapProfiling)) {\n      LOG(ERROR) << \"--\" << switches::kEnableHeapProfiling\n                 << \" specified with --\" << switches::kMemlog\n                 << \"which are not compatible. Memlog will be disabled.\";\n      return Mode::kNone;\n    }\n\n    std::string mode;\n    if (cmdline->HasSwitch(switches::kMemlog)) {\n      mode = cmdline->GetSwitchValueASCII(switches::kMemlog);\n    } else {\n      mode = base::GetFieldTrialParamValueByFeature(\n           kOOPHeapProfilingFeature, kOOPHeapProfilingFeatureMode);\n     }\n \n    if (mode == switches::kMemlogModeAll)\n      return Mode::kAll;\n    if (mode == switches::kMemlogModeMinimal)\n      return Mode::kMinimal;\n    if (mode == switches::kMemlogModeBrowser)\n      return Mode::kBrowser;\n    if (mode == switches::kMemlogModeGpu)\n      return Mode::kGpu;\n    if (mode == switches::kMemlogModeRendererSampling)\n      return Mode::kRendererSampling;\n    DLOG(ERROR) << \"Unsupported value: \\\"\" << mode << \"\\\" passed to --\"\n                << switches::kMemlog;\n   }\n   return Mode::kNone;\n #else\n  LOG_IF(ERROR, cmdline->HasSwitch(switches::kMemlog))\n      << \"--\" << switches::kMemlog\n      << \" specified but it will have no effect because the use_allocator_shim \"\n      << \"is not available in this build.\";\n  return Mode::kNone;\n #endif\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144245,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "ProfilingProcessHost::Mode ProfilingProcessHost::GetCurrentMode() {\n  const base::CommandLine* cmdline = base::CommandLine::ForCurrentProcess();\n#if BUILDFLAG(USE_ALLOCATOR_SHIM)\n  if (cmdline->HasSwitch(switches::kMemlog) ||\n      base::FeatureList::IsEnabled(kOOPHeapProfilingFeature)) {\n    if (cmdline->HasSwitch(switches::kEnableHeapProfiling)) {\n      LOG(ERROR) << \"--\" << switches::kEnableHeapProfiling\n                 << \" specified with --\" << switches::kMemlog\n                 << \"which are not compatible. Memlog will be disabled.\";\n      return Mode::kNone;\n    }\n\n    std::string mode;\n    if (cmdline->HasSwitch(switches::kMemlog)) {\n      mode = cmdline->GetSwitchValueASCII(switches::kMemlog);\n    } else {\n      mode = base::GetFieldTrialParamValueByFeature(\n           kOOPHeapProfilingFeature, kOOPHeapProfilingFeatureMode);\n     }\n \n    return ConvertStringToMode(mode);\n   }\n   return Mode::kNone;\n #else\n  LOG_IF(ERROR, cmdline->HasSwitch(switches::kMemlog))\n      << \"--\" << switches::kMemlog\n      << \" specified but it will have no effect because the use_allocator_shim \"\n      << \"is not available in this build.\";\n  return Mode::kNone;\n #endif\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144246,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "vmxnet3_io_bar0_write(void *opaque, hwaddr addr,\n                      uint64_t val, unsigned size)\n {\n     VMXNET3State *s = opaque;\n \n     if (VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_TXPROD,\n                         VMXNET3_DEVICE_MAX_TX_QUEUES, VMXNET3_REG_ALIGN)) {\n         int tx_queue_idx =\n        return;\n    }\n\n    if (VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_IMR,\n                        VMXNET3_MAX_INTRS, VMXNET3_REG_ALIGN)) {\n        int l = VMW_MULTIREG_IDX_BY_ADDR(addr, VMXNET3_REG_IMR,\n                                         VMXNET3_REG_ALIGN);\n\n        VMW_CBPRN(\"Interrupt mask for line %d written: 0x%\" PRIx64, l, val);\n\n        vmxnet3_on_interrupt_mask_changed(s, l, val);\n        return;\n    }\n\n    if (VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_RXPROD,\n                        VMXNET3_DEVICE_MAX_RX_QUEUES, VMXNET3_REG_ALIGN) ||\n       VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_RXPROD2,\n                        VMXNET3_DEVICE_MAX_RX_QUEUES, VMXNET3_REG_ALIGN)) {\n        return;\n    }\n\n    VMW_WRPRN(\"BAR0 unknown write [%\" PRIx64 \"] = %\" PRIx64 \", size %d\",\n              (uint64_t) addr, val, size);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144335,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "vmxnet3_io_bar0_write(void *opaque, hwaddr addr,\n                      uint64_t val, unsigned size)\n {\n     VMXNET3State *s = opaque;\n \n    if (!s->device_active) {\n        return;\n    }\n\n     if (VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_TXPROD,\n                         VMXNET3_DEVICE_MAX_TX_QUEUES, VMXNET3_REG_ALIGN)) {\n         int tx_queue_idx =\n        return;\n    }\n\n    if (VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_IMR,\n                        VMXNET3_MAX_INTRS, VMXNET3_REG_ALIGN)) {\n        int l = VMW_MULTIREG_IDX_BY_ADDR(addr, VMXNET3_REG_IMR,\n                                         VMXNET3_REG_ALIGN);\n\n        VMW_CBPRN(\"Interrupt mask for line %d written: 0x%\" PRIx64, l, val);\n\n        vmxnet3_on_interrupt_mask_changed(s, l, val);\n        return;\n    }\n\n    if (VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_RXPROD,\n                        VMXNET3_DEVICE_MAX_RX_QUEUES, VMXNET3_REG_ALIGN) ||\n       VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_RXPROD2,\n                        VMXNET3_DEVICE_MAX_RX_QUEUES, VMXNET3_REG_ALIGN)) {\n        return;\n    }\n\n    VMW_WRPRN(\"BAR0 unknown write [%\" PRIx64 \"] = %\" PRIx64 \", size %d\",\n              (uint64_t) addr, val, size);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144336,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "PS_SERIALIZER_DECODE_FUNC(php_binary) /* {{{ */\n{\n\tconst char *p;\n\tchar *name;\n\tconst char *endptr = val + vallen;\n\tzval *current;\n\tint namelen;\n\tint has_value;\n\tphp_unserialize_data_t var_hash;\n\n\tPHP_VAR_UNSERIALIZE_INIT(var_hash);\n\n\tfor (p = val; p < endptr; ) {\n\t\tzval **tmp;\n                namelen = ((unsigned char)(*p)) & (~PS_BIN_UNDEF);\n \n                if (namelen < 0 || namelen > PS_BIN_MAX || (p + namelen) >= endptr) {\n                        return FAILURE;\n                }\n\n\t\tname = estrndup(p + 1, namelen);\n\n\t\tp += namelen + 1;\n\n\t\tif (zend_hash_find(&EG(symbol_table), name, namelen + 1, (void **) &tmp) == SUCCESS) {\n\t\t\tif ((Z_TYPE_PP(tmp) == IS_ARRAY && Z_ARRVAL_PP(tmp) == &EG(symbol_table)) || *tmp == PS(http_session_vars)) {\n\t\t\t\tefree(name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (has_value) {\n\t\t\tALLOC_INIT_ZVAL(current);\n\t\t\tif (php_var_unserialize(&current, (const unsigned char **) &p, (const unsigned char *) endptr, &var_hash TSRMLS_CC)) {\n\t\t\t\tphp_set_session_var(name, namelen, current, &var_hash  TSRMLS_CC);\n\t\t\t} else {\n\t\t\t\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tvar_push_dtor_no_addref(&var_hash, &current);\n\t\t}\n\t\tPS_ADD_VARL(name, namelen);\n\t\tefree(name);\n\t}\n\n\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\n\treturn SUCCESS;\n}\n/* }}} */\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144339,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "PS_SERIALIZER_DECODE_FUNC(php_binary) /* {{{ */\n{\n\tconst char *p;\n\tchar *name;\n\tconst char *endptr = val + vallen;\n\tzval *current;\n\tint namelen;\n\tint has_value;\n\tphp_unserialize_data_t var_hash;\n\n\tPHP_VAR_UNSERIALIZE_INIT(var_hash);\n\n\tfor (p = val; p < endptr; ) {\n\t\tzval **tmp;\n                namelen = ((unsigned char)(*p)) & (~PS_BIN_UNDEF);\n \n                if (namelen < 0 || namelen > PS_BIN_MAX || (p + namelen) >= endptr) {\n                       PHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n                        return FAILURE;\n                }\n\n\t\tname = estrndup(p + 1, namelen);\n\n\t\tp += namelen + 1;\n\n\t\tif (zend_hash_find(&EG(symbol_table), name, namelen + 1, (void **) &tmp) == SUCCESS) {\n\t\t\tif ((Z_TYPE_PP(tmp) == IS_ARRAY && Z_ARRVAL_PP(tmp) == &EG(symbol_table)) || *tmp == PS(http_session_vars)) {\n\t\t\t\tefree(name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (has_value) {\n\t\t\tALLOC_INIT_ZVAL(current);\n\t\t\tif (php_var_unserialize(&current, (const unsigned char **) &p, (const unsigned char *) endptr, &var_hash TSRMLS_CC)) {\n\t\t\t\tphp_set_session_var(name, namelen, current, &var_hash  TSRMLS_CC);\n\t\t\t} else {\n\t\t\t\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tvar_push_dtor_no_addref(&var_hash, &current);\n\t\t}\n\t\tPS_ADD_VARL(name, namelen);\n\t\tefree(name);\n\t}\n\n\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\n\treturn SUCCESS;\n}\n/* }}} */\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144340,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "INST_HANDLER (cpse) {\t// CPSE Rd, Rr\n\tint r = (buf[0] & 0xf) | ((buf[1] & 0x2) << 3);\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n\tRAnalOp next_op;\n\n\t// calculate next instruction size (call recursively avr_op_analyze)\n\t// and free next_op's esil string (we dont need it now)\n\tavr_op_analyze (anal,\n\t\t\t&next_op,\n\t\t\top->addr + op->size, buf + op->size, len - op->size,\n\t\t\tcpu);\n\tr_strbuf_fini (&next_op.esil);\n\top->jump = op->addr + next_op.size + 2;\n\n\t// cycles\n\top->cycles = 1;\t// XXX: This is a bug, because depends on eval state,\n\t\t\t// so it cannot be really be known until this\n\t\t\t// instruction is executed by the ESIL interpreter!!!\n\t\t\t// In case of evaluating to true, this instruction\n\t\t\t// needs 2/3 cycles, elsewhere it needs only 1 cycle.\n\tESIL_A (\"r%d,r%d,^,!,\", r, d);\t\t\t// Rr == Rd\n\tESIL_A (\"?{,%\"PFMT64d\",pc,=,},\", op->jump);\t// ?true => jmp\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144597,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "INST_HANDLER (sbrx) {\t// SBRC Rr, b\n\tint b = buf[0] & 0x7;\n\tint r = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x01) << 4);\n\tRAnalOp next_op = {0};\n\n\tavr_op_analyze (anal,\n\t\t\t&next_op,\n\t\t\top->addr + op->size, buf + op->size, len - op->size,\n\t\t\tcpu);\n\tr_strbuf_fini (&next_op.esil);\n\top->jump = op->addr + next_op.size + 2;\n\n\top->cycles = 1;\t// XXX: This is a bug, because depends on eval state,\n\tESIL_A (\"%d,1,<<,r%d,&,\", b, r);\t\t\t// Rr(b)\n\tESIL_A ((buf[1] & 0xe) == 0xc\n\t\t\t? \"!,\"\t\t// SBRC => branch if cleared\n\t\t\t: \"!,!,\");\t// SBRS => branch if set\n\tESIL_A (\"?{,%\"PFMT64d\",pc,=,},\", op->jump);\t// ?true => jmp\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144598,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static Image *ReadPWPImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  FILE\n    *file;\n\n  Image\n    *image,\n    *next_image,\n    *pwp_image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    c,\n    unique_file;\n\n  MagickBooleanType\n    status;\n\n  register Image\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    filesize,\n    length;\n\n  ssize_t\n    count;\n\n  unsigned char\n    magick[MagickPathExtent];\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  pwp_image=AcquireImage(image_info,exception);\n  image=pwp_image;\n  status=OpenBlob(image_info,pwp_image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return((Image *) NULL);\n  count=ReadBlob(pwp_image,5,magick);\n  if ((count != 5) || (LocaleNCompare((char *) magick,\"SFW95\",5) != 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  read_info=CloneImageInfo(image_info);\n  (void) SetImageInfoProgressMonitor(read_info,(MagickProgressMonitor) NULL,\n    (void *) NULL);\n  SetImageInfoBlob(read_info,(void *) NULL,0);\n  unique_file=AcquireUniqueFileResource(read_info->filename);\n  for ( ; ; )\n  {\n    for (c=ReadBlobByte(pwp_image); c != EOF; c=ReadBlobByte(pwp_image))\n    {\n      for (i=0; i < 17; i++)\n        magick[i]=magick[i+1];\n      magick[17]=(unsigned char) c;\n      if (LocaleNCompare((char *) (magick+12),\"SFW94A\",6) == 0)\n        break;\n    }\n    if (c == EOF)\n      break;\n    if (LocaleNCompare((char *) (magick+12),\"SFW94A\",6) != 0)\n      {\n        (void) RelinquishUniqueFileResource(read_info->filename);\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n    /*\n      Dump SFW image to a temporary file.\n    */\n    file=(FILE *) NULL;\n    if (unique_file != -1)\n      file=fdopen(unique_file,\"wb\");\n    if ((unique_file == -1) || (file == (FILE *) NULL))\n      {\n        (void) RelinquishUniqueFileResource(read_info->filename);\n        ThrowFileException(exception,FileOpenError,\"UnableToWriteFile\",\n          image->filename);\n        image=DestroyImageList(image);\n        return((Image *) NULL);\n      }\n    length=fwrite(\"SFW94A\",1,6,file);\n    (void) length;\n    filesize=65535UL*magick[2]+256L*magick[1]+magick[0];\n    for (i=0; i < (ssize_t) filesize; i++)\n    {\n      c=ReadBlobByte(pwp_image);\n      (void) fputc(c,file);\n    }\n    (void) fclose(file);\n    next_image=ReadImage(read_info,exception);\n    if (next_image == (Image *) NULL)\n      break;\n    (void) FormatLocaleString(next_image->filename,MagickPathExtent,\n      \"slide_%02ld.sfw\",(long) next_image->scene);\n    if (image == (Image *) NULL)\n      image=next_image;\n    else\n      {\n        /*\n          Link image into image list.\n        */\n        for (p=image; p->next != (Image *) NULL; p=GetNextImageInList(p)) ;\n        next_image->previous=p;\n        next_image->scene=p->scene+1;\n        p->next=next_image;\n      }\n    if (image_info->number_scenes != 0)\n      if (next_image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageProgress(image,LoadImagesTag,TellBlob(pwp_image),\n      GetBlobSize(pwp_image));\n    if (status == MagickFalse)\n      break;\n  }\n  if (unique_file != -1)\n    (void) close(unique_file);\n  (void) RelinquishUniqueFileResource(read_info->filename);\n  read_info=DestroyImageInfo(read_info);\n  (void) CloseBlob(pwp_image);\n  pwp_image=DestroyImage(pwp_image);\n  if (EOFBlob(image) != MagickFalse)\n    {\n      char\n        *message;\n\n      message=GetExceptionMessage(errno);\n      (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,\n        \"UnexpectedEndOfFile\",\"`%s': %s\",image->filename,message);\n      message=DestroyString(message);\n    }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144677,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static Image *ReadPWPImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  FILE\n    *file;\n\n  Image\n    *image,\n    *next_image,\n    *pwp_image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    c,\n    unique_file;\n\n  MagickBooleanType\n    status;\n\n  register Image\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    filesize,\n    length;\n\n  ssize_t\n    count;\n\n  unsigned char\n    magick[MagickPathExtent];\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  pwp_image=AcquireImage(image_info,exception);\n  image=pwp_image;\n  status=OpenBlob(image_info,pwp_image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return((Image *) NULL);\n  count=ReadBlob(pwp_image,5,magick);\n  if ((count != 5) || (LocaleNCompare((char *) magick,\"SFW95\",5) != 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  read_info=CloneImageInfo(image_info);\n  (void) SetImageInfoProgressMonitor(read_info,(MagickProgressMonitor) NULL,\n    (void *) NULL);\n  SetImageInfoBlob(read_info,(void *) NULL,0);\n  unique_file=AcquireUniqueFileResource(read_info->filename);\n  for ( ; ; )\n  {\n    for (c=ReadBlobByte(pwp_image); c != EOF; c=ReadBlobByte(pwp_image))\n    {\n      for (i=0; i < 17; i++)\n        magick[i]=magick[i+1];\n      magick[17]=(unsigned char) c;\n      if (LocaleNCompare((char *) (magick+12),\"SFW94A\",6) == 0)\n        break;\n    }\n    if (c == EOF)\n      break;\n    if (LocaleNCompare((char *) (magick+12),\"SFW94A\",6) != 0)\n      {\n        (void) RelinquishUniqueFileResource(read_info->filename);\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n    /*\n      Dump SFW image to a temporary file.\n    */\n    file=(FILE *) NULL;\n    if (unique_file != -1)\n      file=fdopen(unique_file,\"wb\");\n    if ((unique_file == -1) || (file == (FILE *) NULL))\n      {\n        (void) RelinquishUniqueFileResource(read_info->filename);\n        ThrowFileException(exception,FileOpenError,\"UnableToWriteFile\",\n          image->filename);\n        image=DestroyImageList(image);\n        return((Image *) NULL);\n      }\n    length=fwrite(\"SFW94A\",1,6,file);\n    (void) length;\n    filesize=65535UL*magick[2]+256L*magick[1]+magick[0];\n    for (i=0; i < (ssize_t) filesize; i++)\n    {\n      c=ReadBlobByte(pwp_image);\n      (void) fputc(c,file);\n    }\n    (void) fclose(file);\n    next_image=ReadImage(read_info,exception);\n    if (next_image == (Image *) NULL)\n      break;\n    (void) FormatLocaleString(next_image->filename,MagickPathExtent,\n      \"slide_%02ld.sfw\",(long) next_image->scene);\n    if (image == (Image *) NULL)\n      image=next_image;\n    else\n      {\n        /*\n          Link image into image list.\n        */\n        for (p=image; p->next != (Image *) NULL; p=GetNextImageInList(p)) ;\n        next_image->previous=p;\n        next_image->scene=p->scene+1;\n        p->next=next_image;\n      }\n    if (image_info->number_scenes != 0)\n      if (next_image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageProgress(image,LoadImagesTag,TellBlob(pwp_image),\n      GetBlobSize(pwp_image));\n    if (status == MagickFalse)\n      break;\n  }\n  if (unique_file != -1)\n    (void) close(unique_file);\n  (void) RelinquishUniqueFileResource(read_info->filename);\n  read_info=DestroyImageInfo(read_info);\n  if (EOFBlob(image) != MagickFalse)\n    {\n      char\n        *message;\n\n      message=GetExceptionMessage(errno);\n      (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,\n        \"UnexpectedEndOfFile\",\"`%s': %s\",image->filename,message);\n      message=DestroyString(message);\n    }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144678,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "MagickExport MagickBooleanType SetImageType(Image *image,const ImageType type,\n  ExceptionInfo *exception)\n{\n  const char\n    *artifact;\n\n  ImageInfo\n    *image_info;\n\n  MagickBooleanType\n    status;\n\n  QuantizeInfo\n    *quantize_info;\n\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image->signature == MagickCoreSignature);\n  status=MagickTrue;\n  image_info=AcquireImageInfo();\n  image_info->dither=image->dither;\n  artifact=GetImageArtifact(image,\"dither\");\n  if (artifact != (const char *) NULL)\n    (void) SetImageOption(image_info,\"dither\",artifact);\n  switch (type)\n  {\n    case BilevelType:\n    {\n      if (SetImageMonochrome(image,exception) == MagickFalse)\n        {\n          status=TransformImageColorspace(image,GRAYColorspace,exception);\n          (void) NormalizeImage(image,exception);\n          quantize_info=AcquireQuantizeInfo(image_info);\n          quantize_info->number_colors=2;\n          quantize_info->colorspace=GRAYColorspace;\n          status=QuantizeImage(quantize_info,image,exception);\n          quantize_info=DestroyQuantizeInfo(quantize_info);\n        }\n      image->colors=2;\n      image->alpha_trait=UndefinedPixelTrait;\n      break;\n    }\n    case GrayscaleType:\n    {\n      if (SetImageGray(image,exception) == MagickFalse)\n        status=TransformImageColorspace(image,GRAYColorspace,exception);\n      image->alpha_trait=UndefinedPixelTrait;\n      break;\n    }\n    case GrayscaleAlphaType:\n    {\n      if (SetImageGray(image,exception) == MagickFalse)\n        status=TransformImageColorspace(image,GRAYColorspace,exception);\n      if (image->alpha_trait == UndefinedPixelTrait)\n        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);\n      break;\n    }\n    case PaletteType:\n    {\n      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n        status=TransformImageColorspace(image,sRGBColorspace,exception);\n      if ((image->storage_class == DirectClass) || (image->colors > 256))\n        {\n          quantize_info=AcquireQuantizeInfo(image_info);\n          quantize_info->number_colors=256;\n          status=QuantizeImage(quantize_info,image,exception);\n          quantize_info=DestroyQuantizeInfo(quantize_info);\n        }\n      image->alpha_trait=UndefinedPixelTrait;\n      break;\n    }\n    case PaletteBilevelAlphaType:\n    {\n      ChannelType\n        channel_mask;\n\n      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n        status=TransformImageColorspace(image,sRGBColorspace,exception);\n      if (image->alpha_trait == UndefinedPixelTrait)\n        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);\n      channel_mask=SetImageChannelMask(image,AlphaChannel);\n      (void) BilevelImage(image,(double) QuantumRange/2.0,exception);\n      (void) SetImageChannelMask(image,channel_mask);\n      quantize_info=AcquireQuantizeInfo(image_info);\n      status=QuantizeImage(quantize_info,image,exception);\n      quantize_info=DestroyQuantizeInfo(quantize_info);\n      break;\n    }\n    case PaletteAlphaType:\n    {\n      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n        status=TransformImageColorspace(image,sRGBColorspace,exception);\n      if (image->alpha_trait == UndefinedPixelTrait)\n        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);\n      quantize_info=AcquireQuantizeInfo(image_info);\n      quantize_info->colorspace=TransparentColorspace;\n      status=QuantizeImage(quantize_info,image,exception);\n      quantize_info=DestroyQuantizeInfo(quantize_info);\n      break;\n    }\n    case TrueColorType:\n    {\n      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n        status=TransformImageColorspace(image,sRGBColorspace,exception);\n      if (image->storage_class != DirectClass)\n        status=SetImageStorageClass(image,DirectClass,exception);\n      image->alpha_trait=UndefinedPixelTrait;\n      break;\n    }\n    case TrueColorAlphaType:\n    {\n      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n        status=TransformImageColorspace(image,sRGBColorspace,exception);\n      if (image->storage_class != DirectClass)\n        status=SetImageStorageClass(image,DirectClass,exception);\n      if (image->alpha_trait == UndefinedPixelTrait)\n        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);\n      break;\n    }\n    case ColorSeparationType:\n    {\n      if (image->colorspace != CMYKColorspace)\n        {\n          if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n            status=TransformImageColorspace(image,sRGBColorspace,exception);\n          status=TransformImageColorspace(image,CMYKColorspace,exception);\n        }\n      if (image->storage_class != DirectClass)\n        status=SetImageStorageClass(image,DirectClass,exception);\n      image->alpha_trait=UndefinedPixelTrait;\n      break;\n    }\n    case ColorSeparationAlphaType:\n    {\n      if (image->colorspace != CMYKColorspace)\n        {\n          if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n            status=TransformImageColorspace(image,sRGBColorspace,exception);\n          status=TransformImageColorspace(image,CMYKColorspace,exception);\n        }\n      if (image->storage_class != DirectClass)\n        status=SetImageStorageClass(image,DirectClass,exception);\n      if (image->alpha_trait == UndefinedPixelTrait)\n        status=SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);\n      break;\n    }\n    case OptimizeType:\n    case UndefinedType:\n      break;\n  }\n  image_info=DestroyImageInfo(image_info);\n  if (status == MagickFalse)\n    return(status);\n  image->type=type;\n  return(MagickTrue);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144729,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "MagickExport MagickBooleanType SetImageType(Image *image,const ImageType type,\n  ExceptionInfo *exception)\n{\n  const char\n    *artifact;\n\n  ImageInfo\n    *image_info;\n\n  MagickBooleanType\n    status;\n\n  QuantizeInfo\n    *quantize_info;\n\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image->signature == MagickCoreSignature);\n  status=MagickTrue;\n  image_info=AcquireImageInfo();\n  image_info->dither=image->dither;\n  artifact=GetImageArtifact(image,\"dither\");\n  if (artifact != (const char *) NULL)\n    (void) SetImageOption(image_info,\"dither\",artifact);\n  switch (type)\n  {\n    case BilevelType:\n    {\n      if (SetImageMonochrome(image,exception) == MagickFalse)\n        {\n          status=TransformImageColorspace(image,GRAYColorspace,exception);\n          (void) NormalizeImage(image,exception);\n          quantize_info=AcquireQuantizeInfo(image_info);\n          quantize_info->number_colors=2;\n          quantize_info->colorspace=GRAYColorspace;\n          status=QuantizeImage(quantize_info,image,exception);\n          quantize_info=DestroyQuantizeInfo(quantize_info);\n        }\n      status=AcquireImageColormap(image,2,exception);\n      image->alpha_trait=UndefinedPixelTrait;\n      break;\n    }\n    case GrayscaleType:\n    {\n      if (SetImageGray(image,exception) == MagickFalse)\n        status=TransformImageColorspace(image,GRAYColorspace,exception);\n      image->alpha_trait=UndefinedPixelTrait;\n      break;\n    }\n    case GrayscaleAlphaType:\n    {\n      if (SetImageGray(image,exception) == MagickFalse)\n        status=TransformImageColorspace(image,GRAYColorspace,exception);\n      if (image->alpha_trait == UndefinedPixelTrait)\n        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);\n      break;\n    }\n    case PaletteType:\n    {\n      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n        status=TransformImageColorspace(image,sRGBColorspace,exception);\n      if ((image->storage_class == DirectClass) || (image->colors > 256))\n        {\n          quantize_info=AcquireQuantizeInfo(image_info);\n          quantize_info->number_colors=256;\n          status=QuantizeImage(quantize_info,image,exception);\n          quantize_info=DestroyQuantizeInfo(quantize_info);\n        }\n      image->alpha_trait=UndefinedPixelTrait;\n      break;\n    }\n    case PaletteBilevelAlphaType:\n    {\n      ChannelType\n        channel_mask;\n\n      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n        status=TransformImageColorspace(image,sRGBColorspace,exception);\n      if (image->alpha_trait == UndefinedPixelTrait)\n        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);\n      channel_mask=SetImageChannelMask(image,AlphaChannel);\n      (void) BilevelImage(image,(double) QuantumRange/2.0,exception);\n      (void) SetImageChannelMask(image,channel_mask);\n      quantize_info=AcquireQuantizeInfo(image_info);\n      status=QuantizeImage(quantize_info,image,exception);\n      quantize_info=DestroyQuantizeInfo(quantize_info);\n      break;\n    }\n    case PaletteAlphaType:\n    {\n      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n        status=TransformImageColorspace(image,sRGBColorspace,exception);\n      if (image->alpha_trait == UndefinedPixelTrait)\n        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);\n      quantize_info=AcquireQuantizeInfo(image_info);\n      quantize_info->colorspace=TransparentColorspace;\n      status=QuantizeImage(quantize_info,image,exception);\n      quantize_info=DestroyQuantizeInfo(quantize_info);\n      break;\n    }\n    case TrueColorType:\n    {\n      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n        status=TransformImageColorspace(image,sRGBColorspace,exception);\n      if (image->storage_class != DirectClass)\n        status=SetImageStorageClass(image,DirectClass,exception);\n      image->alpha_trait=UndefinedPixelTrait;\n      break;\n    }\n    case TrueColorAlphaType:\n    {\n      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n        status=TransformImageColorspace(image,sRGBColorspace,exception);\n      if (image->storage_class != DirectClass)\n        status=SetImageStorageClass(image,DirectClass,exception);\n      if (image->alpha_trait == UndefinedPixelTrait)\n        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);\n      break;\n    }\n    case ColorSeparationType:\n    {\n      if (image->colorspace != CMYKColorspace)\n        {\n          if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n            status=TransformImageColorspace(image,sRGBColorspace,exception);\n          status=TransformImageColorspace(image,CMYKColorspace,exception);\n        }\n      if (image->storage_class != DirectClass)\n        status=SetImageStorageClass(image,DirectClass,exception);\n      image->alpha_trait=UndefinedPixelTrait;\n      break;\n    }\n    case ColorSeparationAlphaType:\n    {\n      if (image->colorspace != CMYKColorspace)\n        {\n          if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n            status=TransformImageColorspace(image,sRGBColorspace,exception);\n          status=TransformImageColorspace(image,CMYKColorspace,exception);\n        }\n      if (image->storage_class != DirectClass)\n        status=SetImageStorageClass(image,DirectClass,exception);\n      if (image->alpha_trait == UndefinedPixelTrait)\n        status=SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);\n      break;\n    }\n    case OptimizeType:\n    case UndefinedType:\n      break;\n  }\n  image_info=DestroyImageInfo(image_info);\n  if (status == MagickFalse)\n    return(status);\n  image->type=type;\n  return(MagickTrue);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144730,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static inline void get_page(struct page *page)\n{\n\tpage = compound_head(page);\n\t/*\n\t * Getting a normal page or the head of a compound page\n\t * requires to already have an elevated page->_refcount.\n\t */\n\tVM_BUG_ON_PAGE(page_ref_count(page) <= 0, page);\n\tpage_ref_inc(page);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144769,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static inline void get_page(struct page *page)\n{\n\tpage = compound_head(page);\n\t/*\n\t * Getting a normal page or the head of a compound page\n\t * requires to already have an elevated page->_refcount.\n\t */\n\tVM_BUG_ON_PAGE(page_ref_zero_or_close_to_overflow(page), page);\n\tpage_ref_inc(page);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144770,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\tSilenceMessage(const std::string& mask, const std::string& flags)\n\t\t: ClientProtocol::Message(\"SILENCE\")\n\t{\n\t\tPushParam(mask);\n\t\tPushParamRef(flags);\n\t}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144902,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\tSilenceMessage(const std::string& mask, const std::string& flags)\n\t\t: ClientProtocol::Message(\"SILENCE\")\n\t{\n\t\tPushParam(mask);\n\t\tPushParam(flags);\n\t}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144903,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "DNSResult DNS::GetResult()\n{\n\t/* Fetch dns query response and decide where it belongs */\n\tDNSHeader header;\n\tDNSRequest *req;\n\tunsigned char buffer[sizeof(DNSHeader)];\n\tirc::sockets::sockaddrs from;\n\tmemset(&from, 0, sizeof(from));\n\tsocklen_t x = sizeof(from);\n\n\tint length = ServerInstance->SE->RecvFrom(this, (char*)buffer, sizeof(DNSHeader), 0, &from.sa, &x);\n\n\t/* Did we get the whole header? */\n\tif (length < 12)\n\t{\n\t\tServerInstance->Logs->Log(\"RESOLVER\",DEBUG,\"GetResult didn't get a full packet (len=%d)\", length);\n\t\t/* Nope - something screwed up. */\n\t\treturn DNSResult(-1,\"\",0,\"\");\n\t}\n\n\t/* Check wether the reply came from a different DNS\n\t * server to the one we sent it to, or the source-port\n\t * is not 53.\n\t * A user could in theory still spoof dns packets anyway\n\t * but this is less trivial than just sending garbage\n\t * to the server, which is possible without this check.\n\t *\n\t * -- Thanks jilles for pointing this one out.\n\t */\n\tif (from != myserver)\n\t{\n\t\tstd::string server1 = from.str();\n\t\tstd::string server2 = myserver.str();\n\t\tServerInstance->Logs->Log(\"RESOLVER\",DEBUG,\"Got a result from the wrong server! Bad NAT or DNS forging attempt? '%s' != '%s'\",\n\t\t\tserver1.c_str(), server2.c_str());\n\t\treturn DNSResult(-1,\"\",0,\"\");\n\t}\n\n\t/* Put the read header info into a header class */\n\tDNS::FillHeader(&header,buffer,length - 12);\n\n\t/* Get the id of this request.\n\t * Its a 16 bit value stored in two char's,\n\t * so we use logic shifts to create the value.\n\t */\n\tunsigned long this_id = header.id[1] + (header.id[0] << 8);\n\n\t/* Do we have a pending request matching this id? */\n\tif (!requests[this_id])\n\t{\n\t\t/* Somehow we got a DNS response for a request we never made... */\n\t\tServerInstance->Logs->Log(\"RESOLVER\",DEBUG,\"Hmm, got a result that we didn't ask for (id=%lx). Ignoring.\", this_id);\n\t\treturn DNSResult(-1,\"\",0,\"\");\n\t}\n\telse\n\t{\n\t\t/* Remove the query from the list of pending queries */\n\t\treq = requests[this_id];\n\t\trequests[this_id] = NULL;\n\t}\n\n\t/* Inform the DNSRequest class that it has a result to be read.\n\t * When its finished it will return a DNSInfo which is a pair of\n\t * unsigned char* resource record data, and an error message.\n\t */\n\tDNSInfo data = req->ResultIsReady(header, length);\n\tstd::string resultstr;\n\n\t/* Check if we got a result, if we didnt, its an error */\n\tif (data.first == NULL)\n\t{\n\t\t/* An error.\n\t\t * Mask the ID with the value of ERROR_MASK, so that\n\t\t * the dns_deal_with_classes() function knows that its\n\t\t * an error response and needs to be treated uniquely.\n\t\t * Put the error message in the second field.\n\t\t */\n\t\tstd::string ro = req->orig;\n\t\tdelete req;\n\t\treturn DNSResult(this_id | ERROR_MASK, data.second, 0, ro);\n\t}\n\telse\n\t{\n\t\tunsigned long ttl = req->ttl;\n\t\tchar formatted[128];\n\n\t\t/* Forward lookups come back as binary data. We must format them into ascii */\n\t\tswitch (req->type)\n\t\t{\n\t\t\tcase DNS_QUERY_A:\n\t\t\t\tsnprintf(formatted,16,\"%u.%u.%u.%u\",data.first[0],data.first[1],data.first[2],data.first[3]);\n\t\t\t\tresultstr = formatted;\n\t\t\tbreak;\n\n\t\t\tcase DNS_QUERY_AAAA:\n\t\t\t{\n\t\t\t\tif (!inet_ntop(AF_INET6, data.first, formatted, sizeof(formatted)))\n\t\t\t\t{\n\t\t\t\t\tstd::string ro = req->orig;\n\t\t\t\t\tdelete req;\n\t\t\t\t\treturn DNSResult(this_id | ERROR_MASK, \"inet_ntop() failed\", 0, ro);\n\t\t\t\t}\n\n\t\t\t\tresultstr = formatted;\n\n\t\t\t\t/* Special case. Sending ::1 around between servers\n\t\t\t\t * and to clients is dangerous, because the : on the\n\t\t\t\t * start makes the client or server interpret the IP\n\t\t\t\t * as the last parameter on the line with a value \":1\".\n\t\t\t\t */\n\t\t\t\tif (*formatted == ':')\n\t\t\t\t\tresultstr.insert(0, \"0\");\n\t\t\t}\n\t\t\tbreak;\n\n\t\t\tcase DNS_QUERY_CNAME:\n\t\t\t\t/* Identical handling to PTR */\n\n\t\t\tcase DNS_QUERY_PTR:\n\t\t\t\t/* Reverse lookups just come back as char* */\n\t\t\t\tresultstr = std::string((const char*)data.first);\n\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Build the reply with the id and hostname/ip in it */\n\t\tstd::string ro = req->orig;\n\t\tDNSResult result = DNSResult(this_id,resultstr,ttl,ro,req->type);\n\t\tdelete req;\n\t\treturn result;\n\t}\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144908,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "DNSResult DNS::GetResult()\n{\n\t/* Fetch dns query response and decide where it belongs */\n\tDNSHeader header;\n\tDNSRequest *req;\n\tunsigned char buffer[sizeof(DNSHeader)];\n\tirc::sockets::sockaddrs from;\n\tmemset(&from, 0, sizeof(from));\n\tsocklen_t x = sizeof(from);\n\n\tint length = ServerInstance->SE->RecvFrom(this, (char*)buffer, sizeof(DNSHeader), 0, &from.sa, &x);\n\n\t/* Did we get the whole header? */\n\tif (length < 12)\n\t{\n\t\tServerInstance->Logs->Log(\"RESOLVER\",DEBUG,\"GetResult didn't get a full packet (len=%d)\", length);\n\t\t/* Nope - something screwed up. */\n\t\treturn DNSResult(-1,\"\",0,\"\");\n\t}\n\n\t/* Check wether the reply came from a different DNS\n\t * server to the one we sent it to, or the source-port\n\t * is not 53.\n\t * A user could in theory still spoof dns packets anyway\n\t * but this is less trivial than just sending garbage\n\t * to the server, which is possible without this check.\n\t *\n\t * -- Thanks jilles for pointing this one out.\n\t */\n\tif (from != myserver)\n\t{\n\t\tstd::string server1 = from.str();\n\t\tstd::string server2 = myserver.str();\n\t\tServerInstance->Logs->Log(\"RESOLVER\",DEBUG,\"Got a result from the wrong server! Bad NAT or DNS forging attempt? '%s' != '%s'\",\n\t\t\tserver1.c_str(), server2.c_str());\n\t\treturn DNSResult(-1,\"\",0,\"\");\n\t}\n\n\t/* Put the read header info into a header class */\n\tDNS::FillHeader(&header,buffer,length - 12);\n\n\t/* Get the id of this request.\n\t * Its a 16 bit value stored in two char's,\n\t * so we use logic shifts to create the value.\n\t */\n\tunsigned long this_id = header.id[1] + (header.id[0] << 8);\n\n\t/* Do we have a pending request matching this id? */\n\tif (!requests[this_id])\n\t{\n\t\t/* Somehow we got a DNS response for a request we never made... */\n\t\tServerInstance->Logs->Log(\"RESOLVER\",DEBUG,\"Hmm, got a result that we didn't ask for (id=%lx). Ignoring.\", this_id);\n\t\treturn DNSResult(-1,\"\",0,\"\");\n\t}\n\telse\n\t{\n\t\t/* Remove the query from the list of pending queries */\n\t\treq = requests[this_id];\n\t\trequests[this_id] = NULL;\n\t}\n\n\t/* Inform the DNSRequest class that it has a result to be read.\n\t * When its finished it will return a DNSInfo which is a pair of\n\t * unsigned char* resource record data, and an error message.\n\t */\n\tDNSInfo data = req->ResultIsReady(header, length);\n\tstd::string resultstr;\n\n\t/* Check if we got a result, if we didnt, its an error */\n\tif (data.first == NULL)\n\t{\n\t\t/* An error.\n\t\t * Mask the ID with the value of ERROR_MASK, so that\n\t\t * the dns_deal_with_classes() function knows that its\n\t\t * an error response and needs to be treated uniquely.\n\t\t * Put the error message in the second field.\n\t\t */\n\t\tstd::string ro = req->orig;\n\t\tdelete req;\n\t\treturn DNSResult(this_id | ERROR_MASK, data.second, 0, ro);\n\t}\n\telse\n\t{\n\t\tunsigned long ttl = req->ttl;\n\t\tchar formatted[128];\n\n\t\t/* Forward lookups come back as binary data. We must format them into ascii */\n\t\tswitch (req->type)\n\t\t{\n\t\t\tcase DNS_QUERY_A:\n\t\t\t\tsnprintf(formatted,16,\"%u.%u.%u.%u\",data.first[0],data.first[1],data.first[2],data.first[3]);\n\t\t\t\tresultstr = formatted;\n\t\t\tbreak;\n\n\t\t\tcase DNS_QUERY_AAAA:\n\t\t\t{\n\t\t\t\tif (!inet_ntop(AF_INET6, data.first, formatted, sizeof(formatted)))\n\t\t\t\t{\n\t\t\t\t\tstd::string ro = req->orig;\n\t\t\t\t\tdelete req;\n\t\t\t\t\treturn DNSResult(this_id | ERROR_MASK, \"inet_ntop() failed\", 0, ro);\n\t\t\t\t}\n\n\t\t\t\tresultstr = formatted;\n\n\t\t\t\t/* Special case. Sending ::1 around between servers\n\t\t\t\t * and to clients is dangerous, because the : on the\n\t\t\t\t * start makes the client or server interpret the IP\n\t\t\t\t * as the last parameter on the line with a value \":1\".\n\t\t\t\t */\n\t\t\t\tif (*formatted == ':')\n\t\t\t\t\tresultstr.insert(0, \"0\");\n\t\t\t}\n\t\t\tbreak;\n\n\t\t\tcase DNS_QUERY_CNAME:\n\t\t\t\t/* Identical handling to PTR */\n\n\t\t\tcase DNS_QUERY_PTR:\n\t\t\t{\n\t\t\t\t/* Reverse lookups just come back as char* */\n\t\t\t\tresultstr = std::string((const char*)data.first);\n\t\t\t\tif (resultstr.find_first_not_of(\"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.-\") != std::string::npos)\n\t\t\t\t{\n\t\t\t\t\tstd::string ro = req->orig;\n\t\t\t\t\tdelete req;\n\t\t\t\t\treturn DNSResult(this_id | ERROR_MASK, \"Invalid char(s) in reply\", 0, ro);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Build the reply with the id and hostname/ip in it */\n\t\tstd::string ro = req->orig;\n\t\tDNSResult result = DNSResult(this_id,resultstr,ttl,ro,req->type);\n\t\tdelete req;\n\t\treturn result;\n\t}\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144909,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "GF_Err audio_sample_entry_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MPEGAudioSampleEntryBox *ptr;\n\tchar *data;\n\tu8 a, b, c, d;\n\tu32 i, size, v, nb_alnum;\n\tGF_Err e;\n\tu64 pos, start;\n\n\tptr = (GF_MPEGAudioSampleEntryBox *)s;\n\n\tstart = gf_bs_get_position(bs);\n\tgf_bs_seek(bs, start + 8);\n\tv = gf_bs_read_u16(bs);\n\tif (v)\n\t\tptr->is_qtff = 1;\n\n\t//try to disambiguate QTFF v1 and MP4 v1 audio sample entries ...\n\tif (v==1) {\n\t\t//go to end of ISOM audio sample entry, skip 4 byte (box size field), read 4 bytes (box type) and check if this looks like a box\n\t\tgf_bs_seek(bs, start + 8 + 20  + 4);\n\t\ta = gf_bs_read_u8(bs);\n\t\tb = gf_bs_read_u8(bs);\n\t\tc = gf_bs_read_u8(bs);\n\t\td = gf_bs_read_u8(bs);\n\t\tnb_alnum = 0;\n\t\tif (isalnum(a)) nb_alnum++;\n\t\tif (isalnum(b)) nb_alnum++;\n\t\tif (isalnum(c)) nb_alnum++;\n\t\tif (isalnum(d)) nb_alnum++;\n\t\tif (nb_alnum>2) ptr->is_qtff = 0;\n\t}\n\n\tgf_bs_seek(bs, start);\n\te = gf_isom_audio_sample_entry_read((GF_AudioSampleEntryBox*)s, bs);\n\tif (e) return e;\n\tpos = gf_bs_get_position(bs);\n\tsize = (u32) s->size;\n\n\t//when cookie is set on bs, always convert qtff-style mp4a to isobmff-style\n\t//since the conversion is done in addBox and we don't have the bitstream there (arg...), flag the box\n \tif (gf_bs_get_cookie(bs)) {\n \t\tptr->is_qtff |= 1<<16;\n \t}\n\n\te = gf_isom_box_array_read(s, bs, audio_sample_entry_AddBox);\n\tif (!e) return GF_OK;\n\tif (size<8) return GF_ISOM_INVALID_FILE;\n\n\t/*hack for some weird files (possibly recorded with live.com tools, needs further investigations)*/\n\tgf_bs_seek(bs, pos);\n\tdata = (char*)gf_malloc(sizeof(char) * size);\n\tgf_bs_read_data(bs, data, size);\n\tfor (i=0; i<size-8; i++) {\n\t\tif (GF_4CC((u32)data[i+4], (u8)data[i+5], (u8)data[i+6], (u8)data[i+7]) == GF_ISOM_BOX_TYPE_ESDS) {\n\t\t\tGF_BitStream *mybs = gf_bs_new(data + i, size - i, GF_BITSTREAM_READ);\n\t\t\tif (ptr->esd) {\n\t\t\t\tgf_isom_box_del((GF_Box *)ptr->esd);\n\t\t\t\tptr->esd=NULL;\n\t\t\t}\n\n\t\t\te = gf_isom_box_parse((GF_Box **)&ptr->esd, mybs);\n\n\t\t\tif (e==GF_OK) {\n\t\t\t\tgf_isom_box_add_for_dump_mode((GF_Box*)ptr, (GF_Box*)ptr->esd);\n\t\t\t} else if (ptr->esd) {\n\t\t\t\tgf_isom_box_del((GF_Box *)ptr->esd);\n\t\t\t\tptr->esd=NULL;\n\t\t\t}\n\n\t\t\tgf_bs_del(mybs);\n\t\t\tbreak;\n\t\t}\n\t}\n\tgf_free(data);\n\treturn e;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144970,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "GF_Err audio_sample_entry_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MPEGAudioSampleEntryBox *ptr;\n\tchar *data;\n\tu8 a, b, c, d;\n\tu32 i, size, v, nb_alnum;\n\tGF_Err e;\n\tu64 pos, start;\n\n\tptr = (GF_MPEGAudioSampleEntryBox *)s;\n\n\tstart = gf_bs_get_position(bs);\n\tgf_bs_seek(bs, start + 8);\n\tv = gf_bs_read_u16(bs);\n\tif (v)\n\t\tptr->is_qtff = 1;\n\n\t//try to disambiguate QTFF v1 and MP4 v1 audio sample entries ...\n\tif (v==1) {\n\t\t//go to end of ISOM audio sample entry, skip 4 byte (box size field), read 4 bytes (box type) and check if this looks like a box\n\t\tgf_bs_seek(bs, start + 8 + 20  + 4);\n\t\ta = gf_bs_read_u8(bs);\n\t\tb = gf_bs_read_u8(bs);\n\t\tc = gf_bs_read_u8(bs);\n\t\td = gf_bs_read_u8(bs);\n\t\tnb_alnum = 0;\n\t\tif (isalnum(a)) nb_alnum++;\n\t\tif (isalnum(b)) nb_alnum++;\n\t\tif (isalnum(c)) nb_alnum++;\n\t\tif (isalnum(d)) nb_alnum++;\n\t\tif (nb_alnum>2) ptr->is_qtff = 0;\n\t}\n\n\tgf_bs_seek(bs, start);\n\te = gf_isom_audio_sample_entry_read((GF_AudioSampleEntryBox*)s, bs);\n\tif (e) return e;\n\tpos = gf_bs_get_position(bs);\n\tsize = (u32) s->size;\n\n\t//when cookie is set on bs, always convert qtff-style mp4a to isobmff-style\n\t//since the conversion is done in addBox and we don't have the bitstream there (arg...), flag the box\n \tif (gf_bs_get_cookie(bs)) {\n \t\tptr->is_qtff |= 1<<16;\n \t}\n\n\te = gf_isom_box_array_read(s, bs, audio_sample_entry_AddBox);\n\tif (!e) return GF_OK;\n\tif (size<8) return GF_ISOM_INVALID_FILE;\n\n\t/*hack for some weird files (possibly recorded with live.com tools, needs further investigations)*/\n\tgf_bs_seek(bs, pos);\n\tdata = (char*)gf_malloc(sizeof(char) * size);\n\tgf_bs_read_data(bs, data, size);\n\tfor (i=0; i<size-8; i++) {\n\t\tif (GF_4CC((u32)data[i+4], (u8)data[i+5], (u8)data[i+6], (u8)data[i+7]) == GF_ISOM_BOX_TYPE_ESDS) {\n\t\t\textern Bool use_dump_mode;\n\t\t\tGF_BitStream *mybs = gf_bs_new(data + i, size - i, GF_BITSTREAM_READ);\n\t\t\tif (ptr->esd) {\n\t\t\t\tif (!use_dump_mode) gf_isom_box_del((GF_Box *)ptr->esd);\n\t\t\t\tptr->esd=NULL;\n\t\t\t}\n\n\t\t\te = gf_isom_box_parse((GF_Box **)&ptr->esd, mybs);\n\n\t\t\tif (e==GF_OK) {\n\t\t\t\tgf_isom_box_add_for_dump_mode((GF_Box*)ptr, (GF_Box*)ptr->esd);\n\t\t\t} else if (ptr->esd) {\n\t\t\t\tgf_isom_box_del((GF_Box *)ptr->esd);\n\t\t\t\tptr->esd=NULL;\n\t\t\t}\n\n\t\t\tgf_bs_del(mybs);\n\t\t\tbreak;\n\t\t}\n\t}\n\tgf_free(data);\n\treturn e;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144971,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "Error HeifContext::interpret_heif_file()\n{\n  m_all_images.clear();\n  m_top_level_images.clear();\n  m_primary_image.reset();\n\n\n  // --- reference all non-hidden images\n\n  std::vector<heif_item_id> image_IDs = m_heif_file->get_item_IDs();\n\n  bool primary_is_grid = false;\n  for (heif_item_id id : image_IDs) {\n    auto infe_box = m_heif_file->get_infe_box(id);\n    if (!infe_box) {\n      // TODO(farindk): Should we return an error instead of skipping the invalid id?\n      continue;\n    }\n\n    if (item_type_is_image(infe_box->get_item_type())) {\n      auto image = std::make_shared<Image>(this, id);\n      m_all_images.insert(std::make_pair(id, image));\n\n      if (!infe_box->is_hidden_item()) {\n        if (id==m_heif_file->get_primary_image_ID()) {\n          image->set_primary(true);\n          m_primary_image = image;\n          primary_is_grid = infe_box->get_item_type() == \"grid\";\n        }\n\n        m_top_level_images.push_back(image);\n      }\n    }\n  }\n\n\n  if (!m_primary_image) {\n    return Error(heif_error_Invalid_input,\n                 heif_suberror_Nonexisting_item_referenced,\n                 \"'pitm' box references a non-existing image\");\n  }\n\n\n  // --- remove thumbnails from top-level images and assign to their respective image\n\n  auto iref_box = m_heif_file->get_iref_box();\n  if (iref_box) {\n    // m_top_level_images.clear();\n\n    for (auto& pair : m_all_images) {\n      auto& image = pair.second;\n\n      std::vector<Box_iref::Reference> references = iref_box->get_references_from(image->get_id());\n\n      for (const Box_iref::Reference& ref : references) {\n        uint32_t type = ref.header.get_short_type();\n\n        if (type==fourcc(\"thmb\")) {\n          // --- this is a thumbnail image, attach to the main image\n\n          std::vector<heif_item_id> refs = ref.to_item_ID;\n          if (refs.size() != 1) {\n            return Error(heif_error_Invalid_input,\n                         heif_suberror_Unspecified,\n                         \"Too many thumbnail references\");\n          }\n\n          image->set_is_thumbnail_of(refs[0]);\n\n          auto master_iter = m_all_images.find(refs[0]);\n          if (master_iter == m_all_images.end()) {\n            return Error(heif_error_Invalid_input,\n                         heif_suberror_Nonexisting_item_referenced,\n                         \"Thumbnail references a non-existing image\");\n          }\n\n          if (master_iter->second->is_thumbnail()) {\n            return Error(heif_error_Invalid_input,\n                         heif_suberror_Nonexisting_item_referenced,\n                         \"Thumbnail references another thumbnail\");\n          }\n\n          if (image.get() == master_iter->second.get()) {\n            return Error(heif_error_Invalid_input,\n                         heif_suberror_Nonexisting_item_referenced,\n                         \"Recursive thumbnail image detected\");\n          }\n          master_iter->second->add_thumbnail(image);\n\n          remove_top_level_image(image);\n        }\n        else if (type==fourcc(\"auxl\")) {\n\n          // --- this is an auxiliary image\n          //     check whether it is an alpha channel and attach to the main image if yes\n\n          std::vector<Box_ipco::Property> properties;\n          Error err = m_heif_file->get_properties(image->get_id(), properties);\n          if (err) {\n            return err;\n          }\n\n          std::shared_ptr<Box_auxC> auxC_property;\n          for (const auto& property : properties) {\n            auto auxC = std::dynamic_pointer_cast<Box_auxC>(property.property);\n            if (auxC) {\n              auxC_property = auxC;\n            }\n          }\n\n          if (!auxC_property) {\n            std::stringstream sstr;\n            sstr << \"No auxC property for image \" << image->get_id();\n            return Error(heif_error_Invalid_input,\n                         heif_suberror_Auxiliary_image_type_unspecified,\n                         sstr.str());\n          }\n\n          std::vector<heif_item_id> refs = ref.to_item_ID;\n          if (refs.size() != 1) {\n            return Error(heif_error_Invalid_input,\n                         heif_suberror_Unspecified,\n                         \"Too many auxiliary image references\");\n          }\n\n\n          // alpha channel\n\n          if (auxC_property->get_aux_type() == \"urn:mpeg:avc:2015:auxid:1\" ||\n              auxC_property->get_aux_type() == \"urn:mpeg:hevc:2015:auxid:1\") {\n            image->set_is_alpha_channel_of(refs[0]);\n\n            auto master_iter = m_all_images.find(refs[0]);\n            if (image.get() == master_iter->second.get()) {\n              return Error(heif_error_Invalid_input,\n                           heif_suberror_Nonexisting_item_referenced,\n                           \"Recursive alpha image detected\");\n            }\n            master_iter->second->set_alpha_channel(image);\n          }\n\n\n          // depth channel\n\n          if (auxC_property->get_aux_type() == \"urn:mpeg:hevc:2015:auxid:2\") {\n            image->set_is_depth_channel_of(refs[0]);\n\n            auto master_iter = m_all_images.find(refs[0]);\n            if (image.get() == master_iter->second.get()) {\n              return Error(heif_error_Invalid_input,\n                           heif_suberror_Nonexisting_item_referenced,\n                           \"Recursive depth image detected\");\n            }\n            master_iter->second->set_depth_channel(image);\n\n            auto subtypes = auxC_property->get_subtypes();\n\n            std::vector<std::shared_ptr<SEIMessage>> sei_messages;\n            Error err = decode_hevc_aux_sei_messages(subtypes, sei_messages);\n\n            for (auto& msg : sei_messages) {\n              auto depth_msg = std::dynamic_pointer_cast<SEIMessage_depth_representation_info>(msg);\n              if (depth_msg) {\n                image->set_depth_representation_info(*depth_msg);\n              }\n            }\n          }\n\n          remove_top_level_image(image);\n        }\n        else {\n          // 'image' is a normal image, keep it as a top-level image\n        }\n      }\n    }\n  }\n\n\n  // --- check that HEVC images have an hvcC property\n\n  for (auto& pair : m_all_images) {\n    auto& image = pair.second;\n\n    std::shared_ptr<Box_infe> infe = m_heif_file->get_infe_box(image->get_id());\n    if (infe->get_item_type() == \"hvc1\") {\n\n      auto ipma = m_heif_file->get_ipma_box();\n      auto ipco = m_heif_file->get_ipco_box();\n\n      if (!ipco->get_property_for_item_ID(image->get_id(), ipma, fourcc(\"hvcC\"))) {\n        return Error(heif_error_Invalid_input,\n                     heif_suberror_No_hvcC_box,\n                     \"No hvcC property in hvc1 type image\");\n      }\n    }\n  }\n\n\n  // --- read through properties for each image and extract image resolutions\n\n  for (auto& pair : m_all_images) {\n    auto& image = pair.second;\n\n    std::vector<Box_ipco::Property> properties;\n\n    Error err = m_heif_file->get_properties(pair.first, properties);\n    if (err) {\n      return err;\n    }\n\n    bool ispe_read = false;\n    bool primary_colr_set = false;\n    for (const auto& prop : properties) {\n      auto ispe = std::dynamic_pointer_cast<Box_ispe>(prop.property);\n      if (ispe) {\n        uint32_t width = ispe->get_width();\n        uint32_t height = ispe->get_height();\n\n\n        // --- check whether the image size is \"too large\"\n\n        if (width  >= static_cast<uint32_t>(MAX_IMAGE_WIDTH) ||\n            height >= static_cast<uint32_t>(MAX_IMAGE_HEIGHT)) {\n          std::stringstream sstr;\n          sstr << \"Image size \" << width << \"x\" << height << \" exceeds the maximum image size \"\n               << MAX_IMAGE_WIDTH << \"x\" << MAX_IMAGE_HEIGHT << \"\\n\";\n\n          return Error(heif_error_Memory_allocation_error,\n                       heif_suberror_Security_limit_exceeded,\n                       sstr.str());\n        }\n\n        image->set_resolution(width, height);\n        image->set_ispe_resolution(width, height);\n        ispe_read = true;\n      }\n\n      if (ispe_read) {\n        auto clap = std::dynamic_pointer_cast<Box_clap>(prop.property);\n        if (clap) {\n          image->set_resolution( clap->get_width_rounded(),\n                                 clap->get_height_rounded() );\n        }\n\n        auto irot = std::dynamic_pointer_cast<Box_irot>(prop.property);\n        if (irot) {\n          if (irot->get_rotation()==90 ||\n              irot->get_rotation()==270) {\n            // swap width and height\n            image->set_resolution( image->get_height(),\n                                   image->get_width() );\n          }\n        }\n      }\n\n      auto colr = std::dynamic_pointer_cast<Box_colr>(prop.property);\n      if (colr) {\n        auto profile = colr->get_color_profile();\n\n        image->set_color_profile(profile);\n\n        // if this is a grid item we assign the first one's color profile\n        // to the main image which is supposed to be a grid\n\n        // TODO: this condition is not correct. It would also classify a secondary image as a 'grid item'.\n        // We have to set the grid-image color profile in another way...\n        const bool is_grid_item = !image->is_primary() && !image->is_alpha_channel() && !image->is_depth_channel();\n\n        if (primary_is_grid &&\n            !primary_colr_set &&\n            is_grid_item) {\n          m_primary_image->set_color_profile(profile);\n          primary_colr_set = true;\n        }\n      }\n    }\n  }\n\n\n  // --- read metadata and assign to image\n\n  for (heif_item_id id : image_IDs) {\n    std::string item_type    = m_heif_file->get_item_type(id);\n    std::string content_type = m_heif_file->get_content_type(id);\n    if (item_type == \"Exif\" ||\n        (item_type==\"mime\" && content_type==\"application/rdf+xml\")) {\n      std::shared_ptr<ImageMetadata> metadata = std::make_shared<ImageMetadata>();\n      metadata->item_id = id;\n      metadata->item_type = item_type;\n      metadata->content_type = content_type;\n\n      Error err = m_heif_file->get_compressed_image_data(id, &(metadata->m_data));\n      if (err) {\n        return err;\n      }\n\n      //std::cerr.write((const char*)data.data(), data.size());\n\n\n      // --- assign metadata to the image\n\n      if (iref_box) {\n        std::vector<Box_iref::Reference> references = iref_box->get_references_from(id);\n        for (const auto& ref : references) {\n          if (ref.header.get_short_type() == fourcc(\"cdsc\")) {\n            std::vector<uint32_t> refs = ref.to_item_ID;\n            if (refs.size() != 1) {\n              return Error(heif_error_Invalid_input,\n                           heif_suberror_Unspecified,\n                           \"Exif data not correctly assigned to image\");\n            }\n\n            uint32_t exif_image_id = refs[0];\n            auto img_iter = m_all_images.find(exif_image_id);\n            if (img_iter == m_all_images.end()) {\n              return Error(heif_error_Invalid_input,\n                           heif_suberror_Nonexisting_item_referenced,\n                           \"Exif data assigned to non-existing image\");\n            }\n\n            img_iter->second->add_metadata(metadata);\n          }\n        }\n      }\n    }\n  }\n\n  return Error::Ok;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144978,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "Error HeifContext::interpret_heif_file()\n{\n  m_all_images.clear();\n  m_top_level_images.clear();\n  m_primary_image.reset();\n\n\n  // --- reference all non-hidden images\n\n  std::vector<heif_item_id> image_IDs = m_heif_file->get_item_IDs();\n\n  bool primary_is_grid = false;\n  for (heif_item_id id : image_IDs) {\n    auto infe_box = m_heif_file->get_infe_box(id);\n    if (!infe_box) {\n      // TODO(farindk): Should we return an error instead of skipping the invalid id?\n      continue;\n    }\n\n    if (item_type_is_image(infe_box->get_item_type())) {\n      auto image = std::make_shared<Image>(this, id);\n      m_all_images.insert(std::make_pair(id, image));\n\n      if (!infe_box->is_hidden_item()) {\n        if (id==m_heif_file->get_primary_image_ID()) {\n          image->set_primary(true);\n          m_primary_image = image;\n          primary_is_grid = infe_box->get_item_type() == \"grid\";\n        }\n\n        m_top_level_images.push_back(image);\n      }\n    }\n  }\n\n\n  if (!m_primary_image) {\n    return Error(heif_error_Invalid_input,\n                 heif_suberror_Nonexisting_item_referenced,\n                 \"'pitm' box references a non-existing image\");\n  }\n\n\n  // --- remove thumbnails from top-level images and assign to their respective image\n\n  auto iref_box = m_heif_file->get_iref_box();\n  if (iref_box) {\n    // m_top_level_images.clear();\n\n    for (auto& pair : m_all_images) {\n      auto& image = pair.second;\n\n      std::vector<Box_iref::Reference> references = iref_box->get_references_from(image->get_id());\n\n      for (const Box_iref::Reference& ref : references) {\n        uint32_t type = ref.header.get_short_type();\n\n        if (type==fourcc(\"thmb\")) {\n          // --- this is a thumbnail image, attach to the main image\n\n          std::vector<heif_item_id> refs = ref.to_item_ID;\n          if (refs.size() != 1) {\n            return Error(heif_error_Invalid_input,\n                         heif_suberror_Unspecified,\n                         \"Too many thumbnail references\");\n          }\n\n          image->set_is_thumbnail_of(refs[0]);\n\n          auto master_iter = m_all_images.find(refs[0]);\n          if (master_iter == m_all_images.end()) {\n            return Error(heif_error_Invalid_input,\n                         heif_suberror_Nonexisting_item_referenced,\n                         \"Thumbnail references a non-existing image\");\n          }\n\n          if (master_iter->second->is_thumbnail()) {\n            return Error(heif_error_Invalid_input,\n                         heif_suberror_Nonexisting_item_referenced,\n                         \"Thumbnail references another thumbnail\");\n          }\n\n          if (image.get() == master_iter->second.get()) {\n            return Error(heif_error_Invalid_input,\n                         heif_suberror_Nonexisting_item_referenced,\n                         \"Recursive thumbnail image detected\");\n          }\n          master_iter->second->add_thumbnail(image);\n\n          remove_top_level_image(image);\n        }\n        else if (type==fourcc(\"auxl\")) {\n\n          // --- this is an auxiliary image\n          //     check whether it is an alpha channel and attach to the main image if yes\n\n          std::vector<Box_ipco::Property> properties;\n          Error err = m_heif_file->get_properties(image->get_id(), properties);\n          if (err) {\n            return err;\n          }\n\n          std::shared_ptr<Box_auxC> auxC_property;\n          for (const auto& property : properties) {\n            auto auxC = std::dynamic_pointer_cast<Box_auxC>(property.property);\n            if (auxC) {\n              auxC_property = auxC;\n            }\n          }\n\n          if (!auxC_property) {\n            std::stringstream sstr;\n            sstr << \"No auxC property for image \" << image->get_id();\n            return Error(heif_error_Invalid_input,\n                         heif_suberror_Auxiliary_image_type_unspecified,\n                         sstr.str());\n          }\n\n          std::vector<heif_item_id> refs = ref.to_item_ID;\n          if (refs.size() != 1) {\n            return Error(heif_error_Invalid_input,\n                         heif_suberror_Unspecified,\n                         \"Too many auxiliary image references\");\n          }\n\n\n          // alpha channel\n\n          if (auxC_property->get_aux_type() == \"urn:mpeg:avc:2015:auxid:1\" ||\n              auxC_property->get_aux_type() == \"urn:mpeg:hevc:2015:auxid:1\") {\n            image->set_is_alpha_channel_of(refs[0]);\n\n            auto master_iter = m_all_images.find(refs[0]);\n            if (master_iter == m_all_images.end()) {\n              return Error(heif_error_Invalid_input,\n                           heif_suberror_Nonexisting_item_referenced,\n                           \"Non-existing alpha image referenced\");\n            }\n            if (image.get() == master_iter->second.get()) {\n              return Error(heif_error_Invalid_input,\n                           heif_suberror_Nonexisting_item_referenced,\n                           \"Recursive alpha image detected\");\n            }\n            master_iter->second->set_alpha_channel(image);\n          }\n\n\n          // depth channel\n\n          if (auxC_property->get_aux_type() == \"urn:mpeg:hevc:2015:auxid:2\") {\n            image->set_is_depth_channel_of(refs[0]);\n\n            auto master_iter = m_all_images.find(refs[0]);\n            if (image.get() == master_iter->second.get()) {\n              return Error(heif_error_Invalid_input,\n                           heif_suberror_Nonexisting_item_referenced,\n                           \"Recursive depth image detected\");\n            }\n            master_iter->second->set_depth_channel(image);\n\n            auto subtypes = auxC_property->get_subtypes();\n\n            std::vector<std::shared_ptr<SEIMessage>> sei_messages;\n            Error err = decode_hevc_aux_sei_messages(subtypes, sei_messages);\n\n            for (auto& msg : sei_messages) {\n              auto depth_msg = std::dynamic_pointer_cast<SEIMessage_depth_representation_info>(msg);\n              if (depth_msg) {\n                image->set_depth_representation_info(*depth_msg);\n              }\n            }\n          }\n\n          remove_top_level_image(image);\n        }\n        else {\n          // 'image' is a normal image, keep it as a top-level image\n        }\n      }\n    }\n  }\n\n\n  // --- check that HEVC images have an hvcC property\n\n  for (auto& pair : m_all_images) {\n    auto& image = pair.second;\n\n    std::shared_ptr<Box_infe> infe = m_heif_file->get_infe_box(image->get_id());\n    if (infe->get_item_type() == \"hvc1\") {\n\n      auto ipma = m_heif_file->get_ipma_box();\n      auto ipco = m_heif_file->get_ipco_box();\n\n      if (!ipco->get_property_for_item_ID(image->get_id(), ipma, fourcc(\"hvcC\"))) {\n        return Error(heif_error_Invalid_input,\n                     heif_suberror_No_hvcC_box,\n                     \"No hvcC property in hvc1 type image\");\n      }\n    }\n  }\n\n\n  // --- read through properties for each image and extract image resolutions\n\n  for (auto& pair : m_all_images) {\n    auto& image = pair.second;\n\n    std::vector<Box_ipco::Property> properties;\n\n    Error err = m_heif_file->get_properties(pair.first, properties);\n    if (err) {\n      return err;\n    }\n\n    bool ispe_read = false;\n    bool primary_colr_set = false;\n    for (const auto& prop : properties) {\n      auto ispe = std::dynamic_pointer_cast<Box_ispe>(prop.property);\n      if (ispe) {\n        uint32_t width = ispe->get_width();\n        uint32_t height = ispe->get_height();\n\n\n        // --- check whether the image size is \"too large\"\n\n        if (width  >= static_cast<uint32_t>(MAX_IMAGE_WIDTH) ||\n            height >= static_cast<uint32_t>(MAX_IMAGE_HEIGHT)) {\n          std::stringstream sstr;\n          sstr << \"Image size \" << width << \"x\" << height << \" exceeds the maximum image size \"\n               << MAX_IMAGE_WIDTH << \"x\" << MAX_IMAGE_HEIGHT << \"\\n\";\n\n          return Error(heif_error_Memory_allocation_error,\n                       heif_suberror_Security_limit_exceeded,\n                       sstr.str());\n        }\n\n        image->set_resolution(width, height);\n        image->set_ispe_resolution(width, height);\n        ispe_read = true;\n      }\n\n      if (ispe_read) {\n        auto clap = std::dynamic_pointer_cast<Box_clap>(prop.property);\n        if (clap) {\n          image->set_resolution( clap->get_width_rounded(),\n                                 clap->get_height_rounded() );\n        }\n\n        auto irot = std::dynamic_pointer_cast<Box_irot>(prop.property);\n        if (irot) {\n          if (irot->get_rotation()==90 ||\n              irot->get_rotation()==270) {\n            // swap width and height\n            image->set_resolution( image->get_height(),\n                                   image->get_width() );\n          }\n        }\n      }\n\n      auto colr = std::dynamic_pointer_cast<Box_colr>(prop.property);\n      if (colr) {\n        auto profile = colr->get_color_profile();\n\n        image->set_color_profile(profile);\n\n        // if this is a grid item we assign the first one's color profile\n        // to the main image which is supposed to be a grid\n\n        // TODO: this condition is not correct. It would also classify a secondary image as a 'grid item'.\n        // We have to set the grid-image color profile in another way...\n        const bool is_grid_item = !image->is_primary() && !image->is_alpha_channel() && !image->is_depth_channel();\n\n        if (primary_is_grid &&\n            !primary_colr_set &&\n            is_grid_item) {\n          m_primary_image->set_color_profile(profile);\n          primary_colr_set = true;\n        }\n      }\n    }\n  }\n\n\n  // --- read metadata and assign to image\n\n  for (heif_item_id id : image_IDs) {\n    std::string item_type    = m_heif_file->get_item_type(id);\n    std::string content_type = m_heif_file->get_content_type(id);\n    if (item_type == \"Exif\" ||\n        (item_type==\"mime\" && content_type==\"application/rdf+xml\")) {\n      std::shared_ptr<ImageMetadata> metadata = std::make_shared<ImageMetadata>();\n      metadata->item_id = id;\n      metadata->item_type = item_type;\n      metadata->content_type = content_type;\n\n      Error err = m_heif_file->get_compressed_image_data(id, &(metadata->m_data));\n      if (err) {\n        return err;\n      }\n\n      //std::cerr.write((const char*)data.data(), data.size());\n\n\n      // --- assign metadata to the image\n\n      if (iref_box) {\n        std::vector<Box_iref::Reference> references = iref_box->get_references_from(id);\n        for (const auto& ref : references) {\n          if (ref.header.get_short_type() == fourcc(\"cdsc\")) {\n            std::vector<uint32_t> refs = ref.to_item_ID;\n            if (refs.size() != 1) {\n              return Error(heif_error_Invalid_input,\n                           heif_suberror_Unspecified,\n                           \"Exif data not correctly assigned to image\");\n            }\n\n            uint32_t exif_image_id = refs[0];\n            auto img_iter = m_all_images.find(exif_image_id);\n            if (img_iter == m_all_images.end()) {\n              return Error(heif_error_Invalid_input,\n                           heif_suberror_Nonexisting_item_referenced,\n                           \"Exif data assigned to non-existing image\");\n            }\n\n            img_iter->second->add_metadata(metadata);\n          }\n        }\n      }\n    }\n  }\n\n  return Error::Ok;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144979,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "void Magick::Image::read(MagickCore::Image *image,\n  MagickCore::ExceptionInfo *exceptionInfo)\n{\n  // Ensure that multiple image frames were not read.\n  if (image != (MagickCore::Image *) NULL &&\n      image->next != (MagickCore::Image *) NULL)\n    {\n      MagickCore::Image\n        *next;\n\n      // Destroy any extra image frames\n      next=image->next;\n      image->next=(MagickCore::Image *) NULL;\n      next->previous=(MagickCore::Image *) NULL;\n      DestroyImageList(next);\n    }\n  replaceImage(image);\n  if (exceptionInfo->severity == MagickCore::UndefinedException &&\n      image == (MagickCore::Image *) NULL)\n    {\n      (void) MagickCore::DestroyExceptionInfo(exceptionInfo);\n      if (!quiet())\n        throwExceptionExplicit(MagickCore::ImageWarning,\n          \"No image was loaded.\");\n    }\n  ThrowImageException;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145112,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "void Magick::Image::read(MagickCore::Image *image,\n  MagickCore::ExceptionInfo *exceptionInfo)\n{\n  // Ensure that multiple image frames were not read.\n  if (image != (MagickCore::Image *) NULL &&\n      image->next != (MagickCore::Image *) NULL)\n    {\n      MagickCore::Image\n        *next;\n\n      // Destroy any extra image frames\n      next=image->next;\n      image->next=(MagickCore::Image *) NULL;\n      next->previous=(MagickCore::Image *) NULL;\n      DestroyImageList(next);\n    }\n  replaceImage(image);\n  if (exceptionInfo->severity == MagickCore::UndefinedException &&\n      image == (MagickCore::Image *) NULL)\n    {\n      (void) MagickCore::DestroyExceptionInfo(exceptionInfo);\n      if (!quiet())\n        throwExceptionExplicit(MagickCore::ImageWarning,\n          \"No image was loaded.\");\n      return;\n    }\n  ThrowImageException;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145113,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static void gf_m2ts_process_pat(GF_M2TS_Demuxer *ts, GF_M2TS_SECTION_ES *ses, GF_List *sections, u8 table_id, u16 ex_table_id, u8 version_number, u8 last_section_number, u32 status)\n{\n\tGF_M2TS_Program *prog;\n\tGF_M2TS_SECTION_ES *pmt;\n\tu32 i, nb_progs, evt_type;\n\tu32 nb_sections;\n\tu32 data_size;\n\tunsigned char *data;\n\tGF_M2TS_Section *section;\n\n\t/*wait for the last section */\n\tif (!(status&GF_M2TS_TABLE_END)) return;\n\n\t/*skip if already received*/\n\tif (status&GF_M2TS_TABLE_REPEAT) {\n\t\tif (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_PAT_REPEAT, NULL);\n\t\treturn;\n\t}\n\n\tnb_sections = gf_list_count(sections);\n\tif (nb_sections > 1) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"PAT on multiple sections not supported\\n\"));\n\t}\n\n\tsection = (GF_M2TS_Section *)gf_list_get(sections, 0);\n\tdata = section->data;\n\tdata_size = section->data_size;\n\n\tif (!(status&GF_M2TS_TABLE_UPDATE) && gf_list_count(ts->programs)) {\n\t\tif (ts->pat->demux_restarted) {\n\t\t\tts->pat->demux_restarted = 0;\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Multiple different PAT on single TS found, ignoring new PAT declaration (table id %d - extended table id %d)\\n\", table_id, ex_table_id));\n\t\t}\n\t\treturn;\n\t}\n\tnb_progs = data_size / 4;\n\n\tfor (i=0; i<nb_progs; i++) {\n\t\tu16 number, pid;\n\t\tnumber = (data[0]<<8) | data[1];\n\t\tpid = (data[2]&0x1f)<<8 | data[3];\n\t\tdata += 4;\n\t\tif (number==0) {\n\t\t\tif (!ts->nit) {\n\t\t\t\tts->nit = gf_m2ts_section_filter_new(gf_m2ts_process_nit, 0);\n\t\t\t}\n\t\t} else {\n\t\t\tGF_SAFEALLOC(prog, GF_M2TS_Program);\n\t\t\tif (!prog) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Fail to allocate program for pid %d\\n\", pid));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tprog->streams = gf_list_new();\n\t\t\tprog->pmt_pid = pid;\n\t\t\tprog->number = number;\n\t\t\tprog->ts = ts;\n\t\t\tgf_list_add(ts->programs, prog);\n\t\t\tGF_SAFEALLOC(pmt, GF_M2TS_SECTION_ES);\n\t\t\tif (!pmt) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Fail to allocate pmt filter for pid %d\\n\", pid));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tpmt->flags = GF_M2TS_ES_IS_SECTION;\n\t\t\tgf_list_add(prog->streams, pmt);\n\t\t\tpmt->pid = prog->pmt_pid;\n\t\t\tpmt->program = prog;\n\t\t\tts->ess[pmt->pid] = (GF_M2TS_ES *)pmt;\n\t\t\tpmt->sec = gf_m2ts_section_filter_new(gf_m2ts_process_pmt, 0);\n\t\t}\n\t}\n\n\tevt_type = (status&GF_M2TS_TABLE_UPDATE) ? GF_M2TS_EVT_PAT_UPDATE : GF_M2TS_EVT_PAT_FOUND;\n\tif (ts->on_event) ts->on_event(ts, evt_type, NULL);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145160,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static void gf_m2ts_process_pat(GF_M2TS_Demuxer *ts, GF_M2TS_SECTION_ES *ses, GF_List *sections, u8 table_id, u16 ex_table_id, u8 version_number, u8 last_section_number, u32 status)\n{\n\tGF_M2TS_Program *prog;\n\tGF_M2TS_SECTION_ES *pmt;\n\tu32 i, nb_progs, evt_type;\n\tu32 nb_sections;\n\tu32 data_size;\n\tunsigned char *data;\n\tGF_M2TS_Section *section;\n\n\t/*wait for the last section */\n\tif (!(status&GF_M2TS_TABLE_END)) return;\n\n\t/*skip if already received*/\n\tif (status&GF_M2TS_TABLE_REPEAT) {\n\t\tif (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_PAT_REPEAT, NULL);\n\t\treturn;\n\t}\n\n\tnb_sections = gf_list_count(sections);\n\tif (nb_sections > 1) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"PAT on multiple sections not supported\\n\"));\n\t}\n\n\tsection = (GF_M2TS_Section *)gf_list_get(sections, 0);\n\tdata = section->data;\n\tdata_size = section->data_size;\n\n\tif (!(status&GF_M2TS_TABLE_UPDATE) && gf_list_count(ts->programs)) {\n\t\tif (ts->pat->demux_restarted) {\n\t\t\tts->pat->demux_restarted = 0;\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Multiple different PAT on single TS found, ignoring new PAT declaration (table id %d - extended table id %d)\\n\", table_id, ex_table_id));\n\t\t}\n\t\treturn;\n\t}\n\tnb_progs = data_size / 4;\n\n\tfor (i=0; i<nb_progs; i++) {\n\t\tu16 number, pid;\n\t\tnumber = (data[0]<<8) | data[1];\n\t\tpid = (data[2]&0x1f)<<8 | data[3];\n\t\tdata += 4;\n\t\tif (number==0) {\n\t\t\tif (!ts->nit) {\n\t\t\t\tts->nit = gf_m2ts_section_filter_new(gf_m2ts_process_nit, 0);\n\t\t\t}\n\t\t} else if (!pid) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Broken PAT found reserved PID 0, ignoring\\n\", pid));\n\t\t} else if (! ts->ess[pid]) {\n\t\t\tGF_SAFEALLOC(prog, GF_M2TS_Program);\n\t\t\tif (!prog) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Fail to allocate program for pid %d\\n\", pid));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tprog->streams = gf_list_new();\n\t\t\tprog->pmt_pid = pid;\n\t\t\tprog->number = number;\n\t\t\tprog->ts = ts;\n\t\t\tgf_list_add(ts->programs, prog);\n\t\t\tGF_SAFEALLOC(pmt, GF_M2TS_SECTION_ES);\n\t\t\tif (!pmt) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Fail to allocate pmt filter for pid %d\\n\", pid));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tpmt->flags = GF_M2TS_ES_IS_SECTION;\n\t\t\tgf_list_add(prog->streams, pmt);\n\t\t\tpmt->pid = prog->pmt_pid;\n\t\t\tpmt->program = prog;\n\t\t\tts->ess[pmt->pid] = (GF_M2TS_ES *)pmt;\n\t\t\tpmt->sec = gf_m2ts_section_filter_new(gf_m2ts_process_pmt, 0);\n\t\t}\n\t}\n\n\tevt_type = (status&GF_M2TS_TABLE_UPDATE) ? GF_M2TS_EVT_PAT_UPDATE : GF_M2TS_EVT_PAT_FOUND;\n\tif (ts->on_event) ts->on_event(ts, evt_type, NULL);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145161,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static void sp_setup(struct net_device *dev)\n{\n\t/* Finish setting up the DEVICE info. */\n\tdev->netdev_ops\t\t= &sp_netdev_ops;\n\tdev->needs_free_netdev\t= true;\n\tdev->mtu\t\t= SIXP_MTU;\n\tdev->hard_header_len\t= AX25_MAX_HEADER_LEN;\n\tdev->header_ops \t= &ax25_header_ops;\n\n\tdev->addr_len\t\t= AX25_ADDR_LEN;\n\tdev->type\t\t= ARPHRD_AX25;\n\tdev->tx_queue_len\t= 10;\n\n\t/* Only activated in AX.25 mode */\n\tmemcpy(dev->broadcast, &ax25_bcast, AX25_ADDR_LEN);\n\tdev_addr_set(dev, (u8 *)&ax25_defaddr);\n\n\tdev->flags\t\t= 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145214,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static void sp_setup(struct net_device *dev)\n{\n\t/* Finish setting up the DEVICE info. */\n\tdev->netdev_ops\t\t= &sp_netdev_ops;\n\tdev->mtu\t\t= SIXP_MTU;\n\tdev->hard_header_len\t= AX25_MAX_HEADER_LEN;\n\tdev->header_ops \t= &ax25_header_ops;\n\n\tdev->addr_len\t\t= AX25_ADDR_LEN;\n\tdev->type\t\t= ARPHRD_AX25;\n\tdev->tx_queue_len\t= 10;\n\n\t/* Only activated in AX.25 mode */\n\tmemcpy(dev->broadcast, &ax25_bcast, AX25_ADDR_LEN);\n\tdev_addr_set(dev, (u8 *)&ax25_defaddr);\n\n\tdev->flags\t\t= 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145215,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "SPL_METHOD(SplDoublyLinkedList, unserialize)\n{\n\tspl_dllist_object     *intern   = (spl_dllist_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tzval                  *flags, *elem;\n\tchar *buf;\n\tint buf_len;\n\tconst unsigned char *p, *s;\n\tphp_unserialize_data_t var_hash;\n\t\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &buf, &buf_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (buf_len == 0) {\n\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, \"Serialized string cannot be empty\");\n\t\treturn;\n\t}\n\n\ts = p = (const unsigned char*)buf;\n\tPHP_VAR_UNSERIALIZE_INIT(var_hash);\n\n\t/* flags */\n\tALLOC_INIT_ZVAL(flags);\n\tif (!php_var_unserialize(&flags, &p, s + buf_len, &var_hash TSRMLS_CC) || Z_TYPE_P(flags) != IS_LONG) {\n\t\tzval_ptr_dtor(&flags);\n\t\tgoto error;\n\t}\n\tintern->flags = Z_LVAL_P(flags);\n\tzval_ptr_dtor(&flags);\n\n\t/* elements */\n\twhile(*p == ':') {\n\t\t++p;\n\t\tALLOC_INIT_ZVAL(elem);\n\t\tif (!php_var_unserialize(&elem, &p, s + buf_len, &var_hash TSRMLS_CC)) {\n\t\t\tzval_ptr_dtor(&elem);\n\t\t\tgoto error;\n\t\t}\n\n\t\tspl_ptr_llist_push(intern->llist, elem TSRMLS_CC);\n\t}\n\n\tif (*p != '\\0') {\n\t\tgoto error;\n\t}\n\n\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\treturn;\n\nerror:\n\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, \"Error at offset %ld of %d bytes\", (long)((char*)p - buf), buf_len);\n\treturn;\n\n} /* }}} */",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145256,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "SPL_METHOD(SplDoublyLinkedList, serialize)\n{\n\tspl_dllist_object     *intern   = (spl_dllist_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tsmart_str              buf      = {0};\n\tspl_ptr_llist_element *current  = intern->llist->head, *next;\n    zval                   *flags;\n\tphp_serialize_data_t   var_hash;\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tPHP_VAR_SERIALIZE_INIT(var_hash);\n\n\t/* flags */\n\tMAKE_STD_ZVAL(flags);\n\tZVAL_LONG(flags, intern->flags);\n\tphp_var_serialize(&buf, &flags, &var_hash TSRMLS_CC);\n\tzval_ptr_dtor(&flags);\n\n\t/* elements */\n\twhile (current) {\n\t\tsmart_str_appendc(&buf, ':');\n\t\tnext = current->next;\n\n\t\tphp_var_serialize(&buf, (zval **)&current->data, &var_hash TSRMLS_CC);\n\n\t\tcurrent = next;\n\t}\n\n\tsmart_str_0(&buf);\n\n\t/* done */\n\tPHP_VAR_SERIALIZE_DESTROY(var_hash);\n\n\tif (buf.c) {\n\t\tRETURN_STRINGL(buf.c, buf.len, 0);\n\t} else {\n\t\tRETURN_NULL();\n\t}\n\n} /* }}} */",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145257,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static void __dvb_frontend_free(struct dvb_frontend *fe)\n{\n\tstruct dvb_frontend_private *fepriv = fe->frontend_priv;\n\n\tif (fepriv)\n\t\tdvb_free_device(fepriv->dvbdev);\n\n\tdvb_frontend_invoke_release(fe, fe->ops.release);\n\n\tif (fepriv)\n\t\tkfree(fepriv);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145260,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static void __dvb_frontend_free(struct dvb_frontend *fe)\n{\n\tstruct dvb_frontend_private *fepriv = fe->frontend_priv;\n\n\tif (fepriv)\n\t\tdvb_free_device(fepriv->dvbdev);\n\n\tdvb_frontend_invoke_release(fe, fe->ops.release);\n\n\tkfree(fepriv);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145261,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": " */\nstatic struct sk_buff *napi_frags_skb(struct napi_struct *napi)\n{\n\tstruct sk_buff *skb = napi->skb;\n\tconst struct ethhdr *eth;\n\tunsigned int hlen = sizeof(*eth);\n\n\tnapi->skb = NULL;\n\n\tskb_reset_mac_header(skb);\n\tskb_gro_reset_offset(skb);\n\n\teth = skb_gro_header_fast(skb, 0);\n\tif (unlikely(skb_gro_header_hard(skb, hlen))) {\n\t\teth = skb_gro_header_slow(skb, hlen, 0);\n\t\tif (unlikely(!eth)) {\n\t\t\tnet_warn_ratelimited(\"%s: dropping impossible skb from %s\\n\",\n\t\t\t\t\t     __func__, napi->dev->name);\n\t\t\tnapi_reuse_skb(napi, skb);\n\t\t\treturn NULL;\n\t\t}\n\t} else {\n\t\tgro_pull_from_frag0(skb, hlen);\n\t\tNAPI_GRO_CB(skb)->frag0 += hlen;\n\t\tNAPI_GRO_CB(skb)->frag0_len -= hlen;\n\t}\n\t__skb_pull(skb, hlen);\n\n\t/*\n\t * This works because the only protocols we care about don't require\n\t * special handling.\n\t * We'll fix it up properly in napi_frags_finish()\n\t */\n\tskb->protocol = eth->h_proto;\n\n\treturn skb;",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145334,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": " */\nstatic struct sk_buff *napi_frags_skb(struct napi_struct *napi)\n{\n\tstruct sk_buff *skb = napi->skb;\n\tconst struct ethhdr *eth;\n\tunsigned int hlen = sizeof(*eth);\n\n\tnapi->skb = NULL;\n\n\tskb_reset_mac_header(skb);\n\tskb_gro_reset_offset(skb);\n\n\tif (unlikely(skb_gro_header_hard(skb, hlen))) {\n\t\teth = skb_gro_header_slow(skb, hlen, 0);\n\t\tif (unlikely(!eth)) {\n\t\t\tnet_warn_ratelimited(\"%s: dropping impossible skb from %s\\n\",\n\t\t\t\t\t     __func__, napi->dev->name);\n\t\t\tnapi_reuse_skb(napi, skb);\n\t\t\treturn NULL;\n\t\t}\n\t} else {\n\t\teth = (const struct ethhdr *)skb->data;\n\t\tgro_pull_from_frag0(skb, hlen);\n\t\tNAPI_GRO_CB(skb)->frag0 += hlen;\n\t\tNAPI_GRO_CB(skb)->frag0_len -= hlen;\n\t}\n\t__skb_pull(skb, hlen);\n\n\t/*\n\t * This works because the only protocols we care about don't require\n\t * special handling.\n\t * We'll fix it up properly in napi_frags_finish()\n\t */\n\tskb->protocol = eth->h_proto;\n\n\treturn skb;",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145335,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "int get_netnsid_from_name(const char *name)\n{\n\tstruct {\n\t\tstruct nlmsghdr n;\n\t\tstruct rtgenmsg g;\n\t\tchar            buf[1024];\n\t} req = {\n\t\t.n.nlmsg_len = NLMSG_LENGTH(sizeof(struct rtgenmsg)),\n\t\t.n.nlmsg_flags = NLM_F_REQUEST,\n\t\t.n.nlmsg_type = RTM_GETNSID,\n\t\t.g.rtgen_family = AF_UNSPEC,\n\t};\n\tstruct nlmsghdr *answer;\n\tstruct rtattr *tb[NETNSA_MAX + 1];\n\tstruct rtgenmsg *rthdr;\n\tint len, fd;\n\n\tnetns_nsid_socket_init();\n\n\tfd = netns_get_fd(name);\n\tif (fd < 0)\n\t\treturn fd;\n\n\taddattr32(&req.n, 1024, NETNSA_FD, fd);\n\tif (rtnl_talk(&rtnsh, &req.n, &answer) < 0) {\n\t\tclose(fd);\n\t\treturn -2;\n\t}\n\tclose(fd);\n\n\t/* Validate message and parse attributes */\n\tif (answer->nlmsg_type == NLMSG_ERROR)\n\t\tgoto err_out;\n\n\trthdr = NLMSG_DATA(answer);\n\tlen = answer->nlmsg_len - NLMSG_SPACE(sizeof(*rthdr));\n\tif (len < 0)\n\t\tgoto err_out;\n\n\tparse_rtattr(tb, NETNSA_MAX, NETNS_RTA(rthdr), len);\n\n\tif (tb[NETNSA_NSID]) {\n\t\tfree(answer);\n\t\treturn rta_getattr_u32(tb[NETNSA_NSID]);\n\t}\n\nerr_out:\n\tfree(answer);\n\treturn -1;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145348,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "int get_netnsid_from_name(const char *name)\n{\n\tstruct {\n\t\tstruct nlmsghdr n;\n\t\tstruct rtgenmsg g;\n\t\tchar            buf[1024];\n\t} req = {\n\t\t.n.nlmsg_len = NLMSG_LENGTH(sizeof(struct rtgenmsg)),\n\t\t.n.nlmsg_flags = NLM_F_REQUEST,\n\t\t.n.nlmsg_type = RTM_GETNSID,\n\t\t.g.rtgen_family = AF_UNSPEC,\n\t};\n\tstruct nlmsghdr *answer;\n\tstruct rtattr *tb[NETNSA_MAX + 1];\n\tstruct rtgenmsg *rthdr;\n\tint len, fd, ret = -1;\n\n\tnetns_nsid_socket_init();\n\n\tfd = netns_get_fd(name);\n\tif (fd < 0)\n\t\treturn fd;\n\n\taddattr32(&req.n, 1024, NETNSA_FD, fd);\n\tif (rtnl_talk(&rtnsh, &req.n, &answer) < 0) {\n\t\tclose(fd);\n\t\treturn -2;\n\t}\n\tclose(fd);\n\n\t/* Validate message and parse attributes */\n\tif (answer->nlmsg_type == NLMSG_ERROR)\n\t\tgoto out;\n\n\trthdr = NLMSG_DATA(answer);\n\tlen = answer->nlmsg_len - NLMSG_SPACE(sizeof(*rthdr));\n\tif (len < 0)\n\t\tgoto out;\n\n\tparse_rtattr(tb, NETNSA_MAX, NETNS_RTA(rthdr), len);\n\n\tif (tb[NETNSA_NSID]) {\n\t\tret = rta_getattr_u32(tb[NETNSA_NSID]);\n\t}\n\nout:\n\tfree(answer);\n\treturn ret;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145349,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static ssize_t aio_poll(struct aio_kiocb *aiocb, const struct iocb *iocb)\n{\n\tstruct kioctx *ctx = aiocb->ki_ctx;\n\tstruct poll_iocb *req = &aiocb->poll;\n\tstruct aio_poll_table apt;\n\t__poll_t mask;\n\n\t/* reject any unknown events outside the normal event mask. */\n\tif ((u16)iocb->aio_buf != iocb->aio_buf)\n\t\treturn -EINVAL;\n\t/* reject fields that are not defined for poll */\n\tif (iocb->aio_offset || iocb->aio_nbytes || iocb->aio_rw_flags)\n\t\treturn -EINVAL;\n\n\tINIT_WORK(&req->work, aio_poll_complete_work);\n\treq->events = demangle_poll(iocb->aio_buf) | EPOLLERR | EPOLLHUP;\n\treq->file = fget(iocb->aio_fildes);\n\tif (unlikely(!req->file))\n\t\treturn -EBADF;\n\n\treq->head = NULL;\n\treq->woken = false;\n\treq->cancelled = false;\n\n\tapt.pt._qproc = aio_poll_queue_proc;\n\tapt.pt._key = req->events;\n\tapt.iocb = aiocb;\n\tapt.error = -EINVAL; /* same as no support for IOCB_CMD_POLL */\n\n\t/* initialized the list so that we can do list_empty checks */\n\tINIT_LIST_HEAD(&req->wait.entry);\n\tinit_waitqueue_func_entry(&req->wait, aio_poll_wake);\n\n\t/* one for removal from waitqueue, one for this function */\n\trefcount_set(&aiocb->ki_refcnt, 2);\n\n\tmask = vfs_poll(req->file, &apt.pt) & req->events;\n\tif (unlikely(!req->head)) {\n\t\t/* we did not manage to set up a waitqueue, done */\n\t\tgoto out;\n\t}\n\n\tspin_lock_irq(&ctx->ctx_lock);\n\tspin_lock(&req->head->lock);\n\tif (req->woken) {\n\t\t/* wake_up context handles the rest */\n\t\tmask = 0;\n\t\tapt.error = 0;\n\t} else if (mask || apt.error) {\n\t\t/* if we get an error or a mask we are done */\n\t\tWARN_ON_ONCE(list_empty(&req->wait.entry));\n\t\tlist_del_init(&req->wait.entry);\n\t} else {\n\t\t/* actually waiting for an event */\n\t\tlist_add_tail(&aiocb->ki_list, &ctx->active_reqs);\n\t\taiocb->ki_cancel = aio_poll_cancel;\n\t}\n\tspin_unlock(&req->head->lock);\n\tspin_unlock_irq(&ctx->ctx_lock);\n\nout:\n\tif (unlikely(apt.error)) {\n\t\tfput(req->file);\n\t\treturn apt.error;\n\t}\n\n\tif (mask)\n\t\taio_poll_complete(aiocb, mask);\n\tiocb_put(aiocb);\n\treturn 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145350,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static ssize_t aio_poll(struct aio_kiocb *aiocb, const struct iocb *iocb)\n{\n\tstruct kioctx *ctx = aiocb->ki_ctx;\n\tstruct poll_iocb *req = &aiocb->poll;\n\tstruct aio_poll_table apt;\n\t__poll_t mask;\n\n\t/* reject any unknown events outside the normal event mask. */\n\tif ((u16)iocb->aio_buf != iocb->aio_buf)\n\t\treturn -EINVAL;\n\t/* reject fields that are not defined for poll */\n\tif (iocb->aio_offset || iocb->aio_nbytes || iocb->aio_rw_flags)\n\t\treturn -EINVAL;\n\n\tINIT_WORK(&req->work, aio_poll_complete_work);\n\treq->events = demangle_poll(iocb->aio_buf) | EPOLLERR | EPOLLHUP;\n\n\treq->head = NULL;\n\treq->woken = false;\n\treq->cancelled = false;\n\n\tapt.pt._qproc = aio_poll_queue_proc;\n\tapt.pt._key = req->events;\n\tapt.iocb = aiocb;\n\tapt.error = -EINVAL; /* same as no support for IOCB_CMD_POLL */\n\n\t/* initialized the list so that we can do list_empty checks */\n\tINIT_LIST_HEAD(&req->wait.entry);\n\tinit_waitqueue_func_entry(&req->wait, aio_poll_wake);\n\n\t/* one for removal from waitqueue, one for this function */\n\trefcount_set(&aiocb->ki_refcnt, 2);\n\n\tmask = vfs_poll(req->file, &apt.pt) & req->events;\n\tif (unlikely(!req->head)) {\n\t\t/* we did not manage to set up a waitqueue, done */\n\t\tgoto out;\n\t}\n\n\tspin_lock_irq(&ctx->ctx_lock);\n\tspin_lock(&req->head->lock);\n\tif (req->woken) {\n\t\t/* wake_up context handles the rest */\n\t\tmask = 0;\n\t\tapt.error = 0;\n\t} else if (mask || apt.error) {\n\t\t/* if we get an error or a mask we are done */\n\t\tWARN_ON_ONCE(list_empty(&req->wait.entry));\n\t\tlist_del_init(&req->wait.entry);\n\t} else {\n\t\t/* actually waiting for an event */\n\t\tlist_add_tail(&aiocb->ki_list, &ctx->active_reqs);\n\t\taiocb->ki_cancel = aio_poll_cancel;\n\t}\n\tspin_unlock(&req->head->lock);\n\tspin_unlock_irq(&ctx->ctx_lock);\n\nout:\n\tif (unlikely(apt.error))\n\t\treturn apt.error;\n\n\tif (mask)\n\t\taio_poll_complete(aiocb, mask);\n\tiocb_put(aiocb);\n\treturn 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145351,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static void adu_disconnect(struct usb_interface *interface)\n{\n\tstruct adu_device *dev;\n\n\tdev = usb_get_intfdata(interface);\n\n\tmutex_lock(&dev->mtx);\t/* not interruptible */\n\tdev->udev = NULL;\t/* poison */\n\tusb_deregister_dev(interface, &adu_class);\n\tmutex_unlock(&dev->mtx);\n\n\tmutex_lock(&adutux_mutex);\n\tusb_set_intfdata(interface, NULL);\n\n\t/* if the device is not opened, then we clean up right now */\n\tif (!dev->open_count)\n\t\tadu_delete(dev);\n\n\tmutex_unlock(&adutux_mutex);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145358,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static void adu_disconnect(struct usb_interface *interface)\n{\n\tstruct adu_device *dev;\n\n\tdev = usb_get_intfdata(interface);\n\n\tusb_deregister_dev(interface, &adu_class);\n\n\tmutex_lock(&adutux_mutex);\n\tusb_set_intfdata(interface, NULL);\n\n\tmutex_lock(&dev->mtx);\t/* not interruptible */\n\tdev->udev = NULL;\t/* poison */\n\tmutex_unlock(&dev->mtx);\n\n\t/* if the device is not opened, then we clean up right now */\n\tif (!dev->open_count)\n\t\tadu_delete(dev);\n\n\tmutex_unlock(&adutux_mutex);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145359,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static void sunkbd_reinit(struct work_struct *work)\n{\n\tstruct sunkbd *sunkbd = container_of(work, struct sunkbd, tq);\n\n\twait_event_interruptible_timeout(sunkbd->wait, sunkbd->reset >= 0, HZ);\n\n\tserio_write(sunkbd->serio, SUNKBD_CMD_SETLED);\n\tserio_write(sunkbd->serio,\n\t\t(!!test_bit(LED_CAPSL,   sunkbd->dev->led) << 3) |\n\t\t(!!test_bit(LED_SCROLLL, sunkbd->dev->led) << 2) |\n\t\t(!!test_bit(LED_COMPOSE, sunkbd->dev->led) << 1) |\n\t\t !!test_bit(LED_NUML,    sunkbd->dev->led));\n\tserio_write(sunkbd->serio,\n\t\tSUNKBD_CMD_NOCLICK - !!test_bit(SND_CLICK, sunkbd->dev->snd));\n\tserio_write(sunkbd->serio,\n\t\tSUNKBD_CMD_BELLOFF - !!test_bit(SND_BELL, sunkbd->dev->snd));\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145410,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static void sunkbd_set_leds_beeps(struct sunkbd *sunkbd)\n{\n\tserio_write(sunkbd->serio, SUNKBD_CMD_SETLED);\n\tserio_write(sunkbd->serio,\n\t\t(!!test_bit(LED_CAPSL,   sunkbd->dev->led) << 3) |\n\t\t(!!test_bit(LED_SCROLLL, sunkbd->dev->led) << 2) |\n\t\t(!!test_bit(LED_COMPOSE, sunkbd->dev->led) << 1) |\n\t\t !!test_bit(LED_NUML,    sunkbd->dev->led));\n\tserio_write(sunkbd->serio,\n\t\tSUNKBD_CMD_NOCLICK - !!test_bit(SND_CLICK, sunkbd->dev->snd));\n\tserio_write(sunkbd->serio,\n\t\tSUNKBD_CMD_BELLOFF - !!test_bit(SND_BELL, sunkbd->dev->snd));\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145411,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static irqreturn_t sunkbd_interrupt(struct serio *serio,\n\t\tunsigned char data, unsigned int flags)\n{\n\tstruct sunkbd *sunkbd = serio_get_drvdata(serio);\n\n\tif (sunkbd->reset <= -1) {\n\t\t/*\n\t\t * If cp[i] is 0xff, sunkbd->reset will stay -1.\n\t\t * The keyboard sends 0xff 0xff 0xID on powerup.\n\t\t */\n\t\tsunkbd->reset = data;\n\t\twake_up_interruptible(&sunkbd->wait);\n\t\tgoto out;\n\t}\n\n\tif (sunkbd->layout == -1) {\n\t\tsunkbd->layout = data;\n\t\twake_up_interruptible(&sunkbd->wait);\n\t\tgoto out;\n\t}\n\n\tswitch (data) {\n\n\tcase SUNKBD_RET_RESET:\n\t\tschedule_work(&sunkbd->tq);\n\t\tsunkbd->reset = -1;\n\t\tbreak;\n\n\tcase SUNKBD_RET_LAYOUT:\n\t\tsunkbd->layout = -1;\n\t\tbreak;\n\n\tcase SUNKBD_RET_ALLUP: /* All keys released */\n\t\tbreak;\n\n\tdefault:\n\t\tif (!sunkbd->enabled)\n\t\t\tbreak;\n\n\t\tif (sunkbd->keycode[data & SUNKBD_KEY]) {\n\t\t\tinput_report_key(sunkbd->dev,\n\t\t\t\t\t sunkbd->keycode[data & SUNKBD_KEY],\n\t\t\t\t\t !(data & SUNKBD_RELEASE));\n\t\t\tinput_sync(sunkbd->dev);\n\t\t} else {\n\t\t\tprintk(KERN_WARNING\n\t\t\t\t\"sunkbd.c: Unknown key (scancode %#x) %s.\\n\",\n\t\t\t\tdata & SUNKBD_KEY,\n\t\t\t\tdata & SUNKBD_RELEASE ? \"released\" : \"pressed\");\n\t\t}\n\t}\nout:\n\treturn IRQ_HANDLED;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145412,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static irqreturn_t sunkbd_interrupt(struct serio *serio,\n\t\tunsigned char data, unsigned int flags)\n{\n\tstruct sunkbd *sunkbd = serio_get_drvdata(serio);\n\n\tif (sunkbd->reset <= -1) {\n\t\t/*\n\t\t * If cp[i] is 0xff, sunkbd->reset will stay -1.\n\t\t * The keyboard sends 0xff 0xff 0xID on powerup.\n\t\t */\n\t\tsunkbd->reset = data;\n\t\twake_up_interruptible(&sunkbd->wait);\n\t\tgoto out;\n\t}\n\n\tif (sunkbd->layout == -1) {\n\t\tsunkbd->layout = data;\n\t\twake_up_interruptible(&sunkbd->wait);\n\t\tgoto out;\n\t}\n\n\tswitch (data) {\n\n\tcase SUNKBD_RET_RESET:\n\t\tif (sunkbd->enabled)\n\t\t\tschedule_work(&sunkbd->tq);\n\t\tsunkbd->reset = -1;\n\t\tbreak;\n\n\tcase SUNKBD_RET_LAYOUT:\n\t\tsunkbd->layout = -1;\n\t\tbreak;\n\n\tcase SUNKBD_RET_ALLUP: /* All keys released */\n\t\tbreak;\n\n\tdefault:\n\t\tif (!sunkbd->enabled)\n\t\t\tbreak;\n\n\t\tif (sunkbd->keycode[data & SUNKBD_KEY]) {\n\t\t\tinput_report_key(sunkbd->dev,\n\t\t\t\t\t sunkbd->keycode[data & SUNKBD_KEY],\n\t\t\t\t\t !(data & SUNKBD_RELEASE));\n\t\t\tinput_sync(sunkbd->dev);\n\t\t} else {\n\t\t\tprintk(KERN_WARNING\n\t\t\t\t\"sunkbd.c: Unknown key (scancode %#x) %s.\\n\",\n\t\t\t\tdata & SUNKBD_KEY,\n\t\t\t\tdata & SUNKBD_RELEASE ? \"released\" : \"pressed\");\n\t\t}\n\t}\nout:\n\treturn IRQ_HANDLED;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145413,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int phar_extract_file(zend_bool overwrite, phar_entry_info *entry, char *dest, int dest_len, char **error TSRMLS_DC) /* {{{ */\n{\n\tphp_stream_statbuf ssb;\n\tint len;\n\tphp_stream *fp;\n\tchar *fullpath;\n\tconst char *slash;\n\tmode_t mode;\n\tcwd_state new_state;\n\tchar *filename;\n\tsize_t filename_len;\n\n\tif (entry->is_mounted) {\n\t\t/* silently ignore mounted entries */\n\t\treturn SUCCESS;\n\t}\n\n\tif (entry->filename_len >= sizeof(\".phar\")-1 && !memcmp(entry->filename, \".phar\", sizeof(\".phar\")-1)) {\n\t\treturn SUCCESS;\n\t}\n\t/* strip .. from path and restrict it to be under dest directory */\n\tnew_state.cwd = (char*)emalloc(2);\n\tnew_state.cwd[0] = DEFAULT_SLASH;\n\tnew_state.cwd[1] = '\\0';\n\tnew_state.cwd_length = 1;\n\tif (virtual_file_ex(&new_state, entry->filename, NULL, CWD_EXPAND TSRMLS_CC) != 0 ||\n\t\t\tnew_state.cwd_length <= 1) {\n\t\tif (EINVAL == errno && entry->filename_len > 50) {\n\t\t\tchar *tmp = estrndup(entry->filename, 50);\n\t\t\tspprintf(error, 4096, \"Cannot extract \\\"%s...\\\" to \\\"%s...\\\", extracted filename is too long for filesystem\", tmp, dest);\n\t\t\tefree(tmp);\n\t\t} else {\n\t\t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\", internal error\", entry->filename);\n\t\t}\n\t\tefree(new_state.cwd);\n\t\treturn FAILURE;\n\t}\n\tfilename = new_state.cwd + 1;\n\tfilename_len = new_state.cwd_length - 1;\n#ifdef PHP_WIN32\n\t/* unixify the path back, otherwise non zip formats might be broken */\n\t{\n\t\tint cnt = filename_len;\n\n\t\tdo {\n\t\t\tif ('\\\\' == filename[cnt]) {\n\t\t\t\tfilename[cnt] = '/';\n\t\t\t}\n\t\t} while (cnt-- >= 0);\n\t}\n#endif\n\n\tlen = spprintf(&fullpath, 0, \"%s/%s\", dest, filename);\n\n\tif (len >= MAXPATHLEN) {\n\t\tchar *tmp;\n\t\t/* truncate for error message */\n\t\tfullpath[50] = '\\0';\n\t\tif (entry->filename_len > 50) {\n\t\t\ttmp = estrndup(entry->filename, 50);\n\t\t\tspprintf(error, 4096, \"Cannot extract \\\"%s...\\\" to \\\"%s...\\\", extracted filename is too long for filesystem\", tmp, fullpath);\n\t\t\tefree(tmp);\n\t\t} else {\n\t\t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\" to \\\"%s...\\\", extracted filename is too long for filesystem\", entry->filename, fullpath);\n\t\t}\n\t\tefree(fullpath);\n\t\tefree(new_state.cwd);\n\t\treturn FAILURE;\n\t}\n\n\tif (!len) {\n\t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\", internal error\", entry->filename);\n\t\tefree(fullpath);\n\t\tefree(new_state.cwd);\n\t\treturn FAILURE;\n\t}\n\n\tif (PHAR_OPENBASEDIR_CHECKPATH(fullpath)) {\n\t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\" to \\\"%s\\\", openbasedir/safe mode restrictions in effect\", entry->filename, fullpath);\n\t\tefree(fullpath);\n\t\tefree(new_state.cwd);\n\t\treturn FAILURE;\n\t}\n\n\t/* let see if the path already exists */\n\tif (!overwrite && SUCCESS == php_stream_stat_path(fullpath, &ssb)) {\n\t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\" to \\\"%s\\\", path already exists\", entry->filename, fullpath);\n\t\tefree(fullpath);\n\t\tefree(new_state.cwd);\n\t\treturn FAILURE;\n\t}\n\n\t/* perform dirname */\n\tslash = zend_memrchr(filename, '/', filename_len);\n\n\tif (slash) {\n\t\tfullpath[dest_len + (slash - filename) + 1] = '\\0';\n\t} else {\n\t\tfullpath[dest_len] = '\\0';\n\t}\n\n\tif (FAILURE == php_stream_stat_path(fullpath, &ssb)) {\n\t\tif (entry->is_dir) {\n\t\t\tif (!php_stream_mkdir(fullpath, entry->flags & PHAR_ENT_PERM_MASK,  PHP_STREAM_MKDIR_RECURSIVE, NULL)) {\n\t\t\t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\", could not create directory \\\"%s\\\"\", entry->filename, fullpath);\n\t\t\t\tefree(fullpath);\n\t\t\t\tfree(new_state.cwd);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!php_stream_mkdir(fullpath, 0777,  PHP_STREAM_MKDIR_RECURSIVE, NULL)) {\n\t\t\t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\", could not create directory \\\"%s\\\"\", entry->filename, fullpath);\n\t\t\t\tefree(fullpath);\n\t\t\t\tfree(new_state.cwd);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (slash) {\n\t\tfullpath[dest_len + (slash - filename) + 1] = '/';\n\t} else {\n\t\tfullpath[dest_len] = '/';\n\t}\n\n\tfilename = NULL;\n\tefree(new_state.cwd);\n\t/* it is a standalone directory, job done */\n\tif (entry->is_dir) {\n\t\tefree(fullpath);\n\t\treturn SUCCESS;\n\t}\n\n#if PHP_API_VERSION < 20100412\n\tfp = php_stream_open_wrapper(fullpath, \"w+b\", REPORT_ERRORS|ENFORCE_SAFE_MODE, NULL);\n#else\n\tfp = php_stream_open_wrapper(fullpath, \"w+b\", REPORT_ERRORS, NULL);\n#endif\n\n\tif (!fp) {\n\t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\", could not open for writing \\\"%s\\\"\", entry->filename, fullpath);\n\t\tefree(fullpath);\n\t\treturn FAILURE;\n\t}\n\n\tif (!phar_get_efp(entry, 0 TSRMLS_CC)) {\n\t\tif (FAILURE == phar_open_entry_fp(entry, error, 1 TSRMLS_CC)) {\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\" to \\\"%s\\\", unable to open internal file pointer: %s\", entry->filename, fullpath, *error);\n\t\t\t} else {\n\t\t\t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\" to \\\"%s\\\", unable to open internal file pointer\", entry->filename, fullpath);\n\t\t\t}\n\t\t\tefree(fullpath);\n\t\t\tphp_stream_close(fp);\n\t\t\treturn FAILURE;\n\t\t}\n\t}\n\n\tif (FAILURE == phar_seek_efp(entry, 0, SEEK_SET, 0, 0 TSRMLS_CC)) {\n\t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\" to \\\"%s\\\", unable to seek internal file pointer\", entry->filename, fullpath);\n\t\tefree(fullpath);\n\t\tphp_stream_close(fp);\n\t\treturn FAILURE;\n\t}\n\n\tif (SUCCESS != php_stream_copy_to_stream_ex(phar_get_efp(entry, 0 TSRMLS_CC), fp, entry->uncompressed_filesize, NULL)) {\n\t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\" to \\\"%s\\\", copying contents failed\", entry->filename, fullpath);\n\t\tefree(fullpath);\n\t\tphp_stream_close(fp);\n\t\treturn FAILURE;\n\t}\n\n\tphp_stream_close(fp);\n\tmode = (mode_t) entry->flags & PHAR_ENT_PERM_MASK;\n\n\tif (FAILURE == VCWD_CHMOD(fullpath, mode)) {\n\t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\" to \\\"%s\\\", setting file permissions failed\", entry->filename, fullpath);\n\t\tefree(fullpath);\n\t\treturn FAILURE;\n\t}\n\n\tefree(fullpath);\n\treturn SUCCESS;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145442,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int phar_extract_file(zend_bool overwrite, phar_entry_info *entry, char *dest, int dest_len, char **error TSRMLS_DC) /* {{{ */\n{\n\tphp_stream_statbuf ssb;\n\tint len;\n\tphp_stream *fp;\n\tchar *fullpath;\n\tconst char *slash;\n\tmode_t mode;\n\tcwd_state new_state;\n\tchar *filename;\n\tsize_t filename_len;\n\n\tif (entry->is_mounted) {\n\t\t/* silently ignore mounted entries */\n\t\treturn SUCCESS;\n\t}\n\n\tif (entry->filename_len >= sizeof(\".phar\")-1 && !memcmp(entry->filename, \".phar\", sizeof(\".phar\")-1)) {\n\t\treturn SUCCESS;\n\t}\n\t/* strip .. from path and restrict it to be under dest directory */\n\tnew_state.cwd = (char*)emalloc(2);\n\tnew_state.cwd[0] = DEFAULT_SLASH;\n\tnew_state.cwd[1] = '\\0';\n\tnew_state.cwd_length = 1;\n\tif (virtual_file_ex(&new_state, entry->filename, NULL, CWD_EXPAND TSRMLS_CC) != 0 ||\n\t\t\tnew_state.cwd_length <= 1) {\n\t\tif (EINVAL == errno && entry->filename_len > 50) {\n\t\t\tchar *tmp = estrndup(entry->filename, 50);\n\t\t\tspprintf(error, 4096, \"Cannot extract \\\"%s...\\\" to \\\"%s...\\\", extracted filename is too long for filesystem\", tmp, dest);\n\t\t\tefree(tmp);\n\t\t} else {\n\t\t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\", internal error\", entry->filename);\n\t\t}\n\t\tefree(new_state.cwd);\n\t\treturn FAILURE;\n\t}\n\tfilename = new_state.cwd + 1;\n\tfilename_len = new_state.cwd_length - 1;\n#ifdef PHP_WIN32\n\t/* unixify the path back, otherwise non zip formats might be broken */\n\t{\n\t\tint cnt = filename_len;\n\n\t\tdo {\n\t\t\tif ('\\\\' == filename[cnt]) {\n\t\t\t\tfilename[cnt] = '/';\n\t\t\t}\n\t\t} while (cnt-- >= 0);\n\t}\n#endif\n\n\tlen = spprintf(&fullpath, 0, \"%s/%s\", dest, filename);\n\n\tif (len >= MAXPATHLEN) {\n\t\tchar *tmp;\n\t\t/* truncate for error message */\n\t\tfullpath[50] = '\\0';\n\t\tif (entry->filename_len > 50) {\n\t\t\ttmp = estrndup(entry->filename, 50);\n\t\t\tspprintf(error, 4096, \"Cannot extract \\\"%s...\\\" to \\\"%s...\\\", extracted filename is too long for filesystem\", tmp, fullpath);\n\t\t\tefree(tmp);\n\t\t} else {\n\t\t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\" to \\\"%s...\\\", extracted filename is too long for filesystem\", entry->filename, fullpath);\n\t\t}\n\t\tefree(fullpath);\n\t\tefree(new_state.cwd);\n\t\treturn FAILURE;\n\t}\n\n\tif (!len) {\n\t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\", internal error\", entry->filename);\n\t\tefree(fullpath);\n\t\tefree(new_state.cwd);\n\t\treturn FAILURE;\n\t}\n\n\tif (PHAR_OPENBASEDIR_CHECKPATH(fullpath)) {\n\t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\" to \\\"%s\\\", openbasedir/safe mode restrictions in effect\", entry->filename, fullpath);\n\t\tefree(fullpath);\n\t\tefree(new_state.cwd);\n\t\treturn FAILURE;\n\t}\n\n\t/* let see if the path already exists */\n\tif (!overwrite && SUCCESS == php_stream_stat_path(fullpath, &ssb)) {\n\t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\" to \\\"%s\\\", path already exists\", entry->filename, fullpath);\n\t\tefree(fullpath);\n\t\tefree(new_state.cwd);\n\t\treturn FAILURE;\n\t}\n\n\t/* perform dirname */\n\tslash = zend_memrchr(filename, '/', filename_len);\n\n\tif (slash) {\n\t\tfullpath[dest_len + (slash - filename) + 1] = '\\0';\n\t} else {\n\t\tfullpath[dest_len] = '\\0';\n\t}\n\n\tif (FAILURE == php_stream_stat_path(fullpath, &ssb)) {\n\t\tif (entry->is_dir) {\n\t\t\tif (!php_stream_mkdir(fullpath, entry->flags & PHAR_ENT_PERM_MASK,  PHP_STREAM_MKDIR_RECURSIVE, NULL)) {\n\t\t\t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\", could not create directory \\\"%s\\\"\", entry->filename, fullpath);\n\t\t\t\tefree(fullpath);\n\t\t\t\tefree(new_state.cwd);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!php_stream_mkdir(fullpath, 0777,  PHP_STREAM_MKDIR_RECURSIVE, NULL)) {\n\t\t\t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\", could not create directory \\\"%s\\\"\", entry->filename, fullpath);\n\t\t\t\tefree(fullpath);\n\t\t\t\tefree(new_state.cwd);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (slash) {\n\t\tfullpath[dest_len + (slash - filename) + 1] = '/';\n\t} else {\n\t\tfullpath[dest_len] = '/';\n\t}\n\n\tfilename = NULL;\n\tefree(new_state.cwd);\n\t/* it is a standalone directory, job done */\n\tif (entry->is_dir) {\n\t\tefree(fullpath);\n\t\treturn SUCCESS;\n\t}\n\n#if PHP_API_VERSION < 20100412\n\tfp = php_stream_open_wrapper(fullpath, \"w+b\", REPORT_ERRORS|ENFORCE_SAFE_MODE, NULL);\n#else\n\tfp = php_stream_open_wrapper(fullpath, \"w+b\", REPORT_ERRORS, NULL);\n#endif\n\n\tif (!fp) {\n\t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\", could not open for writing \\\"%s\\\"\", entry->filename, fullpath);\n\t\tefree(fullpath);\n\t\treturn FAILURE;\n\t}\n\n\tif (!phar_get_efp(entry, 0 TSRMLS_CC)) {\n\t\tif (FAILURE == phar_open_entry_fp(entry, error, 1 TSRMLS_CC)) {\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\" to \\\"%s\\\", unable to open internal file pointer: %s\", entry->filename, fullpath, *error);\n\t\t\t} else {\n\t\t\t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\" to \\\"%s\\\", unable to open internal file pointer\", entry->filename, fullpath);\n\t\t\t}\n\t\t\tefree(fullpath);\n\t\t\tphp_stream_close(fp);\n\t\t\treturn FAILURE;\n\t\t}\n\t}\n\n\tif (FAILURE == phar_seek_efp(entry, 0, SEEK_SET, 0, 0 TSRMLS_CC)) {\n\t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\" to \\\"%s\\\", unable to seek internal file pointer\", entry->filename, fullpath);\n\t\tefree(fullpath);\n\t\tphp_stream_close(fp);\n\t\treturn FAILURE;\n\t}\n\n\tif (SUCCESS != php_stream_copy_to_stream_ex(phar_get_efp(entry, 0 TSRMLS_CC), fp, entry->uncompressed_filesize, NULL)) {\n\t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\" to \\\"%s\\\", copying contents failed\", entry->filename, fullpath);\n\t\tefree(fullpath);\n\t\tphp_stream_close(fp);\n\t\treturn FAILURE;\n\t}\n\n\tphp_stream_close(fp);\n\tmode = (mode_t) entry->flags & PHAR_ENT_PERM_MASK;\n\n\tif (FAILURE == VCWD_CHMOD(fullpath, mode)) {\n\t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\" to \\\"%s\\\", setting file permissions failed\", entry->filename, fullpath);\n\t\tefree(fullpath);\n\t\treturn FAILURE;\n\t}\n\n\tefree(fullpath);\n\treturn SUCCESS;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145443,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "void dvb_usb_device_exit(struct usb_interface *intf)\n{\n\tstruct dvb_usb_device *d = usb_get_intfdata(intf);\n\tconst char *name = \"generic DVB-USB module\";\n\n\tusb_set_intfdata(intf, NULL);\n\tif (d != NULL && d->desc != NULL) {\n\t\tname = d->desc->name;\n\t\tdvb_usb_exit(d);\n\t}\n\tinfo(\"%s successfully deinitialized and disconnected.\", name);\n\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145528,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "void dvb_usb_device_exit(struct usb_interface *intf)\n{\n\tstruct dvb_usb_device *d = usb_get_intfdata(intf);\n\tconst char *default_name = \"generic DVB-USB module\";\n\tchar name[40];\n\n\tusb_set_intfdata(intf, NULL);\n\tif (d != NULL && d->desc != NULL) {\n\t\tstrscpy(name, d->desc->name, sizeof(name));\n\t\tdvb_usb_exit(d);\n\t} else {\n\t\tstrscpy(name, default_name, sizeof(name));\n\t}\n\tinfo(\"%s successfully deinitialized and disconnected.\", name);\n\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145529,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "void xfrm_state_fini(struct net *net)\n{\n\tunsigned int sz;\n\n\tflush_work(&net->xfrm.state_hash_work);\n\tflush_work(&xfrm_state_gc_work);\n\txfrm_state_flush(net, IPSEC_PROTO_ANY, false, true);\n\n\tWARN_ON(!list_empty(&net->xfrm.state_all));\n\n\tsz = (net->xfrm.state_hmask + 1) * sizeof(struct hlist_head);\n\tWARN_ON(!hlist_empty(net->xfrm.state_byspi));\n\txfrm_hash_free(net->xfrm.state_byspi, sz);\n\tWARN_ON(!hlist_empty(net->xfrm.state_bysrc));\n\txfrm_hash_free(net->xfrm.state_bysrc, sz);\n\tWARN_ON(!hlist_empty(net->xfrm.state_bydst));\n\txfrm_hash_free(net->xfrm.state_bydst, sz);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145534,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "void xfrm_state_fini(struct net *net)\n{\n\tunsigned int sz;\n\n\tflush_work(&net->xfrm.state_hash_work);\n\tflush_work(&xfrm_state_gc_work);\n\txfrm_state_flush(net, 0, false, true);\n\n\tWARN_ON(!list_empty(&net->xfrm.state_all));\n\n\tsz = (net->xfrm.state_hmask + 1) * sizeof(struct hlist_head);\n\tWARN_ON(!hlist_empty(net->xfrm.state_byspi));\n\txfrm_hash_free(net->xfrm.state_byspi, sz);\n\tWARN_ON(!hlist_empty(net->xfrm.state_bysrc));\n\txfrm_hash_free(net->xfrm.state_bysrc, sz);\n\tWARN_ON(!hlist_empty(net->xfrm.state_bydst));\n\txfrm_hash_free(net->xfrm.state_bydst, sz);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145535,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static void event_cap (IRC_SERVER_REC *server, char *args, char *nick, char *address)\n{\n\tGSList *tmp;\n\tGString *cmd;\n\tchar *params, *evt, *list, *star, **caps;\n\tint i, caps_length, disable, avail_caps, multiline;\n\n\tparams = event_get_params(args, 4, NULL, &evt, &star, &list);\n\tif (params == NULL)\n\t\treturn;\n\n\t/* Multiline responses have an additional parameter and we have to do\n\t * this stupid dance to parse them */\n\tif (!g_ascii_strcasecmp(evt, \"LS\") && !strcmp(star, \"*\")) {\n\t\tmultiline = TRUE;\n\t}\n\t/* This branch covers the '*' parameter isn't present, adjust the\n\t * parameter pointer to compensate for this */\n\telse if (list[0] == '\\0') {\n\t\tmultiline = FALSE;\n\t\tlist = star;\n\t}\n\t/* Malformed request, terminate the negotiation */\n\telse {\n\t\tirc_cap_finish_negotiation(server);\n\t\tg_warn_if_reached();\n\t\treturn;\n\t}\n\n\t/* The table is created only when needed */\n\tif (server->cap_supported == NULL) {\n\t\tserver->cap_supported = g_hash_table_new_full(g_str_hash,\n\t\t\t\t\t\t\t      g_str_equal,\n\t\t\t\t\t\t\t      g_free, g_free);\n\t}\n\n\t/* Strip the trailing whitespaces before splitting the string, some servers send responses with\n\t * superfluous whitespaces that g_strsplit the interprets as tokens */\n\tcaps = g_strsplit(g_strchomp(list), \" \", -1);\n\tcaps_length = g_strv_length(caps);\n\n\tif (!g_ascii_strcasecmp(evt, \"LS\")) {\n\t\tif (!server->cap_in_multiline) {\n\t\t\t/* Throw away everything and start from scratch */\n\t\t\tg_hash_table_remove_all(server->cap_supported);\n\t\t}\n\n\t\tserver->cap_in_multiline = multiline;\n\n\t\t/* Create a list of the supported caps */\n\t\tfor (i = 0; i < caps_length; i++) {\n\t\t\tchar *key, *val;\n\n\t\t\tif (!parse_cap_name(caps[i], &key, &val)) {\n\t\t\t\tg_warning(\"Invalid CAP %s key/value pair\", evt);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (g_hash_table_lookup_extended(server->cap_supported, key, NULL, NULL)) {\n\t\t\t\t/* The specification doesn't say anything about\n\t\t\t\t * duplicated values, let's just warn the user */\n\t\t\t\tg_warning(\"The server sent the %s capability twice\", key);\n\t\t\t}\n\t\t\tg_hash_table_insert(server->cap_supported, key, val);\n\t\t}\n\n\t\t/* A multiline response is always terminated by a normal one,\n\t\t * wait until we receive that one to require any CAP */\n\t\tif (multiline == FALSE) {\n\t\t\t/* No CAP has been requested */\n\t\t\tif (server->cap_queue == NULL) {\n\t\t\t\tirc_cap_finish_negotiation(server);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcmd = g_string_new(\"CAP REQ :\");\n\n\t\t\t\tavail_caps = 0;\n\n\t\t\t\t/* To process the queue in order, we need to reverse the stack once */\n\t\t\t\tserver->cap_queue = g_slist_reverse(server->cap_queue);\n\n\t\t\t\t/* Check whether the cap is supported by the server */\n\t\t\t\tfor (tmp = server->cap_queue; tmp != NULL; tmp = tmp->next) {\n\t\t\t\t\tif (g_hash_table_lookup_extended(server->cap_supported, tmp->data, NULL, NULL)) {\n\t\t\t\t\t\tif (avail_caps > 0)\n\t\t\t\t\t\t\tg_string_append_c(cmd, ' ');\n\t\t\t\t\t\tg_string_append(cmd, tmp->data);\n\n\t\t\t\t\t\tavail_caps++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/* Clear the queue here */\n\t\t\t\tgslist_free_full(server->cap_queue, (GDestroyNotify) g_free);\n\t\t\t\tserver->cap_queue = NULL;\n\n\t\t\t\t/* If the server doesn't support any cap we requested close the negotiation here */\n\t\t\t\tif (avail_caps > 0) {\n\t\t\t\t\tsignal_emit(\"server cap req\", 2, server, cmd->str + sizeof(\"CAP REQ :\") - 1);\n\t\t\t\t\tirc_send_cmd_now(server, cmd->str);\n\t\t\t\t} else {\n\t\t\t\t\tirc_cap_finish_negotiation(server);\n\t\t\t\t}\n\n\t\t\t\tg_string_free(cmd, TRUE);\n\t\t\t}\n\t\t}\n\t}\n\telse if (!g_ascii_strcasecmp(evt, \"ACK\")) {\n\t\tint got_sasl = FALSE;\n\n\t\t/* Emit a signal for every ack'd cap */\n\t\tfor (i = 0; i < caps_length; i++) {\n\t\t\tdisable = (*caps[i] == '-');\n\n\t\t\tif (disable)\n\t\t\t\tserver->cap_active = gslist_delete_string(server->cap_active, caps[i] + 1, g_free);\n\t\t\telse\n\t\t\t\tserver->cap_active = g_slist_prepend(server->cap_active, g_strdup(caps[i]));\n\n\t\t\tif (!strcmp(caps[i], \"sasl\"))\n\t\t\t\tgot_sasl = TRUE;\n\n\t\t\tcap_emit_signal(server, \"ack\", caps[i]);\n\t\t}\n\n\t\t/* Hopefully the server has ack'd all the caps requested and we're ready to terminate the\n\t\t * negotiation, unless sasl was requested. In this case we must not terminate the negotiation\n\t\t * until the sasl handshake is over. */\n\t\tif (got_sasl == FALSE)\n\t\t\tirc_cap_finish_negotiation(server);\n\t}\n\telse if (!g_ascii_strcasecmp(evt, \"NAK\")) {\n\t\tg_warning(\"The server answered with a NAK to our CAP request, this should not happen\");\n\n\t\t/* A NAK'd request means that a required cap can't be enabled or disabled, don't update the\n\t\t * list of active caps and notify the listeners. */\n\t\tfor (i = 0; i < caps_length; i++)\n\t\t\tcap_emit_signal(server, \"nak\", caps[i]);\n\t}\n\telse if (!g_ascii_strcasecmp(evt, \"NEW\")) {\n\t\tfor (i = 0; i < caps_length; i++) {\n\t\t\tchar *key, *val;\n\n\t\t\tif (!parse_cap_name(caps[i], &key, &val)) {\n\t\t\t\tg_warning(\"Invalid CAP %s key/value pair\", evt);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tg_hash_table_insert(server->cap_supported, key, val);\n\t\t\tcap_emit_signal(server, \"new\", key);\n\t\t}\n\t}\n\telse if (!g_ascii_strcasecmp(evt, \"DEL\")) {\n\t\tfor (i = 0; i < caps_length; i++) {\n\t\t\tchar *key, *val;\n\n\t\t\tif (!parse_cap_name(caps[i], &key, &val)) {\n\t\t\t\tg_warning(\"Invalid CAP %s key/value pair\", evt);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tg_hash_table_remove(server->cap_supported, key);\n\t\t\tcap_emit_signal(server, \"delete\", key);\n\t\t\t/* The server removed this CAP, remove it from the list\n\t\t\t * of the active ones if we had requested it */\n\t\t\tserver->cap_active = gslist_delete_string(server->cap_active, key, g_free);\n\t\t\t/* We don't transfer the ownership of those two\n\t\t\t * variables this time, just free them when we're done. */\n\t\t\tg_free(key);\n\t\t\tg_free(val);\n\t\t}\n\t}\n\telse if (!g_ascii_strcasecmp(evt, \"LIST\")) {\n\t\t/* do nothing, fe-cap will handle it */\n\t}\n\telse {\n\t\tg_warning(\"Unhandled CAP subcommand %s\", evt);\n\t}\n\n\tg_strfreev(caps);\n\tg_free(params);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145558,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static void event_cap (IRC_SERVER_REC *server, char *args, char *nick, char *address)\n{\n\tGSList *tmp;\n\tGString *cmd;\n\tchar *params, *evt, *list, *star, **caps;\n\tint i, caps_length, disable, avail_caps, multiline;\n\n\tparams = event_get_params(args, 4, NULL, &evt, &star, &list);\n\tif (params == NULL)\n\t\treturn;\n\n\t/* Multiline responses have an additional parameter and we have to do\n\t * this stupid dance to parse them */\n\tif (!g_ascii_strcasecmp(evt, \"LS\") && !strcmp(star, \"*\")) {\n\t\tmultiline = TRUE;\n\t}\n\t/* This branch covers the '*' parameter isn't present, adjust the\n\t * parameter pointer to compensate for this */\n\telse if (list[0] == '\\0') {\n\t\tmultiline = FALSE;\n\t\tlist = star;\n\t}\n\t/* Malformed request, terminate the negotiation */\n\telse {\n\t\tirc_cap_finish_negotiation(server);\n\t\tg_warn_if_reached();\n\t\treturn;\n\t}\n\n\t/* The table is created only when needed */\n\tif (server->cap_supported == NULL) {\n\t\tserver->cap_supported = g_hash_table_new_full(g_str_hash,\n\t\t\t\t\t\t\t      g_str_equal,\n\t\t\t\t\t\t\t      g_free, g_free);\n\t}\n\n\t/* Strip the trailing whitespaces before splitting the string, some servers send responses with\n\t * superfluous whitespaces that g_strsplit the interprets as tokens */\n\tcaps = g_strsplit(g_strchomp(list), \" \", -1);\n\tcaps_length = g_strv_length(caps);\n\n\tif (!g_ascii_strcasecmp(evt, \"LS\")) {\n\t\tif (!server->cap_in_multiline) {\n\t\t\t/* Throw away everything and start from scratch */\n\t\t\tg_hash_table_remove_all(server->cap_supported);\n\t\t}\n\n\t\tserver->cap_in_multiline = multiline;\n\n\t\t/* Create a list of the supported caps */\n\t\tfor (i = 0; i < caps_length; i++) {\n\t\t\tchar *key, *val;\n\n\t\t\tif (!parse_cap_name(caps[i], &key, &val)) {\n\t\t\t\tg_warning(\"Invalid CAP %s key/value pair\", evt);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (g_hash_table_lookup_extended(server->cap_supported, key, NULL, NULL)) {\n\t\t\t\t/* The specification doesn't say anything about\n\t\t\t\t * duplicated values, let's just warn the user */\n\t\t\t\tg_warning(\"The server sent the %s capability twice\", key);\n\t\t\t}\n\t\t\tg_hash_table_replace(server->cap_supported, key, val);\n\t\t}\n\n\t\t/* A multiline response is always terminated by a normal one,\n\t\t * wait until we receive that one to require any CAP */\n\t\tif (multiline == FALSE) {\n\t\t\t/* No CAP has been requested */\n\t\t\tif (server->cap_queue == NULL) {\n\t\t\t\tirc_cap_finish_negotiation(server);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcmd = g_string_new(\"CAP REQ :\");\n\n\t\t\t\tavail_caps = 0;\n\n\t\t\t\t/* To process the queue in order, we need to reverse the stack once */\n\t\t\t\tserver->cap_queue = g_slist_reverse(server->cap_queue);\n\n\t\t\t\t/* Check whether the cap is supported by the server */\n\t\t\t\tfor (tmp = server->cap_queue; tmp != NULL; tmp = tmp->next) {\n\t\t\t\t\tif (g_hash_table_lookup_extended(server->cap_supported, tmp->data, NULL, NULL)) {\n\t\t\t\t\t\tif (avail_caps > 0)\n\t\t\t\t\t\t\tg_string_append_c(cmd, ' ');\n\t\t\t\t\t\tg_string_append(cmd, tmp->data);\n\n\t\t\t\t\t\tavail_caps++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/* Clear the queue here */\n\t\t\t\tgslist_free_full(server->cap_queue, (GDestroyNotify) g_free);\n\t\t\t\tserver->cap_queue = NULL;\n\n\t\t\t\t/* If the server doesn't support any cap we requested close the negotiation here */\n\t\t\t\tif (avail_caps > 0) {\n\t\t\t\t\tsignal_emit(\"server cap req\", 2, server, cmd->str + sizeof(\"CAP REQ :\") - 1);\n\t\t\t\t\tirc_send_cmd_now(server, cmd->str);\n\t\t\t\t} else {\n\t\t\t\t\tirc_cap_finish_negotiation(server);\n\t\t\t\t}\n\n\t\t\t\tg_string_free(cmd, TRUE);\n\t\t\t}\n\t\t}\n\t}\n\telse if (!g_ascii_strcasecmp(evt, \"ACK\")) {\n\t\tint got_sasl = FALSE;\n\n\t\t/* Emit a signal for every ack'd cap */\n\t\tfor (i = 0; i < caps_length; i++) {\n\t\t\tdisable = (*caps[i] == '-');\n\n\t\t\tif (disable)\n\t\t\t\tserver->cap_active = gslist_delete_string(server->cap_active, caps[i] + 1, g_free);\n\t\t\telse\n\t\t\t\tserver->cap_active = g_slist_prepend(server->cap_active, g_strdup(caps[i]));\n\n\t\t\tif (!strcmp(caps[i], \"sasl\"))\n\t\t\t\tgot_sasl = TRUE;\n\n\t\t\tcap_emit_signal(server, \"ack\", caps[i]);\n\t\t}\n\n\t\t/* Hopefully the server has ack'd all the caps requested and we're ready to terminate the\n\t\t * negotiation, unless sasl was requested. In this case we must not terminate the negotiation\n\t\t * until the sasl handshake is over. */\n\t\tif (got_sasl == FALSE)\n\t\t\tirc_cap_finish_negotiation(server);\n\t}\n\telse if (!g_ascii_strcasecmp(evt, \"NAK\")) {\n\t\tg_warning(\"The server answered with a NAK to our CAP request, this should not happen\");\n\n\t\t/* A NAK'd request means that a required cap can't be enabled or disabled, don't update the\n\t\t * list of active caps and notify the listeners. */\n\t\tfor (i = 0; i < caps_length; i++)\n\t\t\tcap_emit_signal(server, \"nak\", caps[i]);\n\t}\n\telse if (!g_ascii_strcasecmp(evt, \"NEW\")) {\n\t\tfor (i = 0; i < caps_length; i++) {\n\t\t\tchar *key, *val;\n\n\t\t\tif (!parse_cap_name(caps[i], &key, &val)) {\n\t\t\t\tg_warning(\"Invalid CAP %s key/value pair\", evt);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tg_hash_table_replace(server->cap_supported, key, val);\n\t\t\tcap_emit_signal(server, \"new\", key);\n\t\t}\n\t}\n\telse if (!g_ascii_strcasecmp(evt, \"DEL\")) {\n\t\tfor (i = 0; i < caps_length; i++) {\n\t\t\tchar *key, *val;\n\n\t\t\tif (!parse_cap_name(caps[i], &key, &val)) {\n\t\t\t\tg_warning(\"Invalid CAP %s key/value pair\", evt);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tg_hash_table_remove(server->cap_supported, key);\n\t\t\tcap_emit_signal(server, \"delete\", key);\n\t\t\t/* The server removed this CAP, remove it from the list\n\t\t\t * of the active ones if we had requested it */\n\t\t\tserver->cap_active = gslist_delete_string(server->cap_active, key, g_free);\n\t\t\t/* We don't transfer the ownership of those two\n\t\t\t * variables this time, just free them when we're done. */\n\t\t\tg_free(key);\n\t\t\tg_free(val);\n\t\t}\n\t}\n\telse if (!g_ascii_strcasecmp(evt, \"LIST\")) {\n\t\t/* do nothing, fe-cap will handle it */\n\t}\n\telse {\n\t\tg_warning(\"Unhandled CAP subcommand %s\", evt);\n\t}\n\n\tg_strfreev(caps);\n\tg_free(params);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145559,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "R_API bool r_crbtree_insert(RRBTree *tree, void *data, RRBComparator cmp, void *user) {\n\tr_return_val_if_fail (tree && data && cmp, false);\n\tbool inserted = false;\n\n\tif (tree->root == NULL) {\n\t\ttree->root = _node_new (data, NULL);\n\t\tif (tree->root == NULL) {\n\t\t\treturn false;\n\t\t}\n\t\tinserted = true;\n\t\tgoto out_exit;\n\t}\n\n\tRRBNode head; /* Fake tree root */\n\tmemset (&head, 0, sizeof (RRBNode));\n\tRRBNode *g = NULL, *parent = &head; /* Grandparent & parent */\n\tRRBNode *p = NULL, *q = tree->root; /* Iterator & parent */\n\tint dir = 0, last = 0; /* Directions */\n\n\t_set_link (parent, q, 1);\n\n\tfor (;;) {\n\t\tif (!q) {\n\t\t\t/* Insert a node at first null link(also set its parent link) */\n\t\t\tq = _node_new (data, p);\n\t\t\tif (!q) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tp->link[dir] = q;\n\t\t\tinserted = true;\n\t\t} else if (IS_RED (q->link[0]) && IS_RED (q->link[1])) {\n\t\t\t/* Simple red violation: color flip */\n\t\t\tq->red = 1;\n\t\t\tq->link[0]->red = 0;\n\t\t\tq->link[1]->red = 0;\n\t\t}\n\n\t\tif (IS_RED (q) && IS_RED (p)) {\n#if 0\n\t\t\t// coverity error, parent is never null\n\t\t\t/* Hard red violation: rotate */\n\t\t\tif (!parent) {\n\t\t\t\treturn false;\n\t\t\t}\n#endif\n\t\t\tint dir2 = parent->link[1] == g;\n\t\t\tif (q == p->link[last]) {\n\t\t\t\t_set_link (parent, _rot_once (g, !last), dir2);\n\t\t\t} else {\n\t\t\t\t_set_link (parent, _rot_twice (g, !last), dir2);\n\t\t\t}\n\t\t}\n\n\t\tif (inserted) {\n\t\t\tbreak;\n\t\t}\n\n\t\tlast = dir;\n\t\tdir = cmp (data, q->data, user) >= 0;\n\n\t\tif (g) {\n\t\t\tparent = g;\n\t\t}\n\n\t\tg = p;\n\t\tp = q;\n\t\tq = q->link[dir];\n\t}\n\n\t/* Update root(it may different due to root rotation) */\n\ttree->root = head.link[1];\n\nout_exit:\n\t/* Invariant: root is black */\n\ttree->root->red = 0;\n\ttree->root->parent = NULL;\n\tif (inserted) {\n\t\ttree->size++;\n\t}\n\n\treturn inserted;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145590,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "R_API bool r_crbtree_insert(RRBTree *tree, void *data, RRBComparator cmp, void *user) {\n\tr_return_val_if_fail (tree && data && cmp, false);\n\tbool inserted = false;\n\n\tif (!tree->root) {\n\t\ttree->root = _node_new (data, NULL);\n\t\tif (!tree->root) {\n\t\t\treturn false;\n\t\t}\n\t\tinserted = true;\n\t\tgoto out_exit;\n\t}\n\n\tRRBNode head; /* Fake tree root */\n\tmemset (&head, 0, sizeof (RRBNode));\n\tRRBNode *g = NULL, *parent = &head; /* Grandparent & parent */\n\tRRBNode *p = NULL, *q = tree->root; /* Iterator & parent */\n\tint dir = 0, last = 0; /* Directions */\n\n\t_set_link (parent, q, 1);\n\n\tfor (;;) {\n\t\tif (!q) {\n\t\t\t/* Insert a node at first null link(also set its parent link) */\n\t\t\tq = _node_new (data, p);\n\t\t\tif (!q) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tp->link[dir] = q;\n\t\t\tinserted = true;\n\t\t} else if (IS_RED (q->link[0]) && IS_RED (q->link[1])) {\n\t\t\t/* Simple red violation: color flip */\n\t\t\tq->red = 1;\n\t\t\tq->link[0]->red = 0;\n\t\t\tq->link[1]->red = 0;\n\t\t}\n\n\t\tif (IS_RED (q) && IS_RED (p)) {\n#if 0\n\t\t\t// coverity error, parent is never null\n\t\t\t/* Hard red violation: rotate */\n\t\t\tif (!parent) {\n\t\t\t\treturn false;\n\t\t\t}\n#endif\n\t\t\tint dir2 = parent->link[1] == g;\n\t\t\tif (q == p->link[last]) {\n\t\t\t\t_set_link (parent, _rot_once (g, !last), dir2);\n\t\t\t} else {\n\t\t\t\t_set_link (parent, _rot_twice (g, !last), dir2);\n\t\t\t}\n\t\t}\n\n\t\tif (inserted) {\n\t\t\tbreak;\n\t\t}\n\n\t\tlast = dir;\n\t\tdir = cmp (data, q->data, user) >= 0;\n\n\t\tif (g) {\n\t\t\tparent = g;\n\t\t}\n\n\t\tg = p;\n\t\tp = q;\n\t\tq = q->link[dir];\n\t}\n\n\t/* Update root(it may different due to root rotation) */\n\ttree->root = head.link[1];\n\nout_exit:\n\t/* Invariant: root is black */\n\ttree->root->red = 0;\n\ttree->root->parent = NULL;\n\tif (inserted) {\n\t\ttree->size++;\n\t}\n\n\treturn inserted;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145591,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "qemuProcessHandleMonitorEOF(qemuMonitorPtr mon,\n                            virDomainObjPtr vm,\n                            void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    qemuDomainObjPrivatePtr priv;\n    struct qemuProcessEvent *processEvent;\n\n    virObjectLock(vm);\n\n    VIR_DEBUG(\"Received EOF on %p '%s'\", vm, vm->def->name);\n\n    priv = vm->privateData;\n    if (priv->beingDestroyed) {\n        VIR_DEBUG(\"Domain is being destroyed, EOF is expected\");\n        goto cleanup;\n    }\n\n    processEvent = g_new0(struct qemuProcessEvent, 1);\n\n    processEvent->eventType = QEMU_PROCESS_EVENT_MONITOR_EOF;\n    processEvent->vm = virObjectRef(vm);\n\n    if (virThreadPoolSendJob(driver->workerPool, 0, processEvent) < 0) {\n        virObjectUnref(vm);\n        qemuProcessEventFree(processEvent);\n        goto cleanup;\n    }\n\n    /* We don't want this EOF handler to be called over and over while the\n     * thread is waiting for a job.\n     */\n    qemuMonitorUnregister(mon);\n\n    /* We don't want any cleanup from EOF handler (or any other\n     * thread) to enter qemu namespace. */\n    qemuDomainDestroyNamespace(driver, vm);\n\n cleanup:\n    virObjectUnlock(vm);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145602,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "qemuProcessHandleMonitorEOF(qemuMonitorPtr mon,\n                            virDomainObjPtr vm,\n                            void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    qemuDomainObjPrivatePtr priv;\n    struct qemuProcessEvent *processEvent;\n\n    virObjectLock(vm);\n\n    VIR_DEBUG(\"Received EOF on %p '%s'\", vm, vm->def->name);\n\n    priv = vm->privateData;\n    if (priv->beingDestroyed) {\n        VIR_DEBUG(\"Domain is being destroyed, EOF is expected\");\n        goto cleanup;\n    }\n\n    processEvent = g_new0(struct qemuProcessEvent, 1);\n\n    processEvent->eventType = QEMU_PROCESS_EVENT_MONITOR_EOF;\n    processEvent->vm = virObjectRef(vm);\n\n    if (virThreadPoolSendJob(driver->workerPool, 0, processEvent) < 0) {\n        virObjectUnref(vm);\n        qemuProcessEventFree(processEvent);\n        goto cleanup;\n    }\n\n    /* We don't want this EOF handler to be called over and over while the\n     * thread is waiting for a job.\n     */\n    virObjectLock(mon);\n    qemuMonitorUnregister(mon);\n    virObjectUnlock(mon);\n\n    /* We don't want any cleanup from EOF handler (or any other\n     * thread) to enter qemu namespace. */\n    qemuDomainDestroyNamespace(driver, vm);\n\n cleanup:\n    virObjectUnlock(vm);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145603,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int sco_sock_sendmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t    size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tvoid *buf;\n\tint err;\n\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\n\terr = sock_error(sk);\n\tif (err)\n\t\treturn err;\n\n\tif (msg->msg_flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\tbuf = kmalloc(len, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tif (memcpy_from_msg(buf, msg, len)) {\n\t\tkfree(buf);\n\t\treturn -EFAULT;\n\t}\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state == BT_CONNECTED)\n\t\terr = sco_send_frame(sk, buf, len, msg->msg_flags);\n\telse\n\t\terr = -ENOTCONN;\n\n\trelease_sock(sk);\n\tkfree(buf);\n\treturn err;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145628,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int sco_sock_sendmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t    size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tint err;\n\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\n\terr = sock_error(sk);\n\tif (err)\n\t\treturn err;\n\n\tif (msg->msg_flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\tskb = bt_skb_sendmsg(sk, msg, len, len, 0, 0);\n\tif (IS_ERR_OR_NULL(skb))\n\t\treturn PTR_ERR(skb);\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state == BT_CONNECTED)\n\t\terr = sco_send_frame(sk, skb);\n\telse\n\t\terr = -ENOTCONN;\n\n\trelease_sock(sk);\n\tif (err)\n\t\tkfree_skb(skb);\n\treturn err;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145629,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static ssize_t ucma_migrate_id(struct ucma_file *new_file,\n\t\t\t       const char __user *inbuf,\n\t\t\t       int in_len, int out_len)\n{\n\tstruct rdma_ucm_migrate_id cmd;\n\tstruct rdma_ucm_migrate_resp resp;\n\tstruct ucma_context *ctx;\n\tstruct fd f;\n\tstruct ucma_file *cur_file;\n\tint ret = 0;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\t/* Get current fd to protect against it being closed */\n\tf = fdget(cmd.fd);\n\tif (!f.file)\n\t\treturn -ENOENT;\n\tif (f.file->f_op != &ucma_fops) {\n\t\tret = -EINVAL;\n\t\tgoto file_put;\n\t}\n\n\t/* Validate current fd and prevent destruction of id. */\n\tctx = ucma_get_ctx(f.file->private_data, cmd.id);\n\tif (IS_ERR(ctx)) {\n\t\tret = PTR_ERR(ctx);\n\t\tgoto file_put;\n\t}\n\n\trdma_lock_handler(ctx->cm_id);\n\tcur_file = ctx->file;\n\tif (cur_file == new_file) {\n\t\tmutex_lock(&cur_file->mut);\n\t\tresp.events_reported = ctx->events_reported;\n\t\tmutex_unlock(&cur_file->mut);\n\t\tgoto response;\n\t}\n\n\t/*\n\t * Migrate events between fd's, maintaining order, and avoiding new\n\t * events being added before existing events.\n\t */\n\tucma_lock_files(cur_file, new_file);\n\txa_lock(&ctx_table);\n\n\tlist_move_tail(&ctx->list, &new_file->ctx_list);\n\tucma_move_events(ctx, new_file);\n\tctx->file = new_file;\n\tresp.events_reported = ctx->events_reported;\n\n\txa_unlock(&ctx_table);\n\tucma_unlock_files(cur_file, new_file);\n\nresponse:\n\tif (copy_to_user(u64_to_user_ptr(cmd.response),\n\t\t\t &resp, sizeof(resp)))\n\t\tret = -EFAULT;\n\n\trdma_unlock_handler(ctx->cm_id);\n\tucma_put_ctx(ctx);\nfile_put:\n\tfdput(f);\n\treturn ret;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145668,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static ssize_t ucma_migrate_id(struct ucma_file *new_file,\n\t\t\t       const char __user *inbuf,\n\t\t\t       int in_len, int out_len)\n{\n\tstruct rdma_ucm_migrate_id cmd;\n\tstruct rdma_ucm_migrate_resp resp;\n\tstruct ucma_event *uevent, *tmp;\n\tstruct ucma_context *ctx;\n\tLIST_HEAD(event_list);\n\tstruct fd f;\n\tstruct ucma_file *cur_file;\n\tint ret = 0;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\t/* Get current fd to protect against it being closed */\n\tf = fdget(cmd.fd);\n\tif (!f.file)\n\t\treturn -ENOENT;\n\tif (f.file->f_op != &ucma_fops) {\n\t\tret = -EINVAL;\n\t\tgoto file_put;\n\t}\n\tcur_file = f.file->private_data;\n\n\t/* Validate current fd and prevent destruction of id. */\n\tctx = ucma_get_ctx(cur_file, cmd.id);\n\tif (IS_ERR(ctx)) {\n\t\tret = PTR_ERR(ctx);\n\t\tgoto file_put;\n\t}\n\n\trdma_lock_handler(ctx->cm_id);\n\t/*\n\t * ctx->file can only be changed under the handler & xa_lock. xa_load()\n\t * must be checked again to ensure the ctx hasn't begun destruction\n\t * since the ucma_get_ctx().\n\t */\n\txa_lock(&ctx_table);\n\tif (_ucma_find_context(cmd.id, cur_file) != ctx) {\n\t\txa_unlock(&ctx_table);\n\t\tret = -ENOENT;\n\t\tgoto err_unlock;\n\t}\n\tctx->file = new_file;\n\txa_unlock(&ctx_table);\n\n\tmutex_lock(&cur_file->mut);\n\tlist_del(&ctx->list);\n\t/*\n\t * At this point lock_handler() prevents addition of new uevents for\n\t * this ctx.\n\t */\n\tlist_for_each_entry_safe(uevent, tmp, &cur_file->event_list, list)\n\t\tif (uevent->ctx == ctx)\n\t\t\tlist_move_tail(&uevent->list, &event_list);\n\tresp.events_reported = ctx->events_reported;\n\tmutex_unlock(&cur_file->mut);\n\n\tmutex_lock(&new_file->mut);\n\tlist_add_tail(&ctx->list, &new_file->ctx_list);\n\tlist_splice_tail(&event_list, &new_file->event_list);\n\tmutex_unlock(&new_file->mut);\n\n\tif (copy_to_user(u64_to_user_ptr(cmd.response),\n\t\t\t &resp, sizeof(resp)))\n\t\tret = -EFAULT;\n\nerr_unlock:\n\trdma_unlock_handler(ctx->cm_id);\n\tucma_put_ctx(ctx);\nfile_put:\n\tfdput(f);\n\treturn ret;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145669,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "key_share_send_params(gnutls_session_t session,\n\t\t      gnutls_buffer_st * extdata)\n{\n\tunsigned i;\n\tint ret;\n\tunsigned char *lengthp;\n\tunsigned int cur_length;\n\tunsigned int generated = 0;\n\tconst gnutls_group_entry_st *group;\n\tconst version_entry_st *ver;\n\n\t/* this extension is only being sent on client side */\n\tif (session->security_parameters.entity == GNUTLS_CLIENT) {\n\t\tver = _gnutls_version_max(session);\n\t\tif (unlikely(ver == NULL || ver->key_shares == 0))\n\t\t\treturn 0;\n\n\t\tif (!have_creds_for_tls13(session))\n\t\t\treturn 0;\n\n\t\t/* write the total length later */\n\t\tlengthp = &extdata->data[extdata->length];\n\n\t\tret =\n\t\t    _gnutls_buffer_append_prefix(extdata, 16, 0);\n\t\tif (ret < 0)\n\t\t\treturn gnutls_assert_val(ret);\n\n\t\tcur_length = extdata->length;\n\n\t\tif (session->internals.hsk_flags & HSK_HRR_RECEIVED) { /* we know the group */\n\t\t\tgroup = get_group(session);\n\t\t\tif (unlikely(group == NULL))\n\t\t\t\treturn gnutls_assert_val(GNUTLS_E_RECEIVED_ILLEGAL_PARAMETER);\n\n\t\t\tret = client_gen_key_share(session, group, extdata);\n\t\t\tif (ret == GNUTLS_E_INT_RET_0)\n\t\t\t\treturn gnutls_assert_val(GNUTLS_E_NO_COMMON_KEY_SHARE);\n\t\t\tif (ret < 0)\n\t\t\t\treturn gnutls_assert_val(ret);\n\t\t} else {\n\t\t\tgnutls_pk_algorithm_t selected_groups[3];\n\t\t\tunsigned max_groups = 2; /* GNUTLS_KEY_SHARE_TOP2 */\n\n\t\t\tif (session->internals.flags & GNUTLS_KEY_SHARE_TOP)\n\t\t\t\tmax_groups = 1;\n\t\t\telse if (session->internals.flags & GNUTLS_KEY_SHARE_TOP3)\n\t\t\t\tmax_groups = 3;\n\n\t\t\tassert(max_groups <= sizeof(selected_groups)/sizeof(selected_groups[0]));\n\n\t\t\t/* generate key shares for out top-(max_groups) groups\n\t\t\t * if they are of different PK type. */\n\t\t\tfor (i = 0; i < session->internals.priorities->groups.size; i++) {\n\t\t\t\tgroup = session->internals.priorities->groups.entry[i];\n\n\t\t\t\tif (generated == 1 && group->pk == selected_groups[0])\n\t\t\t\t\tcontinue;\n\t\t\t\telse if (generated == 2 && (group->pk == selected_groups[1] || group->pk == selected_groups[0]))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tselected_groups[generated] = group->pk;\n\n\t\t\t\tret = client_gen_key_share(session, group, extdata);\n\t\t\t\tif (ret == GNUTLS_E_INT_RET_0)\n\t\t\t\t\tcontinue; /* no key share for this algorithm */\n\t\t\t\tif (ret < 0)\n\t\t\t\t\treturn gnutls_assert_val(ret);\n\n\t\t\t\tgenerated++;\n\n\t\t\t\tif (generated >= max_groups)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* copy actual length */\n\t\t_gnutls_write_uint16(extdata->length - cur_length, lengthp);\n\n\t} else { /* server */\n\t\tver = get_version(session);\n\t\tif (unlikely(ver == NULL || ver->key_shares == 0))\n\t\t\treturn gnutls_assert_val(0);\n\n\t\tif (_gnutls_ext_get_msg(session) == GNUTLS_EXT_FLAG_HRR) {\n\t\t\tgroup = session->internals.cand_group;\n\n\t\t\tif (group == NULL)\n\t\t\t\treturn gnutls_assert_val(GNUTLS_E_NO_COMMON_KEY_SHARE);\n\n\t\t\t_gnutls_session_group_set(session, group);\n\n\t\t\t_gnutls_handshake_log(\"EXT[%p]: requesting retry with group %s\\n\", session, group->name);\n\t\t\tret =\n\t\t\t    _gnutls_buffer_append_prefix(extdata, 16, group->tls_id);\n\t\t\tif (ret < 0)\n\t\t\t\treturn gnutls_assert_val(ret);\n\t\t} else {\n\t\t\t/* if we are negotiating PSK without DH, do not send a key share */\n\t\t\tif ((session->internals.hsk_flags & HSK_PSK_SELECTED) &&\n\t\t\t    (session->internals.hsk_flags & HSK_PSK_KE_MODE_PSK))\n\t\t\t\treturn gnutls_assert_val(0);\n\n\t\t\tgroup = get_group(session);\n\t\t\tif (unlikely(group == NULL))\n\t\t\t\treturn gnutls_assert_val(GNUTLS_E_RECEIVED_ILLEGAL_PARAMETER);\n\n\t\t\tret = server_gen_key_share(session, group, extdata);\n\t\t\tif (ret < 0)\n\t\t\t\treturn gnutls_assert_val(ret);\n\t\t}\n\n\t\tsession->internals.hsk_flags |= HSK_KEY_SHARE_SENT;\n\t}\n\n\treturn 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145674,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "key_share_send_params(gnutls_session_t session,\n\t\t      gnutls_buffer_st * extdata)\n{\n\tunsigned i;\n\tint ret;\n\tunsigned int generated = 0;\n\tconst gnutls_group_entry_st *group;\n\tconst version_entry_st *ver;\n\n\t/* this extension is only being sent on client side */\n\tif (session->security_parameters.entity == GNUTLS_CLIENT) {\n\t\tunsigned int length_pos;\n\n\t\tver = _gnutls_version_max(session);\n\t\tif (unlikely(ver == NULL || ver->key_shares == 0))\n\t\t\treturn 0;\n\n\t\tif (!have_creds_for_tls13(session))\n\t\t\treturn 0;\n\n\t\tlength_pos = extdata->length;\n\n\t\tret =\n\t\t    _gnutls_buffer_append_prefix(extdata, 16, 0);\n\t\tif (ret < 0)\n\t\t\treturn gnutls_assert_val(ret);\n\n\t\tif (session->internals.hsk_flags & HSK_HRR_RECEIVED) { /* we know the group */\n\t\t\tgroup = get_group(session);\n\t\t\tif (unlikely(group == NULL))\n\t\t\t\treturn gnutls_assert_val(GNUTLS_E_RECEIVED_ILLEGAL_PARAMETER);\n\n\t\t\tret = client_gen_key_share(session, group, extdata);\n\t\t\tif (ret == GNUTLS_E_INT_RET_0)\n\t\t\t\treturn gnutls_assert_val(GNUTLS_E_NO_COMMON_KEY_SHARE);\n\t\t\tif (ret < 0)\n\t\t\t\treturn gnutls_assert_val(ret);\n\t\t} else {\n\t\t\tgnutls_pk_algorithm_t selected_groups[3];\n\t\t\tunsigned max_groups = 2; /* GNUTLS_KEY_SHARE_TOP2 */\n\n\t\t\tif (session->internals.flags & GNUTLS_KEY_SHARE_TOP)\n\t\t\t\tmax_groups = 1;\n\t\t\telse if (session->internals.flags & GNUTLS_KEY_SHARE_TOP3)\n\t\t\t\tmax_groups = 3;\n\n\t\t\tassert(max_groups <= sizeof(selected_groups)/sizeof(selected_groups[0]));\n\n\t\t\t/* generate key shares for out top-(max_groups) groups\n\t\t\t * if they are of different PK type. */\n\t\t\tfor (i = 0; i < session->internals.priorities->groups.size; i++) {\n\t\t\t\tgroup = session->internals.priorities->groups.entry[i];\n\n\t\t\t\tif (generated == 1 && group->pk == selected_groups[0])\n\t\t\t\t\tcontinue;\n\t\t\t\telse if (generated == 2 && (group->pk == selected_groups[1] || group->pk == selected_groups[0]))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tselected_groups[generated] = group->pk;\n\n\t\t\t\tret = client_gen_key_share(session, group, extdata);\n\t\t\t\tif (ret == GNUTLS_E_INT_RET_0)\n\t\t\t\t\tcontinue; /* no key share for this algorithm */\n\t\t\t\tif (ret < 0)\n\t\t\t\t\treturn gnutls_assert_val(ret);\n\n\t\t\t\tgenerated++;\n\n\t\t\t\tif (generated >= max_groups)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* copy actual length */\n\t\t_gnutls_write_uint16(extdata->length - length_pos - 2,\n\t\t\t\t     &extdata->data[length_pos]);\n\n\t} else { /* server */\n\t\tver = get_version(session);\n\t\tif (unlikely(ver == NULL || ver->key_shares == 0))\n\t\t\treturn gnutls_assert_val(0);\n\n\t\tif (_gnutls_ext_get_msg(session) == GNUTLS_EXT_FLAG_HRR) {\n\t\t\tgroup = session->internals.cand_group;\n\n\t\t\tif (group == NULL)\n\t\t\t\treturn gnutls_assert_val(GNUTLS_E_NO_COMMON_KEY_SHARE);\n\n\t\t\t_gnutls_session_group_set(session, group);\n\n\t\t\t_gnutls_handshake_log(\"EXT[%p]: requesting retry with group %s\\n\", session, group->name);\n\t\t\tret =\n\t\t\t    _gnutls_buffer_append_prefix(extdata, 16, group->tls_id);\n\t\t\tif (ret < 0)\n\t\t\t\treturn gnutls_assert_val(ret);\n\t\t} else {\n\t\t\t/* if we are negotiating PSK without DH, do not send a key share */\n\t\t\tif ((session->internals.hsk_flags & HSK_PSK_SELECTED) &&\n\t\t\t    (session->internals.hsk_flags & HSK_PSK_KE_MODE_PSK))\n\t\t\t\treturn gnutls_assert_val(0);\n\n\t\t\tgroup = get_group(session);\n\t\t\tif (unlikely(group == NULL))\n\t\t\t\treturn gnutls_assert_val(GNUTLS_E_RECEIVED_ILLEGAL_PARAMETER);\n\n\t\t\tret = server_gen_key_share(session, group, extdata);\n\t\t\tif (ret < 0)\n\t\t\t\treturn gnutls_assert_val(ret);\n\t\t}\n\n\t\tsession->internals.hsk_flags |= HSK_KEY_SHARE_SENT;\n\t}\n\n\treturn 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145675,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "nv_brackets(cmdarg_T *cap)\n{\n    pos_T\tprev_pos;\n    pos_T\t*pos = NULL;\t    // init for GCC\n    pos_T\told_pos;\t    // cursor position before command\n    int\t\tflag;\n    long\tn;\n\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    old_pos = curwin->w_cursor;\n    curwin->w_cursor.coladd = 0;    // TODO: don't do this for an error.\n\n#ifdef FEAT_SEARCHPATH\n    // \"[f\" or \"]f\" : Edit file under the cursor (same as \"gf\")\n    if (cap->nchar == 'f')\n\tnv_gotofile(cap);\n    else\n#endif\n\n#ifdef FEAT_FIND_ID\n    // Find the occurrence(s) of the identifier or define under cursor\n    // in current and included files or jump to the first occurrence.\n    //\n    //\t\t\tsearch\t     list\t    jump\n    //\t\t      fwd   bwd    fwd\t bwd\t fwd\tbwd\n    // identifier     \"]i\"  \"[i\"   \"]I\"  \"[I\"\t\"]^I\"  \"[^I\"\n    // define\t      \"]d\"  \"[d\"   \"]D\"  \"[D\"\t\"]^D\"  \"[^D\"\n    if (vim_strchr((char_u *)\"iI\\011dD\\004\", cap->nchar) != NULL)\n    {\n\tchar_u\t*ptr;\n\tint\tlen;\n\n\tif ((len = find_ident_under_cursor(&ptr, FIND_IDENT)) == 0)\n\t    clearop(cap->oap);\n\telse\n\t{\n\t    find_pattern_in_path(ptr, 0, len, TRUE,\n\t\tcap->count0 == 0 ? !isupper(cap->nchar) : FALSE,\n\t\t((cap->nchar & 0xf) == ('d' & 0xf)) ?  FIND_DEFINE : FIND_ANY,\n\t\tcap->count1,\n\t\tisupper(cap->nchar) ? ACTION_SHOW_ALL :\n\t\t\t    islower(cap->nchar) ? ACTION_SHOW : ACTION_GOTO,\n\t\tcap->cmdchar == ']' ? curwin->w_cursor.lnum + 1 : (linenr_T)1,\n\t\t(linenr_T)MAXLNUM);\n\t    curwin->w_set_curswant = TRUE;\n\t}\n    }\n    else\n#endif\n\n    // \"[{\", \"[(\", \"]}\" or \"])\": go to Nth unclosed '{', '(', '}' or ')'\n    // \"[#\", \"]#\": go to start/end of Nth innermost #if..#endif construct.\n    // \"[/\", \"[*\", \"]/\", \"]*\": go to Nth comment start/end.\n    // \"[m\" or \"]m\" search for prev/next start of (Java) method.\n    // \"[M\" or \"]M\" search for prev/next end of (Java) method.\n    if (  (cap->cmdchar == '['\n\t\t&& vim_strchr((char_u *)\"{(*/#mM\", cap->nchar) != NULL)\n\t    || (cap->cmdchar == ']'\n\t\t&& vim_strchr((char_u *)\"})*/#mM\", cap->nchar) != NULL))\n\tnv_bracket_block(cap, &old_pos);\n\n    // \"[[\", \"[]\", \"]]\" and \"][\": move to start or end of function\n    else if (cap->nchar == '[' || cap->nchar == ']')\n    {\n\tif (cap->nchar == cap->cmdchar)\t\t    // \"]]\" or \"[[\"\n\t    flag = '{';\n\telse\n\t    flag = '}';\t\t    // \"][\" or \"[]\"\n\n\tcurwin->w_set_curswant = TRUE;\n\t// Imitate strange Vi behaviour: When using \"]]\" with an operator\n\t// we also stop at '}'.\n\tif (!findpar(&cap->oap->inclusive, cap->arg, cap->count1, flag,\n\t      (cap->oap->op_type != OP_NOP\n\t\t\t\t      && cap->arg == FORWARD && flag == '{')))\n\t    clearopbeep(cap->oap);\n\telse\n\t{\n\t    if (cap->oap->op_type == OP_NOP)\n\t\tbeginline(BL_WHITE | BL_FIX);\n#ifdef FEAT_FOLDING\n\t    if ((fdo_flags & FDO_BLOCK) && KeyTyped && cap->oap->op_type == OP_NOP)\n\t\tfoldOpenCursor();\n#endif\n\t}\n    }\n\n    // \"[p\", \"[P\", \"]P\" and \"]p\": put with indent adjustment\n    else if (cap->nchar == 'p' || cap->nchar == 'P')\n    {\n\tnv_put_opt(cap, TRUE);\n    }\n\n    // \"['\", \"[`\", \"]'\" and \"]`\": jump to next mark\n    else if (cap->nchar == '\\'' || cap->nchar == '`')\n    {\n\tpos = &curwin->w_cursor;\n\tfor (n = cap->count1; n > 0; --n)\n\t{\n\t    prev_pos = *pos;\n\t    pos = getnextmark(pos, cap->cmdchar == '[' ? BACKWARD : FORWARD,\n\t\t\t\t\t\t\t  cap->nchar == '\\'');\n\t    if (pos == NULL)\n\t\tbreak;\n\t}\n\tif (pos == NULL)\n\t    pos = &prev_pos;\n\tnv_cursormark(cap, cap->nchar == '\\'', pos);\n    }\n\n    // [ or ] followed by a middle mouse click: put selected text with\n    // indent adjustment.  Any other button just does as usual.\n    else if (cap->nchar >= K_RIGHTRELEASE && cap->nchar <= K_LEFTMOUSE)\n    {\n\t(void)do_mouse(cap->oap, cap->nchar,\n\t\t       (cap->cmdchar == ']') ? FORWARD : BACKWARD,\n\t\t       cap->count1, PUT_FIXINDENT);\n    }\n\n#ifdef FEAT_FOLDING\n    // \"[z\" and \"]z\": move to start or end of open fold.\n    else if (cap->nchar == 'z')\n    {\n\tif (foldMoveTo(FALSE, cap->cmdchar == ']' ? FORWARD : BACKWARD,\n\t\t\t\t\t\t\t cap->count1) == FAIL)\n\t    clearopbeep(cap->oap);\n    }\n#endif\n\n#ifdef FEAT_DIFF\n    // \"[c\" and \"]c\": move to next or previous diff-change.\n    else if (cap->nchar == 'c')\n    {\n\tif (diff_move_to(cap->cmdchar == ']' ? FORWARD : BACKWARD,\n\t\t\t\t\t\t\t cap->count1) == FAIL)\n\t    clearopbeep(cap->oap);\n    }\n#endif\n\n#ifdef FEAT_SPELL\n    // \"[s\", \"[S\", \"]s\" and \"]S\": move to next spell error.\n    else if (cap->nchar == 's' || cap->nchar == 'S')\n    {\n\tsetpcmark();\n\tfor (n = 0; n < cap->count1; ++n)\n\t    if (spell_move_to(curwin, cap->cmdchar == ']' ? FORWARD : BACKWARD,\n\t\t\t  cap->nchar == 's' ? TRUE : FALSE, FALSE, NULL) == 0)\n\t    {\n\t\tclearopbeep(cap->oap);\n\t\tbreak;\n\t    }\n\t    else\n\t\tcurwin->w_set_curswant = TRUE;\n# ifdef FEAT_FOLDING\n\tif (cap->oap->op_type == OP_NOP && (fdo_flags & FDO_SEARCH) && KeyTyped)\n\t    foldOpenCursor();\n# endif\n    }\n#endif\n\n    // Not a valid cap->nchar.\n    else\n\tclearopbeep(cap->oap);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145688,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "nv_brackets(cmdarg_T *cap)\n{\n    pos_T\tprev_pos;\n    pos_T\t*pos = NULL;\t    // init for GCC\n    pos_T\told_pos;\t    // cursor position before command\n    int\t\tflag;\n    long\tn;\n\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    old_pos = curwin->w_cursor;\n    curwin->w_cursor.coladd = 0;    // TODO: don't do this for an error.\n\n#ifdef FEAT_SEARCHPATH\n    // \"[f\" or \"]f\" : Edit file under the cursor (same as \"gf\")\n    if (cap->nchar == 'f')\n\tnv_gotofile(cap);\n    else\n#endif\n\n#ifdef FEAT_FIND_ID\n    // Find the occurrence(s) of the identifier or define under cursor\n    // in current and included files or jump to the first occurrence.\n    //\n    //\t\t\tsearch\t     list\t    jump\n    //\t\t      fwd   bwd    fwd\t bwd\t fwd\tbwd\n    // identifier     \"]i\"  \"[i\"   \"]I\"  \"[I\"\t\"]^I\"  \"[^I\"\n    // define\t      \"]d\"  \"[d\"   \"]D\"  \"[D\"\t\"]^D\"  \"[^D\"\n    if (vim_strchr((char_u *)\"iI\\011dD\\004\", cap->nchar) != NULL)\n    {\n\tchar_u\t*ptr;\n\tint\tlen;\n\n\tif ((len = find_ident_under_cursor(&ptr, FIND_IDENT)) == 0)\n\t    clearop(cap->oap);\n\telse\n\t{\n\t    // Make a copy, if the line was changed it will be freed.\n\t    ptr = vim_strnsave(ptr, len);\n\t    if (ptr == NULL)\n\t\treturn;\n\n\t    find_pattern_in_path(ptr, 0, len, TRUE,\n\t\tcap->count0 == 0 ? !isupper(cap->nchar) : FALSE,\n\t\t((cap->nchar & 0xf) == ('d' & 0xf)) ?  FIND_DEFINE : FIND_ANY,\n\t\tcap->count1,\n\t\tisupper(cap->nchar) ? ACTION_SHOW_ALL :\n\t\t\t    islower(cap->nchar) ? ACTION_SHOW : ACTION_GOTO,\n\t\tcap->cmdchar == ']' ? curwin->w_cursor.lnum + 1 : (linenr_T)1,\n\t\t(linenr_T)MAXLNUM);\n\t    vim_free(ptr);\n\t    curwin->w_set_curswant = TRUE;\n\t}\n    }\n    else\n#endif\n\n    // \"[{\", \"[(\", \"]}\" or \"])\": go to Nth unclosed '{', '(', '}' or ')'\n    // \"[#\", \"]#\": go to start/end of Nth innermost #if..#endif construct.\n    // \"[/\", \"[*\", \"]/\", \"]*\": go to Nth comment start/end.\n    // \"[m\" or \"]m\" search for prev/next start of (Java) method.\n    // \"[M\" or \"]M\" search for prev/next end of (Java) method.\n    if (  (cap->cmdchar == '['\n\t\t&& vim_strchr((char_u *)\"{(*/#mM\", cap->nchar) != NULL)\n\t    || (cap->cmdchar == ']'\n\t\t&& vim_strchr((char_u *)\"})*/#mM\", cap->nchar) != NULL))\n\tnv_bracket_block(cap, &old_pos);\n\n    // \"[[\", \"[]\", \"]]\" and \"][\": move to start or end of function\n    else if (cap->nchar == '[' || cap->nchar == ']')\n    {\n\tif (cap->nchar == cap->cmdchar)\t\t    // \"]]\" or \"[[\"\n\t    flag = '{';\n\telse\n\t    flag = '}';\t\t    // \"][\" or \"[]\"\n\n\tcurwin->w_set_curswant = TRUE;\n\t// Imitate strange Vi behaviour: When using \"]]\" with an operator\n\t// we also stop at '}'.\n\tif (!findpar(&cap->oap->inclusive, cap->arg, cap->count1, flag,\n\t      (cap->oap->op_type != OP_NOP\n\t\t\t\t      && cap->arg == FORWARD && flag == '{')))\n\t    clearopbeep(cap->oap);\n\telse\n\t{\n\t    if (cap->oap->op_type == OP_NOP)\n\t\tbeginline(BL_WHITE | BL_FIX);\n#ifdef FEAT_FOLDING\n\t    if ((fdo_flags & FDO_BLOCK) && KeyTyped && cap->oap->op_type == OP_NOP)\n\t\tfoldOpenCursor();\n#endif\n\t}\n    }\n\n    // \"[p\", \"[P\", \"]P\" and \"]p\": put with indent adjustment\n    else if (cap->nchar == 'p' || cap->nchar == 'P')\n    {\n\tnv_put_opt(cap, TRUE);\n    }\n\n    // \"['\", \"[`\", \"]'\" and \"]`\": jump to next mark\n    else if (cap->nchar == '\\'' || cap->nchar == '`')\n    {\n\tpos = &curwin->w_cursor;\n\tfor (n = cap->count1; n > 0; --n)\n\t{\n\t    prev_pos = *pos;\n\t    pos = getnextmark(pos, cap->cmdchar == '[' ? BACKWARD : FORWARD,\n\t\t\t\t\t\t\t  cap->nchar == '\\'');\n\t    if (pos == NULL)\n\t\tbreak;\n\t}\n\tif (pos == NULL)\n\t    pos = &prev_pos;\n\tnv_cursormark(cap, cap->nchar == '\\'', pos);\n    }\n\n    // [ or ] followed by a middle mouse click: put selected text with\n    // indent adjustment.  Any other button just does as usual.\n    else if (cap->nchar >= K_RIGHTRELEASE && cap->nchar <= K_LEFTMOUSE)\n    {\n\t(void)do_mouse(cap->oap, cap->nchar,\n\t\t       (cap->cmdchar == ']') ? FORWARD : BACKWARD,\n\t\t       cap->count1, PUT_FIXINDENT);\n    }\n\n#ifdef FEAT_FOLDING\n    // \"[z\" and \"]z\": move to start or end of open fold.\n    else if (cap->nchar == 'z')\n    {\n\tif (foldMoveTo(FALSE, cap->cmdchar == ']' ? FORWARD : BACKWARD,\n\t\t\t\t\t\t\t cap->count1) == FAIL)\n\t    clearopbeep(cap->oap);\n    }\n#endif\n\n#ifdef FEAT_DIFF\n    // \"[c\" and \"]c\": move to next or previous diff-change.\n    else if (cap->nchar == 'c')\n    {\n\tif (diff_move_to(cap->cmdchar == ']' ? FORWARD : BACKWARD,\n\t\t\t\t\t\t\t cap->count1) == FAIL)\n\t    clearopbeep(cap->oap);\n    }\n#endif\n\n#ifdef FEAT_SPELL\n    // \"[s\", \"[S\", \"]s\" and \"]S\": move to next spell error.\n    else if (cap->nchar == 's' || cap->nchar == 'S')\n    {\n\tsetpcmark();\n\tfor (n = 0; n < cap->count1; ++n)\n\t    if (spell_move_to(curwin, cap->cmdchar == ']' ? FORWARD : BACKWARD,\n\t\t\t  cap->nchar == 's' ? TRUE : FALSE, FALSE, NULL) == 0)\n\t    {\n\t\tclearopbeep(cap->oap);\n\t\tbreak;\n\t    }\n\t    else\n\t\tcurwin->w_set_curswant = TRUE;\n# ifdef FEAT_FOLDING\n\tif (cap->oap->op_type == OP_NOP && (fdo_flags & FDO_SEARCH) && KeyTyped)\n\t    foldOpenCursor();\n# endif\n    }\n#endif\n\n    // Not a valid cap->nchar.\n    else\n\tclearopbeep(cap->oap);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145689,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "  static void  Ins_IP( INS_ARG )\n  {\n    TT_F26Dot6  org_a, org_b, org_x,\n                cur_a, cur_b, cur_x,\n                distance;\n    Int         point;\n    (void)args;\n\n    if ( CUR.top < CUR.GS.loop )\n    {\n      CUR.error = TT_Err_Invalid_Reference;\n      return;\n    }\n\n    org_a = CUR_Func_dualproj( CUR.zp0.org_x[CUR.GS.rp1],\n                               CUR.zp0.org_y[CUR.GS.rp1] );\n\n    org_b = CUR_Func_dualproj( CUR.zp1.org_x[CUR.GS.rp2],\n                               CUR.zp1.org_y[CUR.GS.rp2] );\n\n    cur_a = CUR_Func_project( CUR.zp0.cur_x[CUR.GS.rp1],\n                              CUR.zp0.cur_y[CUR.GS.rp1] );\n\n    cur_b = CUR_Func_project( CUR.zp1.cur_x[CUR.GS.rp2],\n                              CUR.zp1.cur_y[CUR.GS.rp2] );\n\n    while ( CUR.GS.loop > 0 )\n    {\n      CUR.args--;\n\n      point = (Int)CUR.stack[CUR.args];\n      if ( BOUNDS( point, CUR.zp2.n_points ) )\n      {\n        CUR.error = TT_Err_Invalid_Reference;\n        return;\n      }\n\n      org_x = CUR_Func_dualproj( CUR.zp2.org_x[point],\n                                 CUR.zp2.org_y[point] );\n\n      cur_x = CUR_Func_project( CUR.zp2.cur_x[point],\n                                CUR.zp2.cur_y[point] );\n\n      if ( ( org_a <= org_b && org_x <= org_a ) ||\n           ( org_a >  org_b && org_x >= org_a ) )\n\n        distance = ( cur_a - org_a ) + ( org_x - cur_x );\n\n      else if ( ( org_a <= org_b  &&  org_x >= org_b ) ||\n                ( org_a >  org_b  &&  org_x <  org_b ) )\n\n        distance = ( cur_b - org_b ) + ( org_x - cur_x );\n\n      else\n         /* note: it seems that rounding this value isn't a good */\n         /*       idea (cf. width of capital 'S' in Times)       */\n\n         distance = MulDiv_Round( cur_b - cur_a,\n                                  org_x - org_a,\n                                  org_b - org_a ) + ( cur_a - cur_x );\n\n      CUR_Func_move( &CUR.zp2, point, distance );\n\n      CUR.GS.loop--;\n    }\n\n    CUR.GS.loop = 1;\n    CUR.new_top = CUR.args;\n  }",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145748,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "get_futex_key(u32 __user *uaddr, int fshared, union futex_key *key, int rw)\n{\n\tunsigned long address = (unsigned long)uaddr;\n\tstruct mm_struct *mm = current->mm;\n\tstruct page *page, *tail;\n\tstruct address_space *mapping;\n\tint err, ro = 0;\n\n\t/*\n\t * The futex address must be \"naturally\" aligned.\n\t */\n\tkey->both.offset = address % PAGE_SIZE;\n\tif (unlikely((address % sizeof(u32)) != 0))\n\t\treturn -EINVAL;\n\taddress -= key->both.offset;\n\n\tif (unlikely(!access_ok(rw, uaddr, sizeof(u32))))\n\t\treturn -EFAULT;\n\n\tif (unlikely(should_fail_futex(fshared)))\n\t\treturn -EFAULT;\n\n\t/*\n\t * PROCESS_PRIVATE futexes are fast.\n\t * As the mm cannot disappear under us and the 'key' only needs\n\t * virtual address, we dont even have to find the underlying vma.\n\t * Note : We do have to check 'uaddr' is a valid user address,\n\t *        but access_ok() should be faster than find_vma()\n\t */\n\tif (!fshared) {\n\t\tkey->private.mm = mm;\n\t\tkey->private.address = address;\n\t\tget_futex_key_refs(key);  /* implies smp_mb(); (B) */\n\t\treturn 0;\n\t}\n\nagain:\n\t/* Ignore any VERIFY_READ mapping (futex common case) */\n\tif (unlikely(should_fail_futex(fshared)))\n\t\treturn -EFAULT;\n\n\terr = get_user_pages_fast(address, 1, 1, &page);\n\t/*\n\t * If write access is not required (eg. FUTEX_WAIT), try\n\t * and get read-only access.\n\t */\n\tif (err == -EFAULT && rw == VERIFY_READ) {\n\t\terr = get_user_pages_fast(address, 1, 0, &page);\n\t\tro = 1;\n\t}\n\tif (err < 0)\n\t\treturn err;\n\telse\n\t\terr = 0;\n\n\t/*\n\t * The treatment of mapping from this point on is critical. The page\n\t * lock protects many things but in this context the page lock\n\t * stabilizes mapping, prevents inode freeing in the shared\n\t * file-backed region case and guards against movement to swap cache.\n\t *\n\t * Strictly speaking the page lock is not needed in all cases being\n\t * considered here and page lock forces unnecessarily serialization\n\t * From this point on, mapping will be re-verified if necessary and\n\t * page lock will be acquired only if it is unavoidable\n\t *\n\t * Mapping checks require the head page for any compound page so the\n\t * head page and mapping is looked up now. For anonymous pages, it\n\t * does not matter if the page splits in the future as the key is\n\t * based on the address. For filesystem-backed pages, the tail is\n\t * required as the index of the page determines the key. For\n\t * base pages, there is no tail page and tail == page.\n\t */\n\ttail = page;\n\tpage = compound_head(page);\n\tmapping = READ_ONCE(page->mapping);\n\n\t/*\n\t * If page->mapping is NULL, then it cannot be a PageAnon\n\t * page; but it might be the ZERO_PAGE or in the gate area or\n\t * in a special mapping (all cases which we are happy to fail);\n\t * or it may have been a good file page when get_user_pages_fast\n\t * found it, but truncated or holepunched or subjected to\n\t * invalidate_complete_page2 before we got the page lock (also\n\t * cases which we are happy to fail).  And we hold a reference,\n\t * so refcount care in invalidate_complete_page's remove_mapping\n\t * prevents drop_caches from setting mapping to NULL beneath us.\n\t *\n\t * The case we do have to guard against is when memory pressure made\n\t * shmem_writepage move it from filecache to swapcache beneath us:\n\t * an unlikely race, but we do need to retry for page->mapping.\n\t */\n\tif (unlikely(!mapping)) {\n\t\tint shmem_swizzled;\n\n\t\t/*\n\t\t * Page lock is required to identify which special case above\n\t\t * applies. If this is really a shmem page then the page lock\n\t\t * will prevent unexpected transitions.\n\t\t */\n\t\tlock_page(page);\n\t\tshmem_swizzled = PageSwapCache(page) || page->mapping;\n\t\tunlock_page(page);\n\t\tput_page(page);\n\n\t\tif (shmem_swizzled)\n\t\t\tgoto again;\n\n\t\treturn -EFAULT;\n\t}\n\n\t/*\n\t * Private mappings are handled in a simple way.\n\t *\n\t * If the futex key is stored on an anonymous page, then the associated\n\t * object is the mm which is implicitly pinned by the calling process.\n\t *\n\t * NOTE: When userspace waits on a MAP_SHARED mapping, even if\n\t * it's a read-only handle, it's expected that futexes attach to\n\t * the object not the particular process.\n\t */\n\tif (PageAnon(page)) {\n\t\t/*\n\t\t * A RO anonymous page will never change and thus doesn't make\n\t\t * sense for futex operations.\n\t\t */\n\t\tif (unlikely(should_fail_futex(fshared)) || ro) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tkey->both.offset |= FUT_OFF_MMSHARED; /* ref taken on mm */\n\t\tkey->private.mm = mm;\n\t\tkey->private.address = address;\n\n\t\tget_futex_key_refs(key); /* implies smp_mb(); (B) */\n\n\t} else {\n\t\tstruct inode *inode;\n\n\t\t/*\n\t\t * The associated futex object in this case is the inode and\n\t\t * the page->mapping must be traversed. Ordinarily this should\n\t\t * be stabilised under page lock but it's not strictly\n\t\t * necessary in this case as we just want to pin the inode, not\n\t\t * update the radix tree or anything like that.\n\t\t *\n\t\t * The RCU read lock is taken as the inode is finally freed\n\t\t * under RCU. If the mapping still matches expectations then the\n\t\t * mapping->host can be safely accessed as being a valid inode.\n\t\t */\n\t\trcu_read_lock();\n\n\t\tif (READ_ONCE(page->mapping) != mapping) {\n\t\t\trcu_read_unlock();\n\t\t\tput_page(page);\n\n\t\t\tgoto again;\n\t\t}\n\n\t\tinode = READ_ONCE(mapping->host);\n\t\tif (!inode) {\n\t\t\trcu_read_unlock();\n\t\t\tput_page(page);\n\n\t\t\tgoto again;\n\t\t}\n\n\t\t/*\n\t\t * Take a reference unless it is about to be freed. Previously\n\t\t * this reference was taken by ihold under the page lock\n\t\t * pinning the inode in place so i_lock was unnecessary. The\n\t\t * only way for this check to fail is if the inode was\n\t\t * truncated in parallel so warn for now if this happens.\n\t\t *\n\t\t * We are not calling into get_futex_key_refs() in file-backed\n\t\t * cases, therefore a successful atomic_inc return below will\n\t\t * guarantee that get_futex_key() will still imply smp_mb(); (B).\n\t\t */\n\t\tif (WARN_ON_ONCE(!atomic_inc_not_zero(&inode->i_count))) {\n\t\t\trcu_read_unlock();\n\t\t\tput_page(page);\n\n\t\t\tgoto again;\n\t\t}\n\n\t\t/* Should be impossible but lets be paranoid for now */\n\t\tif (WARN_ON_ONCE(inode->i_mapping != mapping)) {\n\t\t\terr = -EFAULT;\n\t\t\trcu_read_unlock();\n\t\t\tiput(inode);\n\n\t\t\tgoto out;\n\t\t}\n\n\t\tkey->both.offset |= FUT_OFF_INODE; /* inode-based key */\n\t\tkey->shared.inode = inode;\n\t\tkey->shared.pgoff = basepage_index(tail);\n\t\trcu_read_unlock();\n\t}\n\nout:\n\tput_page(page);\n\treturn err;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145866,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "int wwunpack(uint8_t *exe, uint32_t exesz, uint8_t *wwsect, struct cli_exe_section *sects, uint16_t scount, uint32_t pe, int desc) {\n  uint8_t *structs = wwsect + 0x2a1, *compd, *ccur, *unpd, *ucur, bc;\n  uint32_t src, srcend, szd, bt, bits;\n  int error=0, i;\n\n  cli_dbgmsg(\"in wwunpack\\n\");\n  while (1) {\n    if (!CLI_ISCONTAINED(wwsect, sects[scount].rsz, structs, 17)) {\n      cli_dbgmsg(\"WWPack: Array of structs out of section\\n\");\n      break;\n    }\n    src = sects[scount].rva - cli_readint32(structs); /* src delta / dst delta - not used / dwords / end of src */\n    structs+=8;\n    szd = cli_readint32(structs) * 4;\n    structs+=4;\n    srcend = cli_readint32(structs);\n    structs+=4;\n\n    unpd = ucur = exe+src+srcend+4-szd;\n    if (!szd || !CLI_ISCONTAINED(exe, exesz, unpd, szd)) {\n      cli_dbgmsg(\"WWPack: Compressed data out of file\\n\");\n      break;\n    }\n    cli_dbgmsg(\"WWP: src: %x, szd: %x, srcend: %x - %x\\n\", src, szd, srcend, srcend+4-szd);\n    if (!(compd = cli_malloc(szd))) {\n        cli_dbgmsg(\"WWPack: Unable to allocate memory for compd\\n\");\n        break;\n    }\n    memcpy(compd, unpd, szd);\n    memset(unpd, -1, szd); /*FIXME*/\n    ccur=compd;\n    \n    RESEED;\n    while(!error) {\n      uint32_t backbytes, backsize;\n      uint8_t saved;\n\n      BIT;\n      if (!bits) { /* BYTE copy */\n\tif(ccur-compd>=szd || !CLI_ISCONTAINED(exe, exesz, ucur, 1))\n\t  error=1;\n\telse\n\t  *ucur++=*ccur++;\n\tcontinue;\n      }\n\n      BITS(2);\n      if(bits==3) { /* WORD backcopy */\n\tuint8_t shifted, subbed = 31;\n\tBITS(2);\n\tshifted = bits + 5;\n\tif(bits>=2) {\n\t  shifted++;\n\t  subbed += 0x80;\n\t}\n\tbackbytes = (1<<shifted)-subbed; /* 1h, 21h, 61h, 161h */\n\tBITS(shifted); /* 5, 6, 8, 9 */\n\tif(error || bits == 0x1ff) break;\n\tbackbytes+=bits;\n\tif(!CLI_ISCONTAINED(exe, exesz, ucur, 2) || !CLI_ISCONTAINED(exe, exesz, ucur-backbytes, 2)) {\n\t  error=1;\n\t} else {\n\t  ucur[0]=*(ucur-backbytes);\n\t  ucur[1]=*(ucur-backbytes+1);\n\t  ucur+=2;\n\t}\n\tcontinue;\n      }\n\n      /* BLOCK backcopy */\n      saved = bits; /* cmp al, 1 / pushf */\n\n      BITS(3);\n      if (bits<6) {\n\tbackbytes = bits;\n\tswitch(bits) {\n\tcase 4: /* 10,11 */\n\t  backbytes++;\n\tcase 3: /* 8,9 */\n\t  BIT;\n\t  backbytes+=bits;\n\tcase 0:\tcase 1:\tcase 2: /* 5,6,7 */\n\t  backbytes+=5;\n\t  break;\n\tcase 5: /* 12 */\n\t  backbytes=12;\n\t  break;\n\t}\n\tBITS(backbytes);\n\tbits+=(1<<backbytes)-31;\n      } else if(bits==6) {\n\tBITS(0x0e);\n\tbits+=0x1fe1;\n      } else {\n\tBITS(0x0f);\n\tbits+=0x5fe1;\n      }\n\n      backbytes = bits;\n\n      /* popf / jb */\n      if (!saved) {\n\tBIT;\n\tif(!bits) {\n\t  BIT;\n\t  bits+=5;\n\t} else {\n\t  BITS(3);\n\t  if(bits) {\n\t    bits+=6;\n\t  } else {\n\t    BITS(4);\n\t    if(bits) {\n\t      bits+=13;\n\t    } else {\n\t      uint8_t cnt = 4;\n\t      uint16_t shifted = 0x0d;\n\t      \n\t      do {\n\t\tif(cnt==7) { cnt = 0x0e; shifted = 0; break; }\n\t\tshifted=((shifted+2)<<1)-1;\n\t\tBIT;\n\t\tcnt++;\n\t      } while(!bits);\n\t      BITS(cnt);\n\t      bits+=shifted;\n\t    }\n\t  }\n\t}\n\tbacksize = bits;\n      } else {\n\tbacksize = saved+2;\n      }\n\n      if(!CLI_ISCONTAINED(exe, exesz, ucur, backsize) || !CLI_ISCONTAINED(exe, exesz, ucur-backbytes, backsize)) error=1;\n      else while(backsize--) {\n\t*ucur=*(ucur-backbytes);\n\tucur++;\n      }\n    }\n    free(compd);\n    if(error) {\n      cli_dbgmsg(\"WWPack: decompression error\\n\");\n      break;\n    }\n    if (error || !*structs++) break;\n  }\n\n  if(!error) {\n    if (pe+6 > exesz || pe+7 > exesz || pe+0x28 > exesz ||\n\t\tpe+0x50 > exesz || pe+0x14 > exesz) \n\treturn CL_EFORMAT;\n    exe[pe+6]=(uint8_t)scount;\n    exe[pe+7]=(uint8_t)(scount>>8);\n    cli_writeint32(&exe[pe+0x28], cli_readint32(wwsect+0x295)+sects[scount].rva+0x299);\n    cli_writeint32(&exe[pe+0x50], cli_readint32(&exe[pe+0x50])-sects[scount].vsz);\n\n    structs = &exe[(0xffff&cli_readint32(&exe[pe+0x14]))+pe+0x18];\n    for(i=0 ; i<scount ; i++) {\n\t  if (!CLI_ISCONTAINED(exe, exesz, structs, 0x28)) {\n\t    cli_dbgmsg(\"WWPack: structs pointer out of bounds\\n\");\n\t    return CL_EFORMAT;\n\t  }\n\n      cli_writeint32(structs+8, sects[i].vsz);\n      cli_writeint32(structs+12, sects[i].rva);\n      cli_writeint32(structs+16, sects[i].vsz);\n      cli_writeint32(structs+20, sects[i].rva);\n      structs+=0x28;\n    }\n\tif (!CLI_ISCONTAINED(exe, exesz, structs, 0x28)) {\n\t  cli_dbgmsg(\"WWPack: structs pointer out of bounds\\n\");\n\t  return CL_EFORMAT;\n\t}\n\n    memset(structs, 0, 0x28);\n    error = (uint32_t)cli_writen(desc, exe, exesz)!=exesz;\n  }\n  return error;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145894,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "int wwunpack(uint8_t *exe, uint32_t exesz, uint8_t *wwsect, struct cli_exe_section *sects, uint16_t scount, uint32_t pe, int desc) {\n  uint8_t *structs = wwsect + 0x2a1, *compd, *ccur, *unpd, *ucur, bc;\n  uint32_t src, srcend, szd, bt, bits;\n  int error=0, i;\n\n  cli_dbgmsg(\"in wwunpack\\n\");\n  while (1) {\n    if (!CLI_ISCONTAINED(wwsect, sects[scount].rsz, structs, 17)) {\n      cli_dbgmsg(\"WWPack: Array of structs out of section\\n\");\n      break;\n    }\n    src = sects[scount].rva - cli_readint32(structs); /* src delta / dst delta - not used / dwords / end of src */\n    structs+=8;\n    szd = cli_readint32(structs) * 4;\n    structs+=4;\n    srcend = cli_readint32(structs);\n    structs+=4;\n\n    unpd = ucur = exe+src+srcend+4-szd;\n    if (!szd || !CLI_ISCONTAINED(exe, exesz, unpd, szd)) {\n      cli_dbgmsg(\"WWPack: Compressed data out of file\\n\");\n      break;\n    }\n    cli_dbgmsg(\"WWP: src: %x, szd: %x, srcend: %x - %x\\n\", src, szd, srcend, srcend+4-szd);\n    if (!(compd = cli_malloc(szd))) {\n        cli_dbgmsg(\"WWPack: Unable to allocate memory for compd\\n\");\n        break;\n    }\n    memcpy(compd, unpd, szd);\n    memset(unpd, -1, szd); /*FIXME*/\n    ccur=compd;\n    \n    RESEED;\n    while(!error) {\n      uint32_t backbytes, backsize;\n      uint8_t saved;\n\n      BIT;\n      if (!bits) { /* BYTE copy */\n\tif(ccur-compd>=szd || !CLI_ISCONTAINED(exe, exesz, ucur, 1))\n\t  error=1;\n\telse\n\t  *ucur++=*ccur++;\n\tcontinue;\n      }\n\n      BITS(2);\n      if(bits==3) { /* WORD backcopy */\n\tuint8_t shifted, subbed = 31;\n\tBITS(2);\n\tshifted = bits + 5;\n\tif(bits>=2) {\n\t  shifted++;\n\t  subbed += 0x80;\n\t}\n\tbackbytes = (1<<shifted)-subbed; /* 1h, 21h, 61h, 161h */\n\tBITS(shifted); /* 5, 6, 8, 9 */\n\tif(error || bits == 0x1ff) break;\n\tbackbytes+=bits;\n\tif(!CLI_ISCONTAINED(exe, exesz, ucur, 2) || !CLI_ISCONTAINED(exe, exesz, ucur-backbytes, 2)) {\n\t  error=1;\n\t} else {\n\t  ucur[0]=*(ucur-backbytes);\n\t  ucur[1]=*(ucur-backbytes+1);\n\t  ucur+=2;\n\t}\n\tcontinue;\n      }\n\n      /* BLOCK backcopy */\n      saved = bits; /* cmp al, 1 / pushf */\n\n      BITS(3);\n      if (bits<6) {\n\tbackbytes = bits;\n\tswitch(bits) {\n\tcase 4: /* 10,11 */\n\t  backbytes++;\n\tcase 3: /* 8,9 */\n\t  BIT;\n\t  backbytes+=bits;\n\tcase 0:\tcase 1:\tcase 2: /* 5,6,7 */\n\t  backbytes+=5;\n\t  break;\n\tcase 5: /* 12 */\n\t  backbytes=12;\n\t  break;\n\t}\n\tBITS(backbytes);\n\tbits+=(1<<backbytes)-31;\n      } else if(bits==6) {\n\tBITS(0x0e);\n\tbits+=0x1fe1;\n      } else {\n\tBITS(0x0f);\n\tbits+=0x5fe1;\n      }\n\n      backbytes = bits;\n\n      /* popf / jb */\n      if (!saved) {\n\tBIT;\n\tif(!bits) {\n\t  BIT;\n\t  bits+=5;\n\t} else {\n\t  BITS(3);\n\t  if(bits) {\n\t    bits+=6;\n\t  } else {\n\t    BITS(4);\n\t    if(bits) {\n\t      bits+=13;\n\t    } else {\n\t      uint8_t cnt = 4;\n\t      uint16_t shifted = 0x0d;\n\t      \n\t      do {\n\t\tif(cnt==7) { cnt = 0x0e; shifted = 0; break; }\n\t\tshifted=((shifted+2)<<1)-1;\n\t\tBIT;\n\t\tcnt++;\n\t      } while(!bits);\n\t      BITS(cnt);\n\t      bits+=shifted;\n\t    }\n\t  }\n\t}\n\tbacksize = bits;\n      } else {\n\tbacksize = saved+2;\n      }\n\n      if(!CLI_ISCONTAINED(exe, exesz, ucur, backsize) || !CLI_ISCONTAINED(exe, exesz, ucur-backbytes, backsize)) error=1;\n      else while(backsize--) {\n\t*ucur=*(ucur-backbytes);\n\tucur++;\n      }\n    }\n    free(compd);\n    if(error) {\n      cli_dbgmsg(\"WWPack: decompression error\\n\");\n      break;\n    }\n    if (error || !*structs++) break;\n  }\n\n  if(!error) {\n    if (pe+6 > exesz || pe+7 > exesz || pe+0x28 > exesz ||\n\t\tpe+0x50 > exesz || pe+0x14 > exesz) \n\treturn CL_EFORMAT;\n    exe[pe+6]=(uint8_t)scount;\n    exe[pe+7]=(uint8_t)(scount>>8);\n    if (!CLI_ISCONTAINED(wwsect, sects[scount].rsz, wwsect+0x295, 4) ||\n        !CLI_ISCONTAINED(wwsect, sects[scount].rsz, wwsect+0x295+sects[scount].rva, 4) ||\n        !CLI_ISCONTAINED(wwsect, sects[scount].rsz, wwsect+0x295+sects[scount].rva+0x299, 4)) {\n        cli_dbgmsg(\"WWPack: unpack memory address out of bounds.\\n\");\n        return CL_EFORMAT;\n    }\n    cli_writeint32(&exe[pe+0x28], cli_readint32(wwsect+0x295)+sects[scount].rva+0x299);\n    cli_writeint32(&exe[pe+0x50], cli_readint32(&exe[pe+0x50])-sects[scount].vsz);\n\n    structs = &exe[(0xffff&cli_readint32(&exe[pe+0x14]))+pe+0x18];\n    for(i=0 ; i<scount ; i++) {\n\t  if (!CLI_ISCONTAINED(exe, exesz, structs, 0x28)) {\n\t    cli_dbgmsg(\"WWPack: structs pointer out of bounds\\n\");\n\t    return CL_EFORMAT;\n\t  }\n\n      cli_writeint32(structs+8, sects[i].vsz);\n      cli_writeint32(structs+12, sects[i].rva);\n      cli_writeint32(structs+16, sects[i].vsz);\n      cli_writeint32(structs+20, sects[i].rva);\n      structs+=0x28;\n    }\n\tif (!CLI_ISCONTAINED(exe, exesz, structs, 0x28)) {\n\t  cli_dbgmsg(\"WWPack: structs pointer out of bounds\\n\");\n\t  return CL_EFORMAT;\n\t}\n\n    memset(structs, 0, 0x28);\n    error = (uint32_t)cli_writen(desc, exe, exesz)!=exesz;\n  }\n  return error;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145895,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "void jbd2_journal_wait_updates(journal_t *journal)\n{\n\ttransaction_t *commit_transaction = journal->j_running_transaction;\n\n\tif (!commit_transaction)\n\t\treturn;\n\n\tspin_lock(&commit_transaction->t_handle_lock);\n\twhile (atomic_read(&commit_transaction->t_updates)) {\n\t\tDEFINE_WAIT(wait);\n\n\t\tprepare_to_wait(&journal->j_wait_updates, &wait,\n\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (atomic_read(&commit_transaction->t_updates)) {\n\t\t\tspin_unlock(&commit_transaction->t_handle_lock);\n\t\t\twrite_unlock(&journal->j_state_lock);\n\t\t\tschedule();\n\t\t\twrite_lock(&journal->j_state_lock);\n\t\t\tspin_lock(&commit_transaction->t_handle_lock);\n\t\t}\n\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t}\n\tspin_unlock(&commit_transaction->t_handle_lock);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145902,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "void jbd2_journal_wait_updates(journal_t *journal)\n{\n\tDEFINE_WAIT(wait);\n\n\twhile (1) {\n\t\t/*\n\t\t * Note that the running transaction can get freed under us if\n\t\t * this transaction is getting committed in\n\t\t * jbd2_journal_commit_transaction() ->\n\t\t * jbd2_journal_free_transaction(). This can only happen when we\n\t\t * release j_state_lock -> schedule() -> acquire j_state_lock.\n\t\t * Hence we should everytime retrieve new j_running_transaction\n\t\t * value (after j_state_lock release acquire cycle), else it may\n\t\t * lead to use-after-free of old freed transaction.\n\t\t */\n\t\ttransaction_t *transaction = journal->j_running_transaction;\n\n\t\tif (!transaction)\n\t\t\tbreak;\n\n\t\tspin_lock(&transaction->t_handle_lock);\n\t\tprepare_to_wait(&journal->j_wait_updates, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!atomic_read(&transaction->t_updates)) {\n\t\t\tspin_unlock(&transaction->t_handle_lock);\n\t\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&transaction->t_handle_lock);\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tschedule();\n\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t\twrite_lock(&journal->j_state_lock);\n\t}\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145903,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int hiddev_open(struct inode *inode, struct file *file)\n{\n\tstruct hiddev_list *list;\n\tstruct usb_interface *intf;\n\tstruct hid_device *hid;\n\tstruct hiddev *hiddev;\n\tint res;\n\n\tintf = usbhid_find_interface(iminor(inode));\n\tif (!intf)\n\t\treturn -ENODEV;\n\thid = usb_get_intfdata(intf);\n\thiddev = hid->hiddev;\n\n\tif (!(list = vzalloc(sizeof(struct hiddev_list))))\n\t\treturn -ENOMEM;\n\tmutex_init(&list->thread_lock);\n\tlist->hiddev = hiddev;\n\tfile->private_data = list;\n\n\t/*\n\t * no need for locking because the USB major number\n\t * is shared which usbcore guards against disconnect\n\t */\n\tif (list->hiddev->exist) {\n\t\tif (!list->hiddev->open++) {\n\t\t\tres = hid_hw_open(hiddev->hid);\n\t\t\tif (res < 0)\n\t\t\t\tgoto bail;\n\t\t}\n\t} else {\n\t\tres = -ENODEV;\n\t\tgoto bail;\n\t}\n\n\tspin_lock_irq(&list->hiddev->list_lock);\n\tlist_add_tail(&list->node, &hiddev->list);\n\tspin_unlock_irq(&list->hiddev->list_lock);\n\n\tmutex_lock(&hiddev->existancelock);\n\t/*\n\t * recheck exist with existance lock held to\n\t * avoid opening a disconnected device\n\t */\n\tif (!list->hiddev->exist) {\n\t\tres = -ENODEV;\n\t\tgoto bail_unlock;\n\t}\n\tif (!list->hiddev->open++)\n\t\tif (list->hiddev->exist) {\n\t\t\tstruct hid_device *hid = hiddev->hid;\n\t\t\tres = hid_hw_power(hid, PM_HINT_FULLON);\n\t\t\tif (res < 0)\n\t\t\t\tgoto bail_unlock;\n\t\t\tres = hid_hw_open(hid);\n\t\t\tif (res < 0)\n\t\t\t\tgoto bail_normal_power;\n\t\t}\n\tmutex_unlock(&hiddev->existancelock);\n\treturn 0;\nbail_normal_power:\n\thid_hw_power(hid, PM_HINT_NORMAL);\nbail_unlock:\n\tmutex_unlock(&hiddev->existancelock);\nbail:\n\tfile->private_data = NULL;\n\tvfree(list);\n\treturn res;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145916,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int hiddev_open(struct inode *inode, struct file *file)\n{\n\tstruct hiddev_list *list;\n\tstruct usb_interface *intf;\n\tstruct hid_device *hid;\n\tstruct hiddev *hiddev;\n\tint res;\n\n\tintf = usbhid_find_interface(iminor(inode));\n\tif (!intf)\n\t\treturn -ENODEV;\n\thid = usb_get_intfdata(intf);\n\thiddev = hid->hiddev;\n\n\tif (!(list = vzalloc(sizeof(struct hiddev_list))))\n\t\treturn -ENOMEM;\n\tmutex_init(&list->thread_lock);\n\tlist->hiddev = hiddev;\n\tfile->private_data = list;\n\n\t/*\n\t * no need for locking because the USB major number\n\t * is shared which usbcore guards against disconnect\n\t */\n\tif (list->hiddev->exist) {\n\t\tif (!list->hiddev->open++) {\n\t\t\tres = hid_hw_open(hiddev->hid);\n\t\t\tif (res < 0)\n\t\t\t\tgoto bail;\n\t\t}\n\t} else {\n\t\tres = -ENODEV;\n\t\tgoto bail;\n\t}\n\n\tspin_lock_irq(&list->hiddev->list_lock);\n\tlist_add_tail(&list->node, &hiddev->list);\n\tspin_unlock_irq(&list->hiddev->list_lock);\n\n\tmutex_lock(&hiddev->existancelock);\n\t/*\n\t * recheck exist with existance lock held to\n\t * avoid opening a disconnected device\n\t */\n\tif (!list->hiddev->exist) {\n\t\tres = -ENODEV;\n\t\tgoto bail_unlock;\n\t}\n\tif (!list->hiddev->open++)\n\t\tif (list->hiddev->exist) {\n\t\t\tstruct hid_device *hid = hiddev->hid;\n\t\t\tres = hid_hw_power(hid, PM_HINT_FULLON);\n\t\t\tif (res < 0)\n\t\t\t\tgoto bail_unlock;\n\t\t\tres = hid_hw_open(hid);\n\t\t\tif (res < 0)\n\t\t\t\tgoto bail_normal_power;\n\t\t}\n\tmutex_unlock(&hiddev->existancelock);\n\treturn 0;\nbail_normal_power:\n\thid_hw_power(hid, PM_HINT_NORMAL);\nbail_unlock:\n\tmutex_unlock(&hiddev->existancelock);\n\n\tspin_lock_irq(&list->hiddev->list_lock);\n\tlist_del(&list->node);\n\tspin_unlock_irq(&list->hiddev->list_lock);\nbail:\n\tfile->private_data = NULL;\n\tvfree(list);\n\treturn res;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145917,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int __init serial_ir_init_module(void)\n{\n\tint result;\n\n\tswitch (type) {\n\tcase IR_HOMEBREW:\n\tcase IR_IRDEO:\n\tcase IR_IRDEO_REMOTE:\n\tcase IR_ANIMAX:\n\tcase IR_IGOR:\n\t\t/* if nothing specified, use ttyS0/com1 and irq 4 */\n\t\tio = io ? io : 0x3f8;\n\t\tirq = irq ? irq : 4;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (!softcarrier) {\n\t\tswitch (type) {\n\t\tcase IR_HOMEBREW:\n\t\tcase IR_IGOR:\n\t\t\thardware[type].set_send_carrier = false;\n\t\t\thardware[type].set_duty_cycle = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* make sure sense is either -1, 0, or 1 */\n\tif (sense != -1)\n\t\tsense = !!sense;\n\n\tresult = serial_ir_init();\n\tif (!result)\n\t\treturn 0;\n\n\tserial_ir_exit();\n\treturn result;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145924,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int __init serial_ir_init_module(void)\n{\n\tswitch (type) {\n\tcase IR_HOMEBREW:\n\tcase IR_IRDEO:\n\tcase IR_IRDEO_REMOTE:\n\tcase IR_ANIMAX:\n\tcase IR_IGOR:\n\t\t/* if nothing specified, use ttyS0/com1 and irq 4 */\n\t\tio = io ? io : 0x3f8;\n\t\tirq = irq ? irq : 4;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (!softcarrier) {\n\t\tswitch (type) {\n\t\tcase IR_HOMEBREW:\n\t\tcase IR_IGOR:\n\t\t\thardware[type].set_send_carrier = false;\n\t\t\thardware[type].set_duty_cycle = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* make sure sense is either -1, 0, or 1 */\n\tif (sense != -1)\n\t\tsense = !!sense;\n\n\treturn serial_ir_init();\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145925,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static struct ip *ip_reass(Slirp *slirp, struct ip *ip, struct ipq *fp)\n{\n    register struct mbuf *m = dtom(slirp, ip);\n    register struct ipasfrag *q;\n    int hlen = ip->ip_hl << 2;\n    int i, next;\n\n    DEBUG_CALL(\"ip_reass\");\n    DEBUG_ARG(\"ip = %p\", ip);\n    DEBUG_ARG(\"fp = %p\", fp);\n    DEBUG_ARG(\"m = %p\", m);\n\n    /*\n     * Presence of header sizes in mbufs\n     * would confuse code below.\n     * Fragment m_data is concatenated.\n     */\n    m->m_data += hlen;\n    m->m_len -= hlen;\n\n    /*\n     * If first fragment to arrive, create a reassembly queue.\n     */\n    if (fp == NULL) {\n        struct mbuf *t = m_get(slirp);\n\n        if (t == NULL) {\n            goto dropfrag;\n        }\n        fp = mtod(t, struct ipq *);\n        insque(&fp->ip_link, &slirp->ipq.ip_link);\n        fp->ipq_ttl = IPFRAGTTL;\n        fp->ipq_p = ip->ip_p;\n        fp->ipq_id = ip->ip_id;\n        fp->frag_link.next = fp->frag_link.prev = &fp->frag_link;\n        fp->ipq_src = ip->ip_src;\n        fp->ipq_dst = ip->ip_dst;\n        q = (struct ipasfrag *)fp;\n        goto insert;\n    }\n\n    /*\n     * Find a segment which begins after this one does.\n     */\n    for (q = fp->frag_link.next; q != (struct ipasfrag *)&fp->frag_link;\n         q = q->ipf_next)\n        if (q->ipf_off > ip->ip_off)\n            break;\n\n    /*\n     * If there is a preceding segment, it may provide some of\n     * our data already.  If so, drop the data from the incoming\n     * segment.  If it provides all of our data, drop us.\n     */\n    if (q->ipf_prev != &fp->frag_link) {\n        struct ipasfrag *pq = q->ipf_prev;\n        i = pq->ipf_off + pq->ipf_len - ip->ip_off;\n        if (i > 0) {\n            if (i >= ip->ip_len)\n                goto dropfrag;\n            m_adj(dtom(slirp, ip), i);\n            ip->ip_off += i;\n            ip->ip_len -= i;\n        }\n    }\n\n    /*\n     * While we overlap succeeding segments trim them or,\n     * if they are completely covered, dequeue them.\n     */\n    while (q != (struct ipasfrag *)&fp->frag_link &&\n           ip->ip_off + ip->ip_len > q->ipf_off) {\n        i = (ip->ip_off + ip->ip_len) - q->ipf_off;\n        if (i < q->ipf_len) {\n            q->ipf_len -= i;\n            q->ipf_off += i;\n            m_adj(dtom(slirp, q), i);\n            break;\n        }\n        q = q->ipf_next;\n        m_free(dtom(slirp, q->ipf_prev));\n        ip_deq(q->ipf_prev);\n    }\n\ninsert:\n    /*\n     * Stick new segment in its place;\n     * check for complete reassembly.\n     */\n    ip_enq(iptofrag(ip), q->ipf_prev);\n    next = 0;\n    for (q = fp->frag_link.next; q != (struct ipasfrag *)&fp->frag_link;\n         q = q->ipf_next) {\n        if (q->ipf_off != next)\n            return NULL;\n        next += q->ipf_len;\n    }\n    if (((struct ipasfrag *)(q->ipf_prev))->ipf_tos & 1)\n        return NULL;\n\n    /*\n     * Reassembly is complete; concatenate fragments.\n     */\n    q = fp->frag_link.next;\n    m = dtom(slirp, q);\n\n    int was_ext = m->m_flags & M_EXT;\n\n    q = (struct ipasfrag *)q->ipf_next;\n    while (q != (struct ipasfrag *)&fp->frag_link) {\n        struct mbuf *t = dtom(slirp, q);\n        q = (struct ipasfrag *)q->ipf_next;\n        m_cat(m, t);\n    }\n\n    /*\n     * Create header for new ip packet by\n     * modifying header of first packet;\n     * dequeue and discard fragment reassembly header.\n     * Make header visible.\n     */\n    q = fp->frag_link.next;\n\n    /*\n     * If the fragments concatenated to an mbuf that's bigger than the total\n     * size of the fragment and the mbuf was not already using an m_ext buffer,\n     * then an m_ext buffer was alloced. But fp->ipq_next points to the old\n     * buffer (in the mbuf), so we must point ip into the new buffer.\n     */\n    if (!was_ext && m->m_flags & M_EXT) {\n        int delta = (char *)q - m->m_dat;\n        q = (struct ipasfrag *)(m->m_ext + delta);\n    }\n\n    ip = fragtoip(q);\n    ip->ip_len = next;\n    ip->ip_tos &= ~1;\n    ip->ip_src = fp->ipq_src;\n    ip->ip_dst = fp->ipq_dst;\n    remque(&fp->ip_link);\n    (void)m_free(dtom(slirp, fp));\n    m->m_len += (ip->ip_hl << 2);\n    m->m_data -= (ip->ip_hl << 2);\n\n    return ip;\n\ndropfrag:\n    m_free(m);\n    return NULL;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145932,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static struct ip *ip_reass(Slirp *slirp, struct ip *ip, struct ipq *fp)\n{\n    register struct mbuf *m = dtom(slirp, ip);\n    register struct ipasfrag *q;\n    int hlen = ip->ip_hl << 2;\n    int i, next;\n\n    DEBUG_CALL(\"ip_reass\");\n    DEBUG_ARG(\"ip = %p\", ip);\n    DEBUG_ARG(\"fp = %p\", fp);\n    DEBUG_ARG(\"m = %p\", m);\n\n    /*\n     * Presence of header sizes in mbufs\n     * would confuse code below.\n     * Fragment m_data is concatenated.\n     */\n    m->m_data += hlen;\n    m->m_len -= hlen;\n\n    /*\n     * If first fragment to arrive, create a reassembly queue.\n     */\n    if (fp == NULL) {\n        struct mbuf *t = m_get(slirp);\n\n        if (t == NULL) {\n            goto dropfrag;\n        }\n        fp = mtod(t, struct ipq *);\n        insque(&fp->ip_link, &slirp->ipq.ip_link);\n        fp->ipq_ttl = IPFRAGTTL;\n        fp->ipq_p = ip->ip_p;\n        fp->ipq_id = ip->ip_id;\n        fp->frag_link.next = fp->frag_link.prev = &fp->frag_link;\n        fp->ipq_src = ip->ip_src;\n        fp->ipq_dst = ip->ip_dst;\n        q = (struct ipasfrag *)fp;\n        goto insert;\n    }\n\n    /*\n     * Find a segment which begins after this one does.\n     */\n    for (q = fp->frag_link.next; q != (struct ipasfrag *)&fp->frag_link;\n         q = q->ipf_next)\n        if (q->ipf_off > ip->ip_off)\n            break;\n\n    /*\n     * If there is a preceding segment, it may provide some of\n     * our data already.  If so, drop the data from the incoming\n     * segment.  If it provides all of our data, drop us.\n     */\n    if (q->ipf_prev != &fp->frag_link) {\n        struct ipasfrag *pq = q->ipf_prev;\n        i = pq->ipf_off + pq->ipf_len - ip->ip_off;\n        if (i > 0) {\n            if (i >= ip->ip_len)\n                goto dropfrag;\n            m_adj(dtom(slirp, ip), i);\n            ip->ip_off += i;\n            ip->ip_len -= i;\n        }\n    }\n\n    /*\n     * While we overlap succeeding segments trim them or,\n     * if they are completely covered, dequeue them.\n     */\n    while (q != (struct ipasfrag *)&fp->frag_link &&\n           ip->ip_off + ip->ip_len > q->ipf_off) {\n        struct ipasfrag *prev;\n        i = (ip->ip_off + ip->ip_len) - q->ipf_off;\n        if (i < q->ipf_len) {\n            q->ipf_len -= i;\n            q->ipf_off += i;\n            m_adj(dtom(slirp, q), i);\n            break;\n        }\n        prev = q;\n        q = q->ipf_next;\n        ip_deq(prev);\n        m_free(dtom(slirp, prev));\n    }\n\ninsert:\n    /*\n     * Stick new segment in its place;\n     * check for complete reassembly.\n     */\n    ip_enq(iptofrag(ip), q->ipf_prev);\n    next = 0;\n    for (q = fp->frag_link.next; q != (struct ipasfrag *)&fp->frag_link;\n         q = q->ipf_next) {\n        if (q->ipf_off != next)\n            return NULL;\n        next += q->ipf_len;\n    }\n    if (((struct ipasfrag *)(q->ipf_prev))->ipf_tos & 1)\n        return NULL;\n\n    /*\n     * Reassembly is complete; concatenate fragments.\n     */\n    q = fp->frag_link.next;\n    m = dtom(slirp, q);\n\n    int was_ext = m->m_flags & M_EXT;\n\n    q = (struct ipasfrag *)q->ipf_next;\n    while (q != (struct ipasfrag *)&fp->frag_link) {\n        struct mbuf *t = dtom(slirp, q);\n        q = (struct ipasfrag *)q->ipf_next;\n        m_cat(m, t);\n    }\n\n    /*\n     * Create header for new ip packet by\n     * modifying header of first packet;\n     * dequeue and discard fragment reassembly header.\n     * Make header visible.\n     */\n    q = fp->frag_link.next;\n\n    /*\n     * If the fragments concatenated to an mbuf that's bigger than the total\n     * size of the fragment and the mbuf was not already using an m_ext buffer,\n     * then an m_ext buffer was alloced. But fp->ipq_next points to the old\n     * buffer (in the mbuf), so we must point ip into the new buffer.\n     */\n    if (!was_ext && m->m_flags & M_EXT) {\n        int delta = (char *)q - m->m_dat;\n        q = (struct ipasfrag *)(m->m_ext + delta);\n    }\n\n    ip = fragtoip(q);\n    ip->ip_len = next;\n    ip->ip_tos &= ~1;\n    ip->ip_src = fp->ipq_src;\n    ip->ip_dst = fp->ipq_dst;\n    remque(&fp->ip_link);\n    (void)m_free(dtom(slirp, fp));\n    m->m_len += (ip->ip_hl << 2);\n    m->m_data -= (ip->ip_hl << 2);\n\n    return ip;\n\ndropfrag:\n    m_free(m);\n    return NULL;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145933,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "nv_replace(cmdarg_T *cap)\n{\n    char_u\t*ptr;\n    int\t\thad_ctrl_v;\n    long\tn;\n\n    if (checkclearop(cap->oap))\n\treturn;\n#ifdef FEAT_JOB_CHANNEL\n    if (bt_prompt(curbuf) && !prompt_curpos_editable())\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n#endif\n\n    // get another character\n    if (cap->nchar == Ctrl_V)\n    {\n\thad_ctrl_v = Ctrl_V;\n\tcap->nchar = get_literal(FALSE);\n\t// Don't redo a multibyte character with CTRL-V.\n\tif (cap->nchar > DEL)\n\t    had_ctrl_v = NUL;\n    }\n    else\n\thad_ctrl_v = NUL;\n\n    // Abort if the character is a special key.\n    if (IS_SPECIAL(cap->nchar))\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n\n    // Visual mode \"r\"\n    if (VIsual_active)\n    {\n\tif (got_int)\n\t    reset_VIsual();\n\tif (had_ctrl_v)\n\t{\n\t    // Use a special (negative) number to make a difference between a\n\t    // literal CR or NL and a line break.\n\t    if (cap->nchar == CAR)\n\t\tcap->nchar = REPLACE_CR_NCHAR;\n\t    else if (cap->nchar == NL)\n\t\tcap->nchar = REPLACE_NL_NCHAR;\n\t}\n\tnv_operator(cap);\n\treturn;\n    }\n\n    // Break tabs, etc.\n    if (virtual_active())\n    {\n\tif (u_save_cursor() == FAIL)\n\t    return;\n\tif (gchar_cursor() == NUL)\n\t{\n\t    // Add extra space and put the cursor on the first one.\n\t    coladvance_force((colnr_T)(getviscol() + cap->count1));\n\t    curwin->w_cursor.col -= cap->count1;\n\t}\n\telse if (gchar_cursor() == TAB)\n\t    coladvance_force(getviscol());\n    }\n\n    // Abort if not enough characters to replace.\n    ptr = ml_get_cursor();\n    if (STRLEN(ptr) < (unsigned)cap->count1\n\t    || (has_mbyte && mb_charlen(ptr) < cap->count1))\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n\n    /*\n     * Replacing with a TAB is done by edit() when it is complicated because\n     * 'expandtab' or 'smarttab' is set.  CTRL-V TAB inserts a literal TAB.\n     * Other characters are done below to avoid problems with things like\n     * CTRL-V 048 (for edit() this would be R CTRL-V 0 ESC).\n     */\n    if (had_ctrl_v != Ctrl_V && cap->nchar == '\\t' && (curbuf->b_p_et || p_sta))\n    {\n\tstuffnumReadbuff(cap->count1);\n\tstuffcharReadbuff('R');\n\tstuffcharReadbuff('\\t');\n\tstuffcharReadbuff(ESC);\n\treturn;\n    }\n\n    // save line for undo\n    if (u_save_cursor() == FAIL)\n\treturn;\n\n    if (had_ctrl_v != Ctrl_V && (cap->nchar == '\\r' || cap->nchar == '\\n'))\n    {\n\t/*\n\t * Replace character(s) by a single newline.\n\t * Strange vi behaviour: Only one newline is inserted.\n\t * Delete the characters here.\n\t * Insert the newline with an insert command, takes care of\n\t * autoindent.\tThe insert command depends on being on the last\n\t * character of a line or not.\n\t */\n\t(void)del_chars(cap->count1, FALSE);\t// delete the characters\n\tstuffcharReadbuff('\\r');\n\tstuffcharReadbuff(ESC);\n\n\t// Give 'r' to edit(), to get the redo command right.\n\tinvoke_edit(cap, TRUE, 'r', FALSE);\n    }\n    else\n    {\n\tprep_redo(cap->oap->regname, cap->count1,\n\t\t\t\t       NUL, 'r', NUL, had_ctrl_v, cap->nchar);\n\n\tcurbuf->b_op_start = curwin->w_cursor;\n\tif (has_mbyte)\n\t{\n\t    int\t\told_State = State;\n\n\t    if (cap->ncharC1 != 0)\n\t\tAppendCharToRedobuff(cap->ncharC1);\n\t    if (cap->ncharC2 != 0)\n\t\tAppendCharToRedobuff(cap->ncharC2);\n\n\t    // This is slow, but it handles replacing a single-byte with a\n\t    // multi-byte and the other way around.  Also handles adding\n\t    // composing characters for utf-8.\n\t    for (n = cap->count1; n > 0; --n)\n\t    {\n\t\tState = REPLACE;\n\t\tif (cap->nchar == Ctrl_E || cap->nchar == Ctrl_Y)\n\t\t{\n\t\t    int c = ins_copychar(curwin->w_cursor.lnum\n\t\t\t\t\t   + (cap->nchar == Ctrl_Y ? -1 : 1));\n\t\t    if (c != NUL)\n\t\t\tins_char(c);\n\t\t    else\n\t\t\t// will be decremented further down\n\t\t\t++curwin->w_cursor.col;\n\t\t}\n\t\telse\n\t\t    ins_char(cap->nchar);\n\t\tState = old_State;\n\t\tif (cap->ncharC1 != 0)\n\t\t    ins_char(cap->ncharC1);\n\t\tif (cap->ncharC2 != 0)\n\t\t    ins_char(cap->ncharC2);\n\t    }\n\t}\n\telse\n\t{\n\t    /*\n\t     * Replace the characters within one line.\n\t     */\n\t    for (n = cap->count1; n > 0; --n)\n\t    {\n\t\t/*\n\t\t * Get ptr again, because u_save and/or showmatch() will have\n\t\t * released the line.  At the same time we let know that the\n\t\t * line will be changed.\n\t\t */\n\t\tptr = ml_get_buf(curbuf, curwin->w_cursor.lnum, TRUE);\n\t\tif (cap->nchar == Ctrl_E || cap->nchar == Ctrl_Y)\n\t\t{\n\t\t  int c = ins_copychar(curwin->w_cursor.lnum\n\t\t\t\t\t   + (cap->nchar == Ctrl_Y ? -1 : 1));\n\t\t  if (c != NUL)\n\t\t    ptr[curwin->w_cursor.col] = c;\n\t\t}\n\t\telse\n\t\t    ptr[curwin->w_cursor.col] = cap->nchar;\n\t\tif (p_sm && msg_silent == 0)\n\t\t    showmatch(cap->nchar);\n\t\t++curwin->w_cursor.col;\n\t    }\n#ifdef FEAT_NETBEANS_INTG\n\t    if (netbeans_active())\n\t    {\n\t\tcolnr_T  start = (colnr_T)(curwin->w_cursor.col - cap->count1);\n\n\t\tnetbeans_removed(curbuf, curwin->w_cursor.lnum, start,\n\t\t\t\t\t\t\t   (long)cap->count1);\n\t\tnetbeans_inserted(curbuf, curwin->w_cursor.lnum, start,\n\t\t\t\t\t       &ptr[start], (int)cap->count1);\n\t    }\n#endif\n\n\t    // mark the buffer as changed and prepare for displaying\n\t    changed_bytes(curwin->w_cursor.lnum,\n\t\t\t       (colnr_T)(curwin->w_cursor.col - cap->count1));\n\t}\n\t--curwin->w_cursor.col;\t    // cursor on the last replaced char\n\t// if the character on the left of the current cursor is a multi-byte\n\t// character, move two characters left\n\tif (has_mbyte)\n\t    mb_adjust_cursor();\n\tcurbuf->b_op_end = curwin->w_cursor;\n\tcurwin->w_set_curswant = TRUE;\n\tset_last_insert(cap->nchar);\n    }\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145964,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "nv_replace(cmdarg_T *cap)\n{\n    char_u\t*ptr;\n    int\t\thad_ctrl_v;\n    long\tn;\n\n    if (checkclearop(cap->oap))\n\treturn;\n#ifdef FEAT_JOB_CHANNEL\n    if (bt_prompt(curbuf) && !prompt_curpos_editable())\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n#endif\n\n    // get another character\n    if (cap->nchar == Ctrl_V)\n    {\n\thad_ctrl_v = Ctrl_V;\n\tcap->nchar = get_literal(FALSE);\n\t// Don't redo a multibyte character with CTRL-V.\n\tif (cap->nchar > DEL)\n\t    had_ctrl_v = NUL;\n    }\n    else\n\thad_ctrl_v = NUL;\n\n    // Abort if the character is a special key.\n    if (IS_SPECIAL(cap->nchar))\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n\n    // Visual mode \"r\"\n    if (VIsual_active)\n    {\n\tif (got_int)\n\t    reset_VIsual();\n\tif (had_ctrl_v)\n\t{\n\t    // Use a special (negative) number to make a difference between a\n\t    // literal CR or NL and a line break.\n\t    if (cap->nchar == CAR)\n\t\tcap->nchar = REPLACE_CR_NCHAR;\n\t    else if (cap->nchar == NL)\n\t\tcap->nchar = REPLACE_NL_NCHAR;\n\t}\n\tnv_operator(cap);\n\treturn;\n    }\n\n    // Break tabs, etc.\n    if (virtual_active())\n    {\n\tif (u_save_cursor() == FAIL)\n\t    return;\n\tif (gchar_cursor() == NUL)\n\t{\n\t    // Add extra space and put the cursor on the first one.\n\t    coladvance_force((colnr_T)(getviscol() + cap->count1));\n\t    curwin->w_cursor.col -= cap->count1;\n\t}\n\telse if (gchar_cursor() == TAB)\n\t    coladvance_force(getviscol());\n    }\n\n    // Abort if not enough characters to replace.\n    ptr = ml_get_cursor();\n    if (STRLEN(ptr) < (unsigned)cap->count1\n\t    || (has_mbyte && mb_charlen(ptr) < cap->count1))\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n\n    /*\n     * Replacing with a TAB is done by edit() when it is complicated because\n     * 'expandtab' or 'smarttab' is set.  CTRL-V TAB inserts a literal TAB.\n     * Other characters are done below to avoid problems with things like\n     * CTRL-V 048 (for edit() this would be R CTRL-V 0 ESC).\n     */\n    if (had_ctrl_v != Ctrl_V && cap->nchar == '\\t' && (curbuf->b_p_et || p_sta))\n    {\n\tstuffnumReadbuff(cap->count1);\n\tstuffcharReadbuff('R');\n\tstuffcharReadbuff('\\t');\n\tstuffcharReadbuff(ESC);\n\treturn;\n    }\n\n    // save line for undo\n    if (u_save_cursor() == FAIL)\n\treturn;\n\n    if (had_ctrl_v != Ctrl_V && (cap->nchar == '\\r' || cap->nchar == '\\n'))\n    {\n\t/*\n\t * Replace character(s) by a single newline.\n\t * Strange vi behaviour: Only one newline is inserted.\n\t * Delete the characters here.\n\t * Insert the newline with an insert command, takes care of\n\t * autoindent.\tThe insert command depends on being on the last\n\t * character of a line or not.\n\t */\n\t(void)del_chars(cap->count1, FALSE);\t// delete the characters\n\tstuffcharReadbuff('\\r');\n\tstuffcharReadbuff(ESC);\n\n\t// Give 'r' to edit(), to get the redo command right.\n\tinvoke_edit(cap, TRUE, 'r', FALSE);\n    }\n    else\n    {\n\tprep_redo(cap->oap->regname, cap->count1,\n\t\t\t\t       NUL, 'r', NUL, had_ctrl_v, cap->nchar);\n\n\tcurbuf->b_op_start = curwin->w_cursor;\n\tif (has_mbyte)\n\t{\n\t    int\t\told_State = State;\n\n\t    if (cap->ncharC1 != 0)\n\t\tAppendCharToRedobuff(cap->ncharC1);\n\t    if (cap->ncharC2 != 0)\n\t\tAppendCharToRedobuff(cap->ncharC2);\n\n\t    // This is slow, but it handles replacing a single-byte with a\n\t    // multi-byte and the other way around.  Also handles adding\n\t    // composing characters for utf-8.\n\t    for (n = cap->count1; n > 0; --n)\n\t    {\n\t\tState = REPLACE;\n\t\tif (cap->nchar == Ctrl_E || cap->nchar == Ctrl_Y)\n\t\t{\n\t\t    int c = ins_copychar(curwin->w_cursor.lnum\n\t\t\t\t\t   + (cap->nchar == Ctrl_Y ? -1 : 1));\n\t\t    if (c != NUL)\n\t\t\tins_char(c);\n\t\t    else\n\t\t\t// will be decremented further down\n\t\t\t++curwin->w_cursor.col;\n\t\t}\n\t\telse\n\t\t    ins_char(cap->nchar);\n\t\tState = old_State;\n\t\tif (cap->ncharC1 != 0)\n\t\t    ins_char(cap->ncharC1);\n\t\tif (cap->ncharC2 != 0)\n\t\t    ins_char(cap->ncharC2);\n\t    }\n\t}\n\telse\n\t{\n\t    /*\n\t     * Replace the characters within one line.\n\t     */\n\t    for (n = cap->count1; n > 0; --n)\n\t    {\n\t\t/*\n\t\t * Get ptr again, because u_save and/or showmatch() will have\n\t\t * released the line.  This may also happen in ins_copychar().\n\t\t * At the same time we let know that the line will be changed.\n\t\t */\n\t\tif (cap->nchar == Ctrl_E || cap->nchar == Ctrl_Y)\n\t\t{\n\t\t  int c = ins_copychar(curwin->w_cursor.lnum\n\t\t\t\t\t   + (cap->nchar == Ctrl_Y ? -1 : 1));\n\n\t\t  ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum, TRUE);\n\t\t  if (c != NUL)\n\t\t    ptr[curwin->w_cursor.col] = c;\n\t\t}\n\t\telse\n\t\t{\n\t\t    ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum, TRUE);\n\t\t    ptr[curwin->w_cursor.col] = cap->nchar;\n\t\t}\n\t\tif (p_sm && msg_silent == 0)\n\t\t    showmatch(cap->nchar);\n\t\t++curwin->w_cursor.col;\n\t    }\n#ifdef FEAT_NETBEANS_INTG\n\t    if (netbeans_active())\n\t    {\n\t\tcolnr_T  start = (colnr_T)(curwin->w_cursor.col - cap->count1);\n\n\t\tnetbeans_removed(curbuf, curwin->w_cursor.lnum, start,\n\t\t\t\t\t\t\t   (long)cap->count1);\n\t\tnetbeans_inserted(curbuf, curwin->w_cursor.lnum, start,\n\t\t\t\t\t       &ptr[start], (int)cap->count1);\n\t    }\n#endif\n\n\t    // mark the buffer as changed and prepare for displaying\n\t    changed_bytes(curwin->w_cursor.lnum,\n\t\t\t       (colnr_T)(curwin->w_cursor.col - cap->count1));\n\t}\n\t--curwin->w_cursor.col;\t    // cursor on the last replaced char\n\t// if the character on the left of the current cursor is a multi-byte\n\t// character, move two characters left\n\tif (has_mbyte)\n\t    mb_adjust_cursor();\n\tcurbuf->b_op_end = curwin->w_cursor;\n\tcurwin->w_set_curswant = TRUE;\n\tset_last_insert(cap->nchar);\n    }\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145965,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static void cpia2_usb_disconnect(struct usb_interface *intf)\n{\n\tstruct camera_data *cam = usb_get_intfdata(intf);\n\tusb_set_intfdata(intf, NULL);\n\n\tDBG(\"Stopping stream\\n\");\n\tcpia2_usb_stream_stop(cam);\n\n\tmutex_lock(&cam->v4l2_lock);\n\tDBG(\"Unregistering camera\\n\");\n\tcpia2_unregister_camera(cam);\n\tv4l2_device_disconnect(&cam->v4l2_dev);\n\tmutex_unlock(&cam->v4l2_lock);\n\tv4l2_device_put(&cam->v4l2_dev);\n\n\tif(cam->buffers) {\n\t\tDBG(\"Wakeup waiting processes\\n\");\n\t\tcam->curbuff->status = FRAME_READY;\n\t\tcam->curbuff->length = 0;\n\t\twake_up_interruptible(&cam->wq_stream);\n\t}\n\n\tLOG(\"CPiA2 camera disconnected.\\n\");\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145996,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static void cpia2_usb_disconnect(struct usb_interface *intf)\n{\n\tstruct camera_data *cam = usb_get_intfdata(intf);\n\tusb_set_intfdata(intf, NULL);\n\n\tDBG(\"Stopping stream\\n\");\n\tcpia2_usb_stream_stop(cam);\n\n\tmutex_lock(&cam->v4l2_lock);\n\tDBG(\"Unregistering camera\\n\");\n\tcpia2_unregister_camera(cam);\n\tv4l2_device_disconnect(&cam->v4l2_dev);\n\tmutex_unlock(&cam->v4l2_lock);\n\n\tif(cam->buffers) {\n\t\tDBG(\"Wakeup waiting processes\\n\");\n\t\tcam->curbuff->status = FRAME_READY;\n\t\tcam->curbuff->length = 0;\n\t\twake_up_interruptible(&cam->wq_stream);\n\t}\n\n\tv4l2_device_put(&cam->v4l2_dev);\n\n\tLOG(\"CPiA2 camera disconnected.\\n\");\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145997,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "int snd_card_disconnect(struct snd_card *card)\n{\n\tstruct snd_monitor_file *mfile;\n\n\tif (!card)\n\t\treturn -EINVAL;\n\n\tspin_lock(&card->files_lock);\n\tif (card->shutdown) {\n\t\tspin_unlock(&card->files_lock);\n\t\treturn 0;\n\t}\n\tcard->shutdown = 1;\n\tspin_unlock(&card->files_lock);\n\n\t/* phase 1: disable fops (user space) operations for ALSA API */\n\tmutex_lock(&snd_card_mutex);\n\tsnd_cards[card->number] = NULL;\n\tclear_bit(card->number, snd_cards_lock);\n\tmutex_unlock(&snd_card_mutex);\n\t\n\t/* phase 2: replace file->f_op with special dummy operations */\n\t\n\tspin_lock(&card->files_lock);\n\tlist_for_each_entry(mfile, &card->files_list, list) {\n\t\t/* it's critical part, use endless loop */\n\t\t/* we have no room to fail */\n\t\tmfile->disconnected_f_op = mfile->file->f_op;\n\n\t\tspin_lock(&shutdown_lock);\n\t\tlist_add(&mfile->shutdown_list, &shutdown_files);\n\t\tspin_unlock(&shutdown_lock);\n\n\t\tmfile->file->f_op = &snd_shutdown_f_ops;\n\t\tfops_get(mfile->file->f_op);\n\t}\n\tspin_unlock(&card->files_lock);\t\n\n\t/* phase 3: notify all connected devices about disconnection */\n\t/* at this point, they cannot respond to any calls except release() */\n\n#if IS_ENABLED(CONFIG_SND_MIXER_OSS)\n\tif (snd_mixer_oss_notify_callback)\n\t\tsnd_mixer_oss_notify_callback(card, SND_MIXER_OSS_NOTIFY_DISCONNECT);\n#endif\n\n\t/* notify all devices that we are disconnected */\n\tsnd_device_disconnect_all(card);\n\n\tsnd_info_card_disconnect(card);\n\tif (card->registered) {\n\t\tdevice_del(&card->card_dev);\n\t\tcard->registered = false;\n\t}\n#ifdef CONFIG_PM\n\twake_up(&card->power_sleep);\n#endif\n\treturn 0;\t\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146074,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "int snd_card_disconnect(struct snd_card *card)\n{\n\tstruct snd_monitor_file *mfile;\n\n\tif (!card)\n\t\treturn -EINVAL;\n\n\tspin_lock(&card->files_lock);\n\tif (card->shutdown) {\n\t\tspin_unlock(&card->files_lock);\n\t\treturn 0;\n\t}\n\tcard->shutdown = 1;\n\tspin_unlock(&card->files_lock);\n\n\t/* replace file->f_op with special dummy operations */\n\tspin_lock(&card->files_lock);\n\tlist_for_each_entry(mfile, &card->files_list, list) {\n\t\t/* it's critical part, use endless loop */\n\t\t/* we have no room to fail */\n\t\tmfile->disconnected_f_op = mfile->file->f_op;\n\n\t\tspin_lock(&shutdown_lock);\n\t\tlist_add(&mfile->shutdown_list, &shutdown_files);\n\t\tspin_unlock(&shutdown_lock);\n\n\t\tmfile->file->f_op = &snd_shutdown_f_ops;\n\t\tfops_get(mfile->file->f_op);\n\t}\n\tspin_unlock(&card->files_lock);\t\n\n\t/* notify all connected devices about disconnection */\n\t/* at this point, they cannot respond to any calls except release() */\n\n#if IS_ENABLED(CONFIG_SND_MIXER_OSS)\n\tif (snd_mixer_oss_notify_callback)\n\t\tsnd_mixer_oss_notify_callback(card, SND_MIXER_OSS_NOTIFY_DISCONNECT);\n#endif\n\n\t/* notify all devices that we are disconnected */\n\tsnd_device_disconnect_all(card);\n\n\tsnd_info_card_disconnect(card);\n\tif (card->registered) {\n\t\tdevice_del(&card->card_dev);\n\t\tcard->registered = false;\n\t}\n\n\t/* disable fops (user space) operations for ALSA API */\n\tmutex_lock(&snd_card_mutex);\n\tsnd_cards[card->number] = NULL;\n\tclear_bit(card->number, snd_cards_lock);\n\tmutex_unlock(&snd_card_mutex);\n\n#ifdef CONFIG_PM\n\twake_up(&card->power_sleep);\n#endif\n\treturn 0;\t\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146075,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "MagickExport MagickBooleanType SetImageAlphaChannel(Image *image,\n  const AlphaChannelOption alpha_type,ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image->signature == MagickCoreSignature);\n  status=MagickTrue;\n  switch (alpha_type)\n  {\n    case ActivateAlphaChannel:\n    {\n      image->alpha_trait=BlendPixelTrait;\n      break;\n    }\n    case AssociateAlphaChannel:\n    {\n      /*\n        Associate alpha.\n      */\n      status=SetImageStorageClass(image,DirectClass,exception);\n      if (status == MagickFalse)\n        break;\n      image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n      #pragma omp parallel for schedule(static) shared(status) \\\n        magick_number_threads(image,image,image->rows,1)\n#endif\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        register Quantum\n          *magick_restrict q;\n\n        register ssize_t\n          x;\n\n        if (status == MagickFalse)\n          continue;\n        q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,\n          exception);\n        if (q == (Quantum *) NULL)\n          {\n            status=MagickFalse;\n            continue;\n          }\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          double\n            gamma;\n\n          register ssize_t\n            i;\n\n          gamma=QuantumScale*GetPixelAlpha(image,q);\n          for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n          {\n            PixelChannel channel = GetPixelChannelChannel(image,i);\n            PixelTrait traits = GetPixelChannelTraits(image,channel);\n            if (channel == AlphaPixelChannel)\n              continue;\n            if ((traits & UpdatePixelTrait) == 0)\n              continue;\n            q[i]=ClampToQuantum(gamma*q[i]);\n          }\n          q+=GetPixelChannels(image);\n        }\n        if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n          status=MagickFalse;\n      }\n      image_view=DestroyCacheView(image_view);\n      image->alpha_trait=CopyPixelTrait;\n      return(status);\n    }\n    case BackgroundAlphaChannel:\n    {\n      /*\n        Set transparent pixels to background color.\n      */\n      if (image->alpha_trait == UndefinedPixelTrait)\n        break;\n      status=SetImageStorageClass(image,DirectClass,exception);\n      if (status == MagickFalse)\n        break;\n      image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n      #pragma omp parallel for schedule(static) shared(status) \\\n        magick_number_threads(image,image,image->rows,1)\n#endif\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        register Quantum\n          *magick_restrict q;\n\n        register ssize_t\n          x;\n\n        if (status == MagickFalse)\n          continue;\n        q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,\n          exception);\n        if (q == (Quantum *) NULL)\n          {\n            status=MagickFalse;\n            continue;\n          }\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          if (GetPixelAlpha(image,q) == TransparentAlpha)\n            {\n              SetPixelViaPixelInfo(image,&image->background_color,q);\n              SetPixelChannel(image,AlphaPixelChannel,TransparentAlpha,q);\n            }\n          q+=GetPixelChannels(image);\n        }\n        if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n          status=MagickFalse;\n      }\n      image_view=DestroyCacheView(image_view);\n      return(status);\n    }\n    case CopyAlphaChannel:\n    {\n      image->alpha_trait=UpdatePixelTrait;\n      status=CompositeImage(image,image,IntensityCompositeOp,MagickTrue,0,0,\n        exception);\n      break;\n    }\n    case DeactivateAlphaChannel:\n    {\n      if (image->alpha_trait == UndefinedPixelTrait)\n        status=SetImageAlpha(image,OpaqueAlpha,exception);\n      image->alpha_trait=CopyPixelTrait;\n      break;\n    }\n    case DisassociateAlphaChannel:\n    {\n      /*\n        Disassociate alpha.\n      */\n      status=SetImageStorageClass(image,DirectClass,exception);\n      if (status == MagickFalse)\n        break;\n      image->alpha_trait=BlendPixelTrait;\n      image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n      #pragma omp parallel for schedule(static) shared(status) \\\n        magick_number_threads(image,image,image->rows,1)\n#endif\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        register Quantum\n          *magick_restrict q;\n\n        register ssize_t\n          x;\n\n        if (status == MagickFalse)\n          continue;\n        q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,\n          exception);\n        if (q == (Quantum *) NULL)\n          {\n            status=MagickFalse;\n            continue;\n          }\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          double\n            gamma,\n            Sa;\n\n          register ssize_t\n            i;\n\n          Sa=QuantumScale*GetPixelAlpha(image,q);\n          gamma=PerceptibleReciprocal(Sa);\n          for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n          {\n            PixelChannel channel = GetPixelChannelChannel(image,i);\n            PixelTrait traits = GetPixelChannelTraits(image,channel);\n            if (channel == AlphaPixelChannel)\n              continue;\n            if ((traits & UpdatePixelTrait) == 0)\n              continue;\n            q[i]=ClampToQuantum(gamma*q[i]);\n          }\n          q+=GetPixelChannels(image);\n        }\n        if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n          status=MagickFalse;\n      }\n      image_view=DestroyCacheView(image_view);\n      image->alpha_trait=UndefinedPixelTrait;\n      return(status);\n    }\n    case DiscreteAlphaChannel:\n    {\n      if (image->alpha_trait == UndefinedPixelTrait)\n        status=SetImageAlpha(image,OpaqueAlpha,exception);\n      image->alpha_trait=UpdatePixelTrait;\n      break;\n    }\n    case ExtractAlphaChannel:\n    {\n      status=CompositeImage(image,image,AlphaCompositeOp,MagickTrue,0,0,\n        exception);\n      image->alpha_trait=UndefinedPixelTrait;\n      break;\n    }\n    case OffAlphaChannel:\n    {\n      image->alpha_trait=UndefinedPixelTrait;\n      break;\n    }\n    case OnAlphaChannel:\n    {\n      if (image->alpha_trait == UndefinedPixelTrait)\n        status=SetImageAlpha(image,OpaqueAlpha,exception);\n      image->alpha_trait=BlendPixelTrait;\n      break;\n    }\n    case OpaqueAlphaChannel:\n    {\n      status=SetImageAlpha(image,OpaqueAlpha,exception);\n      break;\n    }\n    case RemoveAlphaChannel:\n    {\n      /*\n        Remove transparency.\n      */\n      if (image->alpha_trait == UndefinedPixelTrait)\n        break;\n      status=SetImageStorageClass(image,DirectClass,exception);\n      if (status == MagickFalse)\n        break;\n      image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n      #pragma omp parallel for schedule(static) shared(status) \\\n        magick_number_threads(image,image,image->rows,1)\n#endif\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        register Quantum\n          *magick_restrict q;\n\n        register ssize_t\n          x;\n\n        if (status == MagickFalse)\n          continue;\n        q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,\n          exception);\n        if (q == (Quantum *) NULL)\n          {\n            status=MagickFalse;\n            continue;\n          }\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          FlattenPixelInfo(image,&image->background_color,\n            image->background_color.alpha,q,(double) GetPixelAlpha(image,q),q);\n          q+=GetPixelChannels(image);\n        }\n        if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n          status=MagickFalse;\n      }\n      image_view=DestroyCacheView(image_view);\n      image->alpha_trait=image->background_color.alpha_trait;\n      break;\n    }\n    case SetAlphaChannel:\n    {\n      if (image->alpha_trait == UndefinedPixelTrait)\n        status=SetImageAlpha(image,OpaqueAlpha,exception);\n      break;\n    }\n    case ShapeAlphaChannel:\n    {\n      /*\n        Remove transparency.\n      */\n      image->alpha_trait=BlendPixelTrait;\n      status=SetImageStorageClass(image,DirectClass,exception);\n      if (status == MagickFalse)\n        break;\n      image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n      #pragma omp parallel for schedule(static) shared(status) \\\n        magick_number_threads(image,image,image->rows,1)\n#endif\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        PixelInfo\n          background;\n\n        register Quantum\n          *magick_restrict q;\n\n        register ssize_t\n          x;\n\n        if (status == MagickFalse)\n          continue;\n        q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,\n          exception);\n        if (q == (Quantum *) NULL)\n          {\n            status=MagickFalse;\n            continue;\n          }\n        ConformPixelInfo(image,&image->background_color,&background,exception);\n        background.alpha_trait=BlendPixelTrait;\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          background.alpha=GetPixelIntensity(image,q);\n          SetPixelViaPixelInfo(image,&background,q);\n          q+=GetPixelChannels(image);\n        }\n        if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n          status=MagickFalse;\n      }\n      image_view=DestroyCacheView(image_view);\n      break;\n    }\n    case TransparentAlphaChannel:\n    {\n      status=SetImageAlpha(image,TransparentAlpha,exception);\n      break;\n    }\n    case UndefinedAlphaChannel:\n      break;\n  }\n  if (status == MagickFalse)\n    return(status);\n  (void) SetPixelChannelMask(image,image->channel_mask);\n  return(SyncImagePixelCache(image,exception));\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146148,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "MagickExport MagickBooleanType SetImageAlphaChannel(Image *image,\n  const AlphaChannelOption alpha_type,ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image->signature == MagickCoreSignature);\n  status=MagickTrue;\n  switch (alpha_type)\n  {\n    case ActivateAlphaChannel:\n    {\n      image->alpha_trait=BlendPixelTrait;\n      break;\n    }\n    case AssociateAlphaChannel:\n    {\n      /*\n        Associate alpha.\n      */\n      status=SetImageStorageClass(image,DirectClass,exception);\n      if (status == MagickFalse)\n        break;\n      image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n      #pragma omp parallel for schedule(static) shared(status) \\\n        magick_number_threads(image,image,image->rows,1)\n#endif\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        register Quantum\n          *magick_restrict q;\n\n        register ssize_t\n          x;\n\n        if (status == MagickFalse)\n          continue;\n        q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,\n          exception);\n        if (q == (Quantum *) NULL)\n          {\n            status=MagickFalse;\n            continue;\n          }\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          double\n            gamma;\n\n          register ssize_t\n            i;\n\n          gamma=QuantumScale*GetPixelAlpha(image,q);\n          for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n          {\n            PixelChannel channel = GetPixelChannelChannel(image,i);\n            PixelTrait traits = GetPixelChannelTraits(image,channel);\n            if (channel == AlphaPixelChannel)\n              continue;\n            if ((traits & UpdatePixelTrait) == 0)\n              continue;\n            q[i]=ClampToQuantum(gamma*q[i]);\n          }\n          q+=GetPixelChannels(image);\n        }\n        if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n          status=MagickFalse;\n      }\n      image_view=DestroyCacheView(image_view);\n      image->alpha_trait=CopyPixelTrait;\n      return(status);\n    }\n    case BackgroundAlphaChannel:\n    {\n      /*\n        Set transparent pixels to background color.\n      */\n      if (image->alpha_trait == UndefinedPixelTrait)\n        break;\n      status=SetImageStorageClass(image,DirectClass,exception);\n      if (status == MagickFalse)\n        break;\n      image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n      #pragma omp parallel for schedule(static) shared(status) \\\n        magick_number_threads(image,image,image->rows,1)\n#endif\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        register Quantum\n          *magick_restrict q;\n\n        register ssize_t\n          x;\n\n        if (status == MagickFalse)\n          continue;\n        q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,\n          exception);\n        if (q == (Quantum *) NULL)\n          {\n            status=MagickFalse;\n            continue;\n          }\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          if (GetPixelAlpha(image,q) == TransparentAlpha)\n            {\n              SetPixelViaPixelInfo(image,&image->background_color,q);\n              SetPixelChannel(image,AlphaPixelChannel,TransparentAlpha,q);\n            }\n          q+=GetPixelChannels(image);\n        }\n        if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n          status=MagickFalse;\n      }\n      image_view=DestroyCacheView(image_view);\n      return(status);\n    }\n    case CopyAlphaChannel:\n    {\n      image->alpha_trait=UpdatePixelTrait;\n      status=CompositeImage(image,image,IntensityCompositeOp,MagickTrue,0,0,\n        exception);\n      break;\n    }\n    case DeactivateAlphaChannel:\n    {\n      if (image->alpha_trait == UndefinedPixelTrait)\n        status=SetImageAlpha(image,OpaqueAlpha,exception);\n      image->alpha_trait=CopyPixelTrait;\n      break;\n    }\n    case DisassociateAlphaChannel:\n    {\n      /*\n        Disassociate alpha.\n      */\n      status=SetImageStorageClass(image,DirectClass,exception);\n      if (status == MagickFalse)\n        break;\n      image->alpha_trait=BlendPixelTrait;\n      image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n      #pragma omp parallel for schedule(static) shared(status) \\\n        magick_number_threads(image,image,image->rows,1)\n#endif\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        register Quantum\n          *magick_restrict q;\n\n        register ssize_t\n          x;\n\n        if (status == MagickFalse)\n          continue;\n        q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,\n          exception);\n        if (q == (Quantum *) NULL)\n          {\n            status=MagickFalse;\n            continue;\n          }\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          double\n            gamma,\n            Sa;\n\n          register ssize_t\n            i;\n\n          Sa=QuantumScale*GetPixelAlpha(image,q);\n          gamma=PerceptibleReciprocal(Sa);\n          for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n          {\n            PixelChannel channel = GetPixelChannelChannel(image,i);\n            PixelTrait traits = GetPixelChannelTraits(image,channel);\n            if (channel == AlphaPixelChannel)\n              continue;\n            if ((traits & UpdatePixelTrait) == 0)\n              continue;\n            q[i]=ClampToQuantum(gamma*q[i]);\n          }\n          q+=GetPixelChannels(image);\n        }\n        if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n          status=MagickFalse;\n      }\n      image_view=DestroyCacheView(image_view);\n      image->alpha_trait=UndefinedPixelTrait;\n      return(status);\n    }\n    case DiscreteAlphaChannel:\n    {\n      if (image->alpha_trait == UndefinedPixelTrait)\n        status=SetImageAlpha(image,OpaqueAlpha,exception);\n      image->alpha_trait=UpdatePixelTrait;\n      break;\n    }\n    case ExtractAlphaChannel:\n    {\n      status=CompositeImage(image,image,AlphaCompositeOp,MagickTrue,0,0,\n        exception);\n      image->alpha_trait=UndefinedPixelTrait;\n      break;\n    }\n    case OffAlphaChannel:\n    {\n      image->alpha_trait=UndefinedPixelTrait;\n      break;\n    }\n    case OnAlphaChannel:\n    {\n      if (image->alpha_trait == UndefinedPixelTrait)\n        status=SetImageAlpha(image,OpaqueAlpha,exception);\n      image->alpha_trait=BlendPixelTrait;\n      break;\n    }\n    case OpaqueAlphaChannel:\n    {\n      status=SetImageAlpha(image,OpaqueAlpha,exception);\n      break;\n    }\n    case RemoveAlphaChannel:\n    {\n      /*\n        Remove transparency.\n      */\n      if (image->alpha_trait == UndefinedPixelTrait)\n        break;\n      status=SetImageStorageClass(image,DirectClass,exception);\n      if (status == MagickFalse)\n        break;\n      image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n      #pragma omp parallel for schedule(static) shared(status) \\\n        magick_number_threads(image,image,image->rows,1)\n#endif\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        register Quantum\n          *magick_restrict q;\n\n        register ssize_t\n          x;\n\n        if (status == MagickFalse)\n          continue;\n        q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,\n          exception);\n        if (q == (Quantum *) NULL)\n          {\n            status=MagickFalse;\n            continue;\n          }\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          FlattenPixelInfo(image,&image->background_color,\n            image->background_color.alpha,q,(double) GetPixelAlpha(image,q),q);\n          q+=GetPixelChannels(image);\n        }\n        if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n          status=MagickFalse;\n      }\n      image_view=DestroyCacheView(image_view);\n      image->alpha_trait=image->background_color.alpha_trait;\n      break;\n    }\n    case SetAlphaChannel:\n    {\n      if (image->alpha_trait == UndefinedPixelTrait)\n        status=SetImageAlpha(image,OpaqueAlpha,exception);\n      break;\n    }\n    case ShapeAlphaChannel:\n    {\n      /*\n        Remove transparency.\n      */\n      image->alpha_trait=BlendPixelTrait;\n      status=SetImageStorageClass(image,DirectClass,exception);\n      if (status == MagickFalse)\n        break;\n      image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n      #pragma omp parallel for schedule(static) shared(status) \\\n        magick_number_threads(image,image,image->rows,1)\n#endif\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        PixelInfo\n          background;\n\n        register Quantum\n          *magick_restrict q;\n\n        register ssize_t\n          x;\n\n        if (status == MagickFalse)\n          continue;\n        ConformPixelInfo(image,&image->background_color,&background,exception);\n        q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,\n          exception);\n        if (q == (Quantum *) NULL)\n          {\n            status=MagickFalse;\n            continue;\n          }\n        background.alpha_trait=BlendPixelTrait;\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          background.alpha=GetPixelIntensity(image,q);\n          SetPixelViaPixelInfo(image,&background,q);\n          q+=GetPixelChannels(image);\n        }\n        if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n          status=MagickFalse;\n      }\n      image_view=DestroyCacheView(image_view);\n      break;\n    }\n    case TransparentAlphaChannel:\n    {\n      status=SetImageAlpha(image,TransparentAlpha,exception);\n      break;\n    }\n    case UndefinedAlphaChannel:\n      break;\n  }\n  if (status == MagickFalse)\n    return(status);\n  (void) SetPixelChannelMask(image,image->channel_mask);\n  return(SyncImagePixelCache(image,exception));\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146149,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static void iowarrior_disconnect(struct usb_interface *interface)\n{\n\tstruct iowarrior *dev;\n\tint minor;\n\n\tdev = usb_get_intfdata(interface);\n\tmutex_lock(&iowarrior_open_disc_lock);\n\tusb_set_intfdata(interface, NULL);\n\t/* prevent device read, write and ioctl */\n\tdev->present = 0;\n\n\tminor = dev->minor;\n\tmutex_unlock(&iowarrior_open_disc_lock);\n\t/* give back our minor - this will call close() locks need to be dropped at this point*/\n\n\tusb_deregister_dev(interface, &iowarrior_class);\n\n\tmutex_lock(&dev->mutex);\n\n\t/* prevent device read, write and ioctl */\n\n\tmutex_unlock(&dev->mutex);\n\n\tif (dev->opened) {\n\t\t/* There is a process that holds a filedescriptor to the device ,\n\t\t   so we only shutdown read-/write-ops going on.\n\t\t   Deleting the device is postponed until close() was called.\n\t\t */\n\t\tusb_kill_urb(dev->int_in_urb);\n\t\twake_up_interruptible(&dev->read_wait);\n\t\twake_up_interruptible(&dev->write_wait);\n\t} else {\n\t\t/* no process is using the device, cleanup now */\n\t\tiowarrior_delete(dev);\n\t}\n\n\tdev_info(&interface->dev, \"I/O-Warror #%d now disconnected\\n\",\n\t\t minor - IOWARRIOR_MINOR_BASE);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146192,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static void iowarrior_disconnect(struct usb_interface *interface)\n{\n\tstruct iowarrior *dev;\n\tint minor;\n\n\tdev = usb_get_intfdata(interface);\n\tmutex_lock(&iowarrior_open_disc_lock);\n\tusb_set_intfdata(interface, NULL);\n\n\tminor = dev->minor;\n\tmutex_unlock(&iowarrior_open_disc_lock);\n\t/* give back our minor - this will call close() locks need to be dropped at this point*/\n\n\tusb_deregister_dev(interface, &iowarrior_class);\n\n\tmutex_lock(&dev->mutex);\n\n\t/* prevent device read, write and ioctl */\n\tdev->present = 0;\n\n\tif (dev->opened) {\n\t\t/* There is a process that holds a filedescriptor to the device ,\n\t\t   so we only shutdown read-/write-ops going on.\n\t\t   Deleting the device is postponed until close() was called.\n\t\t */\n\t\tusb_kill_urb(dev->int_in_urb);\n\t\twake_up_interruptible(&dev->read_wait);\n\t\twake_up_interruptible(&dev->write_wait);\n\t\tmutex_unlock(&dev->mutex);\n\t} else {\n\t\t/* no process is using the device, cleanup now */\n\t\tmutex_unlock(&dev->mutex);\n\t\tiowarrior_delete(dev);\n\t}\n\n\tdev_info(&interface->dev, \"I/O-Warror #%d now disconnected\\n\",\n\t\t minor - IOWARRIOR_MINOR_BASE);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146193,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static inline int init_new_context(struct task_struct *tsk,\n\t\t\t\t   struct mm_struct *mm)\n{\n\t#ifdef CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS\n\tif (cpu_feature_enabled(X86_FEATURE_OSPKE)) {\n\t\t/* pkey 0 is the default and always allocated */\n\t\tmm->context.pkey_allocation_map = 0x1;\n\t\t/* -1 means unallocated or invalid */\n\t\tmm->context.execute_only_pkey = -1;\n\t}\n\t#endif\n\tinit_new_context_ldt(tsk, mm);\n\n\treturn 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146206,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static inline int init_new_context(struct task_struct *tsk,\n\t\t\t\t   struct mm_struct *mm)\n{\n\t#ifdef CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS\n\tif (cpu_feature_enabled(X86_FEATURE_OSPKE)) {\n\t\t/* pkey 0 is the default and always allocated */\n\t\tmm->context.pkey_allocation_map = 0x1;\n\t\t/* -1 means unallocated or invalid */\n\t\tmm->context.execute_only_pkey = -1;\n\t}\n\t#endif\n\treturn init_new_context_ldt(tsk, mm);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146207,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "int af_alg_release(struct socket *sock)\n{\n\tif (sock->sk)\n\t\tsock_put(sock->sk);\n\treturn 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146340,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "int af_alg_release(struct socket *sock)\n{\n\tif (sock->sk) {\n\t\tsock_put(sock->sk);\n\t\tsock->sk = NULL;\n\t}\n\treturn 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146341,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int ep_loop_check_proc(void *priv, void *cookie, int call_nests)\n{\n\tint error = 0;\n\tstruct file *file = priv;\n\tstruct eventpoll *ep = file->private_data;\n\tstruct eventpoll *ep_tovisit;\n\tstruct rb_node *rbp;\n\tstruct epitem *epi;\n\n\tmutex_lock_nested(&ep->mtx, call_nests + 1);\n\tep->visited = 1;\n\tlist_add(&ep->visited_list_link, &visited_list);\n\tfor (rbp = rb_first_cached(&ep->rbr); rbp; rbp = rb_next(rbp)) {\n\t\tepi = rb_entry(rbp, struct epitem, rbn);\n\t\tif (unlikely(is_file_epoll(epi->ffd.file))) {\n\t\t\tep_tovisit = epi->ffd.file->private_data;\n\t\t\tif (ep_tovisit->visited)\n\t\t\t\tcontinue;\n\t\t\terror = ep_call_nested(&poll_loop_ncalls,\n\t\t\t\t\tep_loop_check_proc, epi->ffd.file,\n\t\t\t\t\tep_tovisit, current);\n\t\t\tif (error != 0)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\t/*\n\t\t\t * If we've reached a file that is not associated with\n\t\t\t * an ep, then we need to check if the newly added\n\t\t\t * links are going to add too many wakeup paths. We do\n\t\t\t * this by adding it to the tfile_check_list, if it's\n\t\t\t * not already there, and calling reverse_path_check()\n\t\t\t * during ep_insert().\n\t\t\t */\n\t\t\tif (list_empty(&epi->ffd.file->f_tfile_llink)) {\n\t\t\t\tget_file(epi->ffd.file);\n\t\t\t\tlist_add(&epi->ffd.file->f_tfile_llink,\n\t\t\t\t\t &tfile_check_list);\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&ep->mtx);\n\n\treturn error;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146364,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int ep_loop_check_proc(void *priv, void *cookie, int call_nests)\n{\n\tint error = 0;\n\tstruct file *file = priv;\n\tstruct eventpoll *ep = file->private_data;\n\tstruct eventpoll *ep_tovisit;\n\tstruct rb_node *rbp;\n\tstruct epitem *epi;\n\n\tmutex_lock_nested(&ep->mtx, call_nests + 1);\n\tep->visited = 1;\n\tlist_add(&ep->visited_list_link, &visited_list);\n\tfor (rbp = rb_first_cached(&ep->rbr); rbp; rbp = rb_next(rbp)) {\n\t\tepi = rb_entry(rbp, struct epitem, rbn);\n\t\tif (unlikely(is_file_epoll(epi->ffd.file))) {\n\t\t\tep_tovisit = epi->ffd.file->private_data;\n\t\t\tif (ep_tovisit->visited)\n\t\t\t\tcontinue;\n\t\t\terror = ep_call_nested(&poll_loop_ncalls,\n\t\t\t\t\tep_loop_check_proc, epi->ffd.file,\n\t\t\t\t\tep_tovisit, current);\n\t\t\tif (error != 0)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\t/*\n\t\t\t * If we've reached a file that is not associated with\n\t\t\t * an ep, then we need to check if the newly added\n\t\t\t * links are going to add too many wakeup paths. We do\n\t\t\t * this by adding it to the tfile_check_list, if it's\n\t\t\t * not already there, and calling reverse_path_check()\n\t\t\t * during ep_insert().\n\t\t\t */\n\t\t\tif (list_empty(&epi->ffd.file->f_tfile_llink)) {\n\t\t\t\tif (get_file_rcu(epi->ffd.file))\n\t\t\t\t\tlist_add(&epi->ffd.file->f_tfile_llink,\n\t\t\t\t\t\t &tfile_check_list);\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&ep->mtx);\n\n\treturn error;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146365,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "R_API int r_egg_lang_parsechar(REgg *egg, char c) {\n\tREggEmit *e = egg->remit;\n\tchar *ptr, str[64], *tmp_ptr = NULL;\n\tint i, j;\n\tif (c == '\\n') {\n\t\tegg->lang.line++;\n\t\tegg->lang.elem_n = 0;\n\t}\n\t/* comments */\n\tif (egg->lang.skipline) {\n\t\tif (c != '\\n') {\n\t\t\tegg->lang.oc = c;\n\t\t\treturn 0;\n\t\t}\n\t\tegg->lang.skipline = 0;\n\t}\n\tif (egg->lang.mode == DATA) {\n\t\treturn parsedatachar (egg, c);\n\t}\n\tif (egg->lang.mode == INLINE) {\n\t\treturn parseinlinechar (egg, c);\n\t}\n\t/* quotes */\n\tif (egg->lang.quoteline) {\n\t\tif (c != egg->lang.quoteline) {\n\t\t\tif (egg->lang.quotelinevar == 1) {\n\t\t\t\tif (c == '`') {\n\t\t\t\t\tegg->lang.elem[egg->lang.elem_n] = 0;\n\t\t\t\t\tegg->lang.elem_n = 0;\n\t\t\t\t\ttmp_ptr = r_egg_mkvar (egg, str, egg->lang.elem, 0);\n\t\t\t\t\tr_egg_printf (egg, \"%s\", tmp_ptr);\n\t\t\t\t\tfree (tmp_ptr);\n\t\t\t\t\tegg->lang.quotelinevar = 0;\n\t\t\t\t} else {\n\t\t\t\t\tegg->lang.elem[egg->lang.elem_n++] = c;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (c == '`') {\n\t\t\t\t\tegg->lang.elem_n = 0;\n\t\t\t\t\tegg->lang.quotelinevar = 1;\n\t\t\t\t} else {\n\t\t\t\t\tr_egg_printf (egg, \"%c\", c);\n\t\t\t\t}\n\t\t\t}\n\t\t\tegg->lang.oc = c;\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tr_egg_printf (egg, \"\\n\");\n\t\t\tegg->lang.quoteline = 0;\n\t\t}\n\t}\n\n\tif (egg->lang.commentmode) {\n\t\tif (c == '/' && egg->lang.oc == '*') {\n\t\t\tegg->lang.commentmode = 0;\n\t\t}\n\t\tegg->lang.oc = c;\n\t\treturn 0;\n\t} else if (c == '*' && egg->lang.oc == '/') {\n\t\tegg->lang.commentmode = 1;\n\t}\n\tif (egg->lang.slurp) {\n\t\tif (egg->lang.slurp != '\"' && c == egg->lang.slurpin) {\t// only happend when (...(...)...)\n\t\t\texit (eprintf (\n\t\t\t\t\t\"%s:%d Nesting of expressions not yet supported\\n\",\n\t\t\t\t\tegg->lang.file, egg->lang.line));\n\t\t}\n\t\tif (c == egg->lang.slurp && egg->lang.oc != '\\\\') {\t// close egg->lang.slurp\n\t\t\tegg->lang.elem[egg->lang.elem_n] = '\\0';\n\t\t\tif (egg->lang.elem_n > 0) {\n\t\t\t\trcc_element (egg, egg->lang.elem);\n\t\t\t} else {\n\t\t\t\te->frame (egg, 0);\n\t\t\t}\n\t\t\tegg->lang.elem_n = 0;\n\t\t\tegg->lang.slurp = 0;\n\t\t} else {\n\t\t\tegg->lang.elem[egg->lang.elem_n++] = c;\n\t\t}\n\t\tegg->lang.elem[egg->lang.elem_n] = '\\0';\n\t} else {\n\t\tswitch (c) {\n\t\tcase ';':\n\t\t\trcc_next (egg);\n\t\t\tbreak;\n\t\tcase '\"':\n\t\t\tegg->lang.slurp = '\"';\n\t\t\tbreak;\n\t\tcase '(':\n\t\t\tegg->lang.slurpin = '(';\n\t\t\tegg->lang.slurp = ')';\n\t\t\tbreak;\n\t\tcase '{':\n\t\t\tif (CTX > 0) {\n\t\t\t\t// r_egg_printf (egg, \" %s:\\n\", get_frame_label (0));\n\t\t\t\tif (egg->lang.nested_callname[CTX] && strstr (egg->lang.nested_callname[CTX], \"if\") &&\n\t\t\t\t    strstr (egg->lang.elem, \"else\")) {\n\t\t\t\t\t*egg->lang.elem = '\\x00';\n\t\t\t\t\tegg->lang.elem_n = 0;\n\t\t\t\t\tR_FREE (egg->lang.ifelse_table[CTX][egg->lang.nestedi[CTX] - 1])\n\t\t\t\t\tegg->lang.ifelse_table[CTX][egg->lang.nestedi[CTX] - 1] =\n\t\t\t\t\t\tr_str_newf (\"  __end_%d_%d_%d\",\n\t\t\t\t\t\t\tegg->lang.nfunctions, CTX, egg->lang.nestedi[CTX]);\n\t\t\t\t}\n\t\t\t\tr_egg_printf (egg, \"  __begin_%d_%d_%d:\\n\",\n\t\t\t\t\tegg->lang.nfunctions, CTX, egg->lang.nestedi[CTX]);\t// %s:\\n\", get_frame_label (0));\n\t\t\t}\n\t\t\trcc_context (egg, 1);\n\t\t\tbreak;\n\t\tcase '}':\n\t\t\tegg->lang.endframe = egg->lang.nested[CTX];\n\t\t\tif (egg->lang.endframe) {\n\t\t\t\t// XXX: use egg->lang.endframe[context]\n\t\t\t\tr_egg_printf (egg, \"%s\", egg->lang.endframe);\n\t\t\t\tR_FREE (egg->lang.nested[CTX]);\n\t\t\t\t// R_FREE (egg->lang.endframe);\n\t\t\t}\n\t\t\tif (CTX > 1) {\n\t\t\t\tif (egg->lang.nested_callname[CTX - 1] && strstr (egg->lang.nested_callname[CTX - 1], \"if\")) {\n\t\t\t\t\ttmp_ptr = r_str_newf (\"__ifelse_%d_%d\", CTX - 1, egg->lang.nestedi[CTX - 1] - 1);\n\t\t\t\t\te->jmp (egg, tmp_ptr, 0);\n\t\t\t\t\tR_FREE (tmp_ptr);\t// mem leak\n\t\t\t\t\tegg->lang.ifelse_table[CTX - 1][egg->lang.nestedi[CTX - 1] - 1] =\n\t\t\t\t\t\tr_str_newf (\"__end_%d_%d_%d\",\n\t\t\t\t\t\t\tegg->lang.nfunctions, CTX - 1, egg->lang.nestedi[CTX - 1] - 1);\n\t\t\t\t}\n\t\t\t\t// if (nestede[CTX]) {\n\t\t\t\t// r_egg_printf (egg, \"%s:\\n\", nestede[CTX]);\n\t\t\t\t////nestede[CTX] = NULL;\n\t\t\t\t// } else {\n\t\t\t\tr_egg_printf (egg, \"  __end_%d_%d_%d:\\n\",\n\t\t\t\t\tegg->lang.nfunctions, CTX - 1, egg->lang.nestedi[CTX - 1] - 1);\n\t\t\t\t// get_end_frame_label (egg));\n\t\t\t\t// }\n\t\t\t}\n\t\t\tif (CTX > 0) {\n\t\t\t\tegg->lang.nbrackets++;\n\t\t\t}\n\t\t\trcc_context (egg, -1);\n\t\t\tif (CTX == 0) {\n\t\t\t\tr_egg_printf (egg, \"\\n\");\n\t\t\t\t// snprintf(str, 64, \"__end_%d\", egg->lang.nfunctions);\n\t\t\t\t// e->jmp(egg, str, 0);\n\t\t\t\t// edit this unnessary jmp to bypass tests\n\t\t\t\tfor (i = 0; i < 32; i++) {\n\t\t\t\t\tfor (j = 0; j < egg->lang.nestedi[i] && j < 32; j++) {\n\t\t\t\t\t\tif (egg->lang.ifelse_table[i][j]) {\n\t\t\t\t\t\t\tr_egg_printf (egg, \"  __ifelse_%d_%d:\\n\", i, j);\n\t\t\t\t\t\t\te->jmp (egg, egg->lang.ifelse_table[i][j], 0);\n\t\t\t\t\t\t\tR_FREE (egg->lang.ifelse_table[i][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// r_egg_printf(egg, \"  __end_%d:\\n\\n\", egg->lang.nfunctions);\n\t\t\t\t// edit this unnessary jmp to bypass tests\n\t\t\t\tegg->lang.nbrackets = 0;\n\t\t\t\tegg->lang.nfunctions++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ':':\n\t\t\tif (egg->lang.oc == '\\n' || egg->lang.oc == '}') {\n\t\t\t\tegg->lang.quoteline = '\\n';\n\t\t\t} else {\n\t\t\t\tegg->lang.elem[egg->lang.elem_n++] = c;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '#':\n\t\t\tif (egg->lang.oc == '\\n') {\n\t\t\t\tegg->lang.skipline = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '/':\n\t\t\tif (egg->lang.oc == '/') {\n\t\t\t\tegg->lang.skipline = 1;\n\t\t\t} else {\n\t\t\t\tegg->lang.elem[egg->lang.elem_n++] = c;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tegg->lang.elem[egg->lang.elem_n++] = c;\n\t\t}\n\t\tif (egg->lang.slurp) {\n\t\t\tif (egg->lang.elem_n) {\n\t\t\t\tptr = egg->lang.elem;\n\t\t\t\tegg->lang.elem[egg->lang.elem_n] = '\\0';\n\t\t\t\twhile (is_space (*ptr)) {\n\t\t\t\t\tptr++;\n\t\t\t\t}\n\t\t\t\trcc_fun (egg, ptr);\n\t\t\t}\n\t\t\tegg->lang.elem_n = 0;\n\t\t}\n\t}\n\tif (c != '\\t' && c != ' ') {\n\t\tegg->lang.oc = c;\n\t}\n\treturn 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146386,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "R_API int r_egg_lang_parsechar(REgg *egg, char c) {\n\tREggEmit *e = egg->remit;\n\tchar *ptr, str[64], *tmp_ptr = NULL;\n\tint i, j;\n\tif (c == '\\n') {\n\t\tegg->lang.line++;\n\t\tegg->lang.elem_n = 0;\n\t}\n\t/* comments */\n\tif (egg->lang.skipline) {\n\t\tif (c != '\\n') {\n\t\t\tegg->lang.oc = c;\n\t\t\treturn 0;\n\t\t}\n\t\tegg->lang.skipline = 0;\n\t}\n\tif (egg->lang.mode == DATA) {\n\t\treturn parsedatachar (egg, c);\n\t}\n\tif (egg->lang.mode == INLINE) {\n\t\treturn parseinlinechar (egg, c);\n\t}\n\t/* quotes */\n\tif (egg->lang.quoteline) {\n\t\tif (c != egg->lang.quoteline) {\n\t\t\tif (egg->lang.quotelinevar == 1) {\n\t\t\t\tif (c == '`') {\n\t\t\t\t\tegg->lang.elem[egg->lang.elem_n] = 0;\n\t\t\t\t\tegg->lang.elem_n = 0;\n\t\t\t\t\ttmp_ptr = r_egg_mkvar (egg, str, egg->lang.elem, 0);\n\t\t\t\t\tr_egg_printf (egg, \"%s\", tmp_ptr);\n\t\t\t\t\tfree (tmp_ptr);\n\t\t\t\t\tegg->lang.quotelinevar = 0;\n\t\t\t\t} else {\n\t\t\t\t\tegg->lang.elem[egg->lang.elem_n++] = c;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (c == '`') {\n\t\t\t\t\tegg->lang.elem_n = 0;\n\t\t\t\t\tegg->lang.quotelinevar = 1;\n\t\t\t\t} else {\n\t\t\t\t\tr_egg_printf (egg, \"%c\", c);\n\t\t\t\t}\n\t\t\t}\n\t\t\tegg->lang.oc = c;\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tr_egg_printf (egg, \"\\n\");\n\t\t\tegg->lang.quoteline = 0;\n\t\t}\n\t}\n\n\tif (egg->lang.commentmode) {\n\t\tif (c == '/' && egg->lang.oc == '*') {\n\t\t\tegg->lang.commentmode = 0;\n\t\t}\n\t\tegg->lang.oc = c;\n\t\treturn 0;\n\t} else if (c == '*' && egg->lang.oc == '/') {\n\t\tegg->lang.commentmode = 1;\n\t}\n\tif (egg->lang.slurp) {\n\t\tif (egg->lang.slurp != '\"' && c == egg->lang.slurpin) {\t// only happend when (...(...)...)\n\t\t\texit (eprintf (\n\t\t\t\t\t\"%s:%d Nesting of expressions not yet supported\\n\",\n\t\t\t\t\tegg->lang.file, egg->lang.line));\n\t\t}\n\t\tif (c == egg->lang.slurp && egg->lang.oc != '\\\\') {\t// close egg->lang.slurp\n\t\t\tegg->lang.elem[egg->lang.elem_n] = '\\0';\n\t\t\tif (egg->lang.elem_n > 0) {\n\t\t\t\trcc_element (egg, egg->lang.elem);\n\t\t\t} else {\n\t\t\t\te->frame (egg, 0);\n\t\t\t}\n\t\t\tegg->lang.elem_n = 0;\n\t\t\tegg->lang.slurp = 0;\n\t\t} else {\n\t\t\tegg->lang.elem[egg->lang.elem_n++] = c;\n\t\t}\n\t\tegg->lang.elem[egg->lang.elem_n] = '\\0';\n\t} else {\n\t\tswitch (c) {\n\t\tcase ';':\n\t\t\trcc_next (egg);\n\t\t\tbreak;\n\t\tcase '\"':\n\t\t\tegg->lang.slurp = '\"';\n\t\t\tbreak;\n\t\tcase '(':\n\t\t\tegg->lang.slurpin = '(';\n\t\t\tegg->lang.slurp = ')';\n\t\t\tbreak;\n\t\tcase '{':\n\t\t\tif (CTX > 0) {\n\t\t\t\tif (CTX > 31 || CTX < 0) {\n\t\t\t\t\teprintf (\"Sinking before overflow\\n\");\n\t\t\t\t\tCTX = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// r_egg_printf (egg, \" %s:\\n\", get_frame_label (0));\n\t\t\t\tif (egg->lang.nested_callname[CTX] && strstr (egg->lang.nested_callname[CTX], \"if\") &&\n\t\t\t\t    strstr (egg->lang.elem, \"else\")) {\n\t\t\t\t\t*egg->lang.elem = '\\x00';\n\t\t\t\t\tegg->lang.elem_n = 0;\n\t\t\t\t\tR_FREE (egg->lang.ifelse_table[CTX][egg->lang.nestedi[CTX] - 1])\n\t\t\t\t\tegg->lang.ifelse_table[CTX][egg->lang.nestedi[CTX] - 1] =\n\t\t\t\t\t\tr_str_newf (\"  __end_%d_%d_%d\",\n\t\t\t\t\t\t\tegg->lang.nfunctions, CTX, egg->lang.nestedi[CTX]);\n\t\t\t\t}\n\t\t\t\tr_egg_printf (egg, \"  __begin_%d_%d_%d:\\n\",\n\t\t\t\t\tegg->lang.nfunctions, CTX, egg->lang.nestedi[CTX]);\t// %s:\\n\", get_frame_label (0));\n\t\t\t}\n\t\t\trcc_context (egg, 1);\n\t\t\tbreak;\n\t\tcase '}':\n\t\t\tegg->lang.endframe = egg->lang.nested[CTX];\n\t\t\tif (egg->lang.endframe) {\n\t\t\t\t// XXX: use egg->lang.endframe[context]\n\t\t\t\tr_egg_printf (egg, \"%s\", egg->lang.endframe);\n\t\t\t\tR_FREE (egg->lang.nested[CTX]);\n\t\t\t\t// R_FREE (egg->lang.endframe);\n\t\t\t}\n\t\t\tif (CTX > 1) {\n\t\t\t\tif (egg->lang.nested_callname[CTX - 1] && strstr (egg->lang.nested_callname[CTX - 1], \"if\")) {\n\t\t\t\t\ttmp_ptr = r_str_newf (\"__ifelse_%d_%d\", CTX - 1, egg->lang.nestedi[CTX - 1] - 1);\n\t\t\t\t\te->jmp (egg, tmp_ptr, 0);\n\t\t\t\t\tR_FREE (tmp_ptr);\t// mem leak\n\t\t\t\t\tegg->lang.ifelse_table[CTX - 1][egg->lang.nestedi[CTX - 1] - 1] =\n\t\t\t\t\t\tr_str_newf (\"__end_%d_%d_%d\",\n\t\t\t\t\t\t\tegg->lang.nfunctions, CTX - 1, egg->lang.nestedi[CTX - 1] - 1);\n\t\t\t\t}\n\t\t\t\t// if (nestede[CTX]) {\n\t\t\t\t// r_egg_printf (egg, \"%s:\\n\", nestede[CTX]);\n\t\t\t\t////nestede[CTX] = NULL;\n\t\t\t\t// } else {\n\t\t\t\tr_egg_printf (egg, \"  __end_%d_%d_%d:\\n\",\n\t\t\t\t\tegg->lang.nfunctions, CTX - 1, egg->lang.nestedi[CTX - 1] - 1);\n\t\t\t\t// get_end_frame_label (egg));\n\t\t\t\t// }\n\t\t\t}\n\t\t\tif (CTX > 0) {\n\t\t\t\tegg->lang.nbrackets++;\n\t\t\t}\n\t\t\trcc_context (egg, -1);\n\t\t\tif (CTX == 0) {\n\t\t\t\tr_egg_printf (egg, \"\\n\");\n\t\t\t\t// snprintf(str, 64, \"__end_%d\", egg->lang.nfunctions);\n\t\t\t\t// e->jmp(egg, str, 0);\n\t\t\t\t// edit this unnessary jmp to bypass tests\n\t\t\t\tfor (i = 0; i < 32; i++) {\n\t\t\t\t\tfor (j = 0; j < egg->lang.nestedi[i] && j < 32; j++) {\n\t\t\t\t\t\tif (egg->lang.ifelse_table[i][j]) {\n\t\t\t\t\t\t\tr_egg_printf (egg, \"  __ifelse_%d_%d:\\n\", i, j);\n\t\t\t\t\t\t\te->jmp (egg, egg->lang.ifelse_table[i][j], 0);\n\t\t\t\t\t\t\tR_FREE (egg->lang.ifelse_table[i][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// r_egg_printf(egg, \"  __end_%d:\\n\\n\", egg->lang.nfunctions);\n\t\t\t\t// edit this unnessary jmp to bypass tests\n\t\t\t\tegg->lang.nbrackets = 0;\n\t\t\t\tegg->lang.nfunctions++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ':':\n\t\t\tif (egg->lang.oc == '\\n' || egg->lang.oc == '}') {\n\t\t\t\tegg->lang.quoteline = '\\n';\n\t\t\t} else {\n\t\t\t\tegg->lang.elem[egg->lang.elem_n++] = c;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '#':\n\t\t\tif (egg->lang.oc == '\\n') {\n\t\t\t\tegg->lang.skipline = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '/':\n\t\t\tif (egg->lang.oc == '/') {\n\t\t\t\tegg->lang.skipline = 1;\n\t\t\t} else {\n\t\t\t\tegg->lang.elem[egg->lang.elem_n++] = c;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tegg->lang.elem[egg->lang.elem_n++] = c;\n\t\t}\n\t\tif (egg->lang.slurp) {\n\t\t\tif (egg->lang.elem_n) {\n\t\t\t\tptr = egg->lang.elem;\n\t\t\t\tegg->lang.elem[egg->lang.elem_n] = '\\0';\n\t\t\t\twhile (is_space (*ptr)) {\n\t\t\t\t\tptr++;\n\t\t\t\t}\n\t\t\t\trcc_fun (egg, ptr);\n\t\t\t}\n\t\t\tegg->lang.elem_n = 0;\n\t\t}\n\t}\n\tif (c != '\\t' && c != ' ') {\n\t\tegg->lang.oc = c;\n\t}\n\treturn 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146387,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static Image *ReadOneMNGImage(MngInfo* mng_info, const ImageInfo *image_info,\n     ExceptionInfo *exception)\n{\n  char\n    page_geometry[MagickPathExtent];\n\n  Image\n    *image;\n\n  MagickBooleanType\n    logging;\n\n  volatile int\n    first_mng_object,\n    object_id,\n    term_chunk_found,\n    skip_to_iend;\n\n  volatile ssize_t\n    image_count=0;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  MngBox\n    default_fb,\n    fb,\n    previous_fb;\n\n#if defined(MNG_INSERT_LAYERS)\n  PixelInfo\n    mng_background_color;\n#endif\n\n  register unsigned char\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    count;\n\n  ssize_t\n    loop_level;\n\n  volatile short\n    skipping_loop;\n\n#if defined(MNG_INSERT_LAYERS)\n  unsigned int\n    mandatory_back=0;\n#endif\n\n  volatile unsigned int\n#ifdef MNG_OBJECT_BUFFERS\n    mng_background_object=0,\n#endif\n    mng_type=0;   /* 0: PNG or JNG; 1: MNG; 2: MNG-LC; 3: MNG-VLC */\n\n  size_t\n    default_frame_timeout,\n    frame_timeout,\n#if defined(MNG_INSERT_LAYERS)\n    image_height,\n    image_width,\n#endif\n    length;\n\n  /* These delays are all measured in image ticks_per_second,\n   * not in MNG ticks_per_second\n   */\n  volatile size_t\n    default_frame_delay,\n    final_delay,\n    final_image_delay,\n    frame_delay,\n#if defined(MNG_INSERT_LAYERS)\n    insert_layers,\n#endif\n    mng_iterations=1,\n    simplicity=0,\n    subframe_height=0,\n    subframe_width=0;\n\n  previous_fb.top=0;\n  previous_fb.bottom=0;\n  previous_fb.left=0;\n  previous_fb.right=0;\n  default_fb.top=0;\n  default_fb.bottom=0;\n  default_fb.left=0;\n  default_fb.right=0;\n\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  Enter ReadOneMNGImage()\");\n\n  image=mng_info->image;\n\n  if (LocaleCompare(image_info->magick,\"MNG\") == 0)\n    {\n      char\n        magic_number[MagickPathExtent];\n\n      /* Verify MNG signature.  */\n      count=(size_t) ReadBlob(image,8,(unsigned char *) magic_number);\n      if ((count < 8) || (memcmp(magic_number,\"\\212MNG\\r\\n\\032\\n\",8) != 0))\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n      /* Initialize some nonzero members of the MngInfo structure.  */\n      for (i=0; i < MNG_MAX_OBJECTS; i++)\n      {\n        mng_info->object_clip[i].right=(ssize_t) PNG_UINT_31_MAX;\n        mng_info->object_clip[i].bottom=(ssize_t) PNG_UINT_31_MAX;\n      }\n      mng_info->exists[0]=MagickTrue;\n    }\n\n  skipping_loop=(-1);\n  first_mng_object=MagickTrue;\n  mng_type=0;\n#if defined(MNG_INSERT_LAYERS)\n  insert_layers=MagickFalse; /* should be False during convert or mogrify */\n#endif\n  default_frame_delay=0;\n  default_frame_timeout=0;\n  frame_delay=0;\n  final_delay=1;\n  mng_info->ticks_per_second=1UL*image->ticks_per_second;\n  object_id=0;\n  skip_to_iend=MagickFalse;\n  term_chunk_found=MagickFalse;\n  mng_info->framing_mode=1;\n#if defined(MNG_INSERT_LAYERS)\n  mandatory_back=MagickFalse;\n#endif\n#if defined(MNG_INSERT_LAYERS)\n  mng_background_color=image->background_color;\n#endif\n  default_fb=mng_info->frame;\n  previous_fb=mng_info->frame;\n  do\n  {\n    char\n      type[MagickPathExtent];\n\n    if (LocaleCompare(image_info->magick,\"MNG\") == 0)\n      {\n        unsigned char\n          *chunk;\n\n        /*\n          Read a new chunk.\n        */\n        type[0]='\\0';\n        (void) ConcatenateMagickString(type,\"errr\",MagickPathExtent);\n        length=(size_t) ReadBlobMSBLong(image);\n        count=(size_t) ReadBlob(image,4,(unsigned char *) type);\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n           \"  Reading MNG chunk type %c%c%c%c, length: %.20g\",\n           type[0],type[1],type[2],type[3],(double) length);\n\n        if ((length > PNG_UINT_31_MAX) || (length > GetBlobSize(image)) ||\n            (count < 4))\n          ThrowReaderException(CorruptImageError,\"CorruptImage\");\n\n        p=NULL;\n        chunk=(unsigned char *) NULL;\n\n        if (length != 0)\n          {\n            chunk=(unsigned char *) AcquireQuantumMemory(length,sizeof(*chunk));\n\n            if (chunk == (unsigned char *) NULL)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n            for (i=0; i < (ssize_t) length; i++)\n            {\n              int\n                c;\n\n              c=ReadBlobByte(image);\n              if (c == EOF)\n                {\n                  chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n                  ThrowReaderException(CorruptImageError,\n                    \"InsufficientImageDataInFile\");\n                }\n              chunk[i]=(unsigned char) c;\n            }\n\n            p=chunk;\n          }\n\n        (void) ReadBlobMSBLong(image);  /* read crc word */\n\n#if !defined(JNG_SUPPORTED)\n        if (memcmp(type,mng_JHDR,4) == 0)\n          {\n            skip_to_iend=MagickTrue;\n\n            if (mng_info->jhdr_warning == 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CoderError,\"JNGCompressNotSupported\",\"`%s'\",image->filename);\n\n            mng_info->jhdr_warning++;\n          }\n#endif\n        if (memcmp(type,mng_DHDR,4) == 0)\n          {\n            skip_to_iend=MagickTrue;\n\n            if (mng_info->dhdr_warning == 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CoderError,\"DeltaPNGNotSupported\",\"`%s'\",image->filename);\n\n            mng_info->dhdr_warning++;\n          }\n        if (memcmp(type,mng_MEND,4) == 0)\n          {\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            break;\n          }\n\n        if (skip_to_iend)\n          {\n            if (memcmp(type,mng_IEND,4) == 0)\n              skip_to_iend=MagickFalse;\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Skip to IEND.\");\n\n            continue;\n          }\n\n        if (memcmp(type,mng_MHDR,4) == 0)\n          {\n            if (length != 28)\n              {\n                chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n                ThrowReaderException(CorruptImageError,\"CorruptImage\");\n              }\n\n            mng_info->mng_width=(unsigned long)mng_get_long(p);\n            mng_info->mng_height=(unsigned long)mng_get_long(&p[4]);\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  MNG width: %.20g\",(double) mng_info->mng_width);\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  MNG height: %.20g\",(double) mng_info->mng_height);\n              }\n\n            p+=8;\n            mng_info->ticks_per_second=(size_t) mng_get_long(p);\n\n            if (mng_info->ticks_per_second == 0)\n              default_frame_delay=0;\n\n            else\n              default_frame_delay=1UL*image->ticks_per_second/\n                mng_info->ticks_per_second;\n\n            frame_delay=default_frame_delay;\n            simplicity=0;\n\n            p+=16;\n            simplicity=(size_t) mng_get_long(p);\n\n            mng_type=1;    /* Full MNG */\n\n            if ((simplicity != 0) && ((simplicity | 11) == 11))\n              mng_type=2; /* LC */\n\n            if ((simplicity != 0) && ((simplicity | 9) == 9))\n              mng_type=3; /* VLC */\n\n#if defined(MNG_INSERT_LAYERS)\n            if (mng_type != 3)\n              insert_layers=MagickTrue;\n#endif\n            if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n              {\n                /* Allocate next image structure.  */\n                AcquireNextImage(image_info,image,exception);\n\n                if (GetNextImageInList(image) == (Image *) NULL)\n                  return((Image *) NULL);\n\n                image=SyncNextImageInList(image);\n                mng_info->image=image;\n              }\n\n            if ((mng_info->mng_width > 65535L) ||\n                (mng_info->mng_height > 65535L))\n              {\n                chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n                ThrowReaderException(ImageError,\"WidthOrHeightExceedsLimit\");\n              }\n\n            (void) FormatLocaleString(page_geometry,MagickPathExtent,\n              \"%.20gx%.20g+0+0\",(double) mng_info->mng_width,(double)\n              mng_info->mng_height);\n\n            mng_info->frame.left=0;\n            mng_info->frame.right=(ssize_t) mng_info->mng_width;\n            mng_info->frame.top=0;\n            mng_info->frame.bottom=(ssize_t) mng_info->mng_height;\n            mng_info->clip=default_fb=previous_fb=mng_info->frame;\n\n            for (i=0; i < MNG_MAX_OBJECTS; i++)\n              mng_info->object_clip[i]=mng_info->frame;\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_TERM,4) == 0)\n          {\n            int\n              repeat=0;\n\n            if (length != 0)\n              repeat=p[0];\n\n            if (repeat == 3 && length > 9)\n              {\n                final_delay=(png_uint_32) mng_get_long(&p[2]);\n                mng_iterations=(png_uint_32) mng_get_long(&p[6]);\n\n                if (mng_iterations == PNG_UINT_31_MAX)\n                  mng_iterations=0;\n\n                image->iterations=mng_iterations;\n                term_chunk_found=MagickTrue;\n              }\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    repeat=%d,  final_delay=%.20g,  iterations=%.20g\",\n                  repeat,(double) final_delay, (double) image->iterations);\n              }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n        if (memcmp(type,mng_DEFI,4) == 0)\n          {\n            if (mng_type == 3)\n              {\n                (void) ThrowMagickException(exception,GetMagickModule(),\n                  CoderError,\"DEFI chunk found in MNG-VLC datastream\",\"`%s'\",\n                  image->filename);\n                chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n                continue;\n              }\n\n            if (length < 2)\n              {\n                chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n                ThrowReaderException(CorruptImageError,\"CorruptImage\");\n              }\n\n            object_id=((unsigned int) p[0] << 8) | (unsigned int) p[1];\n\n            if (mng_type == 2 && object_id != 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CoderError,\"Nonzero object_id in MNG-LC datastream\",\"`%s'\",\n                image->filename);\n\n            if (object_id >= MNG_MAX_OBJECTS)\n              {\n                /*\n                  Instead of using a warning we should allocate a larger\n                  MngInfo structure and continue.\n                */\n                (void) ThrowMagickException(exception,GetMagickModule(),\n                  CoderError,\"object id too large\",\"`%s'\",image->filename);\n                object_id=MNG_MAX_OBJECTS-1;\n              }\n\n            if (mng_info->exists[object_id])\n              if (mng_info->frozen[object_id])\n                {\n                  chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n                  (void) ThrowMagickException(exception,\n                    GetMagickModule(),CoderError,\n                    \"DEFI cannot redefine a frozen MNG object\",\"`%s'\",\n                    image->filename);\n                  continue;\n                }\n\n            mng_info->exists[object_id]=MagickTrue;\n\n            if (length > 2)\n              mng_info->invisible[object_id]=p[2];\n\n            /*\n              Extract object offset info.\n            */\n            if (length > 11)\n              {\n                mng_info->x_off[object_id]=(ssize_t) mng_get_long(&p[4]);\n                mng_info->y_off[object_id]=(ssize_t) mng_get_long(&p[8]);\n                if (logging != MagickFalse)\n                  {\n                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                      \"  x_off[%d]: %.20g,  y_off[%d]: %.20g\",\n                      object_id,(double) mng_info->x_off[object_id],\n                      object_id,(double) mng_info->y_off[object_id]);\n                  }\n              }\n\n            /*\n              Extract object clipping info.\n            */\n            if (length > 27)\n              mng_info->object_clip[object_id]=mng_read_box(mng_info->frame,0,\n                &p[12]);\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n        if (memcmp(type,mng_bKGD,4) == 0)\n          {\n            mng_info->have_global_bkgd=MagickFalse;\n\n            if (length > 5)\n              {\n                mng_info->mng_global_bkgd.red=\n                  ScaleShortToQuantum((unsigned short) ((p[0] << 8) | p[1]));\n\n                mng_info->mng_global_bkgd.green=\n                  ScaleShortToQuantum((unsigned short) ((p[2] << 8) | p[3]));\n\n                mng_info->mng_global_bkgd.blue=\n                  ScaleShortToQuantum((unsigned short) ((p[4] << 8) | p[5]));\n\n                mng_info->have_global_bkgd=MagickTrue;\n              }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n        if (memcmp(type,mng_BACK,4) == 0)\n          {\n#if defined(MNG_INSERT_LAYERS)\n            if (length > 6)\n              mandatory_back=p[6];\n\n            else\n              mandatory_back=0;\n\n            if (mandatory_back && length > 5)\n              {\n                mng_background_color.red=\n                    ScaleShortToQuantum((unsigned short) ((p[0] << 8) | p[1]));\n\n                mng_background_color.green=\n                    ScaleShortToQuantum((unsigned short) ((p[2] << 8) | p[3]));\n\n                mng_background_color.blue=\n                    ScaleShortToQuantum((unsigned short) ((p[4] << 8) | p[5]));\n\n                mng_background_color.alpha=OpaqueAlpha;\n              }\n\n#ifdef MNG_OBJECT_BUFFERS\n            if (length > 8)\n              mng_background_object=(p[7] << 8) | p[8];\n#endif\n#endif\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_PLTE,4) == 0)\n          {\n            /* Read global PLTE.  */\n\n            if (length && (length < 769))\n              {\n                /* Read global PLTE.  */\n\n                if (mng_info->global_plte == (png_colorp) NULL)\n                  mng_info->global_plte=(png_colorp) AcquireQuantumMemory(256,\n                    sizeof(*mng_info->global_plte));\n\n                if (mng_info->global_plte == (png_colorp) NULL)\n                  {\n                    mng_info->global_plte_length=0;\n                    chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n                    ThrowReaderException(ResourceLimitError,\n                      \"MemoryAllocationFailed\");\n                  }\n\n                for (i=0; i < (ssize_t) (length/3); i++)\n                {\n                  mng_info->global_plte[i].red=p[3*i];\n                  mng_info->global_plte[i].green=p[3*i+1];\n                  mng_info->global_plte[i].blue=p[3*i+2];\n                }\n\n                mng_info->global_plte_length=(unsigned int) (length/3);\n              }\n#ifdef MNG_LOOSE\n            for ( ; i < 256; i++)\n            {\n              mng_info->global_plte[i].red=i;\n              mng_info->global_plte[i].green=i;\n              mng_info->global_plte[i].blue=i;\n            }\n\n            if (length != 0)\n              mng_info->global_plte_length=256;\n#endif\n            else\n              mng_info->global_plte_length=0;\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_tRNS,4) == 0)\n          {\n            /* read global tRNS */\n\n            if (length > 0 && length < 257)\n              for (i=0; i < (ssize_t) length; i++)\n                mng_info->global_trns[i]=p[i];\n\n#ifdef MNG_LOOSE\n            for ( ; i < 256; i++)\n              mng_info->global_trns[i]=255;\n#endif\n            mng_info->global_trns_length=(unsigned int) length;\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n        if (memcmp(type,mng_gAMA,4) == 0)\n          {\n            if (length == 4)\n              {\n                ssize_t\n                  igamma;\n\n                igamma=mng_get_long(p);\n                mng_info->global_gamma=((float) igamma)*0.00001;\n                mng_info->have_global_gama=MagickTrue;\n              }\n\n            else\n              mng_info->have_global_gama=MagickFalse;\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_cHRM,4) == 0)\n          {\n            /* Read global cHRM */\n\n            if (length == 32)\n              {\n                mng_info->global_chrm.white_point.x=0.00001*mng_get_long(p);\n                mng_info->global_chrm.white_point.y=0.00001*mng_get_long(&p[4]);\n                mng_info->global_chrm.red_primary.x=0.00001*mng_get_long(&p[8]);\n                mng_info->global_chrm.red_primary.y=0.00001*\n                  mng_get_long(&p[12]);\n                mng_info->global_chrm.green_primary.x=0.00001*\n                  mng_get_long(&p[16]);\n                mng_info->global_chrm.green_primary.y=0.00001*\n                  mng_get_long(&p[20]);\n                mng_info->global_chrm.blue_primary.x=0.00001*\n                  mng_get_long(&p[24]);\n                mng_info->global_chrm.blue_primary.y=0.00001*\n                  mng_get_long(&p[28]);\n                mng_info->have_global_chrm=MagickTrue;\n              }\n            else\n              mng_info->have_global_chrm=MagickFalse;\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_sRGB,4) == 0)\n          {\n            /*\n              Read global sRGB.\n            */\n            if (length != 0)\n              {\n                mng_info->global_srgb_intent=\n                  Magick_RenderingIntent_from_PNG_RenderingIntent(p[0]);\n                mng_info->have_global_srgb=MagickTrue;\n              }\n            else\n              mng_info->have_global_srgb=MagickFalse;\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_iCCP,4) == 0)\n          {\n            /* To do: */\n\n            /*\n              Read global iCCP.\n            */\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n            continue;\n          }\n\n        if (memcmp(type,mng_FRAM,4) == 0)\n          {\n            if (mng_type == 3)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CoderError,\"FRAM chunk found in MNG-VLC datastream\",\"`%s'\",\n                image->filename);\n\n            if ((mng_info->framing_mode == 2) || (mng_info->framing_mode == 4))\n              image->delay=frame_delay;\n\n            frame_delay=default_frame_delay;\n            frame_timeout=default_frame_timeout;\n            fb=default_fb;\n\n            if (length != 0)\n              if (p[0])\n                mng_info->framing_mode=p[0];\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Framing_mode=%d\",mng_info->framing_mode);\n\n            if (length > 6)\n              {\n                /* Note the delay and frame clipping boundaries.  */\n\n                p++; /* framing mode */\n\n                while (((p-chunk) < (long) length) && *p)\n                  p++;  /* frame name */\n\n                p++;  /* frame name terminator */\n\n                if ((p-chunk) < (ssize_t) (length-4))\n                  {\n                    int\n                      change_delay,\n                      change_timeout,\n                      change_clipping;\n\n                    change_delay=(*p++);\n                    change_timeout=(*p++);\n                    change_clipping=(*p++);\n                    p++; /* change_sync */\n\n                    if (change_delay && ((p-chunk) < (ssize_t) (length-4)))\n                      {\n                        frame_delay=1UL*image->ticks_per_second*\n                          mng_get_long(p);\n\n                        if (mng_info->ticks_per_second != 0)\n                          frame_delay/=mng_info->ticks_per_second;\n\n                        else\n                          frame_delay=PNG_UINT_31_MAX;\n\n                        if (change_delay == 2)\n                          default_frame_delay=frame_delay;\n\n                        p+=4;\n\n                        if (logging != MagickFalse)\n                          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                            \"    Framing_delay=%.20g\",(double) frame_delay);\n                      }\n\n                    if (change_timeout && ((p-chunk) < (ssize_t) (length-4)))\n                      {\n                        frame_timeout=1UL*image->ticks_per_second*\n                          mng_get_long(p);\n\n                        if (mng_info->ticks_per_second != 0)\n                          frame_timeout/=mng_info->ticks_per_second;\n\n                        else\n                          frame_timeout=PNG_UINT_31_MAX;\n\n                        if (change_timeout == 2)\n                          default_frame_timeout=frame_timeout;\n\n                        p+=4;\n\n                        if (logging != MagickFalse)\n                          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                            \"    Framing_timeout=%.20g\",(double) frame_timeout);\n                      }\n\n                    if (change_clipping && ((p-chunk) < (ssize_t) (length-16)))\n                      {\n                        fb=mng_read_box(previous_fb,(char) p[0],&p[1]);\n                        p+=16;\n                        previous_fb=fb;\n\n                        if (logging != MagickFalse)\n                          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                            \"    Frame_clip: L=%.20g R=%.20g T=%.20g B=%.20g\",\n                            (double) fb.left,(double) fb.right,(double) fb.top,\n                            (double) fb.bottom);\n\n                        if (change_clipping == 2)\n                          default_fb=fb;\n                      }\n                  }\n              }\n            mng_info->clip=fb;\n            mng_info->clip=mng_minimum_box(fb,mng_info->frame);\n\n            subframe_width=(size_t) (mng_info->clip.right\n               -mng_info->clip.left);\n\n            subframe_height=(size_t) (mng_info->clip.bottom\n               -mng_info->clip.top);\n            /*\n              Insert a background layer behind the frame if framing_mode is 4.\n            */\n#if defined(MNG_INSERT_LAYERS)\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"   subframe_width=%.20g, subframe_height=%.20g\",(double)\n                subframe_width,(double) subframe_height);\n\n            if (insert_layers && (mng_info->framing_mode == 4) &&\n                (subframe_width) && (subframe_height))\n              {\n                /* Allocate next image structure.  */\n                if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n                  {\n                    AcquireNextImage(image_info,image,exception);\n\n                    if (GetNextImageInList(image) == (Image *) NULL)\n                      return(DestroyImageList(image));\n\n                    image=SyncNextImageInList(image);\n                  }\n\n                mng_info->image=image;\n\n                if (term_chunk_found)\n                  {\n                    image->start_loop=MagickTrue;\n                    image->iterations=mng_iterations;\n                    term_chunk_found=MagickFalse;\n                  }\n\n                else\n                    image->start_loop=MagickFalse;\n\n                image->columns=subframe_width;\n                image->rows=subframe_height;\n                image->page.width=subframe_width;\n                image->page.height=subframe_height;\n                image->page.x=mng_info->clip.left;\n                image->page.y=mng_info->clip.top;\n                image->background_color=mng_background_color;\n                image->alpha_trait=UndefinedPixelTrait;\n                image->delay=0;\n                if (SetImageBackgroundColor(image,exception) == MagickFalse)\n                  {\n                    chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n                    return(DestroyImageList(image));\n                  }\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  Insert backgd layer, L=%.20g, R=%.20g T=%.20g, B=%.20g\",\n                    (double) mng_info->clip.left,\n                    (double) mng_info->clip.right,\n                    (double) mng_info->clip.top,\n                    (double) mng_info->clip.bottom);\n              }\n#endif\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_CLIP,4) == 0)\n          {\n            unsigned int\n              first_object,\n              last_object;\n\n            /*\n              Read CLIP.\n            */\n            if (length > 3)\n              {\n                first_object=(p[0] << 8) | p[1];\n                last_object=(p[2] << 8) | p[3];\n                p+=4;\n\n                for (i=(int) first_object; i <= (int) last_object; i++)\n                {\n                  if ((i < 0) || (i >= MNG_MAX_OBJECTS))\n                    continue;\n\n                  if (mng_info->exists[i] && !mng_info->frozen[i])\n                    {\n                      MngBox\n                        box;\n\n                      box=mng_info->object_clip[i];\n                      if ((p-chunk) < (ssize_t) (length-17))\n                        mng_info->object_clip[i]=\n                           mng_read_box(box,(char) p[0],&p[1]);\n                    }\n                }\n\n              }\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_SAVE,4) == 0)\n          {\n            for (i=1; i < MNG_MAX_OBJECTS; i++)\n              if (mng_info->exists[i])\n                {\n                 mng_info->frozen[i]=MagickTrue;\n#ifdef MNG_OBJECT_BUFFERS\n                 if (mng_info->ob[i] != (MngBuffer *) NULL)\n                    mng_info->ob[i]->frozen=MagickTrue;\n#endif\n                }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n            continue;\n          }\n\n        if ((memcmp(type,mng_DISC,4) == 0) || (memcmp(type,mng_SEEK,4) == 0))\n          {\n            /* Read DISC or SEEK.  */\n\n            if ((length == 0) || (length % 2) || !memcmp(type,mng_SEEK,4))\n              {\n                for (i=1; i < MNG_MAX_OBJECTS; i++)\n                  MngInfoDiscardObject(mng_info,i);\n              }\n\n            else\n              {\n                register ssize_t\n                  j;\n\n                for (j=1; j < (ssize_t) length; j+=2)\n                {\n                  i=p[j-1] << 8 | p[j];\n                  MngInfoDiscardObject(mng_info,i);\n                }\n              }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n            continue;\n          }\n\n        if (memcmp(type,mng_MOVE,4) == 0)\n          {\n            size_t\n              first_object,\n              last_object;\n\n            /* read MOVE */\n\n            if (length > 3)\n            {\n              first_object=(p[0] << 8) | p[1];\n              last_object=(p[2] << 8) | p[3];\n              p+=4;\n\n              for (i=(ssize_t) first_object; i <= (ssize_t) last_object; i++)\n              {\n                if ((i < 0) || (i >= MNG_MAX_OBJECTS))\n                  continue;\n\n                if (mng_info->exists[i] && !mng_info->frozen[i] &&\n                    (p-chunk) < (ssize_t) (length-8))\n                  {\n                    MngPair\n                      new_pair;\n\n                    MngPair\n                      old_pair;\n\n                    old_pair.a=mng_info->x_off[i];\n                    old_pair.b=mng_info->y_off[i];\n                    new_pair=mng_read_pair(old_pair,(int) p[0],&p[1]);\n                    mng_info->x_off[i]=new_pair.a;\n                    mng_info->y_off[i]=new_pair.b;\n                  }\n              }\n            }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_LOOP,4) == 0)\n          {\n            ssize_t loop_iters=1;\n            if (length > 4)\n              {\n                loop_level=chunk[0];\n                mng_info->loop_active[loop_level]=1;  /* mark loop active */\n\n                /* Record starting point.  */\n                loop_iters=mng_get_long(&chunk[1]);\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  LOOP level %.20g has %.20g iterations \",\n                    (double) loop_level, (double) loop_iters);\n\n                if (loop_iters <= 0)\n                  skipping_loop=loop_level;\n\n                else\n                  {\n                    if ((MagickSizeType) loop_iters > GetMagickResourceLimit(ListLengthResource))\n                      loop_iters=GetMagickResourceLimit(ListLengthResource);\n                    if (loop_iters >= 2147483647L)\n                      loop_iters=2147483647L;\n                    mng_info->loop_jump[loop_level]=TellBlob(image);\n                    mng_info->loop_count[loop_level]=loop_iters;\n                  }\n\n                mng_info->loop_iteration[loop_level]=0;\n              }\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_ENDL,4) == 0)\n          {\n            if (length > 0)\n              {\n                loop_level=chunk[0];\n\n                if (skipping_loop > 0)\n                  {\n                    if (skipping_loop == loop_level)\n                      {\n                        /*\n                          Found end of zero-iteration loop.\n                        */\n                        skipping_loop=(-1);\n                        mng_info->loop_active[loop_level]=0;\n                      }\n                  }\n\n                else\n                  {\n                    if (mng_info->loop_active[loop_level] == 1)\n                      {\n                        mng_info->loop_count[loop_level]--;\n                        mng_info->loop_iteration[loop_level]++;\n\n                        if (logging != MagickFalse)\n                          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                          \"  ENDL: LOOP level %.20g has %.20g remaining iters\",\n                            (double) loop_level,(double)\n                            mng_info->loop_count[loop_level]);\n\n                        if (mng_info->loop_count[loop_level] > 0)\n                          {\n                            offset=\n                              SeekBlob(image,mng_info->loop_jump[loop_level],\n                              SEEK_SET);\n\n                            if (offset < 0)\n                              {\n                                chunk=(unsigned char *) RelinquishMagickMemory(\n                                  chunk);\n                                ThrowReaderException(CorruptImageError,\n                                  \"ImproperImageHeader\");\n                              }\n                          }\n\n                        else\n                          {\n                            short\n                              last_level;\n\n                            /*\n                              Finished loop.\n                            */\n                            mng_info->loop_active[loop_level]=0;\n                            last_level=(-1);\n                            for (i=0; i < loop_level; i++)\n                              if (mng_info->loop_active[i] == 1)\n                                last_level=(short) i;\n                            loop_level=last_level;\n                          }\n                      }\n                  }\n              }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_CLON,4) == 0)\n          {\n            if (mng_info->clon_warning == 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CoderError,\"CLON is not implemented yet\",\"`%s'\",\n                image->filename);\n\n            mng_info->clon_warning++;\n          }\n\n        if (memcmp(type,mng_MAGN,4) == 0)\n          {\n            png_uint_16\n              magn_first,\n              magn_last,\n              magn_mb,\n              magn_ml,\n              magn_mr,\n              magn_mt,\n              magn_mx,\n              magn_my,\n              magn_methx,\n              magn_methy;\n\n            if (length > 1)\n              magn_first=(p[0] << 8) | p[1];\n\n            else\n              magn_first=0;\n\n            if (length > 3)\n              magn_last=(p[2] << 8) | p[3];\n\n            else\n              magn_last=magn_first;\n#ifndef MNG_OBJECT_BUFFERS\n            if (magn_first || magn_last)\n              if (mng_info->magn_warning == 0)\n                {\n                  (void) ThrowMagickException(exception,\n                     GetMagickModule(),CoderError,\n                     \"MAGN is not implemented yet for nonzero objects\",\n                     \"`%s'\",image->filename);\n\n                   mng_info->magn_warning++;\n                }\n#endif\n            if (length > 4)\n              magn_methx=p[4];\n\n            else\n              magn_methx=0;\n\n            if (length > 6)\n              magn_mx=(p[5] << 8) | p[6];\n\n            else\n              magn_mx=1;\n\n            if (magn_mx == 0)\n              magn_mx=1;\n\n            if (length > 8)\n              magn_my=(p[7] << 8) | p[8];\n\n            else\n              magn_my=magn_mx;\n\n            if (magn_my == 0)\n              magn_my=1;\n\n            if (length > 10)\n              magn_ml=(p[9] << 8) | p[10];\n\n            else\n              magn_ml=magn_mx;\n\n            if (magn_ml == 0)\n              magn_ml=1;\n\n            if (length > 12)\n              magn_mr=(p[11] << 8) | p[12];\n\n            else\n              magn_mr=magn_mx;\n\n            if (magn_mr == 0)\n              magn_mr=1;\n\n            if (length > 14)\n              magn_mt=(p[13] << 8) | p[14];\n\n            else\n              magn_mt=magn_my;\n\n            if (magn_mt == 0)\n              magn_mt=1;\n\n            if (length > 16)\n              magn_mb=(p[15] << 8) | p[16];\n\n            else\n              magn_mb=magn_my;\n\n            if (magn_mb == 0)\n              magn_mb=1;\n\n            if (length > 17)\n              magn_methy=p[17];\n\n            else\n              magn_methy=magn_methx;\n\n\n            if (magn_methx > 5 || magn_methy > 5)\n              if (mng_info->magn_warning == 0)\n                {\n                  (void) ThrowMagickException(exception,\n                     GetMagickModule(),CoderError,\n                     \"Unknown MAGN method in MNG datastream\",\"`%s'\",\n                     image->filename);\n\n                   mng_info->magn_warning++;\n                }\n#ifdef MNG_OBJECT_BUFFERS\n          /* Magnify existing objects in the range magn_first to magn_last */\n#endif\n            if (magn_first == 0 || magn_last == 0)\n              {\n                /* Save the magnification factors for object 0 */\n                mng_info->magn_mb=magn_mb;\n                mng_info->magn_ml=magn_ml;\n                mng_info->magn_mr=magn_mr;\n                mng_info->magn_mt=magn_mt;\n                mng_info->magn_mx=magn_mx;\n                mng_info->magn_my=magn_my;\n                mng_info->magn_methx=magn_methx;\n                mng_info->magn_methy=magn_methy;\n              }\n          }\n\n        if (memcmp(type,mng_PAST,4) == 0)\n          {\n            if (mng_info->past_warning == 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CoderError,\"PAST is not implemented yet\",\"`%s'\",\n                image->filename);\n\n            mng_info->past_warning++;\n          }\n\n        if (memcmp(type,mng_SHOW,4) == 0)\n          {\n            if (mng_info->show_warning == 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CoderError,\"SHOW is not implemented yet\",\"`%s'\",\n                image->filename);\n\n            mng_info->show_warning++;\n          }\n\n        if (memcmp(type,mng_sBIT,4) == 0)\n          {\n            if (length < 4)\n              mng_info->have_global_sbit=MagickFalse;\n\n            else\n              {\n                mng_info->global_sbit.gray=p[0];\n                mng_info->global_sbit.red=p[0];\n                mng_info->global_sbit.green=p[1];\n                mng_info->global_sbit.blue=p[2];\n                mng_info->global_sbit.alpha=p[3];\n                mng_info->have_global_sbit=MagickTrue;\n             }\n          }\n        if (memcmp(type,mng_pHYs,4) == 0)\n          {\n            if (length > 8)\n              {\n                mng_info->global_x_pixels_per_unit=\n                    (size_t) mng_get_long(p);\n                mng_info->global_y_pixels_per_unit=\n                    (size_t) mng_get_long(&p[4]);\n                mng_info->global_phys_unit_type=p[8];\n                mng_info->have_global_phys=MagickTrue;\n              }\n\n            else\n              mng_info->have_global_phys=MagickFalse;\n          }\n        if (memcmp(type,mng_pHYg,4) == 0)\n          {\n            if (mng_info->phyg_warning == 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CoderError,\"pHYg is not implemented.\",\"`%s'\",image->filename);\n\n            mng_info->phyg_warning++;\n          }\n        if (memcmp(type,mng_BASI,4) == 0)\n          {\n            skip_to_iend=MagickTrue;\n\n            if (mng_info->basi_warning == 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CoderError,\"BASI is not implemented yet\",\"`%s'\",\n                image->filename);\n\n            mng_info->basi_warning++;\n#ifdef MNG_BASI_SUPPORTED\n            basi_width=(unsigned long) mng_get_long(p);\n            basi_width=(unsigned long) mng_get_long(&p[4]);\n            basi_color_type=p[8];\n            basi_compression_method=p[9];\n            basi_filter_type=p[10];\n            basi_interlace_method=p[11];\n            if (length > 11)\n              basi_red=((png_uint_32) p[12] << 8) & (png_uint_32) p[13];\n\n            else\n              basi_red=0;\n\n            if (length > 13)\n              basi_green=((png_uint_32) p[14] << 8) & (png_uint_32) p[15];\n\n            else\n              basi_green=0;\n\n            if (length > 15)\n              basi_blue=((png_uint_32) p[16] << 8) & (png_uint_32) p[17];\n\n            else\n              basi_blue=0;\n\n            if (length > 17)\n              basi_alpha=((png_uint_32) p[18] << 8) & (png_uint_32) p[19];\n\n            else\n              {\n                if (basi_sample_depth == 16)\n                  basi_alpha=65535L;\n                else\n                  basi_alpha=255;\n              }\n\n            if (length > 19)\n              basi_viewable=p[20];\n\n            else\n              basi_viewable=0;\n\n#endif\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_IHDR,4)\n#if defined(JNG_SUPPORTED)\n            && memcmp(type,mng_JHDR,4)\n#endif\n            )\n          {\n            /* Not an IHDR or JHDR chunk */\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n            continue;\n          }\n/* Process IHDR */\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Processing %c%c%c%c chunk\",type[0],type[1],type[2],type[3]);\n\n        mng_info->exists[object_id]=MagickTrue;\n        mng_info->viewable[object_id]=MagickTrue;\n\n        if (mng_info->invisible[object_id])\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Skipping invisible object\");\n\n            skip_to_iend=MagickTrue;\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n#if defined(MNG_INSERT_LAYERS)\n        if (length < 8)\n          {\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n          }\n\n        image_width=(size_t) mng_get_long(p);\n        image_height=(size_t) mng_get_long(&p[4]);\n#endif\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        /*\n          Insert a transparent background layer behind the entire animation\n          if it is not full screen.\n        */\n#if defined(MNG_INSERT_LAYERS)\n        if (insert_layers && mng_type && first_mng_object)\n          {\n            if ((mng_info->clip.left > 0) || (mng_info->clip.top > 0) ||\n                (image_width < mng_info->mng_width) ||\n                (mng_info->clip.right < (ssize_t) mng_info->mng_width) ||\n                (image_height < mng_info->mng_height) ||\n                (mng_info->clip.bottom < (ssize_t) mng_info->mng_height))\n              {\n                if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n                  {\n                    /*\n                      Allocate next image structure.\n                    */\n                    AcquireNextImage(image_info,image,exception);\n\n                    if (GetNextImageInList(image) == (Image *) NULL)\n                      return(DestroyImageList(image));\n\n                    image=SyncNextImageInList(image);\n                  }\n                mng_info->image=image;\n\n                if (term_chunk_found)\n                  {\n                    image->start_loop=MagickTrue;\n                    image->iterations=mng_iterations;\n                    term_chunk_found=MagickFalse;\n                  }\n\n                else\n                    image->start_loop=MagickFalse;\n\n                /* Make a background rectangle.  */\n\n                image->delay=0;\n                image->columns=mng_info->mng_width;\n                image->rows=mng_info->mng_height;\n                image->page.width=mng_info->mng_width;\n                image->page.height=mng_info->mng_height;\n                image->page.x=0;\n                image->page.y=0;\n                image->background_color=mng_background_color;\n                (void) SetImageBackgroundColor(image,exception);\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  Inserted transparent background layer, W=%.20g, H=%.20g\",\n                    (double) mng_info->mng_width,(double) mng_info->mng_height);\n              }\n          }\n        /*\n          Insert a background layer behind the upcoming image if\n          framing_mode is 3, and we haven't already inserted one.\n        */\n        if (insert_layers && (mng_info->framing_mode == 3) &&\n                (subframe_width) && (subframe_height) && (simplicity == 0 ||\n                (simplicity & 0x08)))\n          {\n            if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n            {\n              /*\n                Allocate next image structure.\n              */\n              AcquireNextImage(image_info,image,exception);\n\n              if (GetNextImageInList(image) == (Image *) NULL)\n                return(DestroyImageList(image));\n\n              image=SyncNextImageInList(image);\n            }\n\n            mng_info->image=image;\n\n            if (term_chunk_found)\n              {\n                image->start_loop=MagickTrue;\n                image->iterations=mng_iterations;\n                term_chunk_found=MagickFalse;\n              }\n\n            else\n                image->start_loop=MagickFalse;\n\n            image->delay=0;\n            image->columns=subframe_width;\n            image->rows=subframe_height;\n            image->page.width=subframe_width;\n            image->page.height=subframe_height;\n            image->page.x=mng_info->clip.left;\n            image->page.y=mng_info->clip.top;\n            image->background_color=mng_background_color;\n            image->alpha_trait=UndefinedPixelTrait;\n            (void) SetImageBackgroundColor(image,exception);\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Insert background layer, L=%.20g, R=%.20g T=%.20g, B=%.20g\",\n                (double) mng_info->clip.left,(double) mng_info->clip.right,\n                (double) mng_info->clip.top,(double) mng_info->clip.bottom);\n          }\n#endif /* MNG_INSERT_LAYERS */\n        first_mng_object=MagickFalse;\n\n        if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n          {\n            /*\n              Allocate next image structure.\n            */\n            AcquireNextImage(image_info,image,exception);\n\n            if (GetNextImageInList(image) == (Image *) NULL)\n              return(DestroyImageList(image));\n\n            image=SyncNextImageInList(image);\n          }\n        mng_info->image=image;\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n\n        if (status == MagickFalse)\n          break;\n\n        if (term_chunk_found)\n          {\n            image->start_loop=MagickTrue;\n            term_chunk_found=MagickFalse;\n          }\n\n        else\n            image->start_loop=MagickFalse;\n\n        if (mng_info->framing_mode == 1 || mng_info->framing_mode == 3)\n          {\n            image->delay=frame_delay;\n            frame_delay=default_frame_delay;\n          }\n\n        else\n          image->delay=0;\n\n        image->page.width=mng_info->mng_width;\n        image->page.height=mng_info->mng_height;\n        image->page.x=mng_info->x_off[object_id];\n        image->page.y=mng_info->y_off[object_id];\n        image->iterations=mng_iterations;\n\n        /*\n          Seek back to the beginning of the IHDR or JHDR chunk's length field.\n        */\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Seeking back to beginning of %c%c%c%c chunk\",type[0],type[1],\n            type[2],type[3]);\n\n        offset=SeekBlob(image,-((ssize_t) length+12),SEEK_CUR);\n\n        if (offset < 0)\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n\n    mng_info->image=image;\n    mng_info->mng_type=mng_type;\n    mng_info->object_id=object_id;\n\n    if (memcmp(type,mng_IHDR,4) == 0)\n      image=ReadOnePNGImage(mng_info,image_info,exception);\n\n#if defined(JNG_SUPPORTED)\n    else\n      image=ReadOneJNGImage(mng_info,image_info,exception);\n#endif\n\n    if (image == (Image *) NULL)\n      {\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"exit ReadJNGImage() with error\");\n\n        return((Image *) NULL);\n      }\n\n    if (image->columns == 0 || image->rows == 0)\n      {\n        (void) CloseBlob(image);\n        return(DestroyImageList(image));\n      }\n\n    mng_info->image=image;\n\n    if (mng_type)\n      {\n        MngBox\n          crop_box;\n\n        if (((mng_info->magn_methx > 0) && (mng_info->magn_methx <= 5)) &&\n            ((mng_info->magn_methy > 0) && (mng_info->magn_methy <= 5)))\n          {\n            png_uint_32\n               magnified_height,\n               magnified_width;\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Processing MNG MAGN chunk\");\n\n            if (mng_info->magn_methx == 1)\n              {\n                magnified_width=mng_info->magn_ml;\n\n                if (image->columns > 1)\n                   magnified_width += mng_info->magn_mr;\n\n                if (image->columns > 2)\n                   magnified_width += (png_uint_32)\n                      ((image->columns-2)*(mng_info->magn_mx));\n              }\n\n            else\n              {\n                magnified_width=(png_uint_32) image->columns;\n\n                if (image->columns > 1)\n                   magnified_width += mng_info->magn_ml-1;\n\n                if (image->columns > 2)\n                   magnified_width += mng_info->magn_mr-1;\n\n                if (image->columns > 3)\n                   magnified_width += (png_uint_32)\n                      ((image->columns-3)*(mng_info->magn_mx-1));\n              }\n\n            if (mng_info->magn_methy == 1)\n              {\n                magnified_height=mng_info->magn_mt;\n\n                if (image->rows > 1)\n                   magnified_height += mng_info->magn_mb;\n\n                if (image->rows > 2)\n                   magnified_height += (png_uint_32)\n                      ((image->rows-2)*(mng_info->magn_my));\n              }\n\n            else\n              {\n                magnified_height=(png_uint_32) image->rows;\n\n                if (image->rows > 1)\n                   magnified_height += mng_info->magn_mt-1;\n\n                if (image->rows > 2)\n                   magnified_height += mng_info->magn_mb-1;\n\n                if (image->rows > 3)\n                   magnified_height += (png_uint_32)\n                      ((image->rows-3)*(mng_info->magn_my-1));\n              }\n\n            if (magnified_height > image->rows ||\n                magnified_width > image->columns)\n              {\n                Image\n                  *large_image;\n\n                int\n                  yy;\n\n                Quantum\n                  *next,\n                  *prev;\n\n                png_uint_16\n                  magn_methx,\n                  magn_methy;\n\n                ssize_t\n                  m,\n                  y;\n\n                register Quantum\n                  *n,\n                  *q;\n\n                register ssize_t\n                  x;\n\n                /* Allocate next image structure.  */\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Allocate magnified image\");\n\n                AcquireNextImage(image_info,image,exception);\n\n                if (GetNextImageInList(image) == (Image *) NULL)\n                  return(DestroyImageList(image));\n\n                large_image=SyncNextImageInList(image);\n\n                large_image->columns=magnified_width;\n                large_image->rows=magnified_height;\n\n                magn_methx=mng_info->magn_methx;\n                magn_methy=mng_info->magn_methy;\n\n#if (MAGICKCORE_QUANTUM_DEPTH > 16)\n#define QM unsigned short\n                if (magn_methx != 1 || magn_methy != 1)\n                  {\n                  /*\n                     Scale pixels to unsigned shorts to prevent\n                     overflow of intermediate values of interpolations\n                  */\n                     for (y=0; y < (ssize_t) image->rows; y++)\n                     {\n                       q=GetAuthenticPixels(image,0,y,image->columns,1,\n                          exception);\n                       if (q == (Quantum *) NULL)\n                         break;\n                       for (x=(ssize_t) image->columns-1; x >= 0; x--)\n                       {\n                          SetPixelRed(image,ScaleQuantumToShort(\n                            GetPixelRed(image,q)),q);\n                          SetPixelGreen(image,ScaleQuantumToShort(\n                            GetPixelGreen(image,q)),q);\n                          SetPixelBlue(image,ScaleQuantumToShort(\n                            GetPixelBlue(image,q)),q);\n                          SetPixelAlpha(image,ScaleQuantumToShort(\n                            GetPixelAlpha(image,q)),q);\n                          q+=GetPixelChannels(image);\n                       }\n\n                       if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                         break;\n                     }\n                  }\n#else\n#define QM Quantum\n#endif\n\n                if (image->alpha_trait != UndefinedPixelTrait)\n                   (void) SetImageBackgroundColor(large_image,exception);\n\n                else\n                  {\n                    large_image->background_color.alpha=OpaqueAlpha;\n                    (void) SetImageBackgroundColor(large_image,exception);\n\n                    if (magn_methx == 4)\n                      magn_methx=2;\n\n                    if (magn_methx == 5)\n                      magn_methx=3;\n\n                    if (magn_methy == 4)\n                      magn_methy=2;\n\n                    if (magn_methy == 5)\n                      magn_methy=3;\n                  }\n\n                /* magnify the rows into the right side of the large image */\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Magnify the rows to %.20g\",\n                    (double) large_image->rows);\n                m=(ssize_t) mng_info->magn_mt;\n                yy=0;\n                length=(size_t) GetPixelChannels(image)*image->columns;\n                next=(Quantum *) AcquireQuantumMemory(length,sizeof(*next));\n                prev=(Quantum *) AcquireQuantumMemory(length,sizeof(*prev));\n\n                if ((prev == (Quantum *) NULL) ||\n                    (next == (Quantum *) NULL))\n                  {\n                    if (prev != (Quantum *) NULL)\n                      prev=(Quantum *) RelinquishMagickMemory(prev);\n                    if (next != (Quantum *) NULL)\n                      next=(Quantum *) RelinquishMagickMemory(next);\n                    image=DestroyImageList(image);\n                    ThrowReaderException(ResourceLimitError,\n                      \"MemoryAllocationFailed\");\n                  }\n\n                n=GetAuthenticPixels(image,0,0,image->columns,1,exception);\n                (void) memcpy(next,n,length);\n\n                for (y=0; y < (ssize_t) image->rows; y++)\n                {\n                  if (y == 0)\n                    m=(ssize_t) mng_info->magn_mt;\n\n                  else if (magn_methy > 1 && y == (ssize_t) image->rows-2)\n                    m=(ssize_t) mng_info->magn_mb;\n\n                  else if (magn_methy <= 1 && y == (ssize_t) image->rows-1)\n                    m=(ssize_t) mng_info->magn_mb;\n\n                  else if (magn_methy > 1 && y == (ssize_t) image->rows-1)\n                    m=1;\n\n                  else\n                    m=(ssize_t) mng_info->magn_my;\n\n                  n=prev;\n                  prev=next;\n                  next=n;\n\n                  if (y < (ssize_t) image->rows-1)\n                    {\n                      n=GetAuthenticPixels(image,0,y+1,image->columns,1,\n                          exception);\n                      (void) memcpy(next,n,length);\n                    }\n\n                  for (i=0; i < m; i++, yy++)\n                  {\n                    register Quantum\n                      *pixels;\n\n                    assert(yy < (ssize_t) large_image->rows);\n                    pixels=prev;\n                    n=next;\n                    q=GetAuthenticPixels(large_image,0,yy,large_image->columns,\n                      1,exception);\n                    if (q == (Quantum *) NULL)\n                      break;\n                    q+=(large_image->columns-image->columns)*\n                      GetPixelChannels(large_image);\n\n                    for (x=(ssize_t) image->columns-1; x >= 0; x--)\n                    {\n                      /* To do: get color as function of indexes[x] */\n                      /*\n                      if (image->storage_class == PseudoClass)\n                        {\n                        }\n                      */\n\n                      if (magn_methy <= 1)\n                        {\n                          /* replicate previous */\n                          SetPixelRed(large_image,GetPixelRed(image,pixels),q);\n                          SetPixelGreen(large_image,GetPixelGreen(image,\n                             pixels),q);\n                          SetPixelBlue(large_image,GetPixelBlue(image,\n                             pixels),q);\n                          SetPixelAlpha(large_image,GetPixelAlpha(image,\n                             pixels),q);\n                        }\n\n                      else if (magn_methy == 2 || magn_methy == 4)\n                        {\n                          if (i == 0)\n                            {\n                              SetPixelRed(large_image,GetPixelRed(image,\n                                 pixels),q);\n                              SetPixelGreen(large_image,GetPixelGreen(image,\n                                 pixels),q);\n                              SetPixelBlue(large_image,GetPixelBlue(image,\n                                 pixels),q);\n                              SetPixelAlpha(large_image,GetPixelAlpha(image,\n                                 pixels),q);\n                            }\n\n                          else\n                            {\n                              /* Interpolate */\n                              SetPixelRed(large_image,((QM) (((ssize_t)\n                                 (2*i*(GetPixelRed(image,n)\n                                 -GetPixelRed(image,pixels)+m))/\n                                 ((ssize_t) (m*2))\n                                 +GetPixelRed(image,pixels)))),q);\n                              SetPixelGreen(large_image,((QM) (((ssize_t)\n                                 (2*i*(GetPixelGreen(image,n)\n                                 -GetPixelGreen(image,pixels)+m))/\n                                 ((ssize_t) (m*2))\n                                 +GetPixelGreen(image,pixels)))),q);\n                              SetPixelBlue(large_image,((QM) (((ssize_t)\n                                 (2*i*(GetPixelBlue(image,n)\n                                 -GetPixelBlue(image,pixels)+m))/\n                                 ((ssize_t) (m*2))\n                                 +GetPixelBlue(image,pixels)))),q);\n\n                              if (image->alpha_trait != UndefinedPixelTrait)\n                                 SetPixelAlpha(large_image, ((QM) (((ssize_t)\n                                    (2*i*(GetPixelAlpha(image,n)\n                                    -GetPixelAlpha(image,pixels)+m))\n                                    /((ssize_t) (m*2))+\n                                   GetPixelAlpha(image,pixels)))),q);\n                            }\n\n                          if (magn_methy == 4)\n                            {\n                              /* Replicate nearest */\n                              if (i <= ((m+1) << 1))\n                                 SetPixelAlpha(large_image,GetPixelAlpha(image,\n                                    pixels),q);\n                              else\n                                 SetPixelAlpha(large_image,GetPixelAlpha(image,\n                                    n),q);\n                            }\n                        }\n\n                      else /* if (magn_methy == 3 || magn_methy == 5) */\n                        {\n                          /* Replicate nearest */\n                          if (i <= ((m+1) << 1))\n                          {\n                             SetPixelRed(large_image,GetPixelRed(image,\n                                    pixels),q);\n                             SetPixelGreen(large_image,GetPixelGreen(image,\n                                    pixels),q);\n                             SetPixelBlue(large_image,GetPixelBlue(image,\n                                    pixels),q);\n                             SetPixelAlpha(large_image,GetPixelAlpha(image,\n                                    pixels),q);\n                          }\n\n                          else\n                          {\n                             SetPixelRed(large_image,GetPixelRed(image,n),q);\n                             SetPixelGreen(large_image,GetPixelGreen(image,n),\n                                    q);\n                             SetPixelBlue(large_image,GetPixelBlue(image,n),\n                                    q);\n                             SetPixelAlpha(large_image,GetPixelAlpha(image,n),\n                                    q);\n                          }\n\n                          if (magn_methy == 5)\n                            {\n                              SetPixelAlpha(large_image,(QM) (((ssize_t) (2*i*\n                                 (GetPixelAlpha(image,n)\n                                 -GetPixelAlpha(image,pixels))\n                                 +m))/((ssize_t) (m*2))\n                                 +GetPixelAlpha(image,pixels)),q);\n                            }\n                        }\n                      n+=GetPixelChannels(image);\n                      q+=GetPixelChannels(large_image);\n                      pixels+=GetPixelChannels(image);\n                    } /* x */\n\n                    if (SyncAuthenticPixels(large_image,exception) == 0)\n                      break;\n\n                  } /* i */\n                } /* y */\n\n                prev=(Quantum *) RelinquishMagickMemory(prev);\n                next=(Quantum *) RelinquishMagickMemory(next);\n\n                length=image->columns;\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Delete original image\");\n\n                DeleteImageFromList(&image);\n\n                image=large_image;\n\n                mng_info->image=image;\n\n                /* magnify the columns */\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Magnify the columns to %.20g\",\n                    (double) image->columns);\n\n                for (y=0; y < (ssize_t) image->rows; y++)\n                {\n                  register Quantum\n                    *pixels;\n\n                  q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n                  if (q == (Quantum *) NULL)\n                    break;\n                  pixels=q+(image->columns-length)*GetPixelChannels(image);\n                  n=pixels+GetPixelChannels(image);\n\n                  for (x=(ssize_t) (image->columns-length);\n                    x < (ssize_t) image->columns; x++)\n                  {\n                    /* To do: Rewrite using Get/Set***PixelChannel() */\n\n                    if (x == (ssize_t) (image->columns-length))\n                      m=(ssize_t) mng_info->magn_ml;\n\n                    else if (magn_methx > 1 && x == (ssize_t) image->columns-2)\n                      m=(ssize_t) mng_info->magn_mr;\n\n                    else if (magn_methx <= 1 &&\n                        x == (ssize_t) image->columns-1)\n                      m=(ssize_t) mng_info->magn_mr;\n\n                    else if (magn_methx > 1 && x == (ssize_t) image->columns-1)\n                      m=1;\n\n                    else\n                      m=(ssize_t) mng_info->magn_mx;\n\n                    for (i=0; i < m; i++)\n                    {\n                      if (magn_methx <= 1)\n                        {\n                          /* replicate previous */\n                          SetPixelRed(image,GetPixelRed(image,pixels),q);\n                          SetPixelGreen(image,GetPixelGreen(image,pixels),q);\n                          SetPixelBlue(image,GetPixelBlue(image,pixels),q);\n                          SetPixelAlpha(image,GetPixelAlpha(image,pixels),q);\n                        }\n\n                      else if (magn_methx == 2 || magn_methx == 4)\n                        {\n                          if (i == 0)\n                          {\n                            SetPixelRed(image,GetPixelRed(image,pixels),q);\n                            SetPixelGreen(image,GetPixelGreen(image,pixels),q);\n                            SetPixelBlue(image,GetPixelBlue(image,pixels),q);\n                            SetPixelAlpha(image,GetPixelAlpha(image,pixels),q);\n                          }\n\n                          /* To do: Rewrite using Get/Set***PixelChannel() */\n                          else\n                            {\n                              /* Interpolate */\n                              SetPixelRed(image,(QM) ((2*i*(\n                                 GetPixelRed(image,n)\n                                 -GetPixelRed(image,pixels))+m)\n                                 /((ssize_t) (m*2))+\n                                 GetPixelRed(image,pixels)),q);\n\n                              SetPixelGreen(image,(QM) ((2*i*(\n                                 GetPixelGreen(image,n)\n                                 -GetPixelGreen(image,pixels))+m)\n                                 /((ssize_t) (m*2))+\n                                 GetPixelGreen(image,pixels)),q);\n\n                              SetPixelBlue(image,(QM) ((2*i*(\n                                 GetPixelBlue(image,n)\n                                 -GetPixelBlue(image,pixels))+m)\n                                 /((ssize_t) (m*2))+\n                                 GetPixelBlue(image,pixels)),q);\n                              if (image->alpha_trait != UndefinedPixelTrait)\n                                 SetPixelAlpha(image,(QM) ((2*i*(\n                                   GetPixelAlpha(image,n)\n                                   -GetPixelAlpha(image,pixels))+m)\n                                   /((ssize_t) (m*2))+\n                                   GetPixelAlpha(image,pixels)),q);\n                            }\n\n                          if (magn_methx == 4)\n                            {\n                              /* Replicate nearest */\n                              if (i <= ((m+1) << 1))\n                              {\n                                 SetPixelAlpha(image,\n                                   GetPixelAlpha(image,pixels)+0,q);\n                              }\n                              else\n                              {\n                                 SetPixelAlpha(image,\n                                   GetPixelAlpha(image,n)+0,q);\n                              }\n                            }\n                        }\n\n                      else /* if (magn_methx == 3 || magn_methx == 5) */\n                        {\n                          /* Replicate nearest */\n                          if (i <= ((m+1) << 1))\n                          {\n                             SetPixelRed(image,GetPixelRed(image,pixels),q);\n                             SetPixelGreen(image,GetPixelGreen(image,\n                                 pixels),q);\n                             SetPixelBlue(image,GetPixelBlue(image,pixels),q);\n                             SetPixelAlpha(image,GetPixelAlpha(image,\n                                 pixels),q);\n                          }\n\n                          else\n                          {\n                             SetPixelRed(image,GetPixelRed(image,n),q);\n                             SetPixelGreen(image,GetPixelGreen(image,n),q);\n                             SetPixelBlue(image,GetPixelBlue(image,n),q);\n                             SetPixelAlpha(image,GetPixelAlpha(image,n),q);\n                          }\n\n                          if (magn_methx == 5)\n                            {\n                              /* Interpolate */\n                              SetPixelAlpha(image,\n                                 (QM) ((2*i*( GetPixelAlpha(image,n)\n                                 -GetPixelAlpha(image,pixels))+m)/\n                                 ((ssize_t) (m*2))\n                                 +GetPixelAlpha(image,pixels)),q);\n                            }\n                        }\n                      q+=GetPixelChannels(image);\n                    }\n                    n+=GetPixelChannels(image);\n                  }\n\n                  if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                    break;\n                }\n#if (MAGICKCORE_QUANTUM_DEPTH > 16)\n              if (magn_methx != 1 || magn_methy != 1)\n                {\n                /*\n                   Rescale pixels to Quantum\n                */\n                   for (y=0; y < (ssize_t) image->rows; y++)\n                   {\n                     q=GetAuthenticPixels(image,0,y,image->columns,1,\n                       exception);\n                     if (q == (Quantum *) NULL)\n                       break;\n\n                     for (x=(ssize_t) image->columns-1; x >= 0; x--)\n                     {\n                        SetPixelRed(image,ScaleShortToQuantum(\n                          GetPixelRed(image,q)),q);\n                        SetPixelGreen(image,ScaleShortToQuantum(\n                          GetPixelGreen(image,q)),q);\n                        SetPixelBlue(image,ScaleShortToQuantum(\n                          GetPixelBlue(image,q)),q);\n                        SetPixelAlpha(image,ScaleShortToQuantum(\n                          GetPixelAlpha(image,q)),q);\n                        q+=GetPixelChannels(image);\n                     }\n\n                     if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                       break;\n                   }\n                }\n#endif\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  Finished MAGN processing\");\n              }\n          }\n\n        /*\n          Crop_box is with respect to the upper left corner of the MNG.\n        */\n        crop_box.left=mng_info->image_box.left+mng_info->x_off[object_id];\n        crop_box.right=mng_info->image_box.right+mng_info->x_off[object_id];\n        crop_box.top=mng_info->image_box.top+mng_info->y_off[object_id];\n        crop_box.bottom=mng_info->image_box.bottom+mng_info->y_off[object_id];\n        crop_box=mng_minimum_box(crop_box,mng_info->clip);\n        crop_box=mng_minimum_box(crop_box,mng_info->frame);\n        crop_box=mng_minimum_box(crop_box,mng_info->object_clip[object_id]);\n        if ((crop_box.left != (mng_info->image_box.left\n            +mng_info->x_off[object_id])) ||\n            (crop_box.right != (mng_info->image_box.right\n            +mng_info->x_off[object_id])) ||\n            (crop_box.top != (mng_info->image_box.top\n            +mng_info->y_off[object_id])) ||\n            (crop_box.bottom != (mng_info->image_box.bottom\n            +mng_info->y_off[object_id])))\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Crop the PNG image\");\n\n            if ((crop_box.left < crop_box.right) &&\n                (crop_box.top < crop_box.bottom))\n              {\n                Image\n                  *im;\n\n                RectangleInfo\n                  crop_info;\n\n                /*\n                  Crop_info is with respect to the upper left corner of\n                  the image.\n                */\n                crop_info.x=(crop_box.left-mng_info->x_off[object_id]);\n                crop_info.y=(crop_box.top-mng_info->y_off[object_id]);\n                crop_info.width=(size_t) (crop_box.right-crop_box.left);\n                crop_info.height=(size_t) (crop_box.bottom-crop_box.top);\n                image->page.width=image->columns;\n                image->page.height=image->rows;\n                image->page.x=0;\n                image->page.y=0;\n                im=CropImage(image,&crop_info,exception);\n\n                if (im != (Image *) NULL)\n                  {\n                    image->columns=im->columns;\n                    image->rows=im->rows;\n                    im=DestroyImage(im);\n                    image->page.width=image->columns;\n                    image->page.height=image->rows;\n                    image->page.x=crop_box.left;\n                    image->page.y=crop_box.top;\n                  }\n              }\n\n            else\n              {\n                /*\n                  No pixels in crop area.  The MNG spec still requires\n                  a layer, though, so make a single transparent pixel in\n                  the top left corner.\n                */\n                image->columns=1;\n                image->rows=1;\n                image->colors=2;\n                (void) SetImageBackgroundColor(image,exception);\n                image->page.width=1;\n                image->page.height=1;\n                image->page.x=0;\n                image->page.y=0;\n              }\n          }\n#ifndef PNG_READ_EMPTY_PLTE_SUPPORTED\n        image=mng_info->image;\n#endif\n      }\n\n#if (MAGICKCORE_QUANTUM_DEPTH > 16)\n      /* PNG does not handle depths greater than 16 so reduce it even\n       * if lossy.\n       */\n      if (image->depth > 16)\n         image->depth=16;\n#endif\n\n#if (MAGICKCORE_QUANTUM_DEPTH > 8)\n      if (image->depth > 8)\n        {\n          /* To do: fill low byte properly */\n          image->depth=16;\n        }\n\n      if (LosslessReduceDepthOK(image,exception) != MagickFalse)\n         image->depth = 8;\n#endif\n\n      if (image_info->number_scenes != 0)\n        {\n          if (mng_info->scenes_found >\n             (ssize_t) (image_info->first_scene+image_info->number_scenes))\n            break;\n        }\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Finished reading image datastream.\");\n\n  } while (LocaleCompare(image_info->magick,\"MNG\") == 0);\n\n  (void) CloseBlob(image);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Finished reading all image datastreams.\");\n\n#if defined(MNG_INSERT_LAYERS)\n  if (insert_layers && !mng_info->image_found && (mng_info->mng_width) &&\n       (mng_info->mng_height))\n    {\n      /*\n        Insert a background layer if nothing else was found.\n      */\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  No images found.  Inserting a background layer.\");\n\n      if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n        {\n          /*\n            Allocate next image structure.\n          */\n          AcquireNextImage(image_info,image,exception);\n          if (GetNextImageInList(image) == (Image *) NULL)\n            {\n              if (logging != MagickFalse)\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Allocation failed, returning NULL.\");\n\n              return(DestroyImageList(image));;\n            }\n          image=SyncNextImageInList(image);\n        }\n      image->columns=mng_info->mng_width;\n      image->rows=mng_info->mng_height;\n      image->page.width=mng_info->mng_width;\n      image->page.height=mng_info->mng_height;\n      image->page.x=0;\n      image->page.y=0;\n      image->background_color=mng_background_color;\n      image->alpha_trait=UndefinedPixelTrait;\n\n      if (image_info->ping == MagickFalse)\n        (void) SetImageBackgroundColor(image,exception);\n\n      mng_info->image_found++;\n    }\n#endif\n  image->iterations=mng_iterations;\n\n  if (mng_iterations == 1)\n    image->start_loop=MagickTrue;\n\n  while (GetPreviousImageInList(image) != (Image *) NULL)\n  {\n    image_count++;\n    if (image_count > 10*mng_info->image_found)\n      {\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  No beginning\");\n\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          CoderError,\"Linked list is corrupted, beginning of list not found\",\n          \"`%s'\",image_info->filename);\n\n        return(DestroyImageList(image));\n      }\n\n    image=GetPreviousImageInList(image);\n\n    if (GetNextImageInList(image) == (Image *) NULL)\n      {\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  Corrupt list\");\n\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          CoderError,\"Linked list is corrupted; next_image is NULL\",\"`%s'\",\n          image_info->filename);\n      }\n  }\n\n  if (mng_info->ticks_per_second && mng_info->image_found > 1 &&\n             GetNextImageInList(image) ==\n     (Image *) NULL)\n    {\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  First image null\");\n\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        CoderError,\"image->next for first image is NULL but shouldn't be.\",\n        \"`%s'\",image_info->filename);\n    }\n\n  if (mng_info->image_found == 0)\n    {\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  No visible images found.\");\n\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        CoderError,\"No visible images in file\",\"`%s'\",image_info->filename);\n\n      return(DestroyImageList(image));\n    }\n\n  if (mng_info->ticks_per_second)\n    final_delay=1UL*MagickMax(image->ticks_per_second,1L)*\n            final_delay/mng_info->ticks_per_second;\n\n  else\n    image->start_loop=MagickTrue;\n\n  /* Find final nonzero image delay */\n  final_image_delay=0;\n\n  while (GetNextImageInList(image) != (Image *) NULL)\n    {\n      if (image->delay)\n        final_image_delay=image->delay;\n\n      image=GetNextImageInList(image);\n    }\n\n  if (final_delay < final_image_delay)\n    final_delay=final_image_delay;\n\n  image->delay=final_delay;\n\n  if (logging != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  image->delay=%.20g, final_delay=%.20g\",(double) image->delay,\n        (double) final_delay);\n\n  if (logging != MagickFalse)\n    {\n      int\n        scene;\n\n      scene=0;\n      image=GetFirstImageInList(image);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Before coalesce:\");\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    scene 0 delay=%.20g\",(double) image->delay);\n\n      while (GetNextImageInList(image) != (Image *) NULL)\n      {\n        image=GetNextImageInList(image);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    scene %.20g delay=%.20g\",(double) scene++,\n          (double) image->delay);\n      }\n    }\n\n  image=GetFirstImageInList(image);\n#ifdef MNG_COALESCE_LAYERS\n  if (insert_layers && image->next)\n    {\n      Image\n        *next_image,\n        *next;\n\n      size_t\n        scene;\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Coalesce Images\");\n\n      scene=image->scene;\n      next_image=CoalesceImages(image,exception);\n      image=DestroyImageList(image);\n      if (next_image == (Image *) NULL)\n        {\n          mng_info=MngInfoFreeStruct(mng_info);\n          return((Image *) NULL);\n        }\n      image=next_image;\n\n      for (next=image; next != (Image *) NULL; next=next_image)\n      {\n         next->page.width=mng_info->mng_width;\n         next->page.height=mng_info->mng_height;\n         next->page.x=0;\n         next->page.y=0;\n         next->scene=scene++;\n         next_image=GetNextImageInList(next);\n\n         if (next_image == (Image *) NULL)\n           break;\n\n         if (next->delay == 0)\n           {\n             scene--;\n             next_image->previous=GetPreviousImageInList(next);\n             if (GetPreviousImageInList(next) == (Image *) NULL)\n               image=next_image;\n             else\n               next->previous->next=next_image;\n             next=DestroyImage(next);\n           }\n      }\n    }\n#endif\n\n  while (GetNextImageInList(image) != (Image *) NULL)\n      image=GetNextImageInList(image);\n\n  image->dispose=BackgroundDispose;\n\n  if (logging != MagickFalse)\n    {\n      int\n        scene;\n\n      scene=0;\n      image=GetFirstImageInList(image);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  After coalesce:\");\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    scene 0 delay=%.20g dispose=%.20g\",(double) image->delay,\n        (double) image->dispose);\n\n      while (GetNextImageInList(image) != (Image *) NULL)\n      {\n        image=GetNextImageInList(image);\n\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    scene %.20g delay=%.20g dispose=%.20g\",(double) scene++,\n          (double) image->delay,(double) image->dispose);\n      }\n   }\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  exit ReadOneMNGImage();\");\n\n  return(image);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146474,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static Image *ReadOneMNGImage(MngInfo* mng_info, const ImageInfo *image_info,\n     ExceptionInfo *exception)\n{\n  char\n    page_geometry[MagickPathExtent];\n\n  Image\n    *image;\n\n  MagickBooleanType\n    logging;\n\n  volatile int\n    first_mng_object,\n    object_id,\n    term_chunk_found,\n    skip_to_iend;\n\n  volatile ssize_t\n    image_count=0;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  MngBox\n    default_fb,\n    fb,\n    previous_fb;\n\n#if defined(MNG_INSERT_LAYERS)\n  PixelInfo\n    mng_background_color;\n#endif\n\n  register unsigned char\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    count;\n\n  ssize_t\n    loop_level;\n\n  volatile short\n    skipping_loop;\n\n#if defined(MNG_INSERT_LAYERS)\n  unsigned int\n    mandatory_back=0;\n#endif\n\n  volatile unsigned int\n#ifdef MNG_OBJECT_BUFFERS\n    mng_background_object=0,\n#endif\n    mng_type=0;   /* 0: PNG or JNG; 1: MNG; 2: MNG-LC; 3: MNG-VLC */\n\n  size_t\n    default_frame_timeout,\n    frame_timeout,\n#if defined(MNG_INSERT_LAYERS)\n    image_height,\n    image_width,\n#endif\n    length;\n\n  /* These delays are all measured in image ticks_per_second,\n   * not in MNG ticks_per_second\n   */\n  volatile size_t\n    default_frame_delay,\n    final_delay,\n    final_image_delay,\n    frame_delay,\n#if defined(MNG_INSERT_LAYERS)\n    insert_layers,\n#endif\n    mng_iterations=1,\n    simplicity=0,\n    subframe_height=0,\n    subframe_width=0;\n\n  previous_fb.top=0;\n  previous_fb.bottom=0;\n  previous_fb.left=0;\n  previous_fb.right=0;\n  default_fb.top=0;\n  default_fb.bottom=0;\n  default_fb.left=0;\n  default_fb.right=0;\n\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  Enter ReadOneMNGImage()\");\n\n  image=mng_info->image;\n\n  if (LocaleCompare(image_info->magick,\"MNG\") == 0)\n    {\n      char\n        magic_number[MagickPathExtent];\n\n      /* Verify MNG signature.  */\n      count=(size_t) ReadBlob(image,8,(unsigned char *) magic_number);\n      if ((count < 8) || (memcmp(magic_number,\"\\212MNG\\r\\n\\032\\n\",8) != 0))\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n      /* Initialize some nonzero members of the MngInfo structure.  */\n      for (i=0; i < MNG_MAX_OBJECTS; i++)\n      {\n        mng_info->object_clip[i].right=(ssize_t) PNG_UINT_31_MAX;\n        mng_info->object_clip[i].bottom=(ssize_t) PNG_UINT_31_MAX;\n      }\n      mng_info->exists[0]=MagickTrue;\n    }\n\n  skipping_loop=(-1);\n  first_mng_object=MagickTrue;\n  mng_type=0;\n#if defined(MNG_INSERT_LAYERS)\n  insert_layers=MagickFalse; /* should be False during convert or mogrify */\n#endif\n  default_frame_delay=0;\n  default_frame_timeout=0;\n  frame_delay=0;\n  final_delay=1;\n  mng_info->ticks_per_second=1UL*image->ticks_per_second;\n  object_id=0;\n  skip_to_iend=MagickFalse;\n  term_chunk_found=MagickFalse;\n  mng_info->framing_mode=1;\n#if defined(MNG_INSERT_LAYERS)\n  mandatory_back=MagickFalse;\n#endif\n#if defined(MNG_INSERT_LAYERS)\n  mng_background_color=image->background_color;\n#endif\n  default_fb=mng_info->frame;\n  previous_fb=mng_info->frame;\n  do\n  {\n    char\n      type[MagickPathExtent];\n\n    if (LocaleCompare(image_info->magick,\"MNG\") == 0)\n      {\n        unsigned char\n          *chunk;\n\n        /*\n          Read a new chunk.\n        */\n        type[0]='\\0';\n        (void) ConcatenateMagickString(type,\"errr\",MagickPathExtent);\n        length=(size_t) ReadBlobMSBLong(image);\n        count=(size_t) ReadBlob(image,4,(unsigned char *) type);\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n           \"  Reading MNG chunk type %c%c%c%c, length: %.20g\",\n           type[0],type[1],type[2],type[3],(double) length);\n\n        if ((length > PNG_UINT_31_MAX) || (length > GetBlobSize(image)) ||\n            (count < 4))\n          ThrowReaderException(CorruptImageError,\"CorruptImage\");\n\n        p=NULL;\n        chunk=(unsigned char *) NULL;\n\n        if (length != 0)\n          {\n            chunk=(unsigned char *) AcquireQuantumMemory(length,sizeof(*chunk));\n\n            if (chunk == (unsigned char *) NULL)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n            for (i=0; i < (ssize_t) length; i++)\n            {\n              int\n                c;\n\n              c=ReadBlobByte(image);\n              if (c == EOF)\n                {\n                  chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n                  ThrowReaderException(CorruptImageError,\n                    \"InsufficientImageDataInFile\");\n                }\n              chunk[i]=(unsigned char) c;\n            }\n\n            p=chunk;\n          }\n\n        (void) ReadBlobMSBLong(image);  /* read crc word */\n\n#if !defined(JNG_SUPPORTED)\n        if (memcmp(type,mng_JHDR,4) == 0)\n          {\n            skip_to_iend=MagickTrue;\n\n            if (mng_info->jhdr_warning == 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CoderError,\"JNGCompressNotSupported\",\"`%s'\",image->filename);\n\n            mng_info->jhdr_warning++;\n          }\n#endif\n        if (memcmp(type,mng_DHDR,4) == 0)\n          {\n            skip_to_iend=MagickTrue;\n\n            if (mng_info->dhdr_warning == 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CoderError,\"DeltaPNGNotSupported\",\"`%s'\",image->filename);\n\n            mng_info->dhdr_warning++;\n          }\n        if (memcmp(type,mng_MEND,4) == 0)\n          {\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            break;\n          }\n\n        if (skip_to_iend)\n          {\n            if (memcmp(type,mng_IEND,4) == 0)\n              skip_to_iend=MagickFalse;\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Skip to IEND.\");\n\n            continue;\n          }\n\n        if (memcmp(type,mng_MHDR,4) == 0)\n          {\n            if (length != 28)\n              {\n                chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n                ThrowReaderException(CorruptImageError,\"CorruptImage\");\n              }\n\n            mng_info->mng_width=(unsigned long)mng_get_long(p);\n            mng_info->mng_height=(unsigned long)mng_get_long(&p[4]);\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  MNG width: %.20g\",(double) mng_info->mng_width);\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  MNG height: %.20g\",(double) mng_info->mng_height);\n              }\n\n            p+=8;\n            mng_info->ticks_per_second=(size_t) mng_get_long(p);\n\n            if (mng_info->ticks_per_second == 0)\n              default_frame_delay=0;\n\n            else\n              default_frame_delay=1UL*image->ticks_per_second/\n                mng_info->ticks_per_second;\n\n            frame_delay=default_frame_delay;\n            simplicity=0;\n\n            p+=16;\n            simplicity=(size_t) mng_get_long(p);\n\n            mng_type=1;    /* Full MNG */\n\n            if ((simplicity != 0) && ((simplicity | 11) == 11))\n              mng_type=2; /* LC */\n\n            if ((simplicity != 0) && ((simplicity | 9) == 9))\n              mng_type=3; /* VLC */\n\n#if defined(MNG_INSERT_LAYERS)\n            if (mng_type != 3)\n              insert_layers=MagickTrue;\n#endif\n            if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n              {\n                /* Allocate next image structure.  */\n                AcquireNextImage(image_info,image,exception);\n\n                if (GetNextImageInList(image) == (Image *) NULL)\n                  return((Image *) NULL);\n\n                image=SyncNextImageInList(image);\n                mng_info->image=image;\n              }\n\n            if ((mng_info->mng_width > 65535L) ||\n                (mng_info->mng_height > 65535L))\n              {\n                chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n                ThrowReaderException(ImageError,\"WidthOrHeightExceedsLimit\");\n              }\n\n            (void) FormatLocaleString(page_geometry,MagickPathExtent,\n              \"%.20gx%.20g+0+0\",(double) mng_info->mng_width,(double)\n              mng_info->mng_height);\n\n            mng_info->frame.left=0;\n            mng_info->frame.right=(ssize_t) mng_info->mng_width;\n            mng_info->frame.top=0;\n            mng_info->frame.bottom=(ssize_t) mng_info->mng_height;\n            mng_info->clip=default_fb=previous_fb=mng_info->frame;\n\n            for (i=0; i < MNG_MAX_OBJECTS; i++)\n              mng_info->object_clip[i]=mng_info->frame;\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_TERM,4) == 0)\n          {\n            int\n              repeat=0;\n\n            if (length != 0)\n              repeat=p[0];\n\n            if (repeat == 3 && length > 9)\n              {\n                final_delay=(png_uint_32) mng_get_long(&p[2]);\n                mng_iterations=(png_uint_32) mng_get_long(&p[6]);\n\n                if (mng_iterations == PNG_UINT_31_MAX)\n                  mng_iterations=0;\n\n                image->iterations=mng_iterations;\n                term_chunk_found=MagickTrue;\n              }\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    repeat=%d,  final_delay=%.20g,  iterations=%.20g\",\n                  repeat,(double) final_delay, (double) image->iterations);\n              }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n        if (memcmp(type,mng_DEFI,4) == 0)\n          {\n            if (mng_type == 3)\n              {\n                (void) ThrowMagickException(exception,GetMagickModule(),\n                  CoderError,\"DEFI chunk found in MNG-VLC datastream\",\"`%s'\",\n                  image->filename);\n                chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n                continue;\n              }\n\n            if (length < 2)\n              {\n                chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n                ThrowReaderException(CorruptImageError,\"CorruptImage\");\n              }\n\n            object_id=((unsigned int) p[0] << 8) | (unsigned int) p[1];\n\n            if (mng_type == 2 && object_id != 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CoderError,\"Nonzero object_id in MNG-LC datastream\",\"`%s'\",\n                image->filename);\n\n            if (object_id >= MNG_MAX_OBJECTS)\n              {\n                /*\n                  Instead of using a warning we should allocate a larger\n                  MngInfo structure and continue.\n                */\n                (void) ThrowMagickException(exception,GetMagickModule(),\n                  CoderError,\"object id too large\",\"`%s'\",image->filename);\n                object_id=MNG_MAX_OBJECTS-1;\n              }\n\n            if (mng_info->exists[object_id])\n              if (mng_info->frozen[object_id])\n                {\n                  chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n                  (void) ThrowMagickException(exception,\n                    GetMagickModule(),CoderError,\n                    \"DEFI cannot redefine a frozen MNG object\",\"`%s'\",\n                    image->filename);\n                  continue;\n                }\n\n            mng_info->exists[object_id]=MagickTrue;\n\n            if (length > 2)\n              mng_info->invisible[object_id]=p[2];\n\n            /*\n              Extract object offset info.\n            */\n            if (length > 11)\n              {\n                mng_info->x_off[object_id]=(ssize_t) mng_get_long(&p[4]);\n                mng_info->y_off[object_id]=(ssize_t) mng_get_long(&p[8]);\n                if (logging != MagickFalse)\n                  {\n                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                      \"  x_off[%d]: %.20g,  y_off[%d]: %.20g\",\n                      object_id,(double) mng_info->x_off[object_id],\n                      object_id,(double) mng_info->y_off[object_id]);\n                  }\n              }\n\n            /*\n              Extract object clipping info.\n            */\n            if (length > 27)\n              mng_info->object_clip[object_id]=mng_read_box(mng_info->frame,0,\n                &p[12]);\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n        if (memcmp(type,mng_bKGD,4) == 0)\n          {\n            mng_info->have_global_bkgd=MagickFalse;\n\n            if (length > 5)\n              {\n                mng_info->mng_global_bkgd.red=\n                  ScaleShortToQuantum((unsigned short) ((p[0] << 8) | p[1]));\n\n                mng_info->mng_global_bkgd.green=\n                  ScaleShortToQuantum((unsigned short) ((p[2] << 8) | p[3]));\n\n                mng_info->mng_global_bkgd.blue=\n                  ScaleShortToQuantum((unsigned short) ((p[4] << 8) | p[5]));\n\n                mng_info->have_global_bkgd=MagickTrue;\n              }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n        if (memcmp(type,mng_BACK,4) == 0)\n          {\n#if defined(MNG_INSERT_LAYERS)\n            if (length > 6)\n              mandatory_back=p[6];\n\n            else\n              mandatory_back=0;\n\n            if (mandatory_back && length > 5)\n              {\n                mng_background_color.red=\n                    ScaleShortToQuantum((unsigned short) ((p[0] << 8) | p[1]));\n\n                mng_background_color.green=\n                    ScaleShortToQuantum((unsigned short) ((p[2] << 8) | p[3]));\n\n                mng_background_color.blue=\n                    ScaleShortToQuantum((unsigned short) ((p[4] << 8) | p[5]));\n\n                mng_background_color.alpha=OpaqueAlpha;\n              }\n\n#ifdef MNG_OBJECT_BUFFERS\n            if (length > 8)\n              mng_background_object=(p[7] << 8) | p[8];\n#endif\n#endif\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_PLTE,4) == 0)\n          {\n            /* Read global PLTE.  */\n\n            if (length && (length < 769))\n              {\n                /* Read global PLTE.  */\n\n                if (mng_info->global_plte == (png_colorp) NULL)\n                  mng_info->global_plte=(png_colorp) AcquireQuantumMemory(256,\n                    sizeof(*mng_info->global_plte));\n\n                if (mng_info->global_plte == (png_colorp) NULL)\n                  {\n                    mng_info->global_plte_length=0;\n                    chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n                    ThrowReaderException(ResourceLimitError,\n                      \"MemoryAllocationFailed\");\n                  }\n\n                for (i=0; i < (ssize_t) (length/3); i++)\n                {\n                  mng_info->global_plte[i].red=p[3*i];\n                  mng_info->global_plte[i].green=p[3*i+1];\n                  mng_info->global_plte[i].blue=p[3*i+2];\n                }\n\n                mng_info->global_plte_length=(unsigned int) (length/3);\n              }\n#ifdef MNG_LOOSE\n            for ( ; i < 256; i++)\n            {\n              mng_info->global_plte[i].red=i;\n              mng_info->global_plte[i].green=i;\n              mng_info->global_plte[i].blue=i;\n            }\n\n            if (length != 0)\n              mng_info->global_plte_length=256;\n#endif\n            else\n              mng_info->global_plte_length=0;\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_tRNS,4) == 0)\n          {\n            /* read global tRNS */\n\n            if (length > 0 && length < 257)\n              for (i=0; i < (ssize_t) length; i++)\n                mng_info->global_trns[i]=p[i];\n\n#ifdef MNG_LOOSE\n            for ( ; i < 256; i++)\n              mng_info->global_trns[i]=255;\n#endif\n            mng_info->global_trns_length=(unsigned int) length;\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n        if (memcmp(type,mng_gAMA,4) == 0)\n          {\n            if (length == 4)\n              {\n                ssize_t\n                  igamma;\n\n                igamma=mng_get_long(p);\n                mng_info->global_gamma=((float) igamma)*0.00001;\n                mng_info->have_global_gama=MagickTrue;\n              }\n\n            else\n              mng_info->have_global_gama=MagickFalse;\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_cHRM,4) == 0)\n          {\n            /* Read global cHRM */\n\n            if (length == 32)\n              {\n                mng_info->global_chrm.white_point.x=0.00001*mng_get_long(p);\n                mng_info->global_chrm.white_point.y=0.00001*mng_get_long(&p[4]);\n                mng_info->global_chrm.red_primary.x=0.00001*mng_get_long(&p[8]);\n                mng_info->global_chrm.red_primary.y=0.00001*\n                  mng_get_long(&p[12]);\n                mng_info->global_chrm.green_primary.x=0.00001*\n                  mng_get_long(&p[16]);\n                mng_info->global_chrm.green_primary.y=0.00001*\n                  mng_get_long(&p[20]);\n                mng_info->global_chrm.blue_primary.x=0.00001*\n                  mng_get_long(&p[24]);\n                mng_info->global_chrm.blue_primary.y=0.00001*\n                  mng_get_long(&p[28]);\n                mng_info->have_global_chrm=MagickTrue;\n              }\n            else\n              mng_info->have_global_chrm=MagickFalse;\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_sRGB,4) == 0)\n          {\n            /*\n              Read global sRGB.\n            */\n            if (length != 0)\n              {\n                mng_info->global_srgb_intent=\n                  Magick_RenderingIntent_from_PNG_RenderingIntent(p[0]);\n                mng_info->have_global_srgb=MagickTrue;\n              }\n            else\n              mng_info->have_global_srgb=MagickFalse;\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_iCCP,4) == 0)\n          {\n            /* To do: */\n\n            /*\n              Read global iCCP.\n            */\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n            continue;\n          }\n\n        if (memcmp(type,mng_FRAM,4) == 0)\n          {\n            if (mng_type == 3)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CoderError,\"FRAM chunk found in MNG-VLC datastream\",\"`%s'\",\n                image->filename);\n\n            if ((mng_info->framing_mode == 2) || (mng_info->framing_mode == 4))\n              image->delay=frame_delay;\n\n            frame_delay=default_frame_delay;\n            frame_timeout=default_frame_timeout;\n            fb=default_fb;\n\n            if (length != 0)\n              if (p[0])\n                mng_info->framing_mode=p[0];\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Framing_mode=%d\",mng_info->framing_mode);\n\n            if (length > 6)\n              {\n                /* Note the delay and frame clipping boundaries.  */\n\n                p++; /* framing mode */\n\n                while (((p-chunk) < (long) length) && *p)\n                  p++;  /* frame name */\n\n                p++;  /* frame name terminator */\n\n                if ((p-chunk) < (ssize_t) (length-4))\n                  {\n                    int\n                      change_delay,\n                      change_timeout,\n                      change_clipping;\n\n                    change_delay=(*p++);\n                    change_timeout=(*p++);\n                    change_clipping=(*p++);\n                    p++; /* change_sync */\n\n                    if (change_delay && ((p-chunk) < (ssize_t) (length-4)))\n                      {\n                        frame_delay=1UL*image->ticks_per_second*\n                          mng_get_long(p);\n\n                        if (mng_info->ticks_per_second != 0)\n                          frame_delay/=mng_info->ticks_per_second;\n\n                        else\n                          frame_delay=PNG_UINT_31_MAX;\n\n                        if (change_delay == 2)\n                          default_frame_delay=frame_delay;\n\n                        p+=4;\n\n                        if (logging != MagickFalse)\n                          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                            \"    Framing_delay=%.20g\",(double) frame_delay);\n                      }\n\n                    if (change_timeout && ((p-chunk) < (ssize_t) (length-4)))\n                      {\n                        frame_timeout=1UL*image->ticks_per_second*\n                          mng_get_long(p);\n\n                        if (mng_info->ticks_per_second != 0)\n                          frame_timeout/=mng_info->ticks_per_second;\n\n                        else\n                          frame_timeout=PNG_UINT_31_MAX;\n\n                        if (change_timeout == 2)\n                          default_frame_timeout=frame_timeout;\n\n                        p+=4;\n\n                        if (logging != MagickFalse)\n                          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                            \"    Framing_timeout=%.20g\",(double) frame_timeout);\n                      }\n\n                    if (change_clipping && ((p-chunk) < (ssize_t) (length-16)))\n                      {\n                        fb=mng_read_box(previous_fb,(char) p[0],&p[1]);\n                        p+=16;\n                        previous_fb=fb;\n\n                        if (logging != MagickFalse)\n                          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                            \"    Frame_clip: L=%.20g R=%.20g T=%.20g B=%.20g\",\n                            (double) fb.left,(double) fb.right,(double) fb.top,\n                            (double) fb.bottom);\n\n                        if (change_clipping == 2)\n                          default_fb=fb;\n                      }\n                  }\n              }\n            mng_info->clip=fb;\n            mng_info->clip=mng_minimum_box(fb,mng_info->frame);\n\n            subframe_width=(size_t) (mng_info->clip.right\n               -mng_info->clip.left);\n\n            subframe_height=(size_t) (mng_info->clip.bottom\n               -mng_info->clip.top);\n            /*\n              Insert a background layer behind the frame if framing_mode is 4.\n            */\n#if defined(MNG_INSERT_LAYERS)\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"   subframe_width=%.20g, subframe_height=%.20g\",(double)\n                subframe_width,(double) subframe_height);\n\n            if (insert_layers && (mng_info->framing_mode == 4) &&\n                (subframe_width) && (subframe_height))\n              {\n                /* Allocate next image structure.  */\n                if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n                  {\n                    AcquireNextImage(image_info,image,exception);\n\n                    if (GetNextImageInList(image) == (Image *) NULL)\n                      return(DestroyImageList(image));\n\n                    image=SyncNextImageInList(image);\n                  }\n\n                mng_info->image=image;\n\n                if (term_chunk_found)\n                  {\n                    image->start_loop=MagickTrue;\n                    image->iterations=mng_iterations;\n                    term_chunk_found=MagickFalse;\n                  }\n\n                else\n                    image->start_loop=MagickFalse;\n\n                image->columns=subframe_width;\n                image->rows=subframe_height;\n                image->page.width=subframe_width;\n                image->page.height=subframe_height;\n                image->page.x=mng_info->clip.left;\n                image->page.y=mng_info->clip.top;\n                image->background_color=mng_background_color;\n                image->alpha_trait=UndefinedPixelTrait;\n                image->delay=0;\n                if (SetImageBackgroundColor(image,exception) == MagickFalse)\n                  {\n                    chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n                    return(DestroyImageList(image));\n                  }\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  Insert backgd layer, L=%.20g, R=%.20g T=%.20g, B=%.20g\",\n                    (double) mng_info->clip.left,\n                    (double) mng_info->clip.right,\n                    (double) mng_info->clip.top,\n                    (double) mng_info->clip.bottom);\n              }\n#endif\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_CLIP,4) == 0)\n          {\n            unsigned int\n              first_object,\n              last_object;\n\n            /*\n              Read CLIP.\n            */\n            if (length > 3)\n              {\n                first_object=(p[0] << 8) | p[1];\n                last_object=(p[2] << 8) | p[3];\n                p+=4;\n\n                for (i=(int) first_object; i <= (int) last_object; i++)\n                {\n                  if ((i < 0) || (i >= MNG_MAX_OBJECTS))\n                    continue;\n\n                  if (mng_info->exists[i] && !mng_info->frozen[i])\n                    {\n                      MngBox\n                        box;\n\n                      box=mng_info->object_clip[i];\n                      if ((p-chunk) < (ssize_t) (length-17))\n                        mng_info->object_clip[i]=\n                           mng_read_box(box,(char) p[0],&p[1]);\n                    }\n                }\n\n              }\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_SAVE,4) == 0)\n          {\n            for (i=1; i < MNG_MAX_OBJECTS; i++)\n              if (mng_info->exists[i])\n                {\n                 mng_info->frozen[i]=MagickTrue;\n#ifdef MNG_OBJECT_BUFFERS\n                 if (mng_info->ob[i] != (MngBuffer *) NULL)\n                    mng_info->ob[i]->frozen=MagickTrue;\n#endif\n                }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n            continue;\n          }\n\n        if ((memcmp(type,mng_DISC,4) == 0) || (memcmp(type,mng_SEEK,4) == 0))\n          {\n            /* Read DISC or SEEK.  */\n\n            if ((length == 0) || (length % 2) || !memcmp(type,mng_SEEK,4))\n              {\n                for (i=1; i < MNG_MAX_OBJECTS; i++)\n                  MngInfoDiscardObject(mng_info,i);\n              }\n\n            else\n              {\n                register ssize_t\n                  j;\n\n                for (j=1; j < (ssize_t) length; j+=2)\n                {\n                  i=p[j-1] << 8 | p[j];\n                  MngInfoDiscardObject(mng_info,i);\n                }\n              }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n            continue;\n          }\n\n        if (memcmp(type,mng_MOVE,4) == 0)\n          {\n            size_t\n              first_object,\n              last_object;\n\n            /* read MOVE */\n\n            if (length > 3)\n            {\n              first_object=(p[0] << 8) | p[1];\n              last_object=(p[2] << 8) | p[3];\n              p+=4;\n\n              for (i=(ssize_t) first_object; i <= (ssize_t) last_object; i++)\n              {\n                if ((i < 0) || (i >= MNG_MAX_OBJECTS))\n                  continue;\n\n                if (mng_info->exists[i] && !mng_info->frozen[i] &&\n                    (p-chunk) < (ssize_t) (length-8))\n                  {\n                    MngPair\n                      new_pair;\n\n                    MngPair\n                      old_pair;\n\n                    old_pair.a=mng_info->x_off[i];\n                    old_pair.b=mng_info->y_off[i];\n                    new_pair=mng_read_pair(old_pair,(int) p[0],&p[1]);\n                    mng_info->x_off[i]=new_pair.a;\n                    mng_info->y_off[i]=new_pair.b;\n                  }\n              }\n            }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_LOOP,4) == 0)\n          {\n            ssize_t loop_iters=1;\n            if (length > 4)\n              {\n                loop_level=chunk[0];\n                mng_info->loop_active[loop_level]=1;  /* mark loop active */\n\n                /* Record starting point.  */\n                loop_iters=mng_get_long(&chunk[1]);\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  LOOP level %.20g has %.20g iterations \",\n                    (double) loop_level, (double) loop_iters);\n\n                if (loop_iters <= 0)\n                  skipping_loop=loop_level;\n\n                else\n                  {\n                    if ((MagickSizeType) loop_iters > GetMagickResourceLimit(ListLengthResource))\n                      loop_iters=GetMagickResourceLimit(ListLengthResource);\n                    if (loop_iters >= 2147483647L)\n                      loop_iters=2147483647L;\n                    mng_info->loop_jump[loop_level]=TellBlob(image);\n                    mng_info->loop_count[loop_level]=loop_iters;\n                  }\n\n                mng_info->loop_iteration[loop_level]=0;\n              }\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_ENDL,4) == 0)\n          {\n            if (length > 0)\n              {\n                loop_level=chunk[0];\n\n                if (skipping_loop > 0)\n                  {\n                    if (skipping_loop == loop_level)\n                      {\n                        /*\n                          Found end of zero-iteration loop.\n                        */\n                        skipping_loop=(-1);\n                        mng_info->loop_active[loop_level]=0;\n                      }\n                  }\n\n                else\n                  {\n                    if (mng_info->loop_active[loop_level] == 1)\n                      {\n                        mng_info->loop_count[loop_level]--;\n                        mng_info->loop_iteration[loop_level]++;\n\n                        if (logging != MagickFalse)\n                          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                          \"  ENDL: LOOP level %.20g has %.20g remaining iters\",\n                            (double) loop_level,(double)\n                            mng_info->loop_count[loop_level]);\n\n                        if (mng_info->loop_count[loop_level] > 0)\n                          {\n                            offset=\n                              SeekBlob(image,mng_info->loop_jump[loop_level],\n                              SEEK_SET);\n\n                            if (offset < 0)\n                              {\n                                chunk=(unsigned char *) RelinquishMagickMemory(\n                                  chunk);\n                                ThrowReaderException(CorruptImageError,\n                                  \"ImproperImageHeader\");\n                              }\n                          }\n\n                        else\n                          {\n                            short\n                              last_level;\n\n                            /*\n                              Finished loop.\n                            */\n                            mng_info->loop_active[loop_level]=0;\n                            last_level=(-1);\n                            for (i=0; i < loop_level; i++)\n                              if (mng_info->loop_active[i] == 1)\n                                last_level=(short) i;\n                            loop_level=last_level;\n                          }\n                      }\n                  }\n              }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_CLON,4) == 0)\n          {\n            if (mng_info->clon_warning == 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CoderError,\"CLON is not implemented yet\",\"`%s'\",\n                image->filename);\n\n            mng_info->clon_warning++;\n          }\n\n        if (memcmp(type,mng_MAGN,4) == 0)\n          {\n            png_uint_16\n              magn_first,\n              magn_last,\n              magn_mb,\n              magn_ml,\n              magn_mr,\n              magn_mt,\n              magn_mx,\n              magn_my,\n              magn_methx,\n              magn_methy;\n\n            if (length > 1)\n              magn_first=(p[0] << 8) | p[1];\n\n            else\n              magn_first=0;\n\n            if (length > 3)\n              magn_last=(p[2] << 8) | p[3];\n\n            else\n              magn_last=magn_first;\n#ifndef MNG_OBJECT_BUFFERS\n            if (magn_first || magn_last)\n              if (mng_info->magn_warning == 0)\n                {\n                  (void) ThrowMagickException(exception,\n                     GetMagickModule(),CoderError,\n                     \"MAGN is not implemented yet for nonzero objects\",\n                     \"`%s'\",image->filename);\n\n                   mng_info->magn_warning++;\n                }\n#endif\n            if (length > 4)\n              magn_methx=p[4];\n\n            else\n              magn_methx=0;\n\n            if (length > 6)\n              magn_mx=(p[5] << 8) | p[6];\n\n            else\n              magn_mx=1;\n\n            if (magn_mx == 0)\n              magn_mx=1;\n\n            if (length > 8)\n              magn_my=(p[7] << 8) | p[8];\n\n            else\n              magn_my=magn_mx;\n\n            if (magn_my == 0)\n              magn_my=1;\n\n            if (length > 10)\n              magn_ml=(p[9] << 8) | p[10];\n\n            else\n              magn_ml=magn_mx;\n\n            if (magn_ml == 0)\n              magn_ml=1;\n\n            if (length > 12)\n              magn_mr=(p[11] << 8) | p[12];\n\n            else\n              magn_mr=magn_mx;\n\n            if (magn_mr == 0)\n              magn_mr=1;\n\n            if (length > 14)\n              magn_mt=(p[13] << 8) | p[14];\n\n            else\n              magn_mt=magn_my;\n\n            if (magn_mt == 0)\n              magn_mt=1;\n\n            if (length > 16)\n              magn_mb=(p[15] << 8) | p[16];\n\n            else\n              magn_mb=magn_my;\n\n            if (magn_mb == 0)\n              magn_mb=1;\n\n            if (length > 17)\n              magn_methy=p[17];\n\n            else\n              magn_methy=magn_methx;\n\n\n            if (magn_methx > 5 || magn_methy > 5)\n              if (mng_info->magn_warning == 0)\n                {\n                  (void) ThrowMagickException(exception,\n                     GetMagickModule(),CoderError,\n                     \"Unknown MAGN method in MNG datastream\",\"`%s'\",\n                     image->filename);\n\n                   mng_info->magn_warning++;\n                }\n#ifdef MNG_OBJECT_BUFFERS\n          /* Magnify existing objects in the range magn_first to magn_last */\n#endif\n            if (magn_first == 0 || magn_last == 0)\n              {\n                /* Save the magnification factors for object 0 */\n                mng_info->magn_mb=magn_mb;\n                mng_info->magn_ml=magn_ml;\n                mng_info->magn_mr=magn_mr;\n                mng_info->magn_mt=magn_mt;\n                mng_info->magn_mx=magn_mx;\n                mng_info->magn_my=magn_my;\n                mng_info->magn_methx=magn_methx;\n                mng_info->magn_methy=magn_methy;\n              }\n          }\n\n        if (memcmp(type,mng_PAST,4) == 0)\n          {\n            if (mng_info->past_warning == 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CoderError,\"PAST is not implemented yet\",\"`%s'\",\n                image->filename);\n\n            mng_info->past_warning++;\n          }\n\n        if (memcmp(type,mng_SHOW,4) == 0)\n          {\n            if (mng_info->show_warning == 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CoderError,\"SHOW is not implemented yet\",\"`%s'\",\n                image->filename);\n\n            mng_info->show_warning++;\n          }\n\n        if (memcmp(type,mng_sBIT,4) == 0)\n          {\n            if (length < 4)\n              mng_info->have_global_sbit=MagickFalse;\n\n            else\n              {\n                mng_info->global_sbit.gray=p[0];\n                mng_info->global_sbit.red=p[0];\n                mng_info->global_sbit.green=p[1];\n                mng_info->global_sbit.blue=p[2];\n                mng_info->global_sbit.alpha=p[3];\n                mng_info->have_global_sbit=MagickTrue;\n             }\n          }\n        if (memcmp(type,mng_pHYs,4) == 0)\n          {\n            if (length > 8)\n              {\n                mng_info->global_x_pixels_per_unit=\n                    (size_t) mng_get_long(p);\n                mng_info->global_y_pixels_per_unit=\n                    (size_t) mng_get_long(&p[4]);\n                mng_info->global_phys_unit_type=p[8];\n                mng_info->have_global_phys=MagickTrue;\n              }\n\n            else\n              mng_info->have_global_phys=MagickFalse;\n          }\n        if (memcmp(type,mng_pHYg,4) == 0)\n          {\n            if (mng_info->phyg_warning == 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CoderError,\"pHYg is not implemented.\",\"`%s'\",image->filename);\n\n            mng_info->phyg_warning++;\n          }\n        if (memcmp(type,mng_BASI,4) == 0)\n          {\n            skip_to_iend=MagickTrue;\n\n            if (mng_info->basi_warning == 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CoderError,\"BASI is not implemented yet\",\"`%s'\",\n                image->filename);\n\n            mng_info->basi_warning++;\n#ifdef MNG_BASI_SUPPORTED\n            basi_width=(unsigned long) mng_get_long(p);\n            basi_width=(unsigned long) mng_get_long(&p[4]);\n            basi_color_type=p[8];\n            basi_compression_method=p[9];\n            basi_filter_type=p[10];\n            basi_interlace_method=p[11];\n            if (length > 11)\n              basi_red=((png_uint_32) p[12] << 8) & (png_uint_32) p[13];\n\n            else\n              basi_red=0;\n\n            if (length > 13)\n              basi_green=((png_uint_32) p[14] << 8) & (png_uint_32) p[15];\n\n            else\n              basi_green=0;\n\n            if (length > 15)\n              basi_blue=((png_uint_32) p[16] << 8) & (png_uint_32) p[17];\n\n            else\n              basi_blue=0;\n\n            if (length > 17)\n              basi_alpha=((png_uint_32) p[18] << 8) & (png_uint_32) p[19];\n\n            else\n              {\n                if (basi_sample_depth == 16)\n                  basi_alpha=65535L;\n                else\n                  basi_alpha=255;\n              }\n\n            if (length > 19)\n              basi_viewable=p[20];\n\n            else\n              basi_viewable=0;\n\n#endif\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_IHDR,4)\n#if defined(JNG_SUPPORTED)\n            && memcmp(type,mng_JHDR,4)\n#endif\n            )\n          {\n            /* Not an IHDR or JHDR chunk */\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n            continue;\n          }\n/* Process IHDR */\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Processing %c%c%c%c chunk\",type[0],type[1],type[2],type[3]);\n\n        mng_info->exists[object_id]=MagickTrue;\n        mng_info->viewable[object_id]=MagickTrue;\n\n        if (mng_info->invisible[object_id])\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Skipping invisible object\");\n\n            skip_to_iend=MagickTrue;\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n#if defined(MNG_INSERT_LAYERS)\n        if (length < 8)\n          {\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n          }\n\n        image_width=(size_t) mng_get_long(p);\n        image_height=(size_t) mng_get_long(&p[4]);\n#endif\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        /*\n          Insert a transparent background layer behind the entire animation\n          if it is not full screen.\n        */\n#if defined(MNG_INSERT_LAYERS)\n        if (insert_layers && mng_type && first_mng_object)\n          {\n            if ((mng_info->clip.left > 0) || (mng_info->clip.top > 0) ||\n                (image_width < mng_info->mng_width) ||\n                (mng_info->clip.right < (ssize_t) mng_info->mng_width) ||\n                (image_height < mng_info->mng_height) ||\n                (mng_info->clip.bottom < (ssize_t) mng_info->mng_height))\n              {\n                if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n                  {\n                    /*\n                      Allocate next image structure.\n                    */\n                    AcquireNextImage(image_info,image,exception);\n\n                    if (GetNextImageInList(image) == (Image *) NULL)\n                      return(DestroyImageList(image));\n\n                    image=SyncNextImageInList(image);\n                  }\n                mng_info->image=image;\n\n                if (term_chunk_found)\n                  {\n                    image->start_loop=MagickTrue;\n                    image->iterations=mng_iterations;\n                    term_chunk_found=MagickFalse;\n                  }\n\n                else\n                    image->start_loop=MagickFalse;\n\n                /* Make a background rectangle.  */\n\n                image->delay=0;\n                image->columns=mng_info->mng_width;\n                image->rows=mng_info->mng_height;\n                image->page.width=mng_info->mng_width;\n                image->page.height=mng_info->mng_height;\n                image->page.x=0;\n                image->page.y=0;\n                image->background_color=mng_background_color;\n                (void) SetImageBackgroundColor(image,exception);\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  Inserted transparent background layer, W=%.20g, H=%.20g\",\n                    (double) mng_info->mng_width,(double) mng_info->mng_height);\n              }\n          }\n        /*\n          Insert a background layer behind the upcoming image if\n          framing_mode is 3, and we haven't already inserted one.\n        */\n        if (insert_layers && (mng_info->framing_mode == 3) &&\n                (subframe_width) && (subframe_height) && (simplicity == 0 ||\n                (simplicity & 0x08)))\n          {\n            if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n            {\n              /*\n                Allocate next image structure.\n              */\n              AcquireNextImage(image_info,image,exception);\n\n              if (GetNextImageInList(image) == (Image *) NULL)\n                return(DestroyImageList(image));\n\n              image=SyncNextImageInList(image);\n            }\n\n            mng_info->image=image;\n\n            if (term_chunk_found)\n              {\n                image->start_loop=MagickTrue;\n                image->iterations=mng_iterations;\n                term_chunk_found=MagickFalse;\n              }\n\n            else\n                image->start_loop=MagickFalse;\n\n            image->delay=0;\n            image->columns=subframe_width;\n            image->rows=subframe_height;\n            image->page.width=subframe_width;\n            image->page.height=subframe_height;\n            image->page.x=mng_info->clip.left;\n            image->page.y=mng_info->clip.top;\n            image->background_color=mng_background_color;\n            image->alpha_trait=UndefinedPixelTrait;\n            (void) SetImageBackgroundColor(image,exception);\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Insert background layer, L=%.20g, R=%.20g T=%.20g, B=%.20g\",\n                (double) mng_info->clip.left,(double) mng_info->clip.right,\n                (double) mng_info->clip.top,(double) mng_info->clip.bottom);\n          }\n#endif /* MNG_INSERT_LAYERS */\n        first_mng_object=MagickFalse;\n\n        if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n          {\n            /*\n              Allocate next image structure.\n            */\n            AcquireNextImage(image_info,image,exception);\n\n            if (GetNextImageInList(image) == (Image *) NULL)\n              return(DestroyImageList(image));\n\n            image=SyncNextImageInList(image);\n          }\n        mng_info->image=image;\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n\n        if (status == MagickFalse)\n          break;\n\n        if (term_chunk_found)\n          {\n            image->start_loop=MagickTrue;\n            term_chunk_found=MagickFalse;\n          }\n\n        else\n            image->start_loop=MagickFalse;\n\n        if (mng_info->framing_mode == 1 || mng_info->framing_mode == 3)\n          {\n            image->delay=frame_delay;\n            frame_delay=default_frame_delay;\n          }\n\n        else\n          image->delay=0;\n\n        image->page.width=mng_info->mng_width;\n        image->page.height=mng_info->mng_height;\n        image->page.x=mng_info->x_off[object_id];\n        image->page.y=mng_info->y_off[object_id];\n        image->iterations=mng_iterations;\n\n        /*\n          Seek back to the beginning of the IHDR or JHDR chunk's length field.\n        */\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Seeking back to beginning of %c%c%c%c chunk\",type[0],type[1],\n            type[2],type[3]);\n\n        offset=SeekBlob(image,-((ssize_t) length+12),SEEK_CUR);\n\n        if (offset < 0)\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n\n    mng_info->image=image;\n    mng_info->mng_type=mng_type;\n    mng_info->object_id=object_id;\n\n    if (memcmp(type,mng_IHDR,4) == 0)\n      image=ReadOnePNGImage(mng_info,image_info,exception);\n\n#if defined(JNG_SUPPORTED)\n    else\n      image=ReadOneJNGImage(mng_info,image_info,exception);\n#endif\n\n    if (image == (Image *) NULL)\n      {\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"exit ReadJNGImage() with error\");\n\n        return((Image *) NULL);\n      }\n\n    if (image->columns == 0 || image->rows == 0)\n      {\n        (void) CloseBlob(image);\n        return(DestroyImageList(image));\n      }\n\n    mng_info->image=image;\n\n    if (mng_type)\n      {\n        MngBox\n          crop_box;\n\n        if (((mng_info->magn_methx > 0) && (mng_info->magn_methx <= 5)) &&\n            ((mng_info->magn_methy > 0) && (mng_info->magn_methy <= 5)))\n          {\n            png_uint_32\n               magnified_height,\n               magnified_width;\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Processing MNG MAGN chunk\");\n\n            if (mng_info->magn_methx == 1)\n              {\n                magnified_width=mng_info->magn_ml;\n\n                if (image->columns > 1)\n                   magnified_width += mng_info->magn_mr;\n\n                if (image->columns > 2)\n                   magnified_width += (png_uint_32)\n                      ((image->columns-2)*(mng_info->magn_mx));\n              }\n\n            else\n              {\n                magnified_width=(png_uint_32) image->columns;\n\n                if (image->columns > 1)\n                   magnified_width += mng_info->magn_ml-1;\n\n                if (image->columns > 2)\n                   magnified_width += mng_info->magn_mr-1;\n\n                if (image->columns > 3)\n                   magnified_width += (png_uint_32)\n                      ((image->columns-3)*(mng_info->magn_mx-1));\n              }\n\n            if (mng_info->magn_methy == 1)\n              {\n                magnified_height=mng_info->magn_mt;\n\n                if (image->rows > 1)\n                   magnified_height += mng_info->magn_mb;\n\n                if (image->rows > 2)\n                   magnified_height += (png_uint_32)\n                      ((image->rows-2)*(mng_info->magn_my));\n              }\n\n            else\n              {\n                magnified_height=(png_uint_32) image->rows;\n\n                if (image->rows > 1)\n                   magnified_height += mng_info->magn_mt-1;\n\n                if (image->rows > 2)\n                   magnified_height += mng_info->magn_mb-1;\n\n                if (image->rows > 3)\n                   magnified_height += (png_uint_32)\n                      ((image->rows-3)*(mng_info->magn_my-1));\n              }\n\n            if (magnified_height > image->rows ||\n                magnified_width > image->columns)\n              {\n                Image\n                  *large_image;\n\n                int\n                  yy;\n\n                Quantum\n                  *next,\n                  *prev;\n\n                png_uint_16\n                  magn_methx,\n                  magn_methy;\n\n                ssize_t\n                  m,\n                  y;\n\n                register Quantum\n                  *n,\n                  *q;\n\n                register ssize_t\n                  x;\n\n                /* Allocate next image structure.  */\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Allocate magnified image\");\n\n                AcquireNextImage(image_info,image,exception);\n\n                if (GetNextImageInList(image) == (Image *) NULL)\n                  return(DestroyImageList(image));\n\n                large_image=SyncNextImageInList(image);\n\n                large_image->columns=magnified_width;\n                large_image->rows=magnified_height;\n\n                magn_methx=mng_info->magn_methx;\n                magn_methy=mng_info->magn_methy;\n\n#if (MAGICKCORE_QUANTUM_DEPTH > 16)\n#define QM unsigned short\n                if (magn_methx != 1 || magn_methy != 1)\n                  {\n                  /*\n                     Scale pixels to unsigned shorts to prevent\n                     overflow of intermediate values of interpolations\n                  */\n                     for (y=0; y < (ssize_t) image->rows; y++)\n                     {\n                       q=GetAuthenticPixels(image,0,y,image->columns,1,\n                          exception);\n                       if (q == (Quantum *) NULL)\n                         break;\n                       for (x=(ssize_t) image->columns-1; x >= 0; x--)\n                       {\n                          SetPixelRed(image,ScaleQuantumToShort(\n                            GetPixelRed(image,q)),q);\n                          SetPixelGreen(image,ScaleQuantumToShort(\n                            GetPixelGreen(image,q)),q);\n                          SetPixelBlue(image,ScaleQuantumToShort(\n                            GetPixelBlue(image,q)),q);\n                          SetPixelAlpha(image,ScaleQuantumToShort(\n                            GetPixelAlpha(image,q)),q);\n                          q+=GetPixelChannels(image);\n                       }\n\n                       if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                         break;\n                     }\n                  }\n#else\n#define QM Quantum\n#endif\n\n                if (image->alpha_trait != UndefinedPixelTrait)\n                   (void) SetImageBackgroundColor(large_image,exception);\n\n                else\n                  {\n                    large_image->background_color.alpha=OpaqueAlpha;\n                    (void) SetImageBackgroundColor(large_image,exception);\n\n                    if (magn_methx == 4)\n                      magn_methx=2;\n\n                    if (magn_methx == 5)\n                      magn_methx=3;\n\n                    if (magn_methy == 4)\n                      magn_methy=2;\n\n                    if (magn_methy == 5)\n                      magn_methy=3;\n                  }\n\n                /* magnify the rows into the right side of the large image */\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Magnify the rows to %.20g\",\n                    (double) large_image->rows);\n                m=(ssize_t) mng_info->magn_mt;\n                yy=0;\n                length=(size_t) GetPixelChannels(image)*image->columns;\n                next=(Quantum *) AcquireQuantumMemory(length,sizeof(*next));\n                prev=(Quantum *) AcquireQuantumMemory(length,sizeof(*prev));\n\n                if ((prev == (Quantum *) NULL) ||\n                    (next == (Quantum *) NULL))\n                  {\n                    if (prev != (Quantum *) NULL)\n                      prev=(Quantum *) RelinquishMagickMemory(prev);\n                    if (next != (Quantum *) NULL)\n                      next=(Quantum *) RelinquishMagickMemory(next);\n                    image=DestroyImageList(image);\n                    ThrowReaderException(ResourceLimitError,\n                      \"MemoryAllocationFailed\");\n                  }\n\n                n=GetAuthenticPixels(image,0,0,image->columns,1,exception);\n                (void) memcpy(next,n,length);\n\n                for (y=0; y < (ssize_t) image->rows; y++)\n                {\n                  if (y == 0)\n                    m=(ssize_t) mng_info->magn_mt;\n\n                  else if (magn_methy > 1 && y == (ssize_t) image->rows-2)\n                    m=(ssize_t) mng_info->magn_mb;\n\n                  else if (magn_methy <= 1 && y == (ssize_t) image->rows-1)\n                    m=(ssize_t) mng_info->magn_mb;\n\n                  else if (magn_methy > 1 && y == (ssize_t) image->rows-1)\n                    m=1;\n\n                  else\n                    m=(ssize_t) mng_info->magn_my;\n\n                  n=prev;\n                  prev=next;\n                  next=n;\n\n                  if (y < (ssize_t) image->rows-1)\n                    {\n                      n=GetAuthenticPixels(image,0,y+1,image->columns,1,\n                          exception);\n                      (void) memcpy(next,n,length);\n                    }\n\n                  for (i=0; i < m; i++, yy++)\n                  {\n                    register Quantum\n                      *pixels;\n\n                    assert(yy < (ssize_t) large_image->rows);\n                    pixels=prev;\n                    n=next;\n                    q=GetAuthenticPixels(large_image,0,yy,large_image->columns,\n                      1,exception);\n                    if (q == (Quantum *) NULL)\n                      break;\n                    q+=(large_image->columns-image->columns)*\n                      GetPixelChannels(large_image);\n\n                    for (x=(ssize_t) image->columns-1; x >= 0; x--)\n                    {\n                      /* To do: get color as function of indexes[x] */\n                      /*\n                      if (image->storage_class == PseudoClass)\n                        {\n                        }\n                      */\n\n                      if (magn_methy <= 1)\n                        {\n                          /* replicate previous */\n                          SetPixelRed(large_image,GetPixelRed(image,pixels),q);\n                          SetPixelGreen(large_image,GetPixelGreen(image,\n                             pixels),q);\n                          SetPixelBlue(large_image,GetPixelBlue(image,\n                             pixels),q);\n                          SetPixelAlpha(large_image,GetPixelAlpha(image,\n                             pixels),q);\n                        }\n\n                      else if (magn_methy == 2 || magn_methy == 4)\n                        {\n                          if (i == 0)\n                            {\n                              SetPixelRed(large_image,GetPixelRed(image,\n                                 pixels),q);\n                              SetPixelGreen(large_image,GetPixelGreen(image,\n                                 pixels),q);\n                              SetPixelBlue(large_image,GetPixelBlue(image,\n                                 pixels),q);\n                              SetPixelAlpha(large_image,GetPixelAlpha(image,\n                                 pixels),q);\n                            }\n\n                          else\n                            {\n                              /* Interpolate */\n                              SetPixelRed(large_image,((QM) (((ssize_t)\n                                 (2*i*(GetPixelRed(image,n)\n                                 -GetPixelRed(image,pixels)+m))/\n                                 ((ssize_t) (m*2))\n                                 +GetPixelRed(image,pixels)))),q);\n                              SetPixelGreen(large_image,((QM) (((ssize_t)\n                                 (2*i*(GetPixelGreen(image,n)\n                                 -GetPixelGreen(image,pixels)+m))/\n                                 ((ssize_t) (m*2))\n                                 +GetPixelGreen(image,pixels)))),q);\n                              SetPixelBlue(large_image,((QM) (((ssize_t)\n                                 (2*i*(GetPixelBlue(image,n)\n                                 -GetPixelBlue(image,pixels)+m))/\n                                 ((ssize_t) (m*2))\n                                 +GetPixelBlue(image,pixels)))),q);\n\n                              if (image->alpha_trait != UndefinedPixelTrait)\n                                 SetPixelAlpha(large_image, ((QM) (((ssize_t)\n                                    (2*i*(GetPixelAlpha(image,n)\n                                    -GetPixelAlpha(image,pixels)+m))\n                                    /((ssize_t) (m*2))+\n                                   GetPixelAlpha(image,pixels)))),q);\n                            }\n\n                          if (magn_methy == 4)\n                            {\n                              /* Replicate nearest */\n                              if (i <= ((m+1) << 1))\n                                 SetPixelAlpha(large_image,GetPixelAlpha(image,\n                                    pixels),q);\n                              else\n                                 SetPixelAlpha(large_image,GetPixelAlpha(image,\n                                    n),q);\n                            }\n                        }\n\n                      else /* if (magn_methy == 3 || magn_methy == 5) */\n                        {\n                          /* Replicate nearest */\n                          if (i <= ((m+1) << 1))\n                          {\n                             SetPixelRed(large_image,GetPixelRed(image,\n                                    pixels),q);\n                             SetPixelGreen(large_image,GetPixelGreen(image,\n                                    pixels),q);\n                             SetPixelBlue(large_image,GetPixelBlue(image,\n                                    pixels),q);\n                             SetPixelAlpha(large_image,GetPixelAlpha(image,\n                                    pixels),q);\n                          }\n\n                          else\n                          {\n                             SetPixelRed(large_image,GetPixelRed(image,n),q);\n                             SetPixelGreen(large_image,GetPixelGreen(image,n),\n                                    q);\n                             SetPixelBlue(large_image,GetPixelBlue(image,n),\n                                    q);\n                             SetPixelAlpha(large_image,GetPixelAlpha(image,n),\n                                    q);\n                          }\n\n                          if (magn_methy == 5)\n                            {\n                              SetPixelAlpha(large_image,(QM) (((ssize_t) (2*i*\n                                 (GetPixelAlpha(image,n)\n                                 -GetPixelAlpha(image,pixels))\n                                 +m))/((ssize_t) (m*2))\n                                 +GetPixelAlpha(image,pixels)),q);\n                            }\n                        }\n                      n+=GetPixelChannels(image);\n                      q+=GetPixelChannels(large_image);\n                      pixels+=GetPixelChannels(image);\n                    } /* x */\n\n                    if (SyncAuthenticPixels(large_image,exception) == 0)\n                      break;\n\n                  } /* i */\n                } /* y */\n\n                prev=(Quantum *) RelinquishMagickMemory(prev);\n                next=(Quantum *) RelinquishMagickMemory(next);\n\n                length=image->columns;\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Delete original image\");\n\n                DeleteImageFromList(&image);\n\n                image=large_image;\n\n                mng_info->image=image;\n\n                /* magnify the columns */\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Magnify the columns to %.20g\",\n                    (double) image->columns);\n\n                for (y=0; y < (ssize_t) image->rows; y++)\n                {\n                  register Quantum\n                    *pixels;\n\n                  q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n                  if (q == (Quantum *) NULL)\n                    break;\n                  pixels=q+(image->columns-length)*GetPixelChannels(image);\n                  n=pixels+GetPixelChannels(image);\n\n                  for (x=(ssize_t) (image->columns-length);\n                    x < (ssize_t) image->columns; x++)\n                  {\n                    /* To do: Rewrite using Get/Set***PixelChannel() */\n\n                    if (x == (ssize_t) (image->columns-length))\n                      m=(ssize_t) mng_info->magn_ml;\n\n                    else if (magn_methx > 1 && x == (ssize_t) image->columns-2)\n                      m=(ssize_t) mng_info->magn_mr;\n\n                    else if (magn_methx <= 1 &&\n                        x == (ssize_t) image->columns-1)\n                      m=(ssize_t) mng_info->magn_mr;\n\n                    else if (magn_methx > 1 && x == (ssize_t) image->columns-1)\n                      m=1;\n\n                    else\n                      m=(ssize_t) mng_info->magn_mx;\n\n                    for (i=0; i < m; i++)\n                    {\n                      if (magn_methx <= 1)\n                        {\n                          /* replicate previous */\n                          SetPixelRed(image,GetPixelRed(image,pixels),q);\n                          SetPixelGreen(image,GetPixelGreen(image,pixels),q);\n                          SetPixelBlue(image,GetPixelBlue(image,pixels),q);\n                          SetPixelAlpha(image,GetPixelAlpha(image,pixels),q);\n                        }\n\n                      else if (magn_methx == 2 || magn_methx == 4)\n                        {\n                          if (i == 0)\n                          {\n                            SetPixelRed(image,GetPixelRed(image,pixels),q);\n                            SetPixelGreen(image,GetPixelGreen(image,pixels),q);\n                            SetPixelBlue(image,GetPixelBlue(image,pixels),q);\n                            SetPixelAlpha(image,GetPixelAlpha(image,pixels),q);\n                          }\n\n                          /* To do: Rewrite using Get/Set***PixelChannel() */\n                          else\n                            {\n                              /* Interpolate */\n                              SetPixelRed(image,(QM) ((2*i*(\n                                 GetPixelRed(image,n)\n                                 -GetPixelRed(image,pixels))+m)\n                                 /((ssize_t) (m*2))+\n                                 GetPixelRed(image,pixels)),q);\n\n                              SetPixelGreen(image,(QM) ((2*i*(\n                                 GetPixelGreen(image,n)\n                                 -GetPixelGreen(image,pixels))+m)\n                                 /((ssize_t) (m*2))+\n                                 GetPixelGreen(image,pixels)),q);\n\n                              SetPixelBlue(image,(QM) ((2*i*(\n                                 GetPixelBlue(image,n)\n                                 -GetPixelBlue(image,pixels))+m)\n                                 /((ssize_t) (m*2))+\n                                 GetPixelBlue(image,pixels)),q);\n                              if (image->alpha_trait != UndefinedPixelTrait)\n                                 SetPixelAlpha(image,(QM) ((2*i*(\n                                   GetPixelAlpha(image,n)\n                                   -GetPixelAlpha(image,pixels))+m)\n                                   /((ssize_t) (m*2))+\n                                   GetPixelAlpha(image,pixels)),q);\n                            }\n\n                          if (magn_methx == 4)\n                            {\n                              /* Replicate nearest */\n                              if (i <= ((m+1) << 1))\n                              {\n                                 SetPixelAlpha(image,\n                                   GetPixelAlpha(image,pixels)+0,q);\n                              }\n                              else\n                              {\n                                 SetPixelAlpha(image,\n                                   GetPixelAlpha(image,n)+0,q);\n                              }\n                            }\n                        }\n\n                      else /* if (magn_methx == 3 || magn_methx == 5) */\n                        {\n                          /* Replicate nearest */\n                          if (i <= ((m+1) << 1))\n                          {\n                             SetPixelRed(image,GetPixelRed(image,pixels),q);\n                             SetPixelGreen(image,GetPixelGreen(image,\n                                 pixels),q);\n                             SetPixelBlue(image,GetPixelBlue(image,pixels),q);\n                             SetPixelAlpha(image,GetPixelAlpha(image,\n                                 pixels),q);\n                          }\n\n                          else\n                          {\n                             SetPixelRed(image,GetPixelRed(image,n),q);\n                             SetPixelGreen(image,GetPixelGreen(image,n),q);\n                             SetPixelBlue(image,GetPixelBlue(image,n),q);\n                             SetPixelAlpha(image,GetPixelAlpha(image,n),q);\n                          }\n\n                          if (magn_methx == 5)\n                            {\n                              /* Interpolate */\n                              SetPixelAlpha(image,\n                                 (QM) ((2*i*( GetPixelAlpha(image,n)\n                                 -GetPixelAlpha(image,pixels))+m)/\n                                 ((ssize_t) (m*2))\n                                 +GetPixelAlpha(image,pixels)),q);\n                            }\n                        }\n                      q+=GetPixelChannels(image);\n                    }\n                    n+=GetPixelChannels(image);\n                  }\n\n                  if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                    break;\n                }\n#if (MAGICKCORE_QUANTUM_DEPTH > 16)\n              if (magn_methx != 1 || magn_methy != 1)\n                {\n                /*\n                   Rescale pixels to Quantum\n                */\n                   for (y=0; y < (ssize_t) image->rows; y++)\n                   {\n                     q=GetAuthenticPixels(image,0,y,image->columns,1,\n                       exception);\n                     if (q == (Quantum *) NULL)\n                       break;\n\n                     for (x=(ssize_t) image->columns-1; x >= 0; x--)\n                     {\n                        SetPixelRed(image,ScaleShortToQuantum(\n                          GetPixelRed(image,q)),q);\n                        SetPixelGreen(image,ScaleShortToQuantum(\n                          GetPixelGreen(image,q)),q);\n                        SetPixelBlue(image,ScaleShortToQuantum(\n                          GetPixelBlue(image,q)),q);\n                        SetPixelAlpha(image,ScaleShortToQuantum(\n                          GetPixelAlpha(image,q)),q);\n                        q+=GetPixelChannels(image);\n                     }\n\n                     if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                       break;\n                   }\n                }\n#endif\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  Finished MAGN processing\");\n              }\n          }\n\n        /*\n          Crop_box is with respect to the upper left corner of the MNG.\n        */\n        crop_box.left=mng_info->image_box.left+mng_info->x_off[object_id];\n        crop_box.right=mng_info->image_box.right+mng_info->x_off[object_id];\n        crop_box.top=mng_info->image_box.top+mng_info->y_off[object_id];\n        crop_box.bottom=mng_info->image_box.bottom+mng_info->y_off[object_id];\n        crop_box=mng_minimum_box(crop_box,mng_info->clip);\n        crop_box=mng_minimum_box(crop_box,mng_info->frame);\n        crop_box=mng_minimum_box(crop_box,mng_info->object_clip[object_id]);\n        if ((crop_box.left != (mng_info->image_box.left\n            +mng_info->x_off[object_id])) ||\n            (crop_box.right != (mng_info->image_box.right\n            +mng_info->x_off[object_id])) ||\n            (crop_box.top != (mng_info->image_box.top\n            +mng_info->y_off[object_id])) ||\n            (crop_box.bottom != (mng_info->image_box.bottom\n            +mng_info->y_off[object_id])))\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Crop the PNG image\");\n\n            if ((crop_box.left < crop_box.right) &&\n                (crop_box.top < crop_box.bottom))\n              {\n                Image\n                  *im;\n\n                RectangleInfo\n                  crop_info;\n\n                /*\n                  Crop_info is with respect to the upper left corner of\n                  the image.\n                */\n                crop_info.x=(crop_box.left-mng_info->x_off[object_id]);\n                crop_info.y=(crop_box.top-mng_info->y_off[object_id]);\n                crop_info.width=(size_t) (crop_box.right-crop_box.left);\n                crop_info.height=(size_t) (crop_box.bottom-crop_box.top);\n                image->page.width=image->columns;\n                image->page.height=image->rows;\n                image->page.x=0;\n                image->page.y=0;\n                im=CropImage(image,&crop_info,exception);\n\n                if (im != (Image *) NULL)\n                  {\n                    image->columns=im->columns;\n                    image->rows=im->rows;\n                    im=DestroyImage(im);\n                    image->page.width=image->columns;\n                    image->page.height=image->rows;\n                    image->page.x=crop_box.left;\n                    image->page.y=crop_box.top;\n                  }\n              }\n\n            else\n              {\n                /*\n                  No pixels in crop area.  The MNG spec still requires\n                  a layer, though, so make a single transparent pixel in\n                  the top left corner.\n                */\n                image->columns=1;\n                image->rows=1;\n                image->colors=2;\n                (void) SetImageBackgroundColor(image,exception);\n                image->page.width=1;\n                image->page.height=1;\n                image->page.x=0;\n                image->page.y=0;\n              }\n          }\n#ifndef PNG_READ_EMPTY_PLTE_SUPPORTED\n        image=mng_info->image;\n#endif\n      }\n\n#if (MAGICKCORE_QUANTUM_DEPTH > 16)\n      /* PNG does not handle depths greater than 16 so reduce it even\n       * if lossy.\n       */\n      if (image->depth > 16)\n         image->depth=16;\n#endif\n\n#if (MAGICKCORE_QUANTUM_DEPTH > 8)\n      if (image->depth > 8)\n        {\n          /* To do: fill low byte properly */\n          image->depth=16;\n        }\n\n      if (LosslessReduceDepthOK(image,exception) != MagickFalse)\n         image->depth = 8;\n#endif\n\n      if (image_info->number_scenes != 0)\n        {\n          if (mng_info->scenes_found >\n             (ssize_t) (image_info->first_scene+image_info->number_scenes))\n            break;\n        }\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Finished reading image datastream.\");\n\n  } while (LocaleCompare(image_info->magick,\"MNG\") == 0);\n\n  (void) CloseBlob(image);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Finished reading all image datastreams.\");\n\n#if defined(MNG_INSERT_LAYERS)\n  if (insert_layers && !mng_info->image_found && (mng_info->mng_width) &&\n       (mng_info->mng_height))\n    {\n      /*\n        Insert a background layer if nothing else was found.\n      */\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  No images found.  Inserting a background layer.\");\n\n      if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n        {\n          /*\n            Allocate next image structure.\n          */\n          AcquireNextImage(image_info,image,exception);\n          if (GetNextImageInList(image) == (Image *) NULL)\n            {\n              if (logging != MagickFalse)\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Allocation failed, returning NULL.\");\n\n              return(DestroyImageList(image));;\n            }\n          image=SyncNextImageInList(image);\n        }\n      image->columns=mng_info->mng_width;\n      image->rows=mng_info->mng_height;\n      image->page.width=mng_info->mng_width;\n      image->page.height=mng_info->mng_height;\n      image->page.x=0;\n      image->page.y=0;\n      image->background_color=mng_background_color;\n      image->alpha_trait=UndefinedPixelTrait;\n\n      if (image_info->ping == MagickFalse)\n        (void) SetImageBackgroundColor(image,exception);\n\n      mng_info->image_found++;\n    }\n#endif\n  image->iterations=mng_iterations;\n\n  if (mng_iterations == 1)\n    image->start_loop=MagickTrue;\n\n  while (GetPreviousImageInList(image) != (Image *) NULL)\n  {\n    image_count++;\n    if (image_count > 10*mng_info->image_found)\n      {\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  No beginning\");\n\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          CoderError,\"Linked list is corrupted, beginning of list not found\",\n          \"`%s'\",image_info->filename);\n\n        return(DestroyImageList(image));\n      }\n\n    image=GetPreviousImageInList(image);\n\n    if (GetNextImageInList(image) == (Image *) NULL)\n      {\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  Corrupt list\");\n\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          CoderError,\"Linked list is corrupted; next_image is NULL\",\"`%s'\",\n          image_info->filename);\n      }\n  }\n\n  if (mng_info->ticks_per_second && mng_info->image_found > 1 &&\n             GetNextImageInList(image) ==\n     (Image *) NULL)\n    {\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  First image null\");\n\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        CoderError,\"image->next for first image is NULL but shouldn't be.\",\n        \"`%s'\",image_info->filename);\n    }\n\n  if (mng_info->image_found == 0)\n    {\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  No visible images found.\");\n\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        CoderError,\"No visible images in file\",\"`%s'\",image_info->filename);\n\n      return(DestroyImageList(image));\n    }\n\n  if (mng_info->ticks_per_second)\n    final_delay=1UL*MagickMax(image->ticks_per_second,1L)*\n            final_delay/mng_info->ticks_per_second;\n\n  else\n    image->start_loop=MagickTrue;\n\n  /* Find final nonzero image delay */\n  final_image_delay=0;\n\n  while (GetNextImageInList(image) != (Image *) NULL)\n    {\n      if (image->delay)\n        final_image_delay=image->delay;\n\n      image=GetNextImageInList(image);\n    }\n\n  if (final_delay < final_image_delay)\n    final_delay=final_image_delay;\n\n  image->delay=final_delay;\n\n  if (logging != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  image->delay=%.20g, final_delay=%.20g\",(double) image->delay,\n        (double) final_delay);\n\n  if (logging != MagickFalse)\n    {\n      int\n        scene;\n\n      scene=0;\n      image=GetFirstImageInList(image);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Before coalesce:\");\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    scene 0 delay=%.20g\",(double) image->delay);\n\n      while (GetNextImageInList(image) != (Image *) NULL)\n      {\n        image=GetNextImageInList(image);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    scene %.20g delay=%.20g\",(double) scene++,\n          (double) image->delay);\n      }\n    }\n\n  image=GetFirstImageInList(image);\n#ifdef MNG_COALESCE_LAYERS\n  if (insert_layers && image->next)\n    {\n      Image\n        *next_image,\n        *next;\n\n      size_t\n        scene;\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Coalesce Images\");\n\n      scene=image->scene;\n      next_image=CoalesceImages(image,exception);\n      image=DestroyImageList(image);\n      if (next_image == (Image *) NULL)\n        return((Image *) NULL);\n      image=next_image;\n\n      for (next=image; next != (Image *) NULL; next=next_image)\n      {\n         next->page.width=mng_info->mng_width;\n         next->page.height=mng_info->mng_height;\n         next->page.x=0;\n         next->page.y=0;\n         next->scene=scene++;\n         next_image=GetNextImageInList(next);\n\n         if (next_image == (Image *) NULL)\n           break;\n\n         if (next->delay == 0)\n           {\n             scene--;\n             next_image->previous=GetPreviousImageInList(next);\n             if (GetPreviousImageInList(next) == (Image *) NULL)\n               image=next_image;\n             else\n               next->previous->next=next_image;\n             next=DestroyImage(next);\n           }\n      }\n    }\n#endif\n\n  while (GetNextImageInList(image) != (Image *) NULL)\n      image=GetNextImageInList(image);\n\n  image->dispose=BackgroundDispose;\n\n  if (logging != MagickFalse)\n    {\n      int\n        scene;\n\n      scene=0;\n      image=GetFirstImageInList(image);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  After coalesce:\");\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    scene 0 delay=%.20g dispose=%.20g\",(double) image->delay,\n        (double) image->dispose);\n\n      while (GetNextImageInList(image) != (Image *) NULL)\n      {\n        image=GetNextImageInList(image);\n\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    scene %.20g delay=%.20g dispose=%.20g\",(double) scene++,\n          (double) image->delay,(double) image->dispose);\n      }\n   }\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  exit ReadOneMNGImage();\");\n\n  return(image);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146475,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "nfqnl_build_packet_message(struct net *net, struct nfqnl_instance *queue,\n\t\t\t   struct nf_queue_entry *entry,\n\t\t\t   __be32 **packet_id_ptr)\n{\n\tsize_t size;\n\tsize_t data_len = 0, cap_len = 0;\n\tunsigned int hlen = 0;\n\tstruct sk_buff *skb;\n\tstruct nlattr *nla;\n\tstruct nfqnl_msg_packet_hdr *pmsg;\n\tstruct nlmsghdr *nlh;\n\tstruct nfgenmsg *nfmsg;\n\tstruct sk_buff *entskb = entry->skb;\n\tstruct net_device *indev;\n\tstruct net_device *outdev;\n\tstruct nf_conn *ct = NULL;\n\tenum ip_conntrack_info uninitialized_var(ctinfo);\n\tbool csum_verify;\n\n\tsize =    nlmsg_total_size(sizeof(struct nfgenmsg))\n\t\t+ nla_total_size(sizeof(struct nfqnl_msg_packet_hdr))\n\t\t+ nla_total_size(sizeof(u_int32_t))\t/* ifindex */\n\t\t+ nla_total_size(sizeof(u_int32_t))\t/* ifindex */\n#ifdef CONFIG_BRIDGE_NETFILTER\n\t\t+ nla_total_size(sizeof(u_int32_t))\t/* ifindex */\n\t\t+ nla_total_size(sizeof(u_int32_t))\t/* ifindex */\n#endif\n\t\t+ nla_total_size(sizeof(u_int32_t))\t/* mark */\n\t\t+ nla_total_size(sizeof(struct nfqnl_msg_packet_hw))\n\t\t+ nla_total_size(sizeof(u_int32_t))\t/* skbinfo */\n\t\t+ nla_total_size(sizeof(u_int32_t));\t/* cap_len */\n\n\tif (entskb->tstamp.tv64)\n\t\tsize += nla_total_size(sizeof(struct nfqnl_msg_packet_timestamp));\n\n\tif (entry->hook <= NF_INET_FORWARD ||\n\t   (entry->hook == NF_INET_POST_ROUTING && entskb->sk == NULL))\n\t\tcsum_verify = !skb_csum_unnecessary(entskb);\n\telse\n\t\tcsum_verify = false;\n\n\toutdev = entry->outdev;\n\n\tswitch ((enum nfqnl_config_mode)ACCESS_ONCE(queue->copy_mode)) {\n\tcase NFQNL_COPY_META:\n\tcase NFQNL_COPY_NONE:\n\t\tbreak;\n\n\tcase NFQNL_COPY_PACKET:\n\t\tif (!(queue->flags & NFQA_CFG_F_GSO) &&\n\t\t    entskb->ip_summed == CHECKSUM_PARTIAL &&\n\t\t    skb_checksum_help(entskb))\n\t\t\treturn NULL;\n\n\t\tdata_len = ACCESS_ONCE(queue->copy_range);\n\t\tif (data_len > entskb->len)\n\t\t\tdata_len = entskb->len;\n\n\t\thlen = skb_zerocopy_headlen(entskb);\n\t\thlen = min_t(unsigned int, hlen, data_len);\n\t\tsize += sizeof(struct nlattr) + hlen;\n\t\tcap_len = entskb->len;\n\t\tbreak;\n\t}\n\n\tif (queue->flags & NFQA_CFG_F_CONNTRACK)\n\t\tct = nfqnl_ct_get(entskb, &size, &ctinfo);\n\n\tif (queue->flags & NFQA_CFG_F_UID_GID) {\n\t\tsize +=  (nla_total_size(sizeof(u_int32_t))\t/* uid */\n\t\t\t+ nla_total_size(sizeof(u_int32_t)));\t/* gid */\n\t}\n\n\tskb = nfnetlink_alloc_skb(net, size, queue->peer_portid,\n\t\t\t\t  GFP_ATOMIC);\n\tif (!skb)\n\t\treturn NULL;\n\n\tnlh = nlmsg_put(skb, 0, 0,\n\t\t\tNFNL_SUBSYS_QUEUE << 8 | NFQNL_MSG_PACKET,\n\t\t\tsizeof(struct nfgenmsg), 0);\n\tif (!nlh) {\n\t\tkfree_skb(skb);\n\t\treturn NULL;\n\t}\n\tnfmsg = nlmsg_data(nlh);\n\tnfmsg->nfgen_family = entry->pf;\n\tnfmsg->version = NFNETLINK_V0;\n\tnfmsg->res_id = htons(queue->queue_num);\n\n\tnla = __nla_reserve(skb, NFQA_PACKET_HDR, sizeof(*pmsg));\n\tpmsg = nla_data(nla);\n\tpmsg->hw_protocol\t= entskb->protocol;\n\tpmsg->hook\t\t= entry->hook;\n\t*packet_id_ptr\t\t= &pmsg->packet_id;\n\n\tindev = entry->indev;\n\tif (indev) {\n#ifndef CONFIG_BRIDGE_NETFILTER\n\t\tif (nla_put_be32(skb, NFQA_IFINDEX_INDEV, htonl(indev->ifindex)))\n\t\t\tgoto nla_put_failure;\n#else\n\t\tif (entry->pf == PF_BRIDGE) {\n\t\t\t/* Case 1: indev is physical input device, we need to\n\t\t\t * look for bridge group (when called from\n\t\t\t * netfilter_bridge) */\n\t\t\tif (nla_put_be32(skb, NFQA_IFINDEX_PHYSINDEV,\n\t\t\t\t\t htonl(indev->ifindex)) ||\n\t\t\t/* this is the bridge group \"brX\" */\n\t\t\t/* rcu_read_lock()ed by __nf_queue */\n\t\t\t    nla_put_be32(skb, NFQA_IFINDEX_INDEV,\n\t\t\t\t\t htonl(br_port_get_rcu(indev)->br->dev->ifindex)))\n\t\t\t\tgoto nla_put_failure;\n\t\t} else {\n\t\t\t/* Case 2: indev is bridge group, we need to look for\n\t\t\t * physical device (when called from ipv4) */\n\t\t\tif (nla_put_be32(skb, NFQA_IFINDEX_INDEV,\n\t\t\t\t\t htonl(indev->ifindex)))\n\t\t\t\tgoto nla_put_failure;\n\t\t\tif (entskb->nf_bridge && entskb->nf_bridge->physindev &&\n\t\t\t    nla_put_be32(skb, NFQA_IFINDEX_PHYSINDEV,\n\t\t\t\t\t htonl(entskb->nf_bridge->physindev->ifindex)))\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n#endif\n\t}\n\n\tif (outdev) {\n#ifndef CONFIG_BRIDGE_NETFILTER\n\t\tif (nla_put_be32(skb, NFQA_IFINDEX_OUTDEV, htonl(outdev->ifindex)))\n\t\t\tgoto nla_put_failure;\n#else\n\t\tif (entry->pf == PF_BRIDGE) {\n\t\t\t/* Case 1: outdev is physical output device, we need to\n\t\t\t * look for bridge group (when called from\n\t\t\t * netfilter_bridge) */\n\t\t\tif (nla_put_be32(skb, NFQA_IFINDEX_PHYSOUTDEV,\n\t\t\t\t\t htonl(outdev->ifindex)) ||\n\t\t\t/* this is the bridge group \"brX\" */\n\t\t\t/* rcu_read_lock()ed by __nf_queue */\n\t\t\t    nla_put_be32(skb, NFQA_IFINDEX_OUTDEV,\n\t\t\t\t\t htonl(br_port_get_rcu(outdev)->br->dev->ifindex)))\n\t\t\t\tgoto nla_put_failure;\n\t\t} else {\n\t\t\t/* Case 2: outdev is bridge group, we need to look for\n\t\t\t * physical output device (when called from ipv4) */\n\t\t\tif (nla_put_be32(skb, NFQA_IFINDEX_OUTDEV,\n\t\t\t\t\t htonl(outdev->ifindex)))\n\t\t\t\tgoto nla_put_failure;\n\t\t\tif (entskb->nf_bridge && entskb->nf_bridge->physoutdev &&\n\t\t\t    nla_put_be32(skb, NFQA_IFINDEX_PHYSOUTDEV,\n\t\t\t\t\t htonl(entskb->nf_bridge->physoutdev->ifindex)))\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n#endif\n\t}\n\n\tif (entskb->mark &&\n\t    nla_put_be32(skb, NFQA_MARK, htonl(entskb->mark)))\n\t\tgoto nla_put_failure;\n\n\tif (indev && entskb->dev &&\n\t    entskb->mac_header != entskb->network_header) {\n\t\tstruct nfqnl_msg_packet_hw phw;\n\t\tint len;\n\n\t\tmemset(&phw, 0, sizeof(phw));\n\t\tlen = dev_parse_header(entskb, phw.hw_addr);\n\t\tif (len) {\n\t\t\tphw.hw_addrlen = htons(len);\n\t\t\tif (nla_put(skb, NFQA_HWADDR, sizeof(phw), &phw))\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n\t}\n\n\tif (entskb->tstamp.tv64) {\n\t\tstruct nfqnl_msg_packet_timestamp ts;\n\t\tstruct timeval tv = ktime_to_timeval(entskb->tstamp);\n\t\tts.sec = cpu_to_be64(tv.tv_sec);\n\t\tts.usec = cpu_to_be64(tv.tv_usec);\n\n\t\tif (nla_put(skb, NFQA_TIMESTAMP, sizeof(ts), &ts))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif ((queue->flags & NFQA_CFG_F_UID_GID) && entskb->sk &&\n\t    nfqnl_put_sk_uidgid(skb, entskb->sk) < 0)\n\t\tgoto nla_put_failure;\n\n\tif (ct && nfqnl_ct_put(skb, ct, ctinfo) < 0)\n\t\tgoto nla_put_failure;\n\n\tif (cap_len > data_len &&\n\t    nla_put_be32(skb, NFQA_CAP_LEN, htonl(cap_len)))\n\t\tgoto nla_put_failure;\n\n\tif (nfqnl_put_packet_info(skb, entskb, csum_verify))\n\t\tgoto nla_put_failure;\n\n\tif (data_len) {\n\t\tstruct nlattr *nla;\n\n\t\tif (skb_tailroom(skb) < sizeof(*nla) + hlen)\n\t\t\tgoto nla_put_failure;\n\n\t\tnla = (struct nlattr *)skb_put(skb, sizeof(*nla));\n\t\tnla->nla_type = NFQA_PAYLOAD;\n\t\tnla->nla_len = nla_attr_size(data_len);\n\n\t\tskb_zerocopy(skb, entskb, data_len, hlen);\n\t}\n\n\tnlh->nlmsg_len = skb->len;\n\treturn skb;\n\nnla_put_failure:\n\tkfree_skb(skb);\n\tnet_err_ratelimited(\"nf_queue: error creating packet message\\n\");\n\treturn NULL;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146498,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "nfqnl_build_packet_message(struct net *net, struct nfqnl_instance *queue,\n\t\t\t   struct nf_queue_entry *entry,\n\t\t\t   __be32 **packet_id_ptr)\n{\n\tsize_t size;\n\tsize_t data_len = 0, cap_len = 0;\n\tunsigned int hlen = 0;\n\tstruct sk_buff *skb;\n\tstruct nlattr *nla;\n\tstruct nfqnl_msg_packet_hdr *pmsg;\n\tstruct nlmsghdr *nlh;\n\tstruct nfgenmsg *nfmsg;\n\tstruct sk_buff *entskb = entry->skb;\n\tstruct net_device *indev;\n\tstruct net_device *outdev;\n\tstruct nf_conn *ct = NULL;\n\tenum ip_conntrack_info uninitialized_var(ctinfo);\n\tbool csum_verify;\n\n\tsize =    nlmsg_total_size(sizeof(struct nfgenmsg))\n\t\t+ nla_total_size(sizeof(struct nfqnl_msg_packet_hdr))\n\t\t+ nla_total_size(sizeof(u_int32_t))\t/* ifindex */\n\t\t+ nla_total_size(sizeof(u_int32_t))\t/* ifindex */\n#ifdef CONFIG_BRIDGE_NETFILTER\n\t\t+ nla_total_size(sizeof(u_int32_t))\t/* ifindex */\n\t\t+ nla_total_size(sizeof(u_int32_t))\t/* ifindex */\n#endif\n\t\t+ nla_total_size(sizeof(u_int32_t))\t/* mark */\n\t\t+ nla_total_size(sizeof(struct nfqnl_msg_packet_hw))\n\t\t+ nla_total_size(sizeof(u_int32_t))\t/* skbinfo */\n\t\t+ nla_total_size(sizeof(u_int32_t));\t/* cap_len */\n\n\tif (entskb->tstamp.tv64)\n\t\tsize += nla_total_size(sizeof(struct nfqnl_msg_packet_timestamp));\n\n\tif (entry->hook <= NF_INET_FORWARD ||\n\t   (entry->hook == NF_INET_POST_ROUTING && entskb->sk == NULL))\n\t\tcsum_verify = !skb_csum_unnecessary(entskb);\n\telse\n\t\tcsum_verify = false;\n\n\toutdev = entry->outdev;\n\n\tswitch ((enum nfqnl_config_mode)ACCESS_ONCE(queue->copy_mode)) {\n\tcase NFQNL_COPY_META:\n\tcase NFQNL_COPY_NONE:\n\t\tbreak;\n\n\tcase NFQNL_COPY_PACKET:\n\t\tif (!(queue->flags & NFQA_CFG_F_GSO) &&\n\t\t    entskb->ip_summed == CHECKSUM_PARTIAL &&\n\t\t    skb_checksum_help(entskb))\n\t\t\treturn NULL;\n\n\t\tdata_len = ACCESS_ONCE(queue->copy_range);\n\t\tif (data_len > entskb->len)\n\t\t\tdata_len = entskb->len;\n\n\t\thlen = skb_zerocopy_headlen(entskb);\n\t\thlen = min_t(unsigned int, hlen, data_len);\n\t\tsize += sizeof(struct nlattr) + hlen;\n\t\tcap_len = entskb->len;\n\t\tbreak;\n\t}\n\n\tif (queue->flags & NFQA_CFG_F_CONNTRACK)\n\t\tct = nfqnl_ct_get(entskb, &size, &ctinfo);\n\n\tif (queue->flags & NFQA_CFG_F_UID_GID) {\n\t\tsize +=  (nla_total_size(sizeof(u_int32_t))\t/* uid */\n\t\t\t+ nla_total_size(sizeof(u_int32_t)));\t/* gid */\n\t}\n\n\tskb = nfnetlink_alloc_skb(net, size, queue->peer_portid,\n\t\t\t\t  GFP_ATOMIC);\n\tif (!skb) {\n\t\tskb_tx_error(entskb);\n\t\treturn NULL;\n\t}\n\n\tnlh = nlmsg_put(skb, 0, 0,\n\t\t\tNFNL_SUBSYS_QUEUE << 8 | NFQNL_MSG_PACKET,\n\t\t\tsizeof(struct nfgenmsg), 0);\n\tif (!nlh) {\n\t\tskb_tx_error(entskb);\n\t\tkfree_skb(skb);\n\t\treturn NULL;\n\t}\n\tnfmsg = nlmsg_data(nlh);\n\tnfmsg->nfgen_family = entry->pf;\n\tnfmsg->version = NFNETLINK_V0;\n\tnfmsg->res_id = htons(queue->queue_num);\n\n\tnla = __nla_reserve(skb, NFQA_PACKET_HDR, sizeof(*pmsg));\n\tpmsg = nla_data(nla);\n\tpmsg->hw_protocol\t= entskb->protocol;\n\tpmsg->hook\t\t= entry->hook;\n\t*packet_id_ptr\t\t= &pmsg->packet_id;\n\n\tindev = entry->indev;\n\tif (indev) {\n#ifndef CONFIG_BRIDGE_NETFILTER\n\t\tif (nla_put_be32(skb, NFQA_IFINDEX_INDEV, htonl(indev->ifindex)))\n\t\t\tgoto nla_put_failure;\n#else\n\t\tif (entry->pf == PF_BRIDGE) {\n\t\t\t/* Case 1: indev is physical input device, we need to\n\t\t\t * look for bridge group (when called from\n\t\t\t * netfilter_bridge) */\n\t\t\tif (nla_put_be32(skb, NFQA_IFINDEX_PHYSINDEV,\n\t\t\t\t\t htonl(indev->ifindex)) ||\n\t\t\t/* this is the bridge group \"brX\" */\n\t\t\t/* rcu_read_lock()ed by __nf_queue */\n\t\t\t    nla_put_be32(skb, NFQA_IFINDEX_INDEV,\n\t\t\t\t\t htonl(br_port_get_rcu(indev)->br->dev->ifindex)))\n\t\t\t\tgoto nla_put_failure;\n\t\t} else {\n\t\t\t/* Case 2: indev is bridge group, we need to look for\n\t\t\t * physical device (when called from ipv4) */\n\t\t\tif (nla_put_be32(skb, NFQA_IFINDEX_INDEV,\n\t\t\t\t\t htonl(indev->ifindex)))\n\t\t\t\tgoto nla_put_failure;\n\t\t\tif (entskb->nf_bridge && entskb->nf_bridge->physindev &&\n\t\t\t    nla_put_be32(skb, NFQA_IFINDEX_PHYSINDEV,\n\t\t\t\t\t htonl(entskb->nf_bridge->physindev->ifindex)))\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n#endif\n\t}\n\n\tif (outdev) {\n#ifndef CONFIG_BRIDGE_NETFILTER\n\t\tif (nla_put_be32(skb, NFQA_IFINDEX_OUTDEV, htonl(outdev->ifindex)))\n\t\t\tgoto nla_put_failure;\n#else\n\t\tif (entry->pf == PF_BRIDGE) {\n\t\t\t/* Case 1: outdev is physical output device, we need to\n\t\t\t * look for bridge group (when called from\n\t\t\t * netfilter_bridge) */\n\t\t\tif (nla_put_be32(skb, NFQA_IFINDEX_PHYSOUTDEV,\n\t\t\t\t\t htonl(outdev->ifindex)) ||\n\t\t\t/* this is the bridge group \"brX\" */\n\t\t\t/* rcu_read_lock()ed by __nf_queue */\n\t\t\t    nla_put_be32(skb, NFQA_IFINDEX_OUTDEV,\n\t\t\t\t\t htonl(br_port_get_rcu(outdev)->br->dev->ifindex)))\n\t\t\t\tgoto nla_put_failure;\n\t\t} else {\n\t\t\t/* Case 2: outdev is bridge group, we need to look for\n\t\t\t * physical output device (when called from ipv4) */\n\t\t\tif (nla_put_be32(skb, NFQA_IFINDEX_OUTDEV,\n\t\t\t\t\t htonl(outdev->ifindex)))\n\t\t\t\tgoto nla_put_failure;\n\t\t\tif (entskb->nf_bridge && entskb->nf_bridge->physoutdev &&\n\t\t\t    nla_put_be32(skb, NFQA_IFINDEX_PHYSOUTDEV,\n\t\t\t\t\t htonl(entskb->nf_bridge->physoutdev->ifindex)))\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n#endif\n\t}\n\n\tif (entskb->mark &&\n\t    nla_put_be32(skb, NFQA_MARK, htonl(entskb->mark)))\n\t\tgoto nla_put_failure;\n\n\tif (indev && entskb->dev &&\n\t    entskb->mac_header != entskb->network_header) {\n\t\tstruct nfqnl_msg_packet_hw phw;\n\t\tint len;\n\n\t\tmemset(&phw, 0, sizeof(phw));\n\t\tlen = dev_parse_header(entskb, phw.hw_addr);\n\t\tif (len) {\n\t\t\tphw.hw_addrlen = htons(len);\n\t\t\tif (nla_put(skb, NFQA_HWADDR, sizeof(phw), &phw))\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n\t}\n\n\tif (entskb->tstamp.tv64) {\n\t\tstruct nfqnl_msg_packet_timestamp ts;\n\t\tstruct timeval tv = ktime_to_timeval(entskb->tstamp);\n\t\tts.sec = cpu_to_be64(tv.tv_sec);\n\t\tts.usec = cpu_to_be64(tv.tv_usec);\n\n\t\tif (nla_put(skb, NFQA_TIMESTAMP, sizeof(ts), &ts))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif ((queue->flags & NFQA_CFG_F_UID_GID) && entskb->sk &&\n\t    nfqnl_put_sk_uidgid(skb, entskb->sk) < 0)\n\t\tgoto nla_put_failure;\n\n\tif (ct && nfqnl_ct_put(skb, ct, ctinfo) < 0)\n\t\tgoto nla_put_failure;\n\n\tif (cap_len > data_len &&\n\t    nla_put_be32(skb, NFQA_CAP_LEN, htonl(cap_len)))\n\t\tgoto nla_put_failure;\n\n\tif (nfqnl_put_packet_info(skb, entskb, csum_verify))\n\t\tgoto nla_put_failure;\n\n\tif (data_len) {\n\t\tstruct nlattr *nla;\n\n\t\tif (skb_tailroom(skb) < sizeof(*nla) + hlen)\n\t\t\tgoto nla_put_failure;\n\n\t\tnla = (struct nlattr *)skb_put(skb, sizeof(*nla));\n\t\tnla->nla_type = NFQA_PAYLOAD;\n\t\tnla->nla_len = nla_attr_size(data_len);\n\n\t\tif (skb_zerocopy(skb, entskb, data_len, hlen))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tnlh->nlmsg_len = skb->len;\n\treturn skb;\n\nnla_put_failure:\n\tskb_tx_error(entskb);\n\tkfree_skb(skb);\n\tnet_err_ratelimited(\"nf_queue: error creating packet message\\n\");\n\treturn NULL;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146499,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "nfa_regmatch(\n    nfa_regprog_T\t*prog,\n    nfa_state_T\t\t*start,\n    regsubs_T\t\t*submatch,\n    regsubs_T\t\t*m)\n{\n    int\t\tresult = FALSE;\n    size_t\tsize = 0;\n    int\t\tflag = 0;\n    int\t\tgo_to_nextline = FALSE;\n    nfa_thread_T *t;\n    nfa_list_T\tlist[2];\n    int\t\tlistidx;\n    nfa_list_T\t*thislist;\n    nfa_list_T\t*nextlist;\n    int\t\t*listids = NULL;\n    int\t\tlistids_len = 0;\n    nfa_state_T *add_state;\n    int\t\tadd_here;\n    int\t\tadd_count;\n    int\t\tadd_off = 0;\n    int\t\ttoplevel = start->c == NFA_MOPEN;\n    regsubs_T\t*r;\n#ifdef NFA_REGEXP_DEBUG_LOG\n    FILE\t*debug;\n#endif\n\n    // Some patterns may take a long time to match, especially when using\n    // recursive_regmatch(). Allow interrupting them with CTRL-C.\n    fast_breakcheck();\n    if (got_int)\n\treturn FALSE;\n#ifdef FEAT_RELTIME\n    if (nfa_did_time_out())\n\treturn FALSE;\n#endif\n\n#ifdef NFA_REGEXP_DEBUG_LOG\n    debug = fopen(NFA_REGEXP_DEBUG_LOG, \"a\");\n    if (debug == NULL)\n    {\n\tsemsg(\"(NFA) COULD NOT OPEN %s!\", NFA_REGEXP_DEBUG_LOG);\n\treturn FALSE;\n    }\n#endif\n    nfa_match = FALSE;\n\n    // Allocate memory for the lists of nodes.\n    size = (prog->nstate + 1) * sizeof(nfa_thread_T);\n\n    list[0].t = alloc(size);\n    list[0].len = prog->nstate + 1;\n    list[1].t = alloc(size);\n    list[1].len = prog->nstate + 1;\n    if (list[0].t == NULL || list[1].t == NULL)\n\tgoto theend;\n\n#ifdef ENABLE_LOG\n    log_fd = fopen(NFA_REGEXP_RUN_LOG, \"a\");\n    if (log_fd != NULL)\n    {\n\tfprintf(log_fd, \"**********************************\\n\");\n\tnfa_set_code(start->c);\n\tfprintf(log_fd, \" RUNNING nfa_regmatch() starting with state %d, code %s\\n\",\n\tabs(start->id), code);\n\tfprintf(log_fd, \"**********************************\\n\");\n    }\n    else\n    {\n\temsg(_(e_log_open_failed));\n\tlog_fd = stderr;\n    }\n#endif\n\n    thislist = &list[0];\n    thislist->n = 0;\n    thislist->has_pim = FALSE;\n    nextlist = &list[1];\n    nextlist->n = 0;\n    nextlist->has_pim = FALSE;\n#ifdef ENABLE_LOG\n    fprintf(log_fd, \"(---) STARTSTATE first\\n\");\n#endif\n    thislist->id = rex.nfa_listid + 1;\n\n    // Inline optimized code for addstate(thislist, start, m, 0) if we know\n    // it's the first MOPEN.\n    if (toplevel)\n    {\n\tif (REG_MULTI)\n\t{\n\t    m->norm.list.multi[0].start_lnum = rex.lnum;\n\t    m->norm.list.multi[0].start_col = (colnr_T)(rex.input - rex.line);\n\t}\n\telse\n\t    m->norm.list.line[0].start = rex.input;\n\tm->norm.in_use = 1;\n\tr = addstate(thislist, start->out, m, NULL, 0);\n    }\n    else\n\tr = addstate(thislist, start, m, NULL, 0);\n    if (r == NULL)\n    {\n\tnfa_match = NFA_TOO_EXPENSIVE;\n\tgoto theend;\n    }\n\n#define\tADD_STATE_IF_MATCH(state)\t\t\t\\\n    if (result) {\t\t\t\t\t\\\n\tadd_state = state->out;\t\t\t\t\\\n\tadd_off = clen;\t\t\t\t\t\\\n    }\n\n    /*\n     * Run for each character.\n     */\n    for (;;)\n    {\n\tint\tcurc;\n\tint\tclen;\n\n\tif (has_mbyte)\n\t{\n\t    curc = (*mb_ptr2char)(rex.input);\n\t    clen = (*mb_ptr2len)(rex.input);\n\t}\n\telse\n\t{\n\t    curc = *rex.input;\n\t    clen = 1;\n\t}\n\tif (curc == NUL)\n\t{\n\t    clen = 0;\n\t    go_to_nextline = FALSE;\n\t}\n\n\t// swap lists\n\tthislist = &list[flag];\n\tnextlist = &list[flag ^= 1];\n\tnextlist->n = 0;\t    // clear nextlist\n\tnextlist->has_pim = FALSE;\n\t++rex.nfa_listid;\n\tif (prog->re_engine == AUTOMATIC_ENGINE\n\t\t&& (rex.nfa_listid >= NFA_MAX_STATES\n# ifdef FEAT_EVAL\n\t\t    || nfa_fail_for_testing\n# endif\n\t\t    ))\n\t{\n\t    // too many states, retry with old engine\n\t    nfa_match = NFA_TOO_EXPENSIVE;\n\t    goto theend;\n\t}\n\n\tthislist->id = rex.nfa_listid;\n\tnextlist->id = rex.nfa_listid + 1;\n\n#ifdef ENABLE_LOG\n\tfprintf(log_fd, \"------------------------------------------\\n\");\n\tfprintf(log_fd, \">>> Reginput is \\\"%s\\\"\\n\", rex.input);\n\tfprintf(log_fd, \">>> Advanced one character... Current char is %c (code %d) \\n\", curc, (int)curc);\n\tfprintf(log_fd, \">>> Thislist has %d states available: \", thislist->n);\n\t{\n\t    int i;\n\n\t    for (i = 0; i < thislist->n; i++)\n\t\tfprintf(log_fd, \"%d  \", abs(thislist->t[i].state->id));\n\t}\n\tfprintf(log_fd, \"\\n\");\n#endif\n\n#ifdef NFA_REGEXP_DEBUG_LOG\n\tfprintf(debug, \"\\n-------------------\\n\");\n#endif\n\t/*\n\t * If the state lists are empty we can stop.\n\t */\n\tif (thislist->n == 0)\n\t    break;\n\n\t// compute nextlist\n\tfor (listidx = 0; listidx < thislist->n; ++listidx)\n\t{\n\t    // If the list gets very long there probably is something wrong.\n\t    // At least allow interrupting with CTRL-C.\n\t    fast_breakcheck();\n\t    if (got_int)\n\t\tbreak;\n#ifdef FEAT_RELTIME\n\t    if (nfa_time_limit != NULL && ++nfa_time_count == 20)\n\t    {\n\t\tnfa_time_count = 0;\n\t\tif (nfa_did_time_out())\n\t\t    break;\n\t    }\n#endif\n\t    t = &thislist->t[listidx];\n\n#ifdef NFA_REGEXP_DEBUG_LOG\n\t    nfa_set_code(t->state->c);\n\t    fprintf(debug, \"%s, \", code);\n#endif\n#ifdef ENABLE_LOG\n\t    {\n\t\tint col;\n\n\t\tif (t->subs.norm.in_use <= 0)\n\t\t    col = -1;\n\t\telse if (REG_MULTI)\n\t\t    col = t->subs.norm.list.multi[0].start_col;\n\t\telse\n\t\t    col = (int)(t->subs.norm.list.line[0].start - rex.line);\n\t\tnfa_set_code(t->state->c);\n\t\tfprintf(log_fd, \"(%d) char %d %s (start col %d)%s... \\n\",\n\t\t\tabs(t->state->id), (int)t->state->c, code, col,\n\t\t\tpim_info(&t->pim));\n\t    }\n#endif\n\n\t    /*\n\t     * Handle the possible codes of the current state.\n\t     * The most important is NFA_MATCH.\n\t     */\n\t    add_state = NULL;\n\t    add_here = FALSE;\n\t    add_count = 0;\n\t    switch (t->state->c)\n\t    {\n\t    case NFA_MATCH:\n\t      {\n\t\t// If the match is not at the start of the line, ends before a\n\t\t// composing characters and rex.reg_icombine is not set, that\n\t\t// is not really a match.\n\t\tif (enc_utf8 && !rex.reg_icombine\n\t\t\t     && rex.input != rex.line && utf_iscomposing(curc))\n\t\t    break;\n\n\t\tnfa_match = TRUE;\n\t\tcopy_sub(&submatch->norm, &t->subs.norm);\n#ifdef FEAT_SYN_HL\n\t\tif (rex.nfa_has_zsubexpr)\n\t\t    copy_sub(&submatch->synt, &t->subs.synt);\n#endif\n#ifdef ENABLE_LOG\n\t\tlog_subsexpr(&t->subs);\n#endif\n\t\t// Found the left-most longest match, do not look at any other\n\t\t// states at this position.  When the list of states is going\n\t\t// to be empty quit without advancing, so that \"rex.input\" is\n\t\t// correct.\n\t\tif (nextlist->n == 0)\n\t\t    clen = 0;\n\t\tgoto nextchar;\n\t      }\n\n\t    case NFA_END_INVISIBLE:\n\t    case NFA_END_INVISIBLE_NEG:\n\t    case NFA_END_PATTERN:\n\t\t/*\n\t\t * This is only encountered after a NFA_START_INVISIBLE or\n\t\t * NFA_START_INVISIBLE_BEFORE node.\n\t\t * They surround a zero-width group, used with \"\\@=\", \"\\&\",\n\t\t * \"\\@!\", \"\\@<=\" and \"\\@<!\".\n\t\t * If we got here, it means that the current \"invisible\" group\n\t\t * finished successfully, so return control to the parent\n\t\t * nfa_regmatch().  For a look-behind match only when it ends\n\t\t * in the position in \"nfa_endp\".\n\t\t * Submatches are stored in *m, and used in the parent call.\n\t\t */\n#ifdef ENABLE_LOG\n\t\tif (nfa_endp != NULL)\n\t\t{\n\t\t    if (REG_MULTI)\n\t\t\tfprintf(log_fd, \"Current lnum: %d, endp lnum: %d; current col: %d, endp col: %d\\n\",\n\t\t\t\t(int)rex.lnum,\n\t\t\t\t(int)nfa_endp->se_u.pos.lnum,\n\t\t\t\t(int)(rex.input - rex.line),\n\t\t\t\tnfa_endp->se_u.pos.col);\n\t\t    else\n\t\t\tfprintf(log_fd, \"Current col: %d, endp col: %d\\n\",\n\t\t\t\t(int)(rex.input - rex.line),\n\t\t\t\t(int)(nfa_endp->se_u.ptr - rex.input));\n\t\t}\n#endif\n\t\t// If \"nfa_endp\" is set it's only a match if it ends at\n\t\t// \"nfa_endp\"\n\t\tif (nfa_endp != NULL && (REG_MULTI\n\t\t\t? (rex.lnum != nfa_endp->se_u.pos.lnum\n\t\t\t    || (int)(rex.input - rex.line)\n\t\t\t\t\t\t!= nfa_endp->se_u.pos.col)\n\t\t\t: rex.input != nfa_endp->se_u.ptr))\n\t\t    break;\n\n\t\t// do not set submatches for \\@!\n\t\tif (t->state->c != NFA_END_INVISIBLE_NEG)\n\t\t{\n\t\t    copy_sub(&m->norm, &t->subs.norm);\n#ifdef FEAT_SYN_HL\n\t\t    if (rex.nfa_has_zsubexpr)\n\t\t\tcopy_sub(&m->synt, &t->subs.synt);\n#endif\n\t\t}\n#ifdef ENABLE_LOG\n\t\tfprintf(log_fd, \"Match found:\\n\");\n\t\tlog_subsexpr(m);\n#endif\n\t\tnfa_match = TRUE;\n\t\t// See comment above at \"goto nextchar\".\n\t\tif (nextlist->n == 0)\n\t\t    clen = 0;\n\t\tgoto nextchar;\n\n\t    case NFA_START_INVISIBLE:\n\t    case NFA_START_INVISIBLE_FIRST:\n\t    case NFA_START_INVISIBLE_NEG:\n\t    case NFA_START_INVISIBLE_NEG_FIRST:\n\t    case NFA_START_INVISIBLE_BEFORE:\n\t    case NFA_START_INVISIBLE_BEFORE_FIRST:\n\t    case NFA_START_INVISIBLE_BEFORE_NEG:\n\t    case NFA_START_INVISIBLE_BEFORE_NEG_FIRST:\n\t\t{\n#ifdef ENABLE_LOG\n\t\t    fprintf(log_fd, \"Failure chance invisible: %d, what follows: %d\\n\",\n\t\t\t    failure_chance(t->state->out, 0),\n\t\t\t    failure_chance(t->state->out1->out, 0));\n#endif\n\t\t    // Do it directly if there already is a PIM or when\n\t\t    // nfa_postprocess() detected it will work better.\n\t\t    if (t->pim.result != NFA_PIM_UNUSED\n\t\t\t || t->state->c == NFA_START_INVISIBLE_FIRST\n\t\t\t || t->state->c == NFA_START_INVISIBLE_NEG_FIRST\n\t\t\t || t->state->c == NFA_START_INVISIBLE_BEFORE_FIRST\n\t\t\t || t->state->c == NFA_START_INVISIBLE_BEFORE_NEG_FIRST)\n\t\t    {\n\t\t\tint in_use = m->norm.in_use;\n\n\t\t\t// Copy submatch info for the recursive call, opposite\n\t\t\t// of what happens on success below.\n\t\t\tcopy_sub_off(&m->norm, &t->subs.norm);\n#ifdef FEAT_SYN_HL\n\t\t\tif (rex.nfa_has_zsubexpr)\n\t\t\t    copy_sub_off(&m->synt, &t->subs.synt);\n#endif\n\n\t\t\t/*\n\t\t\t * First try matching the invisible match, then what\n\t\t\t * follows.\n\t\t\t */\n\t\t\tresult = recursive_regmatch(t->state, NULL, prog,\n\t\t\t\t\t  submatch, m, &listids, &listids_len);\n\t\t\tif (result == NFA_TOO_EXPENSIVE)\n\t\t\t{\n\t\t\t    nfa_match = result;\n\t\t\t    goto theend;\n\t\t\t}\n\n\t\t\t// for \\@! and \\@<! it is a match when the result is\n\t\t\t// FALSE\n\t\t\tif (result != (t->state->c == NFA_START_INVISIBLE_NEG\n\t\t\t       || t->state->c == NFA_START_INVISIBLE_NEG_FIRST\n\t\t\t       || t->state->c\n\t\t\t\t\t   == NFA_START_INVISIBLE_BEFORE_NEG\n\t\t\t       || t->state->c\n\t\t\t\t     == NFA_START_INVISIBLE_BEFORE_NEG_FIRST))\n\t\t\t{\n\t\t\t    // Copy submatch info from the recursive call\n\t\t\t    copy_sub_off(&t->subs.norm, &m->norm);\n#ifdef FEAT_SYN_HL\n\t\t\t    if (rex.nfa_has_zsubexpr)\n\t\t\t\tcopy_sub_off(&t->subs.synt, &m->synt);\n#endif\n\t\t\t    // If the pattern has \\ze and it matched in the\n\t\t\t    // sub pattern, use it.\n\t\t\t    copy_ze_off(&t->subs.norm, &m->norm);\n\n\t\t\t    // t->state->out1 is the corresponding\n\t\t\t    // END_INVISIBLE node; Add its out to the current\n\t\t\t    // list (zero-width match).\n\t\t\t    add_here = TRUE;\n\t\t\t    add_state = t->state->out1->out;\n\t\t\t}\n\t\t\tm->norm.in_use = in_use;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tnfa_pim_T pim;\n\n\t\t\t/*\n\t\t\t * First try matching what follows.  Only if a match\n\t\t\t * is found verify the invisible match matches.  Add a\n\t\t\t * nfa_pim_T to the following states, it contains info\n\t\t\t * about the invisible match.\n\t\t\t */\n\t\t\tpim.state = t->state;\n\t\t\tpim.result = NFA_PIM_TODO;\n\t\t\tpim.subs.norm.in_use = 0;\n#ifdef FEAT_SYN_HL\n\t\t\tpim.subs.synt.in_use = 0;\n#endif\n\t\t\tif (REG_MULTI)\n\t\t\t{\n\t\t\t    pim.end.pos.col = (int)(rex.input - rex.line);\n\t\t\t    pim.end.pos.lnum = rex.lnum;\n\t\t\t}\n\t\t\telse\n\t\t\t    pim.end.ptr = rex.input;\n\n\t\t\t// t->state->out1 is the corresponding END_INVISIBLE\n\t\t\t// node; Add its out to the current list (zero-width\n\t\t\t// match).\n\t\t\tif (addstate_here(thislist, t->state->out1->out,\n\t\t\t\t\t     &t->subs, &pim, &listidx) == NULL)\n\t\t\t{\n\t\t\t    nfa_match = NFA_TOO_EXPENSIVE;\n\t\t\t    goto theend;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    case NFA_START_PATTERN:\n\t      {\n\t\tnfa_state_T *skip = NULL;\n#ifdef ENABLE_LOG\n\t\tint\t    skip_lid = 0;\n#endif\n\n\t\t// There is no point in trying to match the pattern if the\n\t\t// output state is not going to be added to the list.\n\t\tif (state_in_list(nextlist, t->state->out1->out, &t->subs))\n\t\t{\n\t\t    skip = t->state->out1->out;\n#ifdef ENABLE_LOG\n\t\t    skip_lid = nextlist->id;\n#endif\n\t\t}\n\t\telse if (state_in_list(nextlist,\n\t\t\t\t\t  t->state->out1->out->out, &t->subs))\n\t\t{\n\t\t    skip = t->state->out1->out->out;\n#ifdef ENABLE_LOG\n\t\t    skip_lid = nextlist->id;\n#endif\n\t\t}\n\t\telse if (state_in_list(thislist,\n\t\t\t\t\t  t->state->out1->out->out, &t->subs))\n\t\t{\n\t\t    skip = t->state->out1->out->out;\n#ifdef ENABLE_LOG\n\t\t    skip_lid = thislist->id;\n#endif\n\t\t}\n\t\tif (skip != NULL)\n\t\t{\n#ifdef ENABLE_LOG\n\t\t    nfa_set_code(skip->c);\n\t\t    fprintf(log_fd, \"> Not trying to match pattern, output state %d is already in list %d. char %d: %s\\n\",\n\t\t\t    abs(skip->id), skip_lid, skip->c, code);\n#endif\n\t\t    break;\n\t\t}\n\t\t// Copy submatch info to the recursive call, opposite of what\n\t\t// happens afterwards.\n\t\tcopy_sub_off(&m->norm, &t->subs.norm);\n#ifdef FEAT_SYN_HL\n\t\tif (rex.nfa_has_zsubexpr)\n\t\t    copy_sub_off(&m->synt, &t->subs.synt);\n#endif\n\n\t\t// First try matching the pattern.\n\t\tresult = recursive_regmatch(t->state, NULL, prog,\n\t\t\t\t\t  submatch, m, &listids, &listids_len);\n\t\tif (result == NFA_TOO_EXPENSIVE)\n\t\t{\n\t\t    nfa_match = result;\n\t\t    goto theend;\n\t\t}\n\t\tif (result)\n\t\t{\n\t\t    int bytelen;\n\n#ifdef ENABLE_LOG\n\t\t    fprintf(log_fd, \"NFA_START_PATTERN matches:\\n\");\n\t\t    log_subsexpr(m);\n#endif\n\t\t    // Copy submatch info from the recursive call\n\t\t    copy_sub_off(&t->subs.norm, &m->norm);\n#ifdef FEAT_SYN_HL\n\t\t    if (rex.nfa_has_zsubexpr)\n\t\t\tcopy_sub_off(&t->subs.synt, &m->synt);\n#endif\n\t\t    // Now we need to skip over the matched text and then\n\t\t    // continue with what follows.\n\t\t    if (REG_MULTI)\n\t\t\t// TODO: multi-line match\n\t\t\tbytelen = m->norm.list.multi[0].end_col\n\t\t\t\t\t\t  - (int)(rex.input - rex.line);\n\t\t    else\n\t\t\tbytelen = (int)(m->norm.list.line[0].end - rex.input);\n\n#ifdef ENABLE_LOG\n\t\t    fprintf(log_fd, \"NFA_START_PATTERN length: %d\\n\", bytelen);\n#endif\n\t\t    if (bytelen == 0)\n\t\t    {\n\t\t\t// empty match, output of corresponding\n\t\t\t// NFA_END_PATTERN/NFA_SKIP to be used at current\n\t\t\t// position\n\t\t\tadd_here = TRUE;\n\t\t\tadd_state = t->state->out1->out->out;\n\t\t    }\n\t\t    else if (bytelen <= clen)\n\t\t    {\n\t\t\t// match current character, output of corresponding\n\t\t\t// NFA_END_PATTERN to be used at next position.\n\t\t\tadd_state = t->state->out1->out->out;\n\t\t\tadd_off = clen;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// skip over the matched characters, set character\n\t\t\t// count in NFA_SKIP\n\t\t\tadd_state = t->state->out1->out;\n\t\t\tadd_off = bytelen;\n\t\t\tadd_count = bytelen - clen;\n\t\t    }\n\t\t}\n\t\tbreak;\n\t      }\n\n\t    case NFA_BOL:\n\t\tif (rex.input == rex.line)\n\t\t{\n\t\t    add_here = TRUE;\n\t\t    add_state = t->state->out;\n\t\t}\n\t\tbreak;\n\n\t    case NFA_EOL:\n\t\tif (curc == NUL)\n\t\t{\n\t\t    add_here = TRUE;\n\t\t    add_state = t->state->out;\n\t\t}\n\t\tbreak;\n\n\t    case NFA_BOW:\n\t\tresult = TRUE;\n\n\t\tif (curc == NUL)\n\t\t    result = FALSE;\n\t\telse if (has_mbyte)\n\t\t{\n\t\t    int this_class;\n\n\t\t    // Get class of current and previous char (if it exists).\n\t\t    this_class = mb_get_class_buf(rex.input, rex.reg_buf);\n\t\t    if (this_class <= 1)\n\t\t\tresult = FALSE;\n\t\t    else if (reg_prev_class() == this_class)\n\t\t\tresult = FALSE;\n\t\t}\n\t\telse if (!vim_iswordc_buf(curc, rex.reg_buf)\n\t\t\t   || (rex.input > rex.line\n\t\t\t\t&& vim_iswordc_buf(rex.input[-1], rex.reg_buf)))\n\t\t    result = FALSE;\n\t\tif (result)\n\t\t{\n\t\t    add_here = TRUE;\n\t\t    add_state = t->state->out;\n\t\t}\n\t\tbreak;\n\n\t    case NFA_EOW:\n\t\tresult = TRUE;\n\t\tif (rex.input == rex.line)\n\t\t    result = FALSE;\n\t\telse if (has_mbyte)\n\t\t{\n\t\t    int this_class, prev_class;\n\n\t\t    // Get class of current and previous char (if it exists).\n\t\t    this_class = mb_get_class_buf(rex.input, rex.reg_buf);\n\t\t    prev_class = reg_prev_class();\n\t\t    if (this_class == prev_class\n\t\t\t\t\t|| prev_class == 0 || prev_class == 1)\n\t\t\tresult = FALSE;\n\t\t}\n\t\telse if (!vim_iswordc_buf(rex.input[-1], rex.reg_buf)\n\t\t\t|| (rex.input[0] != NUL\n\t\t\t\t\t&& vim_iswordc_buf(curc, rex.reg_buf)))\n\t\t    result = FALSE;\n\t\tif (result)\n\t\t{\n\t\t    add_here = TRUE;\n\t\t    add_state = t->state->out;\n\t\t}\n\t\tbreak;\n\n\t    case NFA_BOF:\n\t\tif (rex.lnum == 0 && rex.input == rex.line\n\t\t\t\t     && (!REG_MULTI || rex.reg_firstlnum == 1))\n\t\t{\n\t\t    add_here = TRUE;\n\t\t    add_state = t->state->out;\n\t\t}\n\t\tbreak;\n\n\t    case NFA_EOF:\n\t\tif (rex.lnum == rex.reg_maxline && curc == NUL)\n\t\t{\n\t\t    add_here = TRUE;\n\t\t    add_state = t->state->out;\n\t\t}\n\t\tbreak;\n\n\t    case NFA_COMPOSING:\n\t    {\n\t\tint\t    mc = curc;\n\t\tint\t    len = 0;\n\t\tnfa_state_T *end;\n\t\tnfa_state_T *sta;\n\t\tint\t    cchars[MAX_MCO];\n\t\tint\t    ccount = 0;\n\t\tint\t    j;\n\n\t\tsta = t->state->out;\n\t\tlen = 0;\n\t\tif (utf_iscomposing(sta->c))\n\t\t{\n\t\t    // Only match composing character(s), ignore base\n\t\t    // character.  Used for \".{composing}\" and \"{composing}\"\n\t\t    // (no preceding character).\n\t\t    len += mb_char2len(mc);\n\t\t}\n\t\tif (rex.reg_icombine && len == 0)\n\t\t{\n\t\t    // If \\Z was present, then ignore composing characters.\n\t\t    // When ignoring the base character this always matches.\n\t\t    if (sta->c != curc)\n\t\t\tresult = FAIL;\n\t\t    else\n\t\t\tresult = OK;\n\t\t    while (sta->c != NFA_END_COMPOSING)\n\t\t\tsta = sta->out;\n\t\t}\n\n\t\t// Check base character matches first, unless ignored.\n\t\telse if (len > 0 || mc == sta->c)\n\t\t{\n\t\t    if (len == 0)\n\t\t    {\n\t\t\tlen += mb_char2len(mc);\n\t\t\tsta = sta->out;\n\t\t    }\n\n\t\t    // We don't care about the order of composing characters.\n\t\t    // Get them into cchars[] first.\n\t\t    while (len < clen)\n\t\t    {\n\t\t\tmc = mb_ptr2char(rex.input + len);\n\t\t\tcchars[ccount++] = mc;\n\t\t\tlen += mb_char2len(mc);\n\t\t\tif (ccount == MAX_MCO)\n\t\t\t    break;\n\t\t    }\n\n\t\t    // Check that each composing char in the pattern matches a\n\t\t    // composing char in the text.  We do not check if all\n\t\t    // composing chars are matched.\n\t\t    result = OK;\n\t\t    while (sta->c != NFA_END_COMPOSING)\n\t\t    {\n\t\t\tfor (j = 0; j < ccount; ++j)\n\t\t\t    if (cchars[j] == sta->c)\n\t\t\t\tbreak;\n\t\t\tif (j == ccount)\n\t\t\t{\n\t\t\t    result = FAIL;\n\t\t\t    break;\n\t\t\t}\n\t\t\tsta = sta->out;\n\t\t    }\n\t\t}\n\t\telse\n\t\t    result = FAIL;\n\n\t\tend = t->state->out1;\t    // NFA_END_COMPOSING\n\t\tADD_STATE_IF_MATCH(end);\n\t\tbreak;\n\t    }\n\n\t    case NFA_NEWL:\n\t\tif (curc == NUL && !rex.reg_line_lbr && REG_MULTI\n\t\t\t\t\t\t && rex.lnum <= rex.reg_maxline)\n\t\t{\n\t\t    go_to_nextline = TRUE;\n\t\t    // Pass -1 for the offset, which means taking the position\n\t\t    // at the start of the next line.\n\t\t    add_state = t->state->out;\n\t\t    add_off = -1;\n\t\t}\n\t\telse if (curc == '\\n' && rex.reg_line_lbr)\n\t\t{\n\t\t    // match \\n as if it is an ordinary character\n\t\t    add_state = t->state->out;\n\t\t    add_off = 1;\n\t\t}\n\t\tbreak;\n\n\t    case NFA_START_COLL:\n\t    case NFA_START_NEG_COLL:\n\t      {\n\t\t// What follows is a list of characters, until NFA_END_COLL.\n\t\t// One of them must match or none of them must match.\n\t\tnfa_state_T\t*state;\n\t\tint\t\tresult_if_matched;\n\t\tint\t\tc1, c2;\n\n\t\t// Never match EOL. If it's part of the collection it is added\n\t\t// as a separate state with an OR.\n\t\tif (curc == NUL)\n\t\t    break;\n\n\t\tstate = t->state->out;\n\t\tresult_if_matched = (t->state->c == NFA_START_COLL);\n\t\tfor (;;)\n\t\t{\n\t\t    if (state->c == NFA_END_COLL)\n\t\t    {\n\t\t\tresult = !result_if_matched;\n\t\t\tbreak;\n\t\t    }\n\t\t    if (state->c == NFA_RANGE_MIN)\n\t\t    {\n\t\t\tc1 = state->val;\n\t\t\tstate = state->out; // advance to NFA_RANGE_MAX\n\t\t\tc2 = state->val;\n#ifdef ENABLE_LOG\n\t\t\tfprintf(log_fd, \"NFA_RANGE_MIN curc=%d c1=%d c2=%d\\n\",\n\t\t\t\tcurc, c1, c2);\n#endif\n\t\t\tif (curc >= c1 && curc <= c2)\n\t\t\t{\n\t\t\t    result = result_if_matched;\n\t\t\t    break;\n\t\t\t}\n\t\t\tif (rex.reg_ic)\n\t\t\t{\n\t\t\t    int curc_low = MB_CASEFOLD(curc);\n\t\t\t    int done = FALSE;\n\n\t\t\t    for ( ; c1 <= c2; ++c1)\n\t\t\t\tif (MB_CASEFOLD(c1) == curc_low)\n\t\t\t\t{\n\t\t\t\t    result = result_if_matched;\n\t\t\t\t    done = TRUE;\n\t\t\t\t    break;\n\t\t\t\t}\n\t\t\t    if (done)\n\t\t\t\tbreak;\n\t\t\t}\n\t\t    }\n\t\t    else if (state->c < 0 ? check_char_class(state->c, curc)\n\t\t\t       : (curc == state->c\n\t\t\t\t   || (rex.reg_ic && MB_CASEFOLD(curc)\n\t\t\t\t\t\t    == MB_CASEFOLD(state->c))))\n\t\t    {\n\t\t\tresult = result_if_matched;\n\t\t\tbreak;\n\t\t    }\n\t\t    state = state->out;\n\t\t}\n\t\tif (result)\n\t\t{\n\t\t    // next state is in out of the NFA_END_COLL, out1 of\n\t\t    // START points to the END state\n\t\t    add_state = t->state->out1->out;\n\t\t    add_off = clen;\n\t\t}\n\t\tbreak;\n\t      }\n\n\t    case NFA_ANY:\n\t\t// Any char except '\\0', (end of input) does not match.\n\t\tif (curc > 0)\n\t\t{\n\t\t    add_state = t->state->out;\n\t\t    add_off = clen;\n\t\t}\n\t\tbreak;\n\n\t    case NFA_ANY_COMPOSING:\n\t\t// On a composing character skip over it.  Otherwise do\n\t\t// nothing.  Always matches.\n\t\tif (enc_utf8 && utf_iscomposing(curc))\n\t\t{\n\t\t    add_off = clen;\n\t\t}\n\t\telse\n\t\t{\n\t\t    add_here = TRUE;\n\t\t    add_off = 0;\n\t\t}\n\t\tadd_state = t->state->out;\n\t\tbreak;\n\n\t    /*\n\t     * Character classes like \\a for alpha, \\d for digit etc.\n\t     */\n\t    case NFA_IDENT:\t//  \\i\n\t\tresult = vim_isIDc(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_SIDENT:\t//  \\I\n\t\tresult = !VIM_ISDIGIT(curc) && vim_isIDc(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_KWORD:\t//  \\k\n\t\tresult = vim_iswordp_buf(rex.input, rex.reg_buf);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_SKWORD:\t//  \\K\n\t\tresult = !VIM_ISDIGIT(curc)\n\t\t\t\t     && vim_iswordp_buf(rex.input, rex.reg_buf);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_FNAME:\t//  \\f\n\t\tresult = vim_isfilec(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_SFNAME:\t//  \\F\n\t\tresult = !VIM_ISDIGIT(curc) && vim_isfilec(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_PRINT:\t//  \\p\n\t\tresult = vim_isprintc(PTR2CHAR(rex.input));\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_SPRINT:\t//  \\P\n\t\tresult = !VIM_ISDIGIT(curc) && vim_isprintc(PTR2CHAR(rex.input));\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_WHITE:\t//  \\s\n\t\tresult = VIM_ISWHITE(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_NWHITE:\t//  \\S\n\t\tresult = curc != NUL && !VIM_ISWHITE(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_DIGIT:\t//  \\d\n\t\tresult = ri_digit(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_NDIGIT:\t//  \\D\n\t\tresult = curc != NUL && !ri_digit(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_HEX:\t//  \\x\n\t\tresult = ri_hex(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_NHEX:\t//  \\X\n\t\tresult = curc != NUL && !ri_hex(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_OCTAL:\t//  \\o\n\t\tresult = ri_octal(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_NOCTAL:\t//  \\O\n\t\tresult = curc != NUL && !ri_octal(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_WORD:\t//  \\w\n\t\tresult = ri_word(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_NWORD:\t//  \\W\n\t\tresult = curc != NUL && !ri_word(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_HEAD:\t//  \\h\n\t\tresult = ri_head(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_NHEAD:\t//  \\H\n\t\tresult = curc != NUL && !ri_head(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_ALPHA:\t//  \\a\n\t\tresult = ri_alpha(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_NALPHA:\t//  \\A\n\t\tresult = curc != NUL && !ri_alpha(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_LOWER:\t//  \\l\n\t\tresult = ri_lower(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_NLOWER:\t//  \\L\n\t\tresult = curc != NUL && !ri_lower(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_UPPER:\t//  \\u\n\t\tresult = ri_upper(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_NUPPER:\t// \\U\n\t\tresult = curc != NUL && !ri_upper(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_LOWER_IC:\t// [a-z]\n\t\tresult = ri_lower(curc) || (rex.reg_ic && ri_upper(curc));\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_NLOWER_IC:\t// [^a-z]\n\t\tresult = curc != NUL\n\t\t\t&& !(ri_lower(curc) || (rex.reg_ic && ri_upper(curc)));\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_UPPER_IC:\t// [A-Z]\n\t\tresult = ri_upper(curc) || (rex.reg_ic && ri_lower(curc));\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_NUPPER_IC:\t// ^[A-Z]\n\t\tresult = curc != NUL\n\t\t\t&& !(ri_upper(curc) || (rex.reg_ic && ri_lower(curc)));\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_BACKREF1:\n\t    case NFA_BACKREF2:\n\t    case NFA_BACKREF3:\n\t    case NFA_BACKREF4:\n\t    case NFA_BACKREF5:\n\t    case NFA_BACKREF6:\n\t    case NFA_BACKREF7:\n\t    case NFA_BACKREF8:\n\t    case NFA_BACKREF9:\n#ifdef FEAT_SYN_HL\n\t    case NFA_ZREF1:\n\t    case NFA_ZREF2:\n\t    case NFA_ZREF3:\n\t    case NFA_ZREF4:\n\t    case NFA_ZREF5:\n\t    case NFA_ZREF6:\n\t    case NFA_ZREF7:\n\t    case NFA_ZREF8:\n\t    case NFA_ZREF9:\n#endif\n\t\t// \\1 .. \\9  \\z1 .. \\z9\n\t      {\n\t\tint subidx;\n\t\tint bytelen;\n\n\t\tif (t->state->c <= NFA_BACKREF9)\n\t\t{\n\t\t    subidx = t->state->c - NFA_BACKREF1 + 1;\n\t\t    result = match_backref(&t->subs.norm, subidx, &bytelen);\n\t\t}\n#ifdef FEAT_SYN_HL\n\t\telse\n\t\t{\n\t\t    subidx = t->state->c - NFA_ZREF1 + 1;\n\t\t    result = match_zref(subidx, &bytelen);\n\t\t}\n#endif\n\n\t\tif (result)\n\t\t{\n\t\t    if (bytelen == 0)\n\t\t    {\n\t\t\t// empty match always works, output of NFA_SKIP to be\n\t\t\t// used next\n\t\t\tadd_here = TRUE;\n\t\t\tadd_state = t->state->out->out;\n\t\t    }\n\t\t    else if (bytelen <= clen)\n\t\t    {\n\t\t\t// match current character, jump ahead to out of\n\t\t\t// NFA_SKIP\n\t\t\tadd_state = t->state->out->out;\n\t\t\tadd_off = clen;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// skip over the matched characters, set character\n\t\t\t// count in NFA_SKIP\n\t\t\tadd_state = t->state->out;\n\t\t\tadd_off = bytelen;\n\t\t\tadd_count = bytelen - clen;\n\t\t    }\n\t\t}\n\t\tbreak;\n\t      }\n\t    case NFA_SKIP:\n\t      // character of previous matching \\1 .. \\9  or \\@>\n\t      if (t->count - clen <= 0)\n\t      {\n\t\t  // end of match, go to what follows\n\t\t  add_state = t->state->out;\n\t\t  add_off = clen;\n\t      }\n\t      else\n\t      {\n\t\t  // add state again with decremented count\n\t\t  add_state = t->state;\n\t\t  add_off = 0;\n\t\t  add_count = t->count - clen;\n\t      }\n\t      break;\n\n\t    case NFA_LNUM:\n\t    case NFA_LNUM_GT:\n\t    case NFA_LNUM_LT:\n\t\tresult = (REG_MULTI &&\n\t\t\tnfa_re_num_cmp(t->state->val, t->state->c - NFA_LNUM,\n\t\t\t    (long_u)(rex.lnum + rex.reg_firstlnum)));\n\t\tif (result)\n\t\t{\n\t\t    add_here = TRUE;\n\t\t    add_state = t->state->out;\n\t\t}\n\t\tbreak;\n\n\t    case NFA_COL:\n\t    case NFA_COL_GT:\n\t    case NFA_COL_LT:\n\t\tresult = nfa_re_num_cmp(t->state->val, t->state->c - NFA_COL,\n\t\t\t(long_u)(rex.input - rex.line) + 1);\n\t\tif (result)\n\t\t{\n\t\t    add_here = TRUE;\n\t\t    add_state = t->state->out;\n\t\t}\n\t\tbreak;\n\n\t    case NFA_VCOL:\n\t    case NFA_VCOL_GT:\n\t    case NFA_VCOL_LT:\n\t\t{\n\t\t    int     op = t->state->c - NFA_VCOL;\n\t\t    colnr_T col = (colnr_T)(rex.input - rex.line);\n\t\t    win_T   *wp = rex.reg_win == NULL ? curwin : rex.reg_win;\n\n\t\t    // Bail out quickly when there can't be a match, avoid the\n\t\t    // overhead of win_linetabsize() on long lines.\n\t\t    if (op != 1 && col > t->state->val\n\t\t\t    * (has_mbyte ? MB_MAXBYTES : 1))\n\t\t\tbreak;\n\t\t    result = FALSE;\n\t\t    if (op == 1 && col - 1 > t->state->val && col > 100)\n\t\t    {\n\t\t\tint ts = wp->w_buffer->b_p_ts;\n\n\t\t\t// Guess that a character won't use more columns than\n\t\t\t// 'tabstop', with a minimum of 4.\n\t\t\tif (ts < 4)\n\t\t\t    ts = 4;\n\t\t\tresult = col > t->state->val * ts;\n\t\t    }\n\t\t    if (!result)\n\t\t\tresult = nfa_re_num_cmp(t->state->val, op,\n\t\t\t\t(long_u)win_linetabsize(wp, rex.line, col) + 1);\n\t\t    if (result)\n\t\t    {\n\t\t\tadd_here = TRUE;\n\t\t\tadd_state = t->state->out;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    case NFA_MARK:\n\t    case NFA_MARK_GT:\n\t    case NFA_MARK_LT:\n\t      {\n\t\tpos_T\t*pos = getmark_buf(rex.reg_buf, t->state->val, FALSE);\n\n\t\t// Compare the mark position to the match position, if the mark\n\t\t// exists and mark is set in reg_buf.\n\t\tif (pos != NULL && pos->lnum > 0)\n\t\t{\n\t\t    colnr_T pos_col = pos->lnum == rex.lnum + rex.reg_firstlnum\n\t\t\t\t\t\t\t  && pos->col == MAXCOL\n\t\t\t\t      ? (colnr_T)STRLEN(reg_getline(\n\t\t\t\t\t\tpos->lnum - rex.reg_firstlnum))\n\t\t\t\t      : pos->col;\n\n\t\t    result = (pos->lnum == rex.lnum + rex.reg_firstlnum\n\t\t\t\t? (pos_col == (colnr_T)(rex.input - rex.line)\n\t\t\t\t    ? t->state->c == NFA_MARK\n\t\t\t\t    : (pos_col < (colnr_T)(rex.input - rex.line)\n\t\t\t\t\t? t->state->c == NFA_MARK_GT\n\t\t\t\t\t: t->state->c == NFA_MARK_LT))\n\t\t\t\t: (pos->lnum < rex.lnum + rex.reg_firstlnum\n\t\t\t\t    ? t->state->c == NFA_MARK_GT\n\t\t\t\t    : t->state->c == NFA_MARK_LT));\n\t\t    if (result)\n\t\t    {\n\t\t\tadd_here = TRUE;\n\t\t\tadd_state = t->state->out;\n\t\t    }\n\t\t}\n\t\tbreak;\n\t      }\n\n\t    case NFA_CURSOR:\n\t\tresult = (rex.reg_win != NULL\n\t\t\t&& (rex.lnum + rex.reg_firstlnum\n\t\t\t\t\t\t == rex.reg_win->w_cursor.lnum)\n\t\t\t&& ((colnr_T)(rex.input - rex.line)\n\t\t\t\t\t\t== rex.reg_win->w_cursor.col));\n\t\tif (result)\n\t\t{\n\t\t    add_here = TRUE;\n\t\t    add_state = t->state->out;\n\t\t}\n\t\tbreak;\n\n\t    case NFA_VISUAL:\n\t\tresult = reg_match_visual();\n\t\tif (result)\n\t\t{\n\t\t    add_here = TRUE;\n\t\t    add_state = t->state->out;\n\t\t}\n\t\tbreak;\n\n\t    case NFA_MOPEN1:\n\t    case NFA_MOPEN2:\n\t    case NFA_MOPEN3:\n\t    case NFA_MOPEN4:\n\t    case NFA_MOPEN5:\n\t    case NFA_MOPEN6:\n\t    case NFA_MOPEN7:\n\t    case NFA_MOPEN8:\n\t    case NFA_MOPEN9:\n#ifdef FEAT_SYN_HL\n\t    case NFA_ZOPEN:\n\t    case NFA_ZOPEN1:\n\t    case NFA_ZOPEN2:\n\t    case NFA_ZOPEN3:\n\t    case NFA_ZOPEN4:\n\t    case NFA_ZOPEN5:\n\t    case NFA_ZOPEN6:\n\t    case NFA_ZOPEN7:\n\t    case NFA_ZOPEN8:\n\t    case NFA_ZOPEN9:\n#endif\n\t    case NFA_NOPEN:\n\t    case NFA_ZSTART:\n\t\t// These states are only added to be able to bail out when\n\t\t// they are added again, nothing is to be done.\n\t\tbreak;\n\n\t    default:\t// regular character\n\t      {\n\t\tint c = t->state->c;\n\n#ifdef DEBUG\n\t\tif (c < 0)\n\t\t    siemsg(\"INTERNAL: Negative state char: %ld\", c);\n#endif\n\t\tresult = (c == curc);\n\n\t\tif (!result && rex.reg_ic)\n\t\t    result = MB_CASEFOLD(c) == MB_CASEFOLD(curc);\n\t\t// If rex.reg_icombine is not set only skip over the character\n\t\t// itself.  When it is set skip over composing characters.\n\t\tif (result && enc_utf8 && !rex.reg_icombine)\n\t\t    clen = utf_ptr2len(rex.input);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\t      }\n\n\t    } // switch (t->state->c)\n\n\t    if (add_state != NULL)\n\t    {\n\t\tnfa_pim_T *pim;\n\t\tnfa_pim_T pim_copy;\n\n\t\tif (t->pim.result == NFA_PIM_UNUSED)\n\t\t    pim = NULL;\n\t\telse\n\t\t    pim = &t->pim;\n\n\t\t// Handle the postponed invisible match if the match might end\n\t\t// without advancing and before the end of the line.\n\t\tif (pim != NULL && (clen == 0 || match_follows(add_state, 0)))\n\t\t{\n\t\t    if (pim->result == NFA_PIM_TODO)\n\t\t    {\n#ifdef ENABLE_LOG\n\t\t\tfprintf(log_fd, \"\\n\");\n\t\t\tfprintf(log_fd, \"==================================\\n\");\n\t\t\tfprintf(log_fd, \"Postponed recursive nfa_regmatch()\\n\");\n\t\t\tfprintf(log_fd, \"\\n\");\n#endif\n\t\t\tresult = recursive_regmatch(pim->state, pim,\n\t\t\t\t    prog, submatch, m, &listids, &listids_len);\n\t\t\tpim->result = result ? NFA_PIM_MATCH : NFA_PIM_NOMATCH;\n\t\t\t// for \\@! and \\@<! it is a match when the result is\n\t\t\t// FALSE\n\t\t\tif (result != (pim->state->c == NFA_START_INVISIBLE_NEG\n\t\t\t     || pim->state->c == NFA_START_INVISIBLE_NEG_FIRST\n\t\t\t     || pim->state->c\n\t\t\t\t\t   == NFA_START_INVISIBLE_BEFORE_NEG\n\t\t\t     || pim->state->c\n\t\t\t\t     == NFA_START_INVISIBLE_BEFORE_NEG_FIRST))\n\t\t\t{\n\t\t\t    // Copy submatch info from the recursive call\n\t\t\t    copy_sub_off(&pim->subs.norm, &m->norm);\n#ifdef FEAT_SYN_HL\n\t\t\t    if (rex.nfa_has_zsubexpr)\n\t\t\t\tcopy_sub_off(&pim->subs.synt, &m->synt);\n#endif\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tresult = (pim->result == NFA_PIM_MATCH);\n#ifdef ENABLE_LOG\n\t\t\tfprintf(log_fd, \"\\n\");\n\t\t\tfprintf(log_fd, \"Using previous recursive nfa_regmatch() result, result == %d\\n\", pim->result);\n\t\t\tfprintf(log_fd, \"MATCH = %s\\n\", result == TRUE ? \"OK\" : \"FALSE\");\n\t\t\tfprintf(log_fd, \"\\n\");\n#endif\n\t\t    }\n\n\t\t    // for \\@! and \\@<! it is a match when result is FALSE\n\t\t    if (result != (pim->state->c == NFA_START_INVISIBLE_NEG\n\t\t\t     || pim->state->c == NFA_START_INVISIBLE_NEG_FIRST\n\t\t\t     || pim->state->c\n\t\t\t\t\t   == NFA_START_INVISIBLE_BEFORE_NEG\n\t\t\t     || pim->state->c\n\t\t\t\t     == NFA_START_INVISIBLE_BEFORE_NEG_FIRST))\n\t\t    {\n\t\t\t// Copy submatch info from the recursive call\n\t\t\tcopy_sub_off(&t->subs.norm, &pim->subs.norm);\n#ifdef FEAT_SYN_HL\n\t\t\tif (rex.nfa_has_zsubexpr)\n\t\t\t    copy_sub_off(&t->subs.synt, &pim->subs.synt);\n#endif\n\t\t    }\n\t\t    else\n\t\t\t// look-behind match failed, don't add the state\n\t\t\tcontinue;\n\n\t\t    // Postponed invisible match was handled, don't add it to\n\t\t    // following states.\n\t\t    pim = NULL;\n\t\t}\n\n\t\t// If \"pim\" points into l->t it will become invalid when\n\t\t// adding the state causes the list to be reallocated.  Make a\n\t\t// local copy to avoid that.\n\t\tif (pim == &t->pim)\n\t\t{\n\t\t    copy_pim(&pim_copy, pim);\n\t\t    pim = &pim_copy;\n\t\t}\n\n\t\tif (add_here)\n\t\t    r = addstate_here(thislist, add_state, &t->subs,\n\t\t\t\t\t\t\t\tpim, &listidx);\n\t\telse\n\t\t{\n\t\t    r = addstate(nextlist, add_state, &t->subs, pim, add_off);\n\t\t    if (add_count > 0)\n\t\t\tnextlist->t[nextlist->n - 1].count = add_count;\n\t\t}\n\t\tif (r == NULL)\n\t\t{\n\t\t    nfa_match = NFA_TOO_EXPENSIVE;\n\t\t    goto theend;\n\t\t}\n\t    }\n\n\t} // for (thislist = thislist; thislist->state; thislist++)\n\n\t// Look for the start of a match in the current position by adding the\n\t// start state to the list of states.\n\t// The first found match is the leftmost one, thus the order of states\n\t// matters!\n\t// Do not add the start state in recursive calls of nfa_regmatch(),\n\t// because recursive calls should only start in the first position.\n\t// Unless \"nfa_endp\" is not NULL, then we match the end position.\n\t// Also don't start a match past the first line.\n\tif (nfa_match == FALSE\n\t\t&& ((toplevel\n\t\t\t&& rex.lnum == 0\n\t\t\t&& clen != 0\n\t\t\t&& (rex.reg_maxcol == 0\n\t\t\t    || (colnr_T)(rex.input - rex.line) < rex.reg_maxcol))\n\t\t    || (nfa_endp != NULL\n\t\t\t&& (REG_MULTI\n\t\t\t    ? (rex.lnum < nfa_endp->se_u.pos.lnum\n\t\t\t       || (rex.lnum == nfa_endp->se_u.pos.lnum\n\t\t\t\t   && (int)(rex.input - rex.line)\n\t\t\t\t\t\t    < nfa_endp->se_u.pos.col))\n\t\t\t    : rex.input < nfa_endp->se_u.ptr))))\n\t{\n#ifdef ENABLE_LOG\n\t    fprintf(log_fd, \"(---) STARTSTATE\\n\");\n#endif\n\t    // Inline optimized code for addstate() if we know the state is\n\t    // the first MOPEN.\n\t    if (toplevel)\n\t    {\n\t\tint add = TRUE;\n\t\tint c;\n\n\t\tif (prog->regstart != NUL && clen != 0)\n\t\t{\n\t\t    if (nextlist->n == 0)\n\t\t    {\n\t\t\tcolnr_T col = (colnr_T)(rex.input - rex.line) + clen;\n\n\t\t\t// Nextlist is empty, we can skip ahead to the\n\t\t\t// character that must appear at the start.\n\t\t\tif (skip_to_start(prog->regstart, &col) == FAIL)\n\t\t\t    break;\n#ifdef ENABLE_LOG\n\t\t\tfprintf(log_fd, \"  Skipping ahead %d bytes to regstart\\n\",\n\t\t\t\tcol - ((colnr_T)(rex.input - rex.line) + clen));\n#endif\n\t\t\trex.input = rex.line + col - clen;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// Checking if the required start character matches is\n\t\t\t// cheaper than adding a state that won't match.\n\t\t\tc = PTR2CHAR(rex.input + clen);\n\t\t\tif (c != prog->regstart && (!rex.reg_ic\n\t\t\t     || MB_CASEFOLD(c) != MB_CASEFOLD(prog->regstart)))\n\t\t\t{\n#ifdef ENABLE_LOG\n\t\t\t    fprintf(log_fd, \"  Skipping start state, regstart does not match\\n\");\n#endif\n\t\t\t    add = FALSE;\n\t\t\t}\n\t\t    }\n\t\t}\n\n\t\tif (add)\n\t\t{\n\t\t    if (REG_MULTI)\n\t\t\tm->norm.list.multi[0].start_col =\n\t\t\t\t\t (colnr_T)(rex.input - rex.line) + clen;\n\t\t    else\n\t\t\tm->norm.list.line[0].start = rex.input + clen;\n\t\t    if (addstate(nextlist, start->out, m, NULL, clen) == NULL)\n\t\t    {\n\t\t\tnfa_match = NFA_TOO_EXPENSIVE;\n\t\t\tgoto theend;\n\t\t    }\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tif (addstate(nextlist, start, m, NULL, clen) == NULL)\n\t\t{\n\t\t    nfa_match = NFA_TOO_EXPENSIVE;\n\t\t    goto theend;\n\t\t}\n\t    }\n\t}\n\n#ifdef ENABLE_LOG\n\tfprintf(log_fd, \">>> Thislist had %d states available: \", thislist->n);\n\t{\n\t    int i;\n\n\t    for (i = 0; i < thislist->n; i++)\n\t\tfprintf(log_fd, \"%d  \", abs(thislist->t[i].state->id));\n\t}\n\tfprintf(log_fd, \"\\n\");\n#endif\n\nnextchar:\n\t// Advance to the next character, or advance to the next line, or\n\t// finish.\n\tif (clen != 0)\n\t    rex.input += clen;\n\telse if (go_to_nextline || (nfa_endp != NULL && REG_MULTI\n\t\t\t\t\t&& rex.lnum < nfa_endp->se_u.pos.lnum))\n\t    reg_nextline();\n\telse\n\t    break;\n\n\t// Allow interrupting with CTRL-C.\n\tline_breakcheck();\n\tif (got_int)\n\t    break;\n#ifdef FEAT_RELTIME\n\t// Check for timeout once in a twenty times to avoid overhead.\n\tif (nfa_time_limit != NULL && ++nfa_time_count == 20)\n\t{\n\t    nfa_time_count = 0;\n\t    if (nfa_did_time_out())\n\t\tbreak;\n\t}\n#endif\n    }\n\n#ifdef ENABLE_LOG\n    if (log_fd != stderr)\n\tfclose(log_fd);\n    log_fd = NULL;\n#endif\n\ntheend:\n    // Free memory\n    vim_free(list[0].t);\n    vim_free(list[1].t);\n    vim_free(listids);\n#undef ADD_STATE_IF_MATCH\n#ifdef NFA_REGEXP_DEBUG_LOG\n    fclose(debug);\n#endif\n\n    return nfa_match;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146516,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "nfa_regmatch(\n    nfa_regprog_T\t*prog,\n    nfa_state_T\t\t*start,\n    regsubs_T\t\t*submatch,\n    regsubs_T\t\t*m)\n{\n    int\t\tresult = FALSE;\n    size_t\tsize = 0;\n    int\t\tflag = 0;\n    int\t\tgo_to_nextline = FALSE;\n    nfa_thread_T *t;\n    nfa_list_T\tlist[2];\n    int\t\tlistidx;\n    nfa_list_T\t*thislist;\n    nfa_list_T\t*nextlist;\n    int\t\t*listids = NULL;\n    int\t\tlistids_len = 0;\n    nfa_state_T *add_state;\n    int\t\tadd_here;\n    int\t\tadd_count;\n    int\t\tadd_off = 0;\n    int\t\ttoplevel = start->c == NFA_MOPEN;\n    regsubs_T\t*r;\n#ifdef NFA_REGEXP_DEBUG_LOG\n    FILE\t*debug;\n#endif\n\n    // Some patterns may take a long time to match, especially when using\n    // recursive_regmatch(). Allow interrupting them with CTRL-C.\n    fast_breakcheck();\n    if (got_int)\n\treturn FALSE;\n#ifdef FEAT_RELTIME\n    if (nfa_did_time_out())\n\treturn FALSE;\n#endif\n\n#ifdef NFA_REGEXP_DEBUG_LOG\n    debug = fopen(NFA_REGEXP_DEBUG_LOG, \"a\");\n    if (debug == NULL)\n    {\n\tsemsg(\"(NFA) COULD NOT OPEN %s!\", NFA_REGEXP_DEBUG_LOG);\n\treturn FALSE;\n    }\n#endif\n    nfa_match = FALSE;\n\n    // Allocate memory for the lists of nodes.\n    size = (prog->nstate + 1) * sizeof(nfa_thread_T);\n\n    list[0].t = alloc(size);\n    list[0].len = prog->nstate + 1;\n    list[1].t = alloc(size);\n    list[1].len = prog->nstate + 1;\n    if (list[0].t == NULL || list[1].t == NULL)\n\tgoto theend;\n\n#ifdef ENABLE_LOG\n    log_fd = fopen(NFA_REGEXP_RUN_LOG, \"a\");\n    if (log_fd != NULL)\n    {\n\tfprintf(log_fd, \"**********************************\\n\");\n\tnfa_set_code(start->c);\n\tfprintf(log_fd, \" RUNNING nfa_regmatch() starting with state %d, code %s\\n\",\n\tabs(start->id), code);\n\tfprintf(log_fd, \"**********************************\\n\");\n    }\n    else\n    {\n\temsg(_(e_log_open_failed));\n\tlog_fd = stderr;\n    }\n#endif\n\n    thislist = &list[0];\n    thislist->n = 0;\n    thislist->has_pim = FALSE;\n    nextlist = &list[1];\n    nextlist->n = 0;\n    nextlist->has_pim = FALSE;\n#ifdef ENABLE_LOG\n    fprintf(log_fd, \"(---) STARTSTATE first\\n\");\n#endif\n    thislist->id = rex.nfa_listid + 1;\n\n    // Inline optimized code for addstate(thislist, start, m, 0) if we know\n    // it's the first MOPEN.\n    if (toplevel)\n    {\n\tif (REG_MULTI)\n\t{\n\t    m->norm.list.multi[0].start_lnum = rex.lnum;\n\t    m->norm.list.multi[0].start_col = (colnr_T)(rex.input - rex.line);\n\t}\n\telse\n\t    m->norm.list.line[0].start = rex.input;\n\tm->norm.in_use = 1;\n\tr = addstate(thislist, start->out, m, NULL, 0);\n    }\n    else\n\tr = addstate(thislist, start, m, NULL, 0);\n    if (r == NULL)\n    {\n\tnfa_match = NFA_TOO_EXPENSIVE;\n\tgoto theend;\n    }\n\n#define\tADD_STATE_IF_MATCH(state)\t\t\t\\\n    if (result) {\t\t\t\t\t\\\n\tadd_state = state->out;\t\t\t\t\\\n\tadd_off = clen;\t\t\t\t\t\\\n    }\n\n    /*\n     * Run for each character.\n     */\n    for (;;)\n    {\n\tint\tcurc;\n\tint\tclen;\n\n\tif (has_mbyte)\n\t{\n\t    curc = (*mb_ptr2char)(rex.input);\n\t    clen = (*mb_ptr2len)(rex.input);\n\t}\n\telse\n\t{\n\t    curc = *rex.input;\n\t    clen = 1;\n\t}\n\tif (curc == NUL)\n\t{\n\t    clen = 0;\n\t    go_to_nextline = FALSE;\n\t}\n\n\t// swap lists\n\tthislist = &list[flag];\n\tnextlist = &list[flag ^= 1];\n\tnextlist->n = 0;\t    // clear nextlist\n\tnextlist->has_pim = FALSE;\n\t++rex.nfa_listid;\n\tif (prog->re_engine == AUTOMATIC_ENGINE\n\t\t&& (rex.nfa_listid >= NFA_MAX_STATES\n# ifdef FEAT_EVAL\n\t\t    || nfa_fail_for_testing\n# endif\n\t\t    ))\n\t{\n\t    // too many states, retry with old engine\n\t    nfa_match = NFA_TOO_EXPENSIVE;\n\t    goto theend;\n\t}\n\n\tthislist->id = rex.nfa_listid;\n\tnextlist->id = rex.nfa_listid + 1;\n\n#ifdef ENABLE_LOG\n\tfprintf(log_fd, \"------------------------------------------\\n\");\n\tfprintf(log_fd, \">>> Reginput is \\\"%s\\\"\\n\", rex.input);\n\tfprintf(log_fd, \">>> Advanced one character... Current char is %c (code %d) \\n\", curc, (int)curc);\n\tfprintf(log_fd, \">>> Thislist has %d states available: \", thislist->n);\n\t{\n\t    int i;\n\n\t    for (i = 0; i < thislist->n; i++)\n\t\tfprintf(log_fd, \"%d  \", abs(thislist->t[i].state->id));\n\t}\n\tfprintf(log_fd, \"\\n\");\n#endif\n\n#ifdef NFA_REGEXP_DEBUG_LOG\n\tfprintf(debug, \"\\n-------------------\\n\");\n#endif\n\t/*\n\t * If the state lists are empty we can stop.\n\t */\n\tif (thislist->n == 0)\n\t    break;\n\n\t// compute nextlist\n\tfor (listidx = 0; listidx < thislist->n; ++listidx)\n\t{\n\t    // If the list gets very long there probably is something wrong.\n\t    // At least allow interrupting with CTRL-C.\n\t    fast_breakcheck();\n\t    if (got_int)\n\t\tbreak;\n#ifdef FEAT_RELTIME\n\t    if (nfa_time_limit != NULL && ++nfa_time_count == 20)\n\t    {\n\t\tnfa_time_count = 0;\n\t\tif (nfa_did_time_out())\n\t\t    break;\n\t    }\n#endif\n\t    t = &thislist->t[listidx];\n\n#ifdef NFA_REGEXP_DEBUG_LOG\n\t    nfa_set_code(t->state->c);\n\t    fprintf(debug, \"%s, \", code);\n#endif\n#ifdef ENABLE_LOG\n\t    {\n\t\tint col;\n\n\t\tif (t->subs.norm.in_use <= 0)\n\t\t    col = -1;\n\t\telse if (REG_MULTI)\n\t\t    col = t->subs.norm.list.multi[0].start_col;\n\t\telse\n\t\t    col = (int)(t->subs.norm.list.line[0].start - rex.line);\n\t\tnfa_set_code(t->state->c);\n\t\tfprintf(log_fd, \"(%d) char %d %s (start col %d)%s... \\n\",\n\t\t\tabs(t->state->id), (int)t->state->c, code, col,\n\t\t\tpim_info(&t->pim));\n\t    }\n#endif\n\n\t    /*\n\t     * Handle the possible codes of the current state.\n\t     * The most important is NFA_MATCH.\n\t     */\n\t    add_state = NULL;\n\t    add_here = FALSE;\n\t    add_count = 0;\n\t    switch (t->state->c)\n\t    {\n\t    case NFA_MATCH:\n\t      {\n\t\t// If the match is not at the start of the line, ends before a\n\t\t// composing characters and rex.reg_icombine is not set, that\n\t\t// is not really a match.\n\t\tif (enc_utf8 && !rex.reg_icombine\n\t\t\t     && rex.input != rex.line && utf_iscomposing(curc))\n\t\t    break;\n\n\t\tnfa_match = TRUE;\n\t\tcopy_sub(&submatch->norm, &t->subs.norm);\n#ifdef FEAT_SYN_HL\n\t\tif (rex.nfa_has_zsubexpr)\n\t\t    copy_sub(&submatch->synt, &t->subs.synt);\n#endif\n#ifdef ENABLE_LOG\n\t\tlog_subsexpr(&t->subs);\n#endif\n\t\t// Found the left-most longest match, do not look at any other\n\t\t// states at this position.  When the list of states is going\n\t\t// to be empty quit without advancing, so that \"rex.input\" is\n\t\t// correct.\n\t\tif (nextlist->n == 0)\n\t\t    clen = 0;\n\t\tgoto nextchar;\n\t      }\n\n\t    case NFA_END_INVISIBLE:\n\t    case NFA_END_INVISIBLE_NEG:\n\t    case NFA_END_PATTERN:\n\t\t/*\n\t\t * This is only encountered after a NFA_START_INVISIBLE or\n\t\t * NFA_START_INVISIBLE_BEFORE node.\n\t\t * They surround a zero-width group, used with \"\\@=\", \"\\&\",\n\t\t * \"\\@!\", \"\\@<=\" and \"\\@<!\".\n\t\t * If we got here, it means that the current \"invisible\" group\n\t\t * finished successfully, so return control to the parent\n\t\t * nfa_regmatch().  For a look-behind match only when it ends\n\t\t * in the position in \"nfa_endp\".\n\t\t * Submatches are stored in *m, and used in the parent call.\n\t\t */\n#ifdef ENABLE_LOG\n\t\tif (nfa_endp != NULL)\n\t\t{\n\t\t    if (REG_MULTI)\n\t\t\tfprintf(log_fd, \"Current lnum: %d, endp lnum: %d; current col: %d, endp col: %d\\n\",\n\t\t\t\t(int)rex.lnum,\n\t\t\t\t(int)nfa_endp->se_u.pos.lnum,\n\t\t\t\t(int)(rex.input - rex.line),\n\t\t\t\tnfa_endp->se_u.pos.col);\n\t\t    else\n\t\t\tfprintf(log_fd, \"Current col: %d, endp col: %d\\n\",\n\t\t\t\t(int)(rex.input - rex.line),\n\t\t\t\t(int)(nfa_endp->se_u.ptr - rex.input));\n\t\t}\n#endif\n\t\t// If \"nfa_endp\" is set it's only a match if it ends at\n\t\t// \"nfa_endp\"\n\t\tif (nfa_endp != NULL && (REG_MULTI\n\t\t\t? (rex.lnum != nfa_endp->se_u.pos.lnum\n\t\t\t    || (int)(rex.input - rex.line)\n\t\t\t\t\t\t!= nfa_endp->se_u.pos.col)\n\t\t\t: rex.input != nfa_endp->se_u.ptr))\n\t\t    break;\n\n\t\t// do not set submatches for \\@!\n\t\tif (t->state->c != NFA_END_INVISIBLE_NEG)\n\t\t{\n\t\t    copy_sub(&m->norm, &t->subs.norm);\n#ifdef FEAT_SYN_HL\n\t\t    if (rex.nfa_has_zsubexpr)\n\t\t\tcopy_sub(&m->synt, &t->subs.synt);\n#endif\n\t\t}\n#ifdef ENABLE_LOG\n\t\tfprintf(log_fd, \"Match found:\\n\");\n\t\tlog_subsexpr(m);\n#endif\n\t\tnfa_match = TRUE;\n\t\t// See comment above at \"goto nextchar\".\n\t\tif (nextlist->n == 0)\n\t\t    clen = 0;\n\t\tgoto nextchar;\n\n\t    case NFA_START_INVISIBLE:\n\t    case NFA_START_INVISIBLE_FIRST:\n\t    case NFA_START_INVISIBLE_NEG:\n\t    case NFA_START_INVISIBLE_NEG_FIRST:\n\t    case NFA_START_INVISIBLE_BEFORE:\n\t    case NFA_START_INVISIBLE_BEFORE_FIRST:\n\t    case NFA_START_INVISIBLE_BEFORE_NEG:\n\t    case NFA_START_INVISIBLE_BEFORE_NEG_FIRST:\n\t\t{\n#ifdef ENABLE_LOG\n\t\t    fprintf(log_fd, \"Failure chance invisible: %d, what follows: %d\\n\",\n\t\t\t    failure_chance(t->state->out, 0),\n\t\t\t    failure_chance(t->state->out1->out, 0));\n#endif\n\t\t    // Do it directly if there already is a PIM or when\n\t\t    // nfa_postprocess() detected it will work better.\n\t\t    if (t->pim.result != NFA_PIM_UNUSED\n\t\t\t || t->state->c == NFA_START_INVISIBLE_FIRST\n\t\t\t || t->state->c == NFA_START_INVISIBLE_NEG_FIRST\n\t\t\t || t->state->c == NFA_START_INVISIBLE_BEFORE_FIRST\n\t\t\t || t->state->c == NFA_START_INVISIBLE_BEFORE_NEG_FIRST)\n\t\t    {\n\t\t\tint in_use = m->norm.in_use;\n\n\t\t\t// Copy submatch info for the recursive call, opposite\n\t\t\t// of what happens on success below.\n\t\t\tcopy_sub_off(&m->norm, &t->subs.norm);\n#ifdef FEAT_SYN_HL\n\t\t\tif (rex.nfa_has_zsubexpr)\n\t\t\t    copy_sub_off(&m->synt, &t->subs.synt);\n#endif\n\n\t\t\t/*\n\t\t\t * First try matching the invisible match, then what\n\t\t\t * follows.\n\t\t\t */\n\t\t\tresult = recursive_regmatch(t->state, NULL, prog,\n\t\t\t\t\t  submatch, m, &listids, &listids_len);\n\t\t\tif (result == NFA_TOO_EXPENSIVE)\n\t\t\t{\n\t\t\t    nfa_match = result;\n\t\t\t    goto theend;\n\t\t\t}\n\n\t\t\t// for \\@! and \\@<! it is a match when the result is\n\t\t\t// FALSE\n\t\t\tif (result != (t->state->c == NFA_START_INVISIBLE_NEG\n\t\t\t       || t->state->c == NFA_START_INVISIBLE_NEG_FIRST\n\t\t\t       || t->state->c\n\t\t\t\t\t   == NFA_START_INVISIBLE_BEFORE_NEG\n\t\t\t       || t->state->c\n\t\t\t\t     == NFA_START_INVISIBLE_BEFORE_NEG_FIRST))\n\t\t\t{\n\t\t\t    // Copy submatch info from the recursive call\n\t\t\t    copy_sub_off(&t->subs.norm, &m->norm);\n#ifdef FEAT_SYN_HL\n\t\t\t    if (rex.nfa_has_zsubexpr)\n\t\t\t\tcopy_sub_off(&t->subs.synt, &m->synt);\n#endif\n\t\t\t    // If the pattern has \\ze and it matched in the\n\t\t\t    // sub pattern, use it.\n\t\t\t    copy_ze_off(&t->subs.norm, &m->norm);\n\n\t\t\t    // t->state->out1 is the corresponding\n\t\t\t    // END_INVISIBLE node; Add its out to the current\n\t\t\t    // list (zero-width match).\n\t\t\t    add_here = TRUE;\n\t\t\t    add_state = t->state->out1->out;\n\t\t\t}\n\t\t\tm->norm.in_use = in_use;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tnfa_pim_T pim;\n\n\t\t\t/*\n\t\t\t * First try matching what follows.  Only if a match\n\t\t\t * is found verify the invisible match matches.  Add a\n\t\t\t * nfa_pim_T to the following states, it contains info\n\t\t\t * about the invisible match.\n\t\t\t */\n\t\t\tpim.state = t->state;\n\t\t\tpim.result = NFA_PIM_TODO;\n\t\t\tpim.subs.norm.in_use = 0;\n#ifdef FEAT_SYN_HL\n\t\t\tpim.subs.synt.in_use = 0;\n#endif\n\t\t\tif (REG_MULTI)\n\t\t\t{\n\t\t\t    pim.end.pos.col = (int)(rex.input - rex.line);\n\t\t\t    pim.end.pos.lnum = rex.lnum;\n\t\t\t}\n\t\t\telse\n\t\t\t    pim.end.ptr = rex.input;\n\n\t\t\t// t->state->out1 is the corresponding END_INVISIBLE\n\t\t\t// node; Add its out to the current list (zero-width\n\t\t\t// match).\n\t\t\tif (addstate_here(thislist, t->state->out1->out,\n\t\t\t\t\t     &t->subs, &pim, &listidx) == NULL)\n\t\t\t{\n\t\t\t    nfa_match = NFA_TOO_EXPENSIVE;\n\t\t\t    goto theend;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    case NFA_START_PATTERN:\n\t      {\n\t\tnfa_state_T *skip = NULL;\n#ifdef ENABLE_LOG\n\t\tint\t    skip_lid = 0;\n#endif\n\n\t\t// There is no point in trying to match the pattern if the\n\t\t// output state is not going to be added to the list.\n\t\tif (state_in_list(nextlist, t->state->out1->out, &t->subs))\n\t\t{\n\t\t    skip = t->state->out1->out;\n#ifdef ENABLE_LOG\n\t\t    skip_lid = nextlist->id;\n#endif\n\t\t}\n\t\telse if (state_in_list(nextlist,\n\t\t\t\t\t  t->state->out1->out->out, &t->subs))\n\t\t{\n\t\t    skip = t->state->out1->out->out;\n#ifdef ENABLE_LOG\n\t\t    skip_lid = nextlist->id;\n#endif\n\t\t}\n\t\telse if (state_in_list(thislist,\n\t\t\t\t\t  t->state->out1->out->out, &t->subs))\n\t\t{\n\t\t    skip = t->state->out1->out->out;\n#ifdef ENABLE_LOG\n\t\t    skip_lid = thislist->id;\n#endif\n\t\t}\n\t\tif (skip != NULL)\n\t\t{\n#ifdef ENABLE_LOG\n\t\t    nfa_set_code(skip->c);\n\t\t    fprintf(log_fd, \"> Not trying to match pattern, output state %d is already in list %d. char %d: %s\\n\",\n\t\t\t    abs(skip->id), skip_lid, skip->c, code);\n#endif\n\t\t    break;\n\t\t}\n\t\t// Copy submatch info to the recursive call, opposite of what\n\t\t// happens afterwards.\n\t\tcopy_sub_off(&m->norm, &t->subs.norm);\n#ifdef FEAT_SYN_HL\n\t\tif (rex.nfa_has_zsubexpr)\n\t\t    copy_sub_off(&m->synt, &t->subs.synt);\n#endif\n\n\t\t// First try matching the pattern.\n\t\tresult = recursive_regmatch(t->state, NULL, prog,\n\t\t\t\t\t  submatch, m, &listids, &listids_len);\n\t\tif (result == NFA_TOO_EXPENSIVE)\n\t\t{\n\t\t    nfa_match = result;\n\t\t    goto theend;\n\t\t}\n\t\tif (result)\n\t\t{\n\t\t    int bytelen;\n\n#ifdef ENABLE_LOG\n\t\t    fprintf(log_fd, \"NFA_START_PATTERN matches:\\n\");\n\t\t    log_subsexpr(m);\n#endif\n\t\t    // Copy submatch info from the recursive call\n\t\t    copy_sub_off(&t->subs.norm, &m->norm);\n#ifdef FEAT_SYN_HL\n\t\t    if (rex.nfa_has_zsubexpr)\n\t\t\tcopy_sub_off(&t->subs.synt, &m->synt);\n#endif\n\t\t    // Now we need to skip over the matched text and then\n\t\t    // continue with what follows.\n\t\t    if (REG_MULTI)\n\t\t\t// TODO: multi-line match\n\t\t\tbytelen = m->norm.list.multi[0].end_col\n\t\t\t\t\t\t  - (int)(rex.input - rex.line);\n\t\t    else\n\t\t\tbytelen = (int)(m->norm.list.line[0].end - rex.input);\n\n#ifdef ENABLE_LOG\n\t\t    fprintf(log_fd, \"NFA_START_PATTERN length: %d\\n\", bytelen);\n#endif\n\t\t    if (bytelen == 0)\n\t\t    {\n\t\t\t// empty match, output of corresponding\n\t\t\t// NFA_END_PATTERN/NFA_SKIP to be used at current\n\t\t\t// position\n\t\t\tadd_here = TRUE;\n\t\t\tadd_state = t->state->out1->out->out;\n\t\t    }\n\t\t    else if (bytelen <= clen)\n\t\t    {\n\t\t\t// match current character, output of corresponding\n\t\t\t// NFA_END_PATTERN to be used at next position.\n\t\t\tadd_state = t->state->out1->out->out;\n\t\t\tadd_off = clen;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// skip over the matched characters, set character\n\t\t\t// count in NFA_SKIP\n\t\t\tadd_state = t->state->out1->out;\n\t\t\tadd_off = bytelen;\n\t\t\tadd_count = bytelen - clen;\n\t\t    }\n\t\t}\n\t\tbreak;\n\t      }\n\n\t    case NFA_BOL:\n\t\tif (rex.input == rex.line)\n\t\t{\n\t\t    add_here = TRUE;\n\t\t    add_state = t->state->out;\n\t\t}\n\t\tbreak;\n\n\t    case NFA_EOL:\n\t\tif (curc == NUL)\n\t\t{\n\t\t    add_here = TRUE;\n\t\t    add_state = t->state->out;\n\t\t}\n\t\tbreak;\n\n\t    case NFA_BOW:\n\t\tresult = TRUE;\n\n\t\tif (curc == NUL)\n\t\t    result = FALSE;\n\t\telse if (has_mbyte)\n\t\t{\n\t\t    int this_class;\n\n\t\t    // Get class of current and previous char (if it exists).\n\t\t    this_class = mb_get_class_buf(rex.input, rex.reg_buf);\n\t\t    if (this_class <= 1)\n\t\t\tresult = FALSE;\n\t\t    else if (reg_prev_class() == this_class)\n\t\t\tresult = FALSE;\n\t\t}\n\t\telse if (!vim_iswordc_buf(curc, rex.reg_buf)\n\t\t\t   || (rex.input > rex.line\n\t\t\t\t&& vim_iswordc_buf(rex.input[-1], rex.reg_buf)))\n\t\t    result = FALSE;\n\t\tif (result)\n\t\t{\n\t\t    add_here = TRUE;\n\t\t    add_state = t->state->out;\n\t\t}\n\t\tbreak;\n\n\t    case NFA_EOW:\n\t\tresult = TRUE;\n\t\tif (rex.input == rex.line)\n\t\t    result = FALSE;\n\t\telse if (has_mbyte)\n\t\t{\n\t\t    int this_class, prev_class;\n\n\t\t    // Get class of current and previous char (if it exists).\n\t\t    this_class = mb_get_class_buf(rex.input, rex.reg_buf);\n\t\t    prev_class = reg_prev_class();\n\t\t    if (this_class == prev_class\n\t\t\t\t\t|| prev_class == 0 || prev_class == 1)\n\t\t\tresult = FALSE;\n\t\t}\n\t\telse if (!vim_iswordc_buf(rex.input[-1], rex.reg_buf)\n\t\t\t|| (rex.input[0] != NUL\n\t\t\t\t\t&& vim_iswordc_buf(curc, rex.reg_buf)))\n\t\t    result = FALSE;\n\t\tif (result)\n\t\t{\n\t\t    add_here = TRUE;\n\t\t    add_state = t->state->out;\n\t\t}\n\t\tbreak;\n\n\t    case NFA_BOF:\n\t\tif (rex.lnum == 0 && rex.input == rex.line\n\t\t\t\t     && (!REG_MULTI || rex.reg_firstlnum == 1))\n\t\t{\n\t\t    add_here = TRUE;\n\t\t    add_state = t->state->out;\n\t\t}\n\t\tbreak;\n\n\t    case NFA_EOF:\n\t\tif (rex.lnum == rex.reg_maxline && curc == NUL)\n\t\t{\n\t\t    add_here = TRUE;\n\t\t    add_state = t->state->out;\n\t\t}\n\t\tbreak;\n\n\t    case NFA_COMPOSING:\n\t    {\n\t\tint\t    mc = curc;\n\t\tint\t    len = 0;\n\t\tnfa_state_T *end;\n\t\tnfa_state_T *sta;\n\t\tint\t    cchars[MAX_MCO];\n\t\tint\t    ccount = 0;\n\t\tint\t    j;\n\n\t\tsta = t->state->out;\n\t\tlen = 0;\n\t\tif (utf_iscomposing(sta->c))\n\t\t{\n\t\t    // Only match composing character(s), ignore base\n\t\t    // character.  Used for \".{composing}\" and \"{composing}\"\n\t\t    // (no preceding character).\n\t\t    len += mb_char2len(mc);\n\t\t}\n\t\tif (rex.reg_icombine && len == 0)\n\t\t{\n\t\t    // If \\Z was present, then ignore composing characters.\n\t\t    // When ignoring the base character this always matches.\n\t\t    if (sta->c != curc)\n\t\t\tresult = FAIL;\n\t\t    else\n\t\t\tresult = OK;\n\t\t    while (sta->c != NFA_END_COMPOSING)\n\t\t\tsta = sta->out;\n\t\t}\n\n\t\t// Check base character matches first, unless ignored.\n\t\telse if (len > 0 || mc == sta->c)\n\t\t{\n\t\t    if (len == 0)\n\t\t    {\n\t\t\tlen += mb_char2len(mc);\n\t\t\tsta = sta->out;\n\t\t    }\n\n\t\t    // We don't care about the order of composing characters.\n\t\t    // Get them into cchars[] first.\n\t\t    while (len < clen)\n\t\t    {\n\t\t\tmc = mb_ptr2char(rex.input + len);\n\t\t\tcchars[ccount++] = mc;\n\t\t\tlen += mb_char2len(mc);\n\t\t\tif (ccount == MAX_MCO)\n\t\t\t    break;\n\t\t    }\n\n\t\t    // Check that each composing char in the pattern matches a\n\t\t    // composing char in the text.  We do not check if all\n\t\t    // composing chars are matched.\n\t\t    result = OK;\n\t\t    while (sta->c != NFA_END_COMPOSING)\n\t\t    {\n\t\t\tfor (j = 0; j < ccount; ++j)\n\t\t\t    if (cchars[j] == sta->c)\n\t\t\t\tbreak;\n\t\t\tif (j == ccount)\n\t\t\t{\n\t\t\t    result = FAIL;\n\t\t\t    break;\n\t\t\t}\n\t\t\tsta = sta->out;\n\t\t    }\n\t\t}\n\t\telse\n\t\t    result = FAIL;\n\n\t\tend = t->state->out1;\t    // NFA_END_COMPOSING\n\t\tADD_STATE_IF_MATCH(end);\n\t\tbreak;\n\t    }\n\n\t    case NFA_NEWL:\n\t\tif (curc == NUL && !rex.reg_line_lbr && REG_MULTI\n\t\t\t\t\t\t && rex.lnum <= rex.reg_maxline)\n\t\t{\n\t\t    go_to_nextline = TRUE;\n\t\t    // Pass -1 for the offset, which means taking the position\n\t\t    // at the start of the next line.\n\t\t    add_state = t->state->out;\n\t\t    add_off = -1;\n\t\t}\n\t\telse if (curc == '\\n' && rex.reg_line_lbr)\n\t\t{\n\t\t    // match \\n as if it is an ordinary character\n\t\t    add_state = t->state->out;\n\t\t    add_off = 1;\n\t\t}\n\t\tbreak;\n\n\t    case NFA_START_COLL:\n\t    case NFA_START_NEG_COLL:\n\t      {\n\t\t// What follows is a list of characters, until NFA_END_COLL.\n\t\t// One of them must match or none of them must match.\n\t\tnfa_state_T\t*state;\n\t\tint\t\tresult_if_matched;\n\t\tint\t\tc1, c2;\n\n\t\t// Never match EOL. If it's part of the collection it is added\n\t\t// as a separate state with an OR.\n\t\tif (curc == NUL)\n\t\t    break;\n\n\t\tstate = t->state->out;\n\t\tresult_if_matched = (t->state->c == NFA_START_COLL);\n\t\tfor (;;)\n\t\t{\n\t\t    if (state->c == NFA_END_COLL)\n\t\t    {\n\t\t\tresult = !result_if_matched;\n\t\t\tbreak;\n\t\t    }\n\t\t    if (state->c == NFA_RANGE_MIN)\n\t\t    {\n\t\t\tc1 = state->val;\n\t\t\tstate = state->out; // advance to NFA_RANGE_MAX\n\t\t\tc2 = state->val;\n#ifdef ENABLE_LOG\n\t\t\tfprintf(log_fd, \"NFA_RANGE_MIN curc=%d c1=%d c2=%d\\n\",\n\t\t\t\tcurc, c1, c2);\n#endif\n\t\t\tif (curc >= c1 && curc <= c2)\n\t\t\t{\n\t\t\t    result = result_if_matched;\n\t\t\t    break;\n\t\t\t}\n\t\t\tif (rex.reg_ic)\n\t\t\t{\n\t\t\t    int curc_low = MB_CASEFOLD(curc);\n\t\t\t    int done = FALSE;\n\n\t\t\t    for ( ; c1 <= c2; ++c1)\n\t\t\t\tif (MB_CASEFOLD(c1) == curc_low)\n\t\t\t\t{\n\t\t\t\t    result = result_if_matched;\n\t\t\t\t    done = TRUE;\n\t\t\t\t    break;\n\t\t\t\t}\n\t\t\t    if (done)\n\t\t\t\tbreak;\n\t\t\t}\n\t\t    }\n\t\t    else if (state->c < 0 ? check_char_class(state->c, curc)\n\t\t\t       : (curc == state->c\n\t\t\t\t   || (rex.reg_ic && MB_CASEFOLD(curc)\n\t\t\t\t\t\t    == MB_CASEFOLD(state->c))))\n\t\t    {\n\t\t\tresult = result_if_matched;\n\t\t\tbreak;\n\t\t    }\n\t\t    state = state->out;\n\t\t}\n\t\tif (result)\n\t\t{\n\t\t    // next state is in out of the NFA_END_COLL, out1 of\n\t\t    // START points to the END state\n\t\t    add_state = t->state->out1->out;\n\t\t    add_off = clen;\n\t\t}\n\t\tbreak;\n\t      }\n\n\t    case NFA_ANY:\n\t\t// Any char except '\\0', (end of input) does not match.\n\t\tif (curc > 0)\n\t\t{\n\t\t    add_state = t->state->out;\n\t\t    add_off = clen;\n\t\t}\n\t\tbreak;\n\n\t    case NFA_ANY_COMPOSING:\n\t\t// On a composing character skip over it.  Otherwise do\n\t\t// nothing.  Always matches.\n\t\tif (enc_utf8 && utf_iscomposing(curc))\n\t\t{\n\t\t    add_off = clen;\n\t\t}\n\t\telse\n\t\t{\n\t\t    add_here = TRUE;\n\t\t    add_off = 0;\n\t\t}\n\t\tadd_state = t->state->out;\n\t\tbreak;\n\n\t    /*\n\t     * Character classes like \\a for alpha, \\d for digit etc.\n\t     */\n\t    case NFA_IDENT:\t//  \\i\n\t\tresult = vim_isIDc(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_SIDENT:\t//  \\I\n\t\tresult = !VIM_ISDIGIT(curc) && vim_isIDc(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_KWORD:\t//  \\k\n\t\tresult = vim_iswordp_buf(rex.input, rex.reg_buf);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_SKWORD:\t//  \\K\n\t\tresult = !VIM_ISDIGIT(curc)\n\t\t\t\t     && vim_iswordp_buf(rex.input, rex.reg_buf);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_FNAME:\t//  \\f\n\t\tresult = vim_isfilec(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_SFNAME:\t//  \\F\n\t\tresult = !VIM_ISDIGIT(curc) && vim_isfilec(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_PRINT:\t//  \\p\n\t\tresult = vim_isprintc(PTR2CHAR(rex.input));\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_SPRINT:\t//  \\P\n\t\tresult = !VIM_ISDIGIT(curc) && vim_isprintc(PTR2CHAR(rex.input));\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_WHITE:\t//  \\s\n\t\tresult = VIM_ISWHITE(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_NWHITE:\t//  \\S\n\t\tresult = curc != NUL && !VIM_ISWHITE(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_DIGIT:\t//  \\d\n\t\tresult = ri_digit(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_NDIGIT:\t//  \\D\n\t\tresult = curc != NUL && !ri_digit(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_HEX:\t//  \\x\n\t\tresult = ri_hex(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_NHEX:\t//  \\X\n\t\tresult = curc != NUL && !ri_hex(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_OCTAL:\t//  \\o\n\t\tresult = ri_octal(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_NOCTAL:\t//  \\O\n\t\tresult = curc != NUL && !ri_octal(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_WORD:\t//  \\w\n\t\tresult = ri_word(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_NWORD:\t//  \\W\n\t\tresult = curc != NUL && !ri_word(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_HEAD:\t//  \\h\n\t\tresult = ri_head(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_NHEAD:\t//  \\H\n\t\tresult = curc != NUL && !ri_head(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_ALPHA:\t//  \\a\n\t\tresult = ri_alpha(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_NALPHA:\t//  \\A\n\t\tresult = curc != NUL && !ri_alpha(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_LOWER:\t//  \\l\n\t\tresult = ri_lower(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_NLOWER:\t//  \\L\n\t\tresult = curc != NUL && !ri_lower(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_UPPER:\t//  \\u\n\t\tresult = ri_upper(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_NUPPER:\t// \\U\n\t\tresult = curc != NUL && !ri_upper(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_LOWER_IC:\t// [a-z]\n\t\tresult = ri_lower(curc) || (rex.reg_ic && ri_upper(curc));\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_NLOWER_IC:\t// [^a-z]\n\t\tresult = curc != NUL\n\t\t\t&& !(ri_lower(curc) || (rex.reg_ic && ri_upper(curc)));\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_UPPER_IC:\t// [A-Z]\n\t\tresult = ri_upper(curc) || (rex.reg_ic && ri_lower(curc));\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_NUPPER_IC:\t// ^[A-Z]\n\t\tresult = curc != NUL\n\t\t\t&& !(ri_upper(curc) || (rex.reg_ic && ri_lower(curc)));\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_BACKREF1:\n\t    case NFA_BACKREF2:\n\t    case NFA_BACKREF3:\n\t    case NFA_BACKREF4:\n\t    case NFA_BACKREF5:\n\t    case NFA_BACKREF6:\n\t    case NFA_BACKREF7:\n\t    case NFA_BACKREF8:\n\t    case NFA_BACKREF9:\n#ifdef FEAT_SYN_HL\n\t    case NFA_ZREF1:\n\t    case NFA_ZREF2:\n\t    case NFA_ZREF3:\n\t    case NFA_ZREF4:\n\t    case NFA_ZREF5:\n\t    case NFA_ZREF6:\n\t    case NFA_ZREF7:\n\t    case NFA_ZREF8:\n\t    case NFA_ZREF9:\n#endif\n\t\t// \\1 .. \\9  \\z1 .. \\z9\n\t      {\n\t\tint subidx;\n\t\tint bytelen;\n\n\t\tif (t->state->c <= NFA_BACKREF9)\n\t\t{\n\t\t    subidx = t->state->c - NFA_BACKREF1 + 1;\n\t\t    result = match_backref(&t->subs.norm, subidx, &bytelen);\n\t\t}\n#ifdef FEAT_SYN_HL\n\t\telse\n\t\t{\n\t\t    subidx = t->state->c - NFA_ZREF1 + 1;\n\t\t    result = match_zref(subidx, &bytelen);\n\t\t}\n#endif\n\n\t\tif (result)\n\t\t{\n\t\t    if (bytelen == 0)\n\t\t    {\n\t\t\t// empty match always works, output of NFA_SKIP to be\n\t\t\t// used next\n\t\t\tadd_here = TRUE;\n\t\t\tadd_state = t->state->out->out;\n\t\t    }\n\t\t    else if (bytelen <= clen)\n\t\t    {\n\t\t\t// match current character, jump ahead to out of\n\t\t\t// NFA_SKIP\n\t\t\tadd_state = t->state->out->out;\n\t\t\tadd_off = clen;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// skip over the matched characters, set character\n\t\t\t// count in NFA_SKIP\n\t\t\tadd_state = t->state->out;\n\t\t\tadd_off = bytelen;\n\t\t\tadd_count = bytelen - clen;\n\t\t    }\n\t\t}\n\t\tbreak;\n\t      }\n\t    case NFA_SKIP:\n\t      // character of previous matching \\1 .. \\9  or \\@>\n\t      if (t->count - clen <= 0)\n\t      {\n\t\t  // end of match, go to what follows\n\t\t  add_state = t->state->out;\n\t\t  add_off = clen;\n\t      }\n\t      else\n\t      {\n\t\t  // add state again with decremented count\n\t\t  add_state = t->state;\n\t\t  add_off = 0;\n\t\t  add_count = t->count - clen;\n\t      }\n\t      break;\n\n\t    case NFA_LNUM:\n\t    case NFA_LNUM_GT:\n\t    case NFA_LNUM_LT:\n\t\tresult = (REG_MULTI &&\n\t\t\tnfa_re_num_cmp(t->state->val, t->state->c - NFA_LNUM,\n\t\t\t    (long_u)(rex.lnum + rex.reg_firstlnum)));\n\t\tif (result)\n\t\t{\n\t\t    add_here = TRUE;\n\t\t    add_state = t->state->out;\n\t\t}\n\t\tbreak;\n\n\t    case NFA_COL:\n\t    case NFA_COL_GT:\n\t    case NFA_COL_LT:\n\t\tresult = nfa_re_num_cmp(t->state->val, t->state->c - NFA_COL,\n\t\t\t(long_u)(rex.input - rex.line) + 1);\n\t\tif (result)\n\t\t{\n\t\t    add_here = TRUE;\n\t\t    add_state = t->state->out;\n\t\t}\n\t\tbreak;\n\n\t    case NFA_VCOL:\n\t    case NFA_VCOL_GT:\n\t    case NFA_VCOL_LT:\n\t\t{\n\t\t    int     op = t->state->c - NFA_VCOL;\n\t\t    colnr_T col = (colnr_T)(rex.input - rex.line);\n\t\t    win_T   *wp = rex.reg_win == NULL ? curwin : rex.reg_win;\n\n\t\t    // Bail out quickly when there can't be a match, avoid the\n\t\t    // overhead of win_linetabsize() on long lines.\n\t\t    if (op != 1 && col > t->state->val\n\t\t\t    * (has_mbyte ? MB_MAXBYTES : 1))\n\t\t\tbreak;\n\t\t    result = FALSE;\n\t\t    if (op == 1 && col - 1 > t->state->val && col > 100)\n\t\t    {\n\t\t\tint ts = wp->w_buffer->b_p_ts;\n\n\t\t\t// Guess that a character won't use more columns than\n\t\t\t// 'tabstop', with a minimum of 4.\n\t\t\tif (ts < 4)\n\t\t\t    ts = 4;\n\t\t\tresult = col > t->state->val * ts;\n\t\t    }\n\t\t    if (!result)\n\t\t\tresult = nfa_re_num_cmp(t->state->val, op,\n\t\t\t\t(long_u)win_linetabsize(wp, rex.line, col) + 1);\n\t\t    if (result)\n\t\t    {\n\t\t\tadd_here = TRUE;\n\t\t\tadd_state = t->state->out;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    case NFA_MARK:\n\t    case NFA_MARK_GT:\n\t    case NFA_MARK_LT:\n\t      {\n\t\tsize_t\tcol = rex.input - rex.line;\n\t\tpos_T\t*pos = getmark_buf(rex.reg_buf, t->state->val, FALSE);\n\n\t\t// Line may have been freed, get it again.\n\t\tif (REG_MULTI)\n\t\t{\n\t\t    rex.line = reg_getline(rex.lnum);\n\t\t    rex.input = rex.line + col;\n\t\t}\n\n\t\t// Compare the mark position to the match position, if the mark\n\t\t// exists and mark is set in reg_buf.\n\t\tif (pos != NULL && pos->lnum > 0)\n\t\t{\n\t\t    colnr_T pos_col = pos->lnum == rex.lnum + rex.reg_firstlnum\n\t\t\t\t\t\t\t  && pos->col == MAXCOL\n\t\t\t\t      ? (colnr_T)STRLEN(reg_getline(\n\t\t\t\t\t\tpos->lnum - rex.reg_firstlnum))\n\t\t\t\t      : pos->col;\n\n\t\t    result = (pos->lnum == rex.lnum + rex.reg_firstlnum\n\t\t\t\t? (pos_col == (colnr_T)(rex.input - rex.line)\n\t\t\t\t    ? t->state->c == NFA_MARK\n\t\t\t\t    : (pos_col < (colnr_T)(rex.input - rex.line)\n\t\t\t\t\t? t->state->c == NFA_MARK_GT\n\t\t\t\t\t: t->state->c == NFA_MARK_LT))\n\t\t\t\t: (pos->lnum < rex.lnum + rex.reg_firstlnum\n\t\t\t\t    ? t->state->c == NFA_MARK_GT\n\t\t\t\t    : t->state->c == NFA_MARK_LT));\n\t\t    if (result)\n\t\t    {\n\t\t\tadd_here = TRUE;\n\t\t\tadd_state = t->state->out;\n\t\t    }\n\t\t}\n\t\tbreak;\n\t      }\n\n\t    case NFA_CURSOR:\n\t\tresult = (rex.reg_win != NULL\n\t\t\t&& (rex.lnum + rex.reg_firstlnum\n\t\t\t\t\t\t == rex.reg_win->w_cursor.lnum)\n\t\t\t&& ((colnr_T)(rex.input - rex.line)\n\t\t\t\t\t\t== rex.reg_win->w_cursor.col));\n\t\tif (result)\n\t\t{\n\t\t    add_here = TRUE;\n\t\t    add_state = t->state->out;\n\t\t}\n\t\tbreak;\n\n\t    case NFA_VISUAL:\n\t\tresult = reg_match_visual();\n\t\tif (result)\n\t\t{\n\t\t    add_here = TRUE;\n\t\t    add_state = t->state->out;\n\t\t}\n\t\tbreak;\n\n\t    case NFA_MOPEN1:\n\t    case NFA_MOPEN2:\n\t    case NFA_MOPEN3:\n\t    case NFA_MOPEN4:\n\t    case NFA_MOPEN5:\n\t    case NFA_MOPEN6:\n\t    case NFA_MOPEN7:\n\t    case NFA_MOPEN8:\n\t    case NFA_MOPEN9:\n#ifdef FEAT_SYN_HL\n\t    case NFA_ZOPEN:\n\t    case NFA_ZOPEN1:\n\t    case NFA_ZOPEN2:\n\t    case NFA_ZOPEN3:\n\t    case NFA_ZOPEN4:\n\t    case NFA_ZOPEN5:\n\t    case NFA_ZOPEN6:\n\t    case NFA_ZOPEN7:\n\t    case NFA_ZOPEN8:\n\t    case NFA_ZOPEN9:\n#endif\n\t    case NFA_NOPEN:\n\t    case NFA_ZSTART:\n\t\t// These states are only added to be able to bail out when\n\t\t// they are added again, nothing is to be done.\n\t\tbreak;\n\n\t    default:\t// regular character\n\t      {\n\t\tint c = t->state->c;\n\n#ifdef DEBUG\n\t\tif (c < 0)\n\t\t    siemsg(\"INTERNAL: Negative state char: %ld\", c);\n#endif\n\t\tresult = (c == curc);\n\n\t\tif (!result && rex.reg_ic)\n\t\t    result = MB_CASEFOLD(c) == MB_CASEFOLD(curc);\n\t\t// If rex.reg_icombine is not set only skip over the character\n\t\t// itself.  When it is set skip over composing characters.\n\t\tif (result && enc_utf8 && !rex.reg_icombine)\n\t\t    clen = utf_ptr2len(rex.input);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\t      }\n\n\t    } // switch (t->state->c)\n\n\t    if (add_state != NULL)\n\t    {\n\t\tnfa_pim_T *pim;\n\t\tnfa_pim_T pim_copy;\n\n\t\tif (t->pim.result == NFA_PIM_UNUSED)\n\t\t    pim = NULL;\n\t\telse\n\t\t    pim = &t->pim;\n\n\t\t// Handle the postponed invisible match if the match might end\n\t\t// without advancing and before the end of the line.\n\t\tif (pim != NULL && (clen == 0 || match_follows(add_state, 0)))\n\t\t{\n\t\t    if (pim->result == NFA_PIM_TODO)\n\t\t    {\n#ifdef ENABLE_LOG\n\t\t\tfprintf(log_fd, \"\\n\");\n\t\t\tfprintf(log_fd, \"==================================\\n\");\n\t\t\tfprintf(log_fd, \"Postponed recursive nfa_regmatch()\\n\");\n\t\t\tfprintf(log_fd, \"\\n\");\n#endif\n\t\t\tresult = recursive_regmatch(pim->state, pim,\n\t\t\t\t    prog, submatch, m, &listids, &listids_len);\n\t\t\tpim->result = result ? NFA_PIM_MATCH : NFA_PIM_NOMATCH;\n\t\t\t// for \\@! and \\@<! it is a match when the result is\n\t\t\t// FALSE\n\t\t\tif (result != (pim->state->c == NFA_START_INVISIBLE_NEG\n\t\t\t     || pim->state->c == NFA_START_INVISIBLE_NEG_FIRST\n\t\t\t     || pim->state->c\n\t\t\t\t\t   == NFA_START_INVISIBLE_BEFORE_NEG\n\t\t\t     || pim->state->c\n\t\t\t\t     == NFA_START_INVISIBLE_BEFORE_NEG_FIRST))\n\t\t\t{\n\t\t\t    // Copy submatch info from the recursive call\n\t\t\t    copy_sub_off(&pim->subs.norm, &m->norm);\n#ifdef FEAT_SYN_HL\n\t\t\t    if (rex.nfa_has_zsubexpr)\n\t\t\t\tcopy_sub_off(&pim->subs.synt, &m->synt);\n#endif\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tresult = (pim->result == NFA_PIM_MATCH);\n#ifdef ENABLE_LOG\n\t\t\tfprintf(log_fd, \"\\n\");\n\t\t\tfprintf(log_fd, \"Using previous recursive nfa_regmatch() result, result == %d\\n\", pim->result);\n\t\t\tfprintf(log_fd, \"MATCH = %s\\n\", result == TRUE ? \"OK\" : \"FALSE\");\n\t\t\tfprintf(log_fd, \"\\n\");\n#endif\n\t\t    }\n\n\t\t    // for \\@! and \\@<! it is a match when result is FALSE\n\t\t    if (result != (pim->state->c == NFA_START_INVISIBLE_NEG\n\t\t\t     || pim->state->c == NFA_START_INVISIBLE_NEG_FIRST\n\t\t\t     || pim->state->c\n\t\t\t\t\t   == NFA_START_INVISIBLE_BEFORE_NEG\n\t\t\t     || pim->state->c\n\t\t\t\t     == NFA_START_INVISIBLE_BEFORE_NEG_FIRST))\n\t\t    {\n\t\t\t// Copy submatch info from the recursive call\n\t\t\tcopy_sub_off(&t->subs.norm, &pim->subs.norm);\n#ifdef FEAT_SYN_HL\n\t\t\tif (rex.nfa_has_zsubexpr)\n\t\t\t    copy_sub_off(&t->subs.synt, &pim->subs.synt);\n#endif\n\t\t    }\n\t\t    else\n\t\t\t// look-behind match failed, don't add the state\n\t\t\tcontinue;\n\n\t\t    // Postponed invisible match was handled, don't add it to\n\t\t    // following states.\n\t\t    pim = NULL;\n\t\t}\n\n\t\t// If \"pim\" points into l->t it will become invalid when\n\t\t// adding the state causes the list to be reallocated.  Make a\n\t\t// local copy to avoid that.\n\t\tif (pim == &t->pim)\n\t\t{\n\t\t    copy_pim(&pim_copy, pim);\n\t\t    pim = &pim_copy;\n\t\t}\n\n\t\tif (add_here)\n\t\t    r = addstate_here(thislist, add_state, &t->subs,\n\t\t\t\t\t\t\t\tpim, &listidx);\n\t\telse\n\t\t{\n\t\t    r = addstate(nextlist, add_state, &t->subs, pim, add_off);\n\t\t    if (add_count > 0)\n\t\t\tnextlist->t[nextlist->n - 1].count = add_count;\n\t\t}\n\t\tif (r == NULL)\n\t\t{\n\t\t    nfa_match = NFA_TOO_EXPENSIVE;\n\t\t    goto theend;\n\t\t}\n\t    }\n\n\t} // for (thislist = thislist; thislist->state; thislist++)\n\n\t// Look for the start of a match in the current position by adding the\n\t// start state to the list of states.\n\t// The first found match is the leftmost one, thus the order of states\n\t// matters!\n\t// Do not add the start state in recursive calls of nfa_regmatch(),\n\t// because recursive calls should only start in the first position.\n\t// Unless \"nfa_endp\" is not NULL, then we match the end position.\n\t// Also don't start a match past the first line.\n\tif (nfa_match == FALSE\n\t\t&& ((toplevel\n\t\t\t&& rex.lnum == 0\n\t\t\t&& clen != 0\n\t\t\t&& (rex.reg_maxcol == 0\n\t\t\t    || (colnr_T)(rex.input - rex.line) < rex.reg_maxcol))\n\t\t    || (nfa_endp != NULL\n\t\t\t&& (REG_MULTI\n\t\t\t    ? (rex.lnum < nfa_endp->se_u.pos.lnum\n\t\t\t       || (rex.lnum == nfa_endp->se_u.pos.lnum\n\t\t\t\t   && (int)(rex.input - rex.line)\n\t\t\t\t\t\t    < nfa_endp->se_u.pos.col))\n\t\t\t    : rex.input < nfa_endp->se_u.ptr))))\n\t{\n#ifdef ENABLE_LOG\n\t    fprintf(log_fd, \"(---) STARTSTATE\\n\");\n#endif\n\t    // Inline optimized code for addstate() if we know the state is\n\t    // the first MOPEN.\n\t    if (toplevel)\n\t    {\n\t\tint add = TRUE;\n\t\tint c;\n\n\t\tif (prog->regstart != NUL && clen != 0)\n\t\t{\n\t\t    if (nextlist->n == 0)\n\t\t    {\n\t\t\tcolnr_T col = (colnr_T)(rex.input - rex.line) + clen;\n\n\t\t\t// Nextlist is empty, we can skip ahead to the\n\t\t\t// character that must appear at the start.\n\t\t\tif (skip_to_start(prog->regstart, &col) == FAIL)\n\t\t\t    break;\n#ifdef ENABLE_LOG\n\t\t\tfprintf(log_fd, \"  Skipping ahead %d bytes to regstart\\n\",\n\t\t\t\tcol - ((colnr_T)(rex.input - rex.line) + clen));\n#endif\n\t\t\trex.input = rex.line + col - clen;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// Checking if the required start character matches is\n\t\t\t// cheaper than adding a state that won't match.\n\t\t\tc = PTR2CHAR(rex.input + clen);\n\t\t\tif (c != prog->regstart && (!rex.reg_ic\n\t\t\t     || MB_CASEFOLD(c) != MB_CASEFOLD(prog->regstart)))\n\t\t\t{\n#ifdef ENABLE_LOG\n\t\t\t    fprintf(log_fd, \"  Skipping start state, regstart does not match\\n\");\n#endif\n\t\t\t    add = FALSE;\n\t\t\t}\n\t\t    }\n\t\t}\n\n\t\tif (add)\n\t\t{\n\t\t    if (REG_MULTI)\n\t\t\tm->norm.list.multi[0].start_col =\n\t\t\t\t\t (colnr_T)(rex.input - rex.line) + clen;\n\t\t    else\n\t\t\tm->norm.list.line[0].start = rex.input + clen;\n\t\t    if (addstate(nextlist, start->out, m, NULL, clen) == NULL)\n\t\t    {\n\t\t\tnfa_match = NFA_TOO_EXPENSIVE;\n\t\t\tgoto theend;\n\t\t    }\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tif (addstate(nextlist, start, m, NULL, clen) == NULL)\n\t\t{\n\t\t    nfa_match = NFA_TOO_EXPENSIVE;\n\t\t    goto theend;\n\t\t}\n\t    }\n\t}\n\n#ifdef ENABLE_LOG\n\tfprintf(log_fd, \">>> Thislist had %d states available: \", thislist->n);\n\t{\n\t    int i;\n\n\t    for (i = 0; i < thislist->n; i++)\n\t\tfprintf(log_fd, \"%d  \", abs(thislist->t[i].state->id));\n\t}\n\tfprintf(log_fd, \"\\n\");\n#endif\n\nnextchar:\n\t// Advance to the next character, or advance to the next line, or\n\t// finish.\n\tif (clen != 0)\n\t    rex.input += clen;\n\telse if (go_to_nextline || (nfa_endp != NULL && REG_MULTI\n\t\t\t\t\t&& rex.lnum < nfa_endp->se_u.pos.lnum))\n\t    reg_nextline();\n\telse\n\t    break;\n\n\t// Allow interrupting with CTRL-C.\n\tline_breakcheck();\n\tif (got_int)\n\t    break;\n#ifdef FEAT_RELTIME\n\t// Check for timeout once in a twenty times to avoid overhead.\n\tif (nfa_time_limit != NULL && ++nfa_time_count == 20)\n\t{\n\t    nfa_time_count = 0;\n\t    if (nfa_did_time_out())\n\t\tbreak;\n\t}\n#endif\n    }\n\n#ifdef ENABLE_LOG\n    if (log_fd != stderr)\n\tfclose(log_fd);\n    log_fd = NULL;\n#endif\n\ntheend:\n    // Free memory\n    vim_free(list[0].t);\n    vim_free(list[1].t);\n    vim_free(listids);\n#undef ADD_STATE_IF_MATCH\n#ifdef NFA_REGEXP_DEBUG_LOG\n    fclose(debug);\n#endif\n\n    return nfa_match;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146517,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static void userfaultfd_event_wait_completion(struct userfaultfd_ctx *ctx,\n\t\t\t\t\t      struct userfaultfd_wait_queue *ewq)\n{\n\tif (WARN_ON_ONCE(current->flags & PF_EXITING))\n\t\tgoto out;\n\n\tewq->ctx = ctx;\n\tinit_waitqueue_entry(&ewq->wq, current);\n\n\tspin_lock(&ctx->event_wqh.lock);\n\t/*\n\t * After the __add_wait_queue the uwq is visible to userland\n\t * through poll/read().\n\t */\n\t__add_wait_queue(&ctx->event_wqh, &ewq->wq);\n\tfor (;;) {\n\t\tset_current_state(TASK_KILLABLE);\n\t\tif (ewq->msg.event == 0)\n\t\t\tbreak;\n\t\tif (READ_ONCE(ctx->released) ||\n\t\t    fatal_signal_pending(current)) {\n\t\t\t/*\n\t\t\t * &ewq->wq may be queued in fork_event, but\n\t\t\t * __remove_wait_queue ignores the head\n\t\t\t * parameter. It would be a problem if it\n\t\t\t * didn't.\n\t\t\t */\n\t\t\t__remove_wait_queue(&ctx->event_wqh, &ewq->wq);\n\t\t\tif (ewq->msg.event == UFFD_EVENT_FORK) {\n\t\t\t\tstruct userfaultfd_ctx *new;\n\n\t\t\t\tnew = (struct userfaultfd_ctx *)\n\t\t\t\t\t(unsigned long)\n\t\t\t\t\tewq->msg.arg.reserved.reserved1;\n\n\t\t\t\tuserfaultfd_ctx_put(new);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tspin_unlock(&ctx->event_wqh.lock);\n\n\t\twake_up_poll(&ctx->fd_wqh, POLLIN);\n\t\tschedule();\n\n\t\tspin_lock(&ctx->event_wqh.lock);\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tspin_unlock(&ctx->event_wqh.lock);\n\n\t/*\n\t * ctx may go away after this if the userfault pseudo fd is\n\t * already released.\n\t */\nout:\n\tuserfaultfd_ctx_put(ctx);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146536,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static void userfaultfd_event_wait_completion(struct userfaultfd_ctx *ctx,\n\t\t\t\t\t      struct userfaultfd_wait_queue *ewq)\n{\n\tstruct userfaultfd_ctx *release_new_ctx;\n\n\tif (WARN_ON_ONCE(current->flags & PF_EXITING))\n\t\tgoto out;\n\n\tewq->ctx = ctx;\n\tinit_waitqueue_entry(&ewq->wq, current);\n\trelease_new_ctx = NULL;\n\n\tspin_lock(&ctx->event_wqh.lock);\n\t/*\n\t * After the __add_wait_queue the uwq is visible to userland\n\t * through poll/read().\n\t */\n\t__add_wait_queue(&ctx->event_wqh, &ewq->wq);\n\tfor (;;) {\n\t\tset_current_state(TASK_KILLABLE);\n\t\tif (ewq->msg.event == 0)\n\t\t\tbreak;\n\t\tif (READ_ONCE(ctx->released) ||\n\t\t    fatal_signal_pending(current)) {\n\t\t\t/*\n\t\t\t * &ewq->wq may be queued in fork_event, but\n\t\t\t * __remove_wait_queue ignores the head\n\t\t\t * parameter. It would be a problem if it\n\t\t\t * didn't.\n\t\t\t */\n\t\t\t__remove_wait_queue(&ctx->event_wqh, &ewq->wq);\n\t\t\tif (ewq->msg.event == UFFD_EVENT_FORK) {\n\t\t\t\tstruct userfaultfd_ctx *new;\n\n\t\t\t\tnew = (struct userfaultfd_ctx *)\n\t\t\t\t\t(unsigned long)\n\t\t\t\t\tewq->msg.arg.reserved.reserved1;\n\t\t\t\trelease_new_ctx = new;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tspin_unlock(&ctx->event_wqh.lock);\n\n\t\twake_up_poll(&ctx->fd_wqh, POLLIN);\n\t\tschedule();\n\n\t\tspin_lock(&ctx->event_wqh.lock);\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tspin_unlock(&ctx->event_wqh.lock);\n\n\tif (release_new_ctx) {\n\t\tstruct vm_area_struct *vma;\n\t\tstruct mm_struct *mm = release_new_ctx->mm;\n\n\t\t/* the various vma->vm_userfaultfd_ctx still points to it */\n\t\tdown_write(&mm->mmap_sem);\n\t\tfor (vma = mm->mmap; vma; vma = vma->vm_next)\n\t\t\tif (vma->vm_userfaultfd_ctx.ctx == release_new_ctx)\n\t\t\t\tvma->vm_userfaultfd_ctx = NULL_VM_UFFD_CTX;\n\t\tup_write(&mm->mmap_sem);\n\n\t\tuserfaultfd_ctx_put(release_new_ctx);\n\t}\n\n\t/*\n\t * ctx may go away after this if the userfault pseudo fd is\n\t * already released.\n\t */\nout:\n\tuserfaultfd_ctx_put(ctx);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146537,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static void opj_j2k_set_cinema_parameters(opj_cparameters_t *parameters,\n        opj_image_t *image, opj_event_mgr_t *p_manager)\n{\n    /* Configure cinema parameters */\n    int i;\n\n    /* No tiling */\n    parameters->tile_size_on = OPJ_FALSE;\n    parameters->cp_tdx = 1;\n    parameters->cp_tdy = 1;\n\n    /* One tile part for each component */\n    parameters->tp_flag = 'C';\n    parameters->tp_on = 1;\n\n    /* Tile and Image shall be at (0,0) */\n    parameters->cp_tx0 = 0;\n    parameters->cp_ty0 = 0;\n    parameters->image_offset_x0 = 0;\n    parameters->image_offset_y0 = 0;\n\n    /* Codeblock size= 32*32 */\n    parameters->cblockw_init = 32;\n    parameters->cblockh_init = 32;\n\n    /* Codeblock style: no mode switch enabled */\n    parameters->mode = 0;\n\n    /* No ROI */\n    parameters->roi_compno = -1;\n\n    /* No subsampling */\n    parameters->subsampling_dx = 1;\n    parameters->subsampling_dy = 1;\n\n    /* 9-7 transform */\n    parameters->irreversible = 1;\n\n    /* Number of layers */\n    if (parameters->tcp_numlayers > 1) {\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\\n\"\n                      \"1 single quality layer\"\n                      \"-> Number of layers forced to 1 (rather than %d)\\n\"\n                      \"-> Rate of the last layer (%3.1f) will be used\",\n                      parameters->tcp_numlayers,\n                      parameters->tcp_rates[parameters->tcp_numlayers - 1]);\n        parameters->tcp_rates[0] = parameters->tcp_rates[parameters->tcp_numlayers - 1];\n        parameters->tcp_numlayers = 1;\n    }\n\n    /* Resolution levels */\n    switch (parameters->rsiz) {\n    case OPJ_PROFILE_CINEMA_2K:\n        if (parameters->numresolution > 6) {\n            opj_event_msg(p_manager, EVT_WARNING,\n                          \"JPEG 2000 Profile-3 (2k dc profile) requires:\\n\"\n                          \"Number of decomposition levels <= 5\\n\"\n                          \"-> Number of decomposition levels forced to 5 (rather than %d)\\n\",\n                          parameters->numresolution + 1);\n            parameters->numresolution = 6;\n        }\n        break;\n    case OPJ_PROFILE_CINEMA_4K:\n        if (parameters->numresolution < 2) {\n            opj_event_msg(p_manager, EVT_WARNING,\n                          \"JPEG 2000 Profile-4 (4k dc profile) requires:\\n\"\n                          \"Number of decomposition levels >= 1 && <= 6\\n\"\n                          \"-> Number of decomposition levels forced to 1 (rather than %d)\\n\",\n                          parameters->numresolution + 1);\n            parameters->numresolution = 1;\n        } else if (parameters->numresolution > 7) {\n            opj_event_msg(p_manager, EVT_WARNING,\n                          \"JPEG 2000 Profile-4 (4k dc profile) requires:\\n\"\n                          \"Number of decomposition levels >= 1 && <= 6\\n\"\n                          \"-> Number of decomposition levels forced to 6 (rather than %d)\\n\",\n                          parameters->numresolution + 1);\n            parameters->numresolution = 7;\n        }\n        break;\n    default :\n        break;\n    }\n\n    /* Precincts */\n    parameters->csty |= 0x01;\n    parameters->res_spec = parameters->numresolution - 1;\n    for (i = 0; i < parameters->res_spec; i++) {\n        parameters->prcw_init[i] = 256;\n        parameters->prch_init[i] = 256;\n    }\n\n    /* The progression order shall be CPRL */\n    parameters->prog_order = OPJ_CPRL;\n\n    /* Progression order changes for 4K, disallowed for 2K */\n    if (parameters->rsiz == OPJ_PROFILE_CINEMA_4K) {\n        parameters->numpocs = (OPJ_UINT32)opj_j2k_initialise_4K_poc(parameters->POC,\n                              parameters->numresolution);\n    } else {\n        parameters->numpocs = 0;\n    }\n\n    /* Limited bit-rate */\n    parameters->cp_disto_alloc = 1;\n    if (parameters->max_cs_size <= 0) {\n        /* No rate has been introduced, 24 fps is assumed */\n        parameters->max_cs_size = OPJ_CINEMA_24_CS;\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\\n\"\n                      \"Maximum 1302083 compressed bytes @ 24fps\\n\"\n                      \"As no rate has been given, this limit will be used.\\n\");\n    } else if (parameters->max_cs_size > OPJ_CINEMA_24_CS) {\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\\n\"\n                      \"Maximum 1302083 compressed bytes @ 24fps\\n\"\n                      \"-> Specified rate exceeds this limit. Rate will be forced to 1302083 bytes.\\n\");\n        parameters->max_cs_size = OPJ_CINEMA_24_CS;\n    }\n\n    if (parameters->max_comp_size <= 0) {\n        /* No rate has been introduced, 24 fps is assumed */\n        parameters->max_comp_size = OPJ_CINEMA_24_COMP;\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\\n\"\n                      \"Maximum 1041666 compressed bytes @ 24fps\\n\"\n                      \"As no rate has been given, this limit will be used.\\n\");\n    } else if (parameters->max_comp_size > OPJ_CINEMA_24_COMP) {\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\\n\"\n                      \"Maximum 1041666 compressed bytes @ 24fps\\n\"\n                      \"-> Specified rate exceeds this limit. Rate will be forced to 1041666 bytes.\\n\");\n        parameters->max_comp_size = OPJ_CINEMA_24_COMP;\n    }\n\n    parameters->tcp_rates[0] = (OPJ_FLOAT32)(image->numcomps * image->comps[0].w *\n                               image->comps[0].h * image->comps[0].prec) /\n                               (OPJ_FLOAT32)(((OPJ_UINT32)parameters->max_cs_size) * 8 * image->comps[0].dx *\n                                       image->comps[0].dy);\n\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146542,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static void opj_j2k_set_cinema_parameters(opj_cparameters_t *parameters,\n        opj_image_t *image, opj_event_mgr_t *p_manager)\n{\n    /* Configure cinema parameters */\n    int i;\n\n    /* No tiling */\n    parameters->tile_size_on = OPJ_FALSE;\n    parameters->cp_tdx = 1;\n    parameters->cp_tdy = 1;\n\n    /* One tile part for each component */\n    parameters->tp_flag = 'C';\n    parameters->tp_on = 1;\n\n    /* Tile and Image shall be at (0,0) */\n    parameters->cp_tx0 = 0;\n    parameters->cp_ty0 = 0;\n    parameters->image_offset_x0 = 0;\n    parameters->image_offset_y0 = 0;\n\n    /* Codeblock size= 32*32 */\n    parameters->cblockw_init = 32;\n    parameters->cblockh_init = 32;\n\n    /* Codeblock style: no mode switch enabled */\n    parameters->mode = 0;\n\n    /* No ROI */\n    parameters->roi_compno = -1;\n\n    /* No subsampling */\n    parameters->subsampling_dx = 1;\n    parameters->subsampling_dy = 1;\n\n    /* 9-7 transform */\n    parameters->irreversible = 1;\n\n    /* Number of layers */\n    if (parameters->tcp_numlayers > 1) {\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\\n\"\n                      \"1 single quality layer\"\n                      \"-> Number of layers forced to 1 (rather than %d)\\n\"\n                      \"-> Rate of the last layer (%3.1f) will be used\",\n                      parameters->tcp_numlayers,\n                      parameters->tcp_rates[parameters->tcp_numlayers - 1]);\n        parameters->tcp_rates[0] = parameters->tcp_rates[parameters->tcp_numlayers - 1];\n        parameters->tcp_numlayers = 1;\n    }\n\n    /* Resolution levels */\n    switch (parameters->rsiz) {\n    case OPJ_PROFILE_CINEMA_2K:\n        if (parameters->numresolution > 6) {\n            opj_event_msg(p_manager, EVT_WARNING,\n                          \"JPEG 2000 Profile-3 (2k dc profile) requires:\\n\"\n                          \"Number of decomposition levels <= 5\\n\"\n                          \"-> Number of decomposition levels forced to 5 (rather than %d)\\n\",\n                          parameters->numresolution + 1);\n            parameters->numresolution = 6;\n        }\n        break;\n    case OPJ_PROFILE_CINEMA_4K:\n        if (parameters->numresolution < 2) {\n            opj_event_msg(p_manager, EVT_WARNING,\n                          \"JPEG 2000 Profile-4 (4k dc profile) requires:\\n\"\n                          \"Number of decomposition levels >= 1 && <= 6\\n\"\n                          \"-> Number of decomposition levels forced to 1 (rather than %d)\\n\",\n                          parameters->numresolution + 1);\n            parameters->numresolution = 1;\n        } else if (parameters->numresolution > 7) {\n            opj_event_msg(p_manager, EVT_WARNING,\n                          \"JPEG 2000 Profile-4 (4k dc profile) requires:\\n\"\n                          \"Number of decomposition levels >= 1 && <= 6\\n\"\n                          \"-> Number of decomposition levels forced to 6 (rather than %d)\\n\",\n                          parameters->numresolution + 1);\n            parameters->numresolution = 7;\n        }\n        break;\n    default :\n        break;\n    }\n\n    /* Precincts */\n    parameters->csty |= 0x01;\n    if (parameters->numresolution == 1) {\n        parameters->res_spec = 1;\n        parameters->prcw_init[0] = 128;\n        parameters->prch_init[0] = 128;\n    } else {\n        parameters->res_spec = parameters->numresolution - 1;\n        for (i = 0; i < parameters->res_spec; i++) {\n            parameters->prcw_init[i] = 256;\n            parameters->prch_init[i] = 256;\n        }\n    }\n\n    /* The progression order shall be CPRL */\n    parameters->prog_order = OPJ_CPRL;\n\n    /* Progression order changes for 4K, disallowed for 2K */\n    if (parameters->rsiz == OPJ_PROFILE_CINEMA_4K) {\n        parameters->numpocs = (OPJ_UINT32)opj_j2k_initialise_4K_poc(parameters->POC,\n                              parameters->numresolution);\n    } else {\n        parameters->numpocs = 0;\n    }\n\n    /* Limited bit-rate */\n    parameters->cp_disto_alloc = 1;\n    if (parameters->max_cs_size <= 0) {\n        /* No rate has been introduced, 24 fps is assumed */\n        parameters->max_cs_size = OPJ_CINEMA_24_CS;\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\\n\"\n                      \"Maximum 1302083 compressed bytes @ 24fps\\n\"\n                      \"As no rate has been given, this limit will be used.\\n\");\n    } else if (parameters->max_cs_size > OPJ_CINEMA_24_CS) {\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\\n\"\n                      \"Maximum 1302083 compressed bytes @ 24fps\\n\"\n                      \"-> Specified rate exceeds this limit. Rate will be forced to 1302083 bytes.\\n\");\n        parameters->max_cs_size = OPJ_CINEMA_24_CS;\n    }\n\n    if (parameters->max_comp_size <= 0) {\n        /* No rate has been introduced, 24 fps is assumed */\n        parameters->max_comp_size = OPJ_CINEMA_24_COMP;\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\\n\"\n                      \"Maximum 1041666 compressed bytes @ 24fps\\n\"\n                      \"As no rate has been given, this limit will be used.\\n\");\n    } else if (parameters->max_comp_size > OPJ_CINEMA_24_COMP) {\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\\n\"\n                      \"Maximum 1041666 compressed bytes @ 24fps\\n\"\n                      \"-> Specified rate exceeds this limit. Rate will be forced to 1041666 bytes.\\n\");\n        parameters->max_comp_size = OPJ_CINEMA_24_COMP;\n    }\n\n    parameters->tcp_rates[0] = (OPJ_FLOAT32)(image->numcomps * image->comps[0].w *\n                               image->comps[0].h * image->comps[0].prec) /\n                               (OPJ_FLOAT32)(((OPJ_UINT32)parameters->max_cs_size) * 8 * image->comps[0].dx *\n                                       image->comps[0].dy);\n\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146543,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int usb_raremono_probe(struct usb_interface *intf,\n\t\t\t\tconst struct usb_device_id *id)\n{\n\tstruct raremono_device *radio;\n\tint retval = 0;\n\n\tradio = devm_kzalloc(&intf->dev, sizeof(struct raremono_device), GFP_KERNEL);\n\tif (radio)\n\t\tradio->buffer = devm_kmalloc(&intf->dev, BUFFER_LENGTH, GFP_KERNEL);\n\n\tif (!radio || !radio->buffer)\n\t\treturn -ENOMEM;\n\n\tradio->usbdev = interface_to_usbdev(intf);\n\tradio->intf = intf;\n\n\t/*\n\t * This device uses the same USB IDs as the si470x SiLabs reference\n\t * design. So do an additional check: attempt to read the device ID\n\t * from the si470x: the lower 12 bits are 0x0242 for the si470x. The\n\t * Raremono always returns 0x0800 (the meaning of that is unknown, but\n\t * at least it works).\n\t *\n\t * We use this check to determine which device we are dealing with.\n\t */\n\tmsleep(20);\n\tretval = usb_control_msg(radio->usbdev,\n\t\tusb_rcvctrlpipe(radio->usbdev, 0),\n\t\tHID_REQ_GET_REPORT,\n\t\tUSB_TYPE_CLASS | USB_RECIP_INTERFACE | USB_DIR_IN,\n\t\t1, 2,\n\t\tradio->buffer, 3, 500);\n\tif (retval != 3 ||\n\t    (get_unaligned_be16(&radio->buffer[1]) & 0xfff) == 0x0242) {\n\t\tdev_info(&intf->dev, \"this is not Thanko's Raremono.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdev_info(&intf->dev, \"Thanko's Raremono connected: (%04X:%04X)\\n\",\n\t\t\tid->idVendor, id->idProduct);\n\n\tretval = v4l2_device_register(&intf->dev, &radio->v4l2_dev);\n\tif (retval < 0) {\n\t\tdev_err(&intf->dev, \"couldn't register v4l2_device\\n\");\n\t\treturn retval;\n\t}\n\n\tmutex_init(&radio->lock);\n\n\tstrscpy(radio->vdev.name, radio->v4l2_dev.name,\n\t\tsizeof(radio->vdev.name));\n\tradio->vdev.v4l2_dev = &radio->v4l2_dev;\n\tradio->vdev.fops = &usb_raremono_fops;\n\tradio->vdev.ioctl_ops = &usb_raremono_ioctl_ops;\n\tradio->vdev.lock = &radio->lock;\n\tradio->vdev.release = video_device_release_empty;\n\tradio->vdev.device_caps = V4L2_CAP_TUNER | V4L2_CAP_RADIO;\n\n\tusb_set_intfdata(intf, &radio->v4l2_dev);\n\n\tvideo_set_drvdata(&radio->vdev, radio);\n\n\traremono_cmd_main(radio, BAND_FM, 95160);\n\n\tretval = video_register_device(&radio->vdev, VFL_TYPE_RADIO, -1);\n\tif (retval == 0) {\n\t\tdev_info(&intf->dev, \"V4L2 device registered as %s\\n\",\n\t\t\t\tvideo_device_node_name(&radio->vdev));\n\t\treturn 0;\n\t}\n\tdev_err(&intf->dev, \"could not register video device\\n\");\n\tv4l2_device_unregister(&radio->v4l2_dev);\n\treturn retval;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146556,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int usb_raremono_probe(struct usb_interface *intf,\n\t\t\t\tconst struct usb_device_id *id)\n{\n\tstruct raremono_device *radio;\n\tint retval = 0;\n\n\tradio = kzalloc(sizeof(*radio), GFP_KERNEL);\n\tif (!radio)\n\t\treturn -ENOMEM;\n\tradio->buffer = kmalloc(BUFFER_LENGTH, GFP_KERNEL);\n\tif (!radio->buffer) {\n\t\tkfree(radio);\n\t\treturn -ENOMEM;\n\t}\n\n\tradio->usbdev = interface_to_usbdev(intf);\n\tradio->intf = intf;\n\n\t/*\n\t * This device uses the same USB IDs as the si470x SiLabs reference\n\t * design. So do an additional check: attempt to read the device ID\n\t * from the si470x: the lower 12 bits are 0x0242 for the si470x. The\n\t * Raremono always returns 0x0800 (the meaning of that is unknown, but\n\t * at least it works).\n\t *\n\t * We use this check to determine which device we are dealing with.\n\t */\n\tmsleep(20);\n\tretval = usb_control_msg(radio->usbdev,\n\t\tusb_rcvctrlpipe(radio->usbdev, 0),\n\t\tHID_REQ_GET_REPORT,\n\t\tUSB_TYPE_CLASS | USB_RECIP_INTERFACE | USB_DIR_IN,\n\t\t1, 2,\n\t\tradio->buffer, 3, 500);\n\tif (retval != 3 ||\n\t    (get_unaligned_be16(&radio->buffer[1]) & 0xfff) == 0x0242) {\n\t\tdev_info(&intf->dev, \"this is not Thanko's Raremono.\\n\");\n\t\tretval = -ENODEV;\n\t\tgoto free_mem;\n\t}\n\n\tdev_info(&intf->dev, \"Thanko's Raremono connected: (%04X:%04X)\\n\",\n\t\t\tid->idVendor, id->idProduct);\n\n\tretval = v4l2_device_register(&intf->dev, &radio->v4l2_dev);\n\tif (retval < 0) {\n\t\tdev_err(&intf->dev, \"couldn't register v4l2_device\\n\");\n\t\tgoto free_mem;\n\t}\n\n\tmutex_init(&radio->lock);\n\n\tstrscpy(radio->vdev.name, radio->v4l2_dev.name,\n\t\tsizeof(radio->vdev.name));\n\tradio->vdev.v4l2_dev = &radio->v4l2_dev;\n\tradio->vdev.fops = &usb_raremono_fops;\n\tradio->vdev.ioctl_ops = &usb_raremono_ioctl_ops;\n\tradio->vdev.lock = &radio->lock;\n\tradio->vdev.release = video_device_release_empty;\n\tradio->vdev.device_caps = V4L2_CAP_TUNER | V4L2_CAP_RADIO;\n\tradio->v4l2_dev.release = raremono_device_release;\n\n\tusb_set_intfdata(intf, &radio->v4l2_dev);\n\n\tvideo_set_drvdata(&radio->vdev, radio);\n\n\traremono_cmd_main(radio, BAND_FM, 95160);\n\n\tretval = video_register_device(&radio->vdev, VFL_TYPE_RADIO, -1);\n\tif (retval == 0) {\n\t\tdev_info(&intf->dev, \"V4L2 device registered as %s\\n\",\n\t\t\t\tvideo_device_node_name(&radio->vdev));\n\t\treturn 0;\n\t}\n\tdev_err(&intf->dev, \"could not register video device\\n\");\n\tv4l2_device_unregister(&radio->v4l2_dev);\n\nfree_mem:\n\tkfree(radio->buffer);\n\tkfree(radio);\n\treturn retval;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146557,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int read_rindex_entry(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tconst unsigned bsize = sdp->sd_sb.sb_bsize;\n\tloff_t pos = sdp->sd_rgrps * sizeof(struct gfs2_rindex);\n\tstruct gfs2_rindex buf;\n\tint error;\n\tstruct gfs2_rgrpd *rgd;\n\n\tif (pos >= i_size_read(&ip->i_inode))\n\t\treturn 1;\n\n\terror = gfs2_internal_read(ip, (char *)&buf, &pos,\n\t\t\t\t   sizeof(struct gfs2_rindex));\n\n\tif (error != sizeof(struct gfs2_rindex))\n\t\treturn (error == 0) ? 1 : error;\n\n\trgd = kmem_cache_zalloc(gfs2_rgrpd_cachep, GFP_NOFS);\n\terror = -ENOMEM;\n\tif (!rgd)\n\t\treturn error;\n\n\trgd->rd_sbd = sdp;\n\trgd->rd_addr = be64_to_cpu(buf.ri_addr);\n\trgd->rd_length = be32_to_cpu(buf.ri_length);\n\trgd->rd_data0 = be64_to_cpu(buf.ri_data0);\n\trgd->rd_data = be32_to_cpu(buf.ri_data);\n\trgd->rd_bitbytes = be32_to_cpu(buf.ri_bitbytes);\n\tspin_lock_init(&rgd->rd_rsspin);\n\n\terror = compute_bitstructs(rgd);\n\tif (error)\n\t\tgoto fail;\n\n\terror = gfs2_glock_get(sdp, rgd->rd_addr,\n\t\t\t       &gfs2_rgrp_glops, CREATE, &rgd->rd_gl);\n\tif (error)\n\t\tgoto fail;\n\n\trgd->rd_gl->gl_object = rgd;\n\trgd->rd_gl->gl_vm.start = (rgd->rd_addr * bsize) & PAGE_MASK;\n\trgd->rd_gl->gl_vm.end = PAGE_ALIGN((rgd->rd_addr + rgd->rd_length) * bsize) - 1;\n\trgd->rd_rgl = (struct gfs2_rgrp_lvb *)rgd->rd_gl->gl_lksb.sb_lvbptr;\n\trgd->rd_flags &= ~(GFS2_RDF_UPTODATE | GFS2_RDF_PREFERRED);\n\tif (rgd->rd_data > sdp->sd_max_rg_data)\n\t\tsdp->sd_max_rg_data = rgd->rd_data;\n\tspin_lock(&sdp->sd_rindex_spin);\n\terror = rgd_insert(rgd);\n\tspin_unlock(&sdp->sd_rindex_spin);\n\tif (!error)\n\t\treturn 0;\n\n\terror = 0; /* someone else read in the rgrp; free it and ignore it */\n\tgfs2_glock_put(rgd->rd_gl);\n\nfail:\n\tkfree(rgd->rd_bits);\n\tkmem_cache_free(gfs2_rgrpd_cachep, rgd);\n\treturn error;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146600,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int read_rindex_entry(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tconst unsigned bsize = sdp->sd_sb.sb_bsize;\n\tloff_t pos = sdp->sd_rgrps * sizeof(struct gfs2_rindex);\n\tstruct gfs2_rindex buf;\n\tint error;\n\tstruct gfs2_rgrpd *rgd;\n\n\tif (pos >= i_size_read(&ip->i_inode))\n\t\treturn 1;\n\n\terror = gfs2_internal_read(ip, (char *)&buf, &pos,\n\t\t\t\t   sizeof(struct gfs2_rindex));\n\n\tif (error != sizeof(struct gfs2_rindex))\n\t\treturn (error == 0) ? 1 : error;\n\n\trgd = kmem_cache_zalloc(gfs2_rgrpd_cachep, GFP_NOFS);\n\terror = -ENOMEM;\n\tif (!rgd)\n\t\treturn error;\n\n\trgd->rd_sbd = sdp;\n\trgd->rd_addr = be64_to_cpu(buf.ri_addr);\n\trgd->rd_length = be32_to_cpu(buf.ri_length);\n\trgd->rd_data0 = be64_to_cpu(buf.ri_data0);\n\trgd->rd_data = be32_to_cpu(buf.ri_data);\n\trgd->rd_bitbytes = be32_to_cpu(buf.ri_bitbytes);\n\tspin_lock_init(&rgd->rd_rsspin);\n\n\terror = compute_bitstructs(rgd);\n\tif (error)\n\t\tgoto fail;\n\n\terror = gfs2_glock_get(sdp, rgd->rd_addr,\n\t\t\t       &gfs2_rgrp_glops, CREATE, &rgd->rd_gl);\n\tif (error)\n\t\tgoto fail;\n\n\trgd->rd_rgl = (struct gfs2_rgrp_lvb *)rgd->rd_gl->gl_lksb.sb_lvbptr;\n\trgd->rd_flags &= ~(GFS2_RDF_UPTODATE | GFS2_RDF_PREFERRED);\n\tif (rgd->rd_data > sdp->sd_max_rg_data)\n\t\tsdp->sd_max_rg_data = rgd->rd_data;\n\tspin_lock(&sdp->sd_rindex_spin);\n\terror = rgd_insert(rgd);\n\tspin_unlock(&sdp->sd_rindex_spin);\n\tif (!error) {\n\t\trgd->rd_gl->gl_object = rgd;\n\t\trgd->rd_gl->gl_vm.start = (rgd->rd_addr * bsize) & PAGE_MASK;\n\t\trgd->rd_gl->gl_vm.end = PAGE_ALIGN((rgd->rd_addr +\n\t\t\t\t\t\t    rgd->rd_length) * bsize) - 1;\n\t\treturn 0;\n\t}\n\n\terror = 0; /* someone else read in the rgrp; free it and ignore it */\n\tgfs2_glock_put(rgd->rd_gl);\n\nfail:\n\tkfree(rgd->rd_bits);\n\trgd->rd_bits = NULL;\n\tkmem_cache_free(gfs2_rgrpd_cachep, rgd);\n\treturn error;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146601,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "void gfs2_clear_rgrpd(struct gfs2_sbd *sdp)\n{\n\tstruct rb_node *n;\n\tstruct gfs2_rgrpd *rgd;\n\tstruct gfs2_glock *gl;\n\n\twhile ((n = rb_first(&sdp->sd_rindex_tree))) {\n\t\trgd = rb_entry(n, struct gfs2_rgrpd, rd_node);\n\t\tgl = rgd->rd_gl;\n\n\t\trb_erase(n, &sdp->sd_rindex_tree);\n\n\t\tif (gl) {\n\t\t\tspin_lock(&gl->gl_lockref.lock);\n\t\t\tgl->gl_object = NULL;\n\t\t\tspin_unlock(&gl->gl_lockref.lock);\n\t\t\tgfs2_glock_add_to_lru(gl);\n\t\t\tgfs2_glock_put(gl);\n\t\t}\n\n\t\tgfs2_free_clones(rgd);\n\t\tkfree(rgd->rd_bits);\n\t\treturn_all_reservations(rgd);\n\t\tkmem_cache_free(gfs2_rgrpd_cachep, rgd);\n\t}\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146602,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "void gfs2_clear_rgrpd(struct gfs2_sbd *sdp)\n{\n\tstruct rb_node *n;\n\tstruct gfs2_rgrpd *rgd;\n\tstruct gfs2_glock *gl;\n\n\twhile ((n = rb_first(&sdp->sd_rindex_tree))) {\n\t\trgd = rb_entry(n, struct gfs2_rgrpd, rd_node);\n\t\tgl = rgd->rd_gl;\n\n\t\trb_erase(n, &sdp->sd_rindex_tree);\n\n\t\tif (gl) {\n\t\t\tspin_lock(&gl->gl_lockref.lock);\n\t\t\tgl->gl_object = NULL;\n\t\t\tspin_unlock(&gl->gl_lockref.lock);\n\t\t\tgfs2_glock_add_to_lru(gl);\n\t\t\tgfs2_glock_put(gl);\n\t\t}\n\n\t\tgfs2_free_clones(rgd);\n\t\tkfree(rgd->rd_bits);\n\t\trgd->rd_bits = NULL;\n\t\treturn_all_reservations(rgd);\n\t\tkmem_cache_free(gfs2_rgrpd_cachep, rgd);\n\t}\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146603,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "__ext4_xattr_check_block(struct inode *inode, struct buffer_head *bh,\n\t\t\t const char *function, unsigned int line)\n{\n\tint error = -EFSCORRUPTED;\n\n\tif (buffer_verified(bh))\n\t\treturn 0;\n\n\tif (BHDR(bh)->h_magic != cpu_to_le32(EXT4_XATTR_MAGIC) ||\n\t    BHDR(bh)->h_blocks != cpu_to_le32(1))\n\t\tgoto errout;\n\terror = -EFSBADCRC;\n\tif (!ext4_xattr_block_csum_verify(inode, bh))\n\t\tgoto errout;\n\terror = ext4_xattr_check_entries(BFIRST(bh), bh->b_data + bh->b_size,\n\t\t\t\t\t bh->b_data);\nerrout:\n\tif (error)\n\t\t__ext4_error_inode(inode, function, line, 0,\n\t\t\t\t   \"corrupted xattr block %llu\",\n\t\t\t\t   (unsigned long long) bh->b_blocknr);\n\telse\n\t\tset_buffer_verified(bh);\n\treturn error;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146606,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "__ext4_xattr_check_block(struct inode *inode, struct buffer_head *bh,\n\t\t\t const char *function, unsigned int line)\n{\n\tint error = -EFSCORRUPTED;\n\n\tif (BHDR(bh)->h_magic != cpu_to_le32(EXT4_XATTR_MAGIC) ||\n\t    BHDR(bh)->h_blocks != cpu_to_le32(1))\n\t\tgoto errout;\n\tif (buffer_verified(bh))\n\t\treturn 0;\n\n\terror = -EFSBADCRC;\n\tif (!ext4_xattr_block_csum_verify(inode, bh))\n\t\tgoto errout;\n\terror = ext4_xattr_check_entries(BFIRST(bh), bh->b_data + bh->b_size,\n\t\t\t\t\t bh->b_data);\nerrout:\n\tif (error)\n\t\t__ext4_error_inode(inode, function, line, 0,\n\t\t\t\t   \"corrupted xattr block %llu\",\n\t\t\t\t   (unsigned long long) bh->b_blocknr);\n\telse\n\t\tset_buffer_verified(bh);\n\treturn error;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146607,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static void close_all_connections(struct Curl_multi *multi)\n{\n  struct connectdata *conn;\n\n  conn = Curl_conncache_find_first_connection(&multi->conn_cache);\n  while(conn) {\n    SIGPIPE_VARIABLE(pipe_st);\n    conn->data = multi->closure_handle;\n\n    sigpipe_ignore(conn->data, &pipe_st);\n    /* This will remove the connection from the cache */\n    (void)Curl_disconnect(conn, FALSE);\n    sigpipe_restore(&pipe_st);\n\n    conn = Curl_conncache_find_first_connection(&multi->conn_cache);\n  }\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146686,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static void close_all_connections(struct Curl_multi *multi)\n{\n  struct connectdata *conn;\n\n  conn = Curl_conncache_find_first_connection(&multi->conn_cache);\n  while(conn) {\n    SIGPIPE_VARIABLE(pipe_st);\n    conn->data = multi->closure_handle;\n\n    sigpipe_ignore(conn->data, &pipe_st);\n    conn->data->easy_conn = NULL; /* clear the easy handle's connection\n                                     pointer */\n    /* This will remove the connection from the cache */\n    (void)Curl_disconnect(conn, FALSE);\n    sigpipe_restore(&pipe_st);\n\n    conn = Curl_conncache_find_first_connection(&multi->conn_cache);\n  }\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146687,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "void __exit atalk_proc_exit(void)\n{\n\tremove_proc_subtree(\"atalk\", init_net.proc_net);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146708,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "void atalk_proc_exit(void)\n{\n\tremove_proc_subtree(\"atalk\", init_net.proc_net);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146709,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "win_enter_ext(\n    win_T\t*wp,\n    int\t\tundo_sync,\n    int\t\tcurwin_invalid,\n    int\t\ttrigger_new_autocmds,\n    int\t\ttrigger_enter_autocmds,\n    int\t\ttrigger_leave_autocmds)\n{\n    int\t\tother_buffer = FALSE;\n\n    if (wp == curwin && !curwin_invalid)\t/* nothing to do */\n\treturn;\n\n#ifdef FEAT_JOB_CHANNEL\n    if (!curwin_invalid)\n\tleaving_window(curwin);\n#endif\n\n    if (!curwin_invalid && trigger_leave_autocmds)\n    {\n\t/*\n\t * Be careful: If autocommands delete the window, return now.\n\t */\n\tif (wp->w_buffer != curbuf)\n\t{\n\t    apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);\n\t    other_buffer = TRUE;\n\t    if (!win_valid(wp))\n\t\treturn;\n\t}\n\tapply_autocmds(EVENT_WINLEAVE, NULL, NULL, FALSE, curbuf);\n\tif (!win_valid(wp))\n\t    return;\n#ifdef FEAT_EVAL\n\t/* autocmds may abort script processing */\n\tif (aborting())\n\t    return;\n#endif\n    }\n\n    /* sync undo before leaving the current buffer */\n    if (undo_sync && curbuf != wp->w_buffer)\n\tu_sync(FALSE);\n\n    /* Might need to scroll the old window before switching, e.g., when the\n     * cursor was moved. */\n    update_topline();\n\n    /* may have to copy the buffer options when 'cpo' contains 'S' */\n    if (wp->w_buffer != curbuf)\n\tbuf_copy_options(wp->w_buffer, BCO_ENTER | BCO_NOHELP);\n    if (!curwin_invalid)\n    {\n\tprevwin = curwin;\t/* remember for CTRL-W p */\n\tcurwin->w_redr_status = TRUE;\n    }\n    curwin = wp;\n    curbuf = wp->w_buffer;\n    check_cursor();\n    if (!virtual_active())\n\tcurwin->w_cursor.coladd = 0;\n    changed_line_abv_curs();\t/* assume cursor position needs updating */\n\n    if (curwin->w_localdir != NULL || curtab->tp_localdir != NULL)\n    {\n\tchar_u\t*dirname;\n\n\t// Window or tab has a local directory: Save current directory as\n\t// global directory (unless that was done already) and change to the\n\t// local directory.\n\tif (globaldir == NULL)\n\t{\n\t    char_u\tcwd[MAXPATHL];\n\n\t    if (mch_dirname(cwd, MAXPATHL) == OK)\n\t\tglobaldir = vim_strsave(cwd);\n\t}\n\tif (curwin->w_localdir != NULL)\n\t    dirname = curwin->w_localdir;\n\telse\n\t    dirname = curtab->tp_localdir;\n\n\tif (mch_chdir((char *)dirname) == 0)\n\t    shorten_fnames(TRUE);\n    }\n    else if (globaldir != NULL)\n    {\n\t/* Window doesn't have a local directory and we are not in the global\n\t * directory: Change to the global directory. */\n\tvim_ignored = mch_chdir((char *)globaldir);\n\tVIM_CLEAR(globaldir);\n\tshorten_fnames(TRUE);\n    }\n\n#ifdef FEAT_JOB_CHANNEL\n    entering_window(curwin);\n#endif\n    if (trigger_new_autocmds)\n\tapply_autocmds(EVENT_WINNEW, NULL, NULL, FALSE, curbuf);\n    if (trigger_enter_autocmds)\n    {\n\tapply_autocmds(EVENT_WINENTER, NULL, NULL, FALSE, curbuf);\n\tif (other_buffer)\n\t    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n    }\n\n#ifdef FEAT_TITLE\n    maketitle();\n#endif\n    curwin->w_redr_status = TRUE;\n#ifdef FEAT_TERMINAL\n    if (bt_terminal(wp->w_buffer))\n\t// terminal is likely in another mode\n\tredraw_mode = TRUE;\n#endif\n    redraw_tabline = TRUE;\n    if (restart_edit)\n\tredraw_later(VALID);\t/* causes status line redraw */\n\n    /* set window height to desired minimal value */\n    if (curwin->w_height < p_wh && !curwin->w_p_wfh\n#ifdef FEAT_TEXT_PROP\n\t    && !popup_is_popup(curwin)\n#endif\n\t    )\n\twin_setheight((int)p_wh);\n    else if (curwin->w_height == 0)\n\twin_setheight(1);\n\n    /* set window width to desired minimal value */\n    if (curwin->w_width < p_wiw && !curwin->w_p_wfw)\n\twin_setwidth((int)p_wiw);\n\n    setmouse();\t\t\t// in case jumped to/from help buffer\n\n    /* Change directories when the 'acd' option is set. */\n    DO_AUTOCHDIR;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146710,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "win_enter_ext(\n    win_T\t*wp,\n    int\t\tundo_sync,\n    int\t\tcurwin_invalid,\n    int\t\ttrigger_new_autocmds,\n    int\t\ttrigger_enter_autocmds,\n    int\t\ttrigger_leave_autocmds)\n{\n    int\t\tother_buffer = FALSE;\n\n    if (wp == curwin && !curwin_invalid)\t/* nothing to do */\n\treturn;\n\n#ifdef FEAT_JOB_CHANNEL\n    if (!curwin_invalid)\n\tleaving_window(curwin);\n#endif\n\n    if (!curwin_invalid && trigger_leave_autocmds)\n    {\n\t/*\n\t * Be careful: If autocommands delete the window, return now.\n\t */\n\tif (wp->w_buffer != curbuf)\n\t{\n\t    apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);\n\t    other_buffer = TRUE;\n\t    if (!win_valid(wp))\n\t\treturn;\n\t}\n\tapply_autocmds(EVENT_WINLEAVE, NULL, NULL, FALSE, curbuf);\n\tif (!win_valid(wp))\n\t    return;\n#ifdef FEAT_EVAL\n\t/* autocmds may abort script processing */\n\tif (aborting())\n\t    return;\n#endif\n    }\n\n    /* sync undo before leaving the current buffer */\n    if (undo_sync && curbuf != wp->w_buffer)\n\tu_sync(FALSE);\n\n    /* Might need to scroll the old window before switching, e.g., when the\n     * cursor was moved. */\n    update_topline();\n\n    /* may have to copy the buffer options when 'cpo' contains 'S' */\n    if (wp->w_buffer != curbuf)\n\tbuf_copy_options(wp->w_buffer, BCO_ENTER | BCO_NOHELP);\n    if (!curwin_invalid)\n    {\n\tprevwin = curwin;\t/* remember for CTRL-W p */\n\tcurwin->w_redr_status = TRUE;\n    }\n    curwin = wp;\n    curbuf = wp->w_buffer;\n    check_cursor();\n    if (!virtual_active())\n\tcurwin->w_cursor.coladd = 0;\n    changed_line_abv_curs();\t/* assume cursor position needs updating */\n\n    if (curwin->w_localdir != NULL || curtab->tp_localdir != NULL)\n    {\n\tchar_u\t*dirname;\n\n\t// Window or tab has a local directory: Save current directory as\n\t// global directory (unless that was done already) and change to the\n\t// local directory.\n\tif (globaldir == NULL)\n\t{\n\t    char_u\tcwd[MAXPATHL];\n\n\t    if (mch_dirname(cwd, MAXPATHL) == OK)\n\t\tglobaldir = vim_strsave(cwd);\n\t}\n\tif (curwin->w_localdir != NULL)\n\t    dirname = curwin->w_localdir;\n\telse\n\t    dirname = curtab->tp_localdir;\n\n\tif (mch_chdir((char *)dirname) == 0)\n\t    shorten_fnames(TRUE);\n    }\n    else if (globaldir != NULL)\n    {\n\t/* Window doesn't have a local directory and we are not in the global\n\t * directory: Change to the global directory. */\n\tvim_ignored = mch_chdir((char *)globaldir);\n\tVIM_CLEAR(globaldir);\n\tshorten_fnames(TRUE);\n    }\n\n#ifdef FEAT_JOB_CHANNEL\n    entering_window(curwin);\n#endif\n    // Careful: autocommands may close the window and make \"wp\" invalid\n    if (trigger_new_autocmds)\n\tapply_autocmds(EVENT_WINNEW, NULL, NULL, FALSE, curbuf);\n    if (trigger_enter_autocmds)\n    {\n\tapply_autocmds(EVENT_WINENTER, NULL, NULL, FALSE, curbuf);\n\tif (other_buffer)\n\t    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n    }\n\n#ifdef FEAT_TITLE\n    maketitle();\n#endif\n    curwin->w_redr_status = TRUE;\n#ifdef FEAT_TERMINAL\n    if (bt_terminal(curwin->w_buffer))\n\t// terminal is likely in another mode\n\tredraw_mode = TRUE;\n#endif\n    redraw_tabline = TRUE;\n    if (restart_edit)\n\tredraw_later(VALID);\t/* causes status line redraw */\n\n    /* set window height to desired minimal value */\n    if (curwin->w_height < p_wh && !curwin->w_p_wfh\n#ifdef FEAT_TEXT_PROP\n\t    && !popup_is_popup(curwin)\n#endif\n\t    )\n\twin_setheight((int)p_wh);\n    else if (curwin->w_height == 0)\n\twin_setheight(1);\n\n    /* set window width to desired minimal value */\n    if (curwin->w_width < p_wiw && !curwin->w_p_wfw)\n\twin_setwidth((int)p_wiw);\n\n    setmouse();\t\t\t// in case jumped to/from help buffer\n\n    /* Change directories when the 'acd' option is set. */\n    DO_AUTOCHDIR;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146711,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int snd_pcm_control_ioctl(struct snd_card *card,\n\t\t\t\t struct snd_ctl_file *control,\n\t\t\t\t unsigned int cmd, unsigned long arg)\n{\n\tswitch (cmd) {\n\tcase SNDRV_CTL_IOCTL_PCM_NEXT_DEVICE:\n\t\t{\n\t\t\tint device;\n\n\t\t\tif (get_user(device, (int __user *)arg))\n\t\t\t\treturn -EFAULT;\n\t\t\tmutex_lock(&register_mutex);\n\t\t\tdevice = snd_pcm_next(card, device);\n\t\t\tmutex_unlock(&register_mutex);\n\t\t\tif (put_user(device, (int __user *)arg))\n\t\t\t\treturn -EFAULT;\n\t\t\treturn 0;\n\t\t}\n\tcase SNDRV_CTL_IOCTL_PCM_INFO:\n\t\t{\n\t\t\tstruct snd_pcm_info __user *info;\n\t\t\tunsigned int device, subdevice;\n\t\t\tint stream;\n\t\t\tstruct snd_pcm *pcm;\n\t\t\tstruct snd_pcm_str *pstr;\n\t\t\tstruct snd_pcm_substream *substream;\n\t\t\tint err;\n\n\t\t\tinfo = (struct snd_pcm_info __user *)arg;\n\t\t\tif (get_user(device, &info->device))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (get_user(stream, &info->stream))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (stream < 0 || stream > 1)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (get_user(subdevice, &info->subdevice))\n\t\t\t\treturn -EFAULT;\n\t\t\tmutex_lock(&register_mutex);\n\t\t\tpcm = snd_pcm_get(card, device);\n\t\t\tif (pcm == NULL) {\n\t\t\t\terr = -ENXIO;\n\t\t\t\tgoto _error;\n\t\t\t}\n\t\t\tpstr = &pcm->streams[stream];\n\t\t\tif (pstr->substream_count == 0) {\n\t\t\t\terr = -ENOENT;\n\t\t\t\tgoto _error;\n\t\t\t}\n\t\t\tif (subdevice >= pstr->substream_count) {\n\t\t\t\terr = -ENXIO;\n\t\t\t\tgoto _error;\n\t\t\t}\n\t\t\tfor (substream = pstr->substream; substream;\n\t\t\t     substream = substream->next)\n\t\t\t\tif (substream->number == (int)subdevice)\n\t\t\t\t\tbreak;\n\t\t\tif (substream == NULL) {\n\t\t\t\terr = -ENXIO;\n\t\t\t\tgoto _error;\n\t\t\t}\n\t\t\terr = snd_pcm_info_user(substream, info);\n\t\t_error:\n\t\t\tmutex_unlock(&register_mutex);\n\t\t\treturn err;\n\t\t}\n\tcase SNDRV_CTL_IOCTL_PCM_PREFER_SUBDEVICE:\n\t\t{\n\t\t\tint val;\n\t\t\t\n\t\t\tif (get_user(val, (int __user *)arg))\n\t\t\t\treturn -EFAULT;\n\t\t\tcontrol->preferred_subdevice[SND_CTL_SUBDEV_PCM] = val;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENOIOCTLCMD;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146778,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int snd_pcm_control_ioctl(struct snd_card *card,\n\t\t\t\t struct snd_ctl_file *control,\n\t\t\t\t unsigned int cmd, unsigned long arg)\n{\n\tswitch (cmd) {\n\tcase SNDRV_CTL_IOCTL_PCM_NEXT_DEVICE:\n\t\t{\n\t\t\tint device;\n\n\t\t\tif (get_user(device, (int __user *)arg))\n\t\t\t\treturn -EFAULT;\n\t\t\tmutex_lock(&register_mutex);\n\t\t\tdevice = snd_pcm_next(card, device);\n\t\t\tmutex_unlock(&register_mutex);\n\t\t\tif (put_user(device, (int __user *)arg))\n\t\t\t\treturn -EFAULT;\n\t\t\treturn 0;\n\t\t}\n\tcase SNDRV_CTL_IOCTL_PCM_INFO:\n\t\t{\n\t\t\tstruct snd_pcm_info __user *info;\n\t\t\tunsigned int device, subdevice;\n\t\t\tint stream;\n\t\t\tstruct snd_pcm *pcm;\n\t\t\tstruct snd_pcm_str *pstr;\n\t\t\tstruct snd_pcm_substream *substream;\n\t\t\tint err;\n\n\t\t\tinfo = (struct snd_pcm_info __user *)arg;\n\t\t\tif (get_user(device, &info->device))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (get_user(stream, &info->stream))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (stream < 0 || stream > 1)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (get_user(subdevice, &info->subdevice))\n\t\t\t\treturn -EFAULT;\n\t\t\tmutex_lock(&register_mutex);\n\t\t\tpcm = snd_pcm_get(card, device);\n\t\t\tif (pcm == NULL) {\n\t\t\t\terr = -ENXIO;\n\t\t\t\tgoto _error;\n\t\t\t}\n\t\t\tpstr = &pcm->streams[stream];\n\t\t\tif (pstr->substream_count == 0) {\n\t\t\t\terr = -ENOENT;\n\t\t\t\tgoto _error;\n\t\t\t}\n\t\t\tif (subdevice >= pstr->substream_count) {\n\t\t\t\terr = -ENXIO;\n\t\t\t\tgoto _error;\n\t\t\t}\n\t\t\tfor (substream = pstr->substream; substream;\n\t\t\t     substream = substream->next)\n\t\t\t\tif (substream->number == (int)subdevice)\n\t\t\t\t\tbreak;\n\t\t\tif (substream == NULL) {\n\t\t\t\terr = -ENXIO;\n\t\t\t\tgoto _error;\n\t\t\t}\n\t\t\tmutex_lock(&pcm->open_mutex);\n\t\t\terr = snd_pcm_info_user(substream, info);\n\t\t\tmutex_unlock(&pcm->open_mutex);\n\t\t_error:\n\t\t\tmutex_unlock(&register_mutex);\n\t\t\treturn err;\n\t\t}\n\tcase SNDRV_CTL_IOCTL_PCM_PREFER_SUBDEVICE:\n\t\t{\n\t\t\tint val;\n\t\t\t\n\t\t\tif (get_user(val, (int __user *)arg))\n\t\t\t\treturn -EFAULT;\n\t\t\tcontrol->preferred_subdevice[SND_CTL_SUBDEV_PCM] = val;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENOIOCTLCMD;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146779,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "exec_instructions(ectx_T *ectx)\n{\n    int\t\tret = FAIL;\n    int\t\tsave_trylevel_at_start = ectx->ec_trylevel_at_start;\n    int\t\tdict_stack_len_at_start = dict_stack.ga_len;\n\n    // Start execution at the first instruction.\n    ectx->ec_iidx = 0;\n\n    // Only catch exceptions in this instruction list.\n    ectx->ec_trylevel_at_start = trylevel;\n\n    for (;;)\n    {\n\tstatic int  breakcheck_count = 0;  // using \"static\" makes it faster\n\tisn_T\t    *iptr;\n\ttypval_T    *tv;\n\n\tif (unlikely(++breakcheck_count >= 100))\n\t{\n\t    line_breakcheck();\n\t    breakcheck_count = 0;\n\t}\n\tif (unlikely(got_int))\n\t{\n\t    // Turn CTRL-C into an exception.\n\t    got_int = FALSE;\n\t    if (throw_exception(\"Vim:Interrupt\", ET_INTERRUPT, NULL) == FAIL)\n\t\tgoto theend;\n\t    did_throw = TRUE;\n\t}\n\n\tif (unlikely(did_emsg && msg_list != NULL && *msg_list != NULL))\n\t{\n\t    // Turn an error message into an exception.\n\t    did_emsg = FALSE;\n\t    if (throw_exception(*msg_list, ET_ERROR, NULL) == FAIL)\n\t\tgoto theend;\n\t    did_throw = TRUE;\n\t    *msg_list = NULL;\n\t}\n\n\tif (unlikely(did_throw))\n\t{\n\t    garray_T\t*trystack = &ectx->ec_trystack;\n\t    trycmd_T    *trycmd = NULL;\n\t    int\t\tindex = trystack->ga_len;\n\n\t    // An exception jumps to the first catch, finally, or returns from\n\t    // the current function.\n\t    while (index > 0)\n\t    {\n\t\ttrycmd = ((trycmd_T *)trystack->ga_data) + index - 1;\n\t\tif (!trycmd->tcd_in_catch || trycmd->tcd_finally_idx != 0)\n\t\t    break;\n\t\t// In the catch and finally block of this try we have to go up\n\t\t// one level.\n\t\t--index;\n\t\ttrycmd = NULL;\n\t    }\n\t    if (trycmd != NULL && trycmd->tcd_frame_idx == ectx->ec_frame_idx)\n\t    {\n\t\tif (trycmd->tcd_in_catch)\n\t\t{\n\t\t    // exception inside \":catch\", jump to \":finally\" once\n\t\t    ectx->ec_iidx = trycmd->tcd_finally_idx;\n\t\t    trycmd->tcd_finally_idx = 0;\n\t\t}\n\t\telse\n\t\t    // jump to first \":catch\"\n\t\t    ectx->ec_iidx = trycmd->tcd_catch_idx;\n\t\ttrycmd->tcd_in_catch = TRUE;\n\t\tdid_throw = FALSE;  // don't come back here until :endtry\n\t\ttrycmd->tcd_did_throw = TRUE;\n\t    }\n\t    else\n\t    {\n\t\t// Not inside try or need to return from current functions.\n\t\t// Push a dummy return value.\n\t\tif (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t    goto theend;\n\t\ttv = STACK_TV_BOT(0);\n\t\ttv->v_type = VAR_NUMBER;\n\t\ttv->vval.v_number = 0;\n\t\t++ectx->ec_stack.ga_len;\n\t\tif (ectx->ec_frame_idx == ectx->ec_initial_frame_idx)\n\t\t{\n\t\t    // At the toplevel we are done.\n\t\t    need_rethrow = TRUE;\n\t\t    if (handle_closure_in_use(ectx, FALSE) == FAIL)\n\t\t\tgoto theend;\n\t\t    goto done;\n\t\t}\n\n\t\tif (func_return(ectx) == FAIL)\n\t\t    goto theend;\n\t    }\n\t    continue;\n\t}\n\n\tiptr = &ectx->ec_instr[ectx->ec_iidx++];\n\tswitch (iptr->isn_type)\n\t{\n\t    // execute Ex command line\n\t    case ISN_EXEC:\n\t\tif (exec_command(iptr) == FAIL)\n\t\t    goto on_error;\n\t\tbreak;\n\n\t    // execute Ex command line split at NL characters.\n\t    case ISN_EXEC_SPLIT:\n\t\t{\n\t\t    source_cookie_T cookie;\n\t\t    char_u\t    *line;\n\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    CLEAR_FIELD(cookie);\n\t\t    cookie.sourcing_lnum = iptr->isn_lnum - 1;\n\t\t    cookie.nextline = iptr->isn_arg.string;\n\t\t    line = get_split_sourceline(0, &cookie, 0, 0);\n\t\t    if (do_cmdline(line,\n\t\t\t\tget_split_sourceline, &cookie,\n\t\t\t\t   DOCMD_VERBOSE|DOCMD_NOWAIT|DOCMD_KEYTYPED)\n\t\t\t\t\t\t\t\t\t== FAIL\n\t\t\t\t|| did_emsg)\n\t\t    {\n\t\t\tvim_free(line);\n\t\t\tgoto on_error;\n\t\t    }\n\t\t    vim_free(line);\n\t\t}\n\t\tbreak;\n\n\t    // execute Ex command line that is only a range\n\t    case ISN_EXECRANGE:\n\t\t{\n\t\t    exarg_T\tea;\n\t\t    char\t*error = NULL;\n\n\t\t    CLEAR_FIELD(ea);\n\t\t    ea.cmdidx = CMD_SIZE;\n\t\t    ea.addr_type = ADDR_LINES;\n\t\t    ea.cmd = iptr->isn_arg.string;\n\t\t    parse_cmd_address(&ea, &error, FALSE);\n\t\t    if (ea.cmd == NULL)\n\t\t\tgoto on_error;\n\t\t    if (error == NULL)\n\t\t\terror = ex_range_without_command(&ea);\n\t\t    if (error != NULL)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\temsg(error);\n\t\t\tgoto on_error;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    // Evaluate an expression with legacy syntax, push it onto the\n\t    // stack.\n\t    case ISN_LEGACY_EVAL:\n\t\t{\n\t\t    char_u  *arg = iptr->isn_arg.string;\n\t\t    int\t    res;\n\t\t    int\t    save_flags = cmdmod.cmod_flags;\n\n\t\t    if (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\tgoto theend;\n\t\t    tv = STACK_TV_BOT(0);\n\t\t    init_tv(tv);\n\t\t    cmdmod.cmod_flags |= CMOD_LEGACY;\n\t\t    res = eval0(arg, tv, NULL, &EVALARG_EVALUATE);\n\t\t    cmdmod.cmod_flags = save_flags;\n\t\t    if (res == FAIL)\n\t\t\tgoto on_error;\n\t\t    ++ectx->ec_stack.ga_len;\n\t\t}\n\t\tbreak;\n\n\t    // push typeval VAR_INSTR with instructions to be executed\n\t    case ISN_INSTR:\n\t\t{\n\t\t    if (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\tgoto theend;\n\t\t    tv = STACK_TV_BOT(0);\n\t\t    tv->vval.v_instr = ALLOC_ONE(instr_T);\n\t\t    if (tv->vval.v_instr == NULL)\n\t\t\tgoto on_error;\n\t\t    ++ectx->ec_stack.ga_len;\n\n\t\t    tv->v_type = VAR_INSTR;\n\t\t    tv->vval.v_instr->instr_ectx = ectx;\n\t\t    tv->vval.v_instr->instr_instr = iptr->isn_arg.instr;\n\t\t}\n\t\tbreak;\n\n\t    // execute :substitute with an expression\n\t    case ISN_SUBSTITUTE:\n\t\t{\n\t\t    subs_T\t\t*subs = &iptr->isn_arg.subs;\n\t\t    source_cookie_T\tcookie;\n\t\t    struct subs_expr_S\t*save_instr = substitute_instr;\n\t\t    struct subs_expr_S\tsubs_instr;\n\t\t    int\t\t\tres;\n\n\t\t    subs_instr.subs_ectx = ectx;\n\t\t    subs_instr.subs_instr = subs->subs_instr;\n\t\t    subs_instr.subs_status = OK;\n\t\t    substitute_instr = &subs_instr;\n\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    // This is very much like ISN_EXEC\n\t\t    CLEAR_FIELD(cookie);\n\t\t    cookie.sourcing_lnum = iptr->isn_lnum - 1;\n\t\t    res = do_cmdline(subs->subs_cmd,\n\t\t\t\tgetsourceline, &cookie,\n\t\t\t\t   DOCMD_VERBOSE|DOCMD_NOWAIT|DOCMD_KEYTYPED);\n\t\t    substitute_instr = save_instr;\n\n\t\t    if (res == FAIL || did_emsg\n\t\t\t\t\t     || subs_instr.subs_status == FAIL)\n\t\t\tgoto on_error;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_FINISH:\n\t\tgoto done;\n\n\t    case ISN_REDIRSTART:\n\t\t// create a dummy entry for var_redir_str()\n\t\tif (alloc_redir_lval() == FAIL)\n\t\t    goto on_error;\n\n\t\t// The output is stored in growarray \"redir_ga\" until\n\t\t// redirection ends.\n\t\tinit_redir_ga();\n\t\tredir_vname = 1;\n\t\tbreak;\n\n\t    case ISN_REDIREND:\n\t\t{\n\t\t    char_u *res = get_clear_redir_ga();\n\n\t\t    // End redirection, put redirected text on the stack.\n\t\t    clear_redir_lval();\n\t\t    redir_vname = 0;\n\n\t\t    if (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t    {\n\t\t\tvim_free(res);\n\t\t\tgoto theend;\n\t\t    }\n\t\t    tv = STACK_TV_BOT(0);\n\t\t    tv->v_type = VAR_STRING;\n\t\t    tv->vval.v_string = res;\n\t\t    ++ectx->ec_stack.ga_len;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_CEXPR_AUCMD:\n#ifdef FEAT_QUICKFIX\n\t\tif (trigger_cexpr_autocmd(iptr->isn_arg.number) == FAIL)\n\t\t    goto on_error;\n#endif\n\t\tbreak;\n\n\t    case ISN_CEXPR_CORE:\n#ifdef FEAT_QUICKFIX\n\t\t{\n\t\t    exarg_T ea;\n\t\t    int\t    res;\n\n\t\t    CLEAR_FIELD(ea);\n\t\t    ea.cmdidx = iptr->isn_arg.cexpr.cexpr_ref->cer_cmdidx;\n\t\t    ea.forceit = iptr->isn_arg.cexpr.cexpr_ref->cer_forceit;\n\t\t    ea.cmdlinep = &iptr->isn_arg.cexpr.cexpr_ref->cer_cmdline;\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    tv = STACK_TV_BOT(0);\n\t\t    res = cexpr_core(&ea, tv);\n\t\t    clear_tv(tv);\n\t\t    if (res == FAIL)\n\t\t\tgoto on_error;\n\t\t}\n#endif\n\t\tbreak;\n\n\t    // execute Ex command from pieces on the stack\n\t    case ISN_EXECCONCAT:\n\t\t{\n\t\t    int\t    count = iptr->isn_arg.number;\n\t\t    size_t  len = 0;\n\t\t    int\t    pass;\n\t\t    int\t    i;\n\t\t    char_u  *cmd = NULL;\n\t\t    char_u  *str;\n\n\t\t    for (pass = 1; pass <= 2; ++pass)\n\t\t    {\n\t\t\tfor (i = 0; i < count; ++i)\n\t\t\t{\n\t\t\t    tv = STACK_TV_BOT(i - count);\n\t\t\t    str = tv->vval.v_string;\n\t\t\t    if (str != NULL && *str != NUL)\n\t\t\t    {\n\t\t\t\tif (pass == 2)\n\t\t\t\t    STRCPY(cmd + len, str);\n\t\t\t\tlen += STRLEN(str);\n\t\t\t    }\n\t\t\t    if (pass == 2)\n\t\t\t\tclear_tv(tv);\n\t\t\t}\n\t\t\tif (pass == 1)\n\t\t\t{\n\t\t\t    cmd = alloc(len + 1);\n\t\t\t    if (unlikely(cmd == NULL))\n\t\t\t\tgoto theend;\n\t\t\t    len = 0;\n\t\t\t}\n\t\t    }\n\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    do_cmdline_cmd(cmd);\n\t\t    vim_free(cmd);\n\t\t}\n\t\tbreak;\n\n\t    // execute :echo {string} ...\n\t    case ISN_ECHO:\n\t\t{\n\t\t    int count = iptr->isn_arg.echo.echo_count;\n\t\t    int\tatstart = TRUE;\n\t\t    int needclr = TRUE;\n\t\t    int\tidx;\n\n\t\t    for (idx = 0; idx < count; ++idx)\n\t\t    {\n\t\t\ttv = STACK_TV_BOT(idx - count);\n\t\t\techo_one(tv, iptr->isn_arg.echo.echo_with_white,\n\t\t\t\t\t\t\t   &atstart, &needclr);\n\t\t\tclear_tv(tv);\n\t\t    }\n\t\t    if (needclr)\n\t\t\tmsg_clr_eos();\n\t\t    ectx->ec_stack.ga_len -= count;\n\t\t}\n\t\tbreak;\n\n\t    // :execute {string} ...\n\t    // :echomsg {string} ...\n\t    // :echoconsole {string} ...\n\t    // :echoerr {string} ...\n\t    case ISN_EXECUTE:\n\t    case ISN_ECHOMSG:\n\t    case ISN_ECHOCONSOLE:\n\t    case ISN_ECHOERR:\n\t\t{\n\t\t    int\t\tcount = iptr->isn_arg.number;\n\t\t    garray_T\tga;\n\t\t    char_u\tbuf[NUMBUFLEN];\n\t\t    char_u\t*p;\n\t\t    int\t\tlen;\n\t\t    int\t\tfailed = FALSE;\n\t\t    int\t\tidx;\n\n\t\t    ga_init2(&ga, 1, 80);\n\t\t    for (idx = 0; idx < count; ++idx)\n\t\t    {\n\t\t\ttv = STACK_TV_BOT(idx - count);\n\t\t\tif (iptr->isn_type == ISN_EXECUTE)\n\t\t\t{\n\t\t\t    if (tv->v_type == VAR_CHANNEL\n\t\t\t\t\t\t      || tv->v_type == VAR_JOB)\n\t\t\t    {\n\t\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\t\tsemsg(_(e_using_invalid_value_as_string_str),\n\t\t\t\t\t\t    vartype_name(tv->v_type));\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t    else\n\t\t\t\tp = tv_get_string_buf(tv, buf);\n\t\t\t}\n\t\t\telse\n\t\t\t    p = tv_stringify(tv, buf);\n\n\t\t\tlen = (int)STRLEN(p);\n\t\t\tif (GA_GROW_FAILS(&ga, len + 2))\n\t\t\t    failed = TRUE;\n\t\t\telse\n\t\t\t{\n\t\t\t    if (ga.ga_len > 0)\n\t\t\t\t((char_u *)(ga.ga_data))[ga.ga_len++] = ' ';\n\t\t\t    STRCPY((char_u *)(ga.ga_data) + ga.ga_len, p);\n\t\t\t    ga.ga_len += len;\n\t\t\t}\n\t\t\tclear_tv(tv);\n\t\t    }\n\t\t    ectx->ec_stack.ga_len -= count;\n\t\t    if (failed)\n\t\t    {\n\t\t\tga_clear(&ga);\n\t\t\tgoto on_error;\n\t\t    }\n\n\t\t    if (ga.ga_data != NULL)\n\t\t    {\n\t\t\tif (iptr->isn_type == ISN_EXECUTE)\n\t\t\t{\n\t\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t\t    do_cmdline_cmd((char_u *)ga.ga_data);\n\t\t\t    if (did_emsg)\n\t\t\t    {\n\t\t\t\tga_clear(&ga);\n\t\t\t\tgoto on_error;\n\t\t\t    }\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    msg_sb_eol();\n\t\t\t    if (iptr->isn_type == ISN_ECHOMSG)\n\t\t\t    {\n\t\t\t\tmsg_attr(ga.ga_data, echo_attr);\n\t\t\t\tout_flush();\n\t\t\t    }\n\t\t\t    else if (iptr->isn_type == ISN_ECHOCONSOLE)\n\t\t\t    {\n\t\t\t\tui_write(ga.ga_data, (int)STRLEN(ga.ga_data),\n\t\t\t\t\t\t\t\t\t TRUE);\n\t\t\t\tui_write((char_u *)\"\\r\\n\", 2, TRUE);\n\t\t\t    }\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\t\temsg(ga.ga_data);\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    ga_clear(&ga);\n\t\t}\n\t\tbreak;\n\n\t    // load local variable or argument\n\t    case ISN_LOAD:\n\t\tif (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t    goto theend;\n\t\tcopy_tv(STACK_TV_VAR(iptr->isn_arg.number), STACK_TV_BOT(0));\n\t\t++ectx->ec_stack.ga_len;\n\t\tbreak;\n\n\t    // load v: variable\n\t    case ISN_LOADV:\n\t\tif (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t    goto theend;\n\t\tcopy_tv(get_vim_var_tv(iptr->isn_arg.number), STACK_TV_BOT(0));\n\t\t++ectx->ec_stack.ga_len;\n\t\tbreak;\n\n\t    // load s: variable in Vim9 script\n\t    case ISN_LOADSCRIPT:\n\t\t{\n\t\t    scriptref_T\t*sref = iptr->isn_arg.script.scriptref;\n\t\t    svar_T\t *sv;\n\n\t\t    sv = get_script_svar(sref, ectx->ec_dfunc_idx);\n\t\t    if (sv == NULL)\n\t\t\tgoto theend;\n\t\t    allocate_if_null(sv->sv_tv);\n\t\t    if (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\tgoto theend;\n\t\t    copy_tv(sv->sv_tv, STACK_TV_BOT(0));\n\t\t    ++ectx->ec_stack.ga_len;\n\t\t}\n\t\tbreak;\n\n\t    // load s: variable in old script\n\t    case ISN_LOADS:\n\t\t{\n\t\t    hashtab_T\t*ht = &SCRIPT_VARS(\n\t\t\t\t\t       iptr->isn_arg.loadstore.ls_sid);\n\t\t    char_u\t*name = iptr->isn_arg.loadstore.ls_name;\n\t\t    dictitem_T\t*di = find_var_in_ht(ht, 0, name, TRUE);\n\n\t\t    if (di == NULL)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tsemsg(_(e_undefined_variable_str), name);\n\t\t\tgoto on_error;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\t    goto theend;\n\t\t\tcopy_tv(&di->di_tv, STACK_TV_BOT(0));\n\t\t\t++ectx->ec_stack.ga_len;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    // load g:/b:/w:/t: variable\n\t    case ISN_LOADG:\n\t    case ISN_LOADB:\n\t    case ISN_LOADW:\n\t    case ISN_LOADT:\n\t\t{\n\t\t    dictitem_T *di = NULL;\n\t\t    hashtab_T *ht = NULL;\n\t\t    char namespace;\n\n\t\t    switch (iptr->isn_type)\n\t\t    {\n\t\t\tcase ISN_LOADG:\n\t\t\t    ht = get_globvar_ht();\n\t\t\t    namespace = 'g';\n\t\t\t    break;\n\t\t\tcase ISN_LOADB:\n\t\t\t    ht = &curbuf->b_vars->dv_hashtab;\n\t\t\t    namespace = 'b';\n\t\t\t    break;\n\t\t\tcase ISN_LOADW:\n\t\t\t    ht = &curwin->w_vars->dv_hashtab;\n\t\t\t    namespace = 'w';\n\t\t\t    break;\n\t\t\tcase ISN_LOADT:\n\t\t\t    ht = &curtab->tp_vars->dv_hashtab;\n\t\t\t    namespace = 't';\n\t\t\t    break;\n\t\t\tdefault:  // Cannot reach here\n\t\t\t    goto theend;\n\t\t    }\n\t\t    di = find_var_in_ht(ht, 0, iptr->isn_arg.string, TRUE);\n\n\t\t    if (di == NULL)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tsemsg(_(e_undefined_variable_char_str),\n\t\t\t\t\t     namespace, iptr->isn_arg.string);\n\t\t\tgoto on_error;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\t    goto theend;\n\t\t\tcopy_tv(&di->di_tv, STACK_TV_BOT(0));\n\t\t\t++ectx->ec_stack.ga_len;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    // load autoload variable\n\t    case ISN_LOADAUTO:\n\t\t{\n\t\t    char_u *name = iptr->isn_arg.string;\n\n\t\t    if (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\tgoto theend;\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    if (eval_variable(name, (int)STRLEN(name), 0,\n\t\t\t      STACK_TV_BOT(0), NULL, EVAL_VAR_VERBOSE) == FAIL)\n\t\t\tgoto on_error;\n\t\t    ++ectx->ec_stack.ga_len;\n\t\t}\n\t\tbreak;\n\n\t    // load g:/b:/w:/t: namespace\n\t    case ISN_LOADGDICT:\n\t    case ISN_LOADBDICT:\n\t    case ISN_LOADWDICT:\n\t    case ISN_LOADTDICT:\n\t\t{\n\t\t    dict_T *d = NULL;\n\n\t\t    switch (iptr->isn_type)\n\t\t    {\n\t\t\tcase ISN_LOADGDICT: d = get_globvar_dict(); break;\n\t\t\tcase ISN_LOADBDICT: d = curbuf->b_vars; break;\n\t\t\tcase ISN_LOADWDICT: d = curwin->w_vars; break;\n\t\t\tcase ISN_LOADTDICT: d = curtab->tp_vars; break;\n\t\t\tdefault:  // Cannot reach here\n\t\t\t    goto theend;\n\t\t    }\n\t\t    if (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\tgoto theend;\n\t\t    tv = STACK_TV_BOT(0);\n\t\t    tv->v_type = VAR_DICT;\n\t\t    tv->v_lock = 0;\n\t\t    tv->vval.v_dict = d;\n\t\t    ++d->dv_refcount;\n\t\t    ++ectx->ec_stack.ga_len;\n\t\t}\n\t\tbreak;\n\n\t    // load &option\n\t    case ISN_LOADOPT:\n\t\t{\n\t\t    typval_T\toptval;\n\t\t    char_u\t*name = iptr->isn_arg.string;\n\n\t\t    // This is not expected to fail, name is checked during\n\t\t    // compilation: don't set SOURCING_LNUM.\n\t\t    if (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\tgoto theend;\n\t\t    if (eval_option(&name, &optval, TRUE) == FAIL)\n\t\t\tgoto theend;\n\t\t    *STACK_TV_BOT(0) = optval;\n\t\t    ++ectx->ec_stack.ga_len;\n\t\t}\n\t\tbreak;\n\n\t    // load $ENV\n\t    case ISN_LOADENV:\n\t\t{\n\t\t    typval_T\toptval;\n\t\t    char_u\t*name = iptr->isn_arg.string;\n\n\t\t    if (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\tgoto theend;\n\t\t    // name is always valid, checked when compiling\n\t\t    (void)eval_env_var(&name, &optval, TRUE);\n\t\t    *STACK_TV_BOT(0) = optval;\n\t\t    ++ectx->ec_stack.ga_len;\n\t\t}\n\t\tbreak;\n\n\t    // load @register\n\t    case ISN_LOADREG:\n\t\tif (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t    goto theend;\n\t\ttv = STACK_TV_BOT(0);\n\t\ttv->v_type = VAR_STRING;\n\t\ttv->v_lock = 0;\n\t\t// This may result in NULL, which should be equivalent to an\n\t\t// empty string.\n\t\ttv->vval.v_string = get_reg_contents(\n\t\t\t\t\t  iptr->isn_arg.number, GREG_EXPR_SRC);\n\t\t++ectx->ec_stack.ga_len;\n\t\tbreak;\n\n\t    // store local variable\n\t    case ISN_STORE:\n\t\t--ectx->ec_stack.ga_len;\n\t\ttv = STACK_TV_VAR(iptr->isn_arg.number);\n\t\tclear_tv(tv);\n\t\t*tv = *STACK_TV_BOT(0);\n\t\tbreak;\n\n\t    // store s: variable in old script\n\t    case ISN_STORES:\n\t\t{\n\t\t    hashtab_T\t*ht = &SCRIPT_VARS(\n\t\t\t\t\t       iptr->isn_arg.loadstore.ls_sid);\n\t\t    char_u\t*name = iptr->isn_arg.loadstore.ls_name;\n\t\t    dictitem_T\t*di = find_var_in_ht(ht, 0, name + 2, TRUE);\n\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    if (di == NULL)\n\t\t\tstore_var(name, STACK_TV_BOT(0));\n\t\t    else\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tif (var_check_permission(di, name) == FAIL)\n\t\t\t{\n\t\t\t    clear_tv(STACK_TV_BOT(0));\n\t\t\t    goto on_error;\n\t\t\t}\n\t\t\tclear_tv(&di->di_tv);\n\t\t\tdi->di_tv = *STACK_TV_BOT(0);\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    // store script-local variable in Vim9 script\n\t    case ISN_STORESCRIPT:\n\t\t{\n\t\t    scriptref_T\t    *sref = iptr->isn_arg.script.scriptref;\n\t\t    svar_T\t    *sv;\n\n\t\t    sv = get_script_svar(sref, ectx->ec_dfunc_idx);\n\t\t    if (sv == NULL)\n\t\t\tgoto theend;\n\t\t    --ectx->ec_stack.ga_len;\n\n\t\t    // \"const\" and \"final\" are checked at compile time, locking\n\t\t    // the value needs to be checked here.\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    if (value_check_lock(sv->sv_tv->v_lock, sv->sv_name, FALSE))\n\t\t    {\n\t\t\tclear_tv(STACK_TV_BOT(0));\n\t\t\tgoto on_error;\n\t\t    }\n\n\t\t    clear_tv(sv->sv_tv);\n\t\t    *sv->sv_tv = *STACK_TV_BOT(0);\n\t\t}\n\t\tbreak;\n\n\t    // store option\n\t    case ISN_STOREOPT:\n\t    case ISN_STOREFUNCOPT:\n\t\t{\n\t\t    char_u\t*opt_name = iptr->isn_arg.storeopt.so_name;\n\t\t    int\t\topt_flags = iptr->isn_arg.storeopt.so_flags;\n\t\t    long\tn = 0;\n\t\t    char_u\t*s = NULL;\n\t\t    char\t*msg;\n\t\t    char_u\tnumbuf[NUMBUFLEN];\n\t\t    char_u\t*tofree = NULL;\n\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    tv = STACK_TV_BOT(0);\n\t\t    if (tv->v_type == VAR_STRING)\n\t\t    {\n\t\t\ts = tv->vval.v_string;\n\t\t\tif (s == NULL)\n\t\t\t    s = (char_u *)\"\";\n\t\t    }\n\t\t    else if (iptr->isn_type == ISN_STOREFUNCOPT)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\t// If the option can be set to a function reference or\n\t\t\t// a lambda and the passed value is a function\n\t\t\t// reference, then convert it to the name (string) of\n\t\t\t// the function reference.\n\t\t\ts = tv2string(tv, &tofree, numbuf, 0);\n\t\t\tif (s == NULL || *s == NUL)\n\t\t\t{\n\t\t\t    clear_tv(tv);\n\t\t\t    goto on_error;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t\t// must be VAR_NUMBER, CHECKTYPE makes sure\n\t\t\tn = tv->vval.v_number;\n\t\t    msg = set_option_value(opt_name, n, s, opt_flags);\n\t\t    clear_tv(tv);\n\t\t    vim_free(tofree);\n\t\t    if (msg != NULL)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\temsg(_(msg));\n\t\t\tgoto on_error;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    // store $ENV\n\t    case ISN_STOREENV:\n\t\t--ectx->ec_stack.ga_len;\n\t\ttv = STACK_TV_BOT(0);\n\t\tvim_setenv_ext(iptr->isn_arg.string, tv_get_string(tv));\n\t\tclear_tv(tv);\n\t\tbreak;\n\n\t    // store @r\n\t    case ISN_STOREREG:\n\t\t{\n\t\t    int\treg = iptr->isn_arg.number;\n\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    tv = STACK_TV_BOT(0);\n\t\t    write_reg_contents(reg, tv_get_string(tv), -1, FALSE);\n\t\t    clear_tv(tv);\n\t\t}\n\t\tbreak;\n\n\t    // store v: variable\n\t    case ISN_STOREV:\n\t\t--ectx->ec_stack.ga_len;\n\t\tif (set_vim_var_tv(iptr->isn_arg.number, STACK_TV_BOT(0))\n\t\t\t\t\t\t\t\t       == FAIL)\n\t\t    // should not happen, type is checked when compiling\n\t\t    goto on_error;\n\t\tbreak;\n\n\t    // store g:/b:/w:/t: variable\n\t    case ISN_STOREG:\n\t    case ISN_STOREB:\n\t    case ISN_STOREW:\n\t    case ISN_STORET:\n\t\t{\n\t\t    dictitem_T\t*di;\n\t\t    hashtab_T\t*ht;\n\t\t    char_u\t*name = iptr->isn_arg.string + 2;\n\n\t\t    switch (iptr->isn_type)\n\t\t    {\n\t\t\tcase ISN_STOREG:\n\t\t\t    ht = get_globvar_ht();\n\t\t\t    break;\n\t\t\tcase ISN_STOREB:\n\t\t\t    ht = &curbuf->b_vars->dv_hashtab;\n\t\t\t    break;\n\t\t\tcase ISN_STOREW:\n\t\t\t    ht = &curwin->w_vars->dv_hashtab;\n\t\t\t    break;\n\t\t\tcase ISN_STORET:\n\t\t\t    ht = &curtab->tp_vars->dv_hashtab;\n\t\t\t    break;\n\t\t\tdefault:  // Cannot reach here\n\t\t\t    goto theend;\n\t\t    }\n\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    di = find_var_in_ht(ht, 0, name, TRUE);\n\t\t    if (di == NULL)\n\t\t\tstore_var(iptr->isn_arg.string, STACK_TV_BOT(0));\n\t\t    else\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tif (var_check_permission(di, name) == FAIL)\n\t\t\t    goto on_error;\n\t\t\tclear_tv(&di->di_tv);\n\t\t\tdi->di_tv = *STACK_TV_BOT(0);\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    // store an autoload variable\n\t    case ISN_STOREAUTO:\n\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\tset_var(iptr->isn_arg.string, STACK_TV_BOT(-1), TRUE);\n\t\tclear_tv(STACK_TV_BOT(-1));\n\t\t--ectx->ec_stack.ga_len;\n\t\tbreak;\n\n\t    // store number in local variable\n\t    case ISN_STORENR:\n\t\ttv = STACK_TV_VAR(iptr->isn_arg.storenr.stnr_idx);\n\t\tclear_tv(tv);\n\t\ttv->v_type = VAR_NUMBER;\n\t\ttv->vval.v_number = iptr->isn_arg.storenr.stnr_val;\n\t\tbreak;\n\n\t    // store value in list or dict variable\n\t    case ISN_STOREINDEX:\n\t\t{\n\t\t    vartype_T\tdest_type = iptr->isn_arg.vartype;\n\t\t    typval_T\t*tv_idx = STACK_TV_BOT(-2);\n\t\t    typval_T\t*tv_dest = STACK_TV_BOT(-1);\n\t\t    int\t\tstatus = OK;\n\n\t\t    // Stack contains:\n\t\t    // -3 value to be stored\n\t\t    // -2 index\n\t\t    // -1 dict or list\n\t\t    tv = STACK_TV_BOT(-3);\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    if (dest_type == VAR_ANY)\n\t\t    {\n\t\t\tdest_type = tv_dest->v_type;\n\t\t\tif (dest_type == VAR_DICT)\n\t\t\t    status = do_2string(tv_idx, TRUE, FALSE);\n\t\t\telse if (dest_type == VAR_LIST\n\t\t\t\t\t       && tv_idx->v_type != VAR_NUMBER)\n\t\t\t{\n\t\t\t    emsg(_(e_number_expected));\n\t\t\t    status = FAIL;\n\t\t\t}\n\t\t    }\n\t\t    else if (dest_type != tv_dest->v_type)\n\t\t    {\n\t\t\t// just in case, should be OK\n\t\t\tsemsg(_(e_expected_str_but_got_str),\n\t\t\t\t    vartype_name(dest_type),\n\t\t\t\t    vartype_name(tv_dest->v_type));\n\t\t\tstatus = FAIL;\n\t\t    }\n\n\t\t    if (status == OK && dest_type == VAR_LIST)\n\t\t    {\n\t\t\tlong\t    lidx = (long)tv_idx->vval.v_number;\n\t\t\tlist_T\t    *list = tv_dest->vval.v_list;\n\n\t\t\tif (list == NULL)\n\t\t\t{\n\t\t\t    emsg(_(e_list_not_set));\n\t\t\t    goto on_error;\n\t\t\t}\n\t\t\tif (lidx < 0 && list->lv_len + lidx >= 0)\n\t\t\t    // negative index is relative to the end\n\t\t\t    lidx = list->lv_len + lidx;\n\t\t\tif (lidx < 0 || lidx > list->lv_len)\n\t\t\t{\n\t\t\t    semsg(_(e_list_index_out_of_range_nr), lidx);\n\t\t\t    goto on_error;\n\t\t\t}\n\t\t\tif (lidx < list->lv_len)\n\t\t\t{\n\t\t\t    listitem_T *li = list_find(list, lidx);\n\n\t\t\t    if (error_if_locked(li->li_tv.v_lock,\n\t\t\t\t\t\t    e_cannot_change_list_item))\n\t\t\t\tgoto on_error;\n\t\t\t    // overwrite existing list item\n\t\t\t    clear_tv(&li->li_tv);\n\t\t\t    li->li_tv = *tv;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    if (error_if_locked(list->lv_lock,\n\t\t\t\t\t\t\t e_cannot_change_list))\n\t\t\t\tgoto on_error;\n\t\t\t    // append to list, only fails when out of memory\n\t\t\t    if (list_append_tv(list, tv) == FAIL)\n\t\t\t\tgoto theend;\n\t\t\t    clear_tv(tv);\n\t\t\t}\n\t\t    }\n\t\t    else if (status == OK && dest_type == VAR_DICT)\n\t\t    {\n\t\t\tchar_u\t\t*key = tv_idx->vval.v_string;\n\t\t\tdict_T\t\t*dict = tv_dest->vval.v_dict;\n\t\t\tdictitem_T\t*di;\n\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tif (dict == NULL)\n\t\t\t{\n\t\t\t    emsg(_(e_dictionary_not_set));\n\t\t\t    goto on_error;\n\t\t\t}\n\t\t\tif (key == NULL)\n\t\t\t    key = (char_u *)\"\";\n\t\t\tdi = dict_find(dict, key, -1);\n\t\t\tif (di != NULL)\n\t\t\t{\n\t\t\t    if (error_if_locked(di->di_tv.v_lock,\n\t\t\t\t\t\t    e_cannot_change_dict_item))\n\t\t\t\tgoto on_error;\n\t\t\t    // overwrite existing value\n\t\t\t    clear_tv(&di->di_tv);\n\t\t\t    di->di_tv = *tv;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    if (error_if_locked(dict->dv_lock,\n\t\t\t\t\t\t\t e_cannot_change_dict))\n\t\t\t\tgoto on_error;\n\t\t\t    // add to dict, only fails when out of memory\n\t\t\t    if (dict_add_tv(dict, (char *)key, tv) == FAIL)\n\t\t\t\tgoto theend;\n\t\t\t    clear_tv(tv);\n\t\t\t}\n\t\t    }\n\t\t    else if (status == OK && dest_type == VAR_BLOB)\n\t\t    {\n\t\t\tlong\t    lidx = (long)tv_idx->vval.v_number;\n\t\t\tblob_T\t    *blob = tv_dest->vval.v_blob;\n\t\t\tvarnumber_T nr;\n\t\t\tint\t    error = FALSE;\n\t\t\tint\t    len;\n\n\t\t\tif (blob == NULL)\n\t\t\t{\n\t\t\t    emsg(_(e_blob_not_set));\n\t\t\t    goto on_error;\n\t\t\t}\n\t\t\tlen = blob_len(blob);\n\t\t\tif (lidx < 0 && len + lidx >= 0)\n\t\t\t    // negative index is relative to the end\n\t\t\t    lidx = len + lidx;\n\n\t\t\t// Can add one byte at the end.\n\t\t\tif (lidx < 0 || lidx > len)\n\t\t\t{\n\t\t\t    semsg(_(e_blob_index_out_of_range_nr), lidx);\n\t\t\t    goto on_error;\n\t\t\t}\n\t\t\tif (value_check_lock(blob->bv_lock,\n\t\t\t\t\t\t      (char_u *)\"blob\", FALSE))\n\t\t\t    goto on_error;\n\t\t\tnr = tv_get_number_chk(tv, &error);\n\t\t\tif (error)\n\t\t\t    goto on_error;\n\t\t\tblob_set_append(blob, lidx, nr);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tstatus = FAIL;\n\t\t\tsemsg(_(e_cannot_index_str), vartype_name(dest_type));\n\t\t    }\n\n\t\t    clear_tv(tv_idx);\n\t\t    clear_tv(tv_dest);\n\t\t    ectx->ec_stack.ga_len -= 3;\n\t\t    if (status == FAIL)\n\t\t    {\n\t\t\tclear_tv(tv);\n\t\t\tgoto on_error;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    // store value in blob range\n\t    case ISN_STORERANGE:\n\t\t{\n\t\t    typval_T\t*tv_idx1 = STACK_TV_BOT(-3);\n\t\t    typval_T\t*tv_idx2 = STACK_TV_BOT(-2);\n\t\t    typval_T\t*tv_dest = STACK_TV_BOT(-1);\n\t\t    int\t\tstatus = OK;\n\n\t\t    // Stack contains:\n\t\t    // -4 value to be stored\n\t\t    // -3 first index or \"none\"\n\t\t    // -2 second index or \"none\"\n\t\t    // -1 destination list or blob\n\t\t    tv = STACK_TV_BOT(-4);\n\t\t    if (tv_dest->v_type == VAR_LIST)\n\t\t    {\n\t\t\tlong\tn1;\n\t\t\tlong\tn2;\n\t\t\tint\terror = FALSE;\n\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tn1 = (long)tv_get_number_chk(tv_idx1, &error);\n\t\t\tif (error)\n\t\t\t    status = FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t    if (tv_idx2->v_type == VAR_SPECIAL\n\t\t\t\t\t&& tv_idx2->vval.v_number == VVAL_NONE)\n\t\t\t\tn2 = list_len(tv_dest->vval.v_list) - 1;\n\t\t\t    else\n\t\t\t\tn2 = (long)tv_get_number_chk(tv_idx2, &error);\n\t\t\t    if (error)\n\t\t\t\tstatus = FAIL;\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tlistitem_T *li1 = check_range_index_one(\n\t\t\t\t\ttv_dest->vval.v_list, &n1, FALSE);\n\n\t\t\t\tif (li1 == NULL)\n\t\t\t\t    status = FAIL;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t    status = check_range_index_two(\n\t\t\t\t\t    tv_dest->vval.v_list,\n\t\t\t\t\t    &n1, li1, &n2, FALSE);\n\t\t\t\t    if (status != FAIL)\n\t\t\t\t\tstatus = list_assign_range(\n\t\t\t\t\t\ttv_dest->vval.v_list,\n\t\t\t\t\t\ttv->vval.v_list,\n\t\t\t\t\t\tn1,\n\t\t\t\t\t\tn2,\n\t\t\t\t\t\ttv_idx2->v_type == VAR_SPECIAL,\n\t\t\t\t\t\t(char_u *)\"=\",\n\t\t\t\t\t\t(char_u *)\"[unknown]\");\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    else if (tv_dest->v_type == VAR_BLOB)\n\t\t    {\n\t\t\tvarnumber_T n1;\n\t\t\tvarnumber_T n2;\n\t\t\tint\t    error = FALSE;\n\n\t\t\tn1 = tv_get_number_chk(tv_idx1, &error);\n\t\t\tif (error)\n\t\t\t    status = FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t    if (tv_idx2->v_type == VAR_SPECIAL\n\t\t\t\t\t&& tv_idx2->vval.v_number == VVAL_NONE)\n\t\t\t\tn2 = blob_len(tv_dest->vval.v_blob) - 1;\n\t\t\t    else\n\t\t\t\tn2 = tv_get_number_chk(tv_idx2, &error);\n\t\t\t    if (error)\n\t\t\t\tstatus = FAIL;\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tlong  bloblen = blob_len(tv_dest->vval.v_blob);\n\n\t\t\t\tif (check_blob_index(bloblen,\n\t\t\t\t\t\t\t     n1, FALSE) == FAIL\n\t\t\t\t\t|| check_blob_range(bloblen,\n\t\t\t\t\t\t\tn1, n2, FALSE) == FAIL)\n\t\t\t\t    status = FAIL;\n\t\t\t\telse\n\t\t\t\t    status = blob_set_range(\n\t\t\t\t\t     tv_dest->vval.v_blob, n1, n2, tv);\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tstatus = FAIL;\n\t\t\temsg(_(e_blob_required));\n\t\t    }\n\n\t\t    clear_tv(tv_idx1);\n\t\t    clear_tv(tv_idx2);\n\t\t    clear_tv(tv_dest);\n\t\t    ectx->ec_stack.ga_len -= 4;\n\t\t    clear_tv(tv);\n\n\t\t    if (status == FAIL)\n\t\t\tgoto on_error;\n\t\t}\n\t\tbreak;\n\n\t    // load or store variable or argument from outer scope\n\t    case ISN_LOADOUTER:\n\t    case ISN_STOREOUTER:\n\t\t{\n\t\t    int\t\tdepth = iptr->isn_arg.outer.outer_depth;\n\t\t    outer_T\t*outer = ectx->ec_outer_ref == NULL ? NULL\n\t\t\t\t\t\t: ectx->ec_outer_ref->or_outer;\n\n\t\t    while (depth > 1 && outer != NULL)\n\t\t    {\n\t\t\touter = outer->out_up;\n\t\t\t--depth;\n\t\t    }\n\t\t    if (outer == NULL)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tif (ectx->ec_frame_idx == ectx->ec_initial_frame_idx\n\t\t\t\t\t\t || ectx->ec_outer_ref == NULL)\n\t\t\t    // Possibly :def function called from legacy\n\t\t\t    // context.\n\t\t\t    emsg(_(e_closure_called_from_invalid_context));\n\t\t\telse\n\t\t\t    iemsg(\"LOADOUTER depth more than scope levels\");\n\t\t\tgoto theend;\n\t\t    }\n\t\t    tv = ((typval_T *)outer->out_stack->ga_data)\n\t\t\t\t    + outer->out_frame_idx + STACK_FRAME_SIZE\n\t\t\t\t    + iptr->isn_arg.outer.outer_idx;\n\t\t    if (iptr->isn_type == ISN_LOADOUTER)\n\t\t    {\n\t\t\tif (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\t    goto theend;\n\t\t\tcopy_tv(tv, STACK_TV_BOT(0));\n\t\t\t++ectx->ec_stack.ga_len;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t--ectx->ec_stack.ga_len;\n\t\t\tclear_tv(tv);\n\t\t\t*tv = *STACK_TV_BOT(0);\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    // unlet item in list or dict variable\n\t    case ISN_UNLETINDEX:\n\t\t{\n\t\t    typval_T\t*tv_idx = STACK_TV_BOT(-2);\n\t\t    typval_T\t*tv_dest = STACK_TV_BOT(-1);\n\t\t    int\t\tstatus = OK;\n\n\t\t    // Stack contains:\n\t\t    // -2 index\n\t\t    // -1 dict or list\n\t\t    if (tv_dest->v_type == VAR_DICT)\n\t\t    {\n\t\t\t// unlet a dict item, index must be a string\n\t\t\tif (tv_idx->v_type != VAR_STRING)\n\t\t\t{\n\t\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t\t    semsg(_(e_expected_str_but_got_str),\n\t\t\t\t\tvartype_name(VAR_STRING),\n\t\t\t\t\tvartype_name(tv_idx->v_type));\n\t\t\t    status = FAIL;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    dict_T\t*d = tv_dest->vval.v_dict;\n\t\t\t    char_u\t*key = tv_idx->vval.v_string;\n\t\t\t    dictitem_T  *di = NULL;\n\n\t\t\t    if (d != NULL && value_check_lock(\n\t\t\t\t\t\t      d->dv_lock, NULL, FALSE))\n\t\t\t\tstatus = FAIL;\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\t\tif (key == NULL)\n\t\t\t\t    key = (char_u *)\"\";\n\t\t\t\tif (d != NULL)\n\t\t\t\t    di = dict_find(d, key, (int)STRLEN(key));\n\t\t\t\tif (di == NULL)\n\t\t\t\t{\n\t\t\t\t    // NULL dict is equivalent to empty dict\n\t\t\t\t    semsg(_(e_key_not_present_in_dictionary), key);\n\t\t\t\t    status = FAIL;\n\t\t\t\t}\n\t\t\t\telse if (var_check_fixed(di->di_flags,\n\t\t\t\t\t\t\t\t   NULL, FALSE)\n\t\t\t\t\t|| var_check_ro(di->di_flags,\n\t\t\t\t\t\t\t\t  NULL, FALSE))\n\t\t\t\t    status = FAIL;\n\t\t\t\telse\n\t\t\t\t    dictitem_remove(d, di);\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    else if (tv_dest->v_type == VAR_LIST)\n\t\t    {\n\t\t\t// unlet a List item, index must be a number\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tif (check_for_number(tv_idx) == FAIL)\n\t\t\t{\n\t\t\t    status = FAIL;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    list_T\t*l = tv_dest->vval.v_list;\n\t\t\t    long\tn = (long)tv_idx->vval.v_number;\n\n\t\t\t    if (l != NULL && value_check_lock(\n\t\t\t\t\t\t      l->lv_lock, NULL, FALSE))\n\t\t\t\tstatus = FAIL;\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tlistitem_T\t*li = list_find(l, n);\n\n\t\t\t\tif (li == NULL)\n\t\t\t\t{\n\t\t\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t\t\t    semsg(_(e_list_index_out_of_range_nr), n);\n\t\t\t\t    status = FAIL;\n\t\t\t\t}\n\t\t\t\telse if (value_check_lock(li->li_tv.v_lock,\n\t\t\t\t\t\t\t\t  NULL, FALSE))\n\t\t\t\t    status = FAIL;\n\t\t\t\telse\n\t\t\t\t    listitem_remove(l, li);\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tstatus = FAIL;\n\t\t\tsemsg(_(e_cannot_index_str),\n\t\t\t\t\t\tvartype_name(tv_dest->v_type));\n\t\t    }\n\n\t\t    clear_tv(tv_idx);\n\t\t    clear_tv(tv_dest);\n\t\t    ectx->ec_stack.ga_len -= 2;\n\t\t    if (status == FAIL)\n\t\t\tgoto on_error;\n\t\t}\n\t\tbreak;\n\n\t    // unlet range of items in list variable\n\t    case ISN_UNLETRANGE:\n\t\t{\n\t\t    // Stack contains:\n\t\t    // -3 index1\n\t\t    // -2 index2\n\t\t    // -1 dict or list\n\t\t    typval_T\t*tv_idx1 = STACK_TV_BOT(-3);\n\t\t    typval_T\t*tv_idx2 = STACK_TV_BOT(-2);\n\t\t    typval_T\t*tv_dest = STACK_TV_BOT(-1);\n\t\t    int\t\tstatus = OK;\n\n\t\t    if (tv_dest->v_type == VAR_LIST)\n\t\t    {\n\t\t\t// indexes must be a number\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tif (check_for_number(tv_idx1) == FAIL\n\t\t\t\t|| (tv_idx2->v_type != VAR_SPECIAL\n\t\t\t\t\t && check_for_number(tv_idx2) == FAIL))\n\t\t\t{\n\t\t\t    status = FAIL;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    list_T\t*l = tv_dest->vval.v_list;\n\t\t\t    long\tn1 = (long)tv_idx1->vval.v_number;\n\t\t\t    long\tn2 = tv_idx2->v_type == VAR_SPECIAL\n\t\t\t\t\t    ? 0 : (long)tv_idx2->vval.v_number;\n\t\t\t    listitem_T\t*li;\n\n\t\t\t    li = list_find_index(l, &n1);\n\t\t\t    if (li == NULL)\n\t\t\t\tstatus = FAIL;\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tif (n1 < 0)\n\t\t\t\t    n1 = list_idx_of_item(l, li);\n\t\t\t\tif (n2 < 0)\n\t\t\t\t{\n\t\t\t\t    listitem_T *li2 = list_find(l, n2);\n\n\t\t\t\t    if (li2 == NULL)\n\t\t\t\t\tstatus = FAIL;\n\t\t\t\t    else\n\t\t\t\t\tn2 = list_idx_of_item(l, li2);\n\t\t\t\t}\n\t\t\t\tif (status != FAIL\n\t\t\t\t\t&& tv_idx2->v_type != VAR_SPECIAL\n\t\t\t\t\t&& n2 < n1)\n\t\t\t\t{\n\t\t\t\t    semsg(_(e_list_index_out_of_range_nr), n2);\n\t\t\t\t    status = FAIL;\n\t\t\t\t}\n\t\t\t\tif (status != FAIL\n\t\t\t\t\t&& list_unlet_range(l, li, NULL, n1,\n\t\t\t\t\t    tv_idx2->v_type != VAR_SPECIAL, n2)\n\t\t\t\t\t\t\t\t       == FAIL)\n\t\t\t\t    status = FAIL;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tstatus = FAIL;\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tsemsg(_(e_cannot_index_str),\n\t\t\t\t\t\tvartype_name(tv_dest->v_type));\n\t\t    }\n\n\t\t    clear_tv(tv_idx1);\n\t\t    clear_tv(tv_idx2);\n\t\t    clear_tv(tv_dest);\n\t\t    ectx->ec_stack.ga_len -= 3;\n\t\t    if (status == FAIL)\n\t\t\tgoto on_error;\n\t\t}\n\t\tbreak;\n\n\t    // push constant\n\t    case ISN_PUSHNR:\n\t    case ISN_PUSHBOOL:\n\t    case ISN_PUSHSPEC:\n\t    case ISN_PUSHF:\n\t    case ISN_PUSHS:\n\t    case ISN_PUSHBLOB:\n\t    case ISN_PUSHFUNC:\n\t    case ISN_PUSHCHANNEL:\n\t    case ISN_PUSHJOB:\n\t\tif (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t    goto theend;\n\t\ttv = STACK_TV_BOT(0);\n\t\ttv->v_lock = 0;\n\t\t++ectx->ec_stack.ga_len;\n\t\tswitch (iptr->isn_type)\n\t\t{\n\t\t    case ISN_PUSHNR:\n\t\t\ttv->v_type = VAR_NUMBER;\n\t\t\ttv->vval.v_number = iptr->isn_arg.number;\n\t\t\tbreak;\n\t\t    case ISN_PUSHBOOL:\n\t\t\ttv->v_type = VAR_BOOL;\n\t\t\ttv->vval.v_number = iptr->isn_arg.number;\n\t\t\tbreak;\n\t\t    case ISN_PUSHSPEC:\n\t\t\ttv->v_type = VAR_SPECIAL;\n\t\t\ttv->vval.v_number = iptr->isn_arg.number;\n\t\t\tbreak;\n#ifdef FEAT_FLOAT\n\t\t    case ISN_PUSHF:\n\t\t\ttv->v_type = VAR_FLOAT;\n\t\t\ttv->vval.v_float = iptr->isn_arg.fnumber;\n\t\t\tbreak;\n#endif\n\t\t    case ISN_PUSHBLOB:\n\t\t\tblob_copy(iptr->isn_arg.blob, tv);\n\t\t\tbreak;\n\t\t    case ISN_PUSHFUNC:\n\t\t\ttv->v_type = VAR_FUNC;\n\t\t\tif (iptr->isn_arg.string == NULL)\n\t\t\t    tv->vval.v_string = NULL;\n\t\t\telse\n\t\t\t    tv->vval.v_string =\n\t\t\t\t\t     vim_strsave(iptr->isn_arg.string);\n\t\t\tbreak;\n\t\t    case ISN_PUSHCHANNEL:\n#ifdef FEAT_JOB_CHANNEL\n\t\t\ttv->v_type = VAR_CHANNEL;\n\t\t\ttv->vval.v_channel = iptr->isn_arg.channel;\n\t\t\tif (tv->vval.v_channel != NULL)\n\t\t\t    ++tv->vval.v_channel->ch_refcount;\n#endif\n\t\t\tbreak;\n\t\t    case ISN_PUSHJOB:\n#ifdef FEAT_JOB_CHANNEL\n\t\t\ttv->v_type = VAR_JOB;\n\t\t\ttv->vval.v_job = iptr->isn_arg.job;\n\t\t\tif (tv->vval.v_job != NULL)\n\t\t\t    ++tv->vval.v_job->jv_refcount;\n#endif\n\t\t\tbreak;\n\t\t    default:\n\t\t\ttv->v_type = VAR_STRING;\n\t\t\ttv->vval.v_string = vim_strsave(\n\t\t\t\tiptr->isn_arg.string == NULL\n\t\t\t\t\t? (char_u *)\"\" : iptr->isn_arg.string);\n\t\t}\n\t\tbreak;\n\n\t    case ISN_UNLET:\n\t\tif (do_unlet(iptr->isn_arg.unlet.ul_name,\n\t\t\t\t       iptr->isn_arg.unlet.ul_forceit) == FAIL)\n\t\t    goto on_error;\n\t\tbreak;\n\t    case ISN_UNLETENV:\n\t\tvim_unsetenv(iptr->isn_arg.unlet.ul_name);\n\t\tbreak;\n\n\t    case ISN_LOCKUNLOCK:\n\t\t{\n\t\t    typval_T\t*lval_root_save = lval_root;\n\t\t    int\t\tres;\n\n\t\t    // Stack has the local variable, argument the whole :lock\n\t\t    // or :unlock command, like ISN_EXEC.\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    lval_root = STACK_TV_BOT(0);\n\t\t    res = exec_command(iptr);\n\t\t    clear_tv(lval_root);\n\t\t    lval_root = lval_root_save;\n\t\t    if (res == FAIL)\n\t\t\tgoto on_error;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_LOCKCONST:\n\t\titem_lock(STACK_TV_BOT(-1), 100, TRUE, TRUE);\n\t\tbreak;\n\n\t    // create a list from items on the stack; uses a single allocation\n\t    // for the list header and the items\n\t    case ISN_NEWLIST:\n\t\tif (exe_newlist(iptr->isn_arg.number, ectx) == FAIL)\n\t\t    goto theend;\n\t\tbreak;\n\n\t    // create a dict from items on the stack\n\t    case ISN_NEWDICT:\n\t\t{\n\t\t    int\t\tcount = iptr->isn_arg.number;\n\t\t    dict_T\t*dict = dict_alloc();\n\t\t    dictitem_T\t*item;\n\t\t    char_u\t*key;\n\t\t    int\t\tidx;\n\n\t\t    if (unlikely(dict == NULL))\n\t\t\tgoto theend;\n\t\t    for (idx = 0; idx < count; ++idx)\n\t\t    {\n\t\t\t// have already checked key type is VAR_STRING\n\t\t\ttv = STACK_TV_BOT(2 * (idx - count));\n\t\t\t// check key is unique\n\t\t\tkey = tv->vval.v_string == NULL\n\t\t\t\t\t    ? (char_u *)\"\" : tv->vval.v_string;\n\t\t\titem = dict_find(dict, key, -1);\n\t\t\tif (item != NULL)\n\t\t\t{\n\t\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t\t    semsg(_(e_duplicate_key_in_dicitonary), key);\n\t\t\t    dict_unref(dict);\n\t\t\t    goto on_error;\n\t\t\t}\n\t\t\titem = dictitem_alloc(key);\n\t\t\tclear_tv(tv);\n\t\t\tif (unlikely(item == NULL))\n\t\t\t{\n\t\t\t    dict_unref(dict);\n\t\t\t    goto theend;\n\t\t\t}\n\t\t\titem->di_tv = *STACK_TV_BOT(2 * (idx - count) + 1);\n\t\t\titem->di_tv.v_lock = 0;\n\t\t\tif (dict_add(dict, item) == FAIL)\n\t\t\t{\n\t\t\t    // can this ever happen?\n\t\t\t    dict_unref(dict);\n\t\t\t    goto theend;\n\t\t\t}\n\t\t    }\n\n\t\t    if (count > 0)\n\t\t\tectx->ec_stack.ga_len -= 2 * count - 1;\n\t\t    else if (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\tgoto theend;\n\t\t    else\n\t\t\t++ectx->ec_stack.ga_len;\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    tv->v_type = VAR_DICT;\n\t\t    tv->v_lock = 0;\n\t\t    tv->vval.v_dict = dict;\n\t\t    ++dict->dv_refcount;\n\t\t}\n\t\tbreak;\n\n\t    // call a :def function\n\t    case ISN_DCALL:\n\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\tif (call_dfunc(iptr->isn_arg.dfunc.cdf_idx,\n\t\t\t\tNULL,\n\t\t\t\tiptr->isn_arg.dfunc.cdf_argcount,\n\t\t\t\tectx) == FAIL)\n\t\t    goto on_error;\n\t\tbreak;\n\n\t    // call a builtin function\n\t    case ISN_BCALL:\n\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\tif (call_bfunc(iptr->isn_arg.bfunc.cbf_idx,\n\t\t\t      iptr->isn_arg.bfunc.cbf_argcount,\n\t\t\t      ectx) == FAIL)\n\t\t    goto on_error;\n\t\tbreak;\n\n\t    // call a funcref or partial\n\t    case ISN_PCALL:\n\t\t{\n\t\t    cpfunc_T\t*pfunc = &iptr->isn_arg.pfunc;\n\t\t    int\t\tr;\n\t\t    typval_T\tpartial_tv;\n\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    if (pfunc->cpf_top)\n\t\t    {\n\t\t\t// funcref is above the arguments\n\t\t\ttv = STACK_TV_BOT(-pfunc->cpf_argcount - 1);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// Get the funcref from the stack.\n\t\t\t--ectx->ec_stack.ga_len;\n\t\t\tpartial_tv = *STACK_TV_BOT(0);\n\t\t\ttv = &partial_tv;\n\t\t    }\n\t\t    r = call_partial(tv, pfunc->cpf_argcount, ectx);\n\t\t    if (tv == &partial_tv)\n\t\t\tclear_tv(&partial_tv);\n\t\t    if (r == FAIL)\n\t\t\tgoto on_error;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_PCALL_END:\n\t\t// PCALL finished, arguments have been consumed and replaced by\n\t\t// the return value.  Now clear the funcref from the stack,\n\t\t// and move the return value in its place.\n\t\t--ectx->ec_stack.ga_len;\n\t\tclear_tv(STACK_TV_BOT(-1));\n\t\t*STACK_TV_BOT(-1) = *STACK_TV_BOT(0);\n\t\tbreak;\n\n\t    // call a user defined function or funcref/partial\n\t    case ISN_UCALL:\n\t\t{\n\t\t    cufunc_T\t*cufunc = &iptr->isn_arg.ufunc;\n\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    if (call_eval_func(cufunc->cuf_name, cufunc->cuf_argcount,\n\t\t\t\t\t\t\t   ectx, iptr) == FAIL)\n\t\t\tgoto on_error;\n\t\t}\n\t\tbreak;\n\n\t    // return from a :def function call without a value\n\t    case ISN_RETURN_VOID:\n\t\tif (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t    goto theend;\n\t\ttv = STACK_TV_BOT(0);\n\t\t++ectx->ec_stack.ga_len;\n\t\ttv->v_type = VAR_VOID;\n\t\ttv->vval.v_number = 0;\n\t\ttv->v_lock = 0;\n\t\t// FALLTHROUGH\n\n\t    // return from a :def function call with what is on the stack\n\t    case ISN_RETURN:\n\t\t{\n\t\t    garray_T\t*trystack = &ectx->ec_trystack;\n\t\t    trycmd_T    *trycmd = NULL;\n\n\t\t    if (trystack->ga_len > 0)\n\t\t\ttrycmd = ((trycmd_T *)trystack->ga_data)\n\t\t\t\t\t\t\t+ trystack->ga_len - 1;\n\t\t    if (trycmd != NULL\n\t\t\t\t && trycmd->tcd_frame_idx == ectx->ec_frame_idx)\n\t\t    {\n\t\t\t// jump to \":finally\" or \":endtry\"\n\t\t\tif (trycmd->tcd_finally_idx != 0)\n\t\t\t    ectx->ec_iidx = trycmd->tcd_finally_idx;\n\t\t\telse\n\t\t\t    ectx->ec_iidx = trycmd->tcd_endtry_idx;\n\t\t\ttrycmd->tcd_return = TRUE;\n\t\t    }\n\t\t    else\n\t\t\tgoto func_return;\n\t\t}\n\t\tbreak;\n\n\t    // push a partial, a reference to a compiled function\n\t    case ISN_FUNCREF:\n\t\t{\n\t\t    partial_T   *pt = ALLOC_CLEAR_ONE(partial_T);\n\t\t    ufunc_T\t*ufunc;\n\t\t    funcref_T\t*funcref = &iptr->isn_arg.funcref;\n\n\t\t    if (pt == NULL)\n\t\t\tgoto theend;\n\t\t    if (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t    {\n\t\t\tvim_free(pt);\n\t\t\tgoto theend;\n\t\t    }\n\t\t    if (funcref->fr_func_name == NULL)\n\t\t    {\n\t\t\tdfunc_T\t*pt_dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t       + funcref->fr_dfunc_idx;\n\n\t\t\tufunc = pt_dfunc->df_ufunc;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tufunc = find_func(funcref->fr_func_name, FALSE, NULL);\n\t\t    }\n\t\t    if (ufunc == NULL)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\temsg(_(e_function_reference_invalid));\n\t\t\tgoto theend;\n\t\t    }\n\t\t    if (fill_partial_and_closure(pt, ufunc, ectx) == FAIL)\n\t\t\tgoto theend;\n\t\t    tv = STACK_TV_BOT(0);\n\t\t    ++ectx->ec_stack.ga_len;\n\t\t    tv->vval.v_partial = pt;\n\t\t    tv->v_type = VAR_PARTIAL;\n\t\t    tv->v_lock = 0;\n\t\t}\n\t\tbreak;\n\n\t    // Create a global function from a lambda.\n\t    case ISN_NEWFUNC:\n\t\t{\n\t\t    newfunc_T\t*newfunc = &iptr->isn_arg.newfunc;\n\n\t\t    if (copy_func(newfunc->nf_lambda, newfunc->nf_global,\n\t\t\t\t\t\t\t\t ectx) == FAIL)\n\t\t\tgoto theend;\n\t\t}\n\t\tbreak;\n\n\t    // List functions\n\t    case ISN_DEF:\n\t\tif (iptr->isn_arg.string == NULL)\n\t\t    list_functions(NULL);\n\t\telse\n\t\t{\n\t\t    exarg_T ea;\n\t\t    char_u  *line_to_free = NULL;\n\n\t\t    CLEAR_FIELD(ea);\n\t\t    ea.cmd = ea.arg = iptr->isn_arg.string;\n\t\t    define_function(&ea, NULL, &line_to_free);\n\t\t    vim_free(line_to_free);\n\t\t}\n\t\tbreak;\n\n\t    // jump if a condition is met\n\t    case ISN_JUMP:\n\t\t{\n\t\t    jumpwhen_T\twhen = iptr->isn_arg.jump.jump_when;\n\t\t    int\t\terror = FALSE;\n\t\t    int\t\tjump = TRUE;\n\n\t\t    if (when != JUMP_ALWAYS)\n\t\t    {\n\t\t\ttv = STACK_TV_BOT(-1);\n\t\t\tif (when == JUMP_IF_COND_FALSE\n\t\t\t\t|| when == JUMP_IF_FALSE\n\t\t\t\t|| when == JUMP_IF_COND_TRUE)\n\t\t\t{\n\t\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t\t    jump = tv_get_bool_chk(tv, &error);\n\t\t\t    if (error)\n\t\t\t\tgoto on_error;\n\t\t\t}\n\t\t\telse\n\t\t\t    jump = tv2bool(tv);\n\t\t\tif (when == JUMP_IF_FALSE\n\t\t\t\t\t     || when == JUMP_AND_KEEP_IF_FALSE\n\t\t\t\t\t     || when == JUMP_IF_COND_FALSE)\n\t\t\t    jump = !jump;\n\t\t\tif (when == JUMP_IF_FALSE || !jump)\n\t\t\t{\n\t\t\t    // drop the value from the stack\n\t\t\t    clear_tv(tv);\n\t\t\t    --ectx->ec_stack.ga_len;\n\t\t\t}\n\t\t    }\n\t\t    if (jump)\n\t\t\tectx->ec_iidx = iptr->isn_arg.jump.jump_where;\n\t\t}\n\t\tbreak;\n\n\t    // Jump if an argument with a default value was already set and not\n\t    // v:none.\n\t    case ISN_JUMP_IF_ARG_SET:\n\t\ttv = STACK_TV_VAR(iptr->isn_arg.jumparg.jump_arg_off);\n\t\tif (tv->v_type != VAR_UNKNOWN\n\t\t\t&& !(tv->v_type == VAR_SPECIAL\n\t\t\t\t\t    && tv->vval.v_number == VVAL_NONE))\n\t\t    ectx->ec_iidx = iptr->isn_arg.jumparg.jump_where;\n\t\tbreak;\n\n\t    // top of a for loop\n\t    case ISN_FOR:\n\t\t{\n\t\t    typval_T\t*ltv = STACK_TV_BOT(-1);\n\t\t    typval_T\t*idxtv =\n\t\t\t\t   STACK_TV_VAR(iptr->isn_arg.forloop.for_idx);\n\n\t\t    if (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\tgoto theend;\n\t\t    if (ltv->v_type == VAR_LIST)\n\t\t    {\n\t\t\tlist_T *list = ltv->vval.v_list;\n\n\t\t\t// push the next item from the list\n\t\t\t++idxtv->vval.v_number;\n\t\t\tif (list == NULL\n\t\t\t\t       || idxtv->vval.v_number >= list->lv_len)\n\t\t\t{\n\t\t\t    // past the end of the list, jump to \"endfor\"\n\t\t\t    ectx->ec_iidx = iptr->isn_arg.forloop.for_end;\n\t\t\t    may_restore_cmdmod(&ectx->ec_funclocal);\n\t\t\t}\n\t\t\telse if (list->lv_first == &range_list_item)\n\t\t\t{\n\t\t\t    // non-materialized range() list\n\t\t\t    tv = STACK_TV_BOT(0);\n\t\t\t    tv->v_type = VAR_NUMBER;\n\t\t\t    tv->v_lock = 0;\n\t\t\t    tv->vval.v_number = list_find_nr(\n\t\t\t\t\t     list, idxtv->vval.v_number, NULL);\n\t\t\t    ++ectx->ec_stack.ga_len;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    listitem_T *li = list_find(list,\n\t\t\t\t\t\t\t idxtv->vval.v_number);\n\n\t\t\t    copy_tv(&li->li_tv, STACK_TV_BOT(0));\n\t\t\t    ++ectx->ec_stack.ga_len;\n\t\t\t}\n\t\t    }\n\t\t    else if (ltv->v_type == VAR_STRING)\n\t\t    {\n\t\t\tchar_u\t*str = ltv->vval.v_string;\n\n\t\t\t// The index is for the last byte of the previous\n\t\t\t// character.\n\t\t\t++idxtv->vval.v_number;\n\t\t\tif (str == NULL || str[idxtv->vval.v_number] == NUL)\n\t\t\t{\n\t\t\t    // past the end of the string, jump to \"endfor\"\n\t\t\t    ectx->ec_iidx = iptr->isn_arg.forloop.for_end;\n\t\t\t    may_restore_cmdmod(&ectx->ec_funclocal);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    int\tclen = mb_ptr2len(str + idxtv->vval.v_number);\n\n\t\t\t    // Push the next character from the string.\n\t\t\t    tv = STACK_TV_BOT(0);\n\t\t\t    tv->v_type = VAR_STRING;\n\t\t\t    tv->vval.v_string = vim_strnsave(\n\t\t\t\t\t     str + idxtv->vval.v_number, clen);\n\t\t\t    ++ectx->ec_stack.ga_len;\n\t\t\t    idxtv->vval.v_number += clen - 1;\n\t\t\t}\n\t\t    }\n\t\t    else if (ltv->v_type == VAR_BLOB)\n\t\t    {\n\t\t\tblob_T\t*blob = ltv->vval.v_blob;\n\n\t\t\t// When we get here the first time make a copy of the\n\t\t\t// blob, so that the iteration still works when it is\n\t\t\t// changed.\n\t\t\tif (idxtv->vval.v_number == -1 && blob != NULL)\n\t\t\t{\n\t\t\t    blob_copy(blob, ltv);\n\t\t\t    blob_unref(blob);\n\t\t\t    blob = ltv->vval.v_blob;\n\t\t\t}\n\n\t\t\t// The index is for the previous byte.\n\t\t\t++idxtv->vval.v_number;\n\t\t\tif (blob == NULL\n\t\t\t\t     || idxtv->vval.v_number >= blob_len(blob))\n\t\t\t{\n\t\t\t    // past the end of the blob, jump to \"endfor\"\n\t\t\t    ectx->ec_iidx = iptr->isn_arg.forloop.for_end;\n\t\t\t    may_restore_cmdmod(&ectx->ec_funclocal);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // Push the next byte from the blob.\n\t\t\t    tv = STACK_TV_BOT(0);\n\t\t\t    tv->v_type = VAR_NUMBER;\n\t\t\t    tv->vval.v_number = blob_get(blob,\n\t\t\t\t\t\t\t idxtv->vval.v_number);\n\t\t\t    ++ectx->ec_stack.ga_len;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tsemsg(_(e_for_loop_on_str_not_supported),\n\t\t\t\t\t\t    vartype_name(ltv->v_type));\n\t\t\tgoto theend;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    // start of \":try\" block\n\t    case ISN_TRY:\n\t\t{\n\t\t    trycmd_T    *trycmd = NULL;\n\n\t\t    if (GA_GROW_FAILS(&ectx->ec_trystack, 1))\n\t\t\tgoto theend;\n\t\t    trycmd = ((trycmd_T *)ectx->ec_trystack.ga_data)\n\t\t\t\t\t\t     + ectx->ec_trystack.ga_len;\n\t\t    ++ectx->ec_trystack.ga_len;\n\t\t    ++trylevel;\n\t\t    CLEAR_POINTER(trycmd);\n\t\t    trycmd->tcd_frame_idx = ectx->ec_frame_idx;\n\t\t    trycmd->tcd_stack_len = ectx->ec_stack.ga_len;\n\t\t    trycmd->tcd_catch_idx =\n\t\t\t\t       iptr->isn_arg.tryref.try_ref->try_catch;\n\t\t    trycmd->tcd_finally_idx =\n\t\t\t\t     iptr->isn_arg.tryref.try_ref->try_finally;\n\t\t    trycmd->tcd_endtry_idx =\n\t\t\t\t      iptr->isn_arg.tryref.try_ref->try_endtry;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_PUSHEXC:\n\t\tif (current_exception == NULL)\n\t\t{\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    iemsg(\"Evaluating catch while current_exception is NULL\");\n\t\t    goto theend;\n\t\t}\n\t\tif (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t    goto theend;\n\t\ttv = STACK_TV_BOT(0);\n\t\t++ectx->ec_stack.ga_len;\n\t\ttv->v_type = VAR_STRING;\n\t\ttv->v_lock = 0;\n\t\ttv->vval.v_string = vim_strsave(\n\t\t\t\t\t   (char_u *)current_exception->value);\n\t\tbreak;\n\n\t    case ISN_CATCH:\n\t\t{\n\t\t    garray_T\t*trystack = &ectx->ec_trystack;\n\n\t\t    may_restore_cmdmod(&ectx->ec_funclocal);\n\t\t    if (trystack->ga_len > 0)\n\t\t    {\n\t\t\ttrycmd_T    *trycmd = ((trycmd_T *)trystack->ga_data)\n\t\t\t\t\t\t\t+ trystack->ga_len - 1;\n\t\t\ttrycmd->tcd_caught = TRUE;\n\t\t\ttrycmd->tcd_did_throw = FALSE;\n\t\t    }\n\t\t    did_emsg = got_int = did_throw = FALSE;\n\t\t    force_abort = need_rethrow = FALSE;\n\t\t    catch_exception(current_exception);\n\t\t}\n\t\tbreak;\n\n\t    case ISN_TRYCONT:\n\t\t{\n\t\t    garray_T\t*trystack = &ectx->ec_trystack;\n\t\t    trycont_T\t*trycont = &iptr->isn_arg.trycont;\n\t\t    int\t\ti;\n\t\t    trycmd_T    *trycmd;\n\t\t    int\t\tiidx = trycont->tct_where;\n\n\t\t    if (trystack->ga_len < trycont->tct_levels)\n\t\t    {\n\t\t\tsiemsg(\"TRYCONT: expected %d levels, found %d\",\n\t\t\t\t\ttrycont->tct_levels, trystack->ga_len);\n\t\t\tgoto theend;\n\t\t    }\n\t\t    // Make :endtry jump to any outer try block and the last\n\t\t    // :endtry inside the loop to the loop start.\n\t\t    for (i = trycont->tct_levels; i > 0; --i)\n\t\t    {\n\t\t\ttrycmd = ((trycmd_T *)trystack->ga_data)\n\t\t\t\t\t\t\t+ trystack->ga_len - i;\n\t\t\t// Add one to tcd_cont to be able to jump to\n\t\t\t// instruction with index zero.\n\t\t\ttrycmd->tcd_cont = iidx + 1;\n\t\t\tiidx = trycmd->tcd_finally_idx == 0\n\t\t\t    ? trycmd->tcd_endtry_idx : trycmd->tcd_finally_idx;\n\t\t    }\n\t\t    // jump to :finally or :endtry of current try statement\n\t\t    ectx->ec_iidx = iidx;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_FINALLY:\n\t\t{\n\t\t    garray_T\t*trystack = &ectx->ec_trystack;\n\t\t    trycmd_T    *trycmd = ((trycmd_T *)trystack->ga_data)\n\t\t\t\t\t\t\t+ trystack->ga_len - 1;\n\n\t\t    // Reset the index to avoid a return statement jumps here\n\t\t    // again.\n\t\t    trycmd->tcd_finally_idx = 0;\n\t\t    break;\n\t\t}\n\n\t    // end of \":try\" block\n\t    case ISN_ENDTRY:\n\t\t{\n\t\t    garray_T\t*trystack = &ectx->ec_trystack;\n\n\t\t    if (trystack->ga_len > 0)\n\t\t    {\n\t\t\ttrycmd_T    *trycmd;\n\n\t\t\t--trystack->ga_len;\n\t\t\t--trylevel;\n\t\t\ttrycmd = ((trycmd_T *)trystack->ga_data)\n\t\t\t\t\t\t\t    + trystack->ga_len;\n\t\t\tif (trycmd->tcd_did_throw)\n\t\t\t    did_throw = TRUE;\n\t\t\tif (trycmd->tcd_caught && current_exception != NULL)\n\t\t\t{\n\t\t\t    // discard the exception\n\t\t\t    if (caught_stack == current_exception)\n\t\t\t\tcaught_stack = caught_stack->caught;\n\t\t\t    discard_current_exception();\n\t\t\t}\n\n\t\t\tif (trycmd->tcd_return)\n\t\t\t    goto func_return;\n\n\t\t\twhile (ectx->ec_stack.ga_len > trycmd->tcd_stack_len)\n\t\t\t{\n\t\t\t    --ectx->ec_stack.ga_len;\n\t\t\t    clear_tv(STACK_TV_BOT(0));\n\t\t\t}\n\t\t\tif (trycmd->tcd_cont != 0)\n\t\t\t    // handling :continue: jump to outer try block or\n\t\t\t    // start of the loop\n\t\t\t    ectx->ec_iidx = trycmd->tcd_cont - 1;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    case ISN_THROW:\n\t\t{\n\t\t    garray_T\t*trystack = &ectx->ec_trystack;\n\n\t\t    if (trystack->ga_len == 0 && trylevel == 0 && emsg_silent)\n\t\t    {\n\t\t\t// throwing an exception while using \"silent!\" causes\n\t\t\t// the function to abort but not display an error.\n\t\t\ttv = STACK_TV_BOT(-1);\n\t\t\tclear_tv(tv);\n\t\t\ttv->v_type = VAR_NUMBER;\n\t\t\ttv->vval.v_number = 0;\n\t\t\tgoto done;\n\t\t    }\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    tv = STACK_TV_BOT(0);\n\t\t    if (tv->vval.v_string == NULL\n\t\t\t\t       || *skipwhite(tv->vval.v_string) == NUL)\n\t\t    {\n\t\t\tvim_free(tv->vval.v_string);\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\temsg(_(e_throw_with_empty_string));\n\t\t\tgoto theend;\n\t\t    }\n\n\t\t    // Inside a \"catch\" we need to first discard the caught\n\t\t    // exception.\n\t\t    if (trystack->ga_len > 0)\n\t\t    {\n\t\t\ttrycmd_T    *trycmd = ((trycmd_T *)trystack->ga_data)\n\t\t\t\t\t\t\t+ trystack->ga_len - 1;\n\t\t\tif (trycmd->tcd_caught && current_exception != NULL)\n\t\t\t{\n\t\t\t    // discard the exception\n\t\t\t    if (caught_stack == current_exception)\n\t\t\t\tcaught_stack = caught_stack->caught;\n\t\t\t    discard_current_exception();\n\t\t\t    trycmd->tcd_caught = FALSE;\n\t\t\t}\n\t\t    }\n\n\t\t    if (throw_exception(tv->vval.v_string, ET_USER, NULL)\n\t\t\t\t\t\t\t\t       == FAIL)\n\t\t    {\n\t\t\tvim_free(tv->vval.v_string);\n\t\t\tgoto theend;\n\t\t    }\n\t\t    did_throw = TRUE;\n\t\t}\n\t\tbreak;\n\n\t    // compare with special values\n\t    case ISN_COMPAREBOOL:\n\t    case ISN_COMPARESPECIAL:\n\t\t{\n\t\t    typval_T\t*tv1 = STACK_TV_BOT(-2);\n\t\t    typval_T\t*tv2 = STACK_TV_BOT(-1);\n\t\t    varnumber_T arg1 = tv1->vval.v_number;\n\t\t    varnumber_T arg2 = tv2->vval.v_number;\n\t\t    int\t\tres;\n\n\t\t    switch (iptr->isn_arg.op.op_type)\n\t\t    {\n\t\t\tcase EXPR_EQUAL: res = arg1 == arg2; break;\n\t\t\tcase EXPR_NEQUAL: res = arg1 != arg2; break;\n\t\t\tdefault: res = 0; break;\n\t\t    }\n\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    tv1->v_type = VAR_BOOL;\n\t\t    tv1->vval.v_number = res ? VVAL_TRUE : VVAL_FALSE;\n\t\t}\n\t\tbreak;\n\n\t    // Operation with two number arguments\n\t    case ISN_OPNR:\n\t    case ISN_COMPARENR:\n\t\t{\n\t\t    typval_T\t*tv1 = STACK_TV_BOT(-2);\n\t\t    typval_T\t*tv2 = STACK_TV_BOT(-1);\n\t\t    varnumber_T arg1 = tv1->vval.v_number;\n\t\t    varnumber_T arg2 = tv2->vval.v_number;\n\t\t    varnumber_T res = 0;\n\t\t    int\t\tdiv_zero = FALSE;\n\n\t\t    switch (iptr->isn_arg.op.op_type)\n\t\t    {\n\t\t\tcase EXPR_MULT: res = arg1 * arg2; break;\n\t\t\tcase EXPR_DIV:  if (arg2 == 0)\n\t\t\t\t\t    div_zero = TRUE;\n\t\t\t\t\telse\n\t\t\t\t\t    res = arg1 / arg2;\n\t\t\t\t\tbreak;\n\t\t\tcase EXPR_REM:  if (arg2 == 0)\n\t\t\t\t\t    div_zero = TRUE;\n\t\t\t\t\telse\n\t\t\t\t\t    res = arg1 % arg2;\n\t\t\t\t\tbreak;\n\t\t\tcase EXPR_SUB: res = arg1 - arg2; break;\n\t\t\tcase EXPR_ADD: res = arg1 + arg2; break;\n\n\t\t\tcase EXPR_EQUAL: res = arg1 == arg2; break;\n\t\t\tcase EXPR_NEQUAL: res = arg1 != arg2; break;\n\t\t\tcase EXPR_GREATER: res = arg1 > arg2; break;\n\t\t\tcase EXPR_GEQUAL: res = arg1 >= arg2; break;\n\t\t\tcase EXPR_SMALLER: res = arg1 < arg2; break;\n\t\t\tcase EXPR_SEQUAL: res = arg1 <= arg2; break;\n\t\t\tdefault: break;\n\t\t    }\n\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    if (iptr->isn_type == ISN_COMPARENR)\n\t\t    {\n\t\t\ttv1->v_type = VAR_BOOL;\n\t\t\ttv1->vval.v_number = res ? VVAL_TRUE : VVAL_FALSE;\n\t\t    }\n\t\t    else\n\t\t\ttv1->vval.v_number = res;\n\t\t    if (div_zero)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\temsg(_(e_divide_by_zero));\n\t\t\tgoto on_error;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    // Computation with two float arguments\n\t    case ISN_OPFLOAT:\n\t    case ISN_COMPAREFLOAT:\n#ifdef FEAT_FLOAT\n\t\t{\n\t\t    typval_T\t*tv1 = STACK_TV_BOT(-2);\n\t\t    typval_T\t*tv2 = STACK_TV_BOT(-1);\n\t\t    float_T\targ1 = tv1->vval.v_float;\n\t\t    float_T\targ2 = tv2->vval.v_float;\n\t\t    float_T\tres = 0;\n\t\t    int\t\tcmp = FALSE;\n\n\t\t    switch (iptr->isn_arg.op.op_type)\n\t\t    {\n\t\t\tcase EXPR_MULT: res = arg1 * arg2; break;\n\t\t\tcase EXPR_DIV: res = arg1 / arg2; break;\n\t\t\tcase EXPR_SUB: res = arg1 - arg2; break;\n\t\t\tcase EXPR_ADD: res = arg1 + arg2; break;\n\n\t\t\tcase EXPR_EQUAL: cmp = arg1 == arg2; break;\n\t\t\tcase EXPR_NEQUAL: cmp = arg1 != arg2; break;\n\t\t\tcase EXPR_GREATER: cmp = arg1 > arg2; break;\n\t\t\tcase EXPR_GEQUAL: cmp = arg1 >= arg2; break;\n\t\t\tcase EXPR_SMALLER: cmp = arg1 < arg2; break;\n\t\t\tcase EXPR_SEQUAL: cmp = arg1 <= arg2; break;\n\t\t\tdefault: cmp = 0; break;\n\t\t    }\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    if (iptr->isn_type == ISN_COMPAREFLOAT)\n\t\t    {\n\t\t\ttv1->v_type = VAR_BOOL;\n\t\t\ttv1->vval.v_number = cmp ? VVAL_TRUE : VVAL_FALSE;\n\t\t    }\n\t\t    else\n\t\t\ttv1->vval.v_float = res;\n\t\t}\n#endif\n\t\tbreak;\n\n\t    case ISN_COMPARELIST:\n\t    case ISN_COMPAREDICT:\n\t    case ISN_COMPAREFUNC:\n\t    case ISN_COMPARESTRING:\n\t    case ISN_COMPAREBLOB:\n\t\t{\n\t\t    typval_T\t*tv1 = STACK_TV_BOT(-2);\n\t\t    typval_T\t*tv2 = STACK_TV_BOT(-1);\n\t\t    exprtype_T\texprtype = iptr->isn_arg.op.op_type;\n\t\t    int\t\tic = iptr->isn_arg.op.op_ic;\n\t\t    int\t\tres = FALSE;\n\t\t    int\t\tstatus = OK;\n\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    if (iptr->isn_type == ISN_COMPARELIST)\n\t\t    {\n\t\t\tstatus = typval_compare_list(tv1, tv2,\n\t\t\t\t\t\t\t   exprtype, ic, &res);\n\t\t    }\n\t\t    else if (iptr->isn_type == ISN_COMPAREDICT)\n\t\t    {\n\t\t\tstatus = typval_compare_dict(tv1, tv2,\n\t\t\t\t\t\t\t   exprtype, ic, &res);\n\t\t    }\n\t\t    else if (iptr->isn_type == ISN_COMPAREFUNC)\n\t\t    {\n\t\t\tstatus = typval_compare_func(tv1, tv2,\n\t\t\t\t\t\t\t   exprtype, ic, &res);\n\t\t    }\n\t\t    else if (iptr->isn_type == ISN_COMPARESTRING)\n\t\t    {\n\t\t\tstatus = typval_compare_string(tv1, tv2,\n\t\t\t\t\t\t\t   exprtype, ic, &res);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tstatus = typval_compare_blob(tv1, tv2, exprtype, &res);\n\t\t    }\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    clear_tv(tv1);\n\t\t    clear_tv(tv2);\n\t\t    tv1->v_type = VAR_BOOL;\n\t\t    tv1->vval.v_number = res ? VVAL_TRUE : VVAL_FALSE;\n\t\t    if (status == FAIL)\n\t\t\tgoto theend;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_COMPAREANY:\n\t\t{\n\t\t    typval_T\t*tv1 = STACK_TV_BOT(-2);\n\t\t    typval_T\t*tv2 = STACK_TV_BOT(-1);\n\t\t    exprtype_T\texprtype = iptr->isn_arg.op.op_type;\n\t\t    int\t\tic = iptr->isn_arg.op.op_ic;\n\t\t    int\t\tstatus;\n\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    status = typval_compare(tv1, tv2, exprtype, ic);\n\t\t    clear_tv(tv2);\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    if (status == FAIL)\n\t\t\tgoto theend;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_ADDLIST:\n\t    case ISN_ADDBLOB:\n\t\t{\n\t\t    typval_T *tv1 = STACK_TV_BOT(-2);\n\t\t    typval_T *tv2 = STACK_TV_BOT(-1);\n\n\t\t    // add two lists or blobs\n\t\t    if (iptr->isn_type == ISN_ADDLIST)\n\t\t    {\n\t\t\tif (iptr->isn_arg.op.op_type == EXPR_APPEND\n\t\t\t\t\t\t   && tv1->vval.v_list != NULL)\n\t\t\t    list_extend(tv1->vval.v_list, tv2->vval.v_list,\n\t\t\t\t\t\t\t\t\t NULL);\n\t\t\telse\n\t\t\t    eval_addlist(tv1, tv2);\n\t\t    }\n\t\t    else\n\t\t\teval_addblob(tv1, tv2);\n\t\t    clear_tv(tv2);\n\t\t    --ectx->ec_stack.ga_len;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_LISTAPPEND:\n\t\t{\n\t\t    typval_T\t*tv1 = STACK_TV_BOT(-2);\n\t\t    typval_T\t*tv2 = STACK_TV_BOT(-1);\n\t\t    list_T\t*l = tv1->vval.v_list;\n\n\t\t    // add an item to a list\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    if (l == NULL)\n\t\t    {\n\t\t\temsg(_(e_cannot_add_to_null_list));\n\t\t\tgoto on_error;\n\t\t    }\n\t\t    if (value_check_lock(l->lv_lock, NULL, FALSE))\n\t\t\tgoto on_error;\n\t\t    if (list_append_tv(l, tv2) == FAIL)\n\t\t\tgoto theend;\n\t\t    clear_tv(tv2);\n\t\t    --ectx->ec_stack.ga_len;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_BLOBAPPEND:\n\t\t{\n\t\t    typval_T\t*tv1 = STACK_TV_BOT(-2);\n\t\t    typval_T\t*tv2 = STACK_TV_BOT(-1);\n\t\t    blob_T\t*b = tv1->vval.v_blob;\n\t\t    int\t\terror = FALSE;\n\t\t    varnumber_T n;\n\n\t\t    // add a number to a blob\n\t\t    if (b == NULL)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\temsg(_(e_cannot_add_to_null_blob));\n\t\t\tgoto on_error;\n\t\t    }\n\t\t    n = tv_get_number_chk(tv2, &error);\n\t\t    if (error)\n\t\t\tgoto on_error;\n\t\t    ga_append(&b->bv_ga, (int)n);\n\t\t    --ectx->ec_stack.ga_len;\n\t\t}\n\t\tbreak;\n\n\t    // Computation with two arguments of unknown type\n\t    case ISN_OPANY:\n\t\t{\n\t\t    typval_T\t*tv1 = STACK_TV_BOT(-2);\n\t\t    typval_T\t*tv2 = STACK_TV_BOT(-1);\n\t\t    varnumber_T\tn1, n2;\n#ifdef FEAT_FLOAT\n\t\t    float_T\tf1 = 0, f2 = 0;\n#endif\n\t\t    int\t\terror = FALSE;\n\n\t\t    if (iptr->isn_arg.op.op_type == EXPR_ADD)\n\t\t    {\n\t\t\tif (tv1->v_type == VAR_LIST && tv2->v_type == VAR_LIST)\n\t\t\t{\n\t\t\t    eval_addlist(tv1, tv2);\n\t\t\t    clear_tv(tv2);\n\t\t\t    --ectx->ec_stack.ga_len;\n\t\t\t    break;\n\t\t\t}\n\t\t\telse if (tv1->v_type == VAR_BLOB\n\t\t\t\t\t\t    && tv2->v_type == VAR_BLOB)\n\t\t\t{\n\t\t\t    eval_addblob(tv1, tv2);\n\t\t\t    clear_tv(tv2);\n\t\t\t    --ectx->ec_stack.ga_len;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n#ifdef FEAT_FLOAT\n\t\t    if (tv1->v_type == VAR_FLOAT)\n\t\t    {\n\t\t\tf1 = tv1->vval.v_float;\n\t\t\tn1 = 0;\n\t\t    }\n\t\t    else\n#endif\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tn1 = tv_get_number_chk(tv1, &error);\n\t\t\tif (error)\n\t\t\t    goto on_error;\n#ifdef FEAT_FLOAT\n\t\t\tif (tv2->v_type == VAR_FLOAT)\n\t\t\t    f1 = n1;\n#endif\n\t\t    }\n#ifdef FEAT_FLOAT\n\t\t    if (tv2->v_type == VAR_FLOAT)\n\t\t    {\n\t\t\tf2 = tv2->vval.v_float;\n\t\t\tn2 = 0;\n\t\t    }\n\t\t    else\n#endif\n\t\t    {\n\t\t\tn2 = tv_get_number_chk(tv2, &error);\n\t\t\tif (error)\n\t\t\t    goto on_error;\n#ifdef FEAT_FLOAT\n\t\t\tif (tv1->v_type == VAR_FLOAT)\n\t\t\t    f2 = n2;\n#endif\n\t\t    }\n#ifdef FEAT_FLOAT\n\t\t    // if there is a float on either side the result is a float\n\t\t    if (tv1->v_type == VAR_FLOAT || tv2->v_type == VAR_FLOAT)\n\t\t    {\n\t\t\tswitch (iptr->isn_arg.op.op_type)\n\t\t\t{\n\t\t\t    case EXPR_MULT: f1 = f1 * f2; break;\n\t\t\t    case EXPR_DIV:  f1 = f1 / f2; break;\n\t\t\t    case EXPR_SUB:  f1 = f1 - f2; break;\n\t\t\t    case EXPR_ADD:  f1 = f1 + f2; break;\n\t\t\t    default: SOURCING_LNUM = iptr->isn_lnum;\n\t\t\t\t     emsg(_(e_cannot_use_percent_with_float));\n\t\t\t\t     goto on_error;\n\t\t\t}\n\t\t\tclear_tv(tv1);\n\t\t\tclear_tv(tv2);\n\t\t\ttv1->v_type = VAR_FLOAT;\n\t\t\ttv1->vval.v_float = f1;\n\t\t\t--ectx->ec_stack.ga_len;\n\t\t    }\n\t\t    else\n#endif\n\t\t    {\n\t\t\tint failed = FALSE;\n\n\t\t\tswitch (iptr->isn_arg.op.op_type)\n\t\t\t{\n\t\t\t    case EXPR_MULT: n1 = n1 * n2; break;\n\t\t\t    case EXPR_DIV:  n1 = num_divide(n1, n2, &failed);\n\t\t\t\t\t    if (failed)\n\t\t\t\t\t\tgoto on_error;\n\t\t\t\t\t    break;\n\t\t\t    case EXPR_SUB:  n1 = n1 - n2; break;\n\t\t\t    case EXPR_ADD:  n1 = n1 + n2; break;\n\t\t\t    default:\t    n1 = num_modulus(n1, n2, &failed);\n\t\t\t\t\t    if (failed)\n\t\t\t\t\t\tgoto on_error;\n\t\t\t\t\t    break;\n\t\t\t}\n\t\t\tclear_tv(tv1);\n\t\t\tclear_tv(tv2);\n\t\t\ttv1->v_type = VAR_NUMBER;\n\t\t\ttv1->vval.v_number = n1;\n\t\t\t--ectx->ec_stack.ga_len;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    case ISN_CONCAT:\n\t\t{\n\t\t    char_u *str1 = STACK_TV_BOT(-2)->vval.v_string;\n\t\t    char_u *str2 = STACK_TV_BOT(-1)->vval.v_string;\n\t\t    char_u *res;\n\n\t\t    res = concat_str(str1, str2);\n\t\t    clear_tv(STACK_TV_BOT(-2));\n\t\t    clear_tv(STACK_TV_BOT(-1));\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    STACK_TV_BOT(-1)->vval.v_string = res;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_STRINDEX:\n\t    case ISN_STRSLICE:\n\t\t{\n\t\t    int\t\tis_slice = iptr->isn_type == ISN_STRSLICE;\n\t\t    varnumber_T\tn1 = 0, n2;\n\t\t    char_u\t*res;\n\n\t\t    // string index: string is at stack-2, index at stack-1\n\t\t    // string slice: string is at stack-3, first index at\n\t\t    // stack-2, second index at stack-1\n\t\t    if (is_slice)\n\t\t    {\n\t\t\ttv = STACK_TV_BOT(-2);\n\t\t\tn1 = tv->vval.v_number;\n\t\t    }\n\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    n2 = tv->vval.v_number;\n\n\t\t    ectx->ec_stack.ga_len -= is_slice ? 2 : 1;\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    if (is_slice)\n\t\t\t// Slice: Select the characters from the string\n\t\t\tres = string_slice(tv->vval.v_string, n1, n2, FALSE);\n\t\t    else\n\t\t\t// Index: The resulting variable is a string of a\n\t\t\t// single character (including composing characters).\n\t\t\t// If the index is too big or negative the result is\n\t\t\t// empty.\n\t\t\tres = char_from_string(tv->vval.v_string, n2);\n\t\t    vim_free(tv->vval.v_string);\n\t\t    tv->vval.v_string = res;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_LISTINDEX:\n\t    case ISN_LISTSLICE:\n\t    case ISN_BLOBINDEX:\n\t    case ISN_BLOBSLICE:\n\t\t{\n\t\t    int\t\tis_slice = iptr->isn_type == ISN_LISTSLICE\n\t\t\t\t\t    || iptr->isn_type == ISN_BLOBSLICE;\n\t\t    int\t\tis_blob = iptr->isn_type == ISN_BLOBINDEX\n\t\t\t\t\t    || iptr->isn_type == ISN_BLOBSLICE;\n\t\t    varnumber_T\tn1, n2;\n\t\t    typval_T\t*val_tv;\n\n\t\t    // list index: list is at stack-2, index at stack-1\n\t\t    // list slice: list is at stack-3, indexes at stack-2 and\n\t\t    // stack-1\n\t\t    // Same for blob.\n\t\t    val_tv = is_slice ? STACK_TV_BOT(-3) : STACK_TV_BOT(-2);\n\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    n1 = n2 = tv->vval.v_number;\n\t\t    clear_tv(tv);\n\n\t\t    if (is_slice)\n\t\t    {\n\t\t\ttv = STACK_TV_BOT(-2);\n\t\t\tn1 = tv->vval.v_number;\n\t\t\tclear_tv(tv);\n\t\t    }\n\n\t\t    ectx->ec_stack.ga_len -= is_slice ? 2 : 1;\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    if (is_blob)\n\t\t    {\n\t\t\tif (blob_slice_or_index(val_tv->vval.v_blob, is_slice,\n\t\t\t\t\t\t    n1, n2, FALSE, tv) == FAIL)\n\t\t\t    goto on_error;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (list_slice_or_index(val_tv->vval.v_list, is_slice,\n\t\t\t\t\t      n1, n2, FALSE, tv, TRUE) == FAIL)\n\t\t\t    goto on_error;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    case ISN_ANYINDEX:\n\t    case ISN_ANYSLICE:\n\t\t{\n\t\t    int\t\tis_slice = iptr->isn_type == ISN_ANYSLICE;\n\t\t    typval_T\t*var1, *var2;\n\t\t    int\t\tres;\n\n\t\t    // index: composite is at stack-2, index at stack-1\n\t\t    // slice: composite is at stack-3, indexes at stack-2 and\n\t\t    // stack-1\n\t\t    tv = is_slice ? STACK_TV_BOT(-3) : STACK_TV_BOT(-2);\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    if (check_can_index(tv, TRUE, TRUE) == FAIL)\n\t\t\tgoto on_error;\n\t\t    var1 = is_slice ? STACK_TV_BOT(-2) : STACK_TV_BOT(-1);\n\t\t    var2 = is_slice ? STACK_TV_BOT(-1) : NULL;\n\t\t    res = eval_index_inner(tv, is_slice, var1, var2,\n\t\t\t\t\t\t\tFALSE, NULL, -1, TRUE);\n\t\t    clear_tv(var1);\n\t\t    if (is_slice)\n\t\t\tclear_tv(var2);\n\t\t    ectx->ec_stack.ga_len -= is_slice ? 2 : 1;\n\t\t    if (res == FAIL)\n\t\t\tgoto on_error;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_SLICE:\n\t\t{\n\t\t    list_T\t*list;\n\t\t    int\t\tcount = iptr->isn_arg.number;\n\n\t\t    // type will have been checked to be a list\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    list = tv->vval.v_list;\n\n\t\t    // no error for short list, expect it to be checked earlier\n\t\t    if (list != NULL && list->lv_len >= count)\n\t\t    {\n\t\t\tlist_T\t*newlist = list_slice(list,\n\t\t\t\t\t\t      count, list->lv_len - 1);\n\n\t\t\tif (newlist != NULL)\n\t\t\t{\n\t\t\t    list_unref(list);\n\t\t\t    tv->vval.v_list = newlist;\n\t\t\t    ++newlist->lv_refcount;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    case ISN_GETITEM:\n\t\t{\n\t\t    listitem_T\t*li;\n\t\t    getitem_T\t*gi = &iptr->isn_arg.getitem;\n\n\t\t    // Get list item: list is at stack-1, push item.\n\t\t    // List type and length is checked for when compiling.\n\t\t    tv = STACK_TV_BOT(-1 - gi->gi_with_op);\n\t\t    li = list_find(tv->vval.v_list, gi->gi_index);\n\n\t\t    if (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\tgoto theend;\n\t\t    ++ectx->ec_stack.ga_len;\n\t\t    copy_tv(&li->li_tv, STACK_TV_BOT(-1));\n\n\t\t    // Useful when used in unpack assignment.  Reset at\n\t\t    // ISN_DROP.\n\t\t    ectx->ec_where.wt_index = gi->gi_index + 1;\n\t\t    ectx->ec_where.wt_variable = TRUE;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_MEMBER:\n\t\t{\n\t\t    dict_T\t*dict;\n\t\t    char_u\t*key;\n\t\t    dictitem_T\t*di;\n\n\t\t    // dict member: dict is at stack-2, key at stack-1\n\t\t    tv = STACK_TV_BOT(-2);\n\t\t    // no need to check for VAR_DICT, CHECKTYPE will check.\n\t\t    dict = tv->vval.v_dict;\n\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    // no need to check for VAR_STRING, 2STRING will check.\n\t\t    key = tv->vval.v_string;\n\t\t    if (key == NULL)\n\t\t\tkey = (char_u *)\"\";\n\n\t\t    if ((di = dict_find(dict, key, -1)) == NULL)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tsemsg(_(e_key_not_present_in_dictionary), key);\n\n\t\t\t// If :silent! is used we will continue, make sure the\n\t\t\t// stack contents makes sense and the dict stack is\n\t\t\t// updated.\n\t\t\tclear_tv(tv);\n\t\t\t--ectx->ec_stack.ga_len;\n\t\t\ttv = STACK_TV_BOT(-1);\n\t\t\t(void) dict_stack_save(tv);\n\t\t\ttv->v_type = VAR_NUMBER;\n\t\t\ttv->vval.v_number = 0;\n\t\t\tgoto on_fatal_error;\n\t\t    }\n\t\t    clear_tv(tv);\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    // Put the dict used on the dict stack, it might be used by\n\t\t    // a dict function later.\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    if (dict_stack_save(tv) == FAIL)\n\t\t\tgoto on_fatal_error;\n\t\t    copy_tv(&di->di_tv, tv);\n\t\t}\n\t\tbreak;\n\n\t    // dict member with string key\n\t    case ISN_STRINGMEMBER:\n\t\t{\n\t\t    dict_T\t*dict;\n\t\t    dictitem_T\t*di;\n\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    if (tv->v_type != VAR_DICT || tv->vval.v_dict == NULL)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\temsg(_(e_dictionary_required));\n\t\t\tgoto on_error;\n\t\t    }\n\t\t    dict = tv->vval.v_dict;\n\n\t\t    if ((di = dict_find(dict, iptr->isn_arg.string, -1))\n\t\t\t\t\t\t\t\t       == NULL)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tsemsg(_(e_key_not_present_in_dictionary), iptr->isn_arg.string);\n\t\t\tgoto on_error;\n\t\t    }\n\t\t    // Put the dict used on the dict stack, it might be used by\n\t\t    // a dict function later.\n\t\t    if (dict_stack_save(tv) == FAIL)\n\t\t\tgoto on_fatal_error;\n\n\t\t    copy_tv(&di->di_tv, tv);\n\t\t}\n\t\tbreak;\n\n\t    case ISN_CLEARDICT:\n\t\tdict_stack_drop();\n\t\tbreak;\n\n\t    case ISN_USEDICT:\n\t\t{\n\t\t    typval_T *dict_tv = dict_stack_get_tv();\n\n\t\t    // Turn \"dict.Func\" into a partial for \"Func\" bound to\n\t\t    // \"dict\".  Don't do this when \"Func\" is already a partial\n\t\t    // that was bound explicitly (pt_auto is FALSE).\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    if (dict_tv != NULL\n\t\t\t    && dict_tv->v_type == VAR_DICT\n\t\t\t    && dict_tv->vval.v_dict != NULL\n\t\t\t    && (tv->v_type == VAR_FUNC\n\t\t\t\t|| (tv->v_type == VAR_PARTIAL\n\t\t\t\t    && (tv->vval.v_partial->pt_auto\n\t\t\t\t     || tv->vval.v_partial->pt_dict == NULL))))\n\t\t    dict_tv->vval.v_dict =\n\t\t\t\t\tmake_partial(dict_tv->vval.v_dict, tv);\n\t\t    dict_stack_drop();\n\t\t}\n\t\tbreak;\n\n\t    case ISN_NEGATENR:\n\t\ttv = STACK_TV_BOT(-1);\n\t\tif (tv->v_type != VAR_NUMBER\n#ifdef FEAT_FLOAT\n\t\t\t&& tv->v_type != VAR_FLOAT\n#endif\n\t\t\t)\n\t\t{\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    emsg(_(e_number_expected));\n\t\t    goto on_error;\n\t\t}\n#ifdef FEAT_FLOAT\n\t\tif (tv->v_type == VAR_FLOAT)\n\t\t    tv->vval.v_float = -tv->vval.v_float;\n\t\telse\n#endif\n\t\t    tv->vval.v_number = -tv->vval.v_number;\n\t\tbreak;\n\n\t    case ISN_CHECKNR:\n\t\t{\n\t\t    int\t\terror = FALSE;\n\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    if (check_not_string(tv) == FAIL)\n\t\t\tgoto on_error;\n\t\t    (void)tv_get_number_chk(tv, &error);\n\t\t    if (error)\n\t\t\tgoto on_error;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_CHECKTYPE:\n\t\t{\n\t\t    checktype_T *ct = &iptr->isn_arg.type;\n\n\t\t    tv = STACK_TV_BOT((int)ct->ct_off);\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    if (!ectx->ec_where.wt_variable)\n\t\t\tectx->ec_where.wt_index = ct->ct_arg_idx;\n\t\t    if (check_typval_type(ct->ct_type, tv, ectx->ec_where)\n\t\t\t\t\t\t\t\t       == FAIL)\n\t\t\tgoto on_error;\n\t\t    if (!ectx->ec_where.wt_variable)\n\t\t\tectx->ec_where.wt_index = 0;\n\n\t\t    // number 0 is FALSE, number 1 is TRUE\n\t\t    if (tv->v_type == VAR_NUMBER\n\t\t\t    && ct->ct_type->tt_type == VAR_BOOL\n\t\t\t    && (tv->vval.v_number == 0\n\t\t\t\t\t\t|| tv->vval.v_number == 1))\n\t\t    {\n\t\t\ttv->v_type = VAR_BOOL;\n\t\t\ttv->vval.v_number = tv->vval.v_number\n\t\t\t\t\t\t      ? VVAL_TRUE : VVAL_FALSE;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    case ISN_CHECKLEN:\n\t\t{\n\t\t    int\t    min_len = iptr->isn_arg.checklen.cl_min_len;\n\t\t    list_T  *list = NULL;\n\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    if (tv->v_type == VAR_LIST)\n\t\t\t    list = tv->vval.v_list;\n\t\t    if (list == NULL || list->lv_len < min_len\n\t\t\t    || (list->lv_len > min_len\n\t\t\t\t\t&& !iptr->isn_arg.checklen.cl_more_OK))\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tsemsg(_(e_expected_nr_items_but_got_nr),\n\t\t\t\t     min_len, list == NULL ? 0 : list->lv_len);\n\t\t\tgoto on_error;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    case ISN_SETTYPE:\n\t\t{\n\t\t    checktype_T *ct = &iptr->isn_arg.type;\n\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    if (tv->v_type == VAR_DICT && tv->vval.v_dict != NULL)\n\t\t    {\n\t\t\tfree_type(tv->vval.v_dict->dv_type);\n\t\t\ttv->vval.v_dict->dv_type = alloc_type(ct->ct_type);\n\t\t    }\n\t\t    else if (tv->v_type == VAR_LIST && tv->vval.v_list != NULL)\n\t\t    {\n\t\t\tfree_type(tv->vval.v_list->lv_type);\n\t\t\ttv->vval.v_list->lv_type = alloc_type(ct->ct_type);\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    case ISN_2BOOL:\n\t    case ISN_COND2BOOL:\n\t\t{\n\t\t    int n;\n\t\t    int error = FALSE;\n\n\t\t    if (iptr->isn_type == ISN_2BOOL)\n\t\t    {\n\t\t\ttv = STACK_TV_BOT(iptr->isn_arg.tobool.offset);\n\t\t\tn = tv2bool(tv);\n\t\t\tif (iptr->isn_arg.tobool.invert)\n\t\t\t    n = !n;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\ttv = STACK_TV_BOT(-1);\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tn = tv_get_bool_chk(tv, &error);\n\t\t\tif (error)\n\t\t\t    goto on_error;\n\t\t    }\n\t\t    clear_tv(tv);\n\t\t    tv->v_type = VAR_BOOL;\n\t\t    tv->vval.v_number = n ? VVAL_TRUE : VVAL_FALSE;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_2STRING:\n\t    case ISN_2STRING_ANY:\n\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\tif (do_2string(STACK_TV_BOT(iptr->isn_arg.tostring.offset),\n\t\t\t\tiptr->isn_type == ISN_2STRING_ANY,\n\t\t\t\t      iptr->isn_arg.tostring.tolerant) == FAIL)\n\t\t\t    goto on_error;\n\t\tbreak;\n\n\t    case ISN_RANGE:\n\t\t{\n\t\t    exarg_T\tea;\n\t\t    char\t*errormsg;\n\n\t\t    ea.line2 = 0;\n\t\t    ea.addr_count = 0;\n\t\t    ea.addr_type = ADDR_LINES;\n\t\t    ea.cmd = iptr->isn_arg.string;\n\t\t    ea.skip = FALSE;\n\t\t    if (parse_cmd_address(&ea, &errormsg, FALSE) == FAIL)\n\t\t\tgoto on_error;\n\n\t\t    if (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\tgoto theend;\n\t\t    ++ectx->ec_stack.ga_len;\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    tv->v_type = VAR_NUMBER;\n\t\t    tv->v_lock = 0;\n\t\t    if (ea.addr_count == 0)\n\t\t\ttv->vval.v_number = curwin->w_cursor.lnum;\n\t\t    else\n\t\t\ttv->vval.v_number = ea.line2;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_PUT:\n\t\t{\n\t\t    int\t\tregname = iptr->isn_arg.put.put_regname;\n\t\t    linenr_T\tlnum = iptr->isn_arg.put.put_lnum;\n\t\t    char_u\t*expr = NULL;\n\t\t    int\t\tdir = FORWARD;\n\n\t\t    if (lnum < -2)\n\t\t    {\n\t\t\t// line number was put on the stack by ISN_RANGE\n\t\t\ttv = STACK_TV_BOT(-1);\n\t\t\tcurwin->w_cursor.lnum = tv->vval.v_number;\n\t\t\tif (lnum == LNUM_VARIABLE_RANGE_ABOVE)\n\t\t\t    dir = BACKWARD;\n\t\t\t--ectx->ec_stack.ga_len;\n\t\t    }\n\t\t    else if (lnum == -2)\n\t\t\t// :put! above cursor\n\t\t\tdir = BACKWARD;\n\t\t    else if (lnum >= 0)\n\t\t\tcurwin->w_cursor.lnum = iptr->isn_arg.put.put_lnum;\n\n\t\t    if (regname == '=')\n\t\t    {\n\t\t\ttv = STACK_TV_BOT(-1);\n\t\t\tif (tv->v_type == VAR_STRING)\n\t\t\t    expr = tv->vval.v_string;\n\t\t\telse\n\t\t\t{\n\t\t\t    expr = typval2string(tv, TRUE); // allocates value\n\t\t\t    clear_tv(tv);\n\t\t\t}\n\t\t\t--ectx->ec_stack.ga_len;\n\t\t    }\n\t\t    check_cursor();\n\t\t    do_put(regname, expr, dir, 1L, PUT_LINE|PUT_CURSLINE);\n\t\t    vim_free(expr);\n\t\t}\n\t\tbreak;\n\n\t    case ISN_CMDMOD:\n\t\tectx->ec_funclocal.floc_save_cmdmod = cmdmod;\n\t\tectx->ec_funclocal.floc_restore_cmdmod = TRUE;\n\t\tectx->ec_funclocal.floc_restore_cmdmod_stacklen =\n\t\t\t\t\t\t\t ectx->ec_stack.ga_len;\n\t\tcmdmod = *iptr->isn_arg.cmdmod.cf_cmdmod;\n\t\tapply_cmdmod(&cmdmod);\n\t\tbreak;\n\n\t    case ISN_CMDMOD_REV:\n\t\t// filter regprog is owned by the instruction, don't free it\n\t\tcmdmod.cmod_filter_regmatch.regprog = NULL;\n\t\tundo_cmdmod(&cmdmod);\n\t\tcmdmod = ectx->ec_funclocal.floc_save_cmdmod;\n\t\tectx->ec_funclocal.floc_restore_cmdmod = FALSE;\n\t\tbreak;\n\n\t    case ISN_UNPACK:\n\t\t{\n\t\t    int\t\tcount = iptr->isn_arg.unpack.unp_count;\n\t\t    int\t\tsemicolon = iptr->isn_arg.unpack.unp_semicolon;\n\t\t    list_T\t*l;\n\t\t    listitem_T\t*li;\n\t\t    int\t\ti;\n\n\t\t    // Check there is a valid list to unpack.\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    if (tv->v_type != VAR_LIST)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\temsg(_(e_for_argument_must_be_sequence_of_lists));\n\t\t\tgoto on_error;\n\t\t    }\n\t\t    l = tv->vval.v_list;\n\t\t    if (l == NULL\n\t\t\t\t|| l->lv_len < (semicolon ? count - 1 : count))\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\temsg(_(e_list_value_does_not_have_enough_items));\n\t\t\tgoto on_error;\n\t\t    }\n\t\t    else if (!semicolon && l->lv_len > count)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\temsg(_(e_list_value_has_more_items_than_targets));\n\t\t\tgoto on_error;\n\t\t    }\n\n\t\t    CHECK_LIST_MATERIALIZE(l);\n\t\t    if (GA_GROW_FAILS(&ectx->ec_stack, count - 1))\n\t\t\tgoto theend;\n\t\t    ectx->ec_stack.ga_len += count - 1;\n\n\t\t    // Variable after semicolon gets a list with the remaining\n\t\t    // items.\n\t\t    if (semicolon)\n\t\t    {\n\t\t\tlist_T\t*rem_list =\n\t\t\t\t  list_alloc_with_items(l->lv_len - count + 1);\n\n\t\t\tif (rem_list == NULL)\n\t\t\t    goto theend;\n\t\t\ttv = STACK_TV_BOT(-count);\n\t\t\ttv->vval.v_list = rem_list;\n\t\t\t++rem_list->lv_refcount;\n\t\t\ttv->v_lock = 0;\n\t\t\tli = l->lv_first;\n\t\t\tfor (i = 0; i < count - 1; ++i)\n\t\t\t    li = li->li_next;\n\t\t\tfor (i = 0; li != NULL; ++i)\n\t\t\t{\n\t\t\t    list_set_item(rem_list, i, &li->li_tv);\n\t\t\t    li = li->li_next;\n\t\t\t}\n\t\t\t--count;\n\t\t    }\n\n\t\t    // Produce the values in reverse order, first item last.\n\t\t    li = l->lv_first;\n\t\t    for (i = 0; i < count; ++i)\n\t\t    {\n\t\t\ttv = STACK_TV_BOT(-i - 1);\n\t\t\tcopy_tv(&li->li_tv, tv);\n\t\t\tli = li->li_next;\n\t\t    }\n\n\t\t    list_unref(l);\n\t\t}\n\t\tbreak;\n\n\t    case ISN_PROF_START:\n\t    case ISN_PROF_END:\n\t\t{\n#ifdef FEAT_PROFILE\n\t\t    funccall_T cookie;\n\t\t    ufunc_T\t    *cur_ufunc =\n\t\t\t\t    (((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t       + ectx->ec_dfunc_idx)->df_ufunc;\n\n\t\t    cookie.func = cur_ufunc;\n\t\t    if (iptr->isn_type == ISN_PROF_START)\n\t\t    {\n\t\t\tfunc_line_start(&cookie, iptr->isn_lnum);\n\t\t\t// if we get here the instruction is executed\n\t\t\tfunc_line_exec(&cookie);\n\t\t    }\n\t\t    else\n\t\t\tfunc_line_end(&cookie);\n#endif\n\t\t}\n\t\tbreak;\n\n\t    case ISN_DEBUG:\n\t\thandle_debug(iptr, ectx);\n\t\tbreak;\n\n\t    case ISN_SHUFFLE:\n\t\t{\n\t\t    typval_T\ttmp_tv;\n\t\t    int\t\titem = iptr->isn_arg.shuffle.shfl_item;\n\t\t    int\t\tup = iptr->isn_arg.shuffle.shfl_up;\n\n\t\t    tmp_tv = *STACK_TV_BOT(-item);\n\t\t    for ( ; up > 0 && item > 1; --up)\n\t\t    {\n\t\t\t*STACK_TV_BOT(-item) = *STACK_TV_BOT(-item + 1);\n\t\t\t--item;\n\t\t    }\n\t\t    *STACK_TV_BOT(-item) = tmp_tv;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_DROP:\n\t\t--ectx->ec_stack.ga_len;\n\t\tclear_tv(STACK_TV_BOT(0));\n\t\tectx->ec_where.wt_index = 0;\n\t\tectx->ec_where.wt_variable = FALSE;\n\t\tbreak;\n\t}\n\tcontinue;\n\nfunc_return:\n\t// Restore previous function. If the frame pointer is where we started\n\t// then there is none and we are done.\n\tif (ectx->ec_frame_idx == ectx->ec_initial_frame_idx)\n\t    goto done;\n\n\tif (func_return(ectx) == FAIL)\n\t    // only fails when out of memory\n\t    goto theend;\n\tcontinue;\n\non_error:\n\t// Jump here for an error that does not require aborting execution.\n\t// If \"emsg_silent\" is set then ignore the error, unless it was set\n\t// when calling the function.\n\tif (did_emsg_cumul + did_emsg == ectx->ec_did_emsg_before\n\t\t\t\t\t   && emsg_silent && did_emsg_def == 0)\n\t{\n\t    // If a sequence of instructions causes an error while \":silent!\"\n\t    // was used, restore the stack length and jump ahead to restoring\n\t    // the cmdmod.\n\t    if (ectx->ec_funclocal.floc_restore_cmdmod)\n\t    {\n\t\twhile (ectx->ec_stack.ga_len\n\t\t\t     > ectx->ec_funclocal.floc_restore_cmdmod_stacklen)\n\t\t{\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    clear_tv(STACK_TV_BOT(0));\n\t\t}\n\t\twhile (ectx->ec_instr[ectx->ec_iidx].isn_type != ISN_CMDMOD_REV)\n\t\t    ++ectx->ec_iidx;\n\t    }\n\t    continue;\n\t}\non_fatal_error:\n\t// Jump here for an error that messes up the stack.\n\t// If we are not inside a try-catch started here, abort execution.\n\tif (trylevel <= ectx->ec_trylevel_at_start)\n\t    goto theend;\n    }\n\ndone:\n    ret = OK;\ntheend:\n    dict_stack_clear(dict_stack_len_at_start);\n    ectx->ec_trylevel_at_start = save_trylevel_at_start;\n    return ret;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146780,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "exec_instructions(ectx_T *ectx)\n{\n    int\t\tret = FAIL;\n    int\t\tsave_trylevel_at_start = ectx->ec_trylevel_at_start;\n    int\t\tdict_stack_len_at_start = dict_stack.ga_len;\n\n    // Start execution at the first instruction.\n    ectx->ec_iidx = 0;\n\n    // Only catch exceptions in this instruction list.\n    ectx->ec_trylevel_at_start = trylevel;\n\n    for (;;)\n    {\n\tstatic int  breakcheck_count = 0;  // using \"static\" makes it faster\n\tisn_T\t    *iptr;\n\ttypval_T    *tv;\n\n\tif (unlikely(++breakcheck_count >= 100))\n\t{\n\t    line_breakcheck();\n\t    breakcheck_count = 0;\n\t}\n\tif (unlikely(got_int))\n\t{\n\t    // Turn CTRL-C into an exception.\n\t    got_int = FALSE;\n\t    if (throw_exception(\"Vim:Interrupt\", ET_INTERRUPT, NULL) == FAIL)\n\t\tgoto theend;\n\t    did_throw = TRUE;\n\t}\n\n\tif (unlikely(did_emsg && msg_list != NULL && *msg_list != NULL))\n\t{\n\t    // Turn an error message into an exception.\n\t    did_emsg = FALSE;\n\t    if (throw_exception(*msg_list, ET_ERROR, NULL) == FAIL)\n\t\tgoto theend;\n\t    did_throw = TRUE;\n\t    *msg_list = NULL;\n\t}\n\n\tif (unlikely(did_throw))\n\t{\n\t    garray_T\t*trystack = &ectx->ec_trystack;\n\t    trycmd_T    *trycmd = NULL;\n\t    int\t\tindex = trystack->ga_len;\n\n\t    // An exception jumps to the first catch, finally, or returns from\n\t    // the current function.\n\t    while (index > 0)\n\t    {\n\t\ttrycmd = ((trycmd_T *)trystack->ga_data) + index - 1;\n\t\tif (!trycmd->tcd_in_catch || trycmd->tcd_finally_idx != 0)\n\t\t    break;\n\t\t// In the catch and finally block of this try we have to go up\n\t\t// one level.\n\t\t--index;\n\t\ttrycmd = NULL;\n\t    }\n\t    if (trycmd != NULL && trycmd->tcd_frame_idx == ectx->ec_frame_idx)\n\t    {\n\t\tif (trycmd->tcd_in_catch)\n\t\t{\n\t\t    // exception inside \":catch\", jump to \":finally\" once\n\t\t    ectx->ec_iidx = trycmd->tcd_finally_idx;\n\t\t    trycmd->tcd_finally_idx = 0;\n\t\t}\n\t\telse\n\t\t    // jump to first \":catch\"\n\t\t    ectx->ec_iidx = trycmd->tcd_catch_idx;\n\t\ttrycmd->tcd_in_catch = TRUE;\n\t\tdid_throw = FALSE;  // don't come back here until :endtry\n\t\ttrycmd->tcd_did_throw = TRUE;\n\t    }\n\t    else\n\t    {\n\t\t// Not inside try or need to return from current functions.\n\t\t// Push a dummy return value.\n\t\tif (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t    goto theend;\n\t\ttv = STACK_TV_BOT(0);\n\t\ttv->v_type = VAR_NUMBER;\n\t\ttv->vval.v_number = 0;\n\t\t++ectx->ec_stack.ga_len;\n\t\tif (ectx->ec_frame_idx == ectx->ec_initial_frame_idx)\n\t\t{\n\t\t    // At the toplevel we are done.\n\t\t    need_rethrow = TRUE;\n\t\t    if (handle_closure_in_use(ectx, FALSE) == FAIL)\n\t\t\tgoto theend;\n\t\t    goto done;\n\t\t}\n\n\t\tif (func_return(ectx) == FAIL)\n\t\t    goto theend;\n\t    }\n\t    continue;\n\t}\n\n\tiptr = &ectx->ec_instr[ectx->ec_iidx++];\n\tswitch (iptr->isn_type)\n\t{\n\t    // execute Ex command line\n\t    case ISN_EXEC:\n\t\tif (exec_command(iptr) == FAIL)\n\t\t    goto on_error;\n\t\tbreak;\n\n\t    // execute Ex command line split at NL characters.\n\t    case ISN_EXEC_SPLIT:\n\t\t{\n\t\t    source_cookie_T cookie;\n\t\t    char_u\t    *line;\n\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    CLEAR_FIELD(cookie);\n\t\t    cookie.sourcing_lnum = iptr->isn_lnum - 1;\n\t\t    cookie.nextline = iptr->isn_arg.string;\n\t\t    line = get_split_sourceline(0, &cookie, 0, 0);\n\t\t    if (do_cmdline(line,\n\t\t\t\tget_split_sourceline, &cookie,\n\t\t\t\t   DOCMD_VERBOSE|DOCMD_NOWAIT|DOCMD_KEYTYPED)\n\t\t\t\t\t\t\t\t\t== FAIL\n\t\t\t\t|| did_emsg)\n\t\t    {\n\t\t\tvim_free(line);\n\t\t\tgoto on_error;\n\t\t    }\n\t\t    vim_free(line);\n\t\t}\n\t\tbreak;\n\n\t    // execute Ex command line that is only a range\n\t    case ISN_EXECRANGE:\n\t\t{\n\t\t    exarg_T\tea;\n\t\t    char\t*error = NULL;\n\n\t\t    CLEAR_FIELD(ea);\n\t\t    ea.cmdidx = CMD_SIZE;\n\t\t    ea.addr_type = ADDR_LINES;\n\t\t    ea.cmd = iptr->isn_arg.string;\n\t\t    parse_cmd_address(&ea, &error, FALSE);\n\t\t    if (ea.cmd == NULL)\n\t\t\tgoto on_error;\n\t\t    if (error == NULL)\n\t\t\terror = ex_range_without_command(&ea);\n\t\t    if (error != NULL)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\temsg(error);\n\t\t\tgoto on_error;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    // Evaluate an expression with legacy syntax, push it onto the\n\t    // stack.\n\t    case ISN_LEGACY_EVAL:\n\t\t{\n\t\t    char_u  *arg = iptr->isn_arg.string;\n\t\t    int\t    res;\n\t\t    int\t    save_flags = cmdmod.cmod_flags;\n\n\t\t    if (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\tgoto theend;\n\t\t    tv = STACK_TV_BOT(0);\n\t\t    init_tv(tv);\n\t\t    cmdmod.cmod_flags |= CMOD_LEGACY;\n\t\t    res = eval0(arg, tv, NULL, &EVALARG_EVALUATE);\n\t\t    cmdmod.cmod_flags = save_flags;\n\t\t    if (res == FAIL)\n\t\t\tgoto on_error;\n\t\t    ++ectx->ec_stack.ga_len;\n\t\t}\n\t\tbreak;\n\n\t    // push typeval VAR_INSTR with instructions to be executed\n\t    case ISN_INSTR:\n\t\t{\n\t\t    if (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\tgoto theend;\n\t\t    tv = STACK_TV_BOT(0);\n\t\t    tv->vval.v_instr = ALLOC_ONE(instr_T);\n\t\t    if (tv->vval.v_instr == NULL)\n\t\t\tgoto on_error;\n\t\t    ++ectx->ec_stack.ga_len;\n\n\t\t    tv->v_type = VAR_INSTR;\n\t\t    tv->vval.v_instr->instr_ectx = ectx;\n\t\t    tv->vval.v_instr->instr_instr = iptr->isn_arg.instr;\n\t\t}\n\t\tbreak;\n\n\t    // execute :substitute with an expression\n\t    case ISN_SUBSTITUTE:\n\t\t{\n\t\t    subs_T\t\t*subs = &iptr->isn_arg.subs;\n\t\t    source_cookie_T\tcookie;\n\t\t    struct subs_expr_S\t*save_instr = substitute_instr;\n\t\t    struct subs_expr_S\tsubs_instr;\n\t\t    int\t\t\tres;\n\n\t\t    subs_instr.subs_ectx = ectx;\n\t\t    subs_instr.subs_instr = subs->subs_instr;\n\t\t    subs_instr.subs_status = OK;\n\t\t    substitute_instr = &subs_instr;\n\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    // This is very much like ISN_EXEC\n\t\t    CLEAR_FIELD(cookie);\n\t\t    cookie.sourcing_lnum = iptr->isn_lnum - 1;\n\t\t    res = do_cmdline(subs->subs_cmd,\n\t\t\t\tgetsourceline, &cookie,\n\t\t\t\t   DOCMD_VERBOSE|DOCMD_NOWAIT|DOCMD_KEYTYPED);\n\t\t    substitute_instr = save_instr;\n\n\t\t    if (res == FAIL || did_emsg\n\t\t\t\t\t     || subs_instr.subs_status == FAIL)\n\t\t\tgoto on_error;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_FINISH:\n\t\tgoto done;\n\n\t    case ISN_REDIRSTART:\n\t\t// create a dummy entry for var_redir_str()\n\t\tif (alloc_redir_lval() == FAIL)\n\t\t    goto on_error;\n\n\t\t// The output is stored in growarray \"redir_ga\" until\n\t\t// redirection ends.\n\t\tinit_redir_ga();\n\t\tredir_vname = 1;\n\t\tbreak;\n\n\t    case ISN_REDIREND:\n\t\t{\n\t\t    char_u *res = get_clear_redir_ga();\n\n\t\t    // End redirection, put redirected text on the stack.\n\t\t    clear_redir_lval();\n\t\t    redir_vname = 0;\n\n\t\t    if (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t    {\n\t\t\tvim_free(res);\n\t\t\tgoto theend;\n\t\t    }\n\t\t    tv = STACK_TV_BOT(0);\n\t\t    tv->v_type = VAR_STRING;\n\t\t    tv->vval.v_string = res;\n\t\t    ++ectx->ec_stack.ga_len;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_CEXPR_AUCMD:\n#ifdef FEAT_QUICKFIX\n\t\tif (trigger_cexpr_autocmd(iptr->isn_arg.number) == FAIL)\n\t\t    goto on_error;\n#endif\n\t\tbreak;\n\n\t    case ISN_CEXPR_CORE:\n#ifdef FEAT_QUICKFIX\n\t\t{\n\t\t    exarg_T ea;\n\t\t    int\t    res;\n\n\t\t    CLEAR_FIELD(ea);\n\t\t    ea.cmdidx = iptr->isn_arg.cexpr.cexpr_ref->cer_cmdidx;\n\t\t    ea.forceit = iptr->isn_arg.cexpr.cexpr_ref->cer_forceit;\n\t\t    ea.cmdlinep = &iptr->isn_arg.cexpr.cexpr_ref->cer_cmdline;\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    tv = STACK_TV_BOT(0);\n\t\t    res = cexpr_core(&ea, tv);\n\t\t    clear_tv(tv);\n\t\t    if (res == FAIL)\n\t\t\tgoto on_error;\n\t\t}\n#endif\n\t\tbreak;\n\n\t    // execute Ex command from pieces on the stack\n\t    case ISN_EXECCONCAT:\n\t\t{\n\t\t    int\t    count = iptr->isn_arg.number;\n\t\t    size_t  len = 0;\n\t\t    int\t    pass;\n\t\t    int\t    i;\n\t\t    char_u  *cmd = NULL;\n\t\t    char_u  *str;\n\n\t\t    for (pass = 1; pass <= 2; ++pass)\n\t\t    {\n\t\t\tfor (i = 0; i < count; ++i)\n\t\t\t{\n\t\t\t    tv = STACK_TV_BOT(i - count);\n\t\t\t    str = tv->vval.v_string;\n\t\t\t    if (str != NULL && *str != NUL)\n\t\t\t    {\n\t\t\t\tif (pass == 2)\n\t\t\t\t    STRCPY(cmd + len, str);\n\t\t\t\tlen += STRLEN(str);\n\t\t\t    }\n\t\t\t    if (pass == 2)\n\t\t\t\tclear_tv(tv);\n\t\t\t}\n\t\t\tif (pass == 1)\n\t\t\t{\n\t\t\t    cmd = alloc(len + 1);\n\t\t\t    if (unlikely(cmd == NULL))\n\t\t\t\tgoto theend;\n\t\t\t    len = 0;\n\t\t\t}\n\t\t    }\n\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    do_cmdline_cmd(cmd);\n\t\t    vim_free(cmd);\n\t\t}\n\t\tbreak;\n\n\t    // execute :echo {string} ...\n\t    case ISN_ECHO:\n\t\t{\n\t\t    int count = iptr->isn_arg.echo.echo_count;\n\t\t    int\tatstart = TRUE;\n\t\t    int needclr = TRUE;\n\t\t    int\tidx;\n\n\t\t    for (idx = 0; idx < count; ++idx)\n\t\t    {\n\t\t\ttv = STACK_TV_BOT(idx - count);\n\t\t\techo_one(tv, iptr->isn_arg.echo.echo_with_white,\n\t\t\t\t\t\t\t   &atstart, &needclr);\n\t\t\tclear_tv(tv);\n\t\t    }\n\t\t    if (needclr)\n\t\t\tmsg_clr_eos();\n\t\t    ectx->ec_stack.ga_len -= count;\n\t\t}\n\t\tbreak;\n\n\t    // :execute {string} ...\n\t    // :echomsg {string} ...\n\t    // :echoconsole {string} ...\n\t    // :echoerr {string} ...\n\t    case ISN_EXECUTE:\n\t    case ISN_ECHOMSG:\n\t    case ISN_ECHOCONSOLE:\n\t    case ISN_ECHOERR:\n\t\t{\n\t\t    int\t\tcount = iptr->isn_arg.number;\n\t\t    garray_T\tga;\n\t\t    char_u\tbuf[NUMBUFLEN];\n\t\t    char_u\t*p;\n\t\t    int\t\tlen;\n\t\t    int\t\tfailed = FALSE;\n\t\t    int\t\tidx;\n\n\t\t    ga_init2(&ga, 1, 80);\n\t\t    for (idx = 0; idx < count; ++idx)\n\t\t    {\n\t\t\ttv = STACK_TV_BOT(idx - count);\n\t\t\tif (iptr->isn_type == ISN_EXECUTE)\n\t\t\t{\n\t\t\t    if (tv->v_type == VAR_CHANNEL\n\t\t\t\t\t\t      || tv->v_type == VAR_JOB)\n\t\t\t    {\n\t\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\t\tsemsg(_(e_using_invalid_value_as_string_str),\n\t\t\t\t\t\t    vartype_name(tv->v_type));\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t    else\n\t\t\t\tp = tv_get_string_buf(tv, buf);\n\t\t\t}\n\t\t\telse\n\t\t\t    p = tv_stringify(tv, buf);\n\n\t\t\tlen = (int)STRLEN(p);\n\t\t\tif (GA_GROW_FAILS(&ga, len + 2))\n\t\t\t    failed = TRUE;\n\t\t\telse\n\t\t\t{\n\t\t\t    if (ga.ga_len > 0)\n\t\t\t\t((char_u *)(ga.ga_data))[ga.ga_len++] = ' ';\n\t\t\t    STRCPY((char_u *)(ga.ga_data) + ga.ga_len, p);\n\t\t\t    ga.ga_len += len;\n\t\t\t}\n\t\t\tclear_tv(tv);\n\t\t    }\n\t\t    ectx->ec_stack.ga_len -= count;\n\t\t    if (failed)\n\t\t    {\n\t\t\tga_clear(&ga);\n\t\t\tgoto on_error;\n\t\t    }\n\n\t\t    if (ga.ga_data != NULL)\n\t\t    {\n\t\t\tif (iptr->isn_type == ISN_EXECUTE)\n\t\t\t{\n\t\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t\t    do_cmdline_cmd((char_u *)ga.ga_data);\n\t\t\t    if (did_emsg)\n\t\t\t    {\n\t\t\t\tga_clear(&ga);\n\t\t\t\tgoto on_error;\n\t\t\t    }\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    msg_sb_eol();\n\t\t\t    if (iptr->isn_type == ISN_ECHOMSG)\n\t\t\t    {\n\t\t\t\tmsg_attr(ga.ga_data, echo_attr);\n\t\t\t\tout_flush();\n\t\t\t    }\n\t\t\t    else if (iptr->isn_type == ISN_ECHOCONSOLE)\n\t\t\t    {\n\t\t\t\tui_write(ga.ga_data, (int)STRLEN(ga.ga_data),\n\t\t\t\t\t\t\t\t\t TRUE);\n\t\t\t\tui_write((char_u *)\"\\r\\n\", 2, TRUE);\n\t\t\t    }\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\t\temsg(ga.ga_data);\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    ga_clear(&ga);\n\t\t}\n\t\tbreak;\n\n\t    // load local variable or argument\n\t    case ISN_LOAD:\n\t\tif (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t    goto theend;\n\t\tcopy_tv(STACK_TV_VAR(iptr->isn_arg.number), STACK_TV_BOT(0));\n\t\t++ectx->ec_stack.ga_len;\n\t\tbreak;\n\n\t    // load v: variable\n\t    case ISN_LOADV:\n\t\tif (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t    goto theend;\n\t\tcopy_tv(get_vim_var_tv(iptr->isn_arg.number), STACK_TV_BOT(0));\n\t\t++ectx->ec_stack.ga_len;\n\t\tbreak;\n\n\t    // load s: variable in Vim9 script\n\t    case ISN_LOADSCRIPT:\n\t\t{\n\t\t    scriptref_T\t*sref = iptr->isn_arg.script.scriptref;\n\t\t    svar_T\t *sv;\n\n\t\t    sv = get_script_svar(sref, ectx->ec_dfunc_idx);\n\t\t    if (sv == NULL)\n\t\t\tgoto theend;\n\t\t    allocate_if_null(sv->sv_tv);\n\t\t    if (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\tgoto theend;\n\t\t    copy_tv(sv->sv_tv, STACK_TV_BOT(0));\n\t\t    ++ectx->ec_stack.ga_len;\n\t\t}\n\t\tbreak;\n\n\t    // load s: variable in old script\n\t    case ISN_LOADS:\n\t\t{\n\t\t    hashtab_T\t*ht = &SCRIPT_VARS(\n\t\t\t\t\t       iptr->isn_arg.loadstore.ls_sid);\n\t\t    char_u\t*name = iptr->isn_arg.loadstore.ls_name;\n\t\t    dictitem_T\t*di = find_var_in_ht(ht, 0, name, TRUE);\n\n\t\t    if (di == NULL)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tsemsg(_(e_undefined_variable_str), name);\n\t\t\tgoto on_error;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\t    goto theend;\n\t\t\tcopy_tv(&di->di_tv, STACK_TV_BOT(0));\n\t\t\t++ectx->ec_stack.ga_len;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    // load g:/b:/w:/t: variable\n\t    case ISN_LOADG:\n\t    case ISN_LOADB:\n\t    case ISN_LOADW:\n\t    case ISN_LOADT:\n\t\t{\n\t\t    dictitem_T *di = NULL;\n\t\t    hashtab_T *ht = NULL;\n\t\t    char namespace;\n\n\t\t    switch (iptr->isn_type)\n\t\t    {\n\t\t\tcase ISN_LOADG:\n\t\t\t    ht = get_globvar_ht();\n\t\t\t    namespace = 'g';\n\t\t\t    break;\n\t\t\tcase ISN_LOADB:\n\t\t\t    ht = &curbuf->b_vars->dv_hashtab;\n\t\t\t    namespace = 'b';\n\t\t\t    break;\n\t\t\tcase ISN_LOADW:\n\t\t\t    ht = &curwin->w_vars->dv_hashtab;\n\t\t\t    namespace = 'w';\n\t\t\t    break;\n\t\t\tcase ISN_LOADT:\n\t\t\t    ht = &curtab->tp_vars->dv_hashtab;\n\t\t\t    namespace = 't';\n\t\t\t    break;\n\t\t\tdefault:  // Cannot reach here\n\t\t\t    goto theend;\n\t\t    }\n\t\t    di = find_var_in_ht(ht, 0, iptr->isn_arg.string, TRUE);\n\n\t\t    if (di == NULL)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tsemsg(_(e_undefined_variable_char_str),\n\t\t\t\t\t     namespace, iptr->isn_arg.string);\n\t\t\tgoto on_error;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\t    goto theend;\n\t\t\tcopy_tv(&di->di_tv, STACK_TV_BOT(0));\n\t\t\t++ectx->ec_stack.ga_len;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    // load autoload variable\n\t    case ISN_LOADAUTO:\n\t\t{\n\t\t    char_u *name = iptr->isn_arg.string;\n\n\t\t    if (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\tgoto theend;\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    if (eval_variable(name, (int)STRLEN(name), 0,\n\t\t\t      STACK_TV_BOT(0), NULL, EVAL_VAR_VERBOSE) == FAIL)\n\t\t\tgoto on_error;\n\t\t    ++ectx->ec_stack.ga_len;\n\t\t}\n\t\tbreak;\n\n\t    // load g:/b:/w:/t: namespace\n\t    case ISN_LOADGDICT:\n\t    case ISN_LOADBDICT:\n\t    case ISN_LOADWDICT:\n\t    case ISN_LOADTDICT:\n\t\t{\n\t\t    dict_T *d = NULL;\n\n\t\t    switch (iptr->isn_type)\n\t\t    {\n\t\t\tcase ISN_LOADGDICT: d = get_globvar_dict(); break;\n\t\t\tcase ISN_LOADBDICT: d = curbuf->b_vars; break;\n\t\t\tcase ISN_LOADWDICT: d = curwin->w_vars; break;\n\t\t\tcase ISN_LOADTDICT: d = curtab->tp_vars; break;\n\t\t\tdefault:  // Cannot reach here\n\t\t\t    goto theend;\n\t\t    }\n\t\t    if (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\tgoto theend;\n\t\t    tv = STACK_TV_BOT(0);\n\t\t    tv->v_type = VAR_DICT;\n\t\t    tv->v_lock = 0;\n\t\t    tv->vval.v_dict = d;\n\t\t    ++d->dv_refcount;\n\t\t    ++ectx->ec_stack.ga_len;\n\t\t}\n\t\tbreak;\n\n\t    // load &option\n\t    case ISN_LOADOPT:\n\t\t{\n\t\t    typval_T\toptval;\n\t\t    char_u\t*name = iptr->isn_arg.string;\n\n\t\t    // This is not expected to fail, name is checked during\n\t\t    // compilation: don't set SOURCING_LNUM.\n\t\t    if (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\tgoto theend;\n\t\t    if (eval_option(&name, &optval, TRUE) == FAIL)\n\t\t\tgoto theend;\n\t\t    *STACK_TV_BOT(0) = optval;\n\t\t    ++ectx->ec_stack.ga_len;\n\t\t}\n\t\tbreak;\n\n\t    // load $ENV\n\t    case ISN_LOADENV:\n\t\t{\n\t\t    typval_T\toptval;\n\t\t    char_u\t*name = iptr->isn_arg.string;\n\n\t\t    if (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\tgoto theend;\n\t\t    // name is always valid, checked when compiling\n\t\t    (void)eval_env_var(&name, &optval, TRUE);\n\t\t    *STACK_TV_BOT(0) = optval;\n\t\t    ++ectx->ec_stack.ga_len;\n\t\t}\n\t\tbreak;\n\n\t    // load @register\n\t    case ISN_LOADREG:\n\t\tif (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t    goto theend;\n\t\ttv = STACK_TV_BOT(0);\n\t\ttv->v_type = VAR_STRING;\n\t\ttv->v_lock = 0;\n\t\t// This may result in NULL, which should be equivalent to an\n\t\t// empty string.\n\t\ttv->vval.v_string = get_reg_contents(\n\t\t\t\t\t  iptr->isn_arg.number, GREG_EXPR_SRC);\n\t\t++ectx->ec_stack.ga_len;\n\t\tbreak;\n\n\t    // store local variable\n\t    case ISN_STORE:\n\t\t--ectx->ec_stack.ga_len;\n\t\ttv = STACK_TV_VAR(iptr->isn_arg.number);\n\t\tclear_tv(tv);\n\t\t*tv = *STACK_TV_BOT(0);\n\t\tbreak;\n\n\t    // store s: variable in old script\n\t    case ISN_STORES:\n\t\t{\n\t\t    hashtab_T\t*ht = &SCRIPT_VARS(\n\t\t\t\t\t       iptr->isn_arg.loadstore.ls_sid);\n\t\t    char_u\t*name = iptr->isn_arg.loadstore.ls_name;\n\t\t    dictitem_T\t*di = find_var_in_ht(ht, 0, name + 2, TRUE);\n\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    if (di == NULL)\n\t\t\tstore_var(name, STACK_TV_BOT(0));\n\t\t    else\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tif (var_check_permission(di, name) == FAIL)\n\t\t\t{\n\t\t\t    clear_tv(STACK_TV_BOT(0));\n\t\t\t    goto on_error;\n\t\t\t}\n\t\t\tclear_tv(&di->di_tv);\n\t\t\tdi->di_tv = *STACK_TV_BOT(0);\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    // store script-local variable in Vim9 script\n\t    case ISN_STORESCRIPT:\n\t\t{\n\t\t    scriptref_T\t    *sref = iptr->isn_arg.script.scriptref;\n\t\t    svar_T\t    *sv;\n\n\t\t    sv = get_script_svar(sref, ectx->ec_dfunc_idx);\n\t\t    if (sv == NULL)\n\t\t\tgoto theend;\n\t\t    --ectx->ec_stack.ga_len;\n\n\t\t    // \"const\" and \"final\" are checked at compile time, locking\n\t\t    // the value needs to be checked here.\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    if (value_check_lock(sv->sv_tv->v_lock, sv->sv_name, FALSE))\n\t\t    {\n\t\t\tclear_tv(STACK_TV_BOT(0));\n\t\t\tgoto on_error;\n\t\t    }\n\n\t\t    clear_tv(sv->sv_tv);\n\t\t    *sv->sv_tv = *STACK_TV_BOT(0);\n\t\t}\n\t\tbreak;\n\n\t    // store option\n\t    case ISN_STOREOPT:\n\t    case ISN_STOREFUNCOPT:\n\t\t{\n\t\t    char_u\t*opt_name = iptr->isn_arg.storeopt.so_name;\n\t\t    int\t\topt_flags = iptr->isn_arg.storeopt.so_flags;\n\t\t    long\tn = 0;\n\t\t    char_u\t*s = NULL;\n\t\t    char\t*msg;\n\t\t    char_u\tnumbuf[NUMBUFLEN];\n\t\t    char_u\t*tofree = NULL;\n\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    tv = STACK_TV_BOT(0);\n\t\t    if (tv->v_type == VAR_STRING)\n\t\t    {\n\t\t\ts = tv->vval.v_string;\n\t\t\tif (s == NULL)\n\t\t\t    s = (char_u *)\"\";\n\t\t    }\n\t\t    else if (iptr->isn_type == ISN_STOREFUNCOPT)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\t// If the option can be set to a function reference or\n\t\t\t// a lambda and the passed value is a function\n\t\t\t// reference, then convert it to the name (string) of\n\t\t\t// the function reference.\n\t\t\ts = tv2string(tv, &tofree, numbuf, 0);\n\t\t\tif (s == NULL || *s == NUL)\n\t\t\t{\n\t\t\t    clear_tv(tv);\n\t\t\t    goto on_error;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t\t// must be VAR_NUMBER, CHECKTYPE makes sure\n\t\t\tn = tv->vval.v_number;\n\t\t    msg = set_option_value(opt_name, n, s, opt_flags);\n\t\t    clear_tv(tv);\n\t\t    vim_free(tofree);\n\t\t    if (msg != NULL)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\temsg(_(msg));\n\t\t\tgoto on_error;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    // store $ENV\n\t    case ISN_STOREENV:\n\t\t--ectx->ec_stack.ga_len;\n\t\ttv = STACK_TV_BOT(0);\n\t\tvim_setenv_ext(iptr->isn_arg.string, tv_get_string(tv));\n\t\tclear_tv(tv);\n\t\tbreak;\n\n\t    // store @r\n\t    case ISN_STOREREG:\n\t\t{\n\t\t    int\treg = iptr->isn_arg.number;\n\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    tv = STACK_TV_BOT(0);\n\t\t    write_reg_contents(reg, tv_get_string(tv), -1, FALSE);\n\t\t    clear_tv(tv);\n\t\t}\n\t\tbreak;\n\n\t    // store v: variable\n\t    case ISN_STOREV:\n\t\t--ectx->ec_stack.ga_len;\n\t\tif (set_vim_var_tv(iptr->isn_arg.number, STACK_TV_BOT(0))\n\t\t\t\t\t\t\t\t       == FAIL)\n\t\t    // should not happen, type is checked when compiling\n\t\t    goto on_error;\n\t\tbreak;\n\n\t    // store g:/b:/w:/t: variable\n\t    case ISN_STOREG:\n\t    case ISN_STOREB:\n\t    case ISN_STOREW:\n\t    case ISN_STORET:\n\t\t{\n\t\t    dictitem_T\t*di;\n\t\t    hashtab_T\t*ht;\n\t\t    char_u\t*name = iptr->isn_arg.string + 2;\n\n\t\t    switch (iptr->isn_type)\n\t\t    {\n\t\t\tcase ISN_STOREG:\n\t\t\t    ht = get_globvar_ht();\n\t\t\t    break;\n\t\t\tcase ISN_STOREB:\n\t\t\t    ht = &curbuf->b_vars->dv_hashtab;\n\t\t\t    break;\n\t\t\tcase ISN_STOREW:\n\t\t\t    ht = &curwin->w_vars->dv_hashtab;\n\t\t\t    break;\n\t\t\tcase ISN_STORET:\n\t\t\t    ht = &curtab->tp_vars->dv_hashtab;\n\t\t\t    break;\n\t\t\tdefault:  // Cannot reach here\n\t\t\t    goto theend;\n\t\t    }\n\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    di = find_var_in_ht(ht, 0, name, TRUE);\n\t\t    if (di == NULL)\n\t\t\tstore_var(iptr->isn_arg.string, STACK_TV_BOT(0));\n\t\t    else\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tif (var_check_permission(di, name) == FAIL)\n\t\t\t    goto on_error;\n\t\t\tclear_tv(&di->di_tv);\n\t\t\tdi->di_tv = *STACK_TV_BOT(0);\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    // store an autoload variable\n\t    case ISN_STOREAUTO:\n\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\tset_var(iptr->isn_arg.string, STACK_TV_BOT(-1), TRUE);\n\t\tclear_tv(STACK_TV_BOT(-1));\n\t\t--ectx->ec_stack.ga_len;\n\t\tbreak;\n\n\t    // store number in local variable\n\t    case ISN_STORENR:\n\t\ttv = STACK_TV_VAR(iptr->isn_arg.storenr.stnr_idx);\n\t\tclear_tv(tv);\n\t\ttv->v_type = VAR_NUMBER;\n\t\ttv->vval.v_number = iptr->isn_arg.storenr.stnr_val;\n\t\tbreak;\n\n\t    // store value in list or dict variable\n\t    case ISN_STOREINDEX:\n\t\t{\n\t\t    vartype_T\tdest_type = iptr->isn_arg.vartype;\n\t\t    typval_T\t*tv_idx = STACK_TV_BOT(-2);\n\t\t    typval_T\t*tv_dest = STACK_TV_BOT(-1);\n\t\t    int\t\tstatus = OK;\n\n\t\t    // Stack contains:\n\t\t    // -3 value to be stored\n\t\t    // -2 index\n\t\t    // -1 dict or list\n\t\t    tv = STACK_TV_BOT(-3);\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    if (dest_type == VAR_ANY)\n\t\t    {\n\t\t\tdest_type = tv_dest->v_type;\n\t\t\tif (dest_type == VAR_DICT)\n\t\t\t    status = do_2string(tv_idx, TRUE, FALSE);\n\t\t\telse if (dest_type == VAR_LIST\n\t\t\t\t\t       && tv_idx->v_type != VAR_NUMBER)\n\t\t\t{\n\t\t\t    emsg(_(e_number_expected));\n\t\t\t    status = FAIL;\n\t\t\t}\n\t\t    }\n\t\t    else if (dest_type != tv_dest->v_type)\n\t\t    {\n\t\t\t// just in case, should be OK\n\t\t\tsemsg(_(e_expected_str_but_got_str),\n\t\t\t\t    vartype_name(dest_type),\n\t\t\t\t    vartype_name(tv_dest->v_type));\n\t\t\tstatus = FAIL;\n\t\t    }\n\n\t\t    if (status == OK && dest_type == VAR_LIST)\n\t\t    {\n\t\t\tlong\t    lidx = (long)tv_idx->vval.v_number;\n\t\t\tlist_T\t    *list = tv_dest->vval.v_list;\n\n\t\t\tif (list == NULL)\n\t\t\t{\n\t\t\t    emsg(_(e_list_not_set));\n\t\t\t    goto on_error;\n\t\t\t}\n\t\t\tif (lidx < 0 && list->lv_len + lidx >= 0)\n\t\t\t    // negative index is relative to the end\n\t\t\t    lidx = list->lv_len + lidx;\n\t\t\tif (lidx < 0 || lidx > list->lv_len)\n\t\t\t{\n\t\t\t    semsg(_(e_list_index_out_of_range_nr), lidx);\n\t\t\t    goto on_error;\n\t\t\t}\n\t\t\tif (lidx < list->lv_len)\n\t\t\t{\n\t\t\t    listitem_T *li = list_find(list, lidx);\n\n\t\t\t    if (error_if_locked(li->li_tv.v_lock,\n\t\t\t\t\t\t    e_cannot_change_list_item))\n\t\t\t\tgoto on_error;\n\t\t\t    // overwrite existing list item\n\t\t\t    clear_tv(&li->li_tv);\n\t\t\t    li->li_tv = *tv;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    if (error_if_locked(list->lv_lock,\n\t\t\t\t\t\t\t e_cannot_change_list))\n\t\t\t\tgoto on_error;\n\t\t\t    // append to list, only fails when out of memory\n\t\t\t    if (list_append_tv(list, tv) == FAIL)\n\t\t\t\tgoto theend;\n\t\t\t    clear_tv(tv);\n\t\t\t}\n\t\t    }\n\t\t    else if (status == OK && dest_type == VAR_DICT)\n\t\t    {\n\t\t\tchar_u\t\t*key = tv_idx->vval.v_string;\n\t\t\tdict_T\t\t*dict = tv_dest->vval.v_dict;\n\t\t\tdictitem_T\t*di;\n\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tif (dict == NULL)\n\t\t\t{\n\t\t\t    emsg(_(e_dictionary_not_set));\n\t\t\t    goto on_error;\n\t\t\t}\n\t\t\tif (key == NULL)\n\t\t\t    key = (char_u *)\"\";\n\t\t\tdi = dict_find(dict, key, -1);\n\t\t\tif (di != NULL)\n\t\t\t{\n\t\t\t    if (error_if_locked(di->di_tv.v_lock,\n\t\t\t\t\t\t    e_cannot_change_dict_item))\n\t\t\t\tgoto on_error;\n\t\t\t    // overwrite existing value\n\t\t\t    clear_tv(&di->di_tv);\n\t\t\t    di->di_tv = *tv;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    if (error_if_locked(dict->dv_lock,\n\t\t\t\t\t\t\t e_cannot_change_dict))\n\t\t\t\tgoto on_error;\n\t\t\t    // add to dict, only fails when out of memory\n\t\t\t    if (dict_add_tv(dict, (char *)key, tv) == FAIL)\n\t\t\t\tgoto theend;\n\t\t\t    clear_tv(tv);\n\t\t\t}\n\t\t    }\n\t\t    else if (status == OK && dest_type == VAR_BLOB)\n\t\t    {\n\t\t\tlong\t    lidx = (long)tv_idx->vval.v_number;\n\t\t\tblob_T\t    *blob = tv_dest->vval.v_blob;\n\t\t\tvarnumber_T nr;\n\t\t\tint\t    error = FALSE;\n\t\t\tint\t    len;\n\n\t\t\tif (blob == NULL)\n\t\t\t{\n\t\t\t    emsg(_(e_blob_not_set));\n\t\t\t    goto on_error;\n\t\t\t}\n\t\t\tlen = blob_len(blob);\n\t\t\tif (lidx < 0 && len + lidx >= 0)\n\t\t\t    // negative index is relative to the end\n\t\t\t    lidx = len + lidx;\n\n\t\t\t// Can add one byte at the end.\n\t\t\tif (lidx < 0 || lidx > len)\n\t\t\t{\n\t\t\t    semsg(_(e_blob_index_out_of_range_nr), lidx);\n\t\t\t    goto on_error;\n\t\t\t}\n\t\t\tif (value_check_lock(blob->bv_lock,\n\t\t\t\t\t\t      (char_u *)\"blob\", FALSE))\n\t\t\t    goto on_error;\n\t\t\tnr = tv_get_number_chk(tv, &error);\n\t\t\tif (error)\n\t\t\t    goto on_error;\n\t\t\tblob_set_append(blob, lidx, nr);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tstatus = FAIL;\n\t\t\tsemsg(_(e_cannot_index_str), vartype_name(dest_type));\n\t\t    }\n\n\t\t    clear_tv(tv_idx);\n\t\t    clear_tv(tv_dest);\n\t\t    ectx->ec_stack.ga_len -= 3;\n\t\t    if (status == FAIL)\n\t\t    {\n\t\t\tclear_tv(tv);\n\t\t\tgoto on_error;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    // store value in blob range\n\t    case ISN_STORERANGE:\n\t\t{\n\t\t    typval_T\t*tv_idx1 = STACK_TV_BOT(-3);\n\t\t    typval_T\t*tv_idx2 = STACK_TV_BOT(-2);\n\t\t    typval_T\t*tv_dest = STACK_TV_BOT(-1);\n\t\t    int\t\tstatus = OK;\n\n\t\t    // Stack contains:\n\t\t    // -4 value to be stored\n\t\t    // -3 first index or \"none\"\n\t\t    // -2 second index or \"none\"\n\t\t    // -1 destination list or blob\n\t\t    tv = STACK_TV_BOT(-4);\n\t\t    if (tv_dest->v_type == VAR_LIST)\n\t\t    {\n\t\t\tlong\tn1;\n\t\t\tlong\tn2;\n\t\t\tint\terror = FALSE;\n\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tn1 = (long)tv_get_number_chk(tv_idx1, &error);\n\t\t\tif (error)\n\t\t\t    status = FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t    if (tv_idx2->v_type == VAR_SPECIAL\n\t\t\t\t\t&& tv_idx2->vval.v_number == VVAL_NONE)\n\t\t\t\tn2 = list_len(tv_dest->vval.v_list) - 1;\n\t\t\t    else\n\t\t\t\tn2 = (long)tv_get_number_chk(tv_idx2, &error);\n\t\t\t    if (error)\n\t\t\t\tstatus = FAIL;\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tlistitem_T *li1 = check_range_index_one(\n\t\t\t\t\ttv_dest->vval.v_list, &n1, FALSE);\n\n\t\t\t\tif (li1 == NULL)\n\t\t\t\t    status = FAIL;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t    status = check_range_index_two(\n\t\t\t\t\t    tv_dest->vval.v_list,\n\t\t\t\t\t    &n1, li1, &n2, FALSE);\n\t\t\t\t    if (status != FAIL)\n\t\t\t\t\tstatus = list_assign_range(\n\t\t\t\t\t\ttv_dest->vval.v_list,\n\t\t\t\t\t\ttv->vval.v_list,\n\t\t\t\t\t\tn1,\n\t\t\t\t\t\tn2,\n\t\t\t\t\t\ttv_idx2->v_type == VAR_SPECIAL,\n\t\t\t\t\t\t(char_u *)\"=\",\n\t\t\t\t\t\t(char_u *)\"[unknown]\");\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    else if (tv_dest->v_type == VAR_BLOB)\n\t\t    {\n\t\t\tvarnumber_T n1;\n\t\t\tvarnumber_T n2;\n\t\t\tint\t    error = FALSE;\n\n\t\t\tn1 = tv_get_number_chk(tv_idx1, &error);\n\t\t\tif (error)\n\t\t\t    status = FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t    if (tv_idx2->v_type == VAR_SPECIAL\n\t\t\t\t\t&& tv_idx2->vval.v_number == VVAL_NONE)\n\t\t\t\tn2 = blob_len(tv_dest->vval.v_blob) - 1;\n\t\t\t    else\n\t\t\t\tn2 = tv_get_number_chk(tv_idx2, &error);\n\t\t\t    if (error)\n\t\t\t\tstatus = FAIL;\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tlong  bloblen = blob_len(tv_dest->vval.v_blob);\n\n\t\t\t\tif (check_blob_index(bloblen,\n\t\t\t\t\t\t\t     n1, FALSE) == FAIL\n\t\t\t\t\t|| check_blob_range(bloblen,\n\t\t\t\t\t\t\tn1, n2, FALSE) == FAIL)\n\t\t\t\t    status = FAIL;\n\t\t\t\telse\n\t\t\t\t    status = blob_set_range(\n\t\t\t\t\t     tv_dest->vval.v_blob, n1, n2, tv);\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tstatus = FAIL;\n\t\t\temsg(_(e_blob_required));\n\t\t    }\n\n\t\t    clear_tv(tv_idx1);\n\t\t    clear_tv(tv_idx2);\n\t\t    clear_tv(tv_dest);\n\t\t    ectx->ec_stack.ga_len -= 4;\n\t\t    clear_tv(tv);\n\n\t\t    if (status == FAIL)\n\t\t\tgoto on_error;\n\t\t}\n\t\tbreak;\n\n\t    // load or store variable or argument from outer scope\n\t    case ISN_LOADOUTER:\n\t    case ISN_STOREOUTER:\n\t\t{\n\t\t    int\t\tdepth = iptr->isn_arg.outer.outer_depth;\n\t\t    outer_T\t*outer = ectx->ec_outer_ref == NULL ? NULL\n\t\t\t\t\t\t: ectx->ec_outer_ref->or_outer;\n\n\t\t    while (depth > 1 && outer != NULL)\n\t\t    {\n\t\t\touter = outer->out_up;\n\t\t\t--depth;\n\t\t    }\n\t\t    if (outer == NULL)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tif (ectx->ec_frame_idx == ectx->ec_initial_frame_idx\n\t\t\t\t\t\t || ectx->ec_outer_ref == NULL)\n\t\t\t    // Possibly :def function called from legacy\n\t\t\t    // context.\n\t\t\t    emsg(_(e_closure_called_from_invalid_context));\n\t\t\telse\n\t\t\t    iemsg(\"LOADOUTER depth more than scope levels\");\n\t\t\tgoto theend;\n\t\t    }\n\t\t    tv = ((typval_T *)outer->out_stack->ga_data)\n\t\t\t\t    + outer->out_frame_idx + STACK_FRAME_SIZE\n\t\t\t\t    + iptr->isn_arg.outer.outer_idx;\n\t\t    if (iptr->isn_type == ISN_LOADOUTER)\n\t\t    {\n\t\t\tif (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\t    goto theend;\n\t\t\tcopy_tv(tv, STACK_TV_BOT(0));\n\t\t\t++ectx->ec_stack.ga_len;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t--ectx->ec_stack.ga_len;\n\t\t\tclear_tv(tv);\n\t\t\t*tv = *STACK_TV_BOT(0);\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    // unlet item in list or dict variable\n\t    case ISN_UNLETINDEX:\n\t\t{\n\t\t    typval_T\t*tv_idx = STACK_TV_BOT(-2);\n\t\t    typval_T\t*tv_dest = STACK_TV_BOT(-1);\n\t\t    int\t\tstatus = OK;\n\n\t\t    // Stack contains:\n\t\t    // -2 index\n\t\t    // -1 dict or list\n\t\t    if (tv_dest->v_type == VAR_DICT)\n\t\t    {\n\t\t\t// unlet a dict item, index must be a string\n\t\t\tif (tv_idx->v_type != VAR_STRING)\n\t\t\t{\n\t\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t\t    semsg(_(e_expected_str_but_got_str),\n\t\t\t\t\tvartype_name(VAR_STRING),\n\t\t\t\t\tvartype_name(tv_idx->v_type));\n\t\t\t    status = FAIL;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    dict_T\t*d = tv_dest->vval.v_dict;\n\t\t\t    char_u\t*key = tv_idx->vval.v_string;\n\t\t\t    dictitem_T  *di = NULL;\n\n\t\t\t    if (d != NULL && value_check_lock(\n\t\t\t\t\t\t      d->dv_lock, NULL, FALSE))\n\t\t\t\tstatus = FAIL;\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\t\tif (key == NULL)\n\t\t\t\t    key = (char_u *)\"\";\n\t\t\t\tif (d != NULL)\n\t\t\t\t    di = dict_find(d, key, (int)STRLEN(key));\n\t\t\t\tif (di == NULL)\n\t\t\t\t{\n\t\t\t\t    // NULL dict is equivalent to empty dict\n\t\t\t\t    semsg(_(e_key_not_present_in_dictionary), key);\n\t\t\t\t    status = FAIL;\n\t\t\t\t}\n\t\t\t\telse if (var_check_fixed(di->di_flags,\n\t\t\t\t\t\t\t\t   NULL, FALSE)\n\t\t\t\t\t|| var_check_ro(di->di_flags,\n\t\t\t\t\t\t\t\t  NULL, FALSE))\n\t\t\t\t    status = FAIL;\n\t\t\t\telse\n\t\t\t\t    dictitem_remove(d, di);\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    else if (tv_dest->v_type == VAR_LIST)\n\t\t    {\n\t\t\t// unlet a List item, index must be a number\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tif (check_for_number(tv_idx) == FAIL)\n\t\t\t{\n\t\t\t    status = FAIL;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    list_T\t*l = tv_dest->vval.v_list;\n\t\t\t    long\tn = (long)tv_idx->vval.v_number;\n\n\t\t\t    if (l != NULL && value_check_lock(\n\t\t\t\t\t\t      l->lv_lock, NULL, FALSE))\n\t\t\t\tstatus = FAIL;\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tlistitem_T\t*li = list_find(l, n);\n\n\t\t\t\tif (li == NULL)\n\t\t\t\t{\n\t\t\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t\t\t    semsg(_(e_list_index_out_of_range_nr), n);\n\t\t\t\t    status = FAIL;\n\t\t\t\t}\n\t\t\t\telse if (value_check_lock(li->li_tv.v_lock,\n\t\t\t\t\t\t\t\t  NULL, FALSE))\n\t\t\t\t    status = FAIL;\n\t\t\t\telse\n\t\t\t\t    listitem_remove(l, li);\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tstatus = FAIL;\n\t\t\tsemsg(_(e_cannot_index_str),\n\t\t\t\t\t\tvartype_name(tv_dest->v_type));\n\t\t    }\n\n\t\t    clear_tv(tv_idx);\n\t\t    clear_tv(tv_dest);\n\t\t    ectx->ec_stack.ga_len -= 2;\n\t\t    if (status == FAIL)\n\t\t\tgoto on_error;\n\t\t}\n\t\tbreak;\n\n\t    // unlet range of items in list variable\n\t    case ISN_UNLETRANGE:\n\t\t{\n\t\t    // Stack contains:\n\t\t    // -3 index1\n\t\t    // -2 index2\n\t\t    // -1 dict or list\n\t\t    typval_T\t*tv_idx1 = STACK_TV_BOT(-3);\n\t\t    typval_T\t*tv_idx2 = STACK_TV_BOT(-2);\n\t\t    typval_T\t*tv_dest = STACK_TV_BOT(-1);\n\t\t    int\t\tstatus = OK;\n\n\t\t    if (tv_dest->v_type == VAR_LIST)\n\t\t    {\n\t\t\t// indexes must be a number\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tif (check_for_number(tv_idx1) == FAIL\n\t\t\t\t|| (tv_idx2->v_type != VAR_SPECIAL\n\t\t\t\t\t && check_for_number(tv_idx2) == FAIL))\n\t\t\t{\n\t\t\t    status = FAIL;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    list_T\t*l = tv_dest->vval.v_list;\n\t\t\t    long\tn1 = (long)tv_idx1->vval.v_number;\n\t\t\t    long\tn2 = tv_idx2->v_type == VAR_SPECIAL\n\t\t\t\t\t    ? 0 : (long)tv_idx2->vval.v_number;\n\t\t\t    listitem_T\t*li;\n\n\t\t\t    li = list_find_index(l, &n1);\n\t\t\t    if (li == NULL)\n\t\t\t\tstatus = FAIL;\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tif (n1 < 0)\n\t\t\t\t    n1 = list_idx_of_item(l, li);\n\t\t\t\tif (n2 < 0)\n\t\t\t\t{\n\t\t\t\t    listitem_T *li2 = list_find(l, n2);\n\n\t\t\t\t    if (li2 == NULL)\n\t\t\t\t\tstatus = FAIL;\n\t\t\t\t    else\n\t\t\t\t\tn2 = list_idx_of_item(l, li2);\n\t\t\t\t}\n\t\t\t\tif (status != FAIL\n\t\t\t\t\t&& tv_idx2->v_type != VAR_SPECIAL\n\t\t\t\t\t&& n2 < n1)\n\t\t\t\t{\n\t\t\t\t    semsg(_(e_list_index_out_of_range_nr), n2);\n\t\t\t\t    status = FAIL;\n\t\t\t\t}\n\t\t\t\tif (status != FAIL\n\t\t\t\t\t&& list_unlet_range(l, li, NULL, n1,\n\t\t\t\t\t    tv_idx2->v_type != VAR_SPECIAL, n2)\n\t\t\t\t\t\t\t\t       == FAIL)\n\t\t\t\t    status = FAIL;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tstatus = FAIL;\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tsemsg(_(e_cannot_index_str),\n\t\t\t\t\t\tvartype_name(tv_dest->v_type));\n\t\t    }\n\n\t\t    clear_tv(tv_idx1);\n\t\t    clear_tv(tv_idx2);\n\t\t    clear_tv(tv_dest);\n\t\t    ectx->ec_stack.ga_len -= 3;\n\t\t    if (status == FAIL)\n\t\t\tgoto on_error;\n\t\t}\n\t\tbreak;\n\n\t    // push constant\n\t    case ISN_PUSHNR:\n\t    case ISN_PUSHBOOL:\n\t    case ISN_PUSHSPEC:\n\t    case ISN_PUSHF:\n\t    case ISN_PUSHS:\n\t    case ISN_PUSHBLOB:\n\t    case ISN_PUSHFUNC:\n\t    case ISN_PUSHCHANNEL:\n\t    case ISN_PUSHJOB:\n\t\tif (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t    goto theend;\n\t\ttv = STACK_TV_BOT(0);\n\t\ttv->v_lock = 0;\n\t\t++ectx->ec_stack.ga_len;\n\t\tswitch (iptr->isn_type)\n\t\t{\n\t\t    case ISN_PUSHNR:\n\t\t\ttv->v_type = VAR_NUMBER;\n\t\t\ttv->vval.v_number = iptr->isn_arg.number;\n\t\t\tbreak;\n\t\t    case ISN_PUSHBOOL:\n\t\t\ttv->v_type = VAR_BOOL;\n\t\t\ttv->vval.v_number = iptr->isn_arg.number;\n\t\t\tbreak;\n\t\t    case ISN_PUSHSPEC:\n\t\t\ttv->v_type = VAR_SPECIAL;\n\t\t\ttv->vval.v_number = iptr->isn_arg.number;\n\t\t\tbreak;\n#ifdef FEAT_FLOAT\n\t\t    case ISN_PUSHF:\n\t\t\ttv->v_type = VAR_FLOAT;\n\t\t\ttv->vval.v_float = iptr->isn_arg.fnumber;\n\t\t\tbreak;\n#endif\n\t\t    case ISN_PUSHBLOB:\n\t\t\tblob_copy(iptr->isn_arg.blob, tv);\n\t\t\tbreak;\n\t\t    case ISN_PUSHFUNC:\n\t\t\ttv->v_type = VAR_FUNC;\n\t\t\tif (iptr->isn_arg.string == NULL)\n\t\t\t    tv->vval.v_string = NULL;\n\t\t\telse\n\t\t\t    tv->vval.v_string =\n\t\t\t\t\t     vim_strsave(iptr->isn_arg.string);\n\t\t\tbreak;\n\t\t    case ISN_PUSHCHANNEL:\n#ifdef FEAT_JOB_CHANNEL\n\t\t\ttv->v_type = VAR_CHANNEL;\n\t\t\ttv->vval.v_channel = iptr->isn_arg.channel;\n\t\t\tif (tv->vval.v_channel != NULL)\n\t\t\t    ++tv->vval.v_channel->ch_refcount;\n#endif\n\t\t\tbreak;\n\t\t    case ISN_PUSHJOB:\n#ifdef FEAT_JOB_CHANNEL\n\t\t\ttv->v_type = VAR_JOB;\n\t\t\ttv->vval.v_job = iptr->isn_arg.job;\n\t\t\tif (tv->vval.v_job != NULL)\n\t\t\t    ++tv->vval.v_job->jv_refcount;\n#endif\n\t\t\tbreak;\n\t\t    default:\n\t\t\ttv->v_type = VAR_STRING;\n\t\t\ttv->vval.v_string = vim_strsave(\n\t\t\t\tiptr->isn_arg.string == NULL\n\t\t\t\t\t? (char_u *)\"\" : iptr->isn_arg.string);\n\t\t}\n\t\tbreak;\n\n\t    case ISN_UNLET:\n\t\tif (do_unlet(iptr->isn_arg.unlet.ul_name,\n\t\t\t\t       iptr->isn_arg.unlet.ul_forceit) == FAIL)\n\t\t    goto on_error;\n\t\tbreak;\n\t    case ISN_UNLETENV:\n\t\tvim_unsetenv(iptr->isn_arg.unlet.ul_name);\n\t\tbreak;\n\n\t    case ISN_LOCKUNLOCK:\n\t\t{\n\t\t    typval_T\t*lval_root_save = lval_root;\n\t\t    int\t\tres;\n\n\t\t    // Stack has the local variable, argument the whole :lock\n\t\t    // or :unlock command, like ISN_EXEC.\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    lval_root = STACK_TV_BOT(0);\n\t\t    res = exec_command(iptr);\n\t\t    clear_tv(lval_root);\n\t\t    lval_root = lval_root_save;\n\t\t    if (res == FAIL)\n\t\t\tgoto on_error;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_LOCKCONST:\n\t\titem_lock(STACK_TV_BOT(-1), 100, TRUE, TRUE);\n\t\tbreak;\n\n\t    // create a list from items on the stack; uses a single allocation\n\t    // for the list header and the items\n\t    case ISN_NEWLIST:\n\t\tif (exe_newlist(iptr->isn_arg.number, ectx) == FAIL)\n\t\t    goto theend;\n\t\tbreak;\n\n\t    // create a dict from items on the stack\n\t    case ISN_NEWDICT:\n\t\t{\n\t\t    int\t\tcount = iptr->isn_arg.number;\n\t\t    dict_T\t*dict = dict_alloc();\n\t\t    dictitem_T\t*item;\n\t\t    char_u\t*key;\n\t\t    int\t\tidx;\n\n\t\t    if (unlikely(dict == NULL))\n\t\t\tgoto theend;\n\t\t    for (idx = 0; idx < count; ++idx)\n\t\t    {\n\t\t\t// have already checked key type is VAR_STRING\n\t\t\ttv = STACK_TV_BOT(2 * (idx - count));\n\t\t\t// check key is unique\n\t\t\tkey = tv->vval.v_string == NULL\n\t\t\t\t\t    ? (char_u *)\"\" : tv->vval.v_string;\n\t\t\titem = dict_find(dict, key, -1);\n\t\t\tif (item != NULL)\n\t\t\t{\n\t\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t\t    semsg(_(e_duplicate_key_in_dicitonary), key);\n\t\t\t    dict_unref(dict);\n\t\t\t    goto on_error;\n\t\t\t}\n\t\t\titem = dictitem_alloc(key);\n\t\t\tclear_tv(tv);\n\t\t\tif (unlikely(item == NULL))\n\t\t\t{\n\t\t\t    dict_unref(dict);\n\t\t\t    goto theend;\n\t\t\t}\n\t\t\titem->di_tv = *STACK_TV_BOT(2 * (idx - count) + 1);\n\t\t\titem->di_tv.v_lock = 0;\n\t\t\tif (dict_add(dict, item) == FAIL)\n\t\t\t{\n\t\t\t    // can this ever happen?\n\t\t\t    dict_unref(dict);\n\t\t\t    goto theend;\n\t\t\t}\n\t\t    }\n\n\t\t    if (count > 0)\n\t\t\tectx->ec_stack.ga_len -= 2 * count - 1;\n\t\t    else if (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\tgoto theend;\n\t\t    else\n\t\t\t++ectx->ec_stack.ga_len;\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    tv->v_type = VAR_DICT;\n\t\t    tv->v_lock = 0;\n\t\t    tv->vval.v_dict = dict;\n\t\t    ++dict->dv_refcount;\n\t\t}\n\t\tbreak;\n\n\t    // call a :def function\n\t    case ISN_DCALL:\n\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\tif (call_dfunc(iptr->isn_arg.dfunc.cdf_idx,\n\t\t\t\tNULL,\n\t\t\t\tiptr->isn_arg.dfunc.cdf_argcount,\n\t\t\t\tectx) == FAIL)\n\t\t    goto on_error;\n\t\tbreak;\n\n\t    // call a builtin function\n\t    case ISN_BCALL:\n\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\tif (call_bfunc(iptr->isn_arg.bfunc.cbf_idx,\n\t\t\t      iptr->isn_arg.bfunc.cbf_argcount,\n\t\t\t      ectx) == FAIL)\n\t\t    goto on_error;\n\t\tbreak;\n\n\t    // call a funcref or partial\n\t    case ISN_PCALL:\n\t\t{\n\t\t    cpfunc_T\t*pfunc = &iptr->isn_arg.pfunc;\n\t\t    int\t\tr;\n\t\t    typval_T\tpartial_tv;\n\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    if (pfunc->cpf_top)\n\t\t    {\n\t\t\t// funcref is above the arguments\n\t\t\ttv = STACK_TV_BOT(-pfunc->cpf_argcount - 1);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// Get the funcref from the stack.\n\t\t\t--ectx->ec_stack.ga_len;\n\t\t\tpartial_tv = *STACK_TV_BOT(0);\n\t\t\ttv = &partial_tv;\n\t\t    }\n\t\t    r = call_partial(tv, pfunc->cpf_argcount, ectx);\n\t\t    if (tv == &partial_tv)\n\t\t\tclear_tv(&partial_tv);\n\t\t    if (r == FAIL)\n\t\t\tgoto on_error;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_PCALL_END:\n\t\t// PCALL finished, arguments have been consumed and replaced by\n\t\t// the return value.  Now clear the funcref from the stack,\n\t\t// and move the return value in its place.\n\t\t--ectx->ec_stack.ga_len;\n\t\tclear_tv(STACK_TV_BOT(-1));\n\t\t*STACK_TV_BOT(-1) = *STACK_TV_BOT(0);\n\t\tbreak;\n\n\t    // call a user defined function or funcref/partial\n\t    case ISN_UCALL:\n\t\t{\n\t\t    cufunc_T\t*cufunc = &iptr->isn_arg.ufunc;\n\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    if (call_eval_func(cufunc->cuf_name, cufunc->cuf_argcount,\n\t\t\t\t\t\t\t   ectx, iptr) == FAIL)\n\t\t\tgoto on_error;\n\t\t}\n\t\tbreak;\n\n\t    // return from a :def function call without a value\n\t    case ISN_RETURN_VOID:\n\t\tif (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t    goto theend;\n\t\ttv = STACK_TV_BOT(0);\n\t\t++ectx->ec_stack.ga_len;\n\t\ttv->v_type = VAR_VOID;\n\t\ttv->vval.v_number = 0;\n\t\ttv->v_lock = 0;\n\t\t// FALLTHROUGH\n\n\t    // return from a :def function call with what is on the stack\n\t    case ISN_RETURN:\n\t\t{\n\t\t    garray_T\t*trystack = &ectx->ec_trystack;\n\t\t    trycmd_T    *trycmd = NULL;\n\n\t\t    if (trystack->ga_len > 0)\n\t\t\ttrycmd = ((trycmd_T *)trystack->ga_data)\n\t\t\t\t\t\t\t+ trystack->ga_len - 1;\n\t\t    if (trycmd != NULL\n\t\t\t\t && trycmd->tcd_frame_idx == ectx->ec_frame_idx)\n\t\t    {\n\t\t\t// jump to \":finally\" or \":endtry\"\n\t\t\tif (trycmd->tcd_finally_idx != 0)\n\t\t\t    ectx->ec_iidx = trycmd->tcd_finally_idx;\n\t\t\telse\n\t\t\t    ectx->ec_iidx = trycmd->tcd_endtry_idx;\n\t\t\ttrycmd->tcd_return = TRUE;\n\t\t    }\n\t\t    else\n\t\t\tgoto func_return;\n\t\t}\n\t\tbreak;\n\n\t    // push a partial, a reference to a compiled function\n\t    case ISN_FUNCREF:\n\t\t{\n\t\t    partial_T   *pt = ALLOC_CLEAR_ONE(partial_T);\n\t\t    ufunc_T\t*ufunc;\n\t\t    funcref_T\t*funcref = &iptr->isn_arg.funcref;\n\n\t\t    if (pt == NULL)\n\t\t\tgoto theend;\n\t\t    if (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t    {\n\t\t\tvim_free(pt);\n\t\t\tgoto theend;\n\t\t    }\n\t\t    if (funcref->fr_func_name == NULL)\n\t\t    {\n\t\t\tdfunc_T\t*pt_dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t       + funcref->fr_dfunc_idx;\n\n\t\t\tufunc = pt_dfunc->df_ufunc;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tufunc = find_func(funcref->fr_func_name, FALSE, NULL);\n\t\t    }\n\t\t    if (ufunc == NULL)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\temsg(_(e_function_reference_invalid));\n\t\t\tgoto theend;\n\t\t    }\n\t\t    if (fill_partial_and_closure(pt, ufunc, ectx) == FAIL)\n\t\t\tgoto theend;\n\t\t    tv = STACK_TV_BOT(0);\n\t\t    ++ectx->ec_stack.ga_len;\n\t\t    tv->vval.v_partial = pt;\n\t\t    tv->v_type = VAR_PARTIAL;\n\t\t    tv->v_lock = 0;\n\t\t}\n\t\tbreak;\n\n\t    // Create a global function from a lambda.\n\t    case ISN_NEWFUNC:\n\t\t{\n\t\t    newfunc_T\t*newfunc = &iptr->isn_arg.newfunc;\n\n\t\t    if (copy_func(newfunc->nf_lambda, newfunc->nf_global,\n\t\t\t\t\t\t\t\t ectx) == FAIL)\n\t\t\tgoto theend;\n\t\t}\n\t\tbreak;\n\n\t    // List functions\n\t    case ISN_DEF:\n\t\tif (iptr->isn_arg.string == NULL)\n\t\t    list_functions(NULL);\n\t\telse\n\t\t{\n\t\t    exarg_T\tea;\n\t\t    garray_T\tlines_to_free;\n\n\t\t    CLEAR_FIELD(ea);\n\t\t    ea.cmd = ea.arg = iptr->isn_arg.string;\n\t\t    ga_init2(&lines_to_free, sizeof(char_u *), 50);\n\t\t    define_function(&ea, NULL, &lines_to_free);\n\t\t    ga_clear_strings(&lines_to_free);\n\t\t}\n\t\tbreak;\n\n\t    // jump if a condition is met\n\t    case ISN_JUMP:\n\t\t{\n\t\t    jumpwhen_T\twhen = iptr->isn_arg.jump.jump_when;\n\t\t    int\t\terror = FALSE;\n\t\t    int\t\tjump = TRUE;\n\n\t\t    if (when != JUMP_ALWAYS)\n\t\t    {\n\t\t\ttv = STACK_TV_BOT(-1);\n\t\t\tif (when == JUMP_IF_COND_FALSE\n\t\t\t\t|| when == JUMP_IF_FALSE\n\t\t\t\t|| when == JUMP_IF_COND_TRUE)\n\t\t\t{\n\t\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t\t    jump = tv_get_bool_chk(tv, &error);\n\t\t\t    if (error)\n\t\t\t\tgoto on_error;\n\t\t\t}\n\t\t\telse\n\t\t\t    jump = tv2bool(tv);\n\t\t\tif (when == JUMP_IF_FALSE\n\t\t\t\t\t     || when == JUMP_AND_KEEP_IF_FALSE\n\t\t\t\t\t     || when == JUMP_IF_COND_FALSE)\n\t\t\t    jump = !jump;\n\t\t\tif (when == JUMP_IF_FALSE || !jump)\n\t\t\t{\n\t\t\t    // drop the value from the stack\n\t\t\t    clear_tv(tv);\n\t\t\t    --ectx->ec_stack.ga_len;\n\t\t\t}\n\t\t    }\n\t\t    if (jump)\n\t\t\tectx->ec_iidx = iptr->isn_arg.jump.jump_where;\n\t\t}\n\t\tbreak;\n\n\t    // Jump if an argument with a default value was already set and not\n\t    // v:none.\n\t    case ISN_JUMP_IF_ARG_SET:\n\t\ttv = STACK_TV_VAR(iptr->isn_arg.jumparg.jump_arg_off);\n\t\tif (tv->v_type != VAR_UNKNOWN\n\t\t\t&& !(tv->v_type == VAR_SPECIAL\n\t\t\t\t\t    && tv->vval.v_number == VVAL_NONE))\n\t\t    ectx->ec_iidx = iptr->isn_arg.jumparg.jump_where;\n\t\tbreak;\n\n\t    // top of a for loop\n\t    case ISN_FOR:\n\t\t{\n\t\t    typval_T\t*ltv = STACK_TV_BOT(-1);\n\t\t    typval_T\t*idxtv =\n\t\t\t\t   STACK_TV_VAR(iptr->isn_arg.forloop.for_idx);\n\n\t\t    if (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\tgoto theend;\n\t\t    if (ltv->v_type == VAR_LIST)\n\t\t    {\n\t\t\tlist_T *list = ltv->vval.v_list;\n\n\t\t\t// push the next item from the list\n\t\t\t++idxtv->vval.v_number;\n\t\t\tif (list == NULL\n\t\t\t\t       || idxtv->vval.v_number >= list->lv_len)\n\t\t\t{\n\t\t\t    // past the end of the list, jump to \"endfor\"\n\t\t\t    ectx->ec_iidx = iptr->isn_arg.forloop.for_end;\n\t\t\t    may_restore_cmdmod(&ectx->ec_funclocal);\n\t\t\t}\n\t\t\telse if (list->lv_first == &range_list_item)\n\t\t\t{\n\t\t\t    // non-materialized range() list\n\t\t\t    tv = STACK_TV_BOT(0);\n\t\t\t    tv->v_type = VAR_NUMBER;\n\t\t\t    tv->v_lock = 0;\n\t\t\t    tv->vval.v_number = list_find_nr(\n\t\t\t\t\t     list, idxtv->vval.v_number, NULL);\n\t\t\t    ++ectx->ec_stack.ga_len;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    listitem_T *li = list_find(list,\n\t\t\t\t\t\t\t idxtv->vval.v_number);\n\n\t\t\t    copy_tv(&li->li_tv, STACK_TV_BOT(0));\n\t\t\t    ++ectx->ec_stack.ga_len;\n\t\t\t}\n\t\t    }\n\t\t    else if (ltv->v_type == VAR_STRING)\n\t\t    {\n\t\t\tchar_u\t*str = ltv->vval.v_string;\n\n\t\t\t// The index is for the last byte of the previous\n\t\t\t// character.\n\t\t\t++idxtv->vval.v_number;\n\t\t\tif (str == NULL || str[idxtv->vval.v_number] == NUL)\n\t\t\t{\n\t\t\t    // past the end of the string, jump to \"endfor\"\n\t\t\t    ectx->ec_iidx = iptr->isn_arg.forloop.for_end;\n\t\t\t    may_restore_cmdmod(&ectx->ec_funclocal);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    int\tclen = mb_ptr2len(str + idxtv->vval.v_number);\n\n\t\t\t    // Push the next character from the string.\n\t\t\t    tv = STACK_TV_BOT(0);\n\t\t\t    tv->v_type = VAR_STRING;\n\t\t\t    tv->vval.v_string = vim_strnsave(\n\t\t\t\t\t     str + idxtv->vval.v_number, clen);\n\t\t\t    ++ectx->ec_stack.ga_len;\n\t\t\t    idxtv->vval.v_number += clen - 1;\n\t\t\t}\n\t\t    }\n\t\t    else if (ltv->v_type == VAR_BLOB)\n\t\t    {\n\t\t\tblob_T\t*blob = ltv->vval.v_blob;\n\n\t\t\t// When we get here the first time make a copy of the\n\t\t\t// blob, so that the iteration still works when it is\n\t\t\t// changed.\n\t\t\tif (idxtv->vval.v_number == -1 && blob != NULL)\n\t\t\t{\n\t\t\t    blob_copy(blob, ltv);\n\t\t\t    blob_unref(blob);\n\t\t\t    blob = ltv->vval.v_blob;\n\t\t\t}\n\n\t\t\t// The index is for the previous byte.\n\t\t\t++idxtv->vval.v_number;\n\t\t\tif (blob == NULL\n\t\t\t\t     || idxtv->vval.v_number >= blob_len(blob))\n\t\t\t{\n\t\t\t    // past the end of the blob, jump to \"endfor\"\n\t\t\t    ectx->ec_iidx = iptr->isn_arg.forloop.for_end;\n\t\t\t    may_restore_cmdmod(&ectx->ec_funclocal);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // Push the next byte from the blob.\n\t\t\t    tv = STACK_TV_BOT(0);\n\t\t\t    tv->v_type = VAR_NUMBER;\n\t\t\t    tv->vval.v_number = blob_get(blob,\n\t\t\t\t\t\t\t idxtv->vval.v_number);\n\t\t\t    ++ectx->ec_stack.ga_len;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tsemsg(_(e_for_loop_on_str_not_supported),\n\t\t\t\t\t\t    vartype_name(ltv->v_type));\n\t\t\tgoto theend;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    // start of \":try\" block\n\t    case ISN_TRY:\n\t\t{\n\t\t    trycmd_T    *trycmd = NULL;\n\n\t\t    if (GA_GROW_FAILS(&ectx->ec_trystack, 1))\n\t\t\tgoto theend;\n\t\t    trycmd = ((trycmd_T *)ectx->ec_trystack.ga_data)\n\t\t\t\t\t\t     + ectx->ec_trystack.ga_len;\n\t\t    ++ectx->ec_trystack.ga_len;\n\t\t    ++trylevel;\n\t\t    CLEAR_POINTER(trycmd);\n\t\t    trycmd->tcd_frame_idx = ectx->ec_frame_idx;\n\t\t    trycmd->tcd_stack_len = ectx->ec_stack.ga_len;\n\t\t    trycmd->tcd_catch_idx =\n\t\t\t\t       iptr->isn_arg.tryref.try_ref->try_catch;\n\t\t    trycmd->tcd_finally_idx =\n\t\t\t\t     iptr->isn_arg.tryref.try_ref->try_finally;\n\t\t    trycmd->tcd_endtry_idx =\n\t\t\t\t      iptr->isn_arg.tryref.try_ref->try_endtry;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_PUSHEXC:\n\t\tif (current_exception == NULL)\n\t\t{\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    iemsg(\"Evaluating catch while current_exception is NULL\");\n\t\t    goto theend;\n\t\t}\n\t\tif (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t    goto theend;\n\t\ttv = STACK_TV_BOT(0);\n\t\t++ectx->ec_stack.ga_len;\n\t\ttv->v_type = VAR_STRING;\n\t\ttv->v_lock = 0;\n\t\ttv->vval.v_string = vim_strsave(\n\t\t\t\t\t   (char_u *)current_exception->value);\n\t\tbreak;\n\n\t    case ISN_CATCH:\n\t\t{\n\t\t    garray_T\t*trystack = &ectx->ec_trystack;\n\n\t\t    may_restore_cmdmod(&ectx->ec_funclocal);\n\t\t    if (trystack->ga_len > 0)\n\t\t    {\n\t\t\ttrycmd_T    *trycmd = ((trycmd_T *)trystack->ga_data)\n\t\t\t\t\t\t\t+ trystack->ga_len - 1;\n\t\t\ttrycmd->tcd_caught = TRUE;\n\t\t\ttrycmd->tcd_did_throw = FALSE;\n\t\t    }\n\t\t    did_emsg = got_int = did_throw = FALSE;\n\t\t    force_abort = need_rethrow = FALSE;\n\t\t    catch_exception(current_exception);\n\t\t}\n\t\tbreak;\n\n\t    case ISN_TRYCONT:\n\t\t{\n\t\t    garray_T\t*trystack = &ectx->ec_trystack;\n\t\t    trycont_T\t*trycont = &iptr->isn_arg.trycont;\n\t\t    int\t\ti;\n\t\t    trycmd_T    *trycmd;\n\t\t    int\t\tiidx = trycont->tct_where;\n\n\t\t    if (trystack->ga_len < trycont->tct_levels)\n\t\t    {\n\t\t\tsiemsg(\"TRYCONT: expected %d levels, found %d\",\n\t\t\t\t\ttrycont->tct_levels, trystack->ga_len);\n\t\t\tgoto theend;\n\t\t    }\n\t\t    // Make :endtry jump to any outer try block and the last\n\t\t    // :endtry inside the loop to the loop start.\n\t\t    for (i = trycont->tct_levels; i > 0; --i)\n\t\t    {\n\t\t\ttrycmd = ((trycmd_T *)trystack->ga_data)\n\t\t\t\t\t\t\t+ trystack->ga_len - i;\n\t\t\t// Add one to tcd_cont to be able to jump to\n\t\t\t// instruction with index zero.\n\t\t\ttrycmd->tcd_cont = iidx + 1;\n\t\t\tiidx = trycmd->tcd_finally_idx == 0\n\t\t\t    ? trycmd->tcd_endtry_idx : trycmd->tcd_finally_idx;\n\t\t    }\n\t\t    // jump to :finally or :endtry of current try statement\n\t\t    ectx->ec_iidx = iidx;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_FINALLY:\n\t\t{\n\t\t    garray_T\t*trystack = &ectx->ec_trystack;\n\t\t    trycmd_T    *trycmd = ((trycmd_T *)trystack->ga_data)\n\t\t\t\t\t\t\t+ trystack->ga_len - 1;\n\n\t\t    // Reset the index to avoid a return statement jumps here\n\t\t    // again.\n\t\t    trycmd->tcd_finally_idx = 0;\n\t\t    break;\n\t\t}\n\n\t    // end of \":try\" block\n\t    case ISN_ENDTRY:\n\t\t{\n\t\t    garray_T\t*trystack = &ectx->ec_trystack;\n\n\t\t    if (trystack->ga_len > 0)\n\t\t    {\n\t\t\ttrycmd_T    *trycmd;\n\n\t\t\t--trystack->ga_len;\n\t\t\t--trylevel;\n\t\t\ttrycmd = ((trycmd_T *)trystack->ga_data)\n\t\t\t\t\t\t\t    + trystack->ga_len;\n\t\t\tif (trycmd->tcd_did_throw)\n\t\t\t    did_throw = TRUE;\n\t\t\tif (trycmd->tcd_caught && current_exception != NULL)\n\t\t\t{\n\t\t\t    // discard the exception\n\t\t\t    if (caught_stack == current_exception)\n\t\t\t\tcaught_stack = caught_stack->caught;\n\t\t\t    discard_current_exception();\n\t\t\t}\n\n\t\t\tif (trycmd->tcd_return)\n\t\t\t    goto func_return;\n\n\t\t\twhile (ectx->ec_stack.ga_len > trycmd->tcd_stack_len)\n\t\t\t{\n\t\t\t    --ectx->ec_stack.ga_len;\n\t\t\t    clear_tv(STACK_TV_BOT(0));\n\t\t\t}\n\t\t\tif (trycmd->tcd_cont != 0)\n\t\t\t    // handling :continue: jump to outer try block or\n\t\t\t    // start of the loop\n\t\t\t    ectx->ec_iidx = trycmd->tcd_cont - 1;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    case ISN_THROW:\n\t\t{\n\t\t    garray_T\t*trystack = &ectx->ec_trystack;\n\n\t\t    if (trystack->ga_len == 0 && trylevel == 0 && emsg_silent)\n\t\t    {\n\t\t\t// throwing an exception while using \"silent!\" causes\n\t\t\t// the function to abort but not display an error.\n\t\t\ttv = STACK_TV_BOT(-1);\n\t\t\tclear_tv(tv);\n\t\t\ttv->v_type = VAR_NUMBER;\n\t\t\ttv->vval.v_number = 0;\n\t\t\tgoto done;\n\t\t    }\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    tv = STACK_TV_BOT(0);\n\t\t    if (tv->vval.v_string == NULL\n\t\t\t\t       || *skipwhite(tv->vval.v_string) == NUL)\n\t\t    {\n\t\t\tvim_free(tv->vval.v_string);\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\temsg(_(e_throw_with_empty_string));\n\t\t\tgoto theend;\n\t\t    }\n\n\t\t    // Inside a \"catch\" we need to first discard the caught\n\t\t    // exception.\n\t\t    if (trystack->ga_len > 0)\n\t\t    {\n\t\t\ttrycmd_T    *trycmd = ((trycmd_T *)trystack->ga_data)\n\t\t\t\t\t\t\t+ trystack->ga_len - 1;\n\t\t\tif (trycmd->tcd_caught && current_exception != NULL)\n\t\t\t{\n\t\t\t    // discard the exception\n\t\t\t    if (caught_stack == current_exception)\n\t\t\t\tcaught_stack = caught_stack->caught;\n\t\t\t    discard_current_exception();\n\t\t\t    trycmd->tcd_caught = FALSE;\n\t\t\t}\n\t\t    }\n\n\t\t    if (throw_exception(tv->vval.v_string, ET_USER, NULL)\n\t\t\t\t\t\t\t\t       == FAIL)\n\t\t    {\n\t\t\tvim_free(tv->vval.v_string);\n\t\t\tgoto theend;\n\t\t    }\n\t\t    did_throw = TRUE;\n\t\t}\n\t\tbreak;\n\n\t    // compare with special values\n\t    case ISN_COMPAREBOOL:\n\t    case ISN_COMPARESPECIAL:\n\t\t{\n\t\t    typval_T\t*tv1 = STACK_TV_BOT(-2);\n\t\t    typval_T\t*tv2 = STACK_TV_BOT(-1);\n\t\t    varnumber_T arg1 = tv1->vval.v_number;\n\t\t    varnumber_T arg2 = tv2->vval.v_number;\n\t\t    int\t\tres;\n\n\t\t    switch (iptr->isn_arg.op.op_type)\n\t\t    {\n\t\t\tcase EXPR_EQUAL: res = arg1 == arg2; break;\n\t\t\tcase EXPR_NEQUAL: res = arg1 != arg2; break;\n\t\t\tdefault: res = 0; break;\n\t\t    }\n\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    tv1->v_type = VAR_BOOL;\n\t\t    tv1->vval.v_number = res ? VVAL_TRUE : VVAL_FALSE;\n\t\t}\n\t\tbreak;\n\n\t    // Operation with two number arguments\n\t    case ISN_OPNR:\n\t    case ISN_COMPARENR:\n\t\t{\n\t\t    typval_T\t*tv1 = STACK_TV_BOT(-2);\n\t\t    typval_T\t*tv2 = STACK_TV_BOT(-1);\n\t\t    varnumber_T arg1 = tv1->vval.v_number;\n\t\t    varnumber_T arg2 = tv2->vval.v_number;\n\t\t    varnumber_T res = 0;\n\t\t    int\t\tdiv_zero = FALSE;\n\n\t\t    switch (iptr->isn_arg.op.op_type)\n\t\t    {\n\t\t\tcase EXPR_MULT: res = arg1 * arg2; break;\n\t\t\tcase EXPR_DIV:  if (arg2 == 0)\n\t\t\t\t\t    div_zero = TRUE;\n\t\t\t\t\telse\n\t\t\t\t\t    res = arg1 / arg2;\n\t\t\t\t\tbreak;\n\t\t\tcase EXPR_REM:  if (arg2 == 0)\n\t\t\t\t\t    div_zero = TRUE;\n\t\t\t\t\telse\n\t\t\t\t\t    res = arg1 % arg2;\n\t\t\t\t\tbreak;\n\t\t\tcase EXPR_SUB: res = arg1 - arg2; break;\n\t\t\tcase EXPR_ADD: res = arg1 + arg2; break;\n\n\t\t\tcase EXPR_EQUAL: res = arg1 == arg2; break;\n\t\t\tcase EXPR_NEQUAL: res = arg1 != arg2; break;\n\t\t\tcase EXPR_GREATER: res = arg1 > arg2; break;\n\t\t\tcase EXPR_GEQUAL: res = arg1 >= arg2; break;\n\t\t\tcase EXPR_SMALLER: res = arg1 < arg2; break;\n\t\t\tcase EXPR_SEQUAL: res = arg1 <= arg2; break;\n\t\t\tdefault: break;\n\t\t    }\n\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    if (iptr->isn_type == ISN_COMPARENR)\n\t\t    {\n\t\t\ttv1->v_type = VAR_BOOL;\n\t\t\ttv1->vval.v_number = res ? VVAL_TRUE : VVAL_FALSE;\n\t\t    }\n\t\t    else\n\t\t\ttv1->vval.v_number = res;\n\t\t    if (div_zero)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\temsg(_(e_divide_by_zero));\n\t\t\tgoto on_error;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    // Computation with two float arguments\n\t    case ISN_OPFLOAT:\n\t    case ISN_COMPAREFLOAT:\n#ifdef FEAT_FLOAT\n\t\t{\n\t\t    typval_T\t*tv1 = STACK_TV_BOT(-2);\n\t\t    typval_T\t*tv2 = STACK_TV_BOT(-1);\n\t\t    float_T\targ1 = tv1->vval.v_float;\n\t\t    float_T\targ2 = tv2->vval.v_float;\n\t\t    float_T\tres = 0;\n\t\t    int\t\tcmp = FALSE;\n\n\t\t    switch (iptr->isn_arg.op.op_type)\n\t\t    {\n\t\t\tcase EXPR_MULT: res = arg1 * arg2; break;\n\t\t\tcase EXPR_DIV: res = arg1 / arg2; break;\n\t\t\tcase EXPR_SUB: res = arg1 - arg2; break;\n\t\t\tcase EXPR_ADD: res = arg1 + arg2; break;\n\n\t\t\tcase EXPR_EQUAL: cmp = arg1 == arg2; break;\n\t\t\tcase EXPR_NEQUAL: cmp = arg1 != arg2; break;\n\t\t\tcase EXPR_GREATER: cmp = arg1 > arg2; break;\n\t\t\tcase EXPR_GEQUAL: cmp = arg1 >= arg2; break;\n\t\t\tcase EXPR_SMALLER: cmp = arg1 < arg2; break;\n\t\t\tcase EXPR_SEQUAL: cmp = arg1 <= arg2; break;\n\t\t\tdefault: cmp = 0; break;\n\t\t    }\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    if (iptr->isn_type == ISN_COMPAREFLOAT)\n\t\t    {\n\t\t\ttv1->v_type = VAR_BOOL;\n\t\t\ttv1->vval.v_number = cmp ? VVAL_TRUE : VVAL_FALSE;\n\t\t    }\n\t\t    else\n\t\t\ttv1->vval.v_float = res;\n\t\t}\n#endif\n\t\tbreak;\n\n\t    case ISN_COMPARELIST:\n\t    case ISN_COMPAREDICT:\n\t    case ISN_COMPAREFUNC:\n\t    case ISN_COMPARESTRING:\n\t    case ISN_COMPAREBLOB:\n\t\t{\n\t\t    typval_T\t*tv1 = STACK_TV_BOT(-2);\n\t\t    typval_T\t*tv2 = STACK_TV_BOT(-1);\n\t\t    exprtype_T\texprtype = iptr->isn_arg.op.op_type;\n\t\t    int\t\tic = iptr->isn_arg.op.op_ic;\n\t\t    int\t\tres = FALSE;\n\t\t    int\t\tstatus = OK;\n\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    if (iptr->isn_type == ISN_COMPARELIST)\n\t\t    {\n\t\t\tstatus = typval_compare_list(tv1, tv2,\n\t\t\t\t\t\t\t   exprtype, ic, &res);\n\t\t    }\n\t\t    else if (iptr->isn_type == ISN_COMPAREDICT)\n\t\t    {\n\t\t\tstatus = typval_compare_dict(tv1, tv2,\n\t\t\t\t\t\t\t   exprtype, ic, &res);\n\t\t    }\n\t\t    else if (iptr->isn_type == ISN_COMPAREFUNC)\n\t\t    {\n\t\t\tstatus = typval_compare_func(tv1, tv2,\n\t\t\t\t\t\t\t   exprtype, ic, &res);\n\t\t    }\n\t\t    else if (iptr->isn_type == ISN_COMPARESTRING)\n\t\t    {\n\t\t\tstatus = typval_compare_string(tv1, tv2,\n\t\t\t\t\t\t\t   exprtype, ic, &res);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tstatus = typval_compare_blob(tv1, tv2, exprtype, &res);\n\t\t    }\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    clear_tv(tv1);\n\t\t    clear_tv(tv2);\n\t\t    tv1->v_type = VAR_BOOL;\n\t\t    tv1->vval.v_number = res ? VVAL_TRUE : VVAL_FALSE;\n\t\t    if (status == FAIL)\n\t\t\tgoto theend;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_COMPAREANY:\n\t\t{\n\t\t    typval_T\t*tv1 = STACK_TV_BOT(-2);\n\t\t    typval_T\t*tv2 = STACK_TV_BOT(-1);\n\t\t    exprtype_T\texprtype = iptr->isn_arg.op.op_type;\n\t\t    int\t\tic = iptr->isn_arg.op.op_ic;\n\t\t    int\t\tstatus;\n\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    status = typval_compare(tv1, tv2, exprtype, ic);\n\t\t    clear_tv(tv2);\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    if (status == FAIL)\n\t\t\tgoto theend;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_ADDLIST:\n\t    case ISN_ADDBLOB:\n\t\t{\n\t\t    typval_T *tv1 = STACK_TV_BOT(-2);\n\t\t    typval_T *tv2 = STACK_TV_BOT(-1);\n\n\t\t    // add two lists or blobs\n\t\t    if (iptr->isn_type == ISN_ADDLIST)\n\t\t    {\n\t\t\tif (iptr->isn_arg.op.op_type == EXPR_APPEND\n\t\t\t\t\t\t   && tv1->vval.v_list != NULL)\n\t\t\t    list_extend(tv1->vval.v_list, tv2->vval.v_list,\n\t\t\t\t\t\t\t\t\t NULL);\n\t\t\telse\n\t\t\t    eval_addlist(tv1, tv2);\n\t\t    }\n\t\t    else\n\t\t\teval_addblob(tv1, tv2);\n\t\t    clear_tv(tv2);\n\t\t    --ectx->ec_stack.ga_len;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_LISTAPPEND:\n\t\t{\n\t\t    typval_T\t*tv1 = STACK_TV_BOT(-2);\n\t\t    typval_T\t*tv2 = STACK_TV_BOT(-1);\n\t\t    list_T\t*l = tv1->vval.v_list;\n\n\t\t    // add an item to a list\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    if (l == NULL)\n\t\t    {\n\t\t\temsg(_(e_cannot_add_to_null_list));\n\t\t\tgoto on_error;\n\t\t    }\n\t\t    if (value_check_lock(l->lv_lock, NULL, FALSE))\n\t\t\tgoto on_error;\n\t\t    if (list_append_tv(l, tv2) == FAIL)\n\t\t\tgoto theend;\n\t\t    clear_tv(tv2);\n\t\t    --ectx->ec_stack.ga_len;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_BLOBAPPEND:\n\t\t{\n\t\t    typval_T\t*tv1 = STACK_TV_BOT(-2);\n\t\t    typval_T\t*tv2 = STACK_TV_BOT(-1);\n\t\t    blob_T\t*b = tv1->vval.v_blob;\n\t\t    int\t\terror = FALSE;\n\t\t    varnumber_T n;\n\n\t\t    // add a number to a blob\n\t\t    if (b == NULL)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\temsg(_(e_cannot_add_to_null_blob));\n\t\t\tgoto on_error;\n\t\t    }\n\t\t    n = tv_get_number_chk(tv2, &error);\n\t\t    if (error)\n\t\t\tgoto on_error;\n\t\t    ga_append(&b->bv_ga, (int)n);\n\t\t    --ectx->ec_stack.ga_len;\n\t\t}\n\t\tbreak;\n\n\t    // Computation with two arguments of unknown type\n\t    case ISN_OPANY:\n\t\t{\n\t\t    typval_T\t*tv1 = STACK_TV_BOT(-2);\n\t\t    typval_T\t*tv2 = STACK_TV_BOT(-1);\n\t\t    varnumber_T\tn1, n2;\n#ifdef FEAT_FLOAT\n\t\t    float_T\tf1 = 0, f2 = 0;\n#endif\n\t\t    int\t\terror = FALSE;\n\n\t\t    if (iptr->isn_arg.op.op_type == EXPR_ADD)\n\t\t    {\n\t\t\tif (tv1->v_type == VAR_LIST && tv2->v_type == VAR_LIST)\n\t\t\t{\n\t\t\t    eval_addlist(tv1, tv2);\n\t\t\t    clear_tv(tv2);\n\t\t\t    --ectx->ec_stack.ga_len;\n\t\t\t    break;\n\t\t\t}\n\t\t\telse if (tv1->v_type == VAR_BLOB\n\t\t\t\t\t\t    && tv2->v_type == VAR_BLOB)\n\t\t\t{\n\t\t\t    eval_addblob(tv1, tv2);\n\t\t\t    clear_tv(tv2);\n\t\t\t    --ectx->ec_stack.ga_len;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n#ifdef FEAT_FLOAT\n\t\t    if (tv1->v_type == VAR_FLOAT)\n\t\t    {\n\t\t\tf1 = tv1->vval.v_float;\n\t\t\tn1 = 0;\n\t\t    }\n\t\t    else\n#endif\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tn1 = tv_get_number_chk(tv1, &error);\n\t\t\tif (error)\n\t\t\t    goto on_error;\n#ifdef FEAT_FLOAT\n\t\t\tif (tv2->v_type == VAR_FLOAT)\n\t\t\t    f1 = n1;\n#endif\n\t\t    }\n#ifdef FEAT_FLOAT\n\t\t    if (tv2->v_type == VAR_FLOAT)\n\t\t    {\n\t\t\tf2 = tv2->vval.v_float;\n\t\t\tn2 = 0;\n\t\t    }\n\t\t    else\n#endif\n\t\t    {\n\t\t\tn2 = tv_get_number_chk(tv2, &error);\n\t\t\tif (error)\n\t\t\t    goto on_error;\n#ifdef FEAT_FLOAT\n\t\t\tif (tv1->v_type == VAR_FLOAT)\n\t\t\t    f2 = n2;\n#endif\n\t\t    }\n#ifdef FEAT_FLOAT\n\t\t    // if there is a float on either side the result is a float\n\t\t    if (tv1->v_type == VAR_FLOAT || tv2->v_type == VAR_FLOAT)\n\t\t    {\n\t\t\tswitch (iptr->isn_arg.op.op_type)\n\t\t\t{\n\t\t\t    case EXPR_MULT: f1 = f1 * f2; break;\n\t\t\t    case EXPR_DIV:  f1 = f1 / f2; break;\n\t\t\t    case EXPR_SUB:  f1 = f1 - f2; break;\n\t\t\t    case EXPR_ADD:  f1 = f1 + f2; break;\n\t\t\t    default: SOURCING_LNUM = iptr->isn_lnum;\n\t\t\t\t     emsg(_(e_cannot_use_percent_with_float));\n\t\t\t\t     goto on_error;\n\t\t\t}\n\t\t\tclear_tv(tv1);\n\t\t\tclear_tv(tv2);\n\t\t\ttv1->v_type = VAR_FLOAT;\n\t\t\ttv1->vval.v_float = f1;\n\t\t\t--ectx->ec_stack.ga_len;\n\t\t    }\n\t\t    else\n#endif\n\t\t    {\n\t\t\tint failed = FALSE;\n\n\t\t\tswitch (iptr->isn_arg.op.op_type)\n\t\t\t{\n\t\t\t    case EXPR_MULT: n1 = n1 * n2; break;\n\t\t\t    case EXPR_DIV:  n1 = num_divide(n1, n2, &failed);\n\t\t\t\t\t    if (failed)\n\t\t\t\t\t\tgoto on_error;\n\t\t\t\t\t    break;\n\t\t\t    case EXPR_SUB:  n1 = n1 - n2; break;\n\t\t\t    case EXPR_ADD:  n1 = n1 + n2; break;\n\t\t\t    default:\t    n1 = num_modulus(n1, n2, &failed);\n\t\t\t\t\t    if (failed)\n\t\t\t\t\t\tgoto on_error;\n\t\t\t\t\t    break;\n\t\t\t}\n\t\t\tclear_tv(tv1);\n\t\t\tclear_tv(tv2);\n\t\t\ttv1->v_type = VAR_NUMBER;\n\t\t\ttv1->vval.v_number = n1;\n\t\t\t--ectx->ec_stack.ga_len;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    case ISN_CONCAT:\n\t\t{\n\t\t    char_u *str1 = STACK_TV_BOT(-2)->vval.v_string;\n\t\t    char_u *str2 = STACK_TV_BOT(-1)->vval.v_string;\n\t\t    char_u *res;\n\n\t\t    res = concat_str(str1, str2);\n\t\t    clear_tv(STACK_TV_BOT(-2));\n\t\t    clear_tv(STACK_TV_BOT(-1));\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    STACK_TV_BOT(-1)->vval.v_string = res;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_STRINDEX:\n\t    case ISN_STRSLICE:\n\t\t{\n\t\t    int\t\tis_slice = iptr->isn_type == ISN_STRSLICE;\n\t\t    varnumber_T\tn1 = 0, n2;\n\t\t    char_u\t*res;\n\n\t\t    // string index: string is at stack-2, index at stack-1\n\t\t    // string slice: string is at stack-3, first index at\n\t\t    // stack-2, second index at stack-1\n\t\t    if (is_slice)\n\t\t    {\n\t\t\ttv = STACK_TV_BOT(-2);\n\t\t\tn1 = tv->vval.v_number;\n\t\t    }\n\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    n2 = tv->vval.v_number;\n\n\t\t    ectx->ec_stack.ga_len -= is_slice ? 2 : 1;\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    if (is_slice)\n\t\t\t// Slice: Select the characters from the string\n\t\t\tres = string_slice(tv->vval.v_string, n1, n2, FALSE);\n\t\t    else\n\t\t\t// Index: The resulting variable is a string of a\n\t\t\t// single character (including composing characters).\n\t\t\t// If the index is too big or negative the result is\n\t\t\t// empty.\n\t\t\tres = char_from_string(tv->vval.v_string, n2);\n\t\t    vim_free(tv->vval.v_string);\n\t\t    tv->vval.v_string = res;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_LISTINDEX:\n\t    case ISN_LISTSLICE:\n\t    case ISN_BLOBINDEX:\n\t    case ISN_BLOBSLICE:\n\t\t{\n\t\t    int\t\tis_slice = iptr->isn_type == ISN_LISTSLICE\n\t\t\t\t\t    || iptr->isn_type == ISN_BLOBSLICE;\n\t\t    int\t\tis_blob = iptr->isn_type == ISN_BLOBINDEX\n\t\t\t\t\t    || iptr->isn_type == ISN_BLOBSLICE;\n\t\t    varnumber_T\tn1, n2;\n\t\t    typval_T\t*val_tv;\n\n\t\t    // list index: list is at stack-2, index at stack-1\n\t\t    // list slice: list is at stack-3, indexes at stack-2 and\n\t\t    // stack-1\n\t\t    // Same for blob.\n\t\t    val_tv = is_slice ? STACK_TV_BOT(-3) : STACK_TV_BOT(-2);\n\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    n1 = n2 = tv->vval.v_number;\n\t\t    clear_tv(tv);\n\n\t\t    if (is_slice)\n\t\t    {\n\t\t\ttv = STACK_TV_BOT(-2);\n\t\t\tn1 = tv->vval.v_number;\n\t\t\tclear_tv(tv);\n\t\t    }\n\n\t\t    ectx->ec_stack.ga_len -= is_slice ? 2 : 1;\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    if (is_blob)\n\t\t    {\n\t\t\tif (blob_slice_or_index(val_tv->vval.v_blob, is_slice,\n\t\t\t\t\t\t    n1, n2, FALSE, tv) == FAIL)\n\t\t\t    goto on_error;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (list_slice_or_index(val_tv->vval.v_list, is_slice,\n\t\t\t\t\t      n1, n2, FALSE, tv, TRUE) == FAIL)\n\t\t\t    goto on_error;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    case ISN_ANYINDEX:\n\t    case ISN_ANYSLICE:\n\t\t{\n\t\t    int\t\tis_slice = iptr->isn_type == ISN_ANYSLICE;\n\t\t    typval_T\t*var1, *var2;\n\t\t    int\t\tres;\n\n\t\t    // index: composite is at stack-2, index at stack-1\n\t\t    // slice: composite is at stack-3, indexes at stack-2 and\n\t\t    // stack-1\n\t\t    tv = is_slice ? STACK_TV_BOT(-3) : STACK_TV_BOT(-2);\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    if (check_can_index(tv, TRUE, TRUE) == FAIL)\n\t\t\tgoto on_error;\n\t\t    var1 = is_slice ? STACK_TV_BOT(-2) : STACK_TV_BOT(-1);\n\t\t    var2 = is_slice ? STACK_TV_BOT(-1) : NULL;\n\t\t    res = eval_index_inner(tv, is_slice, var1, var2,\n\t\t\t\t\t\t\tFALSE, NULL, -1, TRUE);\n\t\t    clear_tv(var1);\n\t\t    if (is_slice)\n\t\t\tclear_tv(var2);\n\t\t    ectx->ec_stack.ga_len -= is_slice ? 2 : 1;\n\t\t    if (res == FAIL)\n\t\t\tgoto on_error;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_SLICE:\n\t\t{\n\t\t    list_T\t*list;\n\t\t    int\t\tcount = iptr->isn_arg.number;\n\n\t\t    // type will have been checked to be a list\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    list = tv->vval.v_list;\n\n\t\t    // no error for short list, expect it to be checked earlier\n\t\t    if (list != NULL && list->lv_len >= count)\n\t\t    {\n\t\t\tlist_T\t*newlist = list_slice(list,\n\t\t\t\t\t\t      count, list->lv_len - 1);\n\n\t\t\tif (newlist != NULL)\n\t\t\t{\n\t\t\t    list_unref(list);\n\t\t\t    tv->vval.v_list = newlist;\n\t\t\t    ++newlist->lv_refcount;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    case ISN_GETITEM:\n\t\t{\n\t\t    listitem_T\t*li;\n\t\t    getitem_T\t*gi = &iptr->isn_arg.getitem;\n\n\t\t    // Get list item: list is at stack-1, push item.\n\t\t    // List type and length is checked for when compiling.\n\t\t    tv = STACK_TV_BOT(-1 - gi->gi_with_op);\n\t\t    li = list_find(tv->vval.v_list, gi->gi_index);\n\n\t\t    if (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\tgoto theend;\n\t\t    ++ectx->ec_stack.ga_len;\n\t\t    copy_tv(&li->li_tv, STACK_TV_BOT(-1));\n\n\t\t    // Useful when used in unpack assignment.  Reset at\n\t\t    // ISN_DROP.\n\t\t    ectx->ec_where.wt_index = gi->gi_index + 1;\n\t\t    ectx->ec_where.wt_variable = TRUE;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_MEMBER:\n\t\t{\n\t\t    dict_T\t*dict;\n\t\t    char_u\t*key;\n\t\t    dictitem_T\t*di;\n\n\t\t    // dict member: dict is at stack-2, key at stack-1\n\t\t    tv = STACK_TV_BOT(-2);\n\t\t    // no need to check for VAR_DICT, CHECKTYPE will check.\n\t\t    dict = tv->vval.v_dict;\n\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    // no need to check for VAR_STRING, 2STRING will check.\n\t\t    key = tv->vval.v_string;\n\t\t    if (key == NULL)\n\t\t\tkey = (char_u *)\"\";\n\n\t\t    if ((di = dict_find(dict, key, -1)) == NULL)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tsemsg(_(e_key_not_present_in_dictionary), key);\n\n\t\t\t// If :silent! is used we will continue, make sure the\n\t\t\t// stack contents makes sense and the dict stack is\n\t\t\t// updated.\n\t\t\tclear_tv(tv);\n\t\t\t--ectx->ec_stack.ga_len;\n\t\t\ttv = STACK_TV_BOT(-1);\n\t\t\t(void) dict_stack_save(tv);\n\t\t\ttv->v_type = VAR_NUMBER;\n\t\t\ttv->vval.v_number = 0;\n\t\t\tgoto on_fatal_error;\n\t\t    }\n\t\t    clear_tv(tv);\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    // Put the dict used on the dict stack, it might be used by\n\t\t    // a dict function later.\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    if (dict_stack_save(tv) == FAIL)\n\t\t\tgoto on_fatal_error;\n\t\t    copy_tv(&di->di_tv, tv);\n\t\t}\n\t\tbreak;\n\n\t    // dict member with string key\n\t    case ISN_STRINGMEMBER:\n\t\t{\n\t\t    dict_T\t*dict;\n\t\t    dictitem_T\t*di;\n\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    if (tv->v_type != VAR_DICT || tv->vval.v_dict == NULL)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\temsg(_(e_dictionary_required));\n\t\t\tgoto on_error;\n\t\t    }\n\t\t    dict = tv->vval.v_dict;\n\n\t\t    if ((di = dict_find(dict, iptr->isn_arg.string, -1))\n\t\t\t\t\t\t\t\t       == NULL)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tsemsg(_(e_key_not_present_in_dictionary), iptr->isn_arg.string);\n\t\t\tgoto on_error;\n\t\t    }\n\t\t    // Put the dict used on the dict stack, it might be used by\n\t\t    // a dict function later.\n\t\t    if (dict_stack_save(tv) == FAIL)\n\t\t\tgoto on_fatal_error;\n\n\t\t    copy_tv(&di->di_tv, tv);\n\t\t}\n\t\tbreak;\n\n\t    case ISN_CLEARDICT:\n\t\tdict_stack_drop();\n\t\tbreak;\n\n\t    case ISN_USEDICT:\n\t\t{\n\t\t    typval_T *dict_tv = dict_stack_get_tv();\n\n\t\t    // Turn \"dict.Func\" into a partial for \"Func\" bound to\n\t\t    // \"dict\".  Don't do this when \"Func\" is already a partial\n\t\t    // that was bound explicitly (pt_auto is FALSE).\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    if (dict_tv != NULL\n\t\t\t    && dict_tv->v_type == VAR_DICT\n\t\t\t    && dict_tv->vval.v_dict != NULL\n\t\t\t    && (tv->v_type == VAR_FUNC\n\t\t\t\t|| (tv->v_type == VAR_PARTIAL\n\t\t\t\t    && (tv->vval.v_partial->pt_auto\n\t\t\t\t     || tv->vval.v_partial->pt_dict == NULL))))\n\t\t    dict_tv->vval.v_dict =\n\t\t\t\t\tmake_partial(dict_tv->vval.v_dict, tv);\n\t\t    dict_stack_drop();\n\t\t}\n\t\tbreak;\n\n\t    case ISN_NEGATENR:\n\t\ttv = STACK_TV_BOT(-1);\n\t\tif (tv->v_type != VAR_NUMBER\n#ifdef FEAT_FLOAT\n\t\t\t&& tv->v_type != VAR_FLOAT\n#endif\n\t\t\t)\n\t\t{\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    emsg(_(e_number_expected));\n\t\t    goto on_error;\n\t\t}\n#ifdef FEAT_FLOAT\n\t\tif (tv->v_type == VAR_FLOAT)\n\t\t    tv->vval.v_float = -tv->vval.v_float;\n\t\telse\n#endif\n\t\t    tv->vval.v_number = -tv->vval.v_number;\n\t\tbreak;\n\n\t    case ISN_CHECKNR:\n\t\t{\n\t\t    int\t\terror = FALSE;\n\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    if (check_not_string(tv) == FAIL)\n\t\t\tgoto on_error;\n\t\t    (void)tv_get_number_chk(tv, &error);\n\t\t    if (error)\n\t\t\tgoto on_error;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_CHECKTYPE:\n\t\t{\n\t\t    checktype_T *ct = &iptr->isn_arg.type;\n\n\t\t    tv = STACK_TV_BOT((int)ct->ct_off);\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    if (!ectx->ec_where.wt_variable)\n\t\t\tectx->ec_where.wt_index = ct->ct_arg_idx;\n\t\t    if (check_typval_type(ct->ct_type, tv, ectx->ec_where)\n\t\t\t\t\t\t\t\t       == FAIL)\n\t\t\tgoto on_error;\n\t\t    if (!ectx->ec_where.wt_variable)\n\t\t\tectx->ec_where.wt_index = 0;\n\n\t\t    // number 0 is FALSE, number 1 is TRUE\n\t\t    if (tv->v_type == VAR_NUMBER\n\t\t\t    && ct->ct_type->tt_type == VAR_BOOL\n\t\t\t    && (tv->vval.v_number == 0\n\t\t\t\t\t\t|| tv->vval.v_number == 1))\n\t\t    {\n\t\t\ttv->v_type = VAR_BOOL;\n\t\t\ttv->vval.v_number = tv->vval.v_number\n\t\t\t\t\t\t      ? VVAL_TRUE : VVAL_FALSE;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    case ISN_CHECKLEN:\n\t\t{\n\t\t    int\t    min_len = iptr->isn_arg.checklen.cl_min_len;\n\t\t    list_T  *list = NULL;\n\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    if (tv->v_type == VAR_LIST)\n\t\t\t    list = tv->vval.v_list;\n\t\t    if (list == NULL || list->lv_len < min_len\n\t\t\t    || (list->lv_len > min_len\n\t\t\t\t\t&& !iptr->isn_arg.checklen.cl_more_OK))\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tsemsg(_(e_expected_nr_items_but_got_nr),\n\t\t\t\t     min_len, list == NULL ? 0 : list->lv_len);\n\t\t\tgoto on_error;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    case ISN_SETTYPE:\n\t\t{\n\t\t    checktype_T *ct = &iptr->isn_arg.type;\n\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    if (tv->v_type == VAR_DICT && tv->vval.v_dict != NULL)\n\t\t    {\n\t\t\tfree_type(tv->vval.v_dict->dv_type);\n\t\t\ttv->vval.v_dict->dv_type = alloc_type(ct->ct_type);\n\t\t    }\n\t\t    else if (tv->v_type == VAR_LIST && tv->vval.v_list != NULL)\n\t\t    {\n\t\t\tfree_type(tv->vval.v_list->lv_type);\n\t\t\ttv->vval.v_list->lv_type = alloc_type(ct->ct_type);\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    case ISN_2BOOL:\n\t    case ISN_COND2BOOL:\n\t\t{\n\t\t    int n;\n\t\t    int error = FALSE;\n\n\t\t    if (iptr->isn_type == ISN_2BOOL)\n\t\t    {\n\t\t\ttv = STACK_TV_BOT(iptr->isn_arg.tobool.offset);\n\t\t\tn = tv2bool(tv);\n\t\t\tif (iptr->isn_arg.tobool.invert)\n\t\t\t    n = !n;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\ttv = STACK_TV_BOT(-1);\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tn = tv_get_bool_chk(tv, &error);\n\t\t\tif (error)\n\t\t\t    goto on_error;\n\t\t    }\n\t\t    clear_tv(tv);\n\t\t    tv->v_type = VAR_BOOL;\n\t\t    tv->vval.v_number = n ? VVAL_TRUE : VVAL_FALSE;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_2STRING:\n\t    case ISN_2STRING_ANY:\n\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\tif (do_2string(STACK_TV_BOT(iptr->isn_arg.tostring.offset),\n\t\t\t\tiptr->isn_type == ISN_2STRING_ANY,\n\t\t\t\t      iptr->isn_arg.tostring.tolerant) == FAIL)\n\t\t\t    goto on_error;\n\t\tbreak;\n\n\t    case ISN_RANGE:\n\t\t{\n\t\t    exarg_T\tea;\n\t\t    char\t*errormsg;\n\n\t\t    ea.line2 = 0;\n\t\t    ea.addr_count = 0;\n\t\t    ea.addr_type = ADDR_LINES;\n\t\t    ea.cmd = iptr->isn_arg.string;\n\t\t    ea.skip = FALSE;\n\t\t    if (parse_cmd_address(&ea, &errormsg, FALSE) == FAIL)\n\t\t\tgoto on_error;\n\n\t\t    if (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\tgoto theend;\n\t\t    ++ectx->ec_stack.ga_len;\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    tv->v_type = VAR_NUMBER;\n\t\t    tv->v_lock = 0;\n\t\t    if (ea.addr_count == 0)\n\t\t\ttv->vval.v_number = curwin->w_cursor.lnum;\n\t\t    else\n\t\t\ttv->vval.v_number = ea.line2;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_PUT:\n\t\t{\n\t\t    int\t\tregname = iptr->isn_arg.put.put_regname;\n\t\t    linenr_T\tlnum = iptr->isn_arg.put.put_lnum;\n\t\t    char_u\t*expr = NULL;\n\t\t    int\t\tdir = FORWARD;\n\n\t\t    if (lnum < -2)\n\t\t    {\n\t\t\t// line number was put on the stack by ISN_RANGE\n\t\t\ttv = STACK_TV_BOT(-1);\n\t\t\tcurwin->w_cursor.lnum = tv->vval.v_number;\n\t\t\tif (lnum == LNUM_VARIABLE_RANGE_ABOVE)\n\t\t\t    dir = BACKWARD;\n\t\t\t--ectx->ec_stack.ga_len;\n\t\t    }\n\t\t    else if (lnum == -2)\n\t\t\t// :put! above cursor\n\t\t\tdir = BACKWARD;\n\t\t    else if (lnum >= 0)\n\t\t\tcurwin->w_cursor.lnum = iptr->isn_arg.put.put_lnum;\n\n\t\t    if (regname == '=')\n\t\t    {\n\t\t\ttv = STACK_TV_BOT(-1);\n\t\t\tif (tv->v_type == VAR_STRING)\n\t\t\t    expr = tv->vval.v_string;\n\t\t\telse\n\t\t\t{\n\t\t\t    expr = typval2string(tv, TRUE); // allocates value\n\t\t\t    clear_tv(tv);\n\t\t\t}\n\t\t\t--ectx->ec_stack.ga_len;\n\t\t    }\n\t\t    check_cursor();\n\t\t    do_put(regname, expr, dir, 1L, PUT_LINE|PUT_CURSLINE);\n\t\t    vim_free(expr);\n\t\t}\n\t\tbreak;\n\n\t    case ISN_CMDMOD:\n\t\tectx->ec_funclocal.floc_save_cmdmod = cmdmod;\n\t\tectx->ec_funclocal.floc_restore_cmdmod = TRUE;\n\t\tectx->ec_funclocal.floc_restore_cmdmod_stacklen =\n\t\t\t\t\t\t\t ectx->ec_stack.ga_len;\n\t\tcmdmod = *iptr->isn_arg.cmdmod.cf_cmdmod;\n\t\tapply_cmdmod(&cmdmod);\n\t\tbreak;\n\n\t    case ISN_CMDMOD_REV:\n\t\t// filter regprog is owned by the instruction, don't free it\n\t\tcmdmod.cmod_filter_regmatch.regprog = NULL;\n\t\tundo_cmdmod(&cmdmod);\n\t\tcmdmod = ectx->ec_funclocal.floc_save_cmdmod;\n\t\tectx->ec_funclocal.floc_restore_cmdmod = FALSE;\n\t\tbreak;\n\n\t    case ISN_UNPACK:\n\t\t{\n\t\t    int\t\tcount = iptr->isn_arg.unpack.unp_count;\n\t\t    int\t\tsemicolon = iptr->isn_arg.unpack.unp_semicolon;\n\t\t    list_T\t*l;\n\t\t    listitem_T\t*li;\n\t\t    int\t\ti;\n\n\t\t    // Check there is a valid list to unpack.\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    if (tv->v_type != VAR_LIST)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\temsg(_(e_for_argument_must_be_sequence_of_lists));\n\t\t\tgoto on_error;\n\t\t    }\n\t\t    l = tv->vval.v_list;\n\t\t    if (l == NULL\n\t\t\t\t|| l->lv_len < (semicolon ? count - 1 : count))\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\temsg(_(e_list_value_does_not_have_enough_items));\n\t\t\tgoto on_error;\n\t\t    }\n\t\t    else if (!semicolon && l->lv_len > count)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\temsg(_(e_list_value_has_more_items_than_targets));\n\t\t\tgoto on_error;\n\t\t    }\n\n\t\t    CHECK_LIST_MATERIALIZE(l);\n\t\t    if (GA_GROW_FAILS(&ectx->ec_stack, count - 1))\n\t\t\tgoto theend;\n\t\t    ectx->ec_stack.ga_len += count - 1;\n\n\t\t    // Variable after semicolon gets a list with the remaining\n\t\t    // items.\n\t\t    if (semicolon)\n\t\t    {\n\t\t\tlist_T\t*rem_list =\n\t\t\t\t  list_alloc_with_items(l->lv_len - count + 1);\n\n\t\t\tif (rem_list == NULL)\n\t\t\t    goto theend;\n\t\t\ttv = STACK_TV_BOT(-count);\n\t\t\ttv->vval.v_list = rem_list;\n\t\t\t++rem_list->lv_refcount;\n\t\t\ttv->v_lock = 0;\n\t\t\tli = l->lv_first;\n\t\t\tfor (i = 0; i < count - 1; ++i)\n\t\t\t    li = li->li_next;\n\t\t\tfor (i = 0; li != NULL; ++i)\n\t\t\t{\n\t\t\t    list_set_item(rem_list, i, &li->li_tv);\n\t\t\t    li = li->li_next;\n\t\t\t}\n\t\t\t--count;\n\t\t    }\n\n\t\t    // Produce the values in reverse order, first item last.\n\t\t    li = l->lv_first;\n\t\t    for (i = 0; i < count; ++i)\n\t\t    {\n\t\t\ttv = STACK_TV_BOT(-i - 1);\n\t\t\tcopy_tv(&li->li_tv, tv);\n\t\t\tli = li->li_next;\n\t\t    }\n\n\t\t    list_unref(l);\n\t\t}\n\t\tbreak;\n\n\t    case ISN_PROF_START:\n\t    case ISN_PROF_END:\n\t\t{\n#ifdef FEAT_PROFILE\n\t\t    funccall_T cookie;\n\t\t    ufunc_T\t    *cur_ufunc =\n\t\t\t\t    (((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t       + ectx->ec_dfunc_idx)->df_ufunc;\n\n\t\t    cookie.func = cur_ufunc;\n\t\t    if (iptr->isn_type == ISN_PROF_START)\n\t\t    {\n\t\t\tfunc_line_start(&cookie, iptr->isn_lnum);\n\t\t\t// if we get here the instruction is executed\n\t\t\tfunc_line_exec(&cookie);\n\t\t    }\n\t\t    else\n\t\t\tfunc_line_end(&cookie);\n#endif\n\t\t}\n\t\tbreak;\n\n\t    case ISN_DEBUG:\n\t\thandle_debug(iptr, ectx);\n\t\tbreak;\n\n\t    case ISN_SHUFFLE:\n\t\t{\n\t\t    typval_T\ttmp_tv;\n\t\t    int\t\titem = iptr->isn_arg.shuffle.shfl_item;\n\t\t    int\t\tup = iptr->isn_arg.shuffle.shfl_up;\n\n\t\t    tmp_tv = *STACK_TV_BOT(-item);\n\t\t    for ( ; up > 0 && item > 1; --up)\n\t\t    {\n\t\t\t*STACK_TV_BOT(-item) = *STACK_TV_BOT(-item + 1);\n\t\t\t--item;\n\t\t    }\n\t\t    *STACK_TV_BOT(-item) = tmp_tv;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_DROP:\n\t\t--ectx->ec_stack.ga_len;\n\t\tclear_tv(STACK_TV_BOT(0));\n\t\tectx->ec_where.wt_index = 0;\n\t\tectx->ec_where.wt_variable = FALSE;\n\t\tbreak;\n\t}\n\tcontinue;\n\nfunc_return:\n\t// Restore previous function. If the frame pointer is where we started\n\t// then there is none and we are done.\n\tif (ectx->ec_frame_idx == ectx->ec_initial_frame_idx)\n\t    goto done;\n\n\tif (func_return(ectx) == FAIL)\n\t    // only fails when out of memory\n\t    goto theend;\n\tcontinue;\n\non_error:\n\t// Jump here for an error that does not require aborting execution.\n\t// If \"emsg_silent\" is set then ignore the error, unless it was set\n\t// when calling the function.\n\tif (did_emsg_cumul + did_emsg == ectx->ec_did_emsg_before\n\t\t\t\t\t   && emsg_silent && did_emsg_def == 0)\n\t{\n\t    // If a sequence of instructions causes an error while \":silent!\"\n\t    // was used, restore the stack length and jump ahead to restoring\n\t    // the cmdmod.\n\t    if (ectx->ec_funclocal.floc_restore_cmdmod)\n\t    {\n\t\twhile (ectx->ec_stack.ga_len\n\t\t\t     > ectx->ec_funclocal.floc_restore_cmdmod_stacklen)\n\t\t{\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    clear_tv(STACK_TV_BOT(0));\n\t\t}\n\t\twhile (ectx->ec_instr[ectx->ec_iidx].isn_type != ISN_CMDMOD_REV)\n\t\t    ++ectx->ec_iidx;\n\t    }\n\t    continue;\n\t}\non_fatal_error:\n\t// Jump here for an error that messes up the stack.\n\t// If we are not inside a try-catch started here, abort execution.\n\tif (trylevel <= ectx->ec_trylevel_at_start)\n\t    goto theend;\n    }\n\ndone:\n    ret = OK;\ntheend:\n    dict_stack_clear(dict_stack_len_at_start);\n    ectx->ec_trylevel_at_start = save_trylevel_at_start;\n    return ret;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146781,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  PixelPacket *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  size_t Unknown6;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\n\n  /*\n     Open image file.\n   */\n  quantum_info=(QuantumInfo *) NULL;\n  image = AcquireImage(image_info);\n  image2 = (Image *) NULL;\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  clone_info=(ImageInfo *) NULL;\n  if(ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (strncmp(MATLAB_HDR.identific,\"MATLAB\",6) != 0)\n    {\n      image=ReadMATImageV4(image_info,image,exception);\n      if (image == NULL)\n        {\n          if ((image != image2) && (image2 != (Image *) NULL))\n            image2=DestroyImage(image2);\n          if (clone_info != (ImageInfo *) NULL)\n            clone_info=DestroyImageInfo(clone_info);\n          return((Image *) NULL);\n        }\n      goto END_OF_READING;\n    }\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\n        MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n    {\nMATLAB_KO:\n      if ((image != image2) && (image2 != (Image *) NULL))\n        image2=DestroyImage(image2);\n      if (clone_info != (ImageInfo *) NULL)\n        clone_info=DestroyImageInfo(clone_info);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n\n  filepos = TellBlob(image);\n  while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    if (filepos != (unsigned int) filepos)\n      break;\n    if(SeekBlob(image,filepos,SEEK_SET) != filepos) break;\n    /* printf(\"pos=%X\\n\",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) > GetBlobSize(image))\n      goto MATLAB_KO;\n    filepos += (MagickOffsetType) MATLAB_HDR.ObjectSize + 4 + 4;\n\n    if (clone_info != (ImageInfo *) NULL)\n      clone_info=DestroyImageInfo(clone_info);\n    clone_info=CloneImageInfo(image_info);\n    if ((image != image2) && (image2 != (Image *) NULL))\n      image2=DestroyImage(image2);\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif\n\n    if (MATLAB_HDR.DataType != miMATRIX)\n      {\n        clone_info=DestroyImageInfo(clone_info);\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n        if (image2 != image)\n          DeleteImageFromList(&image2);\n#endif\n        continue;  /* skip another objects. */\n      }\n\n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n\n\n    switch(MATLAB_HDR.DimFlag)\n    {\n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           Unknown6 = ReadBlobXXXLong(image2);\n           (void) Unknown6;\n         if(z!=3)\n           {\n             if (clone_info != (ImageInfo *) NULL)\n               clone_info=DestroyImageInfo(clone_info);\n             if ((image != image2) && (image2 != (Image *) NULL))\n               image2=DestroyImage(image2);\n             ThrowReaderException(CoderError,\n               \"MultidimensionalMatricesAreNotSupported\");\n           }\n         break;\n      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n         if(z!=3 && z!=1)\n           {\n             if (clone_info != (ImageInfo *) NULL)\n               clone_info=DestroyImageInfo(clone_info);\n             if ((image != image2) && (image2 != (Image *) NULL))\n               image2=DestroyImage(image2);\n             ThrowReaderException(CoderError,\n               \"MultidimensionalMatricesAreNotSupported\");\n           }\n         Frames = ReadBlobXXXLong(image2);\n         if (Frames == 0)\n           {\n             if (clone_info != (ImageInfo *) NULL)\n               clone_info=DestroyImageInfo(clone_info);\n             if ((image != image2) && (image2 != (Image *) NULL))\n               image2=DestroyImage(image2);\n             ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n           }\n          if (AcquireMagickResource(ListLengthResource,Frames) == MagickFalse)\n            {\n              if (clone_info != (ImageInfo *) NULL)\n                clone_info=DestroyImageInfo(clone_info);\n              if ((image != image2) && (image2 != (Image *) NULL))\n                image2=DestroyImage(image2);\n              ThrowReaderException(ResourceLimitError,\"ListLengthExceedsLimit\");\n            }\n         break;\n      default:\n        if (clone_info != (ImageInfo *) NULL)\n          clone_info=DestroyImageInfo(clone_info);\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n    }\n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      {\n        if ((image2 != (Image*) NULL) && (image2 != image))\n          {\n            CloseBlob(image2);\n            DeleteImageFromList(&image2);\n          }\n        if (clone_info != (ImageInfo *) NULL)\n          clone_info=DestroyImageInfo(clone_info);\n        ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n      }\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (((size_t) size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n\n    /* data size */\n    if (ReadBlob(image2, 4, (unsigned char *) &size) != 4)\n      goto MATLAB_KO;\n\nNEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;\n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n          {              /* complex float type cell */\n          }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64;\n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          {\n            if (clone_info != (ImageInfo *) NULL)\n              clone_info=DestroyImageInfo(clone_info);\n            if ((image != image2) && (image2 != (Image *) NULL))\n              image2=DestroyImage(image2);\n            ThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\n          }\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n          {                         /* complex double type cell */\n          }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        if (clone_info)\n          clone_info=DestroyImageInfo(clone_info);\n        ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;\n    image->colors = GetQuantumRange(image->depth);\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n    if((unsigned int)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)\n      goto MATLAB_KO;\n      /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        SetImageColorspace(image,GRAYColorspace);\n        image->type=GrayscaleType;\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        if (clone_info != (ImageInfo *) NULL)\n          clone_info=DestroyImageInfo(clone_info);\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    (void) SetImageBackgroundColor(image);\n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      {\n        if (clone_info != (ImageInfo *) NULL)\n          clone_info=DestroyImageInfo(clone_info);\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        if (quantum_info != (QuantumInfo *) NULL)\n          quantum_info=DestroyQuantumInfo(quantum_info);\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n\n  /* ----- Load raster data ----- */\n    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n    if (BImgBuff == NULL)\n      {\n        if (clone_info != (ImageInfo *) NULL)\n          clone_info=DestroyImageInfo(clone_info);\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    (void) memset(BImgBuff,0,ldblk*sizeof(double));\n\n    MinVal = 0;\n    MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n          {\n            if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n            goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n          }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n          {\n            if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n            goto ExitLoop;\n          }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n            {\n              ImportQuantumPixelsFailed:\n              if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n              break;\n            }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n            goto ImportQuantumPixelsFailed;\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n             (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n            FixSignedValues(q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n          {\n            if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n            goto ExitLoop;\n          }\n      }\n    } while(z-- >= 2);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n        {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          if (EOFBlob(image) != MagickFalse)\n            break;\n          InsertComplexDoubleRow((double *)BImgBuff, i, image, MinVal, MaxVal);\n        }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n        {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          if (EOFBlob(image) != MagickFalse)\n            break;\n          InsertComplexFloatRow((float *)BImgBuff, i, image, MinVal, MaxVal);\n        }\n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n      rotated_image->colors = image->colors;\n      DestroyBlob(rotated_image);\n      rotated_image->blob=ReferenceBlob(image->blob);\n      AppendImageToList(&image,rotated_image);\n      DeleteImageFromList(&image);\n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n          }\n        }\n      }\n    if (EOFBlob(image) != MagickFalse)\n      break;\n\n      /* Allocate next image structure. */\n    AcquireNextImage(image_info,image);\n    if (image->next == (Image *) NULL) break;\n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;\n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n    if (quantum_info != (QuantumInfo *) NULL)\n      quantum_info=DestroyQuantumInfo(quantum_info);\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      if(!EOFBlob(image) && TellBlob(image)<filepos)\n        goto NEXT_FRAME;\n    }\n\n    if(image2!=NULL)\n      if(image2!=image)   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) unlink(clone_info->filename);\n          }\n         }\n       }\n    if (clone_info)\n      clone_info=DestroyImageInfo(clone_info);\n  }\n\nEND_OF_READING:\n  RelinquishMagickMemory(BImgBuff);\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          if (tmp == image2)\n            image2=(Image *) NULL;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n  if ((image != image2) && (image2 != (Image *) NULL))\n    image2=DestroyImage(image2);\n  if (image == (Image *) NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\")\n  return(image);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146816,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  PixelPacket *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  size_t Unknown6;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\n\n  /*\n     Open image file.\n   */\n  quantum_info=(QuantumInfo *) NULL;\n  image = AcquireImage(image_info);\n  image2 = (Image *) NULL;\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  clone_info=(ImageInfo *) NULL;\n  if(ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (strncmp(MATLAB_HDR.identific,\"MATLAB\",6) != 0)\n    {\n      image=ReadMATImageV4(image_info,image,exception);\n      if (image == NULL)\n        {\n          if ((image != image2) && (image2 != (Image *) NULL))\n            image2=DestroyImage(image2);\n          if (clone_info != (ImageInfo *) NULL)\n            clone_info=DestroyImageInfo(clone_info);\n          return((Image *) NULL);\n        }\n      goto END_OF_READING;\n    }\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\n        MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n    {\nMATLAB_KO:\n      if ((image != image2) && (image2 != (Image *) NULL))\n        image2=DestroyImage(image2);\n      if (clone_info != (ImageInfo *) NULL)\n        clone_info=DestroyImageInfo(clone_info);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n\n  filepos = TellBlob(image);\n  while(filepos < GetBlobSize(image) && !EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    if(filepos > GetBlobSize(image) || filepos < 0)\n      break;\n    if(SeekBlob(image,filepos,SEEK_SET) != filepos) break;\n    /* printf(\"pos=%X\\n\",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) >= GetBlobSize(image))\n      goto MATLAB_KO;\n    filepos += (MagickOffsetType) MATLAB_HDR.ObjectSize + 4 + 4;\n\n    if (clone_info != (ImageInfo *) NULL)\n      clone_info=DestroyImageInfo(clone_info);\n    clone_info=CloneImageInfo(image_info);\n    if ((image != image2) && (image2 != (Image *) NULL))\n      image2=DestroyImage(image2);\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif\n\n    if (MATLAB_HDR.DataType != miMATRIX)\n      {\n        clone_info=DestroyImageInfo(clone_info);\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n        if (image2 != image)\n          DeleteImageFromList(&image2);\n#endif\n        continue;  /* skip another objects. */\n      }\n\n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n\n\n    switch(MATLAB_HDR.DimFlag)\n    {\n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           Unknown6 = ReadBlobXXXLong(image2);\n           (void) Unknown6;\n         if(z!=3)\n           {\n             if (clone_info != (ImageInfo *) NULL)\n               clone_info=DestroyImageInfo(clone_info);\n             if ((image != image2) && (image2 != (Image *) NULL))\n               image2=DestroyImage(image2);\n             ThrowReaderException(CoderError,\n               \"MultidimensionalMatricesAreNotSupported\");\n           }\n         break;\n      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n         if(z!=3 && z!=1)\n           {\n             if (clone_info != (ImageInfo *) NULL)\n               clone_info=DestroyImageInfo(clone_info);\n             if ((image != image2) && (image2 != (Image *) NULL))\n               image2=DestroyImage(image2);\n             ThrowReaderException(CoderError,\n               \"MultidimensionalMatricesAreNotSupported\");\n           }\n         Frames = ReadBlobXXXLong(image2);\n         if (Frames == 0)\n           {\n             if (clone_info != (ImageInfo *) NULL)\n               clone_info=DestroyImageInfo(clone_info);\n             if ((image != image2) && (image2 != (Image *) NULL))\n               image2=DestroyImage(image2);\n             ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n           }\n          if (AcquireMagickResource(ListLengthResource,Frames) == MagickFalse)\n            {\n              if (clone_info != (ImageInfo *) NULL)\n                clone_info=DestroyImageInfo(clone_info);\n              if ((image != image2) && (image2 != (Image *) NULL))\n                image2=DestroyImage(image2);\n              ThrowReaderException(ResourceLimitError,\"ListLengthExceedsLimit\");\n            }\n         break;\n      default:\n        if (clone_info != (ImageInfo *) NULL)\n          clone_info=DestroyImageInfo(clone_info);\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n    }\n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      {\n        if ((image2 != (Image*) NULL) && (image2 != image))\n          {\n            CloseBlob(image2);\n            DeleteImageFromList(&image2);\n          }\n        if (clone_info != (ImageInfo *) NULL)\n          clone_info=DestroyImageInfo(clone_info);\n        ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n      }\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (((size_t) size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n\n    /* data size */\n    if (ReadBlob(image2, 4, (unsigned char *) &size) != 4)\n      goto MATLAB_KO;\n\nNEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;\n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n          {              /* complex float type cell */\n          }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64;\n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          {\n            if (clone_info != (ImageInfo *) NULL)\n              clone_info=DestroyImageInfo(clone_info);\n            if ((image != image2) && (image2 != (Image *) NULL))\n              image2=DestroyImage(image2);\n            ThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\n          }\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n          {                         /* complex double type cell */\n          }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        if (clone_info)\n          clone_info=DestroyImageInfo(clone_info);\n        ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;\n    image->colors = GetQuantumRange(image->depth);\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n    if((unsigned int)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)\n      goto MATLAB_KO;\n      /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        SetImageColorspace(image,GRAYColorspace);\n        image->type=GrayscaleType;\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        if (clone_info != (ImageInfo *) NULL)\n          clone_info=DestroyImageInfo(clone_info);\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    (void) SetImageBackgroundColor(image);\n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      {\n        if (clone_info != (ImageInfo *) NULL)\n          clone_info=DestroyImageInfo(clone_info);\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        if (quantum_info != (QuantumInfo *) NULL)\n          quantum_info=DestroyQuantumInfo(quantum_info);\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n\n  /* ----- Load raster data ----- */\n    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n    if (BImgBuff == NULL)\n      {\n        if (clone_info != (ImageInfo *) NULL)\n          clone_info=DestroyImageInfo(clone_info);\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    (void) memset(BImgBuff,0,ldblk*sizeof(double));\n\n    MinVal = 0;\n    MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n          {\n            if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n            goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n          }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n          {\n            if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n            ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n            goto ExitLoop;\n          }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n            {\n              ImportQuantumPixelsFailed:\n              if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n              break;\n            }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n            goto ImportQuantumPixelsFailed;\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n             (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n            FixSignedValues(q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n          {\n            if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n            goto ExitLoop;\n          }\n      }\n    } while(z-- >= 2);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n        {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          if (EOFBlob(image) != MagickFalse)\n            break;\n          InsertComplexDoubleRow((double *)BImgBuff, i, image, MinVal, MaxVal);\n        }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n        {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          if (EOFBlob(image) != MagickFalse)\n            break;\n          InsertComplexFloatRow((float *)BImgBuff, i, image, MinVal, MaxVal);\n        }\n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n      rotated_image->colors = image->colors;\n      DestroyBlob(rotated_image);\n      rotated_image->blob=ReferenceBlob(image->blob);\n      AppendImageToList(&image,rotated_image);\n      DeleteImageFromList(&image);\n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n          }\n        }\n      }\n    if (EOFBlob(image) != MagickFalse)\n      break;\n\n      /* Allocate next image structure. */\n    AcquireNextImage(image_info,image);\n    if (image->next == (Image *) NULL) break;\n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;\n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n    if (quantum_info != (QuantumInfo *) NULL)\n      quantum_info=DestroyQuantumInfo(quantum_info);\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      if(!EOFBlob(image) && TellBlob(image)<filepos)\n        goto NEXT_FRAME;\n    }\n\n    if(image2!=NULL)\n      if(image2!=image)   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) unlink(clone_info->filename);\n          }\n         }\n       }\n    if (clone_info)\n      clone_info=DestroyImageInfo(clone_info);\n  }\n\nEND_OF_READING:\n  RelinquishMagickMemory(BImgBuff);\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          if (tmp == image2)\n            image2=(Image *) NULL;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n  if ((image != image2) && (image2 != (Image *) NULL))\n    image2=DestroyImage(image2);\n  if (image == (Image *) NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\")\n  return(image);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146817,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int pn533_usb_probe(struct usb_interface *interface,\n\t\t\tconst struct usb_device_id *id)\n{\n\tstruct pn533 *priv;\n\tstruct pn533_usb_phy *phy;\n\tstruct usb_host_interface *iface_desc;\n\tstruct usb_endpoint_descriptor *endpoint;\n\tint in_endpoint = 0;\n\tint out_endpoint = 0;\n\tint rc = -ENOMEM;\n\tint i;\n\tu32 protocols;\n\tenum pn533_protocol_type protocol_type = PN533_PROTO_REQ_ACK_RESP;\n\tstruct pn533_frame_ops *fops = NULL;\n\tunsigned char *in_buf;\n\tint in_buf_len = PN533_EXT_FRAME_HEADER_LEN +\n\t\t\t PN533_STD_FRAME_MAX_PAYLOAD_LEN +\n\t\t\t PN533_STD_FRAME_TAIL_LEN;\n\n\tphy = devm_kzalloc(&interface->dev, sizeof(*phy), GFP_KERNEL);\n\tif (!phy)\n\t\treturn -ENOMEM;\n\n\tin_buf = kzalloc(in_buf_len, GFP_KERNEL);\n\tif (!in_buf)\n\t\treturn -ENOMEM;\n\n\tphy->udev = usb_get_dev(interface_to_usbdev(interface));\n\tphy->interface = interface;\n\n\tiface_desc = interface->cur_altsetting;\n\tfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {\n\t\tendpoint = &iface_desc->endpoint[i].desc;\n\n\t\tif (!in_endpoint && usb_endpoint_is_bulk_in(endpoint))\n\t\t\tin_endpoint = endpoint->bEndpointAddress;\n\n\t\tif (!out_endpoint && usb_endpoint_is_bulk_out(endpoint))\n\t\t\tout_endpoint = endpoint->bEndpointAddress;\n\t}\n\n\tif (!in_endpoint || !out_endpoint) {\n\t\tnfc_err(&interface->dev,\n\t\t\t\"Could not find bulk-in or bulk-out endpoint\\n\");\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tphy->in_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tphy->out_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tphy->ack_urb = usb_alloc_urb(0, GFP_KERNEL);\n\n\tif (!phy->in_urb || !phy->out_urb || !phy->ack_urb)\n\t\tgoto error;\n\n\tusb_fill_bulk_urb(phy->in_urb, phy->udev,\n\t\t\t  usb_rcvbulkpipe(phy->udev, in_endpoint),\n\t\t\t  in_buf, in_buf_len, NULL, phy);\n\n\tusb_fill_bulk_urb(phy->out_urb, phy->udev,\n\t\t\t  usb_sndbulkpipe(phy->udev, out_endpoint),\n\t\t\t  NULL, 0, pn533_send_complete, phy);\n\tusb_fill_bulk_urb(phy->ack_urb, phy->udev,\n\t\t\t  usb_sndbulkpipe(phy->udev, out_endpoint),\n\t\t\t  NULL, 0, pn533_send_complete, phy);\n\n\tswitch (id->driver_info) {\n\tcase PN533_DEVICE_STD:\n\t\tprotocols = PN533_ALL_PROTOCOLS;\n\t\tbreak;\n\n\tcase PN533_DEVICE_PASORI:\n\t\tprotocols = PN533_NO_TYPE_B_PROTOCOLS;\n\t\tbreak;\n\n\tcase PN533_DEVICE_ACR122U:\n\t\tprotocols = PN533_NO_TYPE_B_PROTOCOLS;\n\t\tfops = &pn533_acr122_frame_ops;\n\t\tprotocol_type = PN533_PROTO_REQ_RESP,\n\n\t\trc = pn533_acr122_poweron_rdr(phy);\n\t\tif (rc < 0) {\n\t\t\tnfc_err(&interface->dev,\n\t\t\t\t\"Couldn't poweron the reader (error %d)\\n\", rc);\n\t\t\tgoto error;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tnfc_err(&interface->dev, \"Unknown device type %lu\\n\",\n\t\t\tid->driver_info);\n\t\trc = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tpriv = pn533_register_device(id->driver_info, protocols, protocol_type,\n\t\t\t\t\tphy, &usb_phy_ops, fops,\n\t\t\t\t\t&phy->udev->dev, &interface->dev);\n\n\tif (IS_ERR(priv)) {\n\t\trc = PTR_ERR(priv);\n\t\tgoto error;\n\t}\n\n\tphy->priv = priv;\n\n\trc = pn533_finalize_setup(priv);\n\tif (rc)\n\t\tgoto error;\n\n\tusb_set_intfdata(interface, phy);\n\n\treturn 0;\n\nerror:\n\tusb_free_urb(phy->in_urb);\n\tusb_free_urb(phy->out_urb);\n\tusb_free_urb(phy->ack_urb);\n\tusb_put_dev(phy->udev);\n\tkfree(in_buf);\n\n\treturn rc;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146856,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int pn533_usb_probe(struct usb_interface *interface,\n\t\t\tconst struct usb_device_id *id)\n{\n\tstruct pn533 *priv;\n\tstruct pn533_usb_phy *phy;\n\tstruct usb_host_interface *iface_desc;\n\tstruct usb_endpoint_descriptor *endpoint;\n\tint in_endpoint = 0;\n\tint out_endpoint = 0;\n\tint rc = -ENOMEM;\n\tint i;\n\tu32 protocols;\n\tenum pn533_protocol_type protocol_type = PN533_PROTO_REQ_ACK_RESP;\n\tstruct pn533_frame_ops *fops = NULL;\n\tunsigned char *in_buf;\n\tint in_buf_len = PN533_EXT_FRAME_HEADER_LEN +\n\t\t\t PN533_STD_FRAME_MAX_PAYLOAD_LEN +\n\t\t\t PN533_STD_FRAME_TAIL_LEN;\n\n\tphy = devm_kzalloc(&interface->dev, sizeof(*phy), GFP_KERNEL);\n\tif (!phy)\n\t\treturn -ENOMEM;\n\n\tin_buf = kzalloc(in_buf_len, GFP_KERNEL);\n\tif (!in_buf)\n\t\treturn -ENOMEM;\n\n\tphy->udev = usb_get_dev(interface_to_usbdev(interface));\n\tphy->interface = interface;\n\n\tiface_desc = interface->cur_altsetting;\n\tfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {\n\t\tendpoint = &iface_desc->endpoint[i].desc;\n\n\t\tif (!in_endpoint && usb_endpoint_is_bulk_in(endpoint))\n\t\t\tin_endpoint = endpoint->bEndpointAddress;\n\n\t\tif (!out_endpoint && usb_endpoint_is_bulk_out(endpoint))\n\t\t\tout_endpoint = endpoint->bEndpointAddress;\n\t}\n\n\tif (!in_endpoint || !out_endpoint) {\n\t\tnfc_err(&interface->dev,\n\t\t\t\"Could not find bulk-in or bulk-out endpoint\\n\");\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tphy->in_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tphy->out_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tphy->ack_urb = usb_alloc_urb(0, GFP_KERNEL);\n\n\tif (!phy->in_urb || !phy->out_urb || !phy->ack_urb)\n\t\tgoto error;\n\n\tusb_fill_bulk_urb(phy->in_urb, phy->udev,\n\t\t\t  usb_rcvbulkpipe(phy->udev, in_endpoint),\n\t\t\t  in_buf, in_buf_len, NULL, phy);\n\n\tusb_fill_bulk_urb(phy->out_urb, phy->udev,\n\t\t\t  usb_sndbulkpipe(phy->udev, out_endpoint),\n\t\t\t  NULL, 0, pn533_send_complete, phy);\n\tusb_fill_bulk_urb(phy->ack_urb, phy->udev,\n\t\t\t  usb_sndbulkpipe(phy->udev, out_endpoint),\n\t\t\t  NULL, 0, pn533_send_complete, phy);\n\n\tswitch (id->driver_info) {\n\tcase PN533_DEVICE_STD:\n\t\tprotocols = PN533_ALL_PROTOCOLS;\n\t\tbreak;\n\n\tcase PN533_DEVICE_PASORI:\n\t\tprotocols = PN533_NO_TYPE_B_PROTOCOLS;\n\t\tbreak;\n\n\tcase PN533_DEVICE_ACR122U:\n\t\tprotocols = PN533_NO_TYPE_B_PROTOCOLS;\n\t\tfops = &pn533_acr122_frame_ops;\n\t\tprotocol_type = PN533_PROTO_REQ_RESP,\n\n\t\trc = pn533_acr122_poweron_rdr(phy);\n\t\tif (rc < 0) {\n\t\t\tnfc_err(&interface->dev,\n\t\t\t\t\"Couldn't poweron the reader (error %d)\\n\", rc);\n\t\t\tgoto error;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tnfc_err(&interface->dev, \"Unknown device type %lu\\n\",\n\t\t\tid->driver_info);\n\t\trc = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tpriv = pn533_register_device(id->driver_info, protocols, protocol_type,\n\t\t\t\t\tphy, &usb_phy_ops, fops,\n\t\t\t\t\t&phy->udev->dev, &interface->dev);\n\n\tif (IS_ERR(priv)) {\n\t\trc = PTR_ERR(priv);\n\t\tgoto error;\n\t}\n\n\tphy->priv = priv;\n\n\trc = pn533_finalize_setup(priv);\n\tif (rc)\n\t\tgoto err_deregister;\n\n\tusb_set_intfdata(interface, phy);\n\n\treturn 0;\n\nerr_deregister:\n\tpn533_unregister_device(phy->priv);\nerror:\n\tusb_kill_urb(phy->in_urb);\n\tusb_kill_urb(phy->out_urb);\n\tusb_kill_urb(phy->ack_urb);\n\n\tusb_free_urb(phy->in_urb);\n\tusb_free_urb(phy->out_urb);\n\tusb_free_urb(phy->ack_urb);\n\tusb_put_dev(phy->udev);\n\tkfree(in_buf);\n\tkfree(phy->ack_buffer);\n\n\treturn rc;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146857,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "htmlParsePubidLiteral(htmlParserCtxtPtr ctxt) {\n    const xmlChar *q;\n    xmlChar *ret = NULL;\n    /*\n     * Name ::= (Letter | '_') (NameChar)*\n     */\n    if (CUR == '\"') {\n        NEXT;\n\tq = CUR_PTR;\n\twhile (IS_PUBIDCHAR_CH(CUR)) NEXT;\n\tif (CUR != '\"') {\n\t    htmlParseErr(ctxt, XML_ERR_LITERAL_NOT_FINISHED,\n\t                 \"Unfinished PubidLiteral\\n\", NULL, NULL);\n\t} else {\n\t    ret = xmlStrndup(q, CUR_PTR - q);\n\t    NEXT;\n\t}\n    } else if (CUR == '\\'') {\n        NEXT;\n\tq = CUR_PTR;\n\twhile ((IS_PUBIDCHAR_CH(CUR)) && (CUR != '\\''))\n\t    NEXT;\n\tif (CUR != '\\'') {\n\t    htmlParseErr(ctxt, XML_ERR_LITERAL_NOT_FINISHED,\n\t                 \"Unfinished PubidLiteral\\n\", NULL, NULL);\n\t} else {\n\t    ret = xmlStrndup(q, CUR_PTR - q);\n\t    NEXT;\n\t}\n    } else {\n\thtmlParseErr(ctxt, XML_ERR_LITERAL_NOT_STARTED,\n\t             \"PubidLiteral \\\" or ' expected\\n\", NULL, NULL);\n    }\n\n    return(ret);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146860,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "htmlParsePubidLiteral(htmlParserCtxtPtr ctxt) {\n    size_t len = 0, startPosition = 0;\n    xmlChar *ret = NULL;\n    /*\n     * Name ::= (Letter | '_') (NameChar)*\n     */\n    if (CUR == '\"') {\n        NEXT;\n\n        if (CUR_PTR < BASE_PTR)\n            return(ret);\n        startPosition = CUR_PTR - BASE_PTR;\n\n        while (IS_PUBIDCHAR_CH(CUR)) {\n            len++;\n            NEXT;\n        }\n\n\tif (CUR != '\"') {\n\t    htmlParseErr(ctxt, XML_ERR_LITERAL_NOT_FINISHED,\n\t                 \"Unfinished PubidLiteral\\n\", NULL, NULL);\n\t} else {\n\t    ret = xmlStrndup((BASE_PTR + startPosition), len);\n\t    NEXT;\n\t}\n    } else if (CUR == '\\'') {\n        NEXT;\n\n        if (CUR_PTR < BASE_PTR)\n            return(ret);\n        startPosition = CUR_PTR - BASE_PTR;\n\n        while ((IS_PUBIDCHAR_CH(CUR)) && (CUR != '\\'')){\n            len++;\n            NEXT;\n        }\n\n\tif (CUR != '\\'') {\n\t    htmlParseErr(ctxt, XML_ERR_LITERAL_NOT_FINISHED,\n\t                 \"Unfinished PubidLiteral\\n\", NULL, NULL);\n\t} else {\n\t    ret = xmlStrndup((BASE_PTR + startPosition), len);\n\t    NEXT;\n\t}\n    } else {\n\thtmlParseErr(ctxt, XML_ERR_LITERAL_NOT_STARTED,\n\t             \"PubidLiteral \\\" or ' expected\\n\", NULL, NULL);\n    }\n\n    return(ret);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146861,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": " */\nstatic void php_wddx_push_element(void *user_data, const XML_Char *name, const XML_Char **atts)\n{\n\tst_entry ent;\n\twddx_stack *stack = (wddx_stack *)user_data;\n\n\tif (!strcmp(name, EL_PACKET)) {\n\t\tint i;\n\n\t\tif (atts) for (i=0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_VERSION)) {\n\t\t\t\t/* nothing for now */\n\t\t\t}\n\t\t}\n\t} else if (!strcmp(name, EL_STRING)) {\n\t\tent.type = ST_STRING;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZ_TYPE_P(ent.data) = IS_STRING;\n\t\tZ_STRVAL_P(ent.data) = STR_EMPTY_ALLOC();\n\t\tZ_STRLEN_P(ent.data) = 0;\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_BINARY)) {\n\t\tent.type = ST_BINARY;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZ_TYPE_P(ent.data) = IS_STRING;\n\t\tZ_STRVAL_P(ent.data) = STR_EMPTY_ALLOC();\n\t\tZ_STRLEN_P(ent.data) = 0;\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_CHAR)) {\n\t\tint i;\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_CHAR_CODE) && atts[i+1] && atts[i+1][0]) {\n\t\t\t\tchar tmp_buf[2];\n\n\t\t\t\tsnprintf(tmp_buf, sizeof(tmp_buf), \"%c\", (char)strtol(atts[i+1], NULL, 16));\n\t\t\t\tphp_wddx_process_data(user_data, tmp_buf, strlen(tmp_buf));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else if (!strcmp(name, EL_NUMBER)) {\n\t\tent.type = ST_NUMBER;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZ_TYPE_P(ent.data) = IS_LONG;\n\t\tZ_LVAL_P(ent.data) = 0;\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_BOOLEAN)) {\n\t\tint i;\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_VALUE) && atts[i+1] && atts[i+1][0]) {\n\t\t\t\tent.type = ST_BOOLEAN;\n\t\t\t\tSET_STACK_VARNAME;\n\n\t\t\t\tALLOC_ZVAL(ent.data);\n\t\t\t\tINIT_PZVAL(ent.data);\n\t\t\t\tZ_TYPE_P(ent.data) = IS_BOOL;\n\t\t\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t\t\t\tphp_wddx_process_data(user_data, atts[i+1], strlen(atts[i+1]));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tent.type = ST_BOOLEAN;\n\t\t\tSET_STACK_VARNAME;\n\t\t\tZVAL_FALSE(&ent.data);\n\t\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t\t}\n\t} else if (!strcmp(name, EL_NULL)) {\n\t\tent.type = ST_NULL;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZVAL_NULL(ent.data);\n\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_ARRAY)) {\n\t\tent.type = ST_ARRAY;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tarray_init(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_STRUCT)) {\n\t\tent.type = ST_STRUCT;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tarray_init(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_VAR)) {\n\t\tint i;\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_NAME) && atts[i+1] && atts[i+1][0]) {\n\t\t\t\tif (stack->varname) efree(stack->varname);\n\t\t\t\tstack->varname = estrdup(atts[i+1]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else if (!strcmp(name, EL_RECORDSET)) {\n\t\tint i;\n\n\t\tent.type = ST_RECORDSET;\n\t\tSET_STACK_VARNAME;\n\t\tMAKE_STD_ZVAL(ent.data);\n\t\tarray_init(ent.data);\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], \"fieldNames\") && atts[i+1] && atts[i+1][0]) {\n\t\t\t\tzval *tmp;\n\t\t\t\tchar *key;\n\t\t\t\tchar *p1, *p2, *endp;\n\n\t\t\t\ti++;\n\t\t\t\tendp = (char *)atts[i] + strlen(atts[i]);\n\t\t\t\tp1 = (char *)atts[i];\n\t\t\t\twhile ((p2 = php_memnstr(p1, \",\", sizeof(\",\")-1, endp)) != NULL) {\n\t\t\t\t\tkey = estrndup(p1, p2 - p1);\n\t\t\t\t\tMAKE_STD_ZVAL(tmp);\n\t\t\t\t\tarray_init(tmp);\n\t\t\t\t\tadd_assoc_zval_ex(ent.data, key, p2 - p1 + 1, tmp);\n\t\t\t\t\tp1 = p2 + sizeof(\",\")-1;\n\t\t\t\t\tefree(key);\n\t\t\t\t}\n\n\t\t\t\tif (p1 <= endp) {\n\t\t\t\t\tMAKE_STD_ZVAL(tmp);\n\t\t\t\t\tarray_init(tmp);\n\t\t\t\t\tadd_assoc_zval_ex(ent.data, p1, endp - p1 + 1, tmp);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_FIELD)) {\n\t\tint i;\n\t\tst_entry ent;\n\n\t\tent.type = ST_FIELD;\n\t\tent.varname = NULL;\n\t\tent.data = NULL;\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_NAME) && atts[i+1] && atts[i+1][0]) {\n\t\t\t\tst_entry *recordset;\n\t\t\t\tzval **field;\n\n\t\t\t\tif (wddx_stack_top(stack, (void**)&recordset) == SUCCESS &&\n\t\t\t\t\trecordset->type == ST_RECORDSET &&\n\t\t\t\t\tzend_hash_find(Z_ARRVAL_P(recordset->data), (char*)atts[i+1], strlen(atts[i+1])+1, (void**)&field) == SUCCESS) {\n\t\t\t\t\tent.data = *field;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_DATETIME)) {\n\t\tent.type = ST_DATETIME;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZ_TYPE_P(ent.data) = IS_LONG;\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146932,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": " */\nstatic void php_wddx_push_element(void *user_data, const XML_Char *name, const XML_Char **atts)\n{\n\tst_entry ent;\n\twddx_stack *stack = (wddx_stack *)user_data;\n\n\tif (!strcmp(name, EL_PACKET)) {\n\t\tint i;\n\n\t\tif (atts) for (i=0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_VERSION)) {\n\t\t\t\t/* nothing for now */\n\t\t\t}\n\t\t}\n\t} else if (!strcmp(name, EL_STRING)) {\n\t\tent.type = ST_STRING;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZ_TYPE_P(ent.data) = IS_STRING;\n\t\tZ_STRVAL_P(ent.data) = STR_EMPTY_ALLOC();\n\t\tZ_STRLEN_P(ent.data) = 0;\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_BINARY)) {\n\t\tent.type = ST_BINARY;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZ_TYPE_P(ent.data) = IS_STRING;\n\t\tZ_STRVAL_P(ent.data) = STR_EMPTY_ALLOC();\n\t\tZ_STRLEN_P(ent.data) = 0;\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_CHAR)) {\n\t\tint i;\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_CHAR_CODE) && atts[i+1] && atts[i+1][0]) {\n\t\t\t\tchar tmp_buf[2];\n\n\t\t\t\tsnprintf(tmp_buf, sizeof(tmp_buf), \"%c\", (char)strtol(atts[i+1], NULL, 16));\n\t\t\t\tphp_wddx_process_data(user_data, tmp_buf, strlen(tmp_buf));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else if (!strcmp(name, EL_NUMBER)) {\n\t\tent.type = ST_NUMBER;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZ_TYPE_P(ent.data) = IS_LONG;\n\t\tZ_LVAL_P(ent.data) = 0;\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_BOOLEAN)) {\n\t\tint i;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZ_TYPE_P(ent.data) = IS_BOOL;\n\t\tent.type = ST_BOOLEAN;\n\t\tSET_STACK_VARNAME;\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_VALUE) && atts[i+1] && atts[i+1][0]) {\n\t\t\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t\t\t\tphp_wddx_process_data(user_data, atts[i+1], strlen(atts[i+1]));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tZVAL_FALSE(ent.data);\n\t\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t\t}\n\t} else if (!strcmp(name, EL_NULL)) {\n\t\tent.type = ST_NULL;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZVAL_NULL(ent.data);\n\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_ARRAY)) {\n\t\tent.type = ST_ARRAY;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tarray_init(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_STRUCT)) {\n\t\tent.type = ST_STRUCT;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tarray_init(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_VAR)) {\n\t\tint i;\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_NAME) && atts[i+1] && atts[i+1][0]) {\n\t\t\t\tif (stack->varname) efree(stack->varname);\n\t\t\t\tstack->varname = estrdup(atts[i+1]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else if (!strcmp(name, EL_RECORDSET)) {\n\t\tint i;\n\n\t\tent.type = ST_RECORDSET;\n\t\tSET_STACK_VARNAME;\n\t\tMAKE_STD_ZVAL(ent.data);\n\t\tarray_init(ent.data);\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], \"fieldNames\") && atts[i+1] && atts[i+1][0]) {\n\t\t\t\tzval *tmp;\n\t\t\t\tchar *key;\n\t\t\t\tchar *p1, *p2, *endp;\n\n\t\t\t\ti++;\n\t\t\t\tendp = (char *)atts[i] + strlen(atts[i]);\n\t\t\t\tp1 = (char *)atts[i];\n\t\t\t\twhile ((p2 = php_memnstr(p1, \",\", sizeof(\",\")-1, endp)) != NULL) {\n\t\t\t\t\tkey = estrndup(p1, p2 - p1);\n\t\t\t\t\tMAKE_STD_ZVAL(tmp);\n\t\t\t\t\tarray_init(tmp);\n\t\t\t\t\tadd_assoc_zval_ex(ent.data, key, p2 - p1 + 1, tmp);\n\t\t\t\t\tp1 = p2 + sizeof(\",\")-1;\n\t\t\t\t\tefree(key);\n\t\t\t\t}\n\n\t\t\t\tif (p1 <= endp) {\n\t\t\t\t\tMAKE_STD_ZVAL(tmp);\n\t\t\t\t\tarray_init(tmp);\n\t\t\t\t\tadd_assoc_zval_ex(ent.data, p1, endp - p1 + 1, tmp);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_FIELD)) {\n\t\tint i;\n\t\tst_entry ent;\n\n\t\tent.type = ST_FIELD;\n\t\tent.varname = NULL;\n\t\tent.data = NULL;\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_NAME) && atts[i+1] && atts[i+1][0]) {\n\t\t\t\tst_entry *recordset;\n\t\t\t\tzval **field;\n\n\t\t\t\tif (wddx_stack_top(stack, (void**)&recordset) == SUCCESS &&\n\t\t\t\t\trecordset->type == ST_RECORDSET &&\n\t\t\t\t\tzend_hash_find(Z_ARRVAL_P(recordset->data), (char*)atts[i+1], strlen(atts[i+1])+1, (void**)&field) == SUCCESS) {\n\t\t\t\t\tent.data = *field;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_DATETIME)) {\n\t\tent.type = ST_DATETIME;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZ_TYPE_P(ent.data) = IS_LONG;\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146933,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "get_futex_key(u32 __user *uaddr, int fshared, union futex_key *key, int rw)\n{\n\tunsigned long address = (unsigned long)uaddr;\n\tstruct mm_struct *mm = current->mm;\n\tstruct page *page;\n\tstruct address_space *mapping;\n\tint err, ro = 0;\n\n\t/*\n\t * The futex address must be \"naturally\" aligned.\n\t */\n\tkey->both.offset = address % PAGE_SIZE;\n\tif (unlikely((address % sizeof(u32)) != 0))\n\t\treturn -EINVAL;\n\taddress -= key->both.offset;\n\n\tif (unlikely(!access_ok(rw, uaddr, sizeof(u32))))\n\t\treturn -EFAULT;\n\n\tif (unlikely(should_fail_futex(fshared)))\n\t\treturn -EFAULT;\n\n\t/*\n\t * PROCESS_PRIVATE futexes are fast.\n\t * As the mm cannot disappear under us and the 'key' only needs\n\t * virtual address, we dont even have to find the underlying vma.\n\t * Note : We do have to check 'uaddr' is a valid user address,\n\t *        but access_ok() should be faster than find_vma()\n\t */\n\tif (!fshared) {\n\t\tkey->private.mm = mm;\n\t\tkey->private.address = address;\n\t\tget_futex_key_refs(key);  /* implies smp_mb(); (B) */\n\t\treturn 0;\n\t}\n\nagain:\n\t/* Ignore any VERIFY_READ mapping (futex common case) */\n\tif (unlikely(should_fail_futex(fshared)))\n\t\treturn -EFAULT;\n\n\terr = get_user_pages_fast(address, 1, 1, &page);\n\t/*\n\t * If write access is not required (eg. FUTEX_WAIT), try\n\t * and get read-only access.\n\t */\n\tif (err == -EFAULT && rw == VERIFY_READ) {\n\t\terr = get_user_pages_fast(address, 1, 0, &page);\n\t\tro = 1;\n\t}\n\tif (err < 0)\n\t\treturn err;\n\telse\n\t\terr = 0;\n\n\tlock_page(page);\n\t/*\n\t * If page->mapping is NULL, then it cannot be a PageAnon\n\t * page; but it might be the ZERO_PAGE or in the gate area or\n\t * in a special mapping (all cases which we are happy to fail);\n\t * or it may have been a good file page when get_user_pages_fast\n\t * found it, but truncated or holepunched or subjected to\n\t * invalidate_complete_page2 before we got the page lock (also\n\t * cases which we are happy to fail).  And we hold a reference,\n\t * so refcount care in invalidate_complete_page's remove_mapping\n\t * prevents drop_caches from setting mapping to NULL beneath us.\n\t *\n\t * The case we do have to guard against is when memory pressure made\n\t * shmem_writepage move it from filecache to swapcache beneath us:\n\t * an unlikely race, but we do need to retry for page->mapping.\n\t */\n\tmapping = compound_head(page)->mapping;\n\tif (!mapping) {\n\t\tint shmem_swizzled = PageSwapCache(page);\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\tif (shmem_swizzled)\n\t\t\tgoto again;\n\t\treturn -EFAULT;\n\t}\n\n\t/*\n\t * Private mappings are handled in a simple way.\n\t *\n\t * NOTE: When userspace waits on a MAP_SHARED mapping, even if\n\t * it's a read-only handle, it's expected that futexes attach to\n\t * the object not the particular process.\n\t */\n\tif (PageAnon(page)) {\n\t\t/*\n\t\t * A RO anonymous page will never change and thus doesn't make\n\t\t * sense for futex operations.\n\t\t */\n\t\tif (unlikely(should_fail_futex(fshared)) || ro) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tkey->both.offset |= FUT_OFF_MMSHARED; /* ref taken on mm */\n\t\tkey->private.mm = mm;\n\t\tkey->private.address = address;\n\t} else {\n\t\tkey->both.offset |= FUT_OFF_INODE; /* inode-based key */\n\t\tkey->shared.inode = mapping->host;\n\t\tkey->shared.pgoff = basepage_index(page);\n\t}\n\n\tget_futex_key_refs(key); /* implies smp_mb(); (B) */\n\nout:\n\tunlock_page(page);\n\tput_page(page);\n\treturn err;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146936,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "get_futex_key(u32 __user *uaddr, int fshared, union futex_key *key, int rw)\n{\n\tunsigned long address = (unsigned long)uaddr;\n\tstruct mm_struct *mm = current->mm;\n\tstruct page *page;\n\tstruct address_space *mapping;\n\tint err, ro = 0;\n\n\t/*\n\t * The futex address must be \"naturally\" aligned.\n\t */\n\tkey->both.offset = address % PAGE_SIZE;\n\tif (unlikely((address % sizeof(u32)) != 0))\n\t\treturn -EINVAL;\n\taddress -= key->both.offset;\n\n\tif (unlikely(!access_ok(rw, uaddr, sizeof(u32))))\n\t\treturn -EFAULT;\n\n\tif (unlikely(should_fail_futex(fshared)))\n\t\treturn -EFAULT;\n\n\t/*\n\t * PROCESS_PRIVATE futexes are fast.\n\t * As the mm cannot disappear under us and the 'key' only needs\n\t * virtual address, we dont even have to find the underlying vma.\n\t * Note : We do have to check 'uaddr' is a valid user address,\n\t *        but access_ok() should be faster than find_vma()\n\t */\n\tif (!fshared) {\n\t\tkey->private.mm = mm;\n\t\tkey->private.address = address;\n\t\tget_futex_key_refs(key);  /* implies smp_mb(); (B) */\n\t\treturn 0;\n\t}\n\nagain:\n\t/* Ignore any VERIFY_READ mapping (futex common case) */\n\tif (unlikely(should_fail_futex(fshared)))\n\t\treturn -EFAULT;\n\n\terr = get_user_pages_fast(address, 1, 1, &page);\n\t/*\n\t * If write access is not required (eg. FUTEX_WAIT), try\n\t * and get read-only access.\n\t */\n\tif (err == -EFAULT && rw == VERIFY_READ) {\n\t\terr = get_user_pages_fast(address, 1, 0, &page);\n\t\tro = 1;\n\t}\n\tif (err < 0)\n\t\treturn err;\n\telse\n\t\terr = 0;\n\n\t/*\n\t * The treatment of mapping from this point on is critical. The page\n\t * lock protects many things but in this context the page lock\n\t * stabilizes mapping, prevents inode freeing in the shared\n\t * file-backed region case and guards against movement to swap cache.\n\t *\n\t * Strictly speaking the page lock is not needed in all cases being\n\t * considered here and page lock forces unnecessarily serialization\n\t * From this point on, mapping will be re-verified if necessary and\n\t * page lock will be acquired only if it is unavoidable\n\t */\n\tpage = compound_head(page);\n\tmapping = READ_ONCE(page->mapping);\n\n\t/*\n\t * If page->mapping is NULL, then it cannot be a PageAnon\n\t * page; but it might be the ZERO_PAGE or in the gate area or\n\t * in a special mapping (all cases which we are happy to fail);\n\t * or it may have been a good file page when get_user_pages_fast\n\t * found it, but truncated or holepunched or subjected to\n\t * invalidate_complete_page2 before we got the page lock (also\n\t * cases which we are happy to fail).  And we hold a reference,\n\t * so refcount care in invalidate_complete_page's remove_mapping\n\t * prevents drop_caches from setting mapping to NULL beneath us.\n\t *\n\t * The case we do have to guard against is when memory pressure made\n\t * shmem_writepage move it from filecache to swapcache beneath us:\n\t * an unlikely race, but we do need to retry for page->mapping.\n\t */\n\tif (unlikely(!mapping)) {\n\t\tint shmem_swizzled;\n\n\t\t/*\n\t\t * Page lock is required to identify which special case above\n\t\t * applies. If this is really a shmem page then the page lock\n\t\t * will prevent unexpected transitions.\n\t\t */\n\t\tlock_page(page);\n\t\tshmem_swizzled = PageSwapCache(page) || page->mapping;\n\t\tunlock_page(page);\n\t\tput_page(page);\n\n\t\tif (shmem_swizzled)\n\t\t\tgoto again;\n\n\t\treturn -EFAULT;\n\t}\n\n\t/*\n\t * Private mappings are handled in a simple way.\n\t *\n\t * If the futex key is stored on an anonymous page, then the associated\n\t * object is the mm which is implicitly pinned by the calling process.\n\t *\n\t * NOTE: When userspace waits on a MAP_SHARED mapping, even if\n\t * it's a read-only handle, it's expected that futexes attach to\n\t * the object not the particular process.\n\t */\n\tif (PageAnon(page)) {\n\t\t/*\n\t\t * A RO anonymous page will never change and thus doesn't make\n\t\t * sense for futex operations.\n\t\t */\n\t\tif (unlikely(should_fail_futex(fshared)) || ro) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tkey->both.offset |= FUT_OFF_MMSHARED; /* ref taken on mm */\n\t\tkey->private.mm = mm;\n\t\tkey->private.address = address;\n\n\t\tget_futex_key_refs(key); /* implies smp_mb(); (B) */\n\n\t} else {\n\t\tstruct inode *inode;\n\n\t\t/*\n\t\t * The associated futex object in this case is the inode and\n\t\t * the page->mapping must be traversed. Ordinarily this should\n\t\t * be stabilised under page lock but it's not strictly\n\t\t * necessary in this case as we just want to pin the inode, not\n\t\t * update the radix tree or anything like that.\n\t\t *\n\t\t * The RCU read lock is taken as the inode is finally freed\n\t\t * under RCU. If the mapping still matches expectations then the\n\t\t * mapping->host can be safely accessed as being a valid inode.\n\t\t */\n\t\trcu_read_lock();\n\n\t\tif (READ_ONCE(page->mapping) != mapping) {\n\t\t\trcu_read_unlock();\n\t\t\tput_page(page);\n\n\t\t\tgoto again;\n\t\t}\n\n\t\tinode = READ_ONCE(mapping->host);\n\t\tif (!inode) {\n\t\t\trcu_read_unlock();\n\t\t\tput_page(page);\n\n\t\t\tgoto again;\n\t\t}\n\n\t\t/*\n\t\t * Take a reference unless it is about to be freed. Previously\n\t\t * this reference was taken by ihold under the page lock\n\t\t * pinning the inode in place so i_lock was unnecessary. The\n\t\t * only way for this check to fail is if the inode was\n\t\t * truncated in parallel so warn for now if this happens.\n\t\t *\n\t\t * We are not calling into get_futex_key_refs() in file-backed\n\t\t * cases, therefore a successful atomic_inc return below will\n\t\t * guarantee that get_futex_key() will still imply smp_mb(); (B).\n\t\t */\n\t\tif (WARN_ON_ONCE(!atomic_inc_not_zero(&inode->i_count))) {\n\t\t\trcu_read_unlock();\n\t\t\tput_page(page);\n\n\t\t\tgoto again;\n\t\t}\n\n\t\t/* Should be impossible but lets be paranoid for now */\n\t\tif (WARN_ON_ONCE(inode->i_mapping != mapping)) {\n\t\t\terr = -EFAULT;\n\t\t\trcu_read_unlock();\n\t\t\tiput(inode);\n\n\t\t\tgoto out;\n\t\t}\n\n\t\tkey->both.offset |= FUT_OFF_INODE; /* inode-based key */\n\t\tkey->shared.inode = inode;\n\t\tkey->shared.pgoff = basepage_index(page);\n\t\trcu_read_unlock();\n\t}\n\nout:\n\tput_page(page);\n\treturn err;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146937,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "int i915_gem_context_destroy_ioctl(struct drm_device *dev, void *data,\n\t\t\t\t   struct drm_file *file)\n{\n\tstruct drm_i915_gem_context_destroy *args = data;\n\tstruct drm_i915_file_private *file_priv = file->driver_priv;\n\tstruct i915_gem_context *ctx;\n\tint ret;\n\n\tif (args->pad != 0)\n\t\treturn -EINVAL;\n\n\tif (args->ctx_id == DEFAULT_CONTEXT_HANDLE)\n\t\treturn -ENOENT;\n\n\tctx = i915_gem_context_lookup(file_priv, args->ctx_id);\n\tif (!ctx)\n\t\treturn -ENOENT;\n\n\tret = mutex_lock_interruptible(&dev->struct_mutex);\n\tif (ret)\n\t\tgoto out;\n\n\tidr_remove(&file_priv->context_idr, ctx->user_handle);\n\tcontext_close(ctx);\n\n\tmutex_unlock(&dev->struct_mutex);\n\nout:\n\ti915_gem_context_put(ctx);\n\treturn 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146950,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "int i915_gem_context_destroy_ioctl(struct drm_device *dev, void *data,\n\t\t\t\t   struct drm_file *file)\n{\n\tstruct drm_i915_gem_context_destroy *args = data;\n\tstruct drm_i915_file_private *file_priv = file->driver_priv;\n\tstruct i915_gem_context *ctx;\n\n\tif (args->pad != 0)\n\t\treturn -EINVAL;\n\n\tif (args->ctx_id == DEFAULT_CONTEXT_HANDLE)\n\t\treturn -ENOENT;\n\n\tif (mutex_lock_interruptible(&file_priv->context_idr_lock))\n\t\treturn -EINTR;\n\n\tctx = idr_remove(&file_priv->context_idr, args->ctx_id);\n\tmutex_unlock(&file_priv->context_idr_lock);\n\tif (!ctx)\n\t\treturn -ENOENT;\n\n\tmutex_lock(&dev->struct_mutex);\n\tcontext_close(ctx);\n\tmutex_unlock(&dev->struct_mutex);\n\n\treturn 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146951,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "dbd_st_fetch(SV *sth, imp_sth_t* imp_sth)\n{\n  dTHX;\n  int num_fields, ChopBlanks, i, rc;\n  unsigned long *lengths;\n  AV *av;\n  int av_length, av_readonly;\n  MYSQL_ROW cols;\n  D_imp_dbh_from_sth;\n  MYSQL* svsock= imp_dbh->pmysql;\n  imp_sth_fbh_t *fbh;\n  D_imp_xxh(sth);\n#if MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n  MYSQL_BIND *buffer;\n#endif\n  MYSQL_FIELD *fields;\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t-> dbd_st_fetch\\n\");\n\n#if MYSQL_ASYNC\n  if(imp_dbh->async_query_in_flight) {\n      if(mysql_db_async_result(sth, &imp_sth->result) <= 0) {\n        return Nullav;\n      }\n  }\n#endif\n\n#if MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n  if (imp_sth->use_server_side_prepare)\n  {\n    if (!DBIc_ACTIVE(imp_sth) )\n    {\n      do_error(sth, JW_ERR_SEQUENCE, \"no statement executing\\n\",NULL);\n      return Nullav;\n    }\n\n    if (imp_sth->fetch_done)\n    {\n      do_error(sth, JW_ERR_SEQUENCE, \"fetch() but fetch already done\",NULL);\n      return Nullav;\n    }\n\n    if (!imp_sth->done_desc)\n    {\n      if (!dbd_describe(sth, imp_sth))\n      {\n        do_error(sth, JW_ERR_SEQUENCE, \"Error while describe result set.\",\n                 NULL);\n        return Nullav;\n      }\n    }\n  }\n#endif\n\n  ChopBlanks = DBIc_is(imp_sth, DBIcf_ChopBlanks);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                  \"\\t\\tdbd_st_fetch for %p, chopblanks %d\\n\",\n                  sth, ChopBlanks);\n\n  if (!imp_sth->result)\n  {\n    do_error(sth, JW_ERR_SEQUENCE, \"fetch() without execute()\" ,NULL);\n    return Nullav;\n  }\n\n  /* fix from 2.9008 */\n  imp_dbh->pmysql->net.last_errno = 0;\n\n#if MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n  if (imp_sth->use_server_side_prepare)\n  {\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tdbd_st_fetch calling mysql_fetch\\n\");\n\n    if ((rc= mysql_stmt_fetch(imp_sth->stmt)))\n    {\n      if (rc == 1)\n        do_error(sth, mysql_stmt_errno(imp_sth->stmt),\n                 mysql_stmt_error(imp_sth->stmt),\n                mysql_stmt_sqlstate(imp_sth->stmt));\n\n#if MYSQL_VERSION_ID >= MYSQL_VERSION_5_0 \n      if (rc == MYSQL_DATA_TRUNCATED) {\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tdbd_st_fetch data truncated\\n\");\n        goto process;\n      }\n#endif\n\n      if (rc == MYSQL_NO_DATA)\n      {\n        /* Update row_num to affected_rows value */\n        imp_sth->row_num= mysql_stmt_affected_rows(imp_sth->stmt);\n        imp_sth->fetch_done=1;\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tdbd_st_fetch no data\\n\");\n      }\n\n      dbd_st_finish(sth, imp_sth);\n\n      return Nullav;\n    }\n\nprocess:\n    imp_sth->currow++;\n\n    av= DBIc_DBISTATE(imp_sth)->get_fbav(imp_sth);\n    num_fields=mysql_stmt_field_count(imp_sth->stmt);\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                    \"\\t\\tdbd_st_fetch called mysql_fetch, rc %d num_fields %d\\n\",\n                    rc, num_fields);\n\n    for (\n         buffer= imp_sth->buffer,\n         fbh= imp_sth->fbh,\n         i= 0;\n         i < num_fields;\n         i++,\n         fbh++,\n         buffer++\n        )\n    {\n      SV *sv= AvARRAY(av)[i]; /* Note: we (re)use the SV in the AV\t*/\n      STRLEN len;\n\n      /* This is wrong, null is not being set correctly\n       * This is not the way to determine length (this would break blobs!)\n       */\n      if (fbh->is_null)\n        (void) SvOK_off(sv);  /*  Field is NULL, return undef  */\n      else\n      {\n        /* In case of BLOB/TEXT fields we allocate only 8192 bytes\n           in dbd_describe() for data. Here we know real size of field\n           so we should increase buffer size and refetch column value\n        */\n        if (fbh->length > buffer->buffer_length || fbh->error)\n        {\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n              \"\\t\\tRefetch BLOB/TEXT column: %d, length: %lu, error: %d\\n\",\n              i, fbh->length, fbh->error);\n\n          Renew(fbh->data, fbh->length, char);\n          buffer->buffer_length= fbh->length;\n          buffer->buffer= (char *) fbh->data;\n\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2) {\n            int j;\n            int m = MIN(*buffer->length, buffer->buffer_length);\n            char *ptr = (char*)buffer->buffer;\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"\\t\\tbefore buffer->buffer: \");\n            for (j = 0; j < m; j++) {\n              PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"%c\", *ptr++);\n            }\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"\\n\");\n          }\n\n          /*TODO: Use offset instead of 0 to fetch only remain part of data*/\n          if (mysql_stmt_fetch_column(imp_sth->stmt, buffer , i, 0))\n            do_error(sth, mysql_stmt_errno(imp_sth->stmt),\n                     mysql_stmt_error(imp_sth->stmt),\n                     mysql_stmt_sqlstate(imp_sth->stmt));\n\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2) {\n            int j;\n            int m = MIN(*buffer->length, buffer->buffer_length);\n            char *ptr = (char*)buffer->buffer;\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"\\t\\tafter buffer->buffer: \");\n            for (j = 0; j < m; j++) {\n              PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"%c\", *ptr++);\n            }\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"\\n\");\n          }\n        }\n\n        /* This does look a lot like Georg's PHP driver doesn't it?  --Brian */\n        /* Credit due to Georg - mysqli_api.c  ;) --PMG */\n        switch (buffer->buffer_type) {\n        case MYSQL_TYPE_DOUBLE:\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tst_fetch double data %f\\n\", fbh->ddata);\n          sv_setnv(sv, fbh->ddata);\n          break;\n\n        case MYSQL_TYPE_LONG:\n        case MYSQL_TYPE_LONGLONG:\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tst_fetch int data %\"IVdf\", unsigned? %d\\n\",\n                          fbh->ldata, buffer->is_unsigned);\n          if (buffer->is_unsigned)\n            sv_setuv(sv, fbh->ldata);\n          else\n            sv_setiv(sv, fbh->ldata);\n\n          break;\n\n        case MYSQL_TYPE_BIT:\n          sv_setpvn(sv, fbh->data, fbh->length);\n\n          break;\n\n        default:\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tERROR IN st_fetch_string\");\n          len= fbh->length;\n\t  /* ChopBlanks server-side prepared statement */\n          if (ChopBlanks)\n          {\n            /* \n              see bottom of:\n              http://www.mysql.org/doc/refman/5.0/en/c-api-datatypes.html\n            */\n            if (fbh->charsetnr != 63)\n              while (len && fbh->data[len-1] == ' ') { --len; }\n          }\n\t  /* END OF ChopBlanks */\n\n          sv_setpvn(sv, fbh->data, len);\n\n\t/* UTF8 */\n        /*HELMUT*/\n#if defined(sv_utf8_decode) && MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n\n#if MYSQL_VERSION_ID >= FIELD_CHARSETNR_VERSION \n  /* SHOW COLLATION WHERE Id = 63; -- 63 == charset binary, collation binary */\n        if ((imp_dbh->enable_utf8 || imp_dbh->enable_utf8mb4) && fbh->charsetnr != 63)\n#else\n\tif ((imp_dbh->enable_utf8 || imp_dbh->enable_utf8mb4) && !(fbh->flags & BINARY_FLAG))\n#endif\n\t  sv_utf8_decode(sv);\n#endif\n\t/* END OF UTF8 */\n          break;\n\n        }\n\n      }\n    }\n\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_fetch, %d cols\\n\", num_fields);\n\n    return av;\n  }\n  else\n  {\n#endif\n\n    imp_sth->currow++;\n\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    {\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tdbd_st_fetch result set details\\n\");\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\timp_sth->result=%p\\n\", imp_sth->result);\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tmysql_num_fields=%u\\n\",\n                    mysql_num_fields(imp_sth->result));\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tmysql_num_rows=%llu\\n\",\n                    mysql_num_rows(imp_sth->result));\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tmysql_affected_rows=%llu\\n\",\n                    mysql_affected_rows(imp_dbh->pmysql));\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tdbd_st_fetch for %p, currow= %d\\n\",\n                    sth,imp_sth->currow);\n    }\n\n    if (!(cols= mysql_fetch_row(imp_sth->result)))\n    {\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      {\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tdbd_st_fetch, no more rows to fetch\");\n      }\n      if (mysql_errno(imp_dbh->pmysql))\n        do_error(sth, mysql_errno(imp_dbh->pmysql),\n                 mysql_error(imp_dbh->pmysql),\n                 mysql_sqlstate(imp_dbh->pmysql));\n\n\n#if MYSQL_VERSION_ID >= MULTIPLE_RESULT_SET_VERSION\n      if (!mysql_more_results(svsock))\n#endif\n        dbd_st_finish(sth, imp_sth);\n      return Nullav;\n    }\n\n    num_fields= mysql_num_fields(imp_sth->result);\n    fields= mysql_fetch_fields(imp_sth->result);\n    lengths= mysql_fetch_lengths(imp_sth->result);\n\n    if ((av= DBIc_FIELDS_AV(imp_sth)) != Nullav)\n    {\n      av_length= av_len(av)+1;\n\n      if (av_length != num_fields)              /* Resize array if necessary */\n      {\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_fetch, size of results array(%d) != num_fields(%d)\\n\",\n                                   av_length, num_fields);\n\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_fetch, result fields(%d)\\n\",\n                                   DBIc_NUM_FIELDS(imp_sth));\n\n        av_readonly = SvREADONLY(av);\n\n        if (av_readonly)\n          SvREADONLY_off( av );              /* DBI sets this readonly */\n\n        while (av_length < num_fields)\n        {\n          av_store(av, av_length++, newSV(0));\n        }\n\n        while (av_length > num_fields)\n        {\n          SvREFCNT_dec(av_pop(av));\n          av_length--;\n        }\n        if (av_readonly)\n          SvREADONLY_on(av);\n      }\n    }\n\n    av= DBIc_DBISTATE(imp_sth)->get_fbav(imp_sth);\n\n    for (i= 0;  i < num_fields; ++i)\n    {\n      char *col= cols[i];\n      SV *sv= AvARRAY(av)[i]; /* Note: we (re)use the SV in the AV\t*/\n\n      if (col)\n      {\n        STRLEN len= lengths[i];\n        if (ChopBlanks)\n        {\n          while (len && col[len-1] == ' ')\n          {\t--len; }\n        }\n\n        /* Set string value returned from mysql server */\n        sv_setpvn(sv, col, len);\n\n        switch (mysql_to_perl_type(fields[i].type)) {\n        case MYSQL_TYPE_DOUBLE:\n          /* Coerce to dobule and set scalar as NV */\n          (void) SvNV(sv);\n          SvNOK_only(sv);\n          break;\n\n        case MYSQL_TYPE_LONG:\n        case MYSQL_TYPE_LONGLONG:\n          /* Coerce to integer and set scalar as UV resp. IV */\n          if (fields[i].flags & UNSIGNED_FLAG)\n          {\n            (void) SvUV(sv);\n            SvIOK_only_UV(sv);\n          }\n          else\n          {\n            (void) SvIV(sv);\n            SvIOK_only(sv);\n          }\n          break;\n\n#if MYSQL_VERSION_ID > NEW_DATATYPE_VERSION\n        case MYSQL_TYPE_BIT:\n          /* Let it as binary string */\n          break;\n#endif\n\n        default:\n\t/* UTF8 */\n        /*HELMUT*/\n#if defined(sv_utf8_decode) && MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n\n  /* see bottom of: http://www.mysql.org/doc/refman/5.0/en/c-api-datatypes.html */\n        if ((imp_dbh->enable_utf8 || imp_dbh->enable_utf8mb4) && fields[i].charsetnr != 63)\n\t  sv_utf8_decode(sv);\n#endif\n\t/* END OF UTF8 */\n          break;\n        }\n      }\n      else\n        (void) SvOK_off(sv);  /*  Field is NULL, return undef  */\n    }\n\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_fetch, %d cols\\n\", num_fields);\n    return av;\n\n#if MYSQL_VERSION_ID  >= SERVER_PREPARE_VERSION\n  }\n#endif\n\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147006,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "dbd_st_fetch(SV *sth, imp_sth_t* imp_sth)\n{\n  dTHX;\n  int num_fields, ChopBlanks, i, rc;\n  unsigned long *lengths;\n  AV *av;\n  int av_length, av_readonly;\n  MYSQL_ROW cols;\n  D_imp_dbh_from_sth;\n  MYSQL* svsock= imp_dbh->pmysql;\n  imp_sth_fbh_t *fbh;\n  D_imp_xxh(sth);\n#if MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n  MYSQL_BIND *buffer;\n#endif\n  MYSQL_FIELD *fields;\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t-> dbd_st_fetch\\n\");\n\n#if MYSQL_ASYNC\n  if(imp_dbh->async_query_in_flight) {\n      if(mysql_db_async_result(sth, &imp_sth->result) <= 0) {\n        return Nullav;\n      }\n  }\n#endif\n\n#if MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n  if (imp_sth->use_server_side_prepare)\n  {\n    if (!DBIc_ACTIVE(imp_sth) )\n    {\n      do_error(sth, JW_ERR_SEQUENCE, \"no statement executing\\n\",NULL);\n      return Nullav;\n    }\n\n    if (imp_sth->fetch_done)\n    {\n      do_error(sth, JW_ERR_SEQUENCE, \"fetch() but fetch already done\",NULL);\n      return Nullav;\n    }\n\n    if (!imp_sth->done_desc)\n    {\n      if (!dbd_describe(sth, imp_sth))\n      {\n        do_error(sth, JW_ERR_SEQUENCE, \"Error while describe result set.\",\n                 NULL);\n        return Nullav;\n      }\n    }\n  }\n#endif\n\n  ChopBlanks = DBIc_is(imp_sth, DBIcf_ChopBlanks);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                  \"\\t\\tdbd_st_fetch for %p, chopblanks %d\\n\",\n                  sth, ChopBlanks);\n\n  if (!imp_sth->result)\n  {\n    do_error(sth, JW_ERR_SEQUENCE, \"fetch() without execute()\" ,NULL);\n    return Nullav;\n  }\n\n  /* fix from 2.9008 */\n  imp_dbh->pmysql->net.last_errno = 0;\n\n#if MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n  if (imp_sth->use_server_side_prepare)\n  {\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tdbd_st_fetch calling mysql_fetch\\n\");\n\n    if ((rc= mysql_stmt_fetch(imp_sth->stmt)))\n    {\n      if (rc == 1)\n        do_error(sth, mysql_stmt_errno(imp_sth->stmt),\n                 mysql_stmt_error(imp_sth->stmt),\n                mysql_stmt_sqlstate(imp_sth->stmt));\n\n#if MYSQL_VERSION_ID >= MYSQL_VERSION_5_0 \n      if (rc == MYSQL_DATA_TRUNCATED) {\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tdbd_st_fetch data truncated\\n\");\n        goto process;\n      }\n#endif\n\n      if (rc == MYSQL_NO_DATA)\n      {\n        /* Update row_num to affected_rows value */\n        imp_sth->row_num= mysql_stmt_affected_rows(imp_sth->stmt);\n        imp_sth->fetch_done=1;\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tdbd_st_fetch no data\\n\");\n      }\n\n      dbd_st_finish(sth, imp_sth);\n\n      return Nullav;\n    }\n\nprocess:\n    imp_sth->currow++;\n\n    av= DBIc_DBISTATE(imp_sth)->get_fbav(imp_sth);\n    num_fields=mysql_stmt_field_count(imp_sth->stmt);\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                    \"\\t\\tdbd_st_fetch called mysql_fetch, rc %d num_fields %d\\n\",\n                    rc, num_fields);\n\n    for (\n         buffer= imp_sth->buffer,\n         fbh= imp_sth->fbh,\n         i= 0;\n         i < num_fields;\n         i++,\n         fbh++,\n         buffer++\n        )\n    {\n      SV *sv= AvARRAY(av)[i]; /* Note: we (re)use the SV in the AV\t*/\n      STRLEN len;\n\n      /* This is wrong, null is not being set correctly\n       * This is not the way to determine length (this would break blobs!)\n       */\n      if (fbh->is_null)\n        (void) SvOK_off(sv);  /*  Field is NULL, return undef  */\n      else\n      {\n        /* In case of BLOB/TEXT fields we allocate only 8192 bytes\n           in dbd_describe() for data. Here we know real size of field\n           so we should increase buffer size and refetch column value\n        */\n        if (fbh->length > buffer->buffer_length || fbh->error)\n        {\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n              \"\\t\\tRefetch BLOB/TEXT column: %d, length: %lu, error: %d\\n\",\n              i, fbh->length, fbh->error);\n\n          Renew(fbh->data, fbh->length, char);\n          buffer->buffer_length= fbh->length;\n          buffer->buffer= (char *) fbh->data;\n          imp_sth->stmt->bind[i].buffer_length = fbh->length;\n          imp_sth->stmt->bind[i].buffer = (char *)fbh->data;\n\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2) {\n            int j;\n            int m = MIN(*buffer->length, buffer->buffer_length);\n            char *ptr = (char*)buffer->buffer;\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"\\t\\tbefore buffer->buffer: \");\n            for (j = 0; j < m; j++) {\n              PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"%c\", *ptr++);\n            }\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"\\n\");\n          }\n\n          /*TODO: Use offset instead of 0 to fetch only remain part of data*/\n          if (mysql_stmt_fetch_column(imp_sth->stmt, buffer , i, 0))\n            do_error(sth, mysql_stmt_errno(imp_sth->stmt),\n                     mysql_stmt_error(imp_sth->stmt),\n                     mysql_stmt_sqlstate(imp_sth->stmt));\n\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2) {\n            int j;\n            int m = MIN(*buffer->length, buffer->buffer_length);\n            char *ptr = (char*)buffer->buffer;\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"\\t\\tafter buffer->buffer: \");\n            for (j = 0; j < m; j++) {\n              PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"%c\", *ptr++);\n            }\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"\\n\");\n          }\n        }\n\n        /* This does look a lot like Georg's PHP driver doesn't it?  --Brian */\n        /* Credit due to Georg - mysqli_api.c  ;) --PMG */\n        switch (buffer->buffer_type) {\n        case MYSQL_TYPE_DOUBLE:\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tst_fetch double data %f\\n\", fbh->ddata);\n          sv_setnv(sv, fbh->ddata);\n          break;\n\n        case MYSQL_TYPE_LONG:\n        case MYSQL_TYPE_LONGLONG:\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tst_fetch int data %\"IVdf\", unsigned? %d\\n\",\n                          fbh->ldata, buffer->is_unsigned);\n          if (buffer->is_unsigned)\n            sv_setuv(sv, fbh->ldata);\n          else\n            sv_setiv(sv, fbh->ldata);\n\n          break;\n\n        case MYSQL_TYPE_BIT:\n          sv_setpvn(sv, fbh->data, fbh->length);\n\n          break;\n\n        default:\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tERROR IN st_fetch_string\");\n          len= fbh->length;\n\t  /* ChopBlanks server-side prepared statement */\n          if (ChopBlanks)\n          {\n            /* \n              see bottom of:\n              http://www.mysql.org/doc/refman/5.0/en/c-api-datatypes.html\n            */\n            if (fbh->charsetnr != 63)\n              while (len && fbh->data[len-1] == ' ') { --len; }\n          }\n\t  /* END OF ChopBlanks */\n\n          sv_setpvn(sv, fbh->data, len);\n\n\t/* UTF8 */\n        /*HELMUT*/\n#if defined(sv_utf8_decode) && MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n\n#if MYSQL_VERSION_ID >= FIELD_CHARSETNR_VERSION \n  /* SHOW COLLATION WHERE Id = 63; -- 63 == charset binary, collation binary */\n        if ((imp_dbh->enable_utf8 || imp_dbh->enable_utf8mb4) && fbh->charsetnr != 63)\n#else\n\tif ((imp_dbh->enable_utf8 || imp_dbh->enable_utf8mb4) && !(fbh->flags & BINARY_FLAG))\n#endif\n\t  sv_utf8_decode(sv);\n#endif\n\t/* END OF UTF8 */\n          break;\n\n        }\n\n      }\n    }\n\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_fetch, %d cols\\n\", num_fields);\n\n    return av;\n  }\n  else\n  {\n#endif\n\n    imp_sth->currow++;\n\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    {\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tdbd_st_fetch result set details\\n\");\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\timp_sth->result=%p\\n\", imp_sth->result);\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tmysql_num_fields=%u\\n\",\n                    mysql_num_fields(imp_sth->result));\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tmysql_num_rows=%llu\\n\",\n                    mysql_num_rows(imp_sth->result));\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tmysql_affected_rows=%llu\\n\",\n                    mysql_affected_rows(imp_dbh->pmysql));\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tdbd_st_fetch for %p, currow= %d\\n\",\n                    sth,imp_sth->currow);\n    }\n\n    if (!(cols= mysql_fetch_row(imp_sth->result)))\n    {\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      {\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tdbd_st_fetch, no more rows to fetch\");\n      }\n      if (mysql_errno(imp_dbh->pmysql))\n        do_error(sth, mysql_errno(imp_dbh->pmysql),\n                 mysql_error(imp_dbh->pmysql),\n                 mysql_sqlstate(imp_dbh->pmysql));\n\n\n#if MYSQL_VERSION_ID >= MULTIPLE_RESULT_SET_VERSION\n      if (!mysql_more_results(svsock))\n#endif\n        dbd_st_finish(sth, imp_sth);\n      return Nullav;\n    }\n\n    num_fields= mysql_num_fields(imp_sth->result);\n    fields= mysql_fetch_fields(imp_sth->result);\n    lengths= mysql_fetch_lengths(imp_sth->result);\n\n    if ((av= DBIc_FIELDS_AV(imp_sth)) != Nullav)\n    {\n      av_length= av_len(av)+1;\n\n      if (av_length != num_fields)              /* Resize array if necessary */\n      {\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_fetch, size of results array(%d) != num_fields(%d)\\n\",\n                                   av_length, num_fields);\n\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_fetch, result fields(%d)\\n\",\n                                   DBIc_NUM_FIELDS(imp_sth));\n\n        av_readonly = SvREADONLY(av);\n\n        if (av_readonly)\n          SvREADONLY_off( av );              /* DBI sets this readonly */\n\n        while (av_length < num_fields)\n        {\n          av_store(av, av_length++, newSV(0));\n        }\n\n        while (av_length > num_fields)\n        {\n          SvREFCNT_dec(av_pop(av));\n          av_length--;\n        }\n        if (av_readonly)\n          SvREADONLY_on(av);\n      }\n    }\n\n    av= DBIc_DBISTATE(imp_sth)->get_fbav(imp_sth);\n\n    for (i= 0;  i < num_fields; ++i)\n    {\n      char *col= cols[i];\n      SV *sv= AvARRAY(av)[i]; /* Note: we (re)use the SV in the AV\t*/\n\n      if (col)\n      {\n        STRLEN len= lengths[i];\n        if (ChopBlanks)\n        {\n          while (len && col[len-1] == ' ')\n          {\t--len; }\n        }\n\n        /* Set string value returned from mysql server */\n        sv_setpvn(sv, col, len);\n\n        switch (mysql_to_perl_type(fields[i].type)) {\n        case MYSQL_TYPE_DOUBLE:\n          /* Coerce to dobule and set scalar as NV */\n          (void) SvNV(sv);\n          SvNOK_only(sv);\n          break;\n\n        case MYSQL_TYPE_LONG:\n        case MYSQL_TYPE_LONGLONG:\n          /* Coerce to integer and set scalar as UV resp. IV */\n          if (fields[i].flags & UNSIGNED_FLAG)\n          {\n            (void) SvUV(sv);\n            SvIOK_only_UV(sv);\n          }\n          else\n          {\n            (void) SvIV(sv);\n            SvIOK_only(sv);\n          }\n          break;\n\n#if MYSQL_VERSION_ID > NEW_DATATYPE_VERSION\n        case MYSQL_TYPE_BIT:\n          /* Let it as binary string */\n          break;\n#endif\n\n        default:\n\t/* UTF8 */\n        /*HELMUT*/\n#if defined(sv_utf8_decode) && MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n\n  /* see bottom of: http://www.mysql.org/doc/refman/5.0/en/c-api-datatypes.html */\n        if ((imp_dbh->enable_utf8 || imp_dbh->enable_utf8mb4) && fields[i].charsetnr != 63)\n\t  sv_utf8_decode(sv);\n#endif\n\t/* END OF UTF8 */\n          break;\n        }\n      }\n      else\n        (void) SvOK_off(sv);  /*  Field is NULL, return undef  */\n    }\n\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_fetch, %d cols\\n\", num_fields);\n    return av;\n\n#if MYSQL_VERSION_ID  >= SERVER_PREPARE_VERSION\n  }\n#endif\n\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147007,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "client_send_params(gnutls_session_t session,\n\t\t   gnutls_buffer_t extdata,\n\t\t   const gnutls_psk_client_credentials_t cred)\n{\n\tint ret, ext_offset = 0;\n\tuint8_t binder_value[MAX_HASH_SIZE];\n\tsize_t spos;\n\tgnutls_datum_t username = {NULL, 0};\n\tgnutls_datum_t user_key = {NULL, 0}, rkey = {NULL, 0};\n\tgnutls_datum_t client_hello;\n\tunsigned next_idx;\n\tconst mac_entry_st *prf_res = NULL;\n\tconst mac_entry_st *prf_psk = NULL;\n\tstruct timespec cur_time;\n\tuint32_t ticket_age, ob_ticket_age;\n\tint free_username = 0;\n\tpsk_auth_info_t info = NULL;\n\tunsigned psk_id_len = 0;\n\tunsigned binders_len, binders_pos;\n\ttls13_ticket_st *ticket = &session->internals.tls13_ticket;\n\n\tif (((session->internals.flags & GNUTLS_NO_TICKETS) ||\n\t    session->internals.tls13_ticket.ticket.data == NULL) &&\n\t    (!cred || !_gnutls_have_psk_credentials(cred, session))) {\n\n\t\treturn 0;\n\t}\n\n\tbinders_len = 0;\n\n\t/* placeholder to be filled later */\n\tspos = extdata->length;\n\tret = _gnutls_buffer_append_prefix(extdata, 16, 0);\n\tif (ret < 0)\n\t\treturn gnutls_assert_val(ret);\n\n\t/* First, let's see if we have a session ticket to send */\n\tif (!(session->internals.flags & GNUTLS_NO_TICKETS) &&\n\t    ticket->ticket.data != NULL) {\n\n\t\t/* We found a session ticket */\n\t\tif (unlikely(ticket->prf == NULL)) {\n\t\t\ttls13_ticket_deinit(ticket);\n\t\t\tret = gnutls_assert_val(GNUTLS_E_INTERNAL_ERROR);\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tprf_res = ticket->prf;\n\n\t\tgnutls_gettime(&cur_time);\n\t\tif (unlikely(_gnutls_timespec_cmp(&cur_time,\n\t\t\t\t\t\t  &ticket->arrival_time) < 0)) {\n\t\t\tgnutls_assert();\n\t\t\ttls13_ticket_deinit(ticket);\n\t\t\tgoto ignore_ticket;\n\t\t}\n\n\t\t/* Check whether the ticket is stale */\n\t\tticket_age = timespec_sub_ms(&cur_time, &ticket->arrival_time);\n\t\tif (ticket_age / 1000 > ticket->lifetime) {\n\t\t\ttls13_ticket_deinit(ticket);\n\t\t\tgoto ignore_ticket;\n\t\t}\n\n\t\tret = compute_psk_from_ticket(ticket, &rkey);\n\t\tif (ret < 0) {\n\t\t\ttls13_ticket_deinit(ticket);\n\t\t\tgoto ignore_ticket;\n\t\t}\n\n\t\t/* Calculate obfuscated ticket age, in milliseconds, mod 2^32 */\n\t\tob_ticket_age = ticket_age + ticket->age_add;\n\n\t\tif ((ret = _gnutls_buffer_append_data_prefix(extdata, 16,\n\t\t\t\t\t\t\t     ticket->ticket.data,\n\t\t\t\t\t\t\t     ticket->ticket.size)) < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* Now append the obfuscated ticket age */\n\t\tif ((ret = _gnutls_buffer_append_prefix(extdata, 32, ob_ticket_age)) < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tpsk_id_len += 6 + ticket->ticket.size;\n\t\tbinders_len += 1 + _gnutls_mac_get_algo_len(prf_res);\n\t}\n\n ignore_ticket:\n\tif (cred && _gnutls_have_psk_credentials(cred, session)) {\n\t\tgnutls_datum_t tkey;\n\n\t\tif (cred->binder_algo == NULL) {\n\t\t\tgnutls_assert();\n\t\t\tret = gnutls_assert_val(GNUTLS_E_INSUFFICIENT_CREDENTIALS);\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tprf_psk = cred->binder_algo;\n\n\t\tret = _gnutls_find_psk_key(session, cred, &username, &tkey, &free_username);\n\t\tif (ret < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif (username.size == 0 || username.size > UINT16_MAX) {\n\t\t\tret = gnutls_assert_val(GNUTLS_E_INVALID_PASSWORD);\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif (!free_username) {\n\t\t\t/* we need to copy the key */\n\t\t\tret = _gnutls_set_datum(&user_key, tkey.data, tkey.size);\n\t\t\tif (ret < 0) {\n\t\t\t\tgnutls_assert();\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t} else {\n\t\t\tuser_key.data = tkey.data;\n\t\t\tuser_key.size = tkey.size;\n\t\t}\n\n\t\tret = _gnutls_auth_info_init(session, GNUTLS_CRD_PSK, sizeof(psk_auth_info_st), 1);\n\t\tif (ret < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tinfo = _gnutls_get_auth_info(session, GNUTLS_CRD_PSK);\n\t\tassert(info != NULL);\n\n\t\t_gnutls_copy_psk_username(info, &username);\n\n\t\tif ((ret = _gnutls_buffer_append_data_prefix(extdata, 16,\n\t\t\t\t\t\t\t     username.data,\n\t\t\t\t\t\t\t     username.size)) < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* Now append the obfuscated ticket age */\n\t\tif ((ret = _gnutls_buffer_append_prefix(extdata, 32, 0)) < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tpsk_id_len += 6 + username.size;\n\t\tbinders_len += 1 + _gnutls_mac_get_algo_len(prf_psk);\n\t}\n\n\t/* if no tickets or identities to be sent */\n\tif (psk_id_len == 0) {\n\t\t/* reset extensions buffer */\n\t\textdata->length = spos;\n\t\treturn 0;\n\t}\n\n\t_gnutls_write_uint16(psk_id_len, &extdata->data[spos]);\n\n\tbinders_pos = extdata->length-spos;\n\text_offset = _gnutls_ext_get_extensions_offset(session);\n\n\t/* Compute the binders. extdata->data points to the start\n\t * of this client hello. */\n\tassert(extdata->length >= sizeof(mbuffer_st));\n\tassert(ext_offset >= (ssize_t)sizeof(mbuffer_st));\n\text_offset -= sizeof(mbuffer_st);\n\tclient_hello.data = extdata->data+sizeof(mbuffer_st);\n\tclient_hello.size = extdata->length-sizeof(mbuffer_st);\n\n\tnext_idx = 0;\n\n\tret = _gnutls_buffer_append_prefix(extdata, 16, binders_len);\n\tif (ret < 0) {\n\t\tgnutls_assert_val(ret);\n\t\tgoto cleanup;\n\t}\n\n\tif (prf_res && rkey.size > 0) {\n\t\tret = compute_psk_binder(session, prf_res,\n\t\t\t\t\t binders_len, binders_pos,\n\t\t\t\t\t ext_offset, &rkey, &client_hello, 1,\n\t\t\t\t\t binder_value);\n\t\tif (ret < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* Associate the selected pre-shared key with the session */\n\t\tgnutls_free(session->key.binders[next_idx].psk.data);\n\t\tsession->key.binders[next_idx].psk.data = rkey.data;\n\t\tsession->key.binders[next_idx].psk.size = rkey.size;\n\t\trkey.data = NULL;\n\n\t\tsession->key.binders[next_idx].prf = prf_res;\n\t\tsession->key.binders[next_idx].resumption = 1;\n\t\tsession->key.binders[next_idx].idx = next_idx;\n\n\t\t_gnutls_handshake_log(\"EXT[%p]: sent PSK resumption identity (%d)\\n\", session, next_idx);\n\n\t\tnext_idx++;\n\n\t\t/* Add the binder */\n\t\tret = _gnutls_buffer_append_data_prefix(extdata, 8, binder_value, prf_res->output_size);\n\t\tif (ret < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tsession->internals.hsk_flags |= HSK_TLS13_TICKET_SENT;\n\t}\n\n\tif (prf_psk && user_key.size > 0 && info) {\n\t\tret = compute_psk_binder(session, prf_psk,\n\t\t\t\t\t binders_len, binders_pos,\n\t\t\t\t\t ext_offset, &user_key, &client_hello, 0,\n\t\t\t\t\t binder_value);\n\t\tif (ret < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* Associate the selected pre-shared key with the session */\n\t\tgnutls_free(session->key.binders[next_idx].psk.data);\n\t\tsession->key.binders[next_idx].psk.data = user_key.data;\n\t\tsession->key.binders[next_idx].psk.size = user_key.size;\n\t\tuser_key.data = NULL;\n\n\t\tsession->key.binders[next_idx].prf = prf_psk;\n\t\tsession->key.binders[next_idx].resumption = 0;\n\t\tsession->key.binders[next_idx].idx = next_idx;\n\n\t\t_gnutls_handshake_log(\"EXT[%p]: sent PSK identity '%s' (%d)\\n\", session, info->username, next_idx);\n\n\t\tnext_idx++;\n\n\t\t/* Add the binder */\n\t\tret = _gnutls_buffer_append_data_prefix(extdata, 8, binder_value, prf_psk->output_size);\n\t\tif (ret < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tret = 0;\n\ncleanup:\n\tif (free_username)\n\t\t_gnutls_free_datum(&username);\n\n\t_gnutls_free_temp_key_datum(&user_key);\n\t_gnutls_free_temp_key_datum(&rkey);\n\n\treturn ret;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147038,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "client_send_params(gnutls_session_t session,\n\t\t   gnutls_buffer_t extdata,\n\t\t   const gnutls_psk_client_credentials_t cred)\n{\n\tint ret, ext_offset = 0;\n\tuint8_t binder_value[MAX_HASH_SIZE];\n\tsize_t spos;\n\tgnutls_datum_t username = {NULL, 0};\n\tgnutls_datum_t user_key = {NULL, 0}, rkey = {NULL, 0};\n\tunsigned client_hello_len;\n\tunsigned next_idx;\n\tconst mac_entry_st *prf_res = NULL;\n\tconst mac_entry_st *prf_psk = NULL;\n\tstruct timespec cur_time;\n\tuint32_t ticket_age, ob_ticket_age;\n\tint free_username = 0;\n\tpsk_auth_info_t info = NULL;\n\tunsigned psk_id_len = 0;\n\tunsigned binders_len, binders_pos;\n\ttls13_ticket_st *ticket = &session->internals.tls13_ticket;\n\n\tif (((session->internals.flags & GNUTLS_NO_TICKETS) ||\n\t    session->internals.tls13_ticket.ticket.data == NULL) &&\n\t    (!cred || !_gnutls_have_psk_credentials(cred, session))) {\n\n\t\treturn 0;\n\t}\n\n\tbinders_len = 0;\n\n\t/* placeholder to be filled later */\n\tspos = extdata->length;\n\tret = _gnutls_buffer_append_prefix(extdata, 16, 0);\n\tif (ret < 0)\n\t\treturn gnutls_assert_val(ret);\n\n\t/* First, let's see if we have a session ticket to send */\n\tif (!(session->internals.flags & GNUTLS_NO_TICKETS) &&\n\t    ticket->ticket.data != NULL) {\n\n\t\t/* We found a session ticket */\n\t\tif (unlikely(ticket->prf == NULL)) {\n\t\t\ttls13_ticket_deinit(ticket);\n\t\t\tret = gnutls_assert_val(GNUTLS_E_INTERNAL_ERROR);\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tprf_res = ticket->prf;\n\n\t\tgnutls_gettime(&cur_time);\n\t\tif (unlikely(_gnutls_timespec_cmp(&cur_time,\n\t\t\t\t\t\t  &ticket->arrival_time) < 0)) {\n\t\t\tgnutls_assert();\n\t\t\ttls13_ticket_deinit(ticket);\n\t\t\tgoto ignore_ticket;\n\t\t}\n\n\t\t/* Check whether the ticket is stale */\n\t\tticket_age = timespec_sub_ms(&cur_time, &ticket->arrival_time);\n\t\tif (ticket_age / 1000 > ticket->lifetime) {\n\t\t\ttls13_ticket_deinit(ticket);\n\t\t\tgoto ignore_ticket;\n\t\t}\n\n\t\tret = compute_psk_from_ticket(ticket, &rkey);\n\t\tif (ret < 0) {\n\t\t\ttls13_ticket_deinit(ticket);\n\t\t\tgoto ignore_ticket;\n\t\t}\n\n\t\t/* Calculate obfuscated ticket age, in milliseconds, mod 2^32 */\n\t\tob_ticket_age = ticket_age + ticket->age_add;\n\n\t\tif ((ret = _gnutls_buffer_append_data_prefix(extdata, 16,\n\t\t\t\t\t\t\t     ticket->ticket.data,\n\t\t\t\t\t\t\t     ticket->ticket.size)) < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* Now append the obfuscated ticket age */\n\t\tif ((ret = _gnutls_buffer_append_prefix(extdata, 32, ob_ticket_age)) < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tpsk_id_len += 6 + ticket->ticket.size;\n\t\tbinders_len += 1 + _gnutls_mac_get_algo_len(prf_res);\n\t}\n\n ignore_ticket:\n\tif (cred && _gnutls_have_psk_credentials(cred, session)) {\n\t\tgnutls_datum_t tkey;\n\n\t\tif (cred->binder_algo == NULL) {\n\t\t\tgnutls_assert();\n\t\t\tret = gnutls_assert_val(GNUTLS_E_INSUFFICIENT_CREDENTIALS);\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tprf_psk = cred->binder_algo;\n\n\t\tret = _gnutls_find_psk_key(session, cred, &username, &tkey, &free_username);\n\t\tif (ret < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif (username.size == 0 || username.size > UINT16_MAX) {\n\t\t\tret = gnutls_assert_val(GNUTLS_E_INVALID_PASSWORD);\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif (!free_username) {\n\t\t\t/* we need to copy the key */\n\t\t\tret = _gnutls_set_datum(&user_key, tkey.data, tkey.size);\n\t\t\tif (ret < 0) {\n\t\t\t\tgnutls_assert();\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t} else {\n\t\t\tuser_key.data = tkey.data;\n\t\t\tuser_key.size = tkey.size;\n\t\t}\n\n\t\tret = _gnutls_auth_info_init(session, GNUTLS_CRD_PSK, sizeof(psk_auth_info_st), 1);\n\t\tif (ret < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tinfo = _gnutls_get_auth_info(session, GNUTLS_CRD_PSK);\n\t\tassert(info != NULL);\n\n\t\t_gnutls_copy_psk_username(info, &username);\n\n\t\tif ((ret = _gnutls_buffer_append_data_prefix(extdata, 16,\n\t\t\t\t\t\t\t     username.data,\n\t\t\t\t\t\t\t     username.size)) < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* Now append the obfuscated ticket age */\n\t\tif ((ret = _gnutls_buffer_append_prefix(extdata, 32, 0)) < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tpsk_id_len += 6 + username.size;\n\t\tbinders_len += 1 + _gnutls_mac_get_algo_len(prf_psk);\n\t}\n\n\t/* if no tickets or identities to be sent */\n\tif (psk_id_len == 0) {\n\t\t/* reset extensions buffer */\n\t\textdata->length = spos;\n\t\treturn 0;\n\t}\n\n\t_gnutls_write_uint16(psk_id_len, &extdata->data[spos]);\n\n\tbinders_pos = extdata->length-spos;\n\text_offset = _gnutls_ext_get_extensions_offset(session);\n\n\t/* Compute the binders. extdata->data points to the start\n\t * of this client hello. */\n\tassert(extdata->length >= sizeof(mbuffer_st));\n\tassert(ext_offset >= (ssize_t)sizeof(mbuffer_st));\n\text_offset -= sizeof(mbuffer_st);\n\tclient_hello_len = extdata->length-sizeof(mbuffer_st);\n\n\tnext_idx = 0;\n\n\tret = _gnutls_buffer_append_prefix(extdata, 16, binders_len);\n\tif (ret < 0) {\n\t\tgnutls_assert_val(ret);\n\t\tgoto cleanup;\n\t}\n\n\tif (prf_res && rkey.size > 0) {\n\t\tgnutls_datum_t client_hello;\n\n\t\tclient_hello.data = extdata->data+sizeof(mbuffer_st);\n\t\tclient_hello.size = client_hello_len;\n\n\t\tret = compute_psk_binder(session, prf_res,\n\t\t\t\t\t binders_len, binders_pos,\n\t\t\t\t\t ext_offset, &rkey, &client_hello, 1,\n\t\t\t\t\t binder_value);\n\t\tif (ret < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* Associate the selected pre-shared key with the session */\n\t\tgnutls_free(session->key.binders[next_idx].psk.data);\n\t\tsession->key.binders[next_idx].psk.data = rkey.data;\n\t\tsession->key.binders[next_idx].psk.size = rkey.size;\n\t\trkey.data = NULL;\n\n\t\tsession->key.binders[next_idx].prf = prf_res;\n\t\tsession->key.binders[next_idx].resumption = 1;\n\t\tsession->key.binders[next_idx].idx = next_idx;\n\n\t\t_gnutls_handshake_log(\"EXT[%p]: sent PSK resumption identity (%d)\\n\", session, next_idx);\n\n\t\tnext_idx++;\n\n\t\t/* Add the binder */\n\t\tret = _gnutls_buffer_append_data_prefix(extdata, 8, binder_value, prf_res->output_size);\n\t\tif (ret < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tsession->internals.hsk_flags |= HSK_TLS13_TICKET_SENT;\n\t}\n\n\tif (prf_psk && user_key.size > 0 && info) {\n\t\tgnutls_datum_t client_hello;\n\n\t\tclient_hello.data = extdata->data+sizeof(mbuffer_st);\n\t\tclient_hello.size = client_hello_len;\n\n\t\tret = compute_psk_binder(session, prf_psk,\n\t\t\t\t\t binders_len, binders_pos,\n\t\t\t\t\t ext_offset, &user_key, &client_hello, 0,\n\t\t\t\t\t binder_value);\n\t\tif (ret < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* Associate the selected pre-shared key with the session */\n\t\tgnutls_free(session->key.binders[next_idx].psk.data);\n\t\tsession->key.binders[next_idx].psk.data = user_key.data;\n\t\tsession->key.binders[next_idx].psk.size = user_key.size;\n\t\tuser_key.data = NULL;\n\n\t\tsession->key.binders[next_idx].prf = prf_psk;\n\t\tsession->key.binders[next_idx].resumption = 0;\n\t\tsession->key.binders[next_idx].idx = next_idx;\n\n\t\t_gnutls_handshake_log(\"EXT[%p]: sent PSK identity '%s' (%d)\\n\", session, info->username, next_idx);\n\n\t\tnext_idx++;\n\n\t\t/* Add the binder */\n\t\tret = _gnutls_buffer_append_data_prefix(extdata, 8, binder_value, prf_psk->output_size);\n\t\tif (ret < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tret = 0;\n\ncleanup:\n\tif (free_username)\n\t\t_gnutls_free_datum(&username);\n\n\t_gnutls_free_temp_key_datum(&user_key);\n\t_gnutls_free_temp_key_datum(&rkey);\n\n\treturn ret;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147039,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  PixelPacket *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  size_t Unknown6;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\n\n  /*\n     Open image file.\n   */\n  quantum_info=(QuantumInfo *) NULL;\n  image = AcquireImage(image_info);\n  image2 = (Image *) NULL;\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  clone_info=(ImageInfo *) NULL;\n  if(ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (strncmp(MATLAB_HDR.identific,\"MATLAB\",6) != 0)\n    {\n      image=ReadMATImageV4(image_info,image,exception);\n      if (image == NULL)\n        {\n          if ((image != image2) && (image2 != (Image *) NULL))\n            image2=DestroyImage(image2);\n          if (clone_info != (ImageInfo *) NULL)\n            clone_info=DestroyImageInfo(clone_info);\n          return((Image *) NULL);\n        }\n      goto END_OF_READING;\n    }\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\n        MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n    {\nMATLAB_KO:\n      if ((image != image2) && (image2 != (Image *) NULL))\n        image2=DestroyImage(image2);\n      if (clone_info != (ImageInfo *) NULL)\n        clone_info=DestroyImageInfo(clone_info);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n\n  filepos = TellBlob(image);\n  while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    if(SeekBlob(image,filepos,SEEK_SET) != filepos) break;\n    /* printf(\"pos=%X\\n\",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) > GetBlobSize(image))\n      goto MATLAB_KO;\n    filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n\n    if (clone_info != (ImageInfo *) NULL)\n      clone_info=DestroyImageInfo(clone_info);\n    clone_info=CloneImageInfo(image_info);\n    if ((image != image2) && (image2 != (Image *) NULL))\n      image2=DestroyImage(image2);\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif\n\n    if (MATLAB_HDR.DataType != miMATRIX)\n      {\n        clone_info=DestroyImageInfo(clone_info);\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n        if (image2 != image)\n          DeleteImageFromList(&image2);\n#endif\n        continue;  /* skip another objects. */\n      }\n\n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n\n\n    switch(MATLAB_HDR.DimFlag)\n    {\n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           Unknown6 = ReadBlobXXXLong(image2);\n           (void) Unknown6;\n         if(z!=3)\n           {\n             if (clone_info != (ImageInfo *) NULL)\n               clone_info=DestroyImageInfo(clone_info);\n             if ((image != image2) && (image2 != (Image *) NULL))\n               image2=DestroyImage(image2);\n             ThrowReaderException(CoderError,\n               \"MultidimensionalMatricesAreNotSupported\");\n           }\n         break;\n      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n         if(z!=3 && z!=1)\n           {\n             if (clone_info != (ImageInfo *) NULL)\n               clone_info=DestroyImageInfo(clone_info);\n             if ((image != image2) && (image2 != (Image *) NULL))\n               image2=DestroyImage(image2);\n             ThrowReaderException(CoderError,\n               \"MultidimensionalMatricesAreNotSupported\");\n           }\n         Frames = ReadBlobXXXLong(image2);\n         if (Frames == 0)\n           {\n             if (clone_info != (ImageInfo *) NULL)\n               clone_info=DestroyImageInfo(clone_info);\n             if ((image != image2) && (image2 != (Image *) NULL))\n               image2=DestroyImage(image2);\n             ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n           }\n          if (AcquireMagickResource(ListLengthResource,Frames) == MagickFalse)\n            {\n              if (clone_info != (ImageInfo *) NULL)\n                clone_info=DestroyImageInfo(clone_info);\n              if ((image != image2) && (image2 != (Image *) NULL))\n                image2=DestroyImage(image2);\n              ThrowReaderException(ResourceLimitError,\"ListLengthExceedsLimit\");\n            }\n         break;\n      default:\n        if (clone_info != (ImageInfo *) NULL)\n          clone_info=DestroyImageInfo(clone_info);\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n    }\n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      {\n        if (image2 != (Image *) NULL)\n          {\n            CloseBlob(image2);\n            DeleteImageFromList(&image2);\n          }\n        if (clone_info != (ImageInfo *) NULL)\n          clone_info=DestroyImageInfo(clone_info);\n        ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n      }\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n\n    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */\n\nNEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;\n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n          {              /* complex float type cell */\n          }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64;\n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          {\n            if (clone_info != (ImageInfo *) NULL)\n              clone_info=DestroyImageInfo(clone_info);\n            if ((image != image2) && (image2 != (Image *) NULL))\n              image2=DestroyImage(image2);\n            ThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\n          }\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n          {                         /* complex double type cell */\n          }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        if (clone_info)\n          clone_info=DestroyImageInfo(clone_info);\n        ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;\n    image->colors = GetQuantumRange(image->depth);\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n    if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)\n      goto MATLAB_KO;\n      /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        SetImageColorspace(image,GRAYColorspace);\n        image->type=GrayscaleType;\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        if (clone_info != (ImageInfo *) NULL)\n          clone_info=DestroyImageInfo(clone_info);\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    (void) SetImageBackgroundColor(image);\n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      {\n        if (clone_info != (ImageInfo *) NULL)\n          clone_info=DestroyImageInfo(clone_info);\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        if (quantum_info != (QuantumInfo *) NULL)\n          quantum_info=DestroyQuantumInfo(quantum_info);\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n\n  /* ----- Load raster data ----- */\n    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n    if (BImgBuff == NULL)\n      {\n        if (clone_info != (ImageInfo *) NULL)\n          clone_info=DestroyImageInfo(clone_info);\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    (void) memset(BImgBuff,0,ldblk*sizeof(double));\n\n    MinVal = 0;\n    MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n          {\n            if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n            goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n          }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n          {\n            if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n            goto ExitLoop;\n          }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n            {\n              ImportQuantumPixelsFailed:\n              if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n              break;\n            }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n            goto ImportQuantumPixelsFailed;\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n             (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n            FixSignedValues(q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n          {\n            if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n            goto ExitLoop;\n          }\n      }\n    } while(z-- >= 2);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n        {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          InsertComplexDoubleRow((double *)BImgBuff, i, image, MinVal, MaxVal);\n        }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n        {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          InsertComplexFloatRow((float *)BImgBuff, i, image, MinVal, MaxVal);\n        }\n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n      rotated_image->colors = image->colors;\n      DestroyBlob(rotated_image);\n      rotated_image->blob=ReferenceBlob(image->blob);\n      AppendImageToList(&image,rotated_image);\n      DeleteImageFromList(&image);\n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n          }\n        }\n      }\n    if (EOFBlob(image) != MagickFalse)\n      break;\n\n      /* Allocate next image structure. */\n    AcquireNextImage(image_info,image);\n    if (image->next == (Image *) NULL) break;\n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;\n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n    if (quantum_info != (QuantumInfo *) NULL)\n      quantum_info=DestroyQuantumInfo(quantum_info);\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      if(!EOFBlob(image) && TellBlob(image)<filepos)\n        goto NEXT_FRAME;\n    }\n\n    if(image2!=NULL)\n      if(image2!=image)   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) unlink(clone_info->filename);\n          }\n         }\n       }\n    if (clone_info)\n      clone_info=DestroyImageInfo(clone_info);\n  }\n\n  RelinquishMagickMemory(BImgBuff);\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\nEND_OF_READING:\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          if (tmp == image2)\n            image2=(Image *) NULL;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n  if ((image != image2) && (image2 != (Image *) NULL))\n    image2=DestroyImage(image2);\n  if (image == (Image *) NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\")\n  return(image);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147058,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  PixelPacket *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  size_t Unknown6;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\n\n  /*\n     Open image file.\n   */\n  quantum_info=(QuantumInfo *) NULL;\n  image = AcquireImage(image_info);\n  image2 = (Image *) NULL;\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  clone_info=(ImageInfo *) NULL;\n  if(ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (strncmp(MATLAB_HDR.identific,\"MATLAB\",6) != 0)\n    {\n      image=ReadMATImageV4(image_info,image,exception);\n      if (image == NULL)\n        {\n          if ((image != image2) && (image2 != (Image *) NULL))\n            image2=DestroyImage(image2);\n          if (clone_info != (ImageInfo *) NULL)\n            clone_info=DestroyImageInfo(clone_info);\n          return((Image *) NULL);\n        }\n      goto END_OF_READING;\n    }\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\n        MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n    {\nMATLAB_KO:\n      if ((image != image2) && (image2 != (Image *) NULL))\n        image2=DestroyImage(image2);\n      if (clone_info != (ImageInfo *) NULL)\n        clone_info=DestroyImageInfo(clone_info);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n\n  filepos = TellBlob(image);\n  while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    if(SeekBlob(image,filepos,SEEK_SET) != filepos) break;\n    /* printf(\"pos=%X\\n\",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) > GetBlobSize(image))\n      goto MATLAB_KO;\n    filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n\n    if (clone_info != (ImageInfo *) NULL)\n      clone_info=DestroyImageInfo(clone_info);\n    clone_info=CloneImageInfo(image_info);\n    if ((image != image2) && (image2 != (Image *) NULL))\n      image2=DestroyImage(image2);\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif\n\n    if (MATLAB_HDR.DataType != miMATRIX)\n      {\n        clone_info=DestroyImageInfo(clone_info);\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n        if (image2 != image)\n          DeleteImageFromList(&image2);\n#endif\n        continue;  /* skip another objects. */\n      }\n\n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n\n\n    switch(MATLAB_HDR.DimFlag)\n    {\n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           Unknown6 = ReadBlobXXXLong(image2);\n           (void) Unknown6;\n         if(z!=3)\n           {\n             if (clone_info != (ImageInfo *) NULL)\n               clone_info=DestroyImageInfo(clone_info);\n             if ((image != image2) && (image2 != (Image *) NULL))\n               image2=DestroyImage(image2);\n             ThrowReaderException(CoderError,\n               \"MultidimensionalMatricesAreNotSupported\");\n           }\n         break;\n      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n         if(z!=3 && z!=1)\n           {\n             if (clone_info != (ImageInfo *) NULL)\n               clone_info=DestroyImageInfo(clone_info);\n             if ((image != image2) && (image2 != (Image *) NULL))\n               image2=DestroyImage(image2);\n             ThrowReaderException(CoderError,\n               \"MultidimensionalMatricesAreNotSupported\");\n           }\n         Frames = ReadBlobXXXLong(image2);\n         if (Frames == 0)\n           {\n             if (clone_info != (ImageInfo *) NULL)\n               clone_info=DestroyImageInfo(clone_info);\n             if ((image != image2) && (image2 != (Image *) NULL))\n               image2=DestroyImage(image2);\n             ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n           }\n          if (AcquireMagickResource(ListLengthResource,Frames) == MagickFalse)\n            {\n              if (clone_info != (ImageInfo *) NULL)\n                clone_info=DestroyImageInfo(clone_info);\n              if ((image != image2) && (image2 != (Image *) NULL))\n                image2=DestroyImage(image2);\n              ThrowReaderException(ResourceLimitError,\"ListLengthExceedsLimit\");\n            }\n         break;\n      default:\n        if (clone_info != (ImageInfo *) NULL)\n          clone_info=DestroyImageInfo(clone_info);\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n    }\n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      {\n        if ((image2 != (Image*) NULL) && (image2 != image))\n          {\n            CloseBlob(image2);\n            DeleteImageFromList(&image2);\n          }\n        if (clone_info != (ImageInfo *) NULL)\n          clone_info=DestroyImageInfo(clone_info);\n        ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n      }\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n\n    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */\n\nNEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;\n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n          {              /* complex float type cell */\n          }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64;\n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          {\n            if (clone_info != (ImageInfo *) NULL)\n              clone_info=DestroyImageInfo(clone_info);\n            if ((image != image2) && (image2 != (Image *) NULL))\n              image2=DestroyImage(image2);\n            ThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\n          }\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n          {                         /* complex double type cell */\n          }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        if (clone_info)\n          clone_info=DestroyImageInfo(clone_info);\n        ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;\n    image->colors = GetQuantumRange(image->depth);\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n    if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)\n      goto MATLAB_KO;\n      /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        SetImageColorspace(image,GRAYColorspace);\n        image->type=GrayscaleType;\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        if (clone_info != (ImageInfo *) NULL)\n          clone_info=DestroyImageInfo(clone_info);\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    (void) SetImageBackgroundColor(image);\n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      {\n        if (clone_info != (ImageInfo *) NULL)\n          clone_info=DestroyImageInfo(clone_info);\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        if (quantum_info != (QuantumInfo *) NULL)\n          quantum_info=DestroyQuantumInfo(quantum_info);\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n\n  /* ----- Load raster data ----- */\n    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n    if (BImgBuff == NULL)\n      {\n        if (clone_info != (ImageInfo *) NULL)\n          clone_info=DestroyImageInfo(clone_info);\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    (void) memset(BImgBuff,0,ldblk*sizeof(double));\n\n    MinVal = 0;\n    MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n          {\n            if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n            goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n          }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n          {\n            if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n            goto ExitLoop;\n          }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n            {\n              ImportQuantumPixelsFailed:\n              if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n              break;\n            }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n            goto ImportQuantumPixelsFailed;\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n             (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n            FixSignedValues(q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n          {\n            if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n            goto ExitLoop;\n          }\n      }\n    } while(z-- >= 2);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n        {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          InsertComplexDoubleRow((double *)BImgBuff, i, image, MinVal, MaxVal);\n        }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n        {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          InsertComplexFloatRow((float *)BImgBuff, i, image, MinVal, MaxVal);\n        }\n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n      rotated_image->colors = image->colors;\n      DestroyBlob(rotated_image);\n      rotated_image->blob=ReferenceBlob(image->blob);\n      AppendImageToList(&image,rotated_image);\n      DeleteImageFromList(&image);\n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n          }\n        }\n      }\n    if (EOFBlob(image) != MagickFalse)\n      break;\n\n      /* Allocate next image structure. */\n    AcquireNextImage(image_info,image);\n    if (image->next == (Image *) NULL) break;\n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;\n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n    if (quantum_info != (QuantumInfo *) NULL)\n      quantum_info=DestroyQuantumInfo(quantum_info);\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      if(!EOFBlob(image) && TellBlob(image)<filepos)\n        goto NEXT_FRAME;\n    }\n\n    if(image2!=NULL)\n      if(image2!=image)   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) unlink(clone_info->filename);\n          }\n         }\n       }\n    if (clone_info)\n      clone_info=DestroyImageInfo(clone_info);\n  }\n\n  RelinquishMagickMemory(BImgBuff);\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\nEND_OF_READING:\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          if (tmp == image2)\n            image2=(Image *) NULL;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n  if ((image != image2) && (image2 != (Image *) NULL))\n    image2=DestroyImage(image2);\n  if (image == (Image *) NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\")\n  return(image);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147059,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static Image *ReadWMFImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  double\n    bounding_height,\n    bounding_width,\n    image_height,\n    image_height_inch,\n    image_width,\n    image_width_inch,\n    resolution_y,\n    resolution_x,\n    units_per_inch;\n\n  float\n    wmf_width,\n    wmf_height;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  unsigned long\n    wmf_options_flags = 0;\n\n  wmf_error_t\n    wmf_error;\n\n  wmf_magick_t\n    *ddata = 0;\n\n  wmfAPI\n    *API = 0;\n\n  wmfAPI_Options\n    wmf_api_options;\n\n  wmfD_Rect\n    bbox;\n\n  image=AcquireImage(image_info,exception);\n  if (OpenBlob(image_info,image,ReadBinaryBlobMode,exception) == MagickFalse)\n    {\n      if (image->debug != MagickFalse)\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  OpenBlob failed\");\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"leave ReadWMFImage()\");\n        }\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n\n  /*\n   * Create WMF API\n   *\n   */\n\n  /* Register callbacks */\n  wmf_options_flags |= WMF_OPT_FUNCTION;\n  (void) ResetMagickMemory(&wmf_api_options, 0, sizeof(wmf_api_options));\n  wmf_api_options.function = ipa_functions;\n\n  /* Ignore non-fatal errors */\n  wmf_options_flags |= WMF_OPT_IGNORE_NONFATAL;\n\n  wmf_error = wmf_api_create(&API, wmf_options_flags, &wmf_api_options);\n  if (wmf_error != wmf_E_None)\n    {\n      if (API)\n        wmf_api_destroy(API);\n      if (image->debug != MagickFalse)\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  wmf_api_create failed\");\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"leave ReadWMFImage()\");\n        }\n      ThrowReaderException(DelegateError,\"UnableToInitializeWMFLibrary\");\n    }\n\n  /* Register progress monitor */\n  wmf_status_function(API,image,magick_progress_callback);\n\n  ddata=WMF_MAGICK_GetData(API);\n  ddata->image=image;\n  ddata->image_info=image_info;\n  ddata->draw_info=CloneDrawInfo(image_info,(const DrawInfo *) NULL);\n  ddata->exception=exception;\n  ddata->draw_info->font=(char *)\n    RelinquishMagickMemory(ddata->draw_info->font);\n  ddata->draw_info->text=(char *)\n    RelinquishMagickMemory(ddata->draw_info->text);\n\n#if defined(MAGICKCORE_WMF_DELEGATE)\n  /* Must initialize font subystem for WMFlite interface */\n  lite_font_init (API,&wmf_api_options); /* similar to wmf_ipa_font_init in src/font.c */\n  /* wmf_arg_fontdirs (API,options); */ /* similar to wmf_arg_fontdirs in src/wmf.c */\n\n#endif\n\n  /*\n   * Open BLOB input via libwmf API\n   *\n   */\n  wmf_error = wmf_bbuf_input(API,ipa_blob_read,ipa_blob_seek,\n    ipa_blob_tell,(void*)image);\n  if (wmf_error != wmf_E_None)\n    {\n      wmf_api_destroy(API);\n      if (image->debug != MagickFalse)\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  wmf_bbuf_input failed\");\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"leave ReadWMFImage()\");\n        }\n      ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",\n        image->filename);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n\n  /*\n   * Scan WMF file\n   *\n   */\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Scanning WMF to obtain bounding box\");\n  wmf_error=wmf_scan(API, 0, &bbox);\n  if (wmf_error != wmf_E_None)\n    {\n      wmf_api_destroy(API);\n      if (ddata->draw_info != (DrawInfo *) NULL)\n        {\n          DestroyDrawInfo(ddata->draw_info);\n          ddata->draw_info=(DrawInfo *)NULL;\n        }\n      if (image->debug != MagickFalse)\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  wmf_scan failed with wmf_error %d\", wmf_error);\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"leave ReadWMFImage()\");\n        }\n      ThrowReaderException(DelegateError,\"FailedToScanFile\");\n    }\n\n  /*\n   * Compute dimensions and scale factors\n   *\n   */\n\n  ddata->bbox=bbox;\n\n  /* User specified resolution */\n  resolution_y=DefaultResolution;\n  if (image->resolution.y != 0.0)\n    {\n      resolution_y = image->resolution.y;\n      if (image->units == PixelsPerCentimeterResolution)\n        resolution_y *= CENTIMETERS_PER_INCH;\n    }\n  resolution_x=DefaultResolution;\n  if (image->resolution.x != 0.0)\n    {\n      resolution_x = image->resolution.x;\n      if (image->units == PixelsPerCentimeterResolution)\n        resolution_x *= CENTIMETERS_PER_INCH;\n    }\n\n  /* Obtain output size expressed in metafile units */\n  wmf_error=wmf_size(API,&wmf_width,&wmf_height);\n  if (wmf_error != wmf_E_None)\n    {\n      wmf_api_destroy(API);\n      if (image->debug != MagickFalse)\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  wmf_size failed with wmf_error %d\", wmf_error);\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"leave ReadWMFImage()\");\n        }\n      ThrowReaderException(DelegateError,\"FailedToComputeOutputSize\");\n    }\n\n  /* Obtain (or guess) metafile units */\n  if ((API)->File->placeable)\n    units_per_inch=(API)->File->pmh->Inch;\n  else if ( (wmf_width*wmf_height) < 1024*1024)\n    units_per_inch=POINTS_PER_INCH;  /* MM_TEXT */\n  else\n    units_per_inch=TWIPS_PER_INCH;  /* MM_TWIPS */\n\n  /* Calculate image width and height based on specified DPI\n     resolution */\n  image_width_inch  = (double) wmf_width / units_per_inch;\n  image_height_inch = (double) wmf_height / units_per_inch;\n  image_width       = image_width_inch * resolution_x;\n  image_height      = image_height_inch * resolution_y;\n\n  /* Compute bounding box scale factors and origin translations\n   *\n   * This all just a hack since libwmf does not currently seem to\n   * provide the mapping between LOGICAL coordinates and DEVICE\n   * coordinates. This mapping is necessary in order to know\n   * where to place the logical bounding box within the image.\n   *\n   */\n\n  bounding_width  = bbox.BR.x - bbox.TL.x;\n  bounding_height = bbox.BR.y - bbox.TL.y;\n\n  ddata->scale_x = image_width/bounding_width;\n  ddata->translate_x = 0-bbox.TL.x;\n  ddata->rotate = 0;\n\n  /* Heuristic: guess that if the vertical coordinates mostly span\n     negative values, then the image must be inverted. */\n  if ( fabs(bbox.BR.y) > fabs(bbox.TL.y) )\n    {\n      /* Normal (Origin at top left of image) */\n      ddata->scale_y = (image_height/bounding_height);\n      ddata->translate_y = 0-bbox.TL.y;\n    }\n  else\n    {\n      /* Inverted (Origin at bottom left of image) */\n      ddata->scale_y = (-image_height/bounding_height);\n      ddata->translate_y = 0-bbox.BR.y;\n    }\n\n  if (image->debug != MagickFalse)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n         \"  Placeable metafile:          %s\",\n         (API)->File->placeable ? \"Yes\" : \"No\");\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Size in metafile units:      %gx%g\",wmf_width,wmf_height);\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Metafile units/inch:         %g\",units_per_inch);\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Size in inches:              %gx%g\",\n        image_width_inch,image_height_inch);\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Bounding Box:                %g,%g %g,%g\",\n        bbox.TL.x, bbox.TL.y, bbox.BR.x, bbox.BR.y);\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Bounding width x height:     %gx%g\",bounding_width,\n        bounding_height);\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Output resolution:           %gx%g\",resolution_x,resolution_y);\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Image size:                  %gx%g\",image_width,image_height);\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Bounding box scale factor:   %g,%g\",ddata->scale_x,\n        ddata->scale_y);\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Translation:                 %g,%g\",\n        ddata->translate_x, ddata->translate_y);\n    }\n\n#if 0\n#if 0\n  {\n    typedef struct _wmfPlayer_t wmfPlayer_t;\n    struct _wmfPlayer_t\n    {\n      wmfPen   default_pen;\n      wmfBrush default_brush;\n      wmfFont  default_font;\n\n      wmfDC* dc; /* current dc */\n    };\n\n    wmfDC\n      *dc;\n\n#define WMF_ELICIT_DC(API) (((wmfPlayer_t*)((API)->player_data))->dc)\n\n    dc = WMF_ELICIT_DC(API);\n\n    printf(\"dc->Window.Ox     = %d\\n\", dc->Window.Ox);\n    printf(\"dc->Window.Oy     = %d\\n\", dc->Window.Oy);\n    printf(\"dc->Window.width  = %d\\n\", dc->Window.width);\n    printf(\"dc->Window.height = %d\\n\", dc->Window.height);\n    printf(\"dc->pixel_width   = %g\\n\", dc->pixel_width);\n    printf(\"dc->pixel_height  = %g\\n\", dc->pixel_height);\n#if defined(MAGICKCORE_WMF_DELEGATE)  /* Only in libwmf 0.3 */\n    printf(\"dc->Ox            = %.d\\n\", dc->Ox);\n    printf(\"dc->Oy            = %.d\\n\", dc->Oy);\n    printf(\"dc->width         = %.d\\n\", dc->width);\n    printf(\"dc->height        = %.d\\n\", dc->height);\n#endif\n\n  }\n#endif\n\n#endif\n\n  /*\n   * Create canvas image\n   *\n   */\n  image->rows=(unsigned long) ceil(image_height);\n  image->columns=(unsigned long) ceil(image_width);\n\n  if (image_info->ping != MagickFalse)\n    {\n      wmf_api_destroy(API);\n      (void) CloseBlob(image);\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"leave ReadWMFImage()\");\n      return(GetFirstImageInList(image));\n    }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n       \"  Creating canvas image with size %lux%lu\",(unsigned long) image->rows,\n       (unsigned long) image->columns);\n\n  /*\n   * Set solid background color\n   */\n  {\n    image->background_color = image_info->background_color;\n    if (image->background_color.alpha != OpaqueAlpha)\n      image->alpha_trait=BlendPixelTrait;\n    (void) SetImageBackgroundColor(image,exception);\n  }\n  /*\n   * Play file to generate Vector drawing commands\n   *\n   */\n\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Playing WMF to prepare vectors\");\n\n  wmf_error = wmf_play(API, 0, &bbox);\n  if (wmf_error != wmf_E_None)\n    {\n      wmf_api_destroy(API);\n      if (image->debug != MagickFalse)\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Playing WMF failed with wmf_error %d\", wmf_error);\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"leave ReadWMFImage()\");\n        }\n      ThrowReaderException(DelegateError,\"FailedToRenderFile\");\n    }\n\n  /*\n   * Scribble on canvas image\n   *\n   */\n\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Rendering WMF vectors\");\n  DrawRender(ddata->draw_wand);\n\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"leave ReadWMFImage()\");\n\n  /* Cleanup allocated data */\n  wmf_api_destroy(API);\n  (void) CloseBlob(image);\n\n  /* Return image */\n  return image;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147094,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static Image *ReadWMFImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  double\n    bounding_height,\n    bounding_width,\n    image_height,\n    image_height_inch,\n    image_width,\n    image_width_inch,\n    resolution_y,\n    resolution_x,\n    units_per_inch;\n\n  float\n    wmf_width,\n    wmf_height;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  unsigned long\n    wmf_options_flags = 0;\n\n  wmf_error_t\n    wmf_error;\n\n  wmf_magick_t\n    *ddata = 0;\n\n  wmfAPI\n    *API = 0;\n\n  wmfAPI_Options\n    wmf_api_options;\n\n  wmfD_Rect\n    bbox;\n\n  image=AcquireImage(image_info,exception);\n  if (OpenBlob(image_info,image,ReadBinaryBlobMode,exception) == MagickFalse)\n    {\n      if (image->debug != MagickFalse)\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  OpenBlob failed\");\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"leave ReadWMFImage()\");\n        }\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n\n  /*\n   * Create WMF API\n   *\n   */\n\n  /* Register callbacks */\n  wmf_options_flags |= WMF_OPT_FUNCTION;\n  (void) ResetMagickMemory(&wmf_api_options, 0, sizeof(wmf_api_options));\n  wmf_api_options.function = ipa_functions;\n\n  /* Ignore non-fatal errors */\n  wmf_options_flags |= WMF_OPT_IGNORE_NONFATAL;\n\n  wmf_error = wmf_api_create(&API, wmf_options_flags, &wmf_api_options);\n  if (wmf_error != wmf_E_None)\n    {\n      if (image->debug != MagickFalse)\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  wmf_api_create failed\");\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"leave ReadWMFImage()\");\n        }\n      if (API)\n        wmf_api_destroy(API);\n      ThrowReaderException(DelegateError,\"UnableToInitializeWMFLibrary\");\n    }\n\n  /* Register progress monitor */\n  wmf_status_function(API,image,magick_progress_callback);\n\n  ddata=WMF_MAGICK_GetData(API);\n  ddata->image=image;\n  ddata->image_info=image_info;\n  ddata->draw_info=CloneDrawInfo(image_info,(const DrawInfo *) NULL);\n  ddata->exception=exception;\n  ddata->draw_info->font=(char *)\n    RelinquishMagickMemory(ddata->draw_info->font);\n  ddata->draw_info->text=(char *)\n    RelinquishMagickMemory(ddata->draw_info->text);\n\n#if defined(MAGICKCORE_WMF_DELEGATE)\n  /* Must initialize font subystem for WMFlite interface */\n  lite_font_init (API,&wmf_api_options); /* similar to wmf_ipa_font_init in src/font.c */\n  /* wmf_arg_fontdirs (API,options); */ /* similar to wmf_arg_fontdirs in src/wmf.c */\n\n#endif\n\n  /*\n   * Open BLOB input via libwmf API\n   *\n   */\n  wmf_error = wmf_bbuf_input(API,ipa_blob_read,ipa_blob_seek,\n    ipa_blob_tell,(void*)image);\n  if (wmf_error != wmf_E_None)\n    {\n      if (image->debug != MagickFalse)\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  wmf_bbuf_input failed\");\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"leave ReadWMFImage()\");\n        }\n      wmf_api_destroy(API);\n      ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",\n        image->filename);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n\n  /*\n   * Scan WMF file\n   *\n   */\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Scanning WMF to obtain bounding box\");\n  wmf_error=wmf_scan(API, 0, &bbox);\n  if (wmf_error != wmf_E_None)\n    {\n      if (ddata->draw_info != (DrawInfo *) NULL)\n        {\n          DestroyDrawInfo(ddata->draw_info);\n          ddata->draw_info=(DrawInfo *)NULL;\n        }\n      if (image->debug != MagickFalse)\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  wmf_scan failed with wmf_error %d\", wmf_error);\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"leave ReadWMFImage()\");\n        }\n      wmf_api_destroy(API);\n      ThrowReaderException(DelegateError,\"FailedToScanFile\");\n    }\n\n  /*\n   * Compute dimensions and scale factors\n   *\n   */\n\n  ddata->bbox=bbox;\n\n  /* User specified resolution */\n  resolution_y=DefaultResolution;\n  if (image->resolution.y != 0.0)\n    {\n      resolution_y = image->resolution.y;\n      if (image->units == PixelsPerCentimeterResolution)\n        resolution_y *= CENTIMETERS_PER_INCH;\n    }\n  resolution_x=DefaultResolution;\n  if (image->resolution.x != 0.0)\n    {\n      resolution_x = image->resolution.x;\n      if (image->units == PixelsPerCentimeterResolution)\n        resolution_x *= CENTIMETERS_PER_INCH;\n    }\n\n  /* Obtain output size expressed in metafile units */\n  wmf_error=wmf_size(API,&wmf_width,&wmf_height);\n  if (wmf_error != wmf_E_None)\n    {\n      if (image->debug != MagickFalse)\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  wmf_size failed with wmf_error %d\", wmf_error);\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"leave ReadWMFImage()\");\n        }\n      wmf_api_destroy(API);\n      ThrowReaderException(DelegateError,\"FailedToComputeOutputSize\");\n    }\n\n  /* Obtain (or guess) metafile units */\n  if ((API)->File->placeable)\n    units_per_inch=(API)->File->pmh->Inch;\n  else if ( (wmf_width*wmf_height) < 1024*1024)\n    units_per_inch=POINTS_PER_INCH;  /* MM_TEXT */\n  else\n    units_per_inch=TWIPS_PER_INCH;  /* MM_TWIPS */\n\n  /* Calculate image width and height based on specified DPI\n     resolution */\n  image_width_inch  = (double) wmf_width / units_per_inch;\n  image_height_inch = (double) wmf_height / units_per_inch;\n  image_width       = image_width_inch * resolution_x;\n  image_height      = image_height_inch * resolution_y;\n\n  /* Compute bounding box scale factors and origin translations\n   *\n   * This all just a hack since libwmf does not currently seem to\n   * provide the mapping between LOGICAL coordinates and DEVICE\n   * coordinates. This mapping is necessary in order to know\n   * where to place the logical bounding box within the image.\n   *\n   */\n\n  bounding_width  = bbox.BR.x - bbox.TL.x;\n  bounding_height = bbox.BR.y - bbox.TL.y;\n\n  ddata->scale_x = image_width/bounding_width;\n  ddata->translate_x = 0-bbox.TL.x;\n  ddata->rotate = 0;\n\n  /* Heuristic: guess that if the vertical coordinates mostly span\n     negative values, then the image must be inverted. */\n  if ( fabs(bbox.BR.y) > fabs(bbox.TL.y) )\n    {\n      /* Normal (Origin at top left of image) */\n      ddata->scale_y = (image_height/bounding_height);\n      ddata->translate_y = 0-bbox.TL.y;\n    }\n  else\n    {\n      /* Inverted (Origin at bottom left of image) */\n      ddata->scale_y = (-image_height/bounding_height);\n      ddata->translate_y = 0-bbox.BR.y;\n    }\n\n  if (image->debug != MagickFalse)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n         \"  Placeable metafile:          %s\",\n         (API)->File->placeable ? \"Yes\" : \"No\");\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Size in metafile units:      %gx%g\",wmf_width,wmf_height);\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Metafile units/inch:         %g\",units_per_inch);\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Size in inches:              %gx%g\",\n        image_width_inch,image_height_inch);\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Bounding Box:                %g,%g %g,%g\",\n        bbox.TL.x, bbox.TL.y, bbox.BR.x, bbox.BR.y);\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Bounding width x height:     %gx%g\",bounding_width,\n        bounding_height);\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Output resolution:           %gx%g\",resolution_x,resolution_y);\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Image size:                  %gx%g\",image_width,image_height);\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Bounding box scale factor:   %g,%g\",ddata->scale_x,\n        ddata->scale_y);\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Translation:                 %g,%g\",\n        ddata->translate_x, ddata->translate_y);\n    }\n\n#if 0\n#if 0\n  {\n    typedef struct _wmfPlayer_t wmfPlayer_t;\n    struct _wmfPlayer_t\n    {\n      wmfPen   default_pen;\n      wmfBrush default_brush;\n      wmfFont  default_font;\n\n      wmfDC* dc; /* current dc */\n    };\n\n    wmfDC\n      *dc;\n\n#define WMF_ELICIT_DC(API) (((wmfPlayer_t*)((API)->player_data))->dc)\n\n    dc = WMF_ELICIT_DC(API);\n\n    printf(\"dc->Window.Ox     = %d\\n\", dc->Window.Ox);\n    printf(\"dc->Window.Oy     = %d\\n\", dc->Window.Oy);\n    printf(\"dc->Window.width  = %d\\n\", dc->Window.width);\n    printf(\"dc->Window.height = %d\\n\", dc->Window.height);\n    printf(\"dc->pixel_width   = %g\\n\", dc->pixel_width);\n    printf(\"dc->pixel_height  = %g\\n\", dc->pixel_height);\n#if defined(MAGICKCORE_WMF_DELEGATE)  /* Only in libwmf 0.3 */\n    printf(\"dc->Ox            = %.d\\n\", dc->Ox);\n    printf(\"dc->Oy            = %.d\\n\", dc->Oy);\n    printf(\"dc->width         = %.d\\n\", dc->width);\n    printf(\"dc->height        = %.d\\n\", dc->height);\n#endif\n\n  }\n#endif\n\n#endif\n\n  /*\n   * Create canvas image\n   *\n   */\n  image->rows=(unsigned long) ceil(image_height);\n  image->columns=(unsigned long) ceil(image_width);\n\n  if (image_info->ping != MagickFalse)\n    {\n      wmf_api_destroy(API);\n      (void) CloseBlob(image);\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"leave ReadWMFImage()\");\n      return(GetFirstImageInList(image));\n    }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n       \"  Creating canvas image with size %lux%lu\",(unsigned long) image->rows,\n       (unsigned long) image->columns);\n\n  /*\n   * Set solid background color\n   */\n  {\n    image->background_color = image_info->background_color;\n    if (image->background_color.alpha != OpaqueAlpha)\n      image->alpha_trait=BlendPixelTrait;\n    (void) SetImageBackgroundColor(image,exception);\n  }\n  /*\n   * Play file to generate Vector drawing commands\n   *\n   */\n\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Playing WMF to prepare vectors\");\n\n  wmf_error = wmf_play(API, 0, &bbox);\n  if (wmf_error != wmf_E_None)\n    {\n      if (image->debug != MagickFalse)\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Playing WMF failed with wmf_error %d\", wmf_error);\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"leave ReadWMFImage()\");\n        }\n      wmf_api_destroy(API);\n      ThrowReaderException(DelegateError,\"FailedToRenderFile\");\n    }\n\n  /*\n   * Scribble on canvas image\n   *\n   */\n\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Rendering WMF vectors\");\n  DrawRender(ddata->draw_wand);\n\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"leave ReadWMFImage()\");\n\n  /* Cleanup allocated data */\n  wmf_api_destroy(API);\n  (void) CloseBlob(image);\n\n  /* Return image */\n  return image;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147095,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "HandleFileDownloadCancelRequest(rfbClientPtr cl, rfbTightClientPtr rtcp)\n{\n\tint n = 0;\n\tchar *reason = NULL;\n\trfbClientToServerTightMsg msg;\n\n\tmemset(&msg, 0, sizeof(rfbClientToServerTightMsg));\n\t\n\tif((n = rfbReadExact(cl, ((char *)&msg)+1, sz_rfbFileDownloadCancelMsg-1)) <= 0) {\n\t\t\n\t\tif (n < 0)\n\t\t\trfbLog(\"File [%s]: Method [%s]: Error while reading \"\n\t\t\t\t\t\"FileDownloadCancelMsg\\n\", __FILE__, __FUNCTION__);\n\t\t\n\t    rfbCloseClient(cl);\n\t    return;\n\t}\n\n\tmsg.fdc.reasonLen = Swap16IfLE(msg.fdc.reasonLen);\n\n\tif(msg.fdc.reasonLen == 0) {\n\t\trfbLog(\"File [%s]: Method [%s]: reason length received is Zero\\n\",\n\t\t\t\t__FILE__, __FUNCTION__);\n\t\treturn;\n\t}\n\t\n\treason = (char*) calloc(msg.fdc.reasonLen + 1, sizeof(char));\n\tif(reason == NULL) {\n\t\trfbLog(\"File [%s]: Method [%s]: Fatal Error: Memory alloc failed\\n\", \n\t\t\t\t__FILE__, __FUNCTION__);\n\t\treturn;\n\t}\n\n\tif((n = rfbReadExact(cl, reason, msg.fdc.reasonLen)) <= 0) {\n\t\t\n\t\tif (n < 0)\n\t\t\trfbLog(\"File [%s]: Method [%s]: Error while reading \"\n\t\t\t\t\t\"FileDownloadCancelMsg\\n\", __FILE__, __FUNCTION__);\n\t\t\n\t    rfbCloseClient(cl);\n\t}\n\n\trfbLog(\"File [%s]: Method [%s]: File Download Cancel Request received:\"\n\t\t\t\t\t\" reason <%s>\\n\", __FILE__, __FUNCTION__, reason);\n\t\n\tpthread_mutex_lock(&fileDownloadMutex);\n\tCloseUndoneFileTransfer(cl, rtcp);\n\tpthread_mutex_unlock(&fileDownloadMutex);\n\t\n\tif(reason != NULL) {\n\t\tfree(reason);\n\t\treason = NULL;\n\t}\n\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147142,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "HandleFileDownloadCancelRequest(rfbClientPtr cl, rfbTightClientPtr rtcp)\n{\n\tint n = 0;\n\tchar *reason = NULL;\n\trfbClientToServerTightMsg msg;\n\n\tmemset(&msg, 0, sizeof(rfbClientToServerTightMsg));\n\t\n\tif((n = rfbReadExact(cl, ((char *)&msg)+1, sz_rfbFileDownloadCancelMsg-1)) <= 0) {\n\t\t\n\t\tif (n < 0)\n\t\t\trfbLog(\"File [%s]: Method [%s]: Error while reading \"\n\t\t\t\t\t\"FileDownloadCancelMsg\\n\", __FILE__, __FUNCTION__);\n\t\t\n\t    rfbCloseClient(cl);\n\t    return;\n\t}\n\n\tmsg.fdc.reasonLen = Swap16IfLE(msg.fdc.reasonLen);\n\n\tif(msg.fdc.reasonLen == 0) {\n\t\trfbLog(\"File [%s]: Method [%s]: reason length received is Zero\\n\",\n\t\t\t\t__FILE__, __FUNCTION__);\n\t\treturn;\n\t}\n\t\n\treason = (char*) calloc(msg.fdc.reasonLen + 1, sizeof(char));\n\tif(reason == NULL) {\n\t\trfbLog(\"File [%s]: Method [%s]: Fatal Error: Memory alloc failed\\n\", \n\t\t\t\t__FILE__, __FUNCTION__);\n\t\treturn;\n\t}\n\n\tif((n = rfbReadExact(cl, reason, msg.fdc.reasonLen)) <= 0) {\n\t\t\n\t\tif (n < 0)\n\t\t\trfbLog(\"File [%s]: Method [%s]: Error while reading \"\n\t\t\t\t\t\"FileDownloadCancelMsg\\n\", __FILE__, __FUNCTION__);\n\t\t\n\t    rfbCloseClient(cl);\n\t    free(reason);\n\t    return;\n\t}\n\n\trfbLog(\"File [%s]: Method [%s]: File Download Cancel Request received:\"\n\t\t\t\t\t\" reason <%s>\\n\", __FILE__, __FUNCTION__, reason);\n\t\n\tpthread_mutex_lock(&fileDownloadMutex);\n\tCloseUndoneFileTransfer(cl, rtcp);\n\tpthread_mutex_unlock(&fileDownloadMutex);\n\t\n\tif(reason != NULL) {\n\t\tfree(reason);\n\t\treason = NULL;\n\t}\n\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147143,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int parse_eops(extop **result, bool critical, int elem)\n{\n    extop *eop = NULL, *prev = NULL;\n    extop **tail = result;\n    int sign;\n    int i = tokval.t_type;\n    int oper_num = 0;\n    bool do_subexpr = false;\n\n    *tail = NULL;\n\n    /* End of string is obvious; ) ends a sub-expression list e.g. DUP */\n    for (i = tokval.t_type; i != TOKEN_EOS; i = stdscan(NULL, &tokval)) {\n        char endparen = ')';   /* Is a right paren the end of list? */\n\n        if (i == ')')\n            break;\n\n        if (!eop) {\n            nasm_new(eop);\n            eop->dup  = 1;\n            eop->elem = elem;\n            do_subexpr = false;\n        }\n        sign = +1;\n\n        /*\n         * end_expression_next() here is to distinguish this from\n         * a string used as part of an expression...\n         */\n        if (i == TOKEN_QMARK) {\n            eop->type = EOT_DB_RESERVE;\n        } else if (do_subexpr && i == '(') {\n            extop *subexpr;\n\n            stdscan(NULL, &tokval); /* Skip paren */\n            if (parse_eops(&eop->val.subexpr, critical, eop->elem) < 0)\n                goto fail;\n\n            subexpr = eop->val.subexpr;\n            if (!subexpr) {\n                /* Subexpression is empty */\n                eop->type = EOT_NOTHING;\n            } else if (!subexpr->next) {\n                /* Subexpression is a single element, flatten */\n                eop->val   = subexpr->val;\n                eop->type  = subexpr->type;\n                eop->dup  *= subexpr->dup;\n                nasm_free(subexpr);\n            } else {\n                eop->type = EOT_EXTOP;\n            }\n\n            /* We should have ended on a closing paren */\n            if (tokval.t_type != ')') {\n                nasm_nonfatal(\"expected `)' after subexpression, got `%s'\",\n                              i == TOKEN_EOS ?\n                              \"end of line\" : tokval.t_charptr);\n                goto fail;\n            }\n            endparen = 0;       /* This time the paren is not the end */\n        } else if (i == '%') {\n            /* %(expression_list) */\n            do_subexpr = true;\n            continue;\n        } else if (i == TOKEN_SIZE) {\n            /* Element size override */\n            eop->elem = tokval.t_inttwo;\n            do_subexpr = true;\n            continue;\n        } else if (i == TOKEN_STR && end_expression_next()) {\n            eop->type            = EOT_DB_STRING;\n            eop->val.string.data = tokval.t_charptr;\n            eop->val.string.len  = tokval.t_inttwo;\n        } else if (i == TOKEN_STRFUNC) {\n            bool parens = false;\n            const char *funcname = tokval.t_charptr;\n            enum strfunc func = tokval.t_integer;\n\n            i = stdscan(NULL, &tokval);\n            if (i == '(') {\n                parens = true;\n                endparen = 0;\n                i = stdscan(NULL, &tokval);\n            }\n            if (i != TOKEN_STR) {\n                nasm_nonfatal(\"%s must be followed by a string constant\",\n                              funcname);\n                eop->type = EOT_NOTHING;\n            } else {\n                eop->type = EOT_DB_STRING_FREE;\n                eop->val.string.len =\n                    string_transform(tokval.t_charptr, tokval.t_inttwo,\n                                     &eop->val.string.data, func);\n                if (eop->val.string.len == (size_t)-1) {\n                    nasm_nonfatal(\"invalid input string to %s\", funcname);\n                    eop->type = EOT_NOTHING;\n                }\n            }\n            if (parens && i && i != ')') {\n                i = stdscan(NULL, &tokval);\n                if (i != ')')\n                    nasm_nonfatal(\"unterminated %s function\", funcname);\n            }\n        } else if (i == '-' || i == '+') {\n            char *save = stdscan_get();\n            struct tokenval tmptok;\n\n            sign = (i == '-') ? -1 : 1;\n            if (stdscan(NULL, &tmptok) != TOKEN_FLOAT) {\n                stdscan_set(save);\n                goto is_expression;\n            } else {\n                tokval = tmptok;\n                goto is_float;\n            }\n        } else if (i == TOKEN_FLOAT) {\n            enum floatize fmt;\n        is_float:\n            eop->type = EOT_DB_FLOAT;\n\n            fmt = float_deffmt(eop->elem);\n            if (fmt == FLOAT_ERR) {\n                nasm_nonfatal(\"no %d-bit floating-point format supported\",\n                              eop->elem << 3);\n                eop->val.string.len = 0;\n            } else if (eop->elem < 1) {\n                nasm_nonfatal(\"floating-point constant\"\n                              \" encountered in unknown instruction\");\n                /*\n                 * fix suggested by Pedro Gimeno... original line was:\n                 * eop->type = EOT_NOTHING;\n                 */\n                eop->val.string.len = 0;\n            } else {\n                eop->val.string.len = eop->elem;\n\n                eop = nasm_realloc(eop, sizeof(extop) + eop->val.string.len);\n                eop->val.string.data = (char *)eop + sizeof(extop);\n                if (!float_const(tokval.t_charptr, sign,\n                                 (uint8_t *)eop->val.string.data, fmt))\n                    eop->val.string.len = 0;\n            }\n            if (!eop->val.string.len)\n                eop->type = EOT_NOTHING;\n        } else {\n            /* anything else, assume it is an expression */\n            expr *value;\n\n        is_expression:\n            value = evaluate(stdscan, NULL, &tokval, NULL,\n                             critical, NULL);\n            i = tokval.t_type;\n            if (!value)                  /* Error in evaluator */\n                goto fail;\n            if (tokval.t_flag & TFLAG_DUP) {\n                /* Expression followed by DUP */\n                if (!is_simple(value)) {\n                    nasm_nonfatal(\"non-constant argument supplied to DUP\");\n                    goto fail;\n                } else if (value->value < 0) {\n                    nasm_nonfatal(\"negative argument supplied to DUP\");\n                    goto fail;\n                }\n                eop->dup *= (size_t)value->value;\n                do_subexpr = true;\n                continue;\n            }\n            if (value_to_extop(value, eop, location.segment)) {\n                nasm_nonfatal(\"expression is not simple or relocatable\");\n            }\n        }\n\n        if (eop->dup == 0 || eop->type == EOT_NOTHING) {\n            nasm_free(eop);\n        } else if (eop->type == EOT_DB_RESERVE &&\n                   prev && prev->type == EOT_DB_RESERVE &&\n                   prev->elem == eop->elem) {\n            /* Coalesce multiple EOT_DB_RESERVE */\n            prev->dup += eop->dup;\n            nasm_free(eop);\n        } else {\n            /* Add this eop to the end of the chain */\n            prev = eop;\n            *tail = eop;\n            tail = &eop->next;\n        }\n\n        oper_num++;\n        eop = NULL;             /* Done with this operand */\n\n        /*\n         * We're about to call stdscan(), which will eat the\n         * comma that we're currently sitting on between\n         * arguments. However, we'd better check first that it\n         * _is_ a comma.\n         */\n        if (i == TOKEN_EOS || i == endparen)\t/* Already at end? */\n            break;\n        if (i != ',') {\n            i = stdscan(NULL, &tokval);\t\t/* eat the comma or final paren */\n            if (i == TOKEN_EOS || i == ')')\t/* got end of expression */\n                break;\n            if (i != ',') {\n                nasm_nonfatal(\"comma expected after operand\");\n                goto fail;\n            }\n        }\n    }\n\n    return oper_num;\n\nfail:\n    if (eop)\n        nasm_free(eop);\n    return -1;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147202,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int parse_eops(extop **result, bool critical, int elem)\n{\n    extop *eop = NULL, *prev = NULL;\n    extop **tail = result;\n    int sign;\n    int i = tokval.t_type;\n    int oper_num = 0;\n    bool do_subexpr = false;\n\n    *tail = NULL;\n\n    /* End of string is obvious; ) ends a sub-expression list e.g. DUP */\n    for (i = tokval.t_type; i != TOKEN_EOS; i = stdscan(NULL, &tokval)) {\n        char endparen = ')';   /* Is a right paren the end of list? */\n\n        if (i == ')')\n            break;\n\n        if (!eop) {\n            nasm_new(eop);\n            eop->dup  = 1;\n            eop->elem = elem;\n            do_subexpr = false;\n        }\n        sign = +1;\n\n        /*\n         * end_expression_next() here is to distinguish this from\n         * a string used as part of an expression...\n         */\n        if (i == TOKEN_QMARK) {\n            eop->type = EOT_DB_RESERVE;\n        } else if (do_subexpr && i == '(') {\n            extop *subexpr;\n\n            stdscan(NULL, &tokval); /* Skip paren */\n            if (parse_eops(&eop->val.subexpr, critical, eop->elem) < 0)\n                goto fail;\n\n            subexpr = eop->val.subexpr;\n            if (!subexpr) {\n                /* Subexpression is empty */\n                eop->type = EOT_NOTHING;\n            } else if (!subexpr->next) {\n                /*\n                 * Subexpression is a single element, flatten.\n                 * Note that if subexpr has an allocated buffer associated\n                 * with it, freeing it would free the buffer, too, so\n                 * we need to move subexpr up, not eop down.\n                 */\n                if (!subexpr->elem)\n                    subexpr->elem = eop->elem;\n                subexpr->dup *= eop->dup;\n                nasm_free(eop);\n                eop = subexpr;\n            } else {\n                eop->type = EOT_EXTOP;\n            }\n\n            /* We should have ended on a closing paren */\n            if (tokval.t_type != ')') {\n                nasm_nonfatal(\"expected `)' after subexpression, got `%s'\",\n                              i == TOKEN_EOS ?\n                              \"end of line\" : tokval.t_charptr);\n                goto fail;\n            }\n            endparen = 0;       /* This time the paren is not the end */\n        } else if (i == '%') {\n            /* %(expression_list) */\n            do_subexpr = true;\n            continue;\n        } else if (i == TOKEN_SIZE) {\n            /* Element size override */\n            eop->elem = tokval.t_inttwo;\n            do_subexpr = true;\n            continue;\n        } else if (i == TOKEN_STR && end_expression_next()) {\n            eop->type            = EOT_DB_STRING;\n            eop->val.string.data = tokval.t_charptr;\n            eop->val.string.len  = tokval.t_inttwo;\n        } else if (i == TOKEN_STRFUNC) {\n            bool parens = false;\n            const char *funcname = tokval.t_charptr;\n            enum strfunc func = tokval.t_integer;\n\n            i = stdscan(NULL, &tokval);\n            if (i == '(') {\n                parens = true;\n                endparen = 0;\n                i = stdscan(NULL, &tokval);\n            }\n            if (i != TOKEN_STR) {\n                nasm_nonfatal(\"%s must be followed by a string constant\",\n                              funcname);\n                eop->type = EOT_NOTHING;\n            } else {\n                eop->type = EOT_DB_STRING_FREE;\n                eop->val.string.len =\n                    string_transform(tokval.t_charptr, tokval.t_inttwo,\n                                     &eop->val.string.data, func);\n                if (eop->val.string.len == (size_t)-1) {\n                    nasm_nonfatal(\"invalid input string to %s\", funcname);\n                    eop->type = EOT_NOTHING;\n                }\n            }\n            if (parens && i && i != ')') {\n                i = stdscan(NULL, &tokval);\n                if (i != ')')\n                    nasm_nonfatal(\"unterminated %s function\", funcname);\n            }\n        } else if (i == '-' || i == '+') {\n            char *save = stdscan_get();\n            struct tokenval tmptok;\n\n            sign = (i == '-') ? -1 : 1;\n            if (stdscan(NULL, &tmptok) != TOKEN_FLOAT) {\n                stdscan_set(save);\n                goto is_expression;\n            } else {\n                tokval = tmptok;\n                goto is_float;\n            }\n        } else if (i == TOKEN_FLOAT) {\n            enum floatize fmt;\n        is_float:\n            eop->type = EOT_DB_FLOAT;\n\n            fmt = float_deffmt(eop->elem);\n            if (fmt == FLOAT_ERR) {\n                nasm_nonfatal(\"no %d-bit floating-point format supported\",\n                              eop->elem << 3);\n                eop->val.string.len = 0;\n            } else if (eop->elem < 1) {\n                nasm_nonfatal(\"floating-point constant\"\n                              \" encountered in unknown instruction\");\n                /*\n                 * fix suggested by Pedro Gimeno... original line was:\n                 * eop->type = EOT_NOTHING;\n                 */\n                eop->val.string.len = 0;\n            } else {\n                eop->val.string.len = eop->elem;\n\n                eop = nasm_realloc(eop, sizeof(extop) + eop->val.string.len);\n                eop->val.string.data = (char *)eop + sizeof(extop);\n                if (!float_const(tokval.t_charptr, sign,\n                                 (uint8_t *)eop->val.string.data, fmt))\n                    eop->val.string.len = 0;\n            }\n            if (!eop->val.string.len)\n                eop->type = EOT_NOTHING;\n        } else {\n            /* anything else, assume it is an expression */\n            expr *value;\n\n        is_expression:\n            value = evaluate(stdscan, NULL, &tokval, NULL,\n                             critical, NULL);\n            i = tokval.t_type;\n            if (!value)                  /* Error in evaluator */\n                goto fail;\n            if (tokval.t_flag & TFLAG_DUP) {\n                /* Expression followed by DUP */\n                if (!is_simple(value)) {\n                    nasm_nonfatal(\"non-constant argument supplied to DUP\");\n                    goto fail;\n                } else if (value->value < 0) {\n                    nasm_nonfatal(\"negative argument supplied to DUP\");\n                    goto fail;\n                }\n                eop->dup *= (size_t)value->value;\n                do_subexpr = true;\n                continue;\n            }\n            if (value_to_extop(value, eop, location.segment)) {\n                nasm_nonfatal(\"expression is not simple or relocatable\");\n            }\n        }\n\n        if (eop->dup == 0 || eop->type == EOT_NOTHING) {\n            nasm_free(eop);\n        } else if (eop->type == EOT_DB_RESERVE &&\n                   prev && prev->type == EOT_DB_RESERVE &&\n                   prev->elem == eop->elem) {\n            /* Coalesce multiple EOT_DB_RESERVE */\n            prev->dup += eop->dup;\n            nasm_free(eop);\n        } else {\n            /* Add this eop to the end of the chain */\n            prev = eop;\n            *tail = eop;\n            tail = &eop->next;\n        }\n\n        oper_num++;\n        eop = NULL;             /* Done with this operand */\n\n        /*\n         * We're about to call stdscan(), which will eat the\n         * comma that we're currently sitting on between\n         * arguments. However, we'd better check first that it\n         * _is_ a comma.\n         */\n        if (i == TOKEN_EOS || i == endparen)\t/* Already at end? */\n            break;\n        if (i != ',') {\n            i = stdscan(NULL, &tokval);\t\t/* eat the comma or final paren */\n            if (i == TOKEN_EOS || i == ')')\t/* got end of expression */\n                break;\n            if (i != ',') {\n                nasm_nonfatal(\"comma expected after operand\");\n                goto fail;\n            }\n        }\n    }\n\n    return oper_num;\n\nfail:\n    if (eop)\n        nasm_free(eop);\n    return -1;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147203,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "ex_open(exarg_T *eap)\n{\n    regmatch_T\tregmatch;\n    char_u\t*p;\n\n#ifdef FEAT_EVAL\n    if (not_in_vim9(eap) == FAIL)\n\treturn;\n#endif\n    curwin->w_cursor.lnum = eap->line2;\n    beginline(BL_SOL | BL_FIX);\n    if (*eap->arg == '/')\n    {\n\t// \":open /pattern/\": put cursor in column found with pattern\n\t++eap->arg;\n\tp = skip_regexp(eap->arg, '/', magic_isset());\n\t*p = NUL;\n\tregmatch.regprog = vim_regcomp(eap->arg, magic_isset() ? RE_MAGIC : 0);\n\tif (regmatch.regprog != NULL)\n\t{\n\t    regmatch.rm_ic = p_ic;\n\t    p = ml_get_curline();\n\t    if (vim_regexec(&regmatch, p, (colnr_T)0))\n\t\tcurwin->w_cursor.col = (colnr_T)(regmatch.startp[0] - p);\n\t    else\n\t\temsg(_(e_nomatch));\n\t    vim_regfree(regmatch.regprog);\n\t}\n\t// Move to the NUL, ignore any other arguments.\n\teap->arg += STRLEN(eap->arg);\n    }\n    check_cursor();\n\n    eap->cmdidx = CMD_visual;\n    do_exedit(eap, NULL);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147226,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "ex_open(exarg_T *eap)\n{\n    regmatch_T\tregmatch;\n    char_u\t*p;\n\n#ifdef FEAT_EVAL\n    if (not_in_vim9(eap) == FAIL)\n\treturn;\n#endif\n    curwin->w_cursor.lnum = eap->line2;\n    beginline(BL_SOL | BL_FIX);\n    if (*eap->arg == '/')\n    {\n\t// \":open /pattern/\": put cursor in column found with pattern\n\t++eap->arg;\n\tp = skip_regexp(eap->arg, '/', magic_isset());\n\t*p = NUL;\n\tregmatch.regprog = vim_regcomp(eap->arg, magic_isset() ? RE_MAGIC : 0);\n\tif (regmatch.regprog != NULL)\n\t{\n\t    // make a copy of the line, when searching for a mark it might be\n\t    // flushed\n\t    char_u *line = vim_strsave(ml_get_curline());\n\n\t    regmatch.rm_ic = p_ic;\n\t    if (vim_regexec(&regmatch, line, (colnr_T)0))\n\t\tcurwin->w_cursor.col = (colnr_T)(regmatch.startp[0] - line);\n\t    else\n\t\temsg(_(e_nomatch));\n\t    vim_regfree(regmatch.regprog);\n\t    vim_free(line);\n\t}\n\t// Move to the NUL, ignore any other arguments.\n\teap->arg += STRLEN(eap->arg);\n    }\n    check_cursor();\n\n    eap->cmdidx = CMD_visual;\n    do_exedit(eap, NULL);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147227,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static OPJ_BOOL opj_t2_encode_packet(OPJ_UINT32 tileno,\n                                     opj_tcd_tile_t * tile,\n                                     opj_tcp_t * tcp,\n                                     opj_pi_iterator_t *pi,\n                                     OPJ_BYTE *dest,\n                                     OPJ_UINT32 * p_data_written,\n                                     OPJ_UINT32 length,\n                                     opj_codestream_info_t *cstr_info,\n                                     J2K_T2_MODE p_t2_mode,\n                                     opj_event_mgr_t *p_manager)\n{\n    OPJ_UINT32 bandno, cblkno;\n    OPJ_BYTE* c = dest;\n    OPJ_UINT32 l_nb_bytes;\n    OPJ_UINT32 compno = pi->compno;     /* component value */\n    OPJ_UINT32 resno  = pi->resno;      /* resolution level value */\n    OPJ_UINT32 precno = pi->precno;     /* precinct value */\n    OPJ_UINT32 layno  = pi->layno;      /* quality layer value */\n    OPJ_UINT32 l_nb_blocks;\n    opj_tcd_band_t *band = 00;\n    opj_tcd_cblk_enc_t* cblk = 00;\n    opj_tcd_pass_t *pass = 00;\n\n    opj_tcd_tilecomp_t *tilec = &tile->comps[compno];\n    opj_tcd_resolution_t *res = &tilec->resolutions[resno];\n\n    opj_bio_t *bio = 00;    /* BIO component */\n    OPJ_BOOL packet_empty = OPJ_TRUE;\n\n    /* <SOP 0xff91> */\n    if (tcp->csty & J2K_CP_CSTY_SOP) {\n        c[0] = 255;\n        c[1] = 145;\n        c[2] = 0;\n        c[3] = 4;\n#if 0\n        c[4] = (tile->packno % 65536) / 256;\n        c[5] = (tile->packno % 65536) % 256;\n#else\n        c[4] = (tile->packno >> 8) & 0xff; /* packno is uint32_t */\n        c[5] = tile->packno & 0xff;\n#endif\n        c += 6;\n        length -= 6;\n    }\n    /* </SOP> */\n\n    if (!layno) {\n        band = res->bands;\n\n        for (bandno = 0; bandno < res->numbands; ++bandno, ++band) {\n            opj_tcd_precinct_t *prc;\n\n            /* Skip empty bands */\n            if (opj_tcd_is_band_empty(band)) {\n                continue;\n            }\n\n            prc = &band->precincts[precno];\n            opj_tgt_reset(prc->incltree);\n            opj_tgt_reset(prc->imsbtree);\n\n            l_nb_blocks = prc->cw * prc->ch;\n            for (cblkno = 0; cblkno < l_nb_blocks; ++cblkno) {\n                cblk = &prc->cblks.enc[cblkno];\n\n                cblk->numpasses = 0;\n                opj_tgt_setvalue(prc->imsbtree, cblkno, band->numbps - (OPJ_INT32)cblk->numbps);\n            }\n        }\n    }\n\n    bio = opj_bio_create();\n    if (!bio) {\n        /* FIXME event manager error callback */\n        return OPJ_FALSE;\n    }\n    opj_bio_init_enc(bio, c, length);\n\n    /* Check if the packet is empty */\n    /* Note: we could also skip that step and always write a packet header */\n    band = res->bands;\n    for (bandno = 0; bandno < res->numbands; ++bandno, ++band) {\n        opj_tcd_precinct_t *prc;\n        /* Skip empty bands */\n        if (opj_tcd_is_band_empty(band)) {\n            continue;\n        }\n\n        prc = &band->precincts[precno];\n        l_nb_blocks = prc->cw * prc->ch;\n        cblk = prc->cblks.enc;\n        for (cblkno = 0; cblkno < l_nb_blocks; cblkno++, ++cblk) {\n            opj_tcd_layer_t *layer = &cblk->layers[layno];\n\n            /* if cblk not included, go to the next cblk  */\n            if (!layer->numpasses) {\n                continue;\n            }\n            packet_empty = OPJ_FALSE;\n            break;\n        }\n        if (!packet_empty) {\n            break;\n        }\n    }\n\n    opj_bio_write(bio, packet_empty ? 0 : 1, 1);           /* Empty header bit */\n\n\n    /* Writing Packet header */\n    band = res->bands;\n    for (bandno = 0; !packet_empty &&\n            bandno < res->numbands; ++bandno, ++band)      {\n        opj_tcd_precinct_t *prc;\n\n        /* Skip empty bands */\n        if (opj_tcd_is_band_empty(band)) {\n            continue;\n        }\n\n        prc = &band->precincts[precno];\n        l_nb_blocks = prc->cw * prc->ch;\n        cblk = prc->cblks.enc;\n\n        for (cblkno = 0; cblkno < l_nb_blocks; ++cblkno) {\n            opj_tcd_layer_t *layer = &cblk->layers[layno];\n\n            if (!cblk->numpasses && layer->numpasses) {\n                opj_tgt_setvalue(prc->incltree, cblkno, (OPJ_INT32)layno);\n            }\n\n            ++cblk;\n        }\n\n        cblk = prc->cblks.enc;\n        for (cblkno = 0; cblkno < l_nb_blocks; cblkno++) {\n            opj_tcd_layer_t *layer = &cblk->layers[layno];\n            OPJ_UINT32 increment = 0;\n            OPJ_UINT32 nump = 0;\n            OPJ_UINT32 len = 0, passno;\n            OPJ_UINT32 l_nb_passes;\n\n            /* cblk inclusion bits */\n            if (!cblk->numpasses) {\n                opj_tgt_encode(bio, prc->incltree, cblkno, (OPJ_INT32)(layno + 1));\n            } else {\n                opj_bio_write(bio, layer->numpasses != 0, 1);\n            }\n\n            /* if cblk not included, go to the next cblk  */\n            if (!layer->numpasses) {\n                ++cblk;\n                continue;\n            }\n\n            /* if first instance of cblk --> zero bit-planes information */\n            if (!cblk->numpasses) {\n                cblk->numlenbits = 3;\n                opj_tgt_encode(bio, prc->imsbtree, cblkno, 999);\n            }\n\n            /* number of coding passes included */\n            opj_t2_putnumpasses(bio, layer->numpasses);\n            l_nb_passes = cblk->numpasses + layer->numpasses;\n            pass = cblk->passes +  cblk->numpasses;\n\n            /* computation of the increase of the length indicator and insertion in the header     */\n            for (passno = cblk->numpasses; passno < l_nb_passes; ++passno) {\n                ++nump;\n                len += pass->len;\n\n                if (pass->term || passno == (cblk->numpasses + layer->numpasses) - 1) {\n                    increment = (OPJ_UINT32)opj_int_max((OPJ_INT32)increment,\n                                                        opj_int_floorlog2((OPJ_INT32)len) + 1\n                                                        - ((OPJ_INT32)cblk->numlenbits + opj_int_floorlog2((OPJ_INT32)nump)));\n                    len = 0;\n                    nump = 0;\n                }\n\n                ++pass;\n            }\n            opj_t2_putcommacode(bio, (OPJ_INT32)increment);\n\n            /* computation of the new Length indicator */\n            cblk->numlenbits += increment;\n\n            pass = cblk->passes +  cblk->numpasses;\n            /* insertion of the codeword segment length */\n            for (passno = cblk->numpasses; passno < l_nb_passes; ++passno) {\n                nump++;\n                len += pass->len;\n\n                if (pass->term || passno == (cblk->numpasses + layer->numpasses) - 1) {\n                    opj_bio_write(bio, (OPJ_UINT32)len,\n                                  cblk->numlenbits + (OPJ_UINT32)opj_int_floorlog2((OPJ_INT32)nump));\n                    len = 0;\n                    nump = 0;\n                }\n                ++pass;\n            }\n\n            ++cblk;\n        }\n    }\n\n    if (!opj_bio_flush(bio)) {\n        opj_bio_destroy(bio);\n        return OPJ_FALSE;               /* modified to eliminate longjmp !! */\n    }\n\n    l_nb_bytes = (OPJ_UINT32)opj_bio_numbytes(bio);\n    c += l_nb_bytes;\n    length -= l_nb_bytes;\n\n    opj_bio_destroy(bio);\n\n    /* <EPH 0xff92> */\n    if (tcp->csty & J2K_CP_CSTY_EPH) {\n        c[0] = 255;\n        c[1] = 146;\n        c += 2;\n        length -= 2;\n    }\n    /* </EPH> */\n\n    /* << INDEX */\n    /* End of packet header position. Currently only represents the distance to start of packet\n       Will be updated later by incrementing with packet start value*/\n    if (cstr_info && cstr_info->index_write) {\n        opj_packet_info_t *info_PK = &cstr_info->tile[tileno].packet[cstr_info->packno];\n        info_PK->end_ph_pos = (OPJ_INT32)(c - dest);\n    }\n    /* INDEX >> */\n\n    /* Writing the packet body */\n    band = res->bands;\n    for (bandno = 0; !packet_empty && bandno < res->numbands; bandno++, ++band) {\n        opj_tcd_precinct_t *prc;\n\n        /* Skip empty bands */\n        if (opj_tcd_is_band_empty(band)) {\n            continue;\n        }\n\n        prc = &band->precincts[precno];\n        l_nb_blocks = prc->cw * prc->ch;\n        cblk = prc->cblks.enc;\n\n        for (cblkno = 0; cblkno < l_nb_blocks; ++cblkno) {\n            opj_tcd_layer_t *layer = &cblk->layers[layno];\n\n            if (!layer->numpasses) {\n                ++cblk;\n                continue;\n            }\n\n            if (layer->len > length) {\n                if (p_t2_mode == FINAL_PASS) {\n                    opj_event_msg(p_manager, EVT_ERROR,\n                                  \"opj_t2_encode_packet(): only %u bytes remaining in \"\n                                  \"output buffer. %u needed.\\n\",\n                                  length, layer->len);\n                }\n                return OPJ_FALSE;\n            }\n\n            memcpy(c, layer->data, layer->len);\n            cblk->numpasses += layer->numpasses;\n            c += layer->len;\n            length -= layer->len;\n\n            /* << INDEX */\n            if (cstr_info && cstr_info->index_write) {\n                opj_packet_info_t *info_PK = &cstr_info->tile[tileno].packet[cstr_info->packno];\n                info_PK->disto += layer->disto;\n                if (cstr_info->D_max < info_PK->disto) {\n                    cstr_info->D_max = info_PK->disto;\n                }\n            }\n\n            ++cblk;\n            /* INDEX >> */\n        }\n    }\n\n    assert(c >= dest);\n    * p_data_written += (OPJ_UINT32)(c - dest);\n\n    return OPJ_TRUE;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147228,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static OPJ_BOOL opj_t2_encode_packet(OPJ_UINT32 tileno,\n                                     opj_tcd_tile_t * tile,\n                                     opj_tcp_t * tcp,\n                                     opj_pi_iterator_t *pi,\n                                     OPJ_BYTE *dest,\n                                     OPJ_UINT32 * p_data_written,\n                                     OPJ_UINT32 length,\n                                     opj_codestream_info_t *cstr_info,\n                                     J2K_T2_MODE p_t2_mode,\n                                     opj_event_mgr_t *p_manager)\n{\n    OPJ_UINT32 bandno, cblkno;\n    OPJ_BYTE* c = dest;\n    OPJ_UINT32 l_nb_bytes;\n    OPJ_UINT32 compno = pi->compno;     /* component value */\n    OPJ_UINT32 resno  = pi->resno;      /* resolution level value */\n    OPJ_UINT32 precno = pi->precno;     /* precinct value */\n    OPJ_UINT32 layno  = pi->layno;      /* quality layer value */\n    OPJ_UINT32 l_nb_blocks;\n    opj_tcd_band_t *band = 00;\n    opj_tcd_cblk_enc_t* cblk = 00;\n    opj_tcd_pass_t *pass = 00;\n\n    opj_tcd_tilecomp_t *tilec = &tile->comps[compno];\n    opj_tcd_resolution_t *res = &tilec->resolutions[resno];\n\n    opj_bio_t *bio = 00;    /* BIO component */\n    OPJ_BOOL packet_empty = OPJ_TRUE;\n\n    /* <SOP 0xff91> */\n    if (tcp->csty & J2K_CP_CSTY_SOP) {\n        if (length < 6) {\n            if (p_t2_mode == FINAL_PASS) {\n                opj_event_msg(p_manager, EVT_ERROR,\n                              \"opj_t2_encode_packet(): only %u bytes remaining in \"\n                              \"output buffer. %u needed.\\n\",\n                              length, 6);\n            }\n            return OPJ_FALSE;\n        }\n        c[0] = 255;\n        c[1] = 145;\n        c[2] = 0;\n        c[3] = 4;\n#if 0\n        c[4] = (tile->packno % 65536) / 256;\n        c[5] = (tile->packno % 65536) % 256;\n#else\n        c[4] = (tile->packno >> 8) & 0xff; /* packno is uint32_t */\n        c[5] = tile->packno & 0xff;\n#endif\n        c += 6;\n        length -= 6;\n    }\n    /* </SOP> */\n\n    if (!layno) {\n        band = res->bands;\n\n        for (bandno = 0; bandno < res->numbands; ++bandno, ++band) {\n            opj_tcd_precinct_t *prc;\n\n            /* Skip empty bands */\n            if (opj_tcd_is_band_empty(band)) {\n                continue;\n            }\n\n            prc = &band->precincts[precno];\n            opj_tgt_reset(prc->incltree);\n            opj_tgt_reset(prc->imsbtree);\n\n            l_nb_blocks = prc->cw * prc->ch;\n            for (cblkno = 0; cblkno < l_nb_blocks; ++cblkno) {\n                cblk = &prc->cblks.enc[cblkno];\n\n                cblk->numpasses = 0;\n                opj_tgt_setvalue(prc->imsbtree, cblkno, band->numbps - (OPJ_INT32)cblk->numbps);\n            }\n        }\n    }\n\n    bio = opj_bio_create();\n    if (!bio) {\n        /* FIXME event manager error callback */\n        return OPJ_FALSE;\n    }\n    opj_bio_init_enc(bio, c, length);\n\n    /* Check if the packet is empty */\n    /* Note: we could also skip that step and always write a packet header */\n    band = res->bands;\n    for (bandno = 0; bandno < res->numbands; ++bandno, ++band) {\n        opj_tcd_precinct_t *prc;\n        /* Skip empty bands */\n        if (opj_tcd_is_band_empty(band)) {\n            continue;\n        }\n\n        prc = &band->precincts[precno];\n        l_nb_blocks = prc->cw * prc->ch;\n        cblk = prc->cblks.enc;\n        for (cblkno = 0; cblkno < l_nb_blocks; cblkno++, ++cblk) {\n            opj_tcd_layer_t *layer = &cblk->layers[layno];\n\n            /* if cblk not included, go to the next cblk  */\n            if (!layer->numpasses) {\n                continue;\n            }\n            packet_empty = OPJ_FALSE;\n            break;\n        }\n        if (!packet_empty) {\n            break;\n        }\n    }\n\n    opj_bio_write(bio, packet_empty ? 0 : 1, 1);           /* Empty header bit */\n\n\n    /* Writing Packet header */\n    band = res->bands;\n    for (bandno = 0; !packet_empty &&\n            bandno < res->numbands; ++bandno, ++band)      {\n        opj_tcd_precinct_t *prc;\n\n        /* Skip empty bands */\n        if (opj_tcd_is_band_empty(band)) {\n            continue;\n        }\n\n        prc = &band->precincts[precno];\n        l_nb_blocks = prc->cw * prc->ch;\n        cblk = prc->cblks.enc;\n\n        for (cblkno = 0; cblkno < l_nb_blocks; ++cblkno) {\n            opj_tcd_layer_t *layer = &cblk->layers[layno];\n\n            if (!cblk->numpasses && layer->numpasses) {\n                opj_tgt_setvalue(prc->incltree, cblkno, (OPJ_INT32)layno);\n            }\n\n            ++cblk;\n        }\n\n        cblk = prc->cblks.enc;\n        for (cblkno = 0; cblkno < l_nb_blocks; cblkno++) {\n            opj_tcd_layer_t *layer = &cblk->layers[layno];\n            OPJ_UINT32 increment = 0;\n            OPJ_UINT32 nump = 0;\n            OPJ_UINT32 len = 0, passno;\n            OPJ_UINT32 l_nb_passes;\n\n            /* cblk inclusion bits */\n            if (!cblk->numpasses) {\n                opj_tgt_encode(bio, prc->incltree, cblkno, (OPJ_INT32)(layno + 1));\n            } else {\n                opj_bio_write(bio, layer->numpasses != 0, 1);\n            }\n\n            /* if cblk not included, go to the next cblk  */\n            if (!layer->numpasses) {\n                ++cblk;\n                continue;\n            }\n\n            /* if first instance of cblk --> zero bit-planes information */\n            if (!cblk->numpasses) {\n                cblk->numlenbits = 3;\n                opj_tgt_encode(bio, prc->imsbtree, cblkno, 999);\n            }\n\n            /* number of coding passes included */\n            opj_t2_putnumpasses(bio, layer->numpasses);\n            l_nb_passes = cblk->numpasses + layer->numpasses;\n            pass = cblk->passes +  cblk->numpasses;\n\n            /* computation of the increase of the length indicator and insertion in the header     */\n            for (passno = cblk->numpasses; passno < l_nb_passes; ++passno) {\n                ++nump;\n                len += pass->len;\n\n                if (pass->term || passno == (cblk->numpasses + layer->numpasses) - 1) {\n                    increment = (OPJ_UINT32)opj_int_max((OPJ_INT32)increment,\n                                                        opj_int_floorlog2((OPJ_INT32)len) + 1\n                                                        - ((OPJ_INT32)cblk->numlenbits + opj_int_floorlog2((OPJ_INT32)nump)));\n                    len = 0;\n                    nump = 0;\n                }\n\n                ++pass;\n            }\n            opj_t2_putcommacode(bio, (OPJ_INT32)increment);\n\n            /* computation of the new Length indicator */\n            cblk->numlenbits += increment;\n\n            pass = cblk->passes +  cblk->numpasses;\n            /* insertion of the codeword segment length */\n            for (passno = cblk->numpasses; passno < l_nb_passes; ++passno) {\n                nump++;\n                len += pass->len;\n\n                if (pass->term || passno == (cblk->numpasses + layer->numpasses) - 1) {\n                    opj_bio_write(bio, (OPJ_UINT32)len,\n                                  cblk->numlenbits + (OPJ_UINT32)opj_int_floorlog2((OPJ_INT32)nump));\n                    len = 0;\n                    nump = 0;\n                }\n                ++pass;\n            }\n\n            ++cblk;\n        }\n    }\n\n    if (!opj_bio_flush(bio)) {\n        opj_bio_destroy(bio);\n        return OPJ_FALSE;               /* modified to eliminate longjmp !! */\n    }\n\n    l_nb_bytes = (OPJ_UINT32)opj_bio_numbytes(bio);\n    c += l_nb_bytes;\n    length -= l_nb_bytes;\n\n    opj_bio_destroy(bio);\n\n    /* <EPH 0xff92> */\n    if (tcp->csty & J2K_CP_CSTY_EPH) {\n        if (length < 2) {\n            if (p_t2_mode == FINAL_PASS) {\n                opj_event_msg(p_manager, EVT_ERROR,\n                              \"opj_t2_encode_packet(): only %u bytes remaining in \"\n                              \"output buffer. %u needed.\\n\",\n                              length, 2);\n            }\n            return OPJ_FALSE;\n        }\n        c[0] = 255;\n        c[1] = 146;\n        c += 2;\n        length -= 2;\n    }\n    /* </EPH> */\n\n    /* << INDEX */\n    /* End of packet header position. Currently only represents the distance to start of packet\n       Will be updated later by incrementing with packet start value*/\n    if (cstr_info && cstr_info->index_write) {\n        opj_packet_info_t *info_PK = &cstr_info->tile[tileno].packet[cstr_info->packno];\n        info_PK->end_ph_pos = (OPJ_INT32)(c - dest);\n    }\n    /* INDEX >> */\n\n    /* Writing the packet body */\n    band = res->bands;\n    for (bandno = 0; !packet_empty && bandno < res->numbands; bandno++, ++band) {\n        opj_tcd_precinct_t *prc;\n\n        /* Skip empty bands */\n        if (opj_tcd_is_band_empty(band)) {\n            continue;\n        }\n\n        prc = &band->precincts[precno];\n        l_nb_blocks = prc->cw * prc->ch;\n        cblk = prc->cblks.enc;\n\n        for (cblkno = 0; cblkno < l_nb_blocks; ++cblkno) {\n            opj_tcd_layer_t *layer = &cblk->layers[layno];\n\n            if (!layer->numpasses) {\n                ++cblk;\n                continue;\n            }\n\n            if (layer->len > length) {\n                if (p_t2_mode == FINAL_PASS) {\n                    opj_event_msg(p_manager, EVT_ERROR,\n                                  \"opj_t2_encode_packet(): only %u bytes remaining in \"\n                                  \"output buffer. %u needed.\\n\",\n                                  length, layer->len);\n                }\n                return OPJ_FALSE;\n            }\n\n            memcpy(c, layer->data, layer->len);\n            cblk->numpasses += layer->numpasses;\n            c += layer->len;\n            length -= layer->len;\n\n            /* << INDEX */\n            if (cstr_info && cstr_info->index_write) {\n                opj_packet_info_t *info_PK = &cstr_info->tile[tileno].packet[cstr_info->packno];\n                info_PK->disto += layer->disto;\n                if (cstr_info->D_max < info_PK->disto) {\n                    cstr_info->D_max = info_PK->disto;\n                }\n            }\n\n            ++cblk;\n            /* INDEX >> */\n        }\n    }\n\n    assert(c >= dest);\n    * p_data_written += (OPJ_UINT32)(c - dest);\n\n    return OPJ_TRUE;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147229,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "llsec_key_alloc(const struct ieee802154_llsec_key *template)\n{\n\tconst int authsizes[3] = { 4, 8, 16 };\n\tstruct mac802154_llsec_key *key;\n\tint i;\n\n\tkey = kzalloc(sizeof(*key), GFP_KERNEL);\n\tif (!key)\n\t\treturn NULL;\n\n\tkref_init(&key->ref);\n\tkey->key = *template;\n\n\tBUILD_BUG_ON(ARRAY_SIZE(authsizes) != ARRAY_SIZE(key->tfm));\n\n\tfor (i = 0; i < ARRAY_SIZE(key->tfm); i++) {\n\t\tkey->tfm[i] = crypto_alloc_aead(\"ccm(aes)\", 0,\n\t\t\t\t\t\tCRYPTO_ALG_ASYNC);\n\t\tif (IS_ERR(key->tfm[i]))\n\t\t\tgoto err_tfm;\n\t\tif (crypto_aead_setkey(key->tfm[i], template->key,\n\t\t\t\t       IEEE802154_LLSEC_KEY_SIZE))\n\t\t\tgoto err_tfm;\n\t\tif (crypto_aead_setauthsize(key->tfm[i], authsizes[i]))\n\t\t\tgoto err_tfm;\n\t}\n\n\tkey->tfm0 = crypto_alloc_sync_skcipher(\"ctr(aes)\", 0, 0);\n\tif (IS_ERR(key->tfm0))\n\t\tgoto err_tfm;\n\n\tif (crypto_sync_skcipher_setkey(key->tfm0, template->key,\n\t\t\t\t   IEEE802154_LLSEC_KEY_SIZE))\n\t\tgoto err_tfm0;\n\n\treturn key;\n\nerr_tfm0:\n\tcrypto_free_sync_skcipher(key->tfm0);\nerr_tfm:\n\tfor (i = 0; i < ARRAY_SIZE(key->tfm); i++)\n\t\tif (key->tfm[i])\n\t\t\tcrypto_free_aead(key->tfm[i]);\n\n\tkfree_sensitive(key);\n\treturn NULL;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147246,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "llsec_key_alloc(const struct ieee802154_llsec_key *template)\n{\n\tconst int authsizes[3] = { 4, 8, 16 };\n\tstruct mac802154_llsec_key *key;\n\tint i;\n\n\tkey = kzalloc(sizeof(*key), GFP_KERNEL);\n\tif (!key)\n\t\treturn NULL;\n\n\tkref_init(&key->ref);\n\tkey->key = *template;\n\n\tBUILD_BUG_ON(ARRAY_SIZE(authsizes) != ARRAY_SIZE(key->tfm));\n\n\tfor (i = 0; i < ARRAY_SIZE(key->tfm); i++) {\n\t\tkey->tfm[i] = crypto_alloc_aead(\"ccm(aes)\", 0,\n\t\t\t\t\t\tCRYPTO_ALG_ASYNC);\n\t\tif (IS_ERR(key->tfm[i]))\n\t\t\tgoto err_tfm;\n\t\tif (crypto_aead_setkey(key->tfm[i], template->key,\n\t\t\t\t       IEEE802154_LLSEC_KEY_SIZE))\n\t\t\tgoto err_tfm;\n\t\tif (crypto_aead_setauthsize(key->tfm[i], authsizes[i]))\n\t\t\tgoto err_tfm;\n\t}\n\n\tkey->tfm0 = crypto_alloc_sync_skcipher(\"ctr(aes)\", 0, 0);\n\tif (IS_ERR(key->tfm0))\n\t\tgoto err_tfm;\n\n\tif (crypto_sync_skcipher_setkey(key->tfm0, template->key,\n\t\t\t\t   IEEE802154_LLSEC_KEY_SIZE))\n\t\tgoto err_tfm0;\n\n\treturn key;\n\nerr_tfm0:\n\tcrypto_free_sync_skcipher(key->tfm0);\nerr_tfm:\n\tfor (i = 0; i < ARRAY_SIZE(key->tfm); i++)\n\t\tif (!IS_ERR_OR_NULL(key->tfm[i]))\n\t\t\tcrypto_free_aead(key->tfm[i]);\n\n\tkfree_sensitive(key);\n\treturn NULL;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147247,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "void blk_cleanup_queue(struct request_queue *q)\n{\n\t/* mark @q DYING, no new request or merges will be allowed afterwards */\n\tmutex_lock(&q->sysfs_lock);\n\tblk_set_queue_dying(q);\n\n\tblk_queue_flag_set(QUEUE_FLAG_NOMERGES, q);\n\tblk_queue_flag_set(QUEUE_FLAG_NOXMERGES, q);\n\tblk_queue_flag_set(QUEUE_FLAG_DYING, q);\n\tmutex_unlock(&q->sysfs_lock);\n\n\t/*\n\t * Drain all requests queued before DYING marking. Set DEAD flag to\n\t * prevent that q->request_fn() gets invoked after draining finished.\n\t */\n\tblk_freeze_queue(q);\n\n\trq_qos_exit(q);\n\n\tblk_queue_flag_set(QUEUE_FLAG_DEAD, q);\n\n\t/* for synchronous bio-based driver finish in-flight integrity i/o */\n\tblk_flush_integrity();\n\n\t/* @q won't process any more request, flush async actions */\n\tdel_timer_sync(&q->backing_dev_info->laptop_mode_wb_timer);\n\tblk_sync_queue(q);\n\n\tif (queue_is_mq(q))\n\t\tblk_mq_exit_queue(q);\n\n\tpercpu_ref_exit(&q->q_usage_counter);\n\n\t/* @q is and will stay empty, shutdown and put */\n\tblk_put_queue(q);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147262,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "void blk_cleanup_queue(struct request_queue *q)\n{\n\t/* mark @q DYING, no new request or merges will be allowed afterwards */\n\tmutex_lock(&q->sysfs_lock);\n\tblk_set_queue_dying(q);\n\n\tblk_queue_flag_set(QUEUE_FLAG_NOMERGES, q);\n\tblk_queue_flag_set(QUEUE_FLAG_NOXMERGES, q);\n\tblk_queue_flag_set(QUEUE_FLAG_DYING, q);\n\tmutex_unlock(&q->sysfs_lock);\n\n\t/*\n\t * Drain all requests queued before DYING marking. Set DEAD flag to\n\t * prevent that q->request_fn() gets invoked after draining finished.\n\t */\n\tblk_freeze_queue(q);\n\n\trq_qos_exit(q);\n\n\tblk_queue_flag_set(QUEUE_FLAG_DEAD, q);\n\n\t/* for synchronous bio-based driver finish in-flight integrity i/o */\n\tblk_flush_integrity();\n\n\t/* @q won't process any more request, flush async actions */\n\tdel_timer_sync(&q->backing_dev_info->laptop_mode_wb_timer);\n\tblk_sync_queue(q);\n\n\tif (queue_is_mq(q))\n\t\tblk_mq_exit_queue(q);\n\n\t/*\n\t * In theory, request pool of sched_tags belongs to request queue.\n\t * However, the current implementation requires tag_set for freeing\n\t * requests, so free the pool now.\n\t *\n\t * Queue has become frozen, there can't be any in-queue requests, so\n\t * it is safe to free requests now.\n\t */\n\tmutex_lock(&q->sysfs_lock);\n\tif (q->elevator)\n\t\tblk_mq_sched_free_requests(q);\n\tmutex_unlock(&q->sysfs_lock);\n\n\tpercpu_ref_exit(&q->q_usage_counter);\n\n\t/* @q is and will stay empty, shutdown and put */\n\tblk_put_queue(q);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147263,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int __init cpia2_init(void)\n{\n\tLOG(\"%s v%s\\n\",\n\t    ABOUT, CPIA_VERSION);\n\tcheck_parameters();\n\tcpia2_usb_init();\n\treturn 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147272,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int __init cpia2_init(void)\n{\n\tLOG(\"%s v%s\\n\",\n\t    ABOUT, CPIA_VERSION);\n\tcheck_parameters();\n\treturn cpia2_usb_init();\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147273,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "receive_msg(BOOL extract_recip)\n{\nint  i;\nint  rc = FAIL;\nint  msg_size = 0;\nint  process_info_len = Ustrlen(process_info);\nint  error_rc = (error_handling == ERRORS_SENDER)?\n       errors_sender_rc : EXIT_FAILURE;\nint  header_size = 256;\nint  start, end, domain;\nint  id_resolution;\nint  had_zero = 0;\nint  prevlines_length = 0;\n\nregister int ptr = 0;\n\nBOOL contains_resent_headers = FALSE;\nBOOL extracted_ignored = FALSE;\nBOOL first_line_ended_crlf = TRUE_UNSET;\nBOOL smtp_yield = TRUE;\nBOOL yield = FALSE;\n\nBOOL resents_exist = FALSE;\nuschar *resent_prefix = US\"\";\nuschar *blackholed_by = NULL;\nuschar *blackhole_log_msg = US\"\";\nenum {NOT_TRIED, TMP_REJ, PERM_REJ, ACCEPTED} cutthrough_done = NOT_TRIED;\n\nflock_t lock_data;\nerror_block *bad_addresses = NULL;\n\nuschar *frozen_by = NULL;\nuschar *queued_by = NULL;\n\nuschar *errmsg;\ngstring * g;\nstruct stat statbuf;\n\n/* Final message to give to SMTP caller, and messages from ACLs */\n\nuschar *smtp_reply = NULL;\nuschar *user_msg, *log_msg;\n\n/* Working header pointers */\n\nheader_line *h, *next;\n\n/* Flags for noting the existence of certain headers (only one left) */\n\nBOOL date_header_exists = FALSE;\n\n/* Pointers to receive the addresses of headers whose contents we need. */\n\nheader_line *from_header = NULL;\nheader_line *subject_header = NULL;\nheader_line *msgid_header = NULL;\nheader_line *received_header;\n\n#ifdef EXPERIMENTAL_DMARC\nint dmarc_up = 0;\n#endif /* EXPERIMENTAL_DMARC */\n\n/* Variables for use when building the Received: header. */\n\nuschar *timestamp;\nint tslen;\n\n/* Release any open files that might have been cached while preparing to\naccept the message - e.g. by verifying addresses - because reading a message\nmight take a fair bit of real time. */\n\nsearch_tidyup();\n\n/* Extracting the recipient list from an input file is incompatible with\ncutthrough delivery with the no-spool option.  It shouldn't be possible\nto set up the combination, but just in case kill any ongoing connection. */\nif (extract_recip || !smtp_input)\n  cancel_cutthrough_connection(TRUE, US\"not smtp input\");\n\n/* Initialize the chain of headers by setting up a place-holder for Received:\nheader. Temporarily mark it as \"old\", i.e. not to be used. We keep header_last\npointing to the end of the chain to make adding headers simple. */\n\nreceived_header = header_list = header_last = store_get(sizeof(header_line));\nheader_list->next = NULL;\nheader_list->type = htype_old;\nheader_list->text = NULL;\nheader_list->slen = 0;\n\n/* Control block for the next header to be read. */\n\nnext = store_get(sizeof(header_line));\nnext->text = store_get(header_size);\n\n/* Initialize message id to be null (indicating no message read), and the\nheader names list to be the normal list. Indicate there is no data file open\nyet, initialize the size and warning count, and deal with no size limit. */\n\nmessage_id[0] = 0;\ndata_file = NULL;\ndata_fd = -1;\nspool_name = US\"\";\nmessage_size = 0;\nwarning_count = 0;\nreceived_count = 1;            /* For the one we will add */\n\nif (thismessage_size_limit <= 0) thismessage_size_limit = INT_MAX;\n\n/* While reading the message, the following counts are computed. */\n\nmessage_linecount = body_linecount = body_zerocount =\n  max_received_linelength = 0;\n\n#ifndef DISABLE_DKIM\n/* Call into DKIM to set up the context.  In CHUNKING mode\nwe clear the dot-stuffing flag */\nif (smtp_input && !smtp_batched_input && !dkim_disable_verify)\n  dkim_exim_verify_init(chunking_state <= CHUNKING_OFFERED);\n#endif\n\n#ifdef EXPERIMENTAL_DMARC\n/* initialize libopendmarc */\ndmarc_up = dmarc_init();\n#endif\n\n/* Remember the time of reception. Exim uses time+pid for uniqueness of message\nids, and fractions of a second are required. See the comments that precede the\nmessage id creation below. */\n\n(void)gettimeofday(&message_id_tv, NULL);\n\n/* For other uses of the received time we can operate with granularity of one\nsecond, and for that we use the global variable received_time. This is for\nthings like ultimate message timeouts.XXX */\n\nreceived_time = message_id_tv;\n\n/* If SMTP input, set the special handler for timeouts. The alarm() calls\nhappen in the smtp_getc() function when it refills its buffer. */\n\nif (smtp_input) os_non_restarting_signal(SIGALRM, data_timeout_handler);\n\n/* If not SMTP input, timeout happens only if configured, and we just set a\nsingle timeout for the whole message. */\n\nelse if (receive_timeout > 0)\n  {\n  os_non_restarting_signal(SIGALRM, data_timeout_handler);\n  alarm(receive_timeout);\n  }\n\n/* SIGTERM and SIGINT are caught always. */\n\nsignal(SIGTERM, data_sigterm_sigint_handler);\nsignal(SIGINT, data_sigterm_sigint_handler);\n\n/* Header lines in messages are not supposed to be very long, though when\nunfolded, to: and cc: headers can take up a lot of store. We must also cope\nwith the possibility of junk being thrown at us. Start by getting 256 bytes for\nstoring the header, and extend this as necessary using string_cat().\n\nTo cope with total lunacies, impose an upper limit on the length of the header\nsection of the message, as otherwise the store will fill up. We must also cope\nwith the possibility of binary zeros in the data. Hence we cannot use fgets().\nFolded header lines are joined into one string, leaving the '\\n' characters\ninside them, so that writing them out reproduces the input.\n\nLoop for each character of each header; the next structure for chaining the\nheader is set up already, with ptr the offset of the next character in\nnext->text. */\n\nfor (;;)\n  {\n  int ch = (receive_getc)(GETC_BUFFER_UNLIMITED);\n\n  /* If we hit EOF on a SMTP connection, it's an error, since incoming\n  SMTP must have a correct \".\" terminator. */\n\n  if (ch == EOF && smtp_input /* && !smtp_batched_input */)\n    {\n    smtp_reply = handle_lost_connection(US\" (header)\");\n    smtp_yield = FALSE;\n    goto TIDYUP;                       /* Skip to end of function */\n    }\n\n  /* See if we are at the current header's size limit - there must be at least\n  four bytes left. This allows for the new character plus a zero, plus two for\n  extra insertions when we are playing games with dots and carriage returns. If\n  we are at the limit, extend the text buffer. This could have been done\n  automatically using string_cat() but because this is a tightish loop storing\n  only one character at a time, we choose to do it inline. Normally\n  store_extend() will be able to extend the block; only at the end of a big\n  store block will a copy be needed. To handle the case of very long headers\n  (and sometimes lunatic messages can have ones that are 100s of K long) we\n  call store_release() for strings that have been copied - if the string is at\n  the start of a block (and therefore the only thing in it, because we aren't\n  doing any other gets), the block gets freed. We can only do this because we\n  know there are no other calls to store_get() going on. */\n\n  if (ptr >= header_size - 4)\n    {\n    int oldsize = header_size;\n    /* header_size += 256; */\n    header_size *= 2;\n    if (!store_extend(next->text, oldsize, header_size))\n      {\n      uschar *newtext = store_get(header_size);\n      memcpy(newtext, next->text, ptr);\n      store_release(next->text);\n      next->text = newtext;\n      }\n    }\n\n  /* Cope with receiving a binary zero. There is dispute about whether\n  these should be allowed in RFC 822 messages. The middle view is that they\n  should not be allowed in headers, at least. Exim takes this attitude at\n  the moment. We can't just stomp on them here, because we don't know that\n  this line is a header yet. Set a flag to cause scanning later. */\n\n  if (ch == 0) had_zero++;\n\n  /* Test for termination. Lines in remote SMTP are terminated by CRLF, while\n  those from data files use just LF. Treat LF in local SMTP input as a\n  terminator too. Treat EOF as a line terminator always. */\n\n  if (ch == EOF) goto EOL;\n\n  /* FUDGE: There are sites out there that don't send CRs before their LFs, and\n  other MTAs accept this. We are therefore forced into this \"liberalisation\"\n  too, so we accept LF as a line terminator whatever the source of the message.\n  However, if the first line of the message ended with a CRLF, we treat a bare\n  LF specially by inserting a white space after it to ensure that the header\n  line is not terminated. */\n\n  if (ch == '\\n')\n    {\n    if (first_line_ended_crlf == TRUE_UNSET) first_line_ended_crlf = FALSE;\n      else if (first_line_ended_crlf) receive_ungetc(' ');\n    goto EOL;\n    }\n\n  /* This is not the end of the line. If this is SMTP input and this is\n  the first character in the line and it is a \".\" character, ignore it.\n  This implements the dot-doubling rule, though header lines starting with\n  dots aren't exactly common. They are legal in RFC 822, though. If the\n  following is CRLF or LF, this is the line that that terminates the\n  entire message. We set message_ended to indicate this has happened (to\n  prevent further reading), and break out of the loop, having freed the\n  empty header, and set next = NULL to indicate no data line. */\n\n  if (ptr == 0 && ch == '.' && (smtp_input || dot_ends))\n    {\n    ch = (receive_getc)(GETC_BUFFER_UNLIMITED);\n    if (ch == '\\r')\n      {\n      ch = (receive_getc)(GETC_BUFFER_UNLIMITED);\n      if (ch != '\\n')\n        {\n        receive_ungetc(ch);\n        ch = '\\r';              /* Revert to CR */\n        }\n      }\n    if (ch == '\\n')\n      {\n      message_ended = END_DOT;\n      store_reset(next);\n      next = NULL;\n      break;                    /* End character-reading loop */\n      }\n\n    /* For non-SMTP input, the dot at the start of the line was really a data\n    character. What is now in ch is the following character. We guaranteed\n    enough space for this above. */\n\n    if (!smtp_input)\n      {\n      next->text[ptr++] = '.';\n      message_size++;\n      }\n    }\n\n  /* If CR is immediately followed by LF, end the line, ignoring the CR, and\n  remember this case if this is the first line ending. */\n\n  if (ch == '\\r')\n    {\n    ch = (receive_getc)(GETC_BUFFER_UNLIMITED);\n    if (ch == '\\n')\n      {\n      if (first_line_ended_crlf == TRUE_UNSET) first_line_ended_crlf = TRUE;\n      goto EOL;\n      }\n\n    /* Otherwise, put back the character after CR, and turn the bare CR\n    into LF SP. */\n\n    ch = (receive_ungetc)(ch);\n    next->text[ptr++] = '\\n';\n    message_size++;\n    ch = ' ';\n    }\n\n  /* We have a data character for the header line. */\n\n  next->text[ptr++] = ch;    /* Add to buffer */\n  message_size++;            /* Total message size so far */\n\n  /* Handle failure due to a humungously long header section. The >= allows\n  for the terminating \\n. Add what we have so far onto the headers list so\n  that it gets reflected in any error message, and back up the just-read\n  character. */\n\n  if (message_size >= header_maxsize)\n    {\n    next->text[ptr] = 0;\n    next->slen = ptr;\n    next->type = htype_other;\n    next->next = NULL;\n    header_last->next = next;\n    header_last = next;\n\n    log_write(0, LOG_MAIN, \"ridiculously long message header received from \"\n      \"%s (more than %d characters): message abandoned\",\n      sender_host_unknown? sender_ident : sender_fullhost, header_maxsize);\n\n    if (smtp_input)\n      {\n      smtp_reply = US\"552 Message header is ridiculously long\";\n      receive_swallow_smtp();\n      goto TIDYUP;                             /* Skip to end of function */\n      }\n\n    else\n      {\n      give_local_error(ERRMESS_VLONGHEADER,\n        string_sprintf(\"message header longer than %d characters received: \"\n         \"message not accepted\", header_maxsize), US\"\", error_rc, stdin,\n           header_list->next);\n      /* Does not return */\n      }\n    }\n\n  continue;                  /* With next input character */\n\n  /* End of header line reached */\n\n  EOL:\n\n  /* Keep track of lines for BSMTP errors and overall message_linecount. */\n\n  receive_linecount++;\n  message_linecount++;\n\n  /* Keep track of maximum line length */\n\n  if (ptr - prevlines_length > max_received_linelength)\n    max_received_linelength = ptr - prevlines_length;\n  prevlines_length = ptr + 1;\n\n  /* Now put in the terminating newline. There is always space for\n  at least two more characters. */\n\n  next->text[ptr++] = '\\n';\n  message_size++;\n\n  /* A blank line signals the end of the headers; release the unwanted\n  space and set next to NULL to indicate this. */\n\n  if (ptr == 1)\n    {\n    store_reset(next);\n    next = NULL;\n    break;\n    }\n\n  /* There is data in the line; see if the next input character is a\n  whitespace character. If it is, we have a continuation of this header line.\n  There is always space for at least one character at this point. */\n\n  if (ch != EOF)\n    {\n    int nextch = (receive_getc)(GETC_BUFFER_UNLIMITED);\n    if (nextch == ' ' || nextch == '\\t')\n      {\n      next->text[ptr++] = nextch;\n      message_size++;\n      continue;                      /* Iterate the loop */\n      }\n    else if (nextch != EOF) (receive_ungetc)(nextch);   /* For next time */\n    else ch = EOF;                   /* Cause main loop to exit at end */\n    }\n\n  /* We have got to the real line end. Terminate the string and release store\n  beyond it. If it turns out to be a real header, internal binary zeros will\n  be squashed later. */\n\n  next->text[ptr] = 0;\n  next->slen = ptr;\n  store_reset(next->text + ptr + 1);\n\n  /* Check the running total size against the overall message size limit. We\n  don't expect to fail here, but if the overall limit is set less than MESSAGE_\n  MAXSIZE and a big header is sent, we want to catch it. Just stop reading\n  headers - the code to read the body will then also hit the buffer. */\n\n  if (message_size > thismessage_size_limit) break;\n\n  /* A line that is not syntactically correct for a header also marks\n  the end of the headers. In this case, we leave next containing the\n  first data line. This might actually be several lines because of the\n  continuation logic applied above, but that doesn't matter.\n\n  It turns out that smail, and presumably sendmail, accept leading lines\n  of the form\n\n  From ph10 Fri Jan  5 12:35 GMT 1996\n\n  in messages. The \"mail\" command on Solaris 2 sends such lines. I cannot\n  find any documentation of this, but for compatibility it had better be\n  accepted. Exim restricts it to the case of non-smtp messages, and\n  treats it as an alternative to the -f command line option. Thus it is\n  ignored except for trusted users or filter testing. Otherwise it is taken\n  as the sender address, unless -f was used (sendmail compatibility).\n\n  It further turns out that some UUCPs generate the From_line in a different\n  format, e.g.\n\n  From ph10 Fri, 7 Jan 97 14:00:00 GMT\n\n  The regex for matching these things is now capable of recognizing both\n  formats (including 2- and 4-digit years in the latter). In fact, the regex\n  is now configurable, as is the expansion string to fish out the sender.\n\n  Even further on it has been discovered that some broken clients send\n  these lines in SMTP messages. There is now an option to ignore them from\n  specified hosts or networks. Sigh. */\n\n  if (header_last == header_list &&\n       (!smtp_input\n         ||\n         (sender_host_address != NULL &&\n           verify_check_host(&ignore_fromline_hosts) == OK)\n         ||\n         (sender_host_address == NULL && ignore_fromline_local)\n       ) &&\n       regex_match_and_setup(regex_From, next->text, 0, -1))\n    {\n    if (!sender_address_forced)\n      {\n      uschar *uucp_sender = expand_string(uucp_from_sender);\n      if (uucp_sender == NULL)\n        {\n        log_write(0, LOG_MAIN|LOG_PANIC,\n          \"expansion of \\\"%s\\\" failed after matching \"\n          \"\\\"From \\\" line: %s\", uucp_from_sender, expand_string_message);\n        }\n      else\n        {\n        int start, end, domain;\n        uschar *errmess;\n        uschar *newsender = parse_extract_address(uucp_sender, &errmess,\n          &start, &end, &domain, TRUE);\n        if (newsender != NULL)\n          {\n          if (domain == 0 && newsender[0] != 0)\n            newsender = rewrite_address_qualify(newsender, FALSE);\n\n          if (filter_test != FTEST_NONE || receive_check_set_sender(newsender))\n            {\n            sender_address = newsender;\n\n            if (trusted_caller || filter_test != FTEST_NONE)\n              {\n              authenticated_sender = NULL;\n              originator_name = US\"\";\n              sender_local = FALSE;\n              }\n\n            if (filter_test != FTEST_NONE)\n              printf(\"Sender taken from \\\"From \\\" line\\n\");\n            }\n          }\n        }\n      }\n    }\n\n  /* Not a leading \"From \" line. Check to see if it is a valid header line.\n  Header names may contain any non-control characters except space and colon,\n  amazingly. */\n\n  else\n    {\n    uschar *p = next->text;\n\n    /* If not a valid header line, break from the header reading loop, leaving\n    next != NULL, indicating that it holds the first line of the body. */\n\n    if (isspace(*p)) break;\n    while (mac_isgraph(*p) && *p != ':') p++;\n    while (isspace(*p)) p++;\n    if (*p != ':')\n      {\n      body_zerocount = had_zero;\n      break;\n      }\n\n    /* We have a valid header line. If there were any binary zeroes in\n    the line, stomp on them here. */\n\n    if (had_zero > 0)\n      for (p = next->text; p < next->text + ptr; p++) if (*p == 0) *p = '?';\n\n    /* It is perfectly legal to have an empty continuation line\n    at the end of a header, but it is confusing to humans\n    looking at such messages, since it looks like a blank line.\n    Reduce confusion by removing redundant white space at the\n    end. We know that there is at least one printing character\n    (the ':' tested for above) so there is no danger of running\n    off the end. */\n\n    p = next->text + ptr - 2;\n    for (;;)\n      {\n      while (*p == ' ' || *p == '\\t') p--;\n      if (*p != '\\n') break;\n      ptr = (p--) - next->text + 1;\n      message_size -= next->slen - ptr;\n      next->text[ptr] = 0;\n      next->slen = ptr;\n      }\n\n    /* Add the header to the chain */\n\n    next->type = htype_other;\n    next->next = NULL;\n    header_last->next = next;\n    header_last = next;\n\n    /* Check the limit for individual line lengths. This comes after adding to\n    the chain so that the failing line is reflected if a bounce is generated\n    (for a local message). */\n\n    if (header_line_maxsize > 0 && next->slen > header_line_maxsize)\n      {\n      log_write(0, LOG_MAIN, \"overlong message header line received from \"\n        \"%s (more than %d characters): message abandoned\",\n        sender_host_unknown? sender_ident : sender_fullhost,\n        header_line_maxsize);\n\n      if (smtp_input)\n        {\n        smtp_reply = US\"552 A message header line is too long\";\n        receive_swallow_smtp();\n        goto TIDYUP;                             /* Skip to end of function */\n        }\n\n      else\n        {\n        give_local_error(ERRMESS_VLONGHDRLINE,\n          string_sprintf(\"message header line longer than %d characters \"\n           \"received: message not accepted\", header_line_maxsize), US\"\",\n           error_rc, stdin, header_list->next);\n        /* Does not return */\n        }\n      }\n\n    /* Note if any resent- fields exist. */\n\n    if (!resents_exist && strncmpic(next->text, US\"resent-\", 7) == 0)\n      {\n      resents_exist = TRUE;\n      resent_prefix = US\"Resent-\";\n      }\n    }\n\n  /* Reject CHUNKING messages that do not CRLF their first header line */\n\n  if (!first_line_ended_crlf && chunking_state > CHUNKING_OFFERED)\n    {\n    log_write(L_size_reject, LOG_MAIN|LOG_REJECT, \"rejected from <%s>%s%s%s%s: \"\n      \"Non-CRLF-terminated header, under CHUNKING: message abandoned\",\n      sender_address,\n      sender_fullhost ? \" H=\" : \"\", sender_fullhost ? sender_fullhost : US\"\",\n      sender_ident ? \" U=\" : \"\",    sender_ident ? sender_ident : US\"\");\n    smtp_printf(\"552 Message header not CRLF terminated\\r\\n\", FALSE);\n    bdat_flush_data();\n    smtp_reply = US\"\";\n    goto TIDYUP;                             /* Skip to end of function */\n    }\n\n  /* The line has been handled. If we have hit EOF, break out of the loop,\n  indicating no pending data line. */\n\n  if (ch == EOF) { next = NULL; break; }\n\n  /* Set up for the next header */\n\n  header_size = 256;\n  next = store_get(sizeof(header_line));\n  next->text = store_get(header_size);\n  ptr = 0;\n  had_zero = 0;\n  prevlines_length = 0;\n  }      /* Continue, starting to read the next header */\n\n/* At this point, we have read all the headers into a data structure in main\nstore. The first header is still the dummy placeholder for the Received: header\nwe are going to generate a bit later on. If next != NULL, it contains the first\ndata line - which terminated the headers before reaching a blank line (not the\nnormal case). */\n\nDEBUG(D_receive)\n  {\n  debug_printf(\">>Headers received:\\n\");\n  for (h = header_list->next; h; h = h->next)\n    debug_printf(\"%s\", h->text);\n  debug_printf(\"\\n\");\n  }\n\n/* End of file on any SMTP connection is an error. If an incoming SMTP call\nis dropped immediately after valid headers, the next thing we will see is EOF.\nWe must test for this specially, as further down the reading of the data is\nskipped if already at EOF. */\n\nif (smtp_input && (receive_feof)())\n  {\n  smtp_reply = handle_lost_connection(US\" (after header)\");\n  smtp_yield = FALSE;\n  goto TIDYUP;                       /* Skip to end of function */\n  }\n\n/* If this is a filter test run and no headers were read, output a warning\nin case there is a mistake in the test message. */\n\nif (filter_test != FTEST_NONE && header_list->next == NULL)\n  printf(\"Warning: no message headers read\\n\");\n\n\n/* Scan the headers to identify them. Some are merely marked for later\nprocessing; some are dealt with here. */\n\nfor (h = header_list->next; h; h = h->next)\n  {\n  BOOL is_resent = strncmpic(h->text, US\"resent-\", 7) == 0;\n  if (is_resent) contains_resent_headers = TRUE;\n\n  switch (header_checkname(h, is_resent))\n    {\n    case htype_bcc:\n    h->type = htype_bcc;        /* Both Bcc: and Resent-Bcc: */\n    break;\n\n    case htype_cc:\n    h->type = htype_cc;         /* Both Cc: and Resent-Cc: */\n    break;\n\n    /* Record whether a Date: or Resent-Date: header exists, as appropriate. */\n\n    case htype_date:\n    if (!resents_exist || is_resent) date_header_exists = TRUE;\n    break;\n\n    /* Same comments as about Return-Path: below. */\n\n    case htype_delivery_date:\n    if (delivery_date_remove) h->type = htype_old;\n    break;\n\n    /* Same comments as about Return-Path: below. */\n\n    case htype_envelope_to:\n    if (envelope_to_remove) h->type = htype_old;\n    break;\n\n    /* Mark all \"From:\" headers so they get rewritten. Save the one that is to\n    be used for Sender: checking. For Sendmail compatibility, if the \"From:\"\n    header consists of just the login id of the user who called Exim, rewrite\n    it with the gecos field first. Apply this rule to Resent-From: if there\n    are resent- fields. */\n\n    case htype_from:\n    h->type = htype_from;\n    if (!resents_exist || is_resent)\n      {\n      from_header = h;\n      if (!smtp_input)\n        {\n        int len;\n        uschar *s = Ustrchr(h->text, ':') + 1;\n        while (isspace(*s)) s++;\n        len = h->slen - (s - h->text) - 1;\n        if (Ustrlen(originator_login) == len &&\n\t    strncmpic(s, originator_login, len) == 0)\n          {\n          uschar *name = is_resent? US\"Resent-From\" : US\"From\";\n          header_add(htype_from, \"%s: %s <%s@%s>\\n\", name, originator_name,\n            originator_login, qualify_domain_sender);\n          from_header = header_last;\n          h->type = htype_old;\n          DEBUG(D_receive|D_rewrite)\n            debug_printf(\"rewrote \\\"%s:\\\" header using gecos\\n\", name);\n         }\n        }\n      }\n    break;\n\n    /* Identify the Message-id: header for generating \"in-reply-to\" in the\n    autoreply transport. For incoming logging, save any resent- value. In both\n    cases, take just the first of any multiples. */\n\n    case htype_id:\n    if (msgid_header == NULL && (!resents_exist || is_resent))\n      {\n      msgid_header = h;\n      h->type = htype_id;\n      }\n    break;\n\n    /* Flag all Received: headers */\n\n    case htype_received:\n    h->type = htype_received;\n    received_count++;\n    break;\n\n    /* \"Reply-to:\" is just noted (there is no resent-reply-to field) */\n\n    case htype_reply_to:\n    h->type = htype_reply_to;\n    break;\n\n    /* The Return-path: header is supposed to be added to messages when\n    they leave the SMTP system. We shouldn't receive messages that already\n    contain Return-path. However, since Exim generates Return-path: on\n    local delivery, resent messages may well contain it. We therefore\n    provide an option (which defaults on) to remove any Return-path: headers\n    on input. Removal actually means flagging as \"old\", which prevents the\n    header being transmitted with the message. */\n\n    case htype_return_path:\n    if (return_path_remove) h->type = htype_old;\n\n    /* If we are testing a mail filter file, use the value of the\n    Return-Path: header to set up the return_path variable, which is not\n    otherwise set. However, remove any <> that surround the address\n    because the variable doesn't have these. */\n\n    if (filter_test != FTEST_NONE)\n      {\n      uschar *start = h->text + 12;\n      uschar *end = start + Ustrlen(start);\n      while (isspace(*start)) start++;\n      while (end > start && isspace(end[-1])) end--;\n      if (*start == '<' && end[-1] == '>')\n        {\n        start++;\n        end--;\n        }\n      return_path = string_copyn(start, end - start);\n      printf(\"Return-path taken from \\\"Return-path:\\\" header line\\n\");\n      }\n    break;\n\n    /* If there is a \"Sender:\" header and the message is locally originated,\n    and from an untrusted caller and suppress_local_fixups is not set, or if we\n    are in submission mode for a remote message, mark it \"old\" so that it will\n    not be transmitted with the message, unless active_local_sender_retain is\n    set. (This can only be true if active_local_from_check is false.) If there\n    are any resent- headers in the message, apply this rule to Resent-Sender:\n    instead of Sender:. Messages with multiple resent- header sets cannot be\n    tidily handled. (For this reason, at least one MUA - Pine - turns old\n    resent- headers into X-resent- headers when resending, leaving just one\n    set.) */\n\n    case htype_sender:\n    h->type = ((!active_local_sender_retain &&\n                (\n                (sender_local && !trusted_caller && !suppress_local_fixups)\n                  || submission_mode\n                )\n               ) &&\n               (!resents_exist||is_resent))?\n      htype_old : htype_sender;\n    break;\n\n    /* Remember the Subject: header for logging. There is no Resent-Subject */\n\n    case htype_subject:\n    subject_header = h;\n    break;\n\n    /* \"To:\" gets flagged, and the existence of a recipient header is noted,\n    whether it's resent- or not. */\n\n    case htype_to:\n    h->type = htype_to;\n    /****\n    to_or_cc_header_exists = TRUE;\n    ****/\n    break;\n    }\n  }\n\n/* Extract recipients from the headers if that is required (the -t option).\nNote that this is documented as being done *before* any address rewriting takes\nplace. There are two possibilities:\n\n(1) According to sendmail documentation for Solaris, IRIX, and HP-UX, any\nrecipients already listed are to be REMOVED from the message. Smail 3 works\nlike this. We need to build a non-recipients tree for that list, because in\nsubsequent processing this data is held in a tree and that's what the\nspool_write_header() function expects. Make sure that non-recipient addresses\nare fully qualified and rewritten if necessary.\n\n(2) According to other sendmail documentation, -t ADDS extracted recipients to\nthose in the command line arguments (and it is rumoured some other MTAs do\nthis). Therefore, there is an option to make Exim behave this way.\n\n*** Notes on \"Resent-\" header lines ***\n\nThe presence of resent-headers in the message makes -t horribly ambiguous.\nExperiments with sendmail showed that it uses recipients for all resent-\nheaders, totally ignoring the concept of \"sets of resent- headers\" as described\nin RFC 2822 section 3.6.6. Sendmail also amalgamates them into a single set\nwith all the addresses in one instance of each header.\n\nThis seems to me not to be at all sensible. Before release 4.20, Exim 4 gave an\nerror for -t if there were resent- headers in the message. However, after a\ndiscussion on the mailing list, I've learned that there are MUAs that use\nresent- headers with -t, and also that the stuff about sets of resent- headers\nand their ordering in RFC 2822 is generally ignored. An MUA that submits a\nmessage with -t and resent- header lines makes sure that only *its* resent-\nheaders are present; previous ones are often renamed as X-resent- for example.\n\nConsequently, Exim has been changed so that, if any resent- header lines are\npresent, the recipients are taken from all of the appropriate resent- lines,\nand not from the ordinary To:, Cc:, etc. */\n\nif (extract_recip)\n  {\n  int rcount = 0;\n  error_block **bnext = &bad_addresses;\n\n  if (extract_addresses_remove_arguments)\n    {\n    while (recipients_count-- > 0)\n      {\n      uschar *s = rewrite_address(recipients_list[recipients_count].address,\n        TRUE, TRUE, global_rewrite_rules, rewrite_existflags);\n      tree_add_nonrecipient(s);\n      }\n    recipients_list = NULL;\n    recipients_count = recipients_list_max = 0;\n    }\n\n  /* Now scan the headers */\n\n  for (h = header_list->next; h; h = h->next)\n    {\n    if ((h->type == htype_to || h->type == htype_cc || h->type == htype_bcc) &&\n        (!contains_resent_headers || strncmpic(h->text, US\"resent-\", 7) == 0))\n      {\n      uschar *s = Ustrchr(h->text, ':') + 1;\n      while (isspace(*s)) s++;\n\n      parse_allow_group = TRUE;          /* Allow address group syntax */\n\n      while (*s != 0)\n        {\n        uschar *ss = parse_find_address_end(s, FALSE);\n        uschar *recipient, *errmess, *p, *pp;\n        int start, end, domain;\n\n        /* Check on maximum */\n\n        if (recipients_max > 0 && ++rcount > recipients_max)\n          {\n          give_local_error(ERRMESS_TOOMANYRECIP, US\"too many recipients\",\n            US\"message rejected: \", error_rc, stdin, NULL);\n          /* Does not return */\n          }\n\n        /* Make a copy of the address, and remove any internal newlines. These\n        may be present as a result of continuations of the header line. The\n        white space that follows the newline must not be removed - it is part\n        of the header. */\n\n        pp = recipient = store_get(ss - s + 1);\n        for (p = s; p < ss; p++) if (*p != '\\n') *pp++ = *p;\n        *pp = 0;\n\n#ifdef SUPPORT_I18N\n\t{\n\tBOOL b = allow_utf8_domains;\n\tallow_utf8_domains = TRUE;\n#endif\n        recipient = parse_extract_address(recipient, &errmess, &start, &end,\n          &domain, FALSE);\n\n#ifdef SUPPORT_I18N\n\tif (string_is_utf8(recipient))\n\t  message_smtputf8 = TRUE;\n\telse\n\t  allow_utf8_domains = b;\n\t}\n#endif\n\n        /* Keep a list of all the bad addresses so we can send a single\n        error message at the end. However, an empty address is not an error;\n        just ignore it. This can come from an empty group list like\n\n          To: Recipients of list:;\n\n        If there are no recipients at all, an error will occur later. */\n\n        if (recipient == NULL && Ustrcmp(errmess, \"empty address\") != 0)\n          {\n          int len = Ustrlen(s);\n          error_block *b = store_get(sizeof(error_block));\n          while (len > 0 && isspace(s[len-1])) len--;\n          b->next = NULL;\n          b->text1 = string_printing(string_copyn(s, len));\n          b->text2 = errmess;\n          *bnext = b;\n          bnext = &(b->next);\n          }\n\n        /* If the recipient is already in the nonrecipients tree, it must\n        have appeared on the command line with the option extract_addresses_\n        remove_arguments set. Do not add it to the recipients, and keep a note\n        that this has happened, in order to give a better error if there are\n        no recipients left. */\n\n        else if (recipient != NULL)\n          {\n          if (tree_search(tree_nonrecipients, recipient) == NULL)\n            receive_add_recipient(recipient, -1);\n          else\n            extracted_ignored = TRUE;\n          }\n\n        /* Move on past this address */\n\n        s = ss + (*ss? 1:0);\n        while (isspace(*s)) s++;\n        }    /* Next address */\n\n      parse_allow_group = FALSE;      /* Reset group syntax flags */\n      parse_found_group = FALSE;\n\n      /* If this was the bcc: header, mark it \"old\", which means it\n      will be kept on the spool, but not transmitted as part of the\n      message. */\n\n      if (h->type == htype_bcc) h->type = htype_old;\n      }   /* For appropriate header line */\n    }     /* For each header line */\n\n  }\n\n/* Now build the unique message id. This has changed several times over the\nlifetime of Exim. This description was rewritten for Exim 4.14 (February 2003).\nRetaining all the history in the comment has become too unwieldy - read\nprevious release sources if you want it.\n\nThe message ID has 3 parts: tttttt-pppppp-ss. Each part is a number in base 62.\nThe first part is the current time, in seconds. The second part is the current\npid. Both are large enough to hold 32-bit numbers in base 62. The third part\ncan hold a number in the range 0-3843. It used to be a computed sequence\nnumber, but is now the fractional component of the current time in units of\n1/2000 of a second (i.e. a value in the range 0-1999). After a message has been\nreceived, Exim ensures that the timer has ticked at the appropriate level\nbefore proceeding, to avoid duplication if the pid happened to be re-used\nwithin the same time period. It seems likely that most messages will take at\nleast half a millisecond to be received, so no delay will normally be\nnecessary. At least for some time...\n\nThere is a modification when localhost_number is set. Formerly this was allowed\nto be as large as 255. Now it is restricted to the range 0-16, and the final\ncomponent of the message id becomes (localhost_number * 200) + fractional time\nin units of 1/200 of a second (i.e. a value in the range 0-3399).\n\nSome not-really-Unix operating systems use case-insensitive file names (Darwin,\nCygwin). For these, we have to use base 36 instead of base 62. Luckily, this\nstill allows the tttttt field to hold a large enough number to last for some\nmore decades, and the final two-digit field can hold numbers up to 1295, which\nis enough for milliseconds (instead of 1/2000 of a second).\n\nHowever, the pppppp field cannot hold a 32-bit pid, but it can hold a 31-bit\npid, so it is probably safe because pids have to be positive. The\nlocalhost_number is restricted to 0-10 for these hosts, and when it is set, the\nfinal field becomes (localhost_number * 100) + fractional time in centiseconds.\n\nNote that string_base62() returns its data in a static storage block, so it\nmust be copied before calling string_base62() again. It always returns exactly\n6 characters.\n\nThere doesn't seem to be anything in the RFC which requires a message id to\nstart with a letter, but Smail was changed to ensure this. The external form of\nthe message id (as supplied by string expansion) therefore starts with an\nadditional leading 'E'. The spool file names do not include this leading\nletter and it is not used internally.\n\nNOTE: If ever the format of message ids is changed, the regular expression for\nchecking that a string is in this format must be updated in a corresponding\nway. It appears in the initializing code in exim.c. The macro MESSAGE_ID_LENGTH\nmust also be changed to reflect the correct string length. The queue-sort code\nneeds to know the layout. Then, of course, other programs that rely on the\nmessage id format will need updating too. */\n\nUstrncpy(message_id, string_base62((long int)(message_id_tv.tv_sec)), 6);\nmessage_id[6] = '-';\nUstrncpy(message_id + 7, string_base62((long int)getpid()), 6);\n\n/* Deal with the case where the host number is set. The value of the number was\nchecked when it was read, to ensure it isn't too big. The timing granularity is\nleft in id_resolution so that an appropriate wait can be done after receiving\nthe message, if necessary (we hope it won't be). */\n\nif (host_number_string != NULL)\n  {\n  id_resolution = (BASE_62 == 62)? 5000 : 10000;\n  sprintf(CS(message_id + MESSAGE_ID_LENGTH - 3), \"-%2s\",\n    string_base62((long int)(\n      host_number * (1000000/id_resolution) +\n        message_id_tv.tv_usec/id_resolution)) + 4);\n  }\n\n/* Host number not set: final field is just the fractional time at an\nappropriate resolution. */\n\nelse\n  {\n  id_resolution = (BASE_62 == 62)? 500 : 1000;\n  sprintf(CS(message_id + MESSAGE_ID_LENGTH - 3), \"-%2s\",\n    string_base62((long int)(message_id_tv.tv_usec/id_resolution)) + 4);\n  }\n\n/* Add the current message id onto the current process info string if\nit will fit. */\n\n(void)string_format(process_info + process_info_len,\n  PROCESS_INFO_SIZE - process_info_len, \" id=%s\", message_id);\n\n/* If we are using multiple input directories, set up the one for this message\nto be the least significant base-62 digit of the time of arrival. Otherwise\nensure that it is an empty string. */\n\nmessage_subdir[0] = split_spool_directory ? message_id[5] : 0;\n\n/* Now that we have the message-id, if there is no message-id: header, generate\none, but only for local (without suppress_local_fixups) or submission mode\nmessages. This can be user-configured if required, but we had better flatten\nany illegal characters therein. */\n\nif (msgid_header == NULL &&\n      ((sender_host_address == NULL && !suppress_local_fixups)\n        || submission_mode))\n  {\n  uschar *p;\n  uschar *id_text = US\"\";\n  uschar *id_domain = primary_hostname;\n\n  /* Permit only letters, digits, dots, and hyphens in the domain */\n\n  if (message_id_domain != NULL)\n    {\n    uschar *new_id_domain = expand_string(message_id_domain);\n    if (new_id_domain == NULL)\n      {\n      if (!expand_string_forcedfail)\n        log_write(0, LOG_MAIN|LOG_PANIC,\n          \"expansion of \\\"%s\\\" (message_id_header_domain) \"\n          \"failed: %s\", message_id_domain, expand_string_message);\n      }\n    else if (*new_id_domain != 0)\n      {\n      id_domain = new_id_domain;\n      for (p = id_domain; *p != 0; p++)\n        if (!isalnum(*p) && *p != '.') *p = '-';  /* No need to test '-' ! */\n      }\n    }\n\n  /* Permit all characters except controls and RFC 2822 specials in the\n  additional text part. */\n\n  if (message_id_text != NULL)\n    {\n    uschar *new_id_text = expand_string(message_id_text);\n    if (new_id_text == NULL)\n      {\n      if (!expand_string_forcedfail)\n        log_write(0, LOG_MAIN|LOG_PANIC,\n          \"expansion of \\\"%s\\\" (message_id_header_text) \"\n          \"failed: %s\", message_id_text, expand_string_message);\n      }\n    else if (*new_id_text != 0)\n      {\n      id_text = new_id_text;\n      for (p = id_text; *p != 0; p++)\n        if (mac_iscntrl_or_special(*p)) *p = '-';\n      }\n    }\n\n  /* Add the header line\n   * Resent-* headers are prepended, per RFC 5322 3.6.6.  Non-Resent-* are\n   * appended, to preserve classical expectations of header ordering. */\n\n  header_add_at_position(!resents_exist, NULL, FALSE, htype_id,\n    \"%sMessage-Id: <%s%s%s@%s>\\n\", resent_prefix, message_id_external,\n    (*id_text == 0)? \"\" : \".\", id_text, id_domain);\n  }\n\n/* If we are to log recipients, keep a copy of the raw ones before any possible\nrewriting. Must copy the count, because later ACLs and the local_scan()\nfunction may mess with the real recipients. */\n\nif (LOGGING(received_recipients))\n  {\n  raw_recipients = store_get(recipients_count * sizeof(uschar *));\n  for (i = 0; i < recipients_count; i++)\n    raw_recipients[i] = string_copy(recipients_list[i].address);\n  raw_recipients_count = recipients_count;\n  }\n\n/* Ensure the recipients list is fully qualified and rewritten. Unqualified\nrecipients will get here only if the conditions were right (allow_unqualified_\nrecipient is TRUE). */\n\nfor (i = 0; i < recipients_count; i++)\n  recipients_list[i].address =\n    rewrite_address(recipients_list[i].address, TRUE, TRUE,\n      global_rewrite_rules, rewrite_existflags);\n\n/* If there is no From: header, generate one for local (without\nsuppress_local_fixups) or submission_mode messages. If there is no sender\naddress, but the sender is local or this is a local delivery error, use the\noriginator login. This shouldn't happen for genuine bounces, but might happen\nfor autoreplies. The addition of From: must be done *before* checking for the\npossible addition of a Sender: header, because untrusted_set_sender allows an\nuntrusted user to set anything in the envelope (which might then get info\nFrom:) but we still want to ensure a valid Sender: if it is required. */\n\nif (from_header == NULL &&\n    ((sender_host_address == NULL && !suppress_local_fixups)\n      || submission_mode))\n  {\n  uschar *oname = US\"\";\n\n  /* Use the originator_name if this is a locally submitted message and the\n  caller is not trusted. For trusted callers, use it only if -F was used to\n  force its value or if we have a non-SMTP message for which -f was not used\n  to set the sender. */\n\n  if (sender_host_address == NULL)\n    {\n    if (!trusted_caller || sender_name_forced ||\n         (!smtp_input && !sender_address_forced))\n      oname = originator_name;\n    }\n\n  /* For non-locally submitted messages, the only time we use the originator\n  name is when it was forced by the /name= option on control=submission. */\n\n  else\n    {\n    if (submission_name != NULL) oname = submission_name;\n    }\n\n  /* Envelope sender is empty */\n\n  if (sender_address[0] == 0)\n    {\n    uschar *fromstart, *fromend;\n\n    fromstart = string_sprintf(\"%sFrom: %s%s\", resent_prefix,\n      oname, (oname[0] == 0)? \"\" : \" <\");\n    fromend = (oname[0] == 0)? US\"\" : US\">\";\n\n    if (sender_local || local_error_message)\n      {\n      header_add(htype_from, \"%s%s@%s%s\\n\", fromstart,\n        local_part_quote(originator_login), qualify_domain_sender,\n        fromend);\n      }\n    else if (submission_mode && authenticated_id != NULL)\n      {\n      if (submission_domain == NULL)\n        {\n        header_add(htype_from, \"%s%s@%s%s\\n\", fromstart,\n          local_part_quote(authenticated_id), qualify_domain_sender,\n          fromend);\n        }\n      else if (submission_domain[0] == 0)  /* empty => whole address set */\n        {\n        header_add(htype_from, \"%s%s%s\\n\", fromstart, authenticated_id,\n          fromend);\n        }\n      else\n        {\n        header_add(htype_from, \"%s%s@%s%s\\n\", fromstart,\n          local_part_quote(authenticated_id), submission_domain,\n          fromend);\n        }\n      from_header = header_last;    /* To get it checked for Sender: */\n      }\n    }\n\n  /* There is a non-null envelope sender. Build the header using the original\n  sender address, before any rewriting that might have been done while\n  verifying it. */\n\n  else\n    {\n    header_add(htype_from, \"%sFrom: %s%s%s%s\\n\", resent_prefix,\n      oname,\n      (oname[0] == 0)? \"\" : \" <\",\n      (sender_address_unrewritten == NULL)?\n        sender_address : sender_address_unrewritten,\n      (oname[0] == 0)? \"\" : \">\");\n\n    from_header = header_last;    /* To get it checked for Sender: */\n    }\n  }\n\n\n/* If the sender is local (without suppress_local_fixups), or if we are in\nsubmission mode and there is an authenticated_id, check that an existing From:\nis correct, and if not, generate a Sender: header, unless disabled. Any\npreviously-existing Sender: header was removed above. Note that sender_local,\nas well as being TRUE if the caller of exim is not trusted, is also true if a\ntrusted caller did not supply a -f argument for non-smtp input. To allow\ntrusted callers to forge From: without supplying -f, we have to test explicitly\nhere. If the From: header contains more than one address, then the call to\nparse_extract_address fails, and a Sender: header is inserted, as required. */\n\nif (from_header != NULL &&\n     (active_local_from_check &&\n       ((sender_local && !trusted_caller && !suppress_local_fixups) ||\n        (submission_mode && authenticated_id != NULL))\n     ))\n  {\n  BOOL make_sender = TRUE;\n  int start, end, domain;\n  uschar *errmess;\n  uschar *from_address =\n    parse_extract_address(Ustrchr(from_header->text, ':') + 1, &errmess,\n      &start, &end, &domain, FALSE);\n  uschar *generated_sender_address;\n\n  if (submission_mode)\n    {\n    if (submission_domain == NULL)\n      {\n      generated_sender_address = string_sprintf(\"%s@%s\",\n        local_part_quote(authenticated_id), qualify_domain_sender);\n      }\n    else if (submission_domain[0] == 0)  /* empty => full address */\n      {\n      generated_sender_address = string_sprintf(\"%s\",\n        authenticated_id);\n      }\n    else\n      {\n      generated_sender_address = string_sprintf(\"%s@%s\",\n        local_part_quote(authenticated_id), submission_domain);\n      }\n    }\n  else\n    generated_sender_address = string_sprintf(\"%s@%s\",\n      local_part_quote(originator_login), qualify_domain_sender);\n\n  /* Remove permitted prefixes and suffixes from the local part of the From:\n  address before doing the comparison with the generated sender. */\n\n  if (from_address != NULL)\n    {\n    int slen;\n    uschar *at = (domain == 0)? NULL : from_address + domain - 1;\n\n    if (at != NULL) *at = 0;\n    from_address += route_check_prefix(from_address, local_from_prefix);\n    slen = route_check_suffix(from_address, local_from_suffix);\n    if (slen > 0)\n      {\n      memmove(from_address+slen, from_address, Ustrlen(from_address)-slen);\n      from_address += slen;\n      }\n    if (at != NULL) *at = '@';\n\n    if (strcmpic(generated_sender_address, from_address) == 0 ||\n      (domain == 0 && strcmpic(from_address, originator_login) == 0))\n        make_sender = FALSE;\n    }\n\n  /* We have to cause the Sender header to be rewritten if there are\n  appropriate rewriting rules. */\n\n  if (make_sender)\n    {\n    if (submission_mode && submission_name == NULL)\n      header_add(htype_sender, \"%sSender: %s\\n\", resent_prefix,\n        generated_sender_address);\n    else\n      header_add(htype_sender, \"%sSender: %s <%s>\\n\",\n        resent_prefix,\n        submission_mode? submission_name : originator_name,\n        generated_sender_address);\n    }\n\n  /* Ensure that a non-null envelope sender address corresponds to the\n  submission mode sender address. */\n\n  if (submission_mode && sender_address[0] != 0)\n    {\n    if (sender_address_unrewritten == NULL)\n      sender_address_unrewritten = sender_address;\n    sender_address = generated_sender_address;\n    if (Ustrcmp(sender_address_unrewritten, generated_sender_address) != 0)\n      log_write(L_address_rewrite, LOG_MAIN,\n        \"\\\"%s\\\" from env-from rewritten as \\\"%s\\\" by submission mode\",\n        sender_address_unrewritten, generated_sender_address);\n    }\n  }\n\n/* If there are any rewriting rules, apply them to the sender address, unless\nit has already been rewritten as part of verification for SMTP input. */\n\nif (global_rewrite_rules != NULL && sender_address_unrewritten == NULL &&\n    sender_address[0] != 0)\n  {\n  sender_address = rewrite_address(sender_address, FALSE, TRUE,\n    global_rewrite_rules, rewrite_existflags);\n  DEBUG(D_receive|D_rewrite)\n    debug_printf(\"rewritten sender = %s\\n\", sender_address);\n  }\n\n\n/* The headers must be run through rewrite_header(), because it ensures that\naddresses are fully qualified, as well as applying any rewriting rules that may\nexist.\n\nQualification of header addresses in a message from a remote host happens only\nif the host is in sender_unqualified_hosts or recipient_unqualified hosts, as\nappropriate. For local messages, qualification always happens, unless -bnq is\nused to explicitly suppress it. No rewriting is done for an unqualified address\nthat is left untouched.\n\nWe start at the second header, skipping our own Received:. This rewriting is\ndocumented as happening *after* recipient addresses are taken from the headers\nby the -t command line option. An added Sender: gets rewritten here. */\n\nfor (h = header_list->next; h; h = h->next)\n  {\n  header_line *newh = rewrite_header(h, NULL, NULL, global_rewrite_rules,\n    rewrite_existflags, TRUE);\n  if (newh) h = newh;\n  }\n\n\n/* An RFC 822 (sic) message is not legal unless it has at least one of \"to\",\n\"cc\", or \"bcc\". Note that although the minimal examples in RFC 822 show just\n\"to\" or \"bcc\", the full syntax spec allows \"cc\" as well. If any resent- header\nexists, this applies to the set of resent- headers rather than the normal set.\n\nThe requirement for a recipient header has been removed in RFC 2822. At this\npoint in the code, earlier versions of Exim added a To: header for locally\nsubmitted messages, and an empty Bcc: header for others. In the light of the\nchanges in RFC 2822, this was dropped in November 2003. */\n\n\n/* If there is no date header, generate one if the message originates locally\n(i.e. not over TCP/IP) and suppress_local_fixups is not set, or if the\nsubmission mode flag is set. Messages without Date: are not valid, but it seems\nto be more confusing if Exim adds one to all remotely-originated messages.\nAs per Message-Id, we prepend if resending, else append.\n*/\n\nif (!date_header_exists &&\n      ((sender_host_address == NULL && !suppress_local_fixups)\n        || submission_mode))\n  header_add_at_position(!resents_exist, NULL, FALSE, htype_other,\n    \"%sDate: %s\\n\", resent_prefix, tod_stamp(tod_full));\n\nsearch_tidyup();    /* Free any cached resources */\n\n/* Show the complete set of headers if debugging. Note that the first one (the\nnew Received:) has not yet been set. */\n\nDEBUG(D_receive)\n  {\n  debug_printf(\">>Headers after rewriting and local additions:\\n\");\n  for (h = header_list->next; h != NULL; h = h->next)\n    debug_printf(\"%c %s\", h->type, h->text);\n  debug_printf(\"\\n\");\n  }\n\n/* The headers are now complete in store. If we are running in filter\ntesting mode, that is all this function does. Return TRUE if the message\nended with a dot. */\n\nif (filter_test != FTEST_NONE)\n  {\n  process_info[process_info_len] = 0;\n  return message_ended == END_DOT;\n  }\n\n/*XXX CHUNKING: need to cancel cutthrough under BDAT, for now.  In future,\nthink more if it could be handled.  Cannot do onward CHUNKING unless\ninbound is, but inbound chunking ought to be ok with outbound plain.\nCould we do onward CHUNKING given inbound CHUNKING?\n*/\nif (chunking_state > CHUNKING_OFFERED)\n  cancel_cutthrough_connection(FALSE, US\"chunking active\");\n\n/* Cutthrough delivery:\nWe have to create the Received header now rather than at the end of reception,\nso the timestamp behaviour is a change to the normal case.\nHaving created it, send the headers to the destination. */\n\nif (cutthrough.fd >= 0 && cutthrough.delivery)\n  {\n  if (received_count > received_headers_max)\n    {\n    cancel_cutthrough_connection(TRUE, US\"too many headers\");\n    if (smtp_input) receive_swallow_smtp();  /* Swallow incoming SMTP */\n    log_write(0, LOG_MAIN|LOG_REJECT, \"rejected from <%s>%s%s%s%s: \"\n      \"Too many \\\"Received\\\" headers\",\n      sender_address,\n      sender_fullhost ? \"H=\" : \"\", sender_fullhost ? sender_fullhost : US\"\",\n      sender_ident ? \"U=\" : \"\", sender_ident ? sender_ident : US\"\");\n    message_id[0] = 0;                       /* Indicate no message accepted */\n    smtp_reply = US\"550 Too many \\\"Received\\\" headers - suspected mail loop\";\n    goto TIDYUP;                             /* Skip to end of function */\n    }\n  received_header_gen();\n  add_acl_headers(ACL_WHERE_RCPT, US\"MAIL or RCPT\");\n  (void) cutthrough_headers_send();\n  }\n\n\n/* Open a new spool file for the data portion of the message. We need\nto access it both via a file descriptor and a stream. Try to make the\ndirectory if it isn't there. */\n\nspool_name = spool_fname(US\"input\", message_subdir, message_id, US\"-D\");\nDEBUG(D_receive) debug_printf(\"Data file name: %s\\n\", spool_name);\n\nif ((data_fd = Uopen(spool_name, O_RDWR|O_CREAT|O_EXCL, SPOOL_MODE)) < 0)\n  {\n  if (errno == ENOENT)\n    {\n    (void) directory_make(spool_directory,\n\t\t        spool_sname(US\"input\", message_subdir),\n\t\t\tINPUT_DIRECTORY_MODE, TRUE);\n    data_fd = Uopen(spool_name, O_RDWR|O_CREAT|O_EXCL, SPOOL_MODE);\n    }\n  if (data_fd < 0)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"Failed to create spool file %s: %s\",\n      spool_name, strerror(errno));\n  }\n\n/* Make sure the file's group is the Exim gid, and double-check the mode\nbecause the group setting doesn't always get set automatically. */\n\nif (fchown(data_fd, exim_uid, exim_gid))\n  log_write(0, LOG_MAIN|LOG_PANIC_DIE,\n    \"Failed setting ownership on spool file %s: %s\",\n    spool_name, strerror(errno));\n(void)fchmod(data_fd, SPOOL_MODE);\n\n/* We now have data file open. Build a stream for it and lock it. We lock only\nthe first line of the file (containing the message ID) because otherwise there\nare problems when Exim is run under Cygwin (I'm told). See comments in\nspool_in.c, where the same locking is done. */\n\ndata_file = fdopen(data_fd, \"w+\");\nlock_data.l_type = F_WRLCK;\nlock_data.l_whence = SEEK_SET;\nlock_data.l_start = 0;\nlock_data.l_len = SPOOL_DATA_START_OFFSET;\n\nif (fcntl(data_fd, F_SETLK, &lock_data) < 0)\n  log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"Cannot lock %s (%d): %s\", spool_name,\n    errno, strerror(errno));\n\n/* We have an open, locked data file. Write the message id to it to make it\nself-identifying. Then read the remainder of the input of this message and\nwrite it to the data file. If the variable next != NULL, it contains the first\ndata line (which was read as a header but then turned out not to have the right\nformat); write it (remembering that it might contain binary zeros). The result\nof fwrite() isn't inspected; instead we call ferror() below. */\n\nfprintf(data_file, \"%s-D\\n\", message_id);\nif (next != NULL)\n  {\n  uschar *s = next->text;\n  int len = next->slen;\n  len = fwrite(s, 1, len, data_file);  len = len; /* compiler quietening */\n  body_linecount++;                 /* Assumes only 1 line */\n  }\n\n/* Note that we might already be at end of file, or the logical end of file\n(indicated by '.'), or might have encountered an error while writing the\nmessage id or \"next\" line. */\n\nif (!ferror(data_file) && !(receive_feof)() && message_ended != END_DOT)\n  {\n  if (smtp_input)\n    {\n    message_ended = chunking_state <= CHUNKING_OFFERED\n      ? read_message_data_smtp(data_file)\n      : spool_wireformat\n      ? read_message_bdat_smtp_wire(data_file)\n      : read_message_bdat_smtp(data_file);\n    receive_linecount++;                /* The terminating \".\" line */\n    }\n  else message_ended = read_message_data(data_file);\n\n  receive_linecount += body_linecount;  /* For BSMTP errors mainly */\n  message_linecount += body_linecount;\n\n  switch (message_ended)\n    {\n    /* Handle premature termination of SMTP */\n\n    case END_EOF:\n      if (smtp_input)\n\t{\n\tUunlink(spool_name);                 /* Lose data file when closed */\n\tcancel_cutthrough_connection(TRUE, US\"sender closed connection\");\n\tmessage_id[0] = 0;                   /* Indicate no message accepted */\n\tsmtp_reply = handle_lost_connection(US\"\");\n\tsmtp_yield = FALSE;\n\tgoto TIDYUP;                         /* Skip to end of function */\n\t}\n      break;\n\n    /* Handle message that is too big. Don't use host_or_ident() in the log\n    message; we want to see the ident value even for non-remote messages. */\n\n    case END_SIZE:\n      Uunlink(spool_name);                /* Lose the data file when closed */\n      cancel_cutthrough_connection(TRUE, US\"mail too big\");\n      if (smtp_input) receive_swallow_smtp();  /* Swallow incoming SMTP */\n\n      log_write(L_size_reject, LOG_MAIN|LOG_REJECT, \"rejected from <%s>%s%s%s%s: \"\n\t\"message too big: read=%d max=%d\",\n\tsender_address,\n\t(sender_fullhost == NULL)? \"\" : \" H=\",\n\t(sender_fullhost == NULL)? US\"\" : sender_fullhost,\n\t(sender_ident == NULL)? \"\" : \" U=\",\n\t(sender_ident == NULL)? US\"\" : sender_ident,\n\tmessage_size,\n\tthismessage_size_limit);\n\n      if (smtp_input)\n\t{\n\tsmtp_reply = US\"552 Message size exceeds maximum permitted\";\n\tmessage_id[0] = 0;               /* Indicate no message accepted */\n\tgoto TIDYUP;                     /* Skip to end of function */\n\t}\n      else\n\t{\n\tfseek(data_file, (long int)SPOOL_DATA_START_OFFSET, SEEK_SET);\n\tgive_local_error(ERRMESS_TOOBIG,\n\t  string_sprintf(\"message too big (max=%d)\", thismessage_size_limit),\n\t  US\"message rejected: \", error_rc, data_file, header_list);\n\t/* Does not return */\n\t}\n      break;\n\n    /* Handle bad BDAT protocol sequence */\n\n    case END_PROTOCOL:\n      Uunlink(spool_name);\t\t/* Lose the data file when closed */\n      cancel_cutthrough_connection(TRUE, US\"sender protocol error\");\n      smtp_reply = US\"\";\t\t/* Response already sent */\n      message_id[0] = 0;\t\t/* Indicate no message accepted */\n      goto TIDYUP;\t\t\t/* Skip to end of function */\n    }\n  }\n\n/* Restore the standard SIGALRM handler for any subsequent processing. (For\nexample, there may be some expansion in an ACL that uses a timer.) */\n\nos_non_restarting_signal(SIGALRM, sigalrm_handler);\n\n/* The message body has now been read into the data file. Call fflush() to\nempty the buffers in C, and then call fsync() to get the data written out onto\nthe disk, as fflush() doesn't do this (or at least, it isn't documented as\nhaving to do this). If there was an I/O error on either input or output,\nattempt to send an error message, and unlink the spool file. For non-SMTP input\nwe can then give up. Note that for SMTP input we must swallow the remainder of\nthe input in cases of output errors, since the far end doesn't expect to see\nanything until the terminating dot line is sent. */\n\nif (fflush(data_file) == EOF || ferror(data_file) ||\n    EXIMfsync(fileno(data_file)) < 0 || (receive_ferror)())\n  {\n  uschar *msg_errno = US strerror(errno);\n  BOOL input_error = (receive_ferror)() != 0;\n  uschar *msg = string_sprintf(\"%s error (%s) while receiving message from %s\",\n    input_error? \"Input read\" : \"Spool write\",\n    msg_errno,\n    (sender_fullhost != NULL)? sender_fullhost : sender_ident);\n\n  log_write(0, LOG_MAIN, \"Message abandoned: %s\", msg);\n  Uunlink(spool_name);                /* Lose the data file */\n  cancel_cutthrough_connection(TRUE, US\"error writing spoolfile\");\n\n  if (smtp_input)\n    {\n    if (input_error)\n      smtp_reply = US\"451 Error while reading input data\";\n    else\n      {\n      smtp_reply = US\"451 Error while writing spool file\";\n      receive_swallow_smtp();\n      }\n    message_id[0] = 0;               /* Indicate no message accepted */\n    goto TIDYUP;                     /* Skip to end of function */\n    }\n\n  else\n    {\n    fseek(data_file, (long int)SPOOL_DATA_START_OFFSET, SEEK_SET);\n    give_local_error(ERRMESS_IOERR, msg, US\"\", error_rc, data_file,\n      header_list);\n    /* Does not return */\n    }\n  }\n\n\n/* No I/O errors were encountered while writing the data file. */\n\nDEBUG(D_receive) debug_printf(\"Data file written for message %s\\n\", message_id);\n\n\n/* If there were any bad addresses extracted by -t, or there were no recipients\nleft after -t, send a message to the sender of this message, or write it to\nstderr if the error handling option is set that way. Note that there may\nlegitimately be no recipients for an SMTP message if they have all been removed\nby \"discard\".\n\nWe need to rewind the data file in order to read it. In the case of no\nrecipients or stderr error writing, throw the data file away afterwards, and\nexit. (This can't be SMTP, which always ensures there's at least one\nsyntactically good recipient address.) */\n\nif (extract_recip && (bad_addresses != NULL || recipients_count == 0))\n  {\n  DEBUG(D_receive)\n    {\n    if (recipients_count == 0) debug_printf(\"*** No recipients\\n\");\n    if (bad_addresses != NULL)\n      {\n      error_block *eblock = bad_addresses;\n      debug_printf(\"*** Bad address(es)\\n\");\n      while (eblock != NULL)\n        {\n        debug_printf(\"  %s: %s\\n\", eblock->text1, eblock->text2);\n        eblock = eblock->next;\n        }\n      }\n    }\n\n  fseek(data_file, (long int)SPOOL_DATA_START_OFFSET, SEEK_SET);\n\n  /* If configured to send errors to the sender, but this fails, force\n  a failure error code. We use a special one for no recipients so that it\n  can be detected by the autoreply transport. Otherwise error_rc is set to\n  errors_sender_rc, which is EXIT_FAILURE unless -oee was given, in which case\n  it is EXIT_SUCCESS. */\n\n  if (error_handling == ERRORS_SENDER)\n    {\n    if (!moan_to_sender(\n          (bad_addresses == NULL)?\n            (extracted_ignored? ERRMESS_IGADDRESS : ERRMESS_NOADDRESS) :\n          (recipients_list == NULL)? ERRMESS_BADNOADDRESS : ERRMESS_BADADDRESS,\n          bad_addresses, header_list, data_file, FALSE))\n      error_rc = (bad_addresses == NULL)? EXIT_NORECIPIENTS : EXIT_FAILURE;\n    }\n  else\n    {\n    if (bad_addresses == NULL)\n      {\n      if (extracted_ignored)\n        fprintf(stderr, \"exim: all -t recipients overridden by command line\\n\");\n      else\n        fprintf(stderr, \"exim: no recipients in message\\n\");\n      }\n    else\n      {\n      fprintf(stderr, \"exim: invalid address%s\",\n        (bad_addresses->next == NULL)? \":\" : \"es:\\n\");\n      while (bad_addresses != NULL)\n        {\n        fprintf(stderr, \"  %s: %s\\n\", bad_addresses->text1,\n          bad_addresses->text2);\n        bad_addresses = bad_addresses->next;\n        }\n      }\n    }\n\n  if (recipients_count == 0 || error_handling == ERRORS_STDERR)\n    {\n    Uunlink(spool_name);\n    (void)fclose(data_file);\n    exim_exit(error_rc, US\"receiving\");\n    }\n  }\n\n/* Data file successfully written. Generate text for the Received: header by\nexpanding the configured string, and adding a timestamp. By leaving this\noperation till now, we ensure that the timestamp is the time that message\nreception was completed. However, this is deliberately done before calling the\ndata ACL and local_scan().\n\nThis Received: header may therefore be inspected by the data ACL and by code in\nthe local_scan() function. When they have run, we update the timestamp to be\nthe final time of reception.\n\nIf there is just one recipient, set up its value in the $received_for variable\nfor use when we generate the Received: header.\n\nNote: the checking for too many Received: headers is handled by the delivery\ncode. */\n/*XXX eventually add excess Received: check for cutthrough case back when classifying them */\n\nif (received_header->text == NULL)\t/* Non-cutthrough case */\n  {\n  received_header_gen();\n\n  /* Set the value of message_body_size for the DATA ACL and for local_scan() */\n\n  message_body_size = (fstat(data_fd, &statbuf) == 0)?\n    statbuf.st_size - SPOOL_DATA_START_OFFSET : -1;\n\n  /* If an ACL from any RCPT commands set up any warning headers to add, do so\n  now, before running the DATA ACL. */\n\n  add_acl_headers(ACL_WHERE_RCPT, US\"MAIL or RCPT\");\n  }\nelse\n  message_body_size = (fstat(data_fd, &statbuf) == 0)?\n    statbuf.st_size - SPOOL_DATA_START_OFFSET : -1;\n\n/* If an ACL is specified for checking things at this stage of reception of a\nmessage, run it, unless all the recipients were removed by \"discard\" in earlier\nACLs. That is the only case in which recipients_count can be zero at this\nstage. Set deliver_datafile to point to the data file so that $message_body and\n$message_body_end can be extracted if needed. Allow $recipients in expansions.\n*/\n\ndeliver_datafile = data_fd;\nuser_msg = NULL;\n\nenable_dollar_recipients = TRUE;\n\nif (recipients_count == 0)\n  blackholed_by = recipients_discarded ? US\"MAIL ACL\" : US\"RCPT ACL\";\n\nelse\n  {\n  /* Handle interactive SMTP messages */\n\n  if (smtp_input && !smtp_batched_input)\n    {\n\n#ifndef DISABLE_DKIM\n    if (!dkim_disable_verify)\n      {\n      /* Finish verification */\n      dkim_exim_verify_finish();\n\n      /* Check if we must run the DKIM ACL */\n      if (acl_smtp_dkim && dkim_verify_signers && *dkim_verify_signers)\n        {\n        uschar * dkim_verify_signers_expanded =\n          expand_string(dkim_verify_signers);\n\tgstring * results = NULL;\n\tint signer_sep = 0;\n\tconst uschar * ptr;\n\tuschar * item;\n\tgstring * seen_items = NULL;\n\tint old_pool = store_pool;\n\n\tstore_pool = POOL_PERM;   /* Allow created variables to live to data ACL */\n\n        if (!(ptr = dkim_verify_signers_expanded))\n          log_write(0, LOG_MAIN|LOG_PANIC,\n            \"expansion of dkim_verify_signers option failed: %s\",\n            expand_string_message);\n\n\t/* Default to OK when no items are present */\n\trc = OK;\n\twhile ((item = string_nextinlist(&ptr, &signer_sep, NULL, 0)))\n\t  {\n\t  /* Prevent running ACL for an empty item */\n\t  if (!item || !*item) continue;\n\n\t  /* Only run ACL once for each domain or identity,\n\t  no matter how often it appears in the expanded list. */\n\t  if (seen_items)\n\t    {\n\t    uschar * seen_item;\n\t    const uschar * seen_items_list = string_from_gstring(seen_items);\n\t    int seen_sep = ':';\n\t    BOOL seen_this_item = FALSE;\n\n\t    while ((seen_item = string_nextinlist(&seen_items_list, &seen_sep,\n\t\t\t\t\t\t  NULL, 0)))\n\t      if (Ustrcmp(seen_item,item) == 0)\n\t\t{\n\t\tseen_this_item = TRUE;\n\t\tbreak;\n\t\t}\n\n\t    if (seen_this_item)\n\t      {\n\t      DEBUG(D_receive)\n\t\tdebug_printf(\"acl_smtp_dkim: skipping signer %s, \"\n\t\t  \"already seen\\n\", item);\n\t      continue;\n\t      }\n\n\t    seen_items = string_catn(seen_items, \":\", 1);\n\t    }\n\t  seen_items = string_cat(seen_items, item);\n\n\t  rc = dkim_exim_acl_run(item, &results, &user_msg, &log_msg);\n\t  if (rc != OK)\n\t    {\n\t    DEBUG(D_receive)\n\t      debug_printf(\"acl_smtp_dkim: acl_check returned %d on %s, \"\n\t\t\"skipping remaining items\\n\", rc, item);\n\t    cancel_cutthrough_connection(TRUE, US\"dkim acl not ok\");\n\t    break;\n\t    }\n\t  }\n\tdkim_verify_status = string_from_gstring(results);\n\tstore_pool = old_pool;\n\tadd_acl_headers(ACL_WHERE_DKIM, US\"DKIM\");\n\tif (rc == DISCARD)\n\t  {\n\t  recipients_count = 0;\n\t  blackholed_by = US\"DKIM ACL\";\n\t  if (log_msg)\n\t    blackhole_log_msg = string_sprintf(\": %s\", log_msg);\n\t  }\n\telse if (rc != OK)\n\t  {\n\t  Uunlink(spool_name);\n\t  if (smtp_handle_acl_fail(ACL_WHERE_DKIM, rc, user_msg, log_msg) != 0)\n\t    smtp_yield = FALSE;    /* No more messages after dropped connection */\n\t  smtp_reply = US\"\";       /* Indicate reply already sent */\n\t  message_id[0] = 0;       /* Indicate no message accepted */\n\t  goto TIDYUP;             /* Skip to end of function */\n\t  }\n        }\n      else\n\tdkim_exim_verify_log_all();\n      }\n#endif /* DISABLE_DKIM */\n\n#ifdef WITH_CONTENT_SCAN\n    if (recipients_count > 0 &&\n        acl_smtp_mime != NULL &&\n        !run_mime_acl(acl_smtp_mime, &smtp_yield, &smtp_reply, &blackholed_by))\n      goto TIDYUP;\n#endif /* WITH_CONTENT_SCAN */\n\n#ifdef EXPERIMENTAL_DMARC\n    dmarc_up = dmarc_store_data(from_header);\n#endif /* EXPERIMENTAL_DMARC */\n\n#ifndef DISABLE_PRDR\n    if (prdr_requested && recipients_count > 1 && acl_smtp_data_prdr)\n      {\n      unsigned int c;\n      int all_pass = OK;\n      int all_fail = FAIL;\n\n      smtp_printf(\"353 PRDR content analysis beginning\\r\\n\", TRUE);\n      /* Loop through recipients, responses must be in same order received */\n      for (c = 0; recipients_count > c; c++)\n        {\n\tuschar * addr= recipients_list[c].address;\n\tuschar * msg= US\"PRDR R=<%s> %s\";\n\tuschar * code;\n        DEBUG(D_receive)\n          debug_printf(\"PRDR processing recipient %s (%d of %d)\\n\",\n                       addr, c+1, recipients_count);\n        rc = acl_check(ACL_WHERE_PRDR, addr,\n                       acl_smtp_data_prdr, &user_msg, &log_msg);\n\n        /* If any recipient rejected content, indicate it in final message */\n        all_pass |= rc;\n        /* If all recipients rejected, indicate in final message */\n        all_fail &= rc;\n\n        switch (rc)\n          {\n          case OK: case DISCARD: code = US\"250\"; break;\n          case DEFER:            code = US\"450\"; break;\n          default:               code = US\"550\"; break;\n          }\n\tif (user_msg != NULL)\n\t  smtp_user_msg(code, user_msg);\n\telse\n\t  {\n\t  switch (rc)\n            {\n            case OK: case DISCARD:\n              msg = string_sprintf(CS msg, addr, \"acceptance\");        break;\n            case DEFER:\n              msg = string_sprintf(CS msg, addr, \"temporary refusal\"); break;\n            default:\n              msg = string_sprintf(CS msg, addr, \"refusal\");           break;\n            }\n          smtp_user_msg(code, msg);\n\t  }\n\tif (log_msg)       log_write(0, LOG_MAIN, \"PRDR %s %s\", addr, log_msg);\n\telse if (user_msg) log_write(0, LOG_MAIN, \"PRDR %s %s\", addr, user_msg);\n\telse               log_write(0, LOG_MAIN, \"%s\", CS msg);\n\n\tif (rc != OK) { receive_remove_recipient(addr); c--; }\n        }\n      /* Set up final message, used if data acl gives OK */\n      smtp_reply = string_sprintf(\"%s id=%s message %s\",\n\t\t       all_fail == FAIL ? US\"550\" : US\"250\",\n\t\t       message_id,\n                       all_fail == FAIL\n\t\t         ? US\"rejected for all recipients\"\n\t\t\t : all_pass == OK\n\t\t\t   ? US\"accepted\"\n\t\t\t   : US\"accepted for some recipients\");\n      if (recipients_count == 0)\n        {\n        message_id[0] = 0;       /* Indicate no message accepted */\n\tgoto TIDYUP;\n\t}\n      }\n    else\n      prdr_requested = FALSE;\n#endif /* !DISABLE_PRDR */\n\n    /* Check the recipients count again, as the MIME ACL might have changed\n    them. */\n\n    if (acl_smtp_data != NULL && recipients_count > 0)\n      {\n      rc = acl_check(ACL_WHERE_DATA, NULL, acl_smtp_data, &user_msg, &log_msg);\n      add_acl_headers(ACL_WHERE_DATA, US\"DATA\");\n      if (rc == DISCARD)\n        {\n        recipients_count = 0;\n        blackholed_by = US\"DATA ACL\";\n        if (log_msg)\n          blackhole_log_msg = string_sprintf(\": %s\", log_msg);\n\tcancel_cutthrough_connection(TRUE, US\"data acl discard\");\n        }\n      else if (rc != OK)\n        {\n        Uunlink(spool_name);\n\tcancel_cutthrough_connection(TRUE, US\"data acl not ok\");\n#ifdef WITH_CONTENT_SCAN\n        unspool_mbox();\n#endif\n#ifdef EXPERIMENTAL_DCC\n\tdcc_ok = 0;\n#endif\n        if (smtp_handle_acl_fail(ACL_WHERE_DATA, rc, user_msg, log_msg) != 0)\n          smtp_yield = FALSE;    /* No more messages after dropped connection */\n        smtp_reply = US\"\";       /* Indicate reply already sent */\n        message_id[0] = 0;       /* Indicate no message accepted */\n        goto TIDYUP;             /* Skip to end of function */\n        }\n      }\n    }\n\n  /* Handle non-SMTP and batch SMTP (i.e. non-interactive) messages. Note that\n  we cannot take different actions for permanent and temporary rejections. */\n\n  else\n    {\n\n#ifdef WITH_CONTENT_SCAN\n    if (acl_not_smtp_mime != NULL &&\n        !run_mime_acl(acl_not_smtp_mime, &smtp_yield, &smtp_reply,\n          &blackholed_by))\n      goto TIDYUP;\n#endif /* WITH_CONTENT_SCAN */\n\n    if (acl_not_smtp != NULL)\n      {\n      uschar *user_msg, *log_msg;\n      rc = acl_check(ACL_WHERE_NOTSMTP, NULL, acl_not_smtp, &user_msg, &log_msg);\n      if (rc == DISCARD)\n        {\n        recipients_count = 0;\n        blackholed_by = US\"non-SMTP ACL\";\n        if (log_msg != NULL)\n          blackhole_log_msg = string_sprintf(\": %s\", log_msg);\n        }\n      else if (rc != OK)\n        {\n        Uunlink(spool_name);\n#ifdef WITH_CONTENT_SCAN\n        unspool_mbox();\n#endif\n#ifdef EXPERIMENTAL_DCC\n\tdcc_ok = 0;\n#endif\n        /* The ACL can specify where rejections are to be logged, possibly\n        nowhere. The default is main and reject logs. */\n\n        if (log_reject_target != 0)\n          log_write(0, log_reject_target, \"F=<%s> rejected by non-SMTP ACL: %s\",\n            sender_address, log_msg);\n\n        if (user_msg == NULL) user_msg = US\"local configuration problem\";\n        if (smtp_batched_input)\n          {\n          moan_smtp_batch(NULL, \"%d %s\", 550, user_msg);\n          /* Does not return */\n          }\n        else\n          {\n          fseek(data_file, (long int)SPOOL_DATA_START_OFFSET, SEEK_SET);\n          give_local_error(ERRMESS_LOCAL_ACL, user_msg,\n            US\"message rejected by non-SMTP ACL: \", error_rc, data_file,\n              header_list);\n          /* Does not return */\n          }\n        }\n      add_acl_headers(ACL_WHERE_NOTSMTP, US\"non-SMTP\");\n      }\n    }\n\n  /* The applicable ACLs have been run */\n\n  if (deliver_freeze) frozen_by = US\"ACL\";     /* for later logging */\n  if (queue_only_policy) queued_by = US\"ACL\";\n  }\n\n#ifdef WITH_CONTENT_SCAN\nunspool_mbox();\n#endif\n\n#ifdef EXPERIMENTAL_DCC\ndcc_ok = 0;\n#endif\n\n\n/* The final check on the message is to run the scan_local() function. The\nversion supplied with Exim always accepts, but this is a hook for sysadmins to\nsupply their own checking code. The local_scan() function is run even when all\nthe recipients have been discarded. */\n/*XXS could we avoid this for the standard case, given that few people will use it? */\n\nlseek(data_fd, (long int)SPOOL_DATA_START_OFFSET, SEEK_SET);\n\n/* Arrange to catch crashes in local_scan(), so that the -D file gets\ndeleted, and the incident gets logged. */\n\nos_non_restarting_signal(SIGSEGV, local_scan_crash_handler);\nos_non_restarting_signal(SIGFPE, local_scan_crash_handler);\nos_non_restarting_signal(SIGILL, local_scan_crash_handler);\nos_non_restarting_signal(SIGBUS, local_scan_crash_handler);\n\nDEBUG(D_receive) debug_printf(\"calling local_scan(); timeout=%d\\n\",\n  local_scan_timeout);\nlocal_scan_data = NULL;\n\nos_non_restarting_signal(SIGALRM, local_scan_timeout_handler);\nif (local_scan_timeout > 0) alarm(local_scan_timeout);\nrc = local_scan(data_fd, &local_scan_data);\nalarm(0);\nos_non_restarting_signal(SIGALRM, sigalrm_handler);\n\nenable_dollar_recipients = FALSE;\n\nstore_pool = POOL_MAIN;   /* In case changed */\nDEBUG(D_receive) debug_printf(\"local_scan() returned %d %s\\n\", rc,\n  local_scan_data);\n\nos_non_restarting_signal(SIGSEGV, SIG_DFL);\nos_non_restarting_signal(SIGFPE, SIG_DFL);\nos_non_restarting_signal(SIGILL, SIG_DFL);\nos_non_restarting_signal(SIGBUS, SIG_DFL);\n\n/* The length check is paranoia against some runaway code, and also because\n(for a success return) lines in the spool file are read into big_buffer. */\n\nif (local_scan_data != NULL)\n  {\n  int len = Ustrlen(local_scan_data);\n  if (len > LOCAL_SCAN_MAX_RETURN) len = LOCAL_SCAN_MAX_RETURN;\n  local_scan_data = string_copyn(local_scan_data, len);\n  }\n\nif (rc == LOCAL_SCAN_ACCEPT_FREEZE)\n  {\n  if (!deliver_freeze)         /* ACL might have already frozen */\n    {\n    deliver_freeze = TRUE;\n    deliver_frozen_at = time(NULL);\n    frozen_by = US\"local_scan()\";\n    }\n  rc = LOCAL_SCAN_ACCEPT;\n  }\nelse if (rc == LOCAL_SCAN_ACCEPT_QUEUE)\n  {\n  if (!queue_only_policy)      /* ACL might have already queued */\n    {\n    queue_only_policy = TRUE;\n    queued_by = US\"local_scan()\";\n    }\n  rc = LOCAL_SCAN_ACCEPT;\n  }\n\n/* Message accepted: remove newlines in local_scan_data because otherwise\nthe spool file gets corrupted. Ensure that all recipients are qualified. */\n\nif (rc == LOCAL_SCAN_ACCEPT)\n  {\n  if (local_scan_data != NULL)\n    {\n    uschar *s;\n    for (s = local_scan_data; *s != 0; s++) if (*s == '\\n') *s = ' ';\n    }\n  for (i = 0; i < recipients_count; i++)\n    {\n    recipient_item *r = recipients_list + i;\n    r->address = rewrite_address_qualify(r->address, TRUE);\n    if (r->errors_to != NULL)\n      r->errors_to = rewrite_address_qualify(r->errors_to, TRUE);\n    }\n  if (recipients_count == 0 && blackholed_by == NULL)\n    blackholed_by = US\"local_scan\";\n  }\n\n/* Message rejected: newlines permitted in local_scan_data to generate\nmultiline SMTP responses. */\n\nelse\n  {\n  uschar *istemp = US\"\";\n  uschar *smtp_code;\n  gstring * g;\n\n  errmsg = local_scan_data;\n\n  Uunlink(spool_name);          /* Cancel this message */\n  switch(rc)\n    {\n    default:\n    log_write(0, LOG_MAIN, \"invalid return %d from local_scan(). Temporary \"\n      \"rejection given\", rc);\n    goto TEMPREJECT;\n\n    case LOCAL_SCAN_REJECT_NOLOGHDR:\n    BIT_CLEAR(log_selector, log_selector_size, Li_rejected_header);\n    /* Fall through */\n\n    case LOCAL_SCAN_REJECT:\n    smtp_code = US\"550\";\n    if (errmsg == NULL) errmsg =  US\"Administrative prohibition\";\n    break;\n\n    case LOCAL_SCAN_TEMPREJECT_NOLOGHDR:\n    BIT_CLEAR(log_selector, log_selector_size, Li_rejected_header);\n    /* Fall through */\n\n    case LOCAL_SCAN_TEMPREJECT:\n    TEMPREJECT:\n    smtp_code = US\"451\";\n    if (errmsg == NULL) errmsg = US\"Temporary local problem\";\n    istemp = US\"temporarily \";\n    break;\n    }\n\n  g = string_append(g, 2, US\"F=\",\n    sender_address[0] == 0 ? US\"<>\" : sender_address);\n  g = add_host_info_for_log(g);\n\n  log_write(0, LOG_MAIN|LOG_REJECT, \"%s %srejected by local_scan(): %.256s\",\n    string_from_gstring(g), istemp, string_printing(errmsg));\n\n  if (smtp_input)\n    {\n    if (!smtp_batched_input)\n      {\n      smtp_respond(smtp_code, 3, TRUE, errmsg);\n      message_id[0] = 0;            /* Indicate no message accepted */\n      smtp_reply = US\"\";            /* Indicate reply already sent */\n      goto TIDYUP;                  /* Skip to end of function */\n      }\n    else\n      {\n      moan_smtp_batch(NULL, \"%s %s\", smtp_code, errmsg);\n      /* Does not return */\n      }\n    }\n  else\n    {\n    fseek(data_file, (long int)SPOOL_DATA_START_OFFSET, SEEK_SET);\n    give_local_error(ERRMESS_LOCAL_SCAN, errmsg,\n      US\"message rejected by local scan code: \", error_rc, data_file,\n        header_list);\n    /* Does not return */\n    }\n  }\n\n/* Reset signal handlers to ignore signals that previously would have caused\nthe message to be abandoned. */\n\nsignal(SIGTERM, SIG_IGN);\nsignal(SIGINT, SIG_IGN);\n\n\n/* Ensure the first time flag is set in the newly-received message. */\n\ndeliver_firsttime = TRUE;\n\n#ifdef EXPERIMENTAL_BRIGHTMAIL\nif (bmi_run == 1)\n  { /* rewind data file */\n  lseek(data_fd, (long int)SPOOL_DATA_START_OFFSET, SEEK_SET);\n  bmi_verdicts = bmi_process_message(header_list, data_fd);\n  }\n#endif\n\n/* Update the timestamp in our Received: header to account for any time taken by\nan ACL or by local_scan(). The new time is the time that all reception\nprocessing is complete. */\n\ntimestamp = expand_string(US\"${tod_full}\");\ntslen = Ustrlen(timestamp);\n\nmemcpy(received_header->text + received_header->slen - tslen - 1,\n  timestamp, tslen);\n\n/* In MUA wrapper mode, ignore queueing actions set by ACL or local_scan() */\n\nif (mua_wrapper)\n  {\n  deliver_freeze = FALSE;\n  queue_only_policy = FALSE;\n  }\n\n/* Keep the data file open until we have written the header file, in order to\nhold onto the lock. In a -bh run, or if the message is to be blackholed, we\ndon't write the header file, and we unlink the data file. If writing the header\nfile fails, we have failed to accept this message. */\n\nif (host_checking || blackholed_by != NULL)\n  {\n  header_line *h;\n  Uunlink(spool_name);\n  msg_size = 0;                                  /* Compute size for log line */\n  for (h = header_list; h != NULL; h = h->next)\n    if (h->type != '*') msg_size += h->slen;\n  }\n\n/* Write the -H file */\n\nelse\n  if ((msg_size = spool_write_header(message_id, SW_RECEIVING, &errmsg)) < 0)\n    {\n    log_write(0, LOG_MAIN, \"Message abandoned: %s\", errmsg);\n    Uunlink(spool_name);           /* Lose the data file */\n\n    if (smtp_input)\n      {\n      smtp_reply = US\"451 Error in writing spool file\";\n      message_id[0] = 0;          /* Indicate no message accepted */\n      goto TIDYUP;\n      }\n    else\n      {\n      fseek(data_file, (long int)SPOOL_DATA_START_OFFSET, SEEK_SET);\n      give_local_error(ERRMESS_IOERR, errmsg, US\"\", error_rc, data_file,\n        header_list);\n      /* Does not return */\n      }\n    }\n\n\n/* The message has now been successfully received. */\n\nreceive_messagecount++;\n\n/* In SMTP sessions we may receive several in one connection. After each one,\nwe wait for the clock to tick at the level of message-id granularity. This is\nso that the combination of time+pid is unique, even on systems where the pid\ncan be re-used within our time interval. We can't shorten the interval without\nre-designing the message-id. See comments above where the message id is\ncreated. This is Something For The Future. */\n\nmessage_id_tv.tv_usec = (message_id_tv.tv_usec/id_resolution) * id_resolution;\nexim_wait_tick(&message_id_tv, id_resolution);\n\n/* Add data size to written header size. We do not count the initial file name\nthat is in the file, but we do add one extra for the notional blank line that\nprecedes the data. This total differs from message_size in that it include the\nadded Received: header and any other headers that got created locally. */\n\nfflush(data_file);\nfstat(data_fd, &statbuf);\n\nmsg_size += statbuf.st_size - SPOOL_DATA_START_OFFSET + 1;\n\n/* Generate a \"message received\" log entry. We do this by building up a dynamic\nstring as required. Since we commonly want to add two items at a time, use a\nmacro to simplify the coding. We log the arrival of a new message while the\nfile is still locked, just in case the machine is *really* fast, and delivers\nit first! Include any message id that is in the message - since the syntax of a\nmessage id is actually an addr-spec, we can use the parse routine to canonicalize\nit. */\n\ng = string_get(256);\n\ng = string_append(g, 2,\n  fake_response == FAIL ? US\"(= \" : US\"<= \",\n  sender_address[0] == 0 ? US\"<>\" : sender_address);\nif (message_reference)\n  g = string_append(g, 2, US\" R=\", message_reference);\n\ng = add_host_info_for_log(g);\n\n#ifdef SUPPORT_TLS\nif (LOGGING(tls_cipher) && tls_in.cipher)\n  g = string_append(g, 2, US\" X=\", tls_in.cipher);\nif (LOGGING(tls_certificate_verified) && tls_in.cipher)\n  g = string_append(g, 2, US\" CV=\", tls_in.certificate_verified ? \"yes\":\"no\");\nif (LOGGING(tls_peerdn) && tls_in.peerdn)\n  g = string_append(g, 3, US\" DN=\\\"\", string_printing(tls_in.peerdn), US\"\\\"\");\nif (LOGGING(tls_sni) && tls_in.sni)\n  g = string_append(g, 3, US\" SNI=\\\"\", string_printing(tls_in.sni), US\"\\\"\");\n#endif\n\nif (sender_host_authenticated)\n  {\n  g = string_append(g, 2, US\" A=\", sender_host_authenticated);\n  if (authenticated_id)\n    {\n    g = string_append(g, 2, US\":\", authenticated_id);\n    if (LOGGING(smtp_mailauth) && authenticated_sender)\n      g = string_append(g, 2, US\":\", authenticated_sender);\n    }\n  }\n\n#ifndef DISABLE_PRDR\nif (prdr_requested)\n  g = string_catn(g, US\" PRDR\", 5);\n#endif\n\n#ifdef SUPPORT_PROXY\nif (proxy_session && LOGGING(proxy))\n  g = string_append(g, 2, US\" PRX=\", proxy_local_address);\n#endif\n\nif (chunking_state > CHUNKING_OFFERED)\n  g = string_catn(g, US\" K\", 2);\n\nsprintf(CS big_buffer, \"%d\", msg_size);\ng = string_append(g, 2, US\" S=\", big_buffer);\n\n/* log 8BITMIME mode announced in MAIL_FROM\n   0 ... no BODY= used\n   7 ... 7BIT\n   8 ... 8BITMIME */\nif (LOGGING(8bitmime))\n  {\n  sprintf(CS big_buffer, \"%d\", body_8bitmime);\n  g = string_append(g, 2, US\" M8S=\", big_buffer);\n  }\n\nif (*queue_name)\n  g = string_append(g, 2, US\" Q=\", queue_name);\n\n/* If an addr-spec in a message-id contains a quoted string, it can contain\nany characters except \" \\ and CR and so in particular it can contain NL!\nTherefore, make sure we use a printing-characters only version for the log.\nAlso, allow for domain literals in the message id. */\n\nif (msgid_header)\n  {\n  uschar *old_id;\n  BOOL save_allow_domain_literals = allow_domain_literals;\n  allow_domain_literals = TRUE;\n  old_id = parse_extract_address(Ustrchr(msgid_header->text, ':') + 1,\n    &errmsg, &start, &end, &domain, FALSE);\n  allow_domain_literals = save_allow_domain_literals;\n  if (old_id != NULL)\n    g = string_append(g, 2, US\" id=\", string_printing(old_id));\n  }\n\n/* If subject logging is turned on, create suitable printing-character\ntext. By expanding $h_subject: we make use of the MIME decoding. */\n\nif (LOGGING(subject) && subject_header != NULL)\n  {\n  int i;\n  uschar *p = big_buffer;\n  uschar *ss = expand_string(US\"$h_subject:\");\n\n  /* Backslash-quote any double quotes or backslashes so as to make a\n  a C-like string, and turn any non-printers into escape sequences. */\n\n  *p++ = '\\\"';\n  if (*ss != 0) for (i = 0; i < 100 && ss[i] != 0; i++)\n    {\n    if (ss[i] == '\\\"' || ss[i] == '\\\\') *p++ = '\\\\';\n    *p++ = ss[i];\n    }\n  *p++ = '\\\"';\n  *p = 0;\n  g = string_append(g, 2, US\" T=\", string_printing(big_buffer));\n  }\n\n/* Terminate the string: string_cat() and string_append() leave room, but do\nnot put the zero in. */\n\n(void) string_from_gstring(g);\n\n/* Create a message log file if message logs are being used and this message is\nnot blackholed. Write the reception stuff to it. We used to leave message log\ncreation until the first delivery, but this has proved confusing for some\npeople. */\n\nif (message_logs && !blackholed_by)\n  {\n  int fd;\n\n  spool_name = spool_fname(US\"msglog\", message_subdir, message_id, US\"\");\n  \n  if (  (fd = Uopen(spool_name, O_WRONLY|O_APPEND|O_CREAT, SPOOL_MODE)) < 0\n     && errno == ENOENT\n     )\n    {\n    (void)directory_make(spool_directory,\n\t\t\tspool_sname(US\"msglog\", message_subdir),\n\t\t\tMSGLOG_DIRECTORY_MODE, TRUE);\n    fd = Uopen(spool_name, O_WRONLY|O_APPEND|O_CREAT, SPOOL_MODE);\n    }\n\n  if (fd < 0)\n    log_write(0, LOG_MAIN|LOG_PANIC, \"Couldn't open message log %s: %s\",\n      spool_name, strerror(errno));\n  else\n    {\n    FILE *message_log = fdopen(fd, \"a\");\n    if (message_log == NULL)\n      {\n      log_write(0, LOG_MAIN|LOG_PANIC, \"Couldn't fdopen message log %s: %s\",\n        spool_name, strerror(errno));\n      (void)close(fd);\n      }\n    else\n      {\n      uschar *now = tod_stamp(tod_log);\n      fprintf(message_log, \"%s Received from %s\\n\", now, g->s+3);\n      if (deliver_freeze) fprintf(message_log, \"%s frozen by %s\\n\", now,\n        frozen_by);\n      if (queue_only_policy) fprintf(message_log,\n        \"%s no immediate delivery: queued%s%s by %s\\n\", now,\n        *queue_name ? \" in \" : \"\", *queue_name ? CS queue_name : \"\",\n\tqueued_by);\n      (void)fclose(message_log);\n      }\n    }\n  }\n\n/* Everything has now been done for a successful message except logging its\narrival, and outputting an SMTP response. While writing to the log, set a flag\nto cause a call to receive_bomb_out() if the log cannot be opened. */\n\nreceive_call_bombout = TRUE;\n\n/* Before sending an SMTP response in a TCP/IP session, we check to see if the\nconnection has gone away. This can only be done if there is no unconsumed input\nwaiting in the local input buffer. We can test for this by calling\nreceive_smtp_buffered(). RFC 2920 (pipelining) explicitly allows for additional\ninput to be sent following the final dot, so the presence of following input is\nnot an error.\n\nIf the connection is still present, but there is no unread input for the\nsocket, the result of a select() call will be zero. If, however, the connection\nhas gone away, or if there is pending input, the result of select() will be\nnon-zero. The two cases can be distinguished by trying to read the next input\ncharacter. If we succeed, we can unread it so that it remains in the local\nbuffer for handling later. If not, the connection has been lost.\n\nOf course, since TCP/IP is asynchronous, there is always a chance that the\nconnection will vanish between the time of this test and the sending of the\nresponse, but the chance of this happening should be small. */\n\nif (smtp_input && sender_host_address != NULL && !sender_host_notsocket &&\n    !receive_smtp_buffered())\n  {\n  struct timeval tv;\n  fd_set select_check;\n  FD_ZERO(&select_check);\n  FD_SET(fileno(smtp_in), &select_check);\n  tv.tv_sec = 0;\n  tv.tv_usec = 0;\n\n  if (select(fileno(smtp_in) + 1, &select_check, NULL, NULL, &tv) != 0)\n    {\n    int c = (receive_getc)(GETC_BUFFER_UNLIMITED);\n    if (c != EOF) (receive_ungetc)(c); else\n      {\n      smtp_notquit_exit(US\"connection-lost\", NULL, NULL);\n      smtp_reply = US\"\";    /* No attempt to send a response */\n      smtp_yield = FALSE;   /* Nothing more on this connection */\n\n      /* Re-use the log line workspace */\n\n      g->ptr = 0;\n      g = string_cat(g, US\"SMTP connection lost after final dot\");\n      g = add_host_info_for_log(g);\n      log_write(0, LOG_MAIN, \"%s\", string_from_gstring(g));\n\n      /* Delete the files for this aborted message. */\n\n      Uunlink(spool_fname(US\"input\", message_subdir, message_id, US\"-D\"));\n      Uunlink(spool_fname(US\"input\", message_subdir, message_id, US\"-H\"));\n      Uunlink(spool_fname(US\"msglog\", message_subdir, message_id, US\"\"));\n\n      goto TIDYUP;\n      }\n    }\n  }\n\n/* The connection has not gone away; we really are going to take responsibility\nfor this message. */\n\n/* Cutthrough - had sender last-dot; assume we've sent (or bufferred) all\n   data onward by now.\n\n   Send dot onward.  If accepted, wipe the spooled files, log as delivered and accept\n   the sender's dot (below).\n   If rejected: copy response to sender, wipe the spooled files, log appropriately.\n   If temp-reject: normally accept to sender, keep the spooled file - unless defer=pass\n   in which case pass temp-reject back to initiator and dump the files.\n\n   Having the normal spool files lets us do data-filtering, and store/forward on temp-reject.\n\n   XXX We do not handle queue-only, freezing, or blackholes.\n*/\nif(cutthrough.fd >= 0 && cutthrough.delivery)\n  {\n  uschar * msg = cutthrough_finaldot();\t/* Ask the target system to accept the message */\n\t\t\t\t\t/* Logging was done in finaldot() */\n  switch(msg[0])\n    {\n    case '2':\t/* Accept. Do the same to the source; dump any spoolfiles.   */\n      cutthrough_done = ACCEPTED;\n      break;\t\t\t\t\t/* message_id needed for SMTP accept below */\n\n    case '4':\t/* Temp-reject. Keep spoolfiles and accept, unless defer-pass mode.\n      \t\t... for which, pass back the exact error */\n      if (cutthrough.defer_pass) smtp_reply = string_copy_malloc(msg);\n      /*FALLTRHOUGH*/\n\n    default:\t/* Unknown response, or error.  Treat as temp-reject.         */\n      cutthrough_done = TMP_REJ;\t\t/* Avoid the usual immediate delivery attempt */\n      break;\t\t\t\t\t/* message_id needed for SMTP accept below */\n\n    case '5':\t/* Perm-reject.  Do the same to the source.  Dump any spoolfiles */\n      smtp_reply = string_copy_malloc(msg);\t\t/* Pass on the exact error */\n      cutthrough_done = PERM_REJ;\n      break;\n    }\n  }\n\n#ifndef DISABLE_PRDR\nif(!smtp_reply || prdr_requested)\n#else\nif(!smtp_reply)\n#endif\n  {\n  log_write(0, LOG_MAIN |\n    (LOGGING(received_recipients)? LOG_RECIPIENTS : 0) |\n    (LOGGING(received_sender)? LOG_SENDER : 0),\n    \"%s\", g->s);\n\n  /* Log any control actions taken by an ACL or local_scan(). */\n\n  if (deliver_freeze) log_write(0, LOG_MAIN, \"frozen by %s\", frozen_by);\n  if (queue_only_policy) log_write(L_delay_delivery, LOG_MAIN,\n    \"no immediate delivery: queued%s%s by %s\",\n    *queue_name ? \" in \" : \"\", *queue_name ? CS queue_name : \"\",       \n    queued_by);\n  }\nreceive_call_bombout = FALSE;\n\nstore_reset(g);   /* The store for the main log message can be reused */\n\n/* If the message is frozen, and freeze_tell is set, do the telling. */\n\nif (deliver_freeze && freeze_tell != NULL && freeze_tell[0] != 0)\n  {\n  moan_tell_someone(freeze_tell, NULL, US\"Message frozen on arrival\",\n    \"Message %s was frozen on arrival by %s.\\nThe sender is <%s>.\\n\",\n    message_id, frozen_by, sender_address);\n  }\n\n\n/* Either a message has been successfully received and written to the two spool\nfiles, or an error in writing the spool has occurred for an SMTP message, or\nan SMTP message has been rejected for policy reasons. (For a non-SMTP message\nwe will have already given up because there's no point in carrying on!) In\neither event, we must now close (and thereby unlock) the data file. In the\nsuccessful case, this leaves the message on the spool, ready for delivery. In\nthe error case, the spool file will be deleted. Then tidy up store, interact\nwith an SMTP call if necessary, and return.\n\nA fflush() was done earlier in the expectation that any write errors on the\ndata file will be flushed(!) out thereby. Nevertheless, it is theoretically\npossible for fclose() to fail - but what to do? What has happened to the lock\nif this happens? */\n\n\nTIDYUP:\nprocess_info[process_info_len] = 0;                /* Remove message id */\nif (data_file != NULL) (void)fclose(data_file);    /* Frees the lock */\n\n/* Now reset signal handlers to their defaults */\n\nsignal(SIGTERM, SIG_DFL);\nsignal(SIGINT, SIG_DFL);\n\n/* Tell an SMTP caller the state of play, and arrange to return the SMTP return\nvalue, which defaults TRUE - meaning there may be more incoming messages from\nthis connection. For non-SMTP callers (where there is only ever one message),\nthe default is FALSE. */\n\nif (smtp_input)\n  {\n  yield = smtp_yield;\n\n  /* Handle interactive SMTP callers. After several kinds of error, smtp_reply\n  is set to the response that should be sent. When it is NULL, we generate\n  default responses. After an ACL error or local_scan() error, the response has\n  already been sent, and smtp_reply is an empty string to indicate this. */\n\n  if (!smtp_batched_input)\n    {\n    if (!smtp_reply)\n      {\n      if (fake_response != OK)\n        smtp_respond(fake_response == DEFER ? US\"450\" : US\"550\",\n\t  3, TRUE, fake_response_text);\n\n      /* An OK response is required; use \"message\" text if present. */\n\n      else if (user_msg)\n        {\n        uschar *code = US\"250\";\n        int len = 3;\n        smtp_message_code(&code, &len, &user_msg, NULL, TRUE);\n        smtp_respond(code, len, TRUE, user_msg);\n        }\n\n      /* Default OK response */\n\n      else if (chunking_state > CHUNKING_OFFERED)\n\t{\n        smtp_printf(\"250- %u byte chunk, total %d\\r\\n250 OK id=%s\\r\\n\", FALSE,\n\t    chunking_datasize, message_size+message_linecount, message_id);\n\tchunking_state = CHUNKING_OFFERED;\n\t}\n      else\n        smtp_printf(\"250 OK id=%s\\r\\n\", FALSE, message_id);\n\n      if (host_checking)\n        fprintf(stdout,\n          \"\\n**** SMTP testing: that is not a real message id!\\n\\n\");\n      }\n\n    /* smtp_reply is set non-empty */\n\n    else if (smtp_reply[0] != 0)\n      if (fake_response != OK && (smtp_reply[0] == '2'))\n        smtp_respond((fake_response == DEFER)? US\"450\" : US\"550\", 3, TRUE,\n          fake_response_text);\n      else\n        smtp_printf(\"%.1024s\\r\\n\", FALSE, smtp_reply);\n\n    switch (cutthrough_done)\n      {\n      case ACCEPTED:\n\tlog_write(0, LOG_MAIN, \"Completed\");/* Delivery was done */\n      case PERM_REJ:\n\t\t\t\t\t\t\t /* Delete spool files */\n\tUunlink(spool_fname(US\"input\", message_subdir, message_id, US\"-D\"));\n\tUunlink(spool_fname(US\"input\", message_subdir, message_id, US\"-H\"));\n\tUunlink(spool_fname(US\"msglog\", message_subdir, message_id, US\"\"));\n\tbreak;\n\n      case TMP_REJ:\n\tif (cutthrough.defer_pass)\n\t  {\n\t  Uunlink(spool_fname(US\"input\", message_subdir, message_id, US\"-D\"));\n\t  Uunlink(spool_fname(US\"input\", message_subdir, message_id, US\"-H\"));\n\t  Uunlink(spool_fname(US\"msglog\", message_subdir, message_id, US\"\"));\n\t  }\n      default:\n\tbreak;\n      }\n    if (cutthrough_done != NOT_TRIED)\n      {\n      message_id[0] = 0;\t  /* Prevent a delivery from starting */\n      cutthrough.delivery = cutthrough.callout_hold_only = FALSE;\n      cutthrough.defer_pass = FALSE;\n      }\n    }\n\n  /* For batched SMTP, generate an error message on failure, and do\n  nothing on success. The function moan_smtp_batch() does not return -\n  it exits from the program with a non-zero return code. */\n\n  else if (smtp_reply)\n    moan_smtp_batch(NULL, \"%s\", smtp_reply);\n  }\n\n\n/* If blackholing, we can immediately log this message's sad fate. The data\nfile has already been unlinked, and the header file was never written to disk.\nWe must now indicate that nothing was received, to prevent a delivery from\nstarting. */\n\nif (blackholed_by)\n  {\n  const uschar *detail = local_scan_data\n    ? string_printing(local_scan_data)\n    : string_sprintf(\"(%s discarded recipients)\", blackholed_by);\n  log_write(0, LOG_MAIN, \"=> blackhole %s%s\", detail, blackhole_log_msg);\n  log_write(0, LOG_MAIN, \"Completed\");\n  message_id[0] = 0;\n  }\n\n/* Reset headers so that logging of rejects for a subsequent message doesn't\ninclude them. It is also important to set header_last = NULL before exiting\nfrom this function, as this prevents certain rewrites that might happen during\nsubsequent verifying (of another incoming message) from trying to add headers\nwhen they shouldn't. */\n\nheader_list = header_last = NULL;\n\nreturn yield;  /* TRUE if more messages (SMTP only) */\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147302,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "receive_msg(BOOL extract_recip)\n{\nint  i;\nint  rc = FAIL;\nint  msg_size = 0;\nint  process_info_len = Ustrlen(process_info);\nint  error_rc = (error_handling == ERRORS_SENDER)?\n       errors_sender_rc : EXIT_FAILURE;\nint  header_size = 256;\nint  start, end, domain;\nint  id_resolution;\nint  had_zero = 0;\nint  prevlines_length = 0;\n\nregister int ptr = 0;\n\nBOOL contains_resent_headers = FALSE;\nBOOL extracted_ignored = FALSE;\nBOOL first_line_ended_crlf = TRUE_UNSET;\nBOOL smtp_yield = TRUE;\nBOOL yield = FALSE;\n\nBOOL resents_exist = FALSE;\nuschar *resent_prefix = US\"\";\nuschar *blackholed_by = NULL;\nuschar *blackhole_log_msg = US\"\";\nenum {NOT_TRIED, TMP_REJ, PERM_REJ, ACCEPTED} cutthrough_done = NOT_TRIED;\n\nflock_t lock_data;\nerror_block *bad_addresses = NULL;\n\nuschar *frozen_by = NULL;\nuschar *queued_by = NULL;\n\nuschar *errmsg;\ngstring * g;\nstruct stat statbuf;\n\n/* Final message to give to SMTP caller, and messages from ACLs */\n\nuschar *smtp_reply = NULL;\nuschar *user_msg, *log_msg;\n\n/* Working header pointers */\n\nheader_line *h, *next;\n\n/* Flags for noting the existence of certain headers (only one left) */\n\nBOOL date_header_exists = FALSE;\n\n/* Pointers to receive the addresses of headers whose contents we need. */\n\nheader_line *from_header = NULL;\nheader_line *subject_header = NULL;\nheader_line *msgid_header = NULL;\nheader_line *received_header;\n\n#ifdef EXPERIMENTAL_DMARC\nint dmarc_up = 0;\n#endif /* EXPERIMENTAL_DMARC */\n\n/* Variables for use when building the Received: header. */\n\nuschar *timestamp;\nint tslen;\n\n/* Release any open files that might have been cached while preparing to\naccept the message - e.g. by verifying addresses - because reading a message\nmight take a fair bit of real time. */\n\nsearch_tidyup();\n\n/* Extracting the recipient list from an input file is incompatible with\ncutthrough delivery with the no-spool option.  It shouldn't be possible\nto set up the combination, but just in case kill any ongoing connection. */\nif (extract_recip || !smtp_input)\n  cancel_cutthrough_connection(TRUE, US\"not smtp input\");\n\n/* Initialize the chain of headers by setting up a place-holder for Received:\nheader. Temporarily mark it as \"old\", i.e. not to be used. We keep header_last\npointing to the end of the chain to make adding headers simple. */\n\nreceived_header = header_list = header_last = store_get(sizeof(header_line));\nheader_list->next = NULL;\nheader_list->type = htype_old;\nheader_list->text = NULL;\nheader_list->slen = 0;\n\n/* Control block for the next header to be read. */\n\nnext = store_get(sizeof(header_line));\nnext->text = store_get(header_size);\n\n/* Initialize message id to be null (indicating no message read), and the\nheader names list to be the normal list. Indicate there is no data file open\nyet, initialize the size and warning count, and deal with no size limit. */\n\nmessage_id[0] = 0;\ndata_file = NULL;\ndata_fd = -1;\nspool_name = US\"\";\nmessage_size = 0;\nwarning_count = 0;\nreceived_count = 1;            /* For the one we will add */\n\nif (thismessage_size_limit <= 0) thismessage_size_limit = INT_MAX;\n\n/* While reading the message, the following counts are computed. */\n\nmessage_linecount = body_linecount = body_zerocount =\n  max_received_linelength = 0;\n\n#ifndef DISABLE_DKIM\n/* Call into DKIM to set up the context.  In CHUNKING mode\nwe clear the dot-stuffing flag */\nif (smtp_input && !smtp_batched_input && !dkim_disable_verify)\n  dkim_exim_verify_init(chunking_state <= CHUNKING_OFFERED);\n#endif\n\n#ifdef EXPERIMENTAL_DMARC\n/* initialize libopendmarc */\ndmarc_up = dmarc_init();\n#endif\n\n/* Remember the time of reception. Exim uses time+pid for uniqueness of message\nids, and fractions of a second are required. See the comments that precede the\nmessage id creation below. */\n\n(void)gettimeofday(&message_id_tv, NULL);\n\n/* For other uses of the received time we can operate with granularity of one\nsecond, and for that we use the global variable received_time. This is for\nthings like ultimate message timeouts.XXX */\n\nreceived_time = message_id_tv;\n\n/* If SMTP input, set the special handler for timeouts. The alarm() calls\nhappen in the smtp_getc() function when it refills its buffer. */\n\nif (smtp_input) os_non_restarting_signal(SIGALRM, data_timeout_handler);\n\n/* If not SMTP input, timeout happens only if configured, and we just set a\nsingle timeout for the whole message. */\n\nelse if (receive_timeout > 0)\n  {\n  os_non_restarting_signal(SIGALRM, data_timeout_handler);\n  alarm(receive_timeout);\n  }\n\n/* SIGTERM and SIGINT are caught always. */\n\nsignal(SIGTERM, data_sigterm_sigint_handler);\nsignal(SIGINT, data_sigterm_sigint_handler);\n\n/* Header lines in messages are not supposed to be very long, though when\nunfolded, to: and cc: headers can take up a lot of store. We must also cope\nwith the possibility of junk being thrown at us. Start by getting 256 bytes for\nstoring the header, and extend this as necessary using string_cat().\n\nTo cope with total lunacies, impose an upper limit on the length of the header\nsection of the message, as otherwise the store will fill up. We must also cope\nwith the possibility of binary zeros in the data. Hence we cannot use fgets().\nFolded header lines are joined into one string, leaving the '\\n' characters\ninside them, so that writing them out reproduces the input.\n\nLoop for each character of each header; the next structure for chaining the\nheader is set up already, with ptr the offset of the next character in\nnext->text. */\n\nfor (;;)\n  {\n  int ch = (receive_getc)(GETC_BUFFER_UNLIMITED);\n\n  /* If we hit EOF on a SMTP connection, it's an error, since incoming\n  SMTP must have a correct \".\" terminator. */\n\n  if (ch == EOF && smtp_input /* && !smtp_batched_input */)\n    {\n    smtp_reply = handle_lost_connection(US\" (header)\");\n    smtp_yield = FALSE;\n    goto TIDYUP;                       /* Skip to end of function */\n    }\n\n  /* See if we are at the current header's size limit - there must be at least\n  four bytes left. This allows for the new character plus a zero, plus two for\n  extra insertions when we are playing games with dots and carriage returns. If\n  we are at the limit, extend the text buffer. This could have been done\n  automatically using string_cat() but because this is a tightish loop storing\n  only one character at a time, we choose to do it inline. Normally\n  store_extend() will be able to extend the block; only at the end of a big\n  store block will a copy be needed. To handle the case of very long headers\n  (and sometimes lunatic messages can have ones that are 100s of K long) we\n  call store_release() for strings that have been copied - if the string is at\n  the start of a block (and therefore the only thing in it, because we aren't\n  doing any other gets), the block gets freed. We can only do this release if\n  there were no allocations since the once that we want to free. */\n\n  if (ptr >= header_size - 4)\n    {\n    int oldsize = header_size;\n    /* header_size += 256; */\n    header_size *= 2;\n    if (!store_extend(next->text, oldsize, header_size))\n      {\n      BOOL release_ok = store_last_get[store_pool] == next->text;\n      uschar *newtext = store_get(header_size);\n      memcpy(newtext, next->text, ptr);\n      if (release_ok) store_release(next->text);\n      next->text = newtext;\n      }\n    }\n\n  /* Cope with receiving a binary zero. There is dispute about whether\n  these should be allowed in RFC 822 messages. The middle view is that they\n  should not be allowed in headers, at least. Exim takes this attitude at\n  the moment. We can't just stomp on them here, because we don't know that\n  this line is a header yet. Set a flag to cause scanning later. */\n\n  if (ch == 0) had_zero++;\n\n  /* Test for termination. Lines in remote SMTP are terminated by CRLF, while\n  those from data files use just LF. Treat LF in local SMTP input as a\n  terminator too. Treat EOF as a line terminator always. */\n\n  if (ch == EOF) goto EOL;\n\n  /* FUDGE: There are sites out there that don't send CRs before their LFs, and\n  other MTAs accept this. We are therefore forced into this \"liberalisation\"\n  too, so we accept LF as a line terminator whatever the source of the message.\n  However, if the first line of the message ended with a CRLF, we treat a bare\n  LF specially by inserting a white space after it to ensure that the header\n  line is not terminated. */\n\n  if (ch == '\\n')\n    {\n    if (first_line_ended_crlf == TRUE_UNSET) first_line_ended_crlf = FALSE;\n      else if (first_line_ended_crlf) receive_ungetc(' ');\n    goto EOL;\n    }\n\n  /* This is not the end of the line. If this is SMTP input and this is\n  the first character in the line and it is a \".\" character, ignore it.\n  This implements the dot-doubling rule, though header lines starting with\n  dots aren't exactly common. They are legal in RFC 822, though. If the\n  following is CRLF or LF, this is the line that that terminates the\n  entire message. We set message_ended to indicate this has happened (to\n  prevent further reading), and break out of the loop, having freed the\n  empty header, and set next = NULL to indicate no data line. */\n\n  if (ptr == 0 && ch == '.' && (smtp_input || dot_ends))\n    {\n    ch = (receive_getc)(GETC_BUFFER_UNLIMITED);\n    if (ch == '\\r')\n      {\n      ch = (receive_getc)(GETC_BUFFER_UNLIMITED);\n      if (ch != '\\n')\n        {\n        receive_ungetc(ch);\n        ch = '\\r';              /* Revert to CR */\n        }\n      }\n    if (ch == '\\n')\n      {\n      message_ended = END_DOT;\n      store_reset(next);\n      next = NULL;\n      break;                    /* End character-reading loop */\n      }\n\n    /* For non-SMTP input, the dot at the start of the line was really a data\n    character. What is now in ch is the following character. We guaranteed\n    enough space for this above. */\n\n    if (!smtp_input)\n      {\n      next->text[ptr++] = '.';\n      message_size++;\n      }\n    }\n\n  /* If CR is immediately followed by LF, end the line, ignoring the CR, and\n  remember this case if this is the first line ending. */\n\n  if (ch == '\\r')\n    {\n    ch = (receive_getc)(GETC_BUFFER_UNLIMITED);\n    if (ch == '\\n')\n      {\n      if (first_line_ended_crlf == TRUE_UNSET) first_line_ended_crlf = TRUE;\n      goto EOL;\n      }\n\n    /* Otherwise, put back the character after CR, and turn the bare CR\n    into LF SP. */\n\n    ch = (receive_ungetc)(ch);\n    next->text[ptr++] = '\\n';\n    message_size++;\n    ch = ' ';\n    }\n\n  /* We have a data character for the header line. */\n\n  next->text[ptr++] = ch;    /* Add to buffer */\n  message_size++;            /* Total message size so far */\n\n  /* Handle failure due to a humungously long header section. The >= allows\n  for the terminating \\n. Add what we have so far onto the headers list so\n  that it gets reflected in any error message, and back up the just-read\n  character. */\n\n  if (message_size >= header_maxsize)\n    {\n    next->text[ptr] = 0;\n    next->slen = ptr;\n    next->type = htype_other;\n    next->next = NULL;\n    header_last->next = next;\n    header_last = next;\n\n    log_write(0, LOG_MAIN, \"ridiculously long message header received from \"\n      \"%s (more than %d characters): message abandoned\",\n      sender_host_unknown? sender_ident : sender_fullhost, header_maxsize);\n\n    if (smtp_input)\n      {\n      smtp_reply = US\"552 Message header is ridiculously long\";\n      receive_swallow_smtp();\n      goto TIDYUP;                             /* Skip to end of function */\n      }\n\n    else\n      {\n      give_local_error(ERRMESS_VLONGHEADER,\n        string_sprintf(\"message header longer than %d characters received: \"\n         \"message not accepted\", header_maxsize), US\"\", error_rc, stdin,\n           header_list->next);\n      /* Does not return */\n      }\n    }\n\n  continue;                  /* With next input character */\n\n  /* End of header line reached */\n\n  EOL:\n\n  /* Keep track of lines for BSMTP errors and overall message_linecount. */\n\n  receive_linecount++;\n  message_linecount++;\n\n  /* Keep track of maximum line length */\n\n  if (ptr - prevlines_length > max_received_linelength)\n    max_received_linelength = ptr - prevlines_length;\n  prevlines_length = ptr + 1;\n\n  /* Now put in the terminating newline. There is always space for\n  at least two more characters. */\n\n  next->text[ptr++] = '\\n';\n  message_size++;\n\n  /* A blank line signals the end of the headers; release the unwanted\n  space and set next to NULL to indicate this. */\n\n  if (ptr == 1)\n    {\n    store_reset(next);\n    next = NULL;\n    break;\n    }\n\n  /* There is data in the line; see if the next input character is a\n  whitespace character. If it is, we have a continuation of this header line.\n  There is always space for at least one character at this point. */\n\n  if (ch != EOF)\n    {\n    int nextch = (receive_getc)(GETC_BUFFER_UNLIMITED);\n    if (nextch == ' ' || nextch == '\\t')\n      {\n      next->text[ptr++] = nextch;\n      message_size++;\n      continue;                      /* Iterate the loop */\n      }\n    else if (nextch != EOF) (receive_ungetc)(nextch);   /* For next time */\n    else ch = EOF;                   /* Cause main loop to exit at end */\n    }\n\n  /* We have got to the real line end. Terminate the string and release store\n  beyond it. If it turns out to be a real header, internal binary zeros will\n  be squashed later. */\n\n  next->text[ptr] = 0;\n  next->slen = ptr;\n  store_reset(next->text + ptr + 1);\n\n  /* Check the running total size against the overall message size limit. We\n  don't expect to fail here, but if the overall limit is set less than MESSAGE_\n  MAXSIZE and a big header is sent, we want to catch it. Just stop reading\n  headers - the code to read the body will then also hit the buffer. */\n\n  if (message_size > thismessage_size_limit) break;\n\n  /* A line that is not syntactically correct for a header also marks\n  the end of the headers. In this case, we leave next containing the\n  first data line. This might actually be several lines because of the\n  continuation logic applied above, but that doesn't matter.\n\n  It turns out that smail, and presumably sendmail, accept leading lines\n  of the form\n\n  From ph10 Fri Jan  5 12:35 GMT 1996\n\n  in messages. The \"mail\" command on Solaris 2 sends such lines. I cannot\n  find any documentation of this, but for compatibility it had better be\n  accepted. Exim restricts it to the case of non-smtp messages, and\n  treats it as an alternative to the -f command line option. Thus it is\n  ignored except for trusted users or filter testing. Otherwise it is taken\n  as the sender address, unless -f was used (sendmail compatibility).\n\n  It further turns out that some UUCPs generate the From_line in a different\n  format, e.g.\n\n  From ph10 Fri, 7 Jan 97 14:00:00 GMT\n\n  The regex for matching these things is now capable of recognizing both\n  formats (including 2- and 4-digit years in the latter). In fact, the regex\n  is now configurable, as is the expansion string to fish out the sender.\n\n  Even further on it has been discovered that some broken clients send\n  these lines in SMTP messages. There is now an option to ignore them from\n  specified hosts or networks. Sigh. */\n\n  if (header_last == header_list &&\n       (!smtp_input\n         ||\n         (sender_host_address != NULL &&\n           verify_check_host(&ignore_fromline_hosts) == OK)\n         ||\n         (sender_host_address == NULL && ignore_fromline_local)\n       ) &&\n       regex_match_and_setup(regex_From, next->text, 0, -1))\n    {\n    if (!sender_address_forced)\n      {\n      uschar *uucp_sender = expand_string(uucp_from_sender);\n      if (uucp_sender == NULL)\n        {\n        log_write(0, LOG_MAIN|LOG_PANIC,\n          \"expansion of \\\"%s\\\" failed after matching \"\n          \"\\\"From \\\" line: %s\", uucp_from_sender, expand_string_message);\n        }\n      else\n        {\n        int start, end, domain;\n        uschar *errmess;\n        uschar *newsender = parse_extract_address(uucp_sender, &errmess,\n          &start, &end, &domain, TRUE);\n        if (newsender != NULL)\n          {\n          if (domain == 0 && newsender[0] != 0)\n            newsender = rewrite_address_qualify(newsender, FALSE);\n\n          if (filter_test != FTEST_NONE || receive_check_set_sender(newsender))\n            {\n            sender_address = newsender;\n\n            if (trusted_caller || filter_test != FTEST_NONE)\n              {\n              authenticated_sender = NULL;\n              originator_name = US\"\";\n              sender_local = FALSE;\n              }\n\n            if (filter_test != FTEST_NONE)\n              printf(\"Sender taken from \\\"From \\\" line\\n\");\n            }\n          }\n        }\n      }\n    }\n\n  /* Not a leading \"From \" line. Check to see if it is a valid header line.\n  Header names may contain any non-control characters except space and colon,\n  amazingly. */\n\n  else\n    {\n    uschar *p = next->text;\n\n    /* If not a valid header line, break from the header reading loop, leaving\n    next != NULL, indicating that it holds the first line of the body. */\n\n    if (isspace(*p)) break;\n    while (mac_isgraph(*p) && *p != ':') p++;\n    while (isspace(*p)) p++;\n    if (*p != ':')\n      {\n      body_zerocount = had_zero;\n      break;\n      }\n\n    /* We have a valid header line. If there were any binary zeroes in\n    the line, stomp on them here. */\n\n    if (had_zero > 0)\n      for (p = next->text; p < next->text + ptr; p++) if (*p == 0) *p = '?';\n\n    /* It is perfectly legal to have an empty continuation line\n    at the end of a header, but it is confusing to humans\n    looking at such messages, since it looks like a blank line.\n    Reduce confusion by removing redundant white space at the\n    end. We know that there is at least one printing character\n    (the ':' tested for above) so there is no danger of running\n    off the end. */\n\n    p = next->text + ptr - 2;\n    for (;;)\n      {\n      while (*p == ' ' || *p == '\\t') p--;\n      if (*p != '\\n') break;\n      ptr = (p--) - next->text + 1;\n      message_size -= next->slen - ptr;\n      next->text[ptr] = 0;\n      next->slen = ptr;\n      }\n\n    /* Add the header to the chain */\n\n    next->type = htype_other;\n    next->next = NULL;\n    header_last->next = next;\n    header_last = next;\n\n    /* Check the limit for individual line lengths. This comes after adding to\n    the chain so that the failing line is reflected if a bounce is generated\n    (for a local message). */\n\n    if (header_line_maxsize > 0 && next->slen > header_line_maxsize)\n      {\n      log_write(0, LOG_MAIN, \"overlong message header line received from \"\n        \"%s (more than %d characters): message abandoned\",\n        sender_host_unknown? sender_ident : sender_fullhost,\n        header_line_maxsize);\n\n      if (smtp_input)\n        {\n        smtp_reply = US\"552 A message header line is too long\";\n        receive_swallow_smtp();\n        goto TIDYUP;                             /* Skip to end of function */\n        }\n\n      else\n        {\n        give_local_error(ERRMESS_VLONGHDRLINE,\n          string_sprintf(\"message header line longer than %d characters \"\n           \"received: message not accepted\", header_line_maxsize), US\"\",\n           error_rc, stdin, header_list->next);\n        /* Does not return */\n        }\n      }\n\n    /* Note if any resent- fields exist. */\n\n    if (!resents_exist && strncmpic(next->text, US\"resent-\", 7) == 0)\n      {\n      resents_exist = TRUE;\n      resent_prefix = US\"Resent-\";\n      }\n    }\n\n  /* Reject CHUNKING messages that do not CRLF their first header line */\n\n  if (!first_line_ended_crlf && chunking_state > CHUNKING_OFFERED)\n    {\n    log_write(L_size_reject, LOG_MAIN|LOG_REJECT, \"rejected from <%s>%s%s%s%s: \"\n      \"Non-CRLF-terminated header, under CHUNKING: message abandoned\",\n      sender_address,\n      sender_fullhost ? \" H=\" : \"\", sender_fullhost ? sender_fullhost : US\"\",\n      sender_ident ? \" U=\" : \"\",    sender_ident ? sender_ident : US\"\");\n    smtp_printf(\"552 Message header not CRLF terminated\\r\\n\", FALSE);\n    bdat_flush_data();\n    smtp_reply = US\"\";\n    goto TIDYUP;                             /* Skip to end of function */\n    }\n\n  /* The line has been handled. If we have hit EOF, break out of the loop,\n  indicating no pending data line. */\n\n  if (ch == EOF) { next = NULL; break; }\n\n  /* Set up for the next header */\n\n  header_size = 256;\n  next = store_get(sizeof(header_line));\n  next->text = store_get(header_size);\n  ptr = 0;\n  had_zero = 0;\n  prevlines_length = 0;\n  }      /* Continue, starting to read the next header */\n\n/* At this point, we have read all the headers into a data structure in main\nstore. The first header is still the dummy placeholder for the Received: header\nwe are going to generate a bit later on. If next != NULL, it contains the first\ndata line - which terminated the headers before reaching a blank line (not the\nnormal case). */\n\nDEBUG(D_receive)\n  {\n  debug_printf(\">>Headers received:\\n\");\n  for (h = header_list->next; h; h = h->next)\n    debug_printf(\"%s\", h->text);\n  debug_printf(\"\\n\");\n  }\n\n/* End of file on any SMTP connection is an error. If an incoming SMTP call\nis dropped immediately after valid headers, the next thing we will see is EOF.\nWe must test for this specially, as further down the reading of the data is\nskipped if already at EOF. */\n\nif (smtp_input && (receive_feof)())\n  {\n  smtp_reply = handle_lost_connection(US\" (after header)\");\n  smtp_yield = FALSE;\n  goto TIDYUP;                       /* Skip to end of function */\n  }\n\n/* If this is a filter test run and no headers were read, output a warning\nin case there is a mistake in the test message. */\n\nif (filter_test != FTEST_NONE && header_list->next == NULL)\n  printf(\"Warning: no message headers read\\n\");\n\n\n/* Scan the headers to identify them. Some are merely marked for later\nprocessing; some are dealt with here. */\n\nfor (h = header_list->next; h; h = h->next)\n  {\n  BOOL is_resent = strncmpic(h->text, US\"resent-\", 7) == 0;\n  if (is_resent) contains_resent_headers = TRUE;\n\n  switch (header_checkname(h, is_resent))\n    {\n    case htype_bcc:\n    h->type = htype_bcc;        /* Both Bcc: and Resent-Bcc: */\n    break;\n\n    case htype_cc:\n    h->type = htype_cc;         /* Both Cc: and Resent-Cc: */\n    break;\n\n    /* Record whether a Date: or Resent-Date: header exists, as appropriate. */\n\n    case htype_date:\n    if (!resents_exist || is_resent) date_header_exists = TRUE;\n    break;\n\n    /* Same comments as about Return-Path: below. */\n\n    case htype_delivery_date:\n    if (delivery_date_remove) h->type = htype_old;\n    break;\n\n    /* Same comments as about Return-Path: below. */\n\n    case htype_envelope_to:\n    if (envelope_to_remove) h->type = htype_old;\n    break;\n\n    /* Mark all \"From:\" headers so they get rewritten. Save the one that is to\n    be used for Sender: checking. For Sendmail compatibility, if the \"From:\"\n    header consists of just the login id of the user who called Exim, rewrite\n    it with the gecos field first. Apply this rule to Resent-From: if there\n    are resent- fields. */\n\n    case htype_from:\n    h->type = htype_from;\n    if (!resents_exist || is_resent)\n      {\n      from_header = h;\n      if (!smtp_input)\n        {\n        int len;\n        uschar *s = Ustrchr(h->text, ':') + 1;\n        while (isspace(*s)) s++;\n        len = h->slen - (s - h->text) - 1;\n        if (Ustrlen(originator_login) == len &&\n\t    strncmpic(s, originator_login, len) == 0)\n          {\n          uschar *name = is_resent? US\"Resent-From\" : US\"From\";\n          header_add(htype_from, \"%s: %s <%s@%s>\\n\", name, originator_name,\n            originator_login, qualify_domain_sender);\n          from_header = header_last;\n          h->type = htype_old;\n          DEBUG(D_receive|D_rewrite)\n            debug_printf(\"rewrote \\\"%s:\\\" header using gecos\\n\", name);\n         }\n        }\n      }\n    break;\n\n    /* Identify the Message-id: header for generating \"in-reply-to\" in the\n    autoreply transport. For incoming logging, save any resent- value. In both\n    cases, take just the first of any multiples. */\n\n    case htype_id:\n    if (msgid_header == NULL && (!resents_exist || is_resent))\n      {\n      msgid_header = h;\n      h->type = htype_id;\n      }\n    break;\n\n    /* Flag all Received: headers */\n\n    case htype_received:\n    h->type = htype_received;\n    received_count++;\n    break;\n\n    /* \"Reply-to:\" is just noted (there is no resent-reply-to field) */\n\n    case htype_reply_to:\n    h->type = htype_reply_to;\n    break;\n\n    /* The Return-path: header is supposed to be added to messages when\n    they leave the SMTP system. We shouldn't receive messages that already\n    contain Return-path. However, since Exim generates Return-path: on\n    local delivery, resent messages may well contain it. We therefore\n    provide an option (which defaults on) to remove any Return-path: headers\n    on input. Removal actually means flagging as \"old\", which prevents the\n    header being transmitted with the message. */\n\n    case htype_return_path:\n    if (return_path_remove) h->type = htype_old;\n\n    /* If we are testing a mail filter file, use the value of the\n    Return-Path: header to set up the return_path variable, which is not\n    otherwise set. However, remove any <> that surround the address\n    because the variable doesn't have these. */\n\n    if (filter_test != FTEST_NONE)\n      {\n      uschar *start = h->text + 12;\n      uschar *end = start + Ustrlen(start);\n      while (isspace(*start)) start++;\n      while (end > start && isspace(end[-1])) end--;\n      if (*start == '<' && end[-1] == '>')\n        {\n        start++;\n        end--;\n        }\n      return_path = string_copyn(start, end - start);\n      printf(\"Return-path taken from \\\"Return-path:\\\" header line\\n\");\n      }\n    break;\n\n    /* If there is a \"Sender:\" header and the message is locally originated,\n    and from an untrusted caller and suppress_local_fixups is not set, or if we\n    are in submission mode for a remote message, mark it \"old\" so that it will\n    not be transmitted with the message, unless active_local_sender_retain is\n    set. (This can only be true if active_local_from_check is false.) If there\n    are any resent- headers in the message, apply this rule to Resent-Sender:\n    instead of Sender:. Messages with multiple resent- header sets cannot be\n    tidily handled. (For this reason, at least one MUA - Pine - turns old\n    resent- headers into X-resent- headers when resending, leaving just one\n    set.) */\n\n    case htype_sender:\n    h->type = ((!active_local_sender_retain &&\n                (\n                (sender_local && !trusted_caller && !suppress_local_fixups)\n                  || submission_mode\n                )\n               ) &&\n               (!resents_exist||is_resent))?\n      htype_old : htype_sender;\n    break;\n\n    /* Remember the Subject: header for logging. There is no Resent-Subject */\n\n    case htype_subject:\n    subject_header = h;\n    break;\n\n    /* \"To:\" gets flagged, and the existence of a recipient header is noted,\n    whether it's resent- or not. */\n\n    case htype_to:\n    h->type = htype_to;\n    /****\n    to_or_cc_header_exists = TRUE;\n    ****/\n    break;\n    }\n  }\n\n/* Extract recipients from the headers if that is required (the -t option).\nNote that this is documented as being done *before* any address rewriting takes\nplace. There are two possibilities:\n\n(1) According to sendmail documentation for Solaris, IRIX, and HP-UX, any\nrecipients already listed are to be REMOVED from the message. Smail 3 works\nlike this. We need to build a non-recipients tree for that list, because in\nsubsequent processing this data is held in a tree and that's what the\nspool_write_header() function expects. Make sure that non-recipient addresses\nare fully qualified and rewritten if necessary.\n\n(2) According to other sendmail documentation, -t ADDS extracted recipients to\nthose in the command line arguments (and it is rumoured some other MTAs do\nthis). Therefore, there is an option to make Exim behave this way.\n\n*** Notes on \"Resent-\" header lines ***\n\nThe presence of resent-headers in the message makes -t horribly ambiguous.\nExperiments with sendmail showed that it uses recipients for all resent-\nheaders, totally ignoring the concept of \"sets of resent- headers\" as described\nin RFC 2822 section 3.6.6. Sendmail also amalgamates them into a single set\nwith all the addresses in one instance of each header.\n\nThis seems to me not to be at all sensible. Before release 4.20, Exim 4 gave an\nerror for -t if there were resent- headers in the message. However, after a\ndiscussion on the mailing list, I've learned that there are MUAs that use\nresent- headers with -t, and also that the stuff about sets of resent- headers\nand their ordering in RFC 2822 is generally ignored. An MUA that submits a\nmessage with -t and resent- header lines makes sure that only *its* resent-\nheaders are present; previous ones are often renamed as X-resent- for example.\n\nConsequently, Exim has been changed so that, if any resent- header lines are\npresent, the recipients are taken from all of the appropriate resent- lines,\nand not from the ordinary To:, Cc:, etc. */\n\nif (extract_recip)\n  {\n  int rcount = 0;\n  error_block **bnext = &bad_addresses;\n\n  if (extract_addresses_remove_arguments)\n    {\n    while (recipients_count-- > 0)\n      {\n      uschar *s = rewrite_address(recipients_list[recipients_count].address,\n        TRUE, TRUE, global_rewrite_rules, rewrite_existflags);\n      tree_add_nonrecipient(s);\n      }\n    recipients_list = NULL;\n    recipients_count = recipients_list_max = 0;\n    }\n\n  /* Now scan the headers */\n\n  for (h = header_list->next; h; h = h->next)\n    {\n    if ((h->type == htype_to || h->type == htype_cc || h->type == htype_bcc) &&\n        (!contains_resent_headers || strncmpic(h->text, US\"resent-\", 7) == 0))\n      {\n      uschar *s = Ustrchr(h->text, ':') + 1;\n      while (isspace(*s)) s++;\n\n      parse_allow_group = TRUE;          /* Allow address group syntax */\n\n      while (*s != 0)\n        {\n        uschar *ss = parse_find_address_end(s, FALSE);\n        uschar *recipient, *errmess, *p, *pp;\n        int start, end, domain;\n\n        /* Check on maximum */\n\n        if (recipients_max > 0 && ++rcount > recipients_max)\n          {\n          give_local_error(ERRMESS_TOOMANYRECIP, US\"too many recipients\",\n            US\"message rejected: \", error_rc, stdin, NULL);\n          /* Does not return */\n          }\n\n        /* Make a copy of the address, and remove any internal newlines. These\n        may be present as a result of continuations of the header line. The\n        white space that follows the newline must not be removed - it is part\n        of the header. */\n\n        pp = recipient = store_get(ss - s + 1);\n        for (p = s; p < ss; p++) if (*p != '\\n') *pp++ = *p;\n        *pp = 0;\n\n#ifdef SUPPORT_I18N\n\t{\n\tBOOL b = allow_utf8_domains;\n\tallow_utf8_domains = TRUE;\n#endif\n        recipient = parse_extract_address(recipient, &errmess, &start, &end,\n          &domain, FALSE);\n\n#ifdef SUPPORT_I18N\n\tif (string_is_utf8(recipient))\n\t  message_smtputf8 = TRUE;\n\telse\n\t  allow_utf8_domains = b;\n\t}\n#endif\n\n        /* Keep a list of all the bad addresses so we can send a single\n        error message at the end. However, an empty address is not an error;\n        just ignore it. This can come from an empty group list like\n\n          To: Recipients of list:;\n\n        If there are no recipients at all, an error will occur later. */\n\n        if (recipient == NULL && Ustrcmp(errmess, \"empty address\") != 0)\n          {\n          int len = Ustrlen(s);\n          error_block *b = store_get(sizeof(error_block));\n          while (len > 0 && isspace(s[len-1])) len--;\n          b->next = NULL;\n          b->text1 = string_printing(string_copyn(s, len));\n          b->text2 = errmess;\n          *bnext = b;\n          bnext = &(b->next);\n          }\n\n        /* If the recipient is already in the nonrecipients tree, it must\n        have appeared on the command line with the option extract_addresses_\n        remove_arguments set. Do not add it to the recipients, and keep a note\n        that this has happened, in order to give a better error if there are\n        no recipients left. */\n\n        else if (recipient != NULL)\n          {\n          if (tree_search(tree_nonrecipients, recipient) == NULL)\n            receive_add_recipient(recipient, -1);\n          else\n            extracted_ignored = TRUE;\n          }\n\n        /* Move on past this address */\n\n        s = ss + (*ss? 1:0);\n        while (isspace(*s)) s++;\n        }    /* Next address */\n\n      parse_allow_group = FALSE;      /* Reset group syntax flags */\n      parse_found_group = FALSE;\n\n      /* If this was the bcc: header, mark it \"old\", which means it\n      will be kept on the spool, but not transmitted as part of the\n      message. */\n\n      if (h->type == htype_bcc) h->type = htype_old;\n      }   /* For appropriate header line */\n    }     /* For each header line */\n\n  }\n\n/* Now build the unique message id. This has changed several times over the\nlifetime of Exim. This description was rewritten for Exim 4.14 (February 2003).\nRetaining all the history in the comment has become too unwieldy - read\nprevious release sources if you want it.\n\nThe message ID has 3 parts: tttttt-pppppp-ss. Each part is a number in base 62.\nThe first part is the current time, in seconds. The second part is the current\npid. Both are large enough to hold 32-bit numbers in base 62. The third part\ncan hold a number in the range 0-3843. It used to be a computed sequence\nnumber, but is now the fractional component of the current time in units of\n1/2000 of a second (i.e. a value in the range 0-1999). After a message has been\nreceived, Exim ensures that the timer has ticked at the appropriate level\nbefore proceeding, to avoid duplication if the pid happened to be re-used\nwithin the same time period. It seems likely that most messages will take at\nleast half a millisecond to be received, so no delay will normally be\nnecessary. At least for some time...\n\nThere is a modification when localhost_number is set. Formerly this was allowed\nto be as large as 255. Now it is restricted to the range 0-16, and the final\ncomponent of the message id becomes (localhost_number * 200) + fractional time\nin units of 1/200 of a second (i.e. a value in the range 0-3399).\n\nSome not-really-Unix operating systems use case-insensitive file names (Darwin,\nCygwin). For these, we have to use base 36 instead of base 62. Luckily, this\nstill allows the tttttt field to hold a large enough number to last for some\nmore decades, and the final two-digit field can hold numbers up to 1295, which\nis enough for milliseconds (instead of 1/2000 of a second).\n\nHowever, the pppppp field cannot hold a 32-bit pid, but it can hold a 31-bit\npid, so it is probably safe because pids have to be positive. The\nlocalhost_number is restricted to 0-10 for these hosts, and when it is set, the\nfinal field becomes (localhost_number * 100) + fractional time in centiseconds.\n\nNote that string_base62() returns its data in a static storage block, so it\nmust be copied before calling string_base62() again. It always returns exactly\n6 characters.\n\nThere doesn't seem to be anything in the RFC which requires a message id to\nstart with a letter, but Smail was changed to ensure this. The external form of\nthe message id (as supplied by string expansion) therefore starts with an\nadditional leading 'E'. The spool file names do not include this leading\nletter and it is not used internally.\n\nNOTE: If ever the format of message ids is changed, the regular expression for\nchecking that a string is in this format must be updated in a corresponding\nway. It appears in the initializing code in exim.c. The macro MESSAGE_ID_LENGTH\nmust also be changed to reflect the correct string length. The queue-sort code\nneeds to know the layout. Then, of course, other programs that rely on the\nmessage id format will need updating too. */\n\nUstrncpy(message_id, string_base62((long int)(message_id_tv.tv_sec)), 6);\nmessage_id[6] = '-';\nUstrncpy(message_id + 7, string_base62((long int)getpid()), 6);\n\n/* Deal with the case where the host number is set. The value of the number was\nchecked when it was read, to ensure it isn't too big. The timing granularity is\nleft in id_resolution so that an appropriate wait can be done after receiving\nthe message, if necessary (we hope it won't be). */\n\nif (host_number_string != NULL)\n  {\n  id_resolution = (BASE_62 == 62)? 5000 : 10000;\n  sprintf(CS(message_id + MESSAGE_ID_LENGTH - 3), \"-%2s\",\n    string_base62((long int)(\n      host_number * (1000000/id_resolution) +\n        message_id_tv.tv_usec/id_resolution)) + 4);\n  }\n\n/* Host number not set: final field is just the fractional time at an\nappropriate resolution. */\n\nelse\n  {\n  id_resolution = (BASE_62 == 62)? 500 : 1000;\n  sprintf(CS(message_id + MESSAGE_ID_LENGTH - 3), \"-%2s\",\n    string_base62((long int)(message_id_tv.tv_usec/id_resolution)) + 4);\n  }\n\n/* Add the current message id onto the current process info string if\nit will fit. */\n\n(void)string_format(process_info + process_info_len,\n  PROCESS_INFO_SIZE - process_info_len, \" id=%s\", message_id);\n\n/* If we are using multiple input directories, set up the one for this message\nto be the least significant base-62 digit of the time of arrival. Otherwise\nensure that it is an empty string. */\n\nmessage_subdir[0] = split_spool_directory ? message_id[5] : 0;\n\n/* Now that we have the message-id, if there is no message-id: header, generate\none, but only for local (without suppress_local_fixups) or submission mode\nmessages. This can be user-configured if required, but we had better flatten\nany illegal characters therein. */\n\nif (msgid_header == NULL &&\n      ((sender_host_address == NULL && !suppress_local_fixups)\n        || submission_mode))\n  {\n  uschar *p;\n  uschar *id_text = US\"\";\n  uschar *id_domain = primary_hostname;\n\n  /* Permit only letters, digits, dots, and hyphens in the domain */\n\n  if (message_id_domain != NULL)\n    {\n    uschar *new_id_domain = expand_string(message_id_domain);\n    if (new_id_domain == NULL)\n      {\n      if (!expand_string_forcedfail)\n        log_write(0, LOG_MAIN|LOG_PANIC,\n          \"expansion of \\\"%s\\\" (message_id_header_domain) \"\n          \"failed: %s\", message_id_domain, expand_string_message);\n      }\n    else if (*new_id_domain != 0)\n      {\n      id_domain = new_id_domain;\n      for (p = id_domain; *p != 0; p++)\n        if (!isalnum(*p) && *p != '.') *p = '-';  /* No need to test '-' ! */\n      }\n    }\n\n  /* Permit all characters except controls and RFC 2822 specials in the\n  additional text part. */\n\n  if (message_id_text != NULL)\n    {\n    uschar *new_id_text = expand_string(message_id_text);\n    if (new_id_text == NULL)\n      {\n      if (!expand_string_forcedfail)\n        log_write(0, LOG_MAIN|LOG_PANIC,\n          \"expansion of \\\"%s\\\" (message_id_header_text) \"\n          \"failed: %s\", message_id_text, expand_string_message);\n      }\n    else if (*new_id_text != 0)\n      {\n      id_text = new_id_text;\n      for (p = id_text; *p != 0; p++)\n        if (mac_iscntrl_or_special(*p)) *p = '-';\n      }\n    }\n\n  /* Add the header line\n   * Resent-* headers are prepended, per RFC 5322 3.6.6.  Non-Resent-* are\n   * appended, to preserve classical expectations of header ordering. */\n\n  header_add_at_position(!resents_exist, NULL, FALSE, htype_id,\n    \"%sMessage-Id: <%s%s%s@%s>\\n\", resent_prefix, message_id_external,\n    (*id_text == 0)? \"\" : \".\", id_text, id_domain);\n  }\n\n/* If we are to log recipients, keep a copy of the raw ones before any possible\nrewriting. Must copy the count, because later ACLs and the local_scan()\nfunction may mess with the real recipients. */\n\nif (LOGGING(received_recipients))\n  {\n  raw_recipients = store_get(recipients_count * sizeof(uschar *));\n  for (i = 0; i < recipients_count; i++)\n    raw_recipients[i] = string_copy(recipients_list[i].address);\n  raw_recipients_count = recipients_count;\n  }\n\n/* Ensure the recipients list is fully qualified and rewritten. Unqualified\nrecipients will get here only if the conditions were right (allow_unqualified_\nrecipient is TRUE). */\n\nfor (i = 0; i < recipients_count; i++)\n  recipients_list[i].address =\n    rewrite_address(recipients_list[i].address, TRUE, TRUE,\n      global_rewrite_rules, rewrite_existflags);\n\n/* If there is no From: header, generate one for local (without\nsuppress_local_fixups) or submission_mode messages. If there is no sender\naddress, but the sender is local or this is a local delivery error, use the\noriginator login. This shouldn't happen for genuine bounces, but might happen\nfor autoreplies. The addition of From: must be done *before* checking for the\npossible addition of a Sender: header, because untrusted_set_sender allows an\nuntrusted user to set anything in the envelope (which might then get info\nFrom:) but we still want to ensure a valid Sender: if it is required. */\n\nif (from_header == NULL &&\n    ((sender_host_address == NULL && !suppress_local_fixups)\n      || submission_mode))\n  {\n  uschar *oname = US\"\";\n\n  /* Use the originator_name if this is a locally submitted message and the\n  caller is not trusted. For trusted callers, use it only if -F was used to\n  force its value or if we have a non-SMTP message for which -f was not used\n  to set the sender. */\n\n  if (sender_host_address == NULL)\n    {\n    if (!trusted_caller || sender_name_forced ||\n         (!smtp_input && !sender_address_forced))\n      oname = originator_name;\n    }\n\n  /* For non-locally submitted messages, the only time we use the originator\n  name is when it was forced by the /name= option on control=submission. */\n\n  else\n    {\n    if (submission_name != NULL) oname = submission_name;\n    }\n\n  /* Envelope sender is empty */\n\n  if (sender_address[0] == 0)\n    {\n    uschar *fromstart, *fromend;\n\n    fromstart = string_sprintf(\"%sFrom: %s%s\", resent_prefix,\n      oname, (oname[0] == 0)? \"\" : \" <\");\n    fromend = (oname[0] == 0)? US\"\" : US\">\";\n\n    if (sender_local || local_error_message)\n      {\n      header_add(htype_from, \"%s%s@%s%s\\n\", fromstart,\n        local_part_quote(originator_login), qualify_domain_sender,\n        fromend);\n      }\n    else if (submission_mode && authenticated_id != NULL)\n      {\n      if (submission_domain == NULL)\n        {\n        header_add(htype_from, \"%s%s@%s%s\\n\", fromstart,\n          local_part_quote(authenticated_id), qualify_domain_sender,\n          fromend);\n        }\n      else if (submission_domain[0] == 0)  /* empty => whole address set */\n        {\n        header_add(htype_from, \"%s%s%s\\n\", fromstart, authenticated_id,\n          fromend);\n        }\n      else\n        {\n        header_add(htype_from, \"%s%s@%s%s\\n\", fromstart,\n          local_part_quote(authenticated_id), submission_domain,\n          fromend);\n        }\n      from_header = header_last;    /* To get it checked for Sender: */\n      }\n    }\n\n  /* There is a non-null envelope sender. Build the header using the original\n  sender address, before any rewriting that might have been done while\n  verifying it. */\n\n  else\n    {\n    header_add(htype_from, \"%sFrom: %s%s%s%s\\n\", resent_prefix,\n      oname,\n      (oname[0] == 0)? \"\" : \" <\",\n      (sender_address_unrewritten == NULL)?\n        sender_address : sender_address_unrewritten,\n      (oname[0] == 0)? \"\" : \">\");\n\n    from_header = header_last;    /* To get it checked for Sender: */\n    }\n  }\n\n\n/* If the sender is local (without suppress_local_fixups), or if we are in\nsubmission mode and there is an authenticated_id, check that an existing From:\nis correct, and if not, generate a Sender: header, unless disabled. Any\npreviously-existing Sender: header was removed above. Note that sender_local,\nas well as being TRUE if the caller of exim is not trusted, is also true if a\ntrusted caller did not supply a -f argument for non-smtp input. To allow\ntrusted callers to forge From: without supplying -f, we have to test explicitly\nhere. If the From: header contains more than one address, then the call to\nparse_extract_address fails, and a Sender: header is inserted, as required. */\n\nif (from_header != NULL &&\n     (active_local_from_check &&\n       ((sender_local && !trusted_caller && !suppress_local_fixups) ||\n        (submission_mode && authenticated_id != NULL))\n     ))\n  {\n  BOOL make_sender = TRUE;\n  int start, end, domain;\n  uschar *errmess;\n  uschar *from_address =\n    parse_extract_address(Ustrchr(from_header->text, ':') + 1, &errmess,\n      &start, &end, &domain, FALSE);\n  uschar *generated_sender_address;\n\n  if (submission_mode)\n    {\n    if (submission_domain == NULL)\n      {\n      generated_sender_address = string_sprintf(\"%s@%s\",\n        local_part_quote(authenticated_id), qualify_domain_sender);\n      }\n    else if (submission_domain[0] == 0)  /* empty => full address */\n      {\n      generated_sender_address = string_sprintf(\"%s\",\n        authenticated_id);\n      }\n    else\n      {\n      generated_sender_address = string_sprintf(\"%s@%s\",\n        local_part_quote(authenticated_id), submission_domain);\n      }\n    }\n  else\n    generated_sender_address = string_sprintf(\"%s@%s\",\n      local_part_quote(originator_login), qualify_domain_sender);\n\n  /* Remove permitted prefixes and suffixes from the local part of the From:\n  address before doing the comparison with the generated sender. */\n\n  if (from_address != NULL)\n    {\n    int slen;\n    uschar *at = (domain == 0)? NULL : from_address + domain - 1;\n\n    if (at != NULL) *at = 0;\n    from_address += route_check_prefix(from_address, local_from_prefix);\n    slen = route_check_suffix(from_address, local_from_suffix);\n    if (slen > 0)\n      {\n      memmove(from_address+slen, from_address, Ustrlen(from_address)-slen);\n      from_address += slen;\n      }\n    if (at != NULL) *at = '@';\n\n    if (strcmpic(generated_sender_address, from_address) == 0 ||\n      (domain == 0 && strcmpic(from_address, originator_login) == 0))\n        make_sender = FALSE;\n    }\n\n  /* We have to cause the Sender header to be rewritten if there are\n  appropriate rewriting rules. */\n\n  if (make_sender)\n    {\n    if (submission_mode && submission_name == NULL)\n      header_add(htype_sender, \"%sSender: %s\\n\", resent_prefix,\n        generated_sender_address);\n    else\n      header_add(htype_sender, \"%sSender: %s <%s>\\n\",\n        resent_prefix,\n        submission_mode? submission_name : originator_name,\n        generated_sender_address);\n    }\n\n  /* Ensure that a non-null envelope sender address corresponds to the\n  submission mode sender address. */\n\n  if (submission_mode && sender_address[0] != 0)\n    {\n    if (sender_address_unrewritten == NULL)\n      sender_address_unrewritten = sender_address;\n    sender_address = generated_sender_address;\n    if (Ustrcmp(sender_address_unrewritten, generated_sender_address) != 0)\n      log_write(L_address_rewrite, LOG_MAIN,\n        \"\\\"%s\\\" from env-from rewritten as \\\"%s\\\" by submission mode\",\n        sender_address_unrewritten, generated_sender_address);\n    }\n  }\n\n/* If there are any rewriting rules, apply them to the sender address, unless\nit has already been rewritten as part of verification for SMTP input. */\n\nif (global_rewrite_rules != NULL && sender_address_unrewritten == NULL &&\n    sender_address[0] != 0)\n  {\n  sender_address = rewrite_address(sender_address, FALSE, TRUE,\n    global_rewrite_rules, rewrite_existflags);\n  DEBUG(D_receive|D_rewrite)\n    debug_printf(\"rewritten sender = %s\\n\", sender_address);\n  }\n\n\n/* The headers must be run through rewrite_header(), because it ensures that\naddresses are fully qualified, as well as applying any rewriting rules that may\nexist.\n\nQualification of header addresses in a message from a remote host happens only\nif the host is in sender_unqualified_hosts or recipient_unqualified hosts, as\nappropriate. For local messages, qualification always happens, unless -bnq is\nused to explicitly suppress it. No rewriting is done for an unqualified address\nthat is left untouched.\n\nWe start at the second header, skipping our own Received:. This rewriting is\ndocumented as happening *after* recipient addresses are taken from the headers\nby the -t command line option. An added Sender: gets rewritten here. */\n\nfor (h = header_list->next; h; h = h->next)\n  {\n  header_line *newh = rewrite_header(h, NULL, NULL, global_rewrite_rules,\n    rewrite_existflags, TRUE);\n  if (newh) h = newh;\n  }\n\n\n/* An RFC 822 (sic) message is not legal unless it has at least one of \"to\",\n\"cc\", or \"bcc\". Note that although the minimal examples in RFC 822 show just\n\"to\" or \"bcc\", the full syntax spec allows \"cc\" as well. If any resent- header\nexists, this applies to the set of resent- headers rather than the normal set.\n\nThe requirement for a recipient header has been removed in RFC 2822. At this\npoint in the code, earlier versions of Exim added a To: header for locally\nsubmitted messages, and an empty Bcc: header for others. In the light of the\nchanges in RFC 2822, this was dropped in November 2003. */\n\n\n/* If there is no date header, generate one if the message originates locally\n(i.e. not over TCP/IP) and suppress_local_fixups is not set, or if the\nsubmission mode flag is set. Messages without Date: are not valid, but it seems\nto be more confusing if Exim adds one to all remotely-originated messages.\nAs per Message-Id, we prepend if resending, else append.\n*/\n\nif (!date_header_exists &&\n      ((sender_host_address == NULL && !suppress_local_fixups)\n        || submission_mode))\n  header_add_at_position(!resents_exist, NULL, FALSE, htype_other,\n    \"%sDate: %s\\n\", resent_prefix, tod_stamp(tod_full));\n\nsearch_tidyup();    /* Free any cached resources */\n\n/* Show the complete set of headers if debugging. Note that the first one (the\nnew Received:) has not yet been set. */\n\nDEBUG(D_receive)\n  {\n  debug_printf(\">>Headers after rewriting and local additions:\\n\");\n  for (h = header_list->next; h != NULL; h = h->next)\n    debug_printf(\"%c %s\", h->type, h->text);\n  debug_printf(\"\\n\");\n  }\n\n/* The headers are now complete in store. If we are running in filter\ntesting mode, that is all this function does. Return TRUE if the message\nended with a dot. */\n\nif (filter_test != FTEST_NONE)\n  {\n  process_info[process_info_len] = 0;\n  return message_ended == END_DOT;\n  }\n\n/*XXX CHUNKING: need to cancel cutthrough under BDAT, for now.  In future,\nthink more if it could be handled.  Cannot do onward CHUNKING unless\ninbound is, but inbound chunking ought to be ok with outbound plain.\nCould we do onward CHUNKING given inbound CHUNKING?\n*/\nif (chunking_state > CHUNKING_OFFERED)\n  cancel_cutthrough_connection(FALSE, US\"chunking active\");\n\n/* Cutthrough delivery:\nWe have to create the Received header now rather than at the end of reception,\nso the timestamp behaviour is a change to the normal case.\nHaving created it, send the headers to the destination. */\n\nif (cutthrough.fd >= 0 && cutthrough.delivery)\n  {\n  if (received_count > received_headers_max)\n    {\n    cancel_cutthrough_connection(TRUE, US\"too many headers\");\n    if (smtp_input) receive_swallow_smtp();  /* Swallow incoming SMTP */\n    log_write(0, LOG_MAIN|LOG_REJECT, \"rejected from <%s>%s%s%s%s: \"\n      \"Too many \\\"Received\\\" headers\",\n      sender_address,\n      sender_fullhost ? \"H=\" : \"\", sender_fullhost ? sender_fullhost : US\"\",\n      sender_ident ? \"U=\" : \"\", sender_ident ? sender_ident : US\"\");\n    message_id[0] = 0;                       /* Indicate no message accepted */\n    smtp_reply = US\"550 Too many \\\"Received\\\" headers - suspected mail loop\";\n    goto TIDYUP;                             /* Skip to end of function */\n    }\n  received_header_gen();\n  add_acl_headers(ACL_WHERE_RCPT, US\"MAIL or RCPT\");\n  (void) cutthrough_headers_send();\n  }\n\n\n/* Open a new spool file for the data portion of the message. We need\nto access it both via a file descriptor and a stream. Try to make the\ndirectory if it isn't there. */\n\nspool_name = spool_fname(US\"input\", message_subdir, message_id, US\"-D\");\nDEBUG(D_receive) debug_printf(\"Data file name: %s\\n\", spool_name);\n\nif ((data_fd = Uopen(spool_name, O_RDWR|O_CREAT|O_EXCL, SPOOL_MODE)) < 0)\n  {\n  if (errno == ENOENT)\n    {\n    (void) directory_make(spool_directory,\n\t\t        spool_sname(US\"input\", message_subdir),\n\t\t\tINPUT_DIRECTORY_MODE, TRUE);\n    data_fd = Uopen(spool_name, O_RDWR|O_CREAT|O_EXCL, SPOOL_MODE);\n    }\n  if (data_fd < 0)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"Failed to create spool file %s: %s\",\n      spool_name, strerror(errno));\n  }\n\n/* Make sure the file's group is the Exim gid, and double-check the mode\nbecause the group setting doesn't always get set automatically. */\n\nif (fchown(data_fd, exim_uid, exim_gid))\n  log_write(0, LOG_MAIN|LOG_PANIC_DIE,\n    \"Failed setting ownership on spool file %s: %s\",\n    spool_name, strerror(errno));\n(void)fchmod(data_fd, SPOOL_MODE);\n\n/* We now have data file open. Build a stream for it and lock it. We lock only\nthe first line of the file (containing the message ID) because otherwise there\nare problems when Exim is run under Cygwin (I'm told). See comments in\nspool_in.c, where the same locking is done. */\n\ndata_file = fdopen(data_fd, \"w+\");\nlock_data.l_type = F_WRLCK;\nlock_data.l_whence = SEEK_SET;\nlock_data.l_start = 0;\nlock_data.l_len = SPOOL_DATA_START_OFFSET;\n\nif (fcntl(data_fd, F_SETLK, &lock_data) < 0)\n  log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"Cannot lock %s (%d): %s\", spool_name,\n    errno, strerror(errno));\n\n/* We have an open, locked data file. Write the message id to it to make it\nself-identifying. Then read the remainder of the input of this message and\nwrite it to the data file. If the variable next != NULL, it contains the first\ndata line (which was read as a header but then turned out not to have the right\nformat); write it (remembering that it might contain binary zeros). The result\nof fwrite() isn't inspected; instead we call ferror() below. */\n\nfprintf(data_file, \"%s-D\\n\", message_id);\nif (next != NULL)\n  {\n  uschar *s = next->text;\n  int len = next->slen;\n  len = fwrite(s, 1, len, data_file);  len = len; /* compiler quietening */\n  body_linecount++;                 /* Assumes only 1 line */\n  }\n\n/* Note that we might already be at end of file, or the logical end of file\n(indicated by '.'), or might have encountered an error while writing the\nmessage id or \"next\" line. */\n\nif (!ferror(data_file) && !(receive_feof)() && message_ended != END_DOT)\n  {\n  if (smtp_input)\n    {\n    message_ended = chunking_state <= CHUNKING_OFFERED\n      ? read_message_data_smtp(data_file)\n      : spool_wireformat\n      ? read_message_bdat_smtp_wire(data_file)\n      : read_message_bdat_smtp(data_file);\n    receive_linecount++;                /* The terminating \".\" line */\n    }\n  else message_ended = read_message_data(data_file);\n\n  receive_linecount += body_linecount;  /* For BSMTP errors mainly */\n  message_linecount += body_linecount;\n\n  switch (message_ended)\n    {\n    /* Handle premature termination of SMTP */\n\n    case END_EOF:\n      if (smtp_input)\n\t{\n\tUunlink(spool_name);                 /* Lose data file when closed */\n\tcancel_cutthrough_connection(TRUE, US\"sender closed connection\");\n\tmessage_id[0] = 0;                   /* Indicate no message accepted */\n\tsmtp_reply = handle_lost_connection(US\"\");\n\tsmtp_yield = FALSE;\n\tgoto TIDYUP;                         /* Skip to end of function */\n\t}\n      break;\n\n    /* Handle message that is too big. Don't use host_or_ident() in the log\n    message; we want to see the ident value even for non-remote messages. */\n\n    case END_SIZE:\n      Uunlink(spool_name);                /* Lose the data file when closed */\n      cancel_cutthrough_connection(TRUE, US\"mail too big\");\n      if (smtp_input) receive_swallow_smtp();  /* Swallow incoming SMTP */\n\n      log_write(L_size_reject, LOG_MAIN|LOG_REJECT, \"rejected from <%s>%s%s%s%s: \"\n\t\"message too big: read=%d max=%d\",\n\tsender_address,\n\t(sender_fullhost == NULL)? \"\" : \" H=\",\n\t(sender_fullhost == NULL)? US\"\" : sender_fullhost,\n\t(sender_ident == NULL)? \"\" : \" U=\",\n\t(sender_ident == NULL)? US\"\" : sender_ident,\n\tmessage_size,\n\tthismessage_size_limit);\n\n      if (smtp_input)\n\t{\n\tsmtp_reply = US\"552 Message size exceeds maximum permitted\";\n\tmessage_id[0] = 0;               /* Indicate no message accepted */\n\tgoto TIDYUP;                     /* Skip to end of function */\n\t}\n      else\n\t{\n\tfseek(data_file, (long int)SPOOL_DATA_START_OFFSET, SEEK_SET);\n\tgive_local_error(ERRMESS_TOOBIG,\n\t  string_sprintf(\"message too big (max=%d)\", thismessage_size_limit),\n\t  US\"message rejected: \", error_rc, data_file, header_list);\n\t/* Does not return */\n\t}\n      break;\n\n    /* Handle bad BDAT protocol sequence */\n\n    case END_PROTOCOL:\n      Uunlink(spool_name);\t\t/* Lose the data file when closed */\n      cancel_cutthrough_connection(TRUE, US\"sender protocol error\");\n      smtp_reply = US\"\";\t\t/* Response already sent */\n      message_id[0] = 0;\t\t/* Indicate no message accepted */\n      goto TIDYUP;\t\t\t/* Skip to end of function */\n    }\n  }\n\n/* Restore the standard SIGALRM handler for any subsequent processing. (For\nexample, there may be some expansion in an ACL that uses a timer.) */\n\nos_non_restarting_signal(SIGALRM, sigalrm_handler);\n\n/* The message body has now been read into the data file. Call fflush() to\nempty the buffers in C, and then call fsync() to get the data written out onto\nthe disk, as fflush() doesn't do this (or at least, it isn't documented as\nhaving to do this). If there was an I/O error on either input or output,\nattempt to send an error message, and unlink the spool file. For non-SMTP input\nwe can then give up. Note that for SMTP input we must swallow the remainder of\nthe input in cases of output errors, since the far end doesn't expect to see\nanything until the terminating dot line is sent. */\n\nif (fflush(data_file) == EOF || ferror(data_file) ||\n    EXIMfsync(fileno(data_file)) < 0 || (receive_ferror)())\n  {\n  uschar *msg_errno = US strerror(errno);\n  BOOL input_error = (receive_ferror)() != 0;\n  uschar *msg = string_sprintf(\"%s error (%s) while receiving message from %s\",\n    input_error? \"Input read\" : \"Spool write\",\n    msg_errno,\n    (sender_fullhost != NULL)? sender_fullhost : sender_ident);\n\n  log_write(0, LOG_MAIN, \"Message abandoned: %s\", msg);\n  Uunlink(spool_name);                /* Lose the data file */\n  cancel_cutthrough_connection(TRUE, US\"error writing spoolfile\");\n\n  if (smtp_input)\n    {\n    if (input_error)\n      smtp_reply = US\"451 Error while reading input data\";\n    else\n      {\n      smtp_reply = US\"451 Error while writing spool file\";\n      receive_swallow_smtp();\n      }\n    message_id[0] = 0;               /* Indicate no message accepted */\n    goto TIDYUP;                     /* Skip to end of function */\n    }\n\n  else\n    {\n    fseek(data_file, (long int)SPOOL_DATA_START_OFFSET, SEEK_SET);\n    give_local_error(ERRMESS_IOERR, msg, US\"\", error_rc, data_file,\n      header_list);\n    /* Does not return */\n    }\n  }\n\n\n/* No I/O errors were encountered while writing the data file. */\n\nDEBUG(D_receive) debug_printf(\"Data file written for message %s\\n\", message_id);\n\n\n/* If there were any bad addresses extracted by -t, or there were no recipients\nleft after -t, send a message to the sender of this message, or write it to\nstderr if the error handling option is set that way. Note that there may\nlegitimately be no recipients for an SMTP message if they have all been removed\nby \"discard\".\n\nWe need to rewind the data file in order to read it. In the case of no\nrecipients or stderr error writing, throw the data file away afterwards, and\nexit. (This can't be SMTP, which always ensures there's at least one\nsyntactically good recipient address.) */\n\nif (extract_recip && (bad_addresses != NULL || recipients_count == 0))\n  {\n  DEBUG(D_receive)\n    {\n    if (recipients_count == 0) debug_printf(\"*** No recipients\\n\");\n    if (bad_addresses != NULL)\n      {\n      error_block *eblock = bad_addresses;\n      debug_printf(\"*** Bad address(es)\\n\");\n      while (eblock != NULL)\n        {\n        debug_printf(\"  %s: %s\\n\", eblock->text1, eblock->text2);\n        eblock = eblock->next;\n        }\n      }\n    }\n\n  fseek(data_file, (long int)SPOOL_DATA_START_OFFSET, SEEK_SET);\n\n  /* If configured to send errors to the sender, but this fails, force\n  a failure error code. We use a special one for no recipients so that it\n  can be detected by the autoreply transport. Otherwise error_rc is set to\n  errors_sender_rc, which is EXIT_FAILURE unless -oee was given, in which case\n  it is EXIT_SUCCESS. */\n\n  if (error_handling == ERRORS_SENDER)\n    {\n    if (!moan_to_sender(\n          (bad_addresses == NULL)?\n            (extracted_ignored? ERRMESS_IGADDRESS : ERRMESS_NOADDRESS) :\n          (recipients_list == NULL)? ERRMESS_BADNOADDRESS : ERRMESS_BADADDRESS,\n          bad_addresses, header_list, data_file, FALSE))\n      error_rc = (bad_addresses == NULL)? EXIT_NORECIPIENTS : EXIT_FAILURE;\n    }\n  else\n    {\n    if (bad_addresses == NULL)\n      {\n      if (extracted_ignored)\n        fprintf(stderr, \"exim: all -t recipients overridden by command line\\n\");\n      else\n        fprintf(stderr, \"exim: no recipients in message\\n\");\n      }\n    else\n      {\n      fprintf(stderr, \"exim: invalid address%s\",\n        (bad_addresses->next == NULL)? \":\" : \"es:\\n\");\n      while (bad_addresses != NULL)\n        {\n        fprintf(stderr, \"  %s: %s\\n\", bad_addresses->text1,\n          bad_addresses->text2);\n        bad_addresses = bad_addresses->next;\n        }\n      }\n    }\n\n  if (recipients_count == 0 || error_handling == ERRORS_STDERR)\n    {\n    Uunlink(spool_name);\n    (void)fclose(data_file);\n    exim_exit(error_rc, US\"receiving\");\n    }\n  }\n\n/* Data file successfully written. Generate text for the Received: header by\nexpanding the configured string, and adding a timestamp. By leaving this\noperation till now, we ensure that the timestamp is the time that message\nreception was completed. However, this is deliberately done before calling the\ndata ACL and local_scan().\n\nThis Received: header may therefore be inspected by the data ACL and by code in\nthe local_scan() function. When they have run, we update the timestamp to be\nthe final time of reception.\n\nIf there is just one recipient, set up its value in the $received_for variable\nfor use when we generate the Received: header.\n\nNote: the checking for too many Received: headers is handled by the delivery\ncode. */\n/*XXX eventually add excess Received: check for cutthrough case back when classifying them */\n\nif (received_header->text == NULL)\t/* Non-cutthrough case */\n  {\n  received_header_gen();\n\n  /* Set the value of message_body_size for the DATA ACL and for local_scan() */\n\n  message_body_size = (fstat(data_fd, &statbuf) == 0)?\n    statbuf.st_size - SPOOL_DATA_START_OFFSET : -1;\n\n  /* If an ACL from any RCPT commands set up any warning headers to add, do so\n  now, before running the DATA ACL. */\n\n  add_acl_headers(ACL_WHERE_RCPT, US\"MAIL or RCPT\");\n  }\nelse\n  message_body_size = (fstat(data_fd, &statbuf) == 0)?\n    statbuf.st_size - SPOOL_DATA_START_OFFSET : -1;\n\n/* If an ACL is specified for checking things at this stage of reception of a\nmessage, run it, unless all the recipients were removed by \"discard\" in earlier\nACLs. That is the only case in which recipients_count can be zero at this\nstage. Set deliver_datafile to point to the data file so that $message_body and\n$message_body_end can be extracted if needed. Allow $recipients in expansions.\n*/\n\ndeliver_datafile = data_fd;\nuser_msg = NULL;\n\nenable_dollar_recipients = TRUE;\n\nif (recipients_count == 0)\n  blackholed_by = recipients_discarded ? US\"MAIL ACL\" : US\"RCPT ACL\";\n\nelse\n  {\n  /* Handle interactive SMTP messages */\n\n  if (smtp_input && !smtp_batched_input)\n    {\n\n#ifndef DISABLE_DKIM\n    if (!dkim_disable_verify)\n      {\n      /* Finish verification */\n      dkim_exim_verify_finish();\n\n      /* Check if we must run the DKIM ACL */\n      if (acl_smtp_dkim && dkim_verify_signers && *dkim_verify_signers)\n        {\n        uschar * dkim_verify_signers_expanded =\n          expand_string(dkim_verify_signers);\n\tgstring * results = NULL;\n\tint signer_sep = 0;\n\tconst uschar * ptr;\n\tuschar * item;\n\tgstring * seen_items = NULL;\n\tint old_pool = store_pool;\n\n\tstore_pool = POOL_PERM;   /* Allow created variables to live to data ACL */\n\n        if (!(ptr = dkim_verify_signers_expanded))\n          log_write(0, LOG_MAIN|LOG_PANIC,\n            \"expansion of dkim_verify_signers option failed: %s\",\n            expand_string_message);\n\n\t/* Default to OK when no items are present */\n\trc = OK;\n\twhile ((item = string_nextinlist(&ptr, &signer_sep, NULL, 0)))\n\t  {\n\t  /* Prevent running ACL for an empty item */\n\t  if (!item || !*item) continue;\n\n\t  /* Only run ACL once for each domain or identity,\n\t  no matter how often it appears in the expanded list. */\n\t  if (seen_items)\n\t    {\n\t    uschar * seen_item;\n\t    const uschar * seen_items_list = string_from_gstring(seen_items);\n\t    int seen_sep = ':';\n\t    BOOL seen_this_item = FALSE;\n\n\t    while ((seen_item = string_nextinlist(&seen_items_list, &seen_sep,\n\t\t\t\t\t\t  NULL, 0)))\n\t      if (Ustrcmp(seen_item,item) == 0)\n\t\t{\n\t\tseen_this_item = TRUE;\n\t\tbreak;\n\t\t}\n\n\t    if (seen_this_item)\n\t      {\n\t      DEBUG(D_receive)\n\t\tdebug_printf(\"acl_smtp_dkim: skipping signer %s, \"\n\t\t  \"already seen\\n\", item);\n\t      continue;\n\t      }\n\n\t    seen_items = string_catn(seen_items, \":\", 1);\n\t    }\n\t  seen_items = string_cat(seen_items, item);\n\n\t  rc = dkim_exim_acl_run(item, &results, &user_msg, &log_msg);\n\t  if (rc != OK)\n\t    {\n\t    DEBUG(D_receive)\n\t      debug_printf(\"acl_smtp_dkim: acl_check returned %d on %s, \"\n\t\t\"skipping remaining items\\n\", rc, item);\n\t    cancel_cutthrough_connection(TRUE, US\"dkim acl not ok\");\n\t    break;\n\t    }\n\t  }\n\tdkim_verify_status = string_from_gstring(results);\n\tstore_pool = old_pool;\n\tadd_acl_headers(ACL_WHERE_DKIM, US\"DKIM\");\n\tif (rc == DISCARD)\n\t  {\n\t  recipients_count = 0;\n\t  blackholed_by = US\"DKIM ACL\";\n\t  if (log_msg)\n\t    blackhole_log_msg = string_sprintf(\": %s\", log_msg);\n\t  }\n\telse if (rc != OK)\n\t  {\n\t  Uunlink(spool_name);\n\t  if (smtp_handle_acl_fail(ACL_WHERE_DKIM, rc, user_msg, log_msg) != 0)\n\t    smtp_yield = FALSE;    /* No more messages after dropped connection */\n\t  smtp_reply = US\"\";       /* Indicate reply already sent */\n\t  message_id[0] = 0;       /* Indicate no message accepted */\n\t  goto TIDYUP;             /* Skip to end of function */\n\t  }\n        }\n      else\n\tdkim_exim_verify_log_all();\n      }\n#endif /* DISABLE_DKIM */\n\n#ifdef WITH_CONTENT_SCAN\n    if (recipients_count > 0 &&\n        acl_smtp_mime != NULL &&\n        !run_mime_acl(acl_smtp_mime, &smtp_yield, &smtp_reply, &blackholed_by))\n      goto TIDYUP;\n#endif /* WITH_CONTENT_SCAN */\n\n#ifdef EXPERIMENTAL_DMARC\n    dmarc_up = dmarc_store_data(from_header);\n#endif /* EXPERIMENTAL_DMARC */\n\n#ifndef DISABLE_PRDR\n    if (prdr_requested && recipients_count > 1 && acl_smtp_data_prdr)\n      {\n      unsigned int c;\n      int all_pass = OK;\n      int all_fail = FAIL;\n\n      smtp_printf(\"353 PRDR content analysis beginning\\r\\n\", TRUE);\n      /* Loop through recipients, responses must be in same order received */\n      for (c = 0; recipients_count > c; c++)\n        {\n\tuschar * addr= recipients_list[c].address;\n\tuschar * msg= US\"PRDR R=<%s> %s\";\n\tuschar * code;\n        DEBUG(D_receive)\n          debug_printf(\"PRDR processing recipient %s (%d of %d)\\n\",\n                       addr, c+1, recipients_count);\n        rc = acl_check(ACL_WHERE_PRDR, addr,\n                       acl_smtp_data_prdr, &user_msg, &log_msg);\n\n        /* If any recipient rejected content, indicate it in final message */\n        all_pass |= rc;\n        /* If all recipients rejected, indicate in final message */\n        all_fail &= rc;\n\n        switch (rc)\n          {\n          case OK: case DISCARD: code = US\"250\"; break;\n          case DEFER:            code = US\"450\"; break;\n          default:               code = US\"550\"; break;\n          }\n\tif (user_msg != NULL)\n\t  smtp_user_msg(code, user_msg);\n\telse\n\t  {\n\t  switch (rc)\n            {\n            case OK: case DISCARD:\n              msg = string_sprintf(CS msg, addr, \"acceptance\");        break;\n            case DEFER:\n              msg = string_sprintf(CS msg, addr, \"temporary refusal\"); break;\n            default:\n              msg = string_sprintf(CS msg, addr, \"refusal\");           break;\n            }\n          smtp_user_msg(code, msg);\n\t  }\n\tif (log_msg)       log_write(0, LOG_MAIN, \"PRDR %s %s\", addr, log_msg);\n\telse if (user_msg) log_write(0, LOG_MAIN, \"PRDR %s %s\", addr, user_msg);\n\telse               log_write(0, LOG_MAIN, \"%s\", CS msg);\n\n\tif (rc != OK) { receive_remove_recipient(addr); c--; }\n        }\n      /* Set up final message, used if data acl gives OK */\n      smtp_reply = string_sprintf(\"%s id=%s message %s\",\n\t\t       all_fail == FAIL ? US\"550\" : US\"250\",\n\t\t       message_id,\n                       all_fail == FAIL\n\t\t         ? US\"rejected for all recipients\"\n\t\t\t : all_pass == OK\n\t\t\t   ? US\"accepted\"\n\t\t\t   : US\"accepted for some recipients\");\n      if (recipients_count == 0)\n        {\n        message_id[0] = 0;       /* Indicate no message accepted */\n\tgoto TIDYUP;\n\t}\n      }\n    else\n      prdr_requested = FALSE;\n#endif /* !DISABLE_PRDR */\n\n    /* Check the recipients count again, as the MIME ACL might have changed\n    them. */\n\n    if (acl_smtp_data != NULL && recipients_count > 0)\n      {\n      rc = acl_check(ACL_WHERE_DATA, NULL, acl_smtp_data, &user_msg, &log_msg);\n      add_acl_headers(ACL_WHERE_DATA, US\"DATA\");\n      if (rc == DISCARD)\n        {\n        recipients_count = 0;\n        blackholed_by = US\"DATA ACL\";\n        if (log_msg)\n          blackhole_log_msg = string_sprintf(\": %s\", log_msg);\n\tcancel_cutthrough_connection(TRUE, US\"data acl discard\");\n        }\n      else if (rc != OK)\n        {\n        Uunlink(spool_name);\n\tcancel_cutthrough_connection(TRUE, US\"data acl not ok\");\n#ifdef WITH_CONTENT_SCAN\n        unspool_mbox();\n#endif\n#ifdef EXPERIMENTAL_DCC\n\tdcc_ok = 0;\n#endif\n        if (smtp_handle_acl_fail(ACL_WHERE_DATA, rc, user_msg, log_msg) != 0)\n          smtp_yield = FALSE;    /* No more messages after dropped connection */\n        smtp_reply = US\"\";       /* Indicate reply already sent */\n        message_id[0] = 0;       /* Indicate no message accepted */\n        goto TIDYUP;             /* Skip to end of function */\n        }\n      }\n    }\n\n  /* Handle non-SMTP and batch SMTP (i.e. non-interactive) messages. Note that\n  we cannot take different actions for permanent and temporary rejections. */\n\n  else\n    {\n\n#ifdef WITH_CONTENT_SCAN\n    if (acl_not_smtp_mime != NULL &&\n        !run_mime_acl(acl_not_smtp_mime, &smtp_yield, &smtp_reply,\n          &blackholed_by))\n      goto TIDYUP;\n#endif /* WITH_CONTENT_SCAN */\n\n    if (acl_not_smtp != NULL)\n      {\n      uschar *user_msg, *log_msg;\n      rc = acl_check(ACL_WHERE_NOTSMTP, NULL, acl_not_smtp, &user_msg, &log_msg);\n      if (rc == DISCARD)\n        {\n        recipients_count = 0;\n        blackholed_by = US\"non-SMTP ACL\";\n        if (log_msg != NULL)\n          blackhole_log_msg = string_sprintf(\": %s\", log_msg);\n        }\n      else if (rc != OK)\n        {\n        Uunlink(spool_name);\n#ifdef WITH_CONTENT_SCAN\n        unspool_mbox();\n#endif\n#ifdef EXPERIMENTAL_DCC\n\tdcc_ok = 0;\n#endif\n        /* The ACL can specify where rejections are to be logged, possibly\n        nowhere. The default is main and reject logs. */\n\n        if (log_reject_target != 0)\n          log_write(0, log_reject_target, \"F=<%s> rejected by non-SMTP ACL: %s\",\n            sender_address, log_msg);\n\n        if (user_msg == NULL) user_msg = US\"local configuration problem\";\n        if (smtp_batched_input)\n          {\n          moan_smtp_batch(NULL, \"%d %s\", 550, user_msg);\n          /* Does not return */\n          }\n        else\n          {\n          fseek(data_file, (long int)SPOOL_DATA_START_OFFSET, SEEK_SET);\n          give_local_error(ERRMESS_LOCAL_ACL, user_msg,\n            US\"message rejected by non-SMTP ACL: \", error_rc, data_file,\n              header_list);\n          /* Does not return */\n          }\n        }\n      add_acl_headers(ACL_WHERE_NOTSMTP, US\"non-SMTP\");\n      }\n    }\n\n  /* The applicable ACLs have been run */\n\n  if (deliver_freeze) frozen_by = US\"ACL\";     /* for later logging */\n  if (queue_only_policy) queued_by = US\"ACL\";\n  }\n\n#ifdef WITH_CONTENT_SCAN\nunspool_mbox();\n#endif\n\n#ifdef EXPERIMENTAL_DCC\ndcc_ok = 0;\n#endif\n\n\n/* The final check on the message is to run the scan_local() function. The\nversion supplied with Exim always accepts, but this is a hook for sysadmins to\nsupply their own checking code. The local_scan() function is run even when all\nthe recipients have been discarded. */\n/*XXS could we avoid this for the standard case, given that few people will use it? */\n\nlseek(data_fd, (long int)SPOOL_DATA_START_OFFSET, SEEK_SET);\n\n/* Arrange to catch crashes in local_scan(), so that the -D file gets\ndeleted, and the incident gets logged. */\n\nos_non_restarting_signal(SIGSEGV, local_scan_crash_handler);\nos_non_restarting_signal(SIGFPE, local_scan_crash_handler);\nos_non_restarting_signal(SIGILL, local_scan_crash_handler);\nos_non_restarting_signal(SIGBUS, local_scan_crash_handler);\n\nDEBUG(D_receive) debug_printf(\"calling local_scan(); timeout=%d\\n\",\n  local_scan_timeout);\nlocal_scan_data = NULL;\n\nos_non_restarting_signal(SIGALRM, local_scan_timeout_handler);\nif (local_scan_timeout > 0) alarm(local_scan_timeout);\nrc = local_scan(data_fd, &local_scan_data);\nalarm(0);\nos_non_restarting_signal(SIGALRM, sigalrm_handler);\n\nenable_dollar_recipients = FALSE;\n\nstore_pool = POOL_MAIN;   /* In case changed */\nDEBUG(D_receive) debug_printf(\"local_scan() returned %d %s\\n\", rc,\n  local_scan_data);\n\nos_non_restarting_signal(SIGSEGV, SIG_DFL);\nos_non_restarting_signal(SIGFPE, SIG_DFL);\nos_non_restarting_signal(SIGILL, SIG_DFL);\nos_non_restarting_signal(SIGBUS, SIG_DFL);\n\n/* The length check is paranoia against some runaway code, and also because\n(for a success return) lines in the spool file are read into big_buffer. */\n\nif (local_scan_data != NULL)\n  {\n  int len = Ustrlen(local_scan_data);\n  if (len > LOCAL_SCAN_MAX_RETURN) len = LOCAL_SCAN_MAX_RETURN;\n  local_scan_data = string_copyn(local_scan_data, len);\n  }\n\nif (rc == LOCAL_SCAN_ACCEPT_FREEZE)\n  {\n  if (!deliver_freeze)         /* ACL might have already frozen */\n    {\n    deliver_freeze = TRUE;\n    deliver_frozen_at = time(NULL);\n    frozen_by = US\"local_scan()\";\n    }\n  rc = LOCAL_SCAN_ACCEPT;\n  }\nelse if (rc == LOCAL_SCAN_ACCEPT_QUEUE)\n  {\n  if (!queue_only_policy)      /* ACL might have already queued */\n    {\n    queue_only_policy = TRUE;\n    queued_by = US\"local_scan()\";\n    }\n  rc = LOCAL_SCAN_ACCEPT;\n  }\n\n/* Message accepted: remove newlines in local_scan_data because otherwise\nthe spool file gets corrupted. Ensure that all recipients are qualified. */\n\nif (rc == LOCAL_SCAN_ACCEPT)\n  {\n  if (local_scan_data != NULL)\n    {\n    uschar *s;\n    for (s = local_scan_data; *s != 0; s++) if (*s == '\\n') *s = ' ';\n    }\n  for (i = 0; i < recipients_count; i++)\n    {\n    recipient_item *r = recipients_list + i;\n    r->address = rewrite_address_qualify(r->address, TRUE);\n    if (r->errors_to != NULL)\n      r->errors_to = rewrite_address_qualify(r->errors_to, TRUE);\n    }\n  if (recipients_count == 0 && blackholed_by == NULL)\n    blackholed_by = US\"local_scan\";\n  }\n\n/* Message rejected: newlines permitted in local_scan_data to generate\nmultiline SMTP responses. */\n\nelse\n  {\n  uschar *istemp = US\"\";\n  uschar *smtp_code;\n  gstring * g;\n\n  errmsg = local_scan_data;\n\n  Uunlink(spool_name);          /* Cancel this message */\n  switch(rc)\n    {\n    default:\n    log_write(0, LOG_MAIN, \"invalid return %d from local_scan(). Temporary \"\n      \"rejection given\", rc);\n    goto TEMPREJECT;\n\n    case LOCAL_SCAN_REJECT_NOLOGHDR:\n    BIT_CLEAR(log_selector, log_selector_size, Li_rejected_header);\n    /* Fall through */\n\n    case LOCAL_SCAN_REJECT:\n    smtp_code = US\"550\";\n    if (errmsg == NULL) errmsg =  US\"Administrative prohibition\";\n    break;\n\n    case LOCAL_SCAN_TEMPREJECT_NOLOGHDR:\n    BIT_CLEAR(log_selector, log_selector_size, Li_rejected_header);\n    /* Fall through */\n\n    case LOCAL_SCAN_TEMPREJECT:\n    TEMPREJECT:\n    smtp_code = US\"451\";\n    if (errmsg == NULL) errmsg = US\"Temporary local problem\";\n    istemp = US\"temporarily \";\n    break;\n    }\n\n  g = string_append(g, 2, US\"F=\",\n    sender_address[0] == 0 ? US\"<>\" : sender_address);\n  g = add_host_info_for_log(g);\n\n  log_write(0, LOG_MAIN|LOG_REJECT, \"%s %srejected by local_scan(): %.256s\",\n    string_from_gstring(g), istemp, string_printing(errmsg));\n\n  if (smtp_input)\n    {\n    if (!smtp_batched_input)\n      {\n      smtp_respond(smtp_code, 3, TRUE, errmsg);\n      message_id[0] = 0;            /* Indicate no message accepted */\n      smtp_reply = US\"\";            /* Indicate reply already sent */\n      goto TIDYUP;                  /* Skip to end of function */\n      }\n    else\n      {\n      moan_smtp_batch(NULL, \"%s %s\", smtp_code, errmsg);\n      /* Does not return */\n      }\n    }\n  else\n    {\n    fseek(data_file, (long int)SPOOL_DATA_START_OFFSET, SEEK_SET);\n    give_local_error(ERRMESS_LOCAL_SCAN, errmsg,\n      US\"message rejected by local scan code: \", error_rc, data_file,\n        header_list);\n    /* Does not return */\n    }\n  }\n\n/* Reset signal handlers to ignore signals that previously would have caused\nthe message to be abandoned. */\n\nsignal(SIGTERM, SIG_IGN);\nsignal(SIGINT, SIG_IGN);\n\n\n/* Ensure the first time flag is set in the newly-received message. */\n\ndeliver_firsttime = TRUE;\n\n#ifdef EXPERIMENTAL_BRIGHTMAIL\nif (bmi_run == 1)\n  { /* rewind data file */\n  lseek(data_fd, (long int)SPOOL_DATA_START_OFFSET, SEEK_SET);\n  bmi_verdicts = bmi_process_message(header_list, data_fd);\n  }\n#endif\n\n/* Update the timestamp in our Received: header to account for any time taken by\nan ACL or by local_scan(). The new time is the time that all reception\nprocessing is complete. */\n\ntimestamp = expand_string(US\"${tod_full}\");\ntslen = Ustrlen(timestamp);\n\nmemcpy(received_header->text + received_header->slen - tslen - 1,\n  timestamp, tslen);\n\n/* In MUA wrapper mode, ignore queueing actions set by ACL or local_scan() */\n\nif (mua_wrapper)\n  {\n  deliver_freeze = FALSE;\n  queue_only_policy = FALSE;\n  }\n\n/* Keep the data file open until we have written the header file, in order to\nhold onto the lock. In a -bh run, or if the message is to be blackholed, we\ndon't write the header file, and we unlink the data file. If writing the header\nfile fails, we have failed to accept this message. */\n\nif (host_checking || blackholed_by != NULL)\n  {\n  header_line *h;\n  Uunlink(spool_name);\n  msg_size = 0;                                  /* Compute size for log line */\n  for (h = header_list; h != NULL; h = h->next)\n    if (h->type != '*') msg_size += h->slen;\n  }\n\n/* Write the -H file */\n\nelse\n  if ((msg_size = spool_write_header(message_id, SW_RECEIVING, &errmsg)) < 0)\n    {\n    log_write(0, LOG_MAIN, \"Message abandoned: %s\", errmsg);\n    Uunlink(spool_name);           /* Lose the data file */\n\n    if (smtp_input)\n      {\n      smtp_reply = US\"451 Error in writing spool file\";\n      message_id[0] = 0;          /* Indicate no message accepted */\n      goto TIDYUP;\n      }\n    else\n      {\n      fseek(data_file, (long int)SPOOL_DATA_START_OFFSET, SEEK_SET);\n      give_local_error(ERRMESS_IOERR, errmsg, US\"\", error_rc, data_file,\n        header_list);\n      /* Does not return */\n      }\n    }\n\n\n/* The message has now been successfully received. */\n\nreceive_messagecount++;\n\n/* In SMTP sessions we may receive several in one connection. After each one,\nwe wait for the clock to tick at the level of message-id granularity. This is\nso that the combination of time+pid is unique, even on systems where the pid\ncan be re-used within our time interval. We can't shorten the interval without\nre-designing the message-id. See comments above where the message id is\ncreated. This is Something For The Future. */\n\nmessage_id_tv.tv_usec = (message_id_tv.tv_usec/id_resolution) * id_resolution;\nexim_wait_tick(&message_id_tv, id_resolution);\n\n/* Add data size to written header size. We do not count the initial file name\nthat is in the file, but we do add one extra for the notional blank line that\nprecedes the data. This total differs from message_size in that it include the\nadded Received: header and any other headers that got created locally. */\n\nfflush(data_file);\nfstat(data_fd, &statbuf);\n\nmsg_size += statbuf.st_size - SPOOL_DATA_START_OFFSET + 1;\n\n/* Generate a \"message received\" log entry. We do this by building up a dynamic\nstring as required. Since we commonly want to add two items at a time, use a\nmacro to simplify the coding. We log the arrival of a new message while the\nfile is still locked, just in case the machine is *really* fast, and delivers\nit first! Include any message id that is in the message - since the syntax of a\nmessage id is actually an addr-spec, we can use the parse routine to canonicalize\nit. */\n\ng = string_get(256);\n\ng = string_append(g, 2,\n  fake_response == FAIL ? US\"(= \" : US\"<= \",\n  sender_address[0] == 0 ? US\"<>\" : sender_address);\nif (message_reference)\n  g = string_append(g, 2, US\" R=\", message_reference);\n\ng = add_host_info_for_log(g);\n\n#ifdef SUPPORT_TLS\nif (LOGGING(tls_cipher) && tls_in.cipher)\n  g = string_append(g, 2, US\" X=\", tls_in.cipher);\nif (LOGGING(tls_certificate_verified) && tls_in.cipher)\n  g = string_append(g, 2, US\" CV=\", tls_in.certificate_verified ? \"yes\":\"no\");\nif (LOGGING(tls_peerdn) && tls_in.peerdn)\n  g = string_append(g, 3, US\" DN=\\\"\", string_printing(tls_in.peerdn), US\"\\\"\");\nif (LOGGING(tls_sni) && tls_in.sni)\n  g = string_append(g, 3, US\" SNI=\\\"\", string_printing(tls_in.sni), US\"\\\"\");\n#endif\n\nif (sender_host_authenticated)\n  {\n  g = string_append(g, 2, US\" A=\", sender_host_authenticated);\n  if (authenticated_id)\n    {\n    g = string_append(g, 2, US\":\", authenticated_id);\n    if (LOGGING(smtp_mailauth) && authenticated_sender)\n      g = string_append(g, 2, US\":\", authenticated_sender);\n    }\n  }\n\n#ifndef DISABLE_PRDR\nif (prdr_requested)\n  g = string_catn(g, US\" PRDR\", 5);\n#endif\n\n#ifdef SUPPORT_PROXY\nif (proxy_session && LOGGING(proxy))\n  g = string_append(g, 2, US\" PRX=\", proxy_local_address);\n#endif\n\nif (chunking_state > CHUNKING_OFFERED)\n  g = string_catn(g, US\" K\", 2);\n\nsprintf(CS big_buffer, \"%d\", msg_size);\ng = string_append(g, 2, US\" S=\", big_buffer);\n\n/* log 8BITMIME mode announced in MAIL_FROM\n   0 ... no BODY= used\n   7 ... 7BIT\n   8 ... 8BITMIME */\nif (LOGGING(8bitmime))\n  {\n  sprintf(CS big_buffer, \"%d\", body_8bitmime);\n  g = string_append(g, 2, US\" M8S=\", big_buffer);\n  }\n\nif (*queue_name)\n  g = string_append(g, 2, US\" Q=\", queue_name);\n\n/* If an addr-spec in a message-id contains a quoted string, it can contain\nany characters except \" \\ and CR and so in particular it can contain NL!\nTherefore, make sure we use a printing-characters only version for the log.\nAlso, allow for domain literals in the message id. */\n\nif (msgid_header)\n  {\n  uschar *old_id;\n  BOOL save_allow_domain_literals = allow_domain_literals;\n  allow_domain_literals = TRUE;\n  old_id = parse_extract_address(Ustrchr(msgid_header->text, ':') + 1,\n    &errmsg, &start, &end, &domain, FALSE);\n  allow_domain_literals = save_allow_domain_literals;\n  if (old_id != NULL)\n    g = string_append(g, 2, US\" id=\", string_printing(old_id));\n  }\n\n/* If subject logging is turned on, create suitable printing-character\ntext. By expanding $h_subject: we make use of the MIME decoding. */\n\nif (LOGGING(subject) && subject_header != NULL)\n  {\n  int i;\n  uschar *p = big_buffer;\n  uschar *ss = expand_string(US\"$h_subject:\");\n\n  /* Backslash-quote any double quotes or backslashes so as to make a\n  a C-like string, and turn any non-printers into escape sequences. */\n\n  *p++ = '\\\"';\n  if (*ss != 0) for (i = 0; i < 100 && ss[i] != 0; i++)\n    {\n    if (ss[i] == '\\\"' || ss[i] == '\\\\') *p++ = '\\\\';\n    *p++ = ss[i];\n    }\n  *p++ = '\\\"';\n  *p = 0;\n  g = string_append(g, 2, US\" T=\", string_printing(big_buffer));\n  }\n\n/* Terminate the string: string_cat() and string_append() leave room, but do\nnot put the zero in. */\n\n(void) string_from_gstring(g);\n\n/* Create a message log file if message logs are being used and this message is\nnot blackholed. Write the reception stuff to it. We used to leave message log\ncreation until the first delivery, but this has proved confusing for some\npeople. */\n\nif (message_logs && !blackholed_by)\n  {\n  int fd;\n\n  spool_name = spool_fname(US\"msglog\", message_subdir, message_id, US\"\");\n  \n  if (  (fd = Uopen(spool_name, O_WRONLY|O_APPEND|O_CREAT, SPOOL_MODE)) < 0\n     && errno == ENOENT\n     )\n    {\n    (void)directory_make(spool_directory,\n\t\t\tspool_sname(US\"msglog\", message_subdir),\n\t\t\tMSGLOG_DIRECTORY_MODE, TRUE);\n    fd = Uopen(spool_name, O_WRONLY|O_APPEND|O_CREAT, SPOOL_MODE);\n    }\n\n  if (fd < 0)\n    log_write(0, LOG_MAIN|LOG_PANIC, \"Couldn't open message log %s: %s\",\n      spool_name, strerror(errno));\n  else\n    {\n    FILE *message_log = fdopen(fd, \"a\");\n    if (message_log == NULL)\n      {\n      log_write(0, LOG_MAIN|LOG_PANIC, \"Couldn't fdopen message log %s: %s\",\n        spool_name, strerror(errno));\n      (void)close(fd);\n      }\n    else\n      {\n      uschar *now = tod_stamp(tod_log);\n      fprintf(message_log, \"%s Received from %s\\n\", now, g->s+3);\n      if (deliver_freeze) fprintf(message_log, \"%s frozen by %s\\n\", now,\n        frozen_by);\n      if (queue_only_policy) fprintf(message_log,\n        \"%s no immediate delivery: queued%s%s by %s\\n\", now,\n        *queue_name ? \" in \" : \"\", *queue_name ? CS queue_name : \"\",\n\tqueued_by);\n      (void)fclose(message_log);\n      }\n    }\n  }\n\n/* Everything has now been done for a successful message except logging its\narrival, and outputting an SMTP response. While writing to the log, set a flag\nto cause a call to receive_bomb_out() if the log cannot be opened. */\n\nreceive_call_bombout = TRUE;\n\n/* Before sending an SMTP response in a TCP/IP session, we check to see if the\nconnection has gone away. This can only be done if there is no unconsumed input\nwaiting in the local input buffer. We can test for this by calling\nreceive_smtp_buffered(). RFC 2920 (pipelining) explicitly allows for additional\ninput to be sent following the final dot, so the presence of following input is\nnot an error.\n\nIf the connection is still present, but there is no unread input for the\nsocket, the result of a select() call will be zero. If, however, the connection\nhas gone away, or if there is pending input, the result of select() will be\nnon-zero. The two cases can be distinguished by trying to read the next input\ncharacter. If we succeed, we can unread it so that it remains in the local\nbuffer for handling later. If not, the connection has been lost.\n\nOf course, since TCP/IP is asynchronous, there is always a chance that the\nconnection will vanish between the time of this test and the sending of the\nresponse, but the chance of this happening should be small. */\n\nif (smtp_input && sender_host_address != NULL && !sender_host_notsocket &&\n    !receive_smtp_buffered())\n  {\n  struct timeval tv;\n  fd_set select_check;\n  FD_ZERO(&select_check);\n  FD_SET(fileno(smtp_in), &select_check);\n  tv.tv_sec = 0;\n  tv.tv_usec = 0;\n\n  if (select(fileno(smtp_in) + 1, &select_check, NULL, NULL, &tv) != 0)\n    {\n    int c = (receive_getc)(GETC_BUFFER_UNLIMITED);\n    if (c != EOF) (receive_ungetc)(c); else\n      {\n      smtp_notquit_exit(US\"connection-lost\", NULL, NULL);\n      smtp_reply = US\"\";    /* No attempt to send a response */\n      smtp_yield = FALSE;   /* Nothing more on this connection */\n\n      /* Re-use the log line workspace */\n\n      g->ptr = 0;\n      g = string_cat(g, US\"SMTP connection lost after final dot\");\n      g = add_host_info_for_log(g);\n      log_write(0, LOG_MAIN, \"%s\", string_from_gstring(g));\n\n      /* Delete the files for this aborted message. */\n\n      Uunlink(spool_fname(US\"input\", message_subdir, message_id, US\"-D\"));\n      Uunlink(spool_fname(US\"input\", message_subdir, message_id, US\"-H\"));\n      Uunlink(spool_fname(US\"msglog\", message_subdir, message_id, US\"\"));\n\n      goto TIDYUP;\n      }\n    }\n  }\n\n/* The connection has not gone away; we really are going to take responsibility\nfor this message. */\n\n/* Cutthrough - had sender last-dot; assume we've sent (or bufferred) all\n   data onward by now.\n\n   Send dot onward.  If accepted, wipe the spooled files, log as delivered and accept\n   the sender's dot (below).\n   If rejected: copy response to sender, wipe the spooled files, log appropriately.\n   If temp-reject: normally accept to sender, keep the spooled file - unless defer=pass\n   in which case pass temp-reject back to initiator and dump the files.\n\n   Having the normal spool files lets us do data-filtering, and store/forward on temp-reject.\n\n   XXX We do not handle queue-only, freezing, or blackholes.\n*/\nif(cutthrough.fd >= 0 && cutthrough.delivery)\n  {\n  uschar * msg = cutthrough_finaldot();\t/* Ask the target system to accept the message */\n\t\t\t\t\t/* Logging was done in finaldot() */\n  switch(msg[0])\n    {\n    case '2':\t/* Accept. Do the same to the source; dump any spoolfiles.   */\n      cutthrough_done = ACCEPTED;\n      break;\t\t\t\t\t/* message_id needed for SMTP accept below */\n\n    case '4':\t/* Temp-reject. Keep spoolfiles and accept, unless defer-pass mode.\n      \t\t... for which, pass back the exact error */\n      if (cutthrough.defer_pass) smtp_reply = string_copy_malloc(msg);\n      /*FALLTRHOUGH*/\n\n    default:\t/* Unknown response, or error.  Treat as temp-reject.         */\n      cutthrough_done = TMP_REJ;\t\t/* Avoid the usual immediate delivery attempt */\n      break;\t\t\t\t\t/* message_id needed for SMTP accept below */\n\n    case '5':\t/* Perm-reject.  Do the same to the source.  Dump any spoolfiles */\n      smtp_reply = string_copy_malloc(msg);\t\t/* Pass on the exact error */\n      cutthrough_done = PERM_REJ;\n      break;\n    }\n  }\n\n#ifndef DISABLE_PRDR\nif(!smtp_reply || prdr_requested)\n#else\nif(!smtp_reply)\n#endif\n  {\n  log_write(0, LOG_MAIN |\n    (LOGGING(received_recipients)? LOG_RECIPIENTS : 0) |\n    (LOGGING(received_sender)? LOG_SENDER : 0),\n    \"%s\", g->s);\n\n  /* Log any control actions taken by an ACL or local_scan(). */\n\n  if (deliver_freeze) log_write(0, LOG_MAIN, \"frozen by %s\", frozen_by);\n  if (queue_only_policy) log_write(L_delay_delivery, LOG_MAIN,\n    \"no immediate delivery: queued%s%s by %s\",\n    *queue_name ? \" in \" : \"\", *queue_name ? CS queue_name : \"\",       \n    queued_by);\n  }\nreceive_call_bombout = FALSE;\n\nstore_reset(g);   /* The store for the main log message can be reused */\n\n/* If the message is frozen, and freeze_tell is set, do the telling. */\n\nif (deliver_freeze && freeze_tell != NULL && freeze_tell[0] != 0)\n  {\n  moan_tell_someone(freeze_tell, NULL, US\"Message frozen on arrival\",\n    \"Message %s was frozen on arrival by %s.\\nThe sender is <%s>.\\n\",\n    message_id, frozen_by, sender_address);\n  }\n\n\n/* Either a message has been successfully received and written to the two spool\nfiles, or an error in writing the spool has occurred for an SMTP message, or\nan SMTP message has been rejected for policy reasons. (For a non-SMTP message\nwe will have already given up because there's no point in carrying on!) In\neither event, we must now close (and thereby unlock) the data file. In the\nsuccessful case, this leaves the message on the spool, ready for delivery. In\nthe error case, the spool file will be deleted. Then tidy up store, interact\nwith an SMTP call if necessary, and return.\n\nA fflush() was done earlier in the expectation that any write errors on the\ndata file will be flushed(!) out thereby. Nevertheless, it is theoretically\npossible for fclose() to fail - but what to do? What has happened to the lock\nif this happens? */\n\n\nTIDYUP:\nprocess_info[process_info_len] = 0;                /* Remove message id */\nif (data_file != NULL) (void)fclose(data_file);    /* Frees the lock */\n\n/* Now reset signal handlers to their defaults */\n\nsignal(SIGTERM, SIG_DFL);\nsignal(SIGINT, SIG_DFL);\n\n/* Tell an SMTP caller the state of play, and arrange to return the SMTP return\nvalue, which defaults TRUE - meaning there may be more incoming messages from\nthis connection. For non-SMTP callers (where there is only ever one message),\nthe default is FALSE. */\n\nif (smtp_input)\n  {\n  yield = smtp_yield;\n\n  /* Handle interactive SMTP callers. After several kinds of error, smtp_reply\n  is set to the response that should be sent. When it is NULL, we generate\n  default responses. After an ACL error or local_scan() error, the response has\n  already been sent, and smtp_reply is an empty string to indicate this. */\n\n  if (!smtp_batched_input)\n    {\n    if (!smtp_reply)\n      {\n      if (fake_response != OK)\n        smtp_respond(fake_response == DEFER ? US\"450\" : US\"550\",\n\t  3, TRUE, fake_response_text);\n\n      /* An OK response is required; use \"message\" text if present. */\n\n      else if (user_msg)\n        {\n        uschar *code = US\"250\";\n        int len = 3;\n        smtp_message_code(&code, &len, &user_msg, NULL, TRUE);\n        smtp_respond(code, len, TRUE, user_msg);\n        }\n\n      /* Default OK response */\n\n      else if (chunking_state > CHUNKING_OFFERED)\n\t{\n        smtp_printf(\"250- %u byte chunk, total %d\\r\\n250 OK id=%s\\r\\n\", FALSE,\n\t    chunking_datasize, message_size+message_linecount, message_id);\n\tchunking_state = CHUNKING_OFFERED;\n\t}\n      else\n        smtp_printf(\"250 OK id=%s\\r\\n\", FALSE, message_id);\n\n      if (host_checking)\n        fprintf(stdout,\n          \"\\n**** SMTP testing: that is not a real message id!\\n\\n\");\n      }\n\n    /* smtp_reply is set non-empty */\n\n    else if (smtp_reply[0] != 0)\n      if (fake_response != OK && (smtp_reply[0] == '2'))\n        smtp_respond((fake_response == DEFER)? US\"450\" : US\"550\", 3, TRUE,\n          fake_response_text);\n      else\n        smtp_printf(\"%.1024s\\r\\n\", FALSE, smtp_reply);\n\n    switch (cutthrough_done)\n      {\n      case ACCEPTED:\n\tlog_write(0, LOG_MAIN, \"Completed\");/* Delivery was done */\n      case PERM_REJ:\n\t\t\t\t\t\t\t /* Delete spool files */\n\tUunlink(spool_fname(US\"input\", message_subdir, message_id, US\"-D\"));\n\tUunlink(spool_fname(US\"input\", message_subdir, message_id, US\"-H\"));\n\tUunlink(spool_fname(US\"msglog\", message_subdir, message_id, US\"\"));\n\tbreak;\n\n      case TMP_REJ:\n\tif (cutthrough.defer_pass)\n\t  {\n\t  Uunlink(spool_fname(US\"input\", message_subdir, message_id, US\"-D\"));\n\t  Uunlink(spool_fname(US\"input\", message_subdir, message_id, US\"-H\"));\n\t  Uunlink(spool_fname(US\"msglog\", message_subdir, message_id, US\"\"));\n\t  }\n      default:\n\tbreak;\n      }\n    if (cutthrough_done != NOT_TRIED)\n      {\n      message_id[0] = 0;\t  /* Prevent a delivery from starting */\n      cutthrough.delivery = cutthrough.callout_hold_only = FALSE;\n      cutthrough.defer_pass = FALSE;\n      }\n    }\n\n  /* For batched SMTP, generate an error message on failure, and do\n  nothing on success. The function moan_smtp_batch() does not return -\n  it exits from the program with a non-zero return code. */\n\n  else if (smtp_reply)\n    moan_smtp_batch(NULL, \"%s\", smtp_reply);\n  }\n\n\n/* If blackholing, we can immediately log this message's sad fate. The data\nfile has already been unlinked, and the header file was never written to disk.\nWe must now indicate that nothing was received, to prevent a delivery from\nstarting. */\n\nif (blackholed_by)\n  {\n  const uschar *detail = local_scan_data\n    ? string_printing(local_scan_data)\n    : string_sprintf(\"(%s discarded recipients)\", blackholed_by);\n  log_write(0, LOG_MAIN, \"=> blackhole %s%s\", detail, blackhole_log_msg);\n  log_write(0, LOG_MAIN, \"Completed\");\n  message_id[0] = 0;\n  }\n\n/* Reset headers so that logging of rejects for a subsequent message doesn't\ninclude them. It is also important to set header_last = NULL before exiting\nfrom this function, as this prevents certain rewrites that might happen during\nsubsequent verifying (of another incoming message) from trying to add headers\nwhen they shouldn't. */\n\nheader_list = header_last = NULL;\n\nreturn yield;  /* TRUE if more messages (SMTP only) */\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147303,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static Image *ReadDCMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define ThrowDCMException(exception,message) \\\n{ \\\n  RelinquishDCMMemory(&info,&map,stream_info,stack,data); \\\n  ThrowReaderException((exception),(message)); \\\n}\n\n  char\n    explicit_vr[MagickPathExtent],\n    implicit_vr[MagickPathExtent],\n    magick[MagickPathExtent],\n    photometric[MagickPathExtent];\n\n  DCMInfo\n    info,\n    *info_copy;\n\n  DCMMap\n    map;\n\n  DCMStreamInfo\n    *stream_info;\n\n  Image\n    *image;\n\n  int\n    datum;\n\n  LinkedListInfo\n    *stack;\n\n  MagickBooleanType\n    explicit_file,\n    explicit_retry,\n    use_explicit;\n\n  MagickOffsetType\n    blob_size,\n    offset;\n\n  unsigned char\n    *p;\n\n  ssize_t\n    i;\n\n  size_t\n    colors,\n    length,\n    number_scenes,\n    quantum,\n    status;\n\n  ssize_t\n    count,\n    scene,\n    sequence_depth;\n\n  unsigned char\n    *data;\n\n  unsigned short\n    group,\n    element;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  image->depth=8UL;\n  image->endian=LSBEndian;\n  /*\n    Read DCM preamble.\n  */\n  (void) memset(&info,0,sizeof(info));\n  (void) memset(&map,0,sizeof(map));\n  data=(unsigned char *) NULL;\n  stream_info=(DCMStreamInfo *) AcquireMagickMemory(sizeof(*stream_info));\n  sequence_depth=0;\n  stack=NewLinkedList(256);\n  if (stream_info == (DCMStreamInfo *) NULL)\n    ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\")\n  (void) memset(stream_info,0,sizeof(*stream_info));\n  count=ReadBlob(image,128,(unsigned char *) magick);\n  if (count != 128)\n    ThrowDCMException(CorruptImageError,\"ImproperImageHeader\")\n  count=ReadBlob(image,4,(unsigned char *) magick);\n  if ((count != 4) || (LocaleNCompare(magick,\"DICM\",4) != 0))\n    {\n      offset=SeekBlob(image,0L,SEEK_SET);\n      if (offset < 0)\n        ThrowDCMException(CorruptImageError,\"ImproperImageHeader\")\n    }\n  /*\n    Read DCM Medical image.\n  */\n  (void) CopyMagickString(photometric,\"MONOCHROME1 \",MagickPathExtent);\n  info.bits_allocated=8;\n  info.bytes_per_pixel=1;\n  info.depth=8;\n  info.mask=0xffff;\n  info.max_value=255UL;\n  info.samples_per_pixel=1;\n  info.signed_data=(~0UL);\n  info.rescale_slope=1.0;\n  element=0;\n  explicit_vr[2]='\\0';\n  explicit_file=MagickFalse;\n  colors=0;\n  number_scenes=1;\n  use_explicit=MagickFalse;\n  explicit_retry=MagickFalse;\n  blob_size=(MagickOffsetType) GetBlobSize(image);\n  while (TellBlob(image) < blob_size)\n  {\n    for (group=0; (group != 0x7FE0) || (element != 0x0010) ; )\n    {\n      /*\n        Read a group.\n      */\n      image->offset=(ssize_t) TellBlob(image);\n      group=ReadBlobLSBShort(image);\n      element=ReadBlobLSBShort(image);\n      if ((group == 0xfffc) && (element == 0xfffc))\n        break;\n      if ((group != 0x0002) && (image->endian == MSBEndian))\n        {\n          group=(unsigned short) ((group << 8) | ((group >> 8) & 0xFF));\n          element=(unsigned short) ((element << 8) | ((element >> 8) & 0xFF));\n        }\n      quantum=0;\n      /*\n        Find corresponding VR for this group and element.\n      */\n      for (i=0; dicom_info[i].group < 0xffff; i++)\n        if ((group == dicom_info[i].group) &&\n            (element == dicom_info[i].element))\n          break;\n      (void) CopyMagickString(implicit_vr,dicom_info[i].vr,MagickPathExtent);\n      count=ReadBlob(image,2,(unsigned char *) explicit_vr);\n      if (count != 2)\n        ThrowDCMException(CorruptImageError,\"ImproperImageHeader\")\n      /*\n        Check for \"explicitness\", but meta-file headers always explicit.\n      */\n      if ((explicit_file == MagickFalse) && (group != 0x0002))\n        explicit_file=(isupper((int) ((unsigned char) *explicit_vr)) != 0) &&\n          (isupper((int) ((unsigned char) *(explicit_vr+1))) != 0) ?\n          MagickTrue : MagickFalse;\n      use_explicit=((group == 0x0002) && (explicit_retry == MagickFalse)) ||\n        (explicit_file != MagickFalse) ? MagickTrue : MagickFalse;\n      if ((use_explicit != MagickFalse) && (strncmp(implicit_vr,\"xs\",2) == 0))\n        (void) CopyMagickString(implicit_vr,explicit_vr,MagickPathExtent);\n      if ((use_explicit == MagickFalse) || (strncmp(implicit_vr,\"!!\",2) == 0))\n        {\n          offset=SeekBlob(image,(MagickOffsetType) -2,SEEK_CUR);\n          if (offset < 0)\n            ThrowDCMException(CorruptImageError,\"ImproperImageHeader\")\n          quantum=4;\n        }\n      else\n        {\n          /*\n            Assume explicit type.\n          */\n          quantum=2;\n          if ((strcmp(explicit_vr,\"OB\") == 0) ||\n              (strcmp(explicit_vr,\"OW\") == 0) ||\n              (strcmp(explicit_vr,\"OF\") == 0) ||\n              (strcmp(explicit_vr,\"SQ\") == 0) ||\n              (strcmp(explicit_vr,\"UN\") == 0) ||\n              (strcmp(explicit_vr,\"UT\") == 0))\n            {\n              (void) ReadBlobLSBShort(image);\n              quantum=4;\n            }\n        }\n      if ((group == 0xFFFE) && (element == 0xE0DD))\n        {\n          /*\n            If we're exiting a sequence, restore the previous image parameters,\n            effectively undoing any parameter changes that happened inside the\n            sequence.\n          */\n          sequence_depth--;\n          info_copy=(DCMInfo *) RemoveLastElementFromLinkedList(stack);\n          if (info_copy == (DCMInfo *)NULL)\n            {\n              /*\n                The sequence's entry and exit points don't line up (tried to\n                exit one more sequence than we entered).\n              */\n              ThrowDCMException(CorruptImageError,\"ImproperImageHeader\")\n            }\n          if (info.scale != (Quantum *) NULL)\n            info.scale=(Quantum *) RelinquishMagickMemory(info.scale);\n          (void) memcpy(&info,info_copy,sizeof(info));\n          info_copy=(DCMInfo *) RelinquishMagickMemory(info_copy);\n        }\n      if (strcmp(explicit_vr,\"SQ\") == 0)\n        {\n          /*\n            If we're entering a sequence, push the current image parameters\n            onto the stack, so we can restore them at the end of the sequence.\n          */\n          info_copy=(DCMInfo *) AcquireMagickMemory(sizeof(info));\n          if (info_copy == (DCMInfo *) NULL)\n            ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\")\n          (void) memcpy(info_copy,&info,sizeof(info));\n          info_copy->scale=(Quantum *) AcquireQuantumMemory(\n            info_copy->scale_size,sizeof(*info_copy->scale));\n          if (info_copy->scale == (Quantum *) NULL)\n            {\n              info_copy=(DCMInfo *) RelinquishMagickMemory(info_copy);\n              ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\")\n            }\n          (void) memcpy(info_copy->scale,info.scale,info_copy->scale_size*\n            sizeof(*info_copy->scale));\n          AppendValueToLinkedList(stack,info_copy);\n          sequence_depth++;\n        }\n      datum=0;\n      if (quantum == 4)\n        {\n          if (group == 0x0002)\n            datum=ReadBlobLSBSignedLong(image);\n          else\n            datum=ReadBlobSignedLong(image);\n        }\n      else\n        if (quantum == 2)\n          {\n            if (group == 0x0002)\n              datum=ReadBlobLSBSignedShort(image);\n            else\n              datum=ReadBlobSignedShort(image);\n          }\n      quantum=0;\n      length=1;\n      if (datum != 0)\n        {\n          if ((strncmp(implicit_vr,\"OW\",2) == 0) ||\n              (strncmp(implicit_vr,\"SS\",2) == 0) ||\n              (strncmp(implicit_vr,\"US\",2) == 0))\n            quantum=2;\n          else\n            if ((strncmp(implicit_vr,\"FL\",2) == 0) ||\n                (strncmp(implicit_vr,\"OF\",2) == 0) ||\n                (strncmp(implicit_vr,\"SL\",2) == 0) ||\n                (strncmp(implicit_vr,\"UL\",2) == 0))\n              quantum=4;\n            else\n              if (strncmp(implicit_vr,\"FD\",2) == 0)\n                quantum=8;\n              else\n                quantum=1;\n          if (datum != ~0)\n            length=(size_t) datum/quantum;\n          else\n            {\n              /*\n                Sequence and item of undefined length.\n              */\n              quantum=0;\n              length=0;\n            }\n        }\n      if (image_info->verbose != MagickFalse)\n        {\n          /*\n            Display Dicom info.\n          */\n          if (use_explicit == MagickFalse)\n            explicit_vr[0]='\\0';\n          for (i=0; dicom_info[i].description != (char *) NULL; i++)\n            if ((group == dicom_info[i].group) &&\n                (element == dicom_info[i].element))\n              break;\n          (void) FormatLocaleFile(stdout,\n            \"0x%04lX %4ld S%ld %s-%s (0x%04lx,0x%04lx)\",\n            (unsigned long) image->offset,(long) length,(long) sequence_depth,\n            implicit_vr,explicit_vr,(unsigned long) group,\n            (unsigned long) element);\n          if (dicom_info[i].description != (char *) NULL)\n            (void) FormatLocaleFile(stdout,\" %s\",dicom_info[i].description);\n          (void) FormatLocaleFile(stdout,\": \");\n        }\n      if ((group == 0x7FE0) && (element == 0x0010))\n        {\n          if (image_info->verbose != MagickFalse)\n            (void) FormatLocaleFile(stdout,\"\\n\");\n          break;\n        }\n      /*\n        Allocate space and read an array.\n      */\n      data=(unsigned char *) NULL;\n      if ((length == 1) && (quantum == 1))\n        datum=ReadBlobByte(image);\n      else\n        if ((length == 1) && (quantum == 2))\n          {\n            if (group == 0x0002)\n              datum=ReadBlobLSBSignedShort(image);\n            else\n              datum=ReadBlobSignedShort(image);\n          }\n        else\n          if ((length == 1) && (quantum == 4))\n            {\n              if (group == 0x0002)\n                datum=ReadBlobLSBSignedLong(image);\n              else\n                datum=ReadBlobSignedLong(image);\n            }\n          else\n            if ((quantum != 0) && (length != 0))\n              {\n                if (length > (size_t) GetBlobSize(image))\n                  ThrowDCMException(CorruptImageError,\n                    \"InsufficientImageDataInFile\")\n                if (~length >= 1)\n                  data=(unsigned char *) AcquireQuantumMemory(length+1,quantum*\n                    sizeof(*data));\n                if (data == (unsigned char *) NULL)\n                  ThrowDCMException(ResourceLimitError,\n                    \"MemoryAllocationFailed\")\n                count=ReadBlob(image,(size_t) quantum*length,data);\n                if (count != (ssize_t) (quantum*length))\n                  {\n                    if (image_info->verbose != MagickFalse)\n                      (void) FormatLocaleFile(stdout,\"count=%d quantum=%d \"\n                        \"length=%d group=%d\\n\",(int) count,(int) quantum,(int)\n                        length,(int) group);\n                     ThrowDCMException(CorruptImageError,\n                       \"InsufficientImageDataInFile\")\n                  }\n                data[length*quantum]='\\0';\n              }\n      if ((((unsigned int) group << 16) | element) == 0xFFFEE0DD)\n        {\n          if (data != (unsigned char *) NULL)\n            data=(unsigned char *) RelinquishMagickMemory(data);\n          continue;\n        }\n      switch (group)\n      {\n        case 0x0002:\n        {\n          switch (element)\n          {\n            case 0x0010:\n            {\n              char\n                transfer_syntax[MagickPathExtent];\n\n              /*\n                Transfer Syntax.\n              */\n              if ((datum == 0) && (explicit_retry == MagickFalse))\n                {\n                  explicit_retry=MagickTrue;\n                  (void) SeekBlob(image,(MagickOffsetType) 0,SEEK_SET);\n                  group=0;\n                  element=0;\n                  if (image_info->verbose != MagickFalse)\n                    (void) FormatLocaleFile(stdout,\n                      \"Corrupted image - trying explicit format\\n\");\n                  break;\n                }\n              *transfer_syntax='\\0';\n              if (data != (unsigned char *) NULL)\n                (void) CopyMagickString(transfer_syntax,(char *) data,\n                  MagickPathExtent);\n              if (image_info->verbose != MagickFalse)\n                (void) FormatLocaleFile(stdout,\"transfer_syntax=%s\\n\",\n                  (const char *) transfer_syntax);\n              if (strncmp(transfer_syntax,\"1.2.840.10008.1.2\",17) == 0)\n                {\n                  int\n                    subtype,\n                    type;\n\n                  type=1;\n                  subtype=0;\n                  if (strlen(transfer_syntax) > 17)\n                    {\n                      count=(ssize_t) sscanf(transfer_syntax+17,\".%d.%d\",&type,\n                        &subtype);\n                      if (count < 1)\n                        ThrowDCMException(CorruptImageError,\n                          \"ImproperImageHeader\")\n                    }\n                  switch (type)\n                  {\n                    case 1:\n                    {\n                      image->endian=LSBEndian;\n                      break;\n                    }\n                    case 2:\n                    {\n                      image->endian=MSBEndian;\n                      break;\n                    }\n                    case 4:\n                    {\n                      if ((subtype >= 80) && (subtype <= 81))\n                        image->compression=JPEGCompression;\n                      else\n                        if ((subtype >= 90) && (subtype <= 93))\n                          image->compression=JPEG2000Compression;\n                        else\n                          image->compression=JPEGCompression;\n                      break;\n                    }\n                    case 5:\n                    {\n                      image->compression=RLECompression;\n                      break;\n                    }\n                  }\n                }\n              break;\n            }\n            default:\n              break;\n          }\n          break;\n        }\n        case 0x0028:\n        {\n          switch (element)\n          {\n            case 0x0002:\n            {\n              /*\n                Samples per pixel.\n              */\n              info.samples_per_pixel=(size_t) datum;\n              if ((info.samples_per_pixel == 0) || (info.samples_per_pixel > 4))\n                ThrowDCMException(CorruptImageError,\"ImproperImageHeader\")\n              break;\n            }\n            case 0x0004:\n            {\n              /*\n                Photometric interpretation.\n              */\n              if (data == (unsigned char *) NULL)\n                break;\n              for (i=0; i < (ssize_t) MagickMin(length,MagickPathExtent-1); i++)\n                photometric[i]=(char) data[i];\n              photometric[i]='\\0';\n              info.polarity=LocaleCompare(photometric,\"MONOCHROME1 \") == 0 ?\n                MagickTrue : MagickFalse;\n              break;\n            }\n            case 0x0006:\n            {\n              /*\n                Planar configuration.\n              */\n              if (datum == 1)\n                image->interlace=PlaneInterlace;\n              break;\n            }\n            case 0x0008:\n            {\n              /*\n                Number of frames.\n              */\n              if (data == (unsigned char *) NULL)\n                break;\n              number_scenes=StringToUnsignedLong((char *) data);\n              break;\n            }\n            case 0x0010:\n            {\n              /*\n                Image rows.\n              */\n              info.height=(size_t) datum;\n              break;\n            }\n            case 0x0011:\n            {\n              /*\n                Image columns.\n              */\n              info.width=(size_t) datum;\n              break;\n            }\n            case 0x0100:\n            {\n              /*\n                Bits allocated.\n              */\n              info.bits_allocated=(size_t) datum;\n              info.bytes_per_pixel=1;\n              if (datum > 8)\n                info.bytes_per_pixel=2;\n              info.depth=info.bits_allocated;\n              if ((info.depth == 0) || (info.depth > 32))\n                ThrowDCMException(CorruptImageError,\"ImproperImageHeader\")\n              info.max_value=(1UL << info.bits_allocated)-1;\n              image->depth=info.depth;\n              break;\n            }\n            case 0x0101:\n            {\n              /*\n                Bits stored.\n              */\n              info.significant_bits=(size_t) datum;\n              info.bytes_per_pixel=1;\n              if (info.significant_bits > 8)\n                info.bytes_per_pixel=2;\n              info.depth=info.significant_bits;\n              if ((info.depth == 0) || (info.depth > 16))\n                ThrowDCMException(CorruptImageError,\"ImproperImageHeader\")\n              info.max_value=(1UL << info.significant_bits)-1;\n              info.mask=(size_t) GetQuantumRange(info.significant_bits);\n              image->depth=info.depth;\n              break;\n            }\n            case 0x0102:\n            {\n              /*\n                High bit.\n              */\n              break;\n            }\n            case 0x0103:\n            {\n              /*\n                Pixel representation.\n              */\n              info.signed_data=(size_t) datum;\n              break;\n            }\n            case 0x1050:\n            {\n              /*\n                Visible pixel range: center.\n              */\n              if (data != (unsigned char *) NULL)\n                info.window_center=StringToDouble((char *) data,(char **) NULL);\n              break;\n            }\n            case 0x1051:\n            {\n              /*\n                Visible pixel range: width.\n              */\n              if (data != (unsigned char *) NULL)\n                info.window_width=StringToDouble((char *) data,(char **) NULL);\n              break;\n            }\n            case 0x1052:\n            {\n              /*\n                Rescale intercept\n              */\n              if (data != (unsigned char *) NULL)\n                info.rescale_intercept=StringToDouble((char *) data,\n                  (char **) NULL);\n              break;\n            }\n            case 0x1053:\n            {\n              /*\n                Rescale slope\n              */\n              if (data != (unsigned char *) NULL)\n                info.rescale_slope=StringToDouble((char *) data,(char **) NULL);\n              break;\n            }\n            case 0x1200:\n            case 0x3006:\n            {\n              /*\n                Populate graymap.\n              */\n              if (data == (unsigned char *) NULL)\n                break;\n              colors=(size_t) (length/info.bytes_per_pixel);\n              datum=(int) colors;\n              if (map.gray != (int *) NULL)\n                map.gray=(int *) RelinquishMagickMemory(map.gray);\n              map.gray=(int *) AcquireQuantumMemory(MagickMax(colors,65536),\n                sizeof(*map.gray));\n              if (map.gray == (int *) NULL)\n                ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\")\n              (void) memset(map.gray,0,MagickMax(colors,65536)*\n                sizeof(*map.gray));\n              for (i=0; i < (ssize_t) colors; i++)\n                if (info.bytes_per_pixel == 1)\n                  map.gray[i]=(int) data[i];\n                else\n                  map.gray[i]=(int) ((short *) data)[i];\n              break;\n            }\n            case 0x1201:\n            {\n              unsigned short\n                index;\n\n              /*\n                Populate redmap.\n              */\n              if (data == (unsigned char *) NULL)\n                break;\n              colors=(size_t) (length/info.bytes_per_pixel);\n              datum=(int) colors;\n              if (map.red != (int *) NULL)\n                map.red=(int *) RelinquishMagickMemory(map.red);\n              map.red=(int *) AcquireQuantumMemory(MagickMax(colors,65536),\n                sizeof(*map.red));\n              if (map.red == (int *) NULL)\n                ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\")\n              (void) memset(map.red,0,MagickMax(colors,65536)*\n                sizeof(*map.red));\n              p=data;\n              for (i=0; i < (ssize_t) colors; i++)\n              {\n                if (image->endian == MSBEndian)\n                  index=(unsigned short) ((*p << 8) | *(p+1));\n                else\n                  index=(unsigned short) (*p | (*(p+1) << 8));\n                map.red[i]=(int) index;\n                p+=2;\n              }\n              break;\n            }\n            case 0x1202:\n            {\n              unsigned short\n                index;\n\n              /*\n                Populate greenmap.\n              */\n              if (data == (unsigned char *) NULL)\n                break;\n              colors=(size_t) (length/info.bytes_per_pixel);\n              datum=(int) colors;\n              if (map.green != (int *) NULL)\n                map.green=(int *) RelinquishMagickMemory(map.green);\n              map.green=(int *) AcquireQuantumMemory(MagickMax(colors,65536),\n                sizeof(*map.green));\n              if (map.green == (int *) NULL)\n                ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\")\n              (void) memset(map.green,0,MagickMax(colors,65536)*\n                sizeof(*map.green));\n              p=data;\n              for (i=0; i < (ssize_t) colors; i++)\n              {\n                if (image->endian == MSBEndian)\n                  index=(unsigned short) ((*p << 8) | *(p+1));\n                else\n                  index=(unsigned short) (*p | (*(p+1) << 8));\n                map.green[i]=(int) index;\n                p+=2;\n              }\n              break;\n            }\n            case 0x1203:\n            {\n              unsigned short\n                index;\n\n              /*\n                Populate bluemap.\n              */\n              if (data == (unsigned char *) NULL)\n                break;\n              colors=(size_t) (length/info.bytes_per_pixel);\n              datum=(int) colors;\n              if (map.blue != (int *) NULL)\n                map.blue=(int *) RelinquishMagickMemory(map.blue);\n              map.blue=(int *) AcquireQuantumMemory(MagickMax(colors,65536),\n                sizeof(*map.blue));\n              if (map.blue == (int *) NULL)\n                ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\")\n              (void) memset(map.blue,0,MagickMax(colors,65536)*\n                sizeof(*map.blue));\n              p=data;\n              for (i=0; i < (ssize_t) colors; i++)\n              {\n                if (image->endian == MSBEndian)\n                  index=(unsigned short) ((*p << 8) | *(p+1));\n                else\n                  index=(unsigned short) (*p | (*(p+1) << 8));\n                map.blue[i]=(int) index;\n                p+=2;\n              }\n              break;\n            }\n            default:\n              break;\n          }\n          break;\n        }\n        case 0x2050:\n        {\n          switch (element)\n          {\n            case 0x0020:\n            {\n              if ((data != (unsigned char *) NULL) &&\n                  (strncmp((char *) data,\"INVERSE\",7) == 0))\n                info.polarity=MagickTrue;\n              break;\n            }\n            default:\n              break;\n          }\n          break;\n        }\n        default:\n          break;\n      }\n      if (data != (unsigned char *) NULL)\n        {\n          char\n            *attribute;\n\n          for (i=0; dicom_info[i].description != (char *) NULL; i++)\n            if ((group == dicom_info[i].group) &&\n                (element == dicom_info[i].element))\n              break;\n          if (dicom_info[i].description != (char *) NULL)\n            {\n              attribute=AcquireString(\"dcm:\");\n              (void) ConcatenateString(&attribute,dicom_info[i].description);\n              for (i=0; i < (ssize_t) MagickMax(length,4); i++)\n                if (isprint((int) data[i]) == 0)\n                  break;\n              if ((i == (ssize_t) length) || (length > 4))\n                {\n                  (void) SubstituteString(&attribute,\" \",\"\");\n                  (void) SetImageProperty(image,attribute,(char *) data,\n                    exception);\n                }\n              attribute=DestroyString(attribute);\n            }\n        }\n      if (image_info->verbose != MagickFalse)\n        {\n          if (data == (unsigned char *) NULL)\n            (void) FormatLocaleFile(stdout,\"%d\\n\",datum);\n          else\n            {\n              /*\n                Display group data.\n              */\n              for (i=0; i < (ssize_t) MagickMax(length,4); i++)\n                if (isprint((int) data[i]) == 0)\n                  break;\n              if ((i != (ssize_t) length) && (length <= 4))\n                {\n                  ssize_t\n                    j;\n\n                  datum=0;\n                  for (j=(ssize_t) length-1; j >= 0; j--)\n                    datum=(256*datum+data[j]);\n                  (void) FormatLocaleFile(stdout,\"%d\",datum);\n                }\n              else\n                for (i=0; i < (ssize_t) length; i++)\n                  if (isprint((int) data[i]) != 0)\n                    (void) FormatLocaleFile(stdout,\"%c\",data[i]);\n                  else\n                    (void) FormatLocaleFile(stdout,\"%c\",'.');\n              (void) FormatLocaleFile(stdout,\"\\n\");\n            }\n        }\n      if (data != (unsigned char *) NULL)\n        data=(unsigned char *) RelinquishMagickMemory(data);\n      if (EOFBlob(image) != MagickFalse)\n        {\n          ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n            image->filename);\n          group=0xfffc;\n          break;\n        }\n    }\n    if ((group == 0xfffc) && (element == 0xfffc))\n      {\n        Image\n          *last;\n\n        last=RemoveLastImageFromList(&image);\n        if (last != (Image *) NULL)\n          last=DestroyImage(last);\n        break;\n      }\n    if ((info.width == 0) || (info.height == 0))\n      ThrowDCMException(CorruptImageError,\"ImproperImageHeader\")\n    image->columns=info.width;\n    image->rows=info.height;\n    if (info.signed_data == 0xffff)\n      info.signed_data=(size_t) (info.significant_bits == 16 ? 1 : 0);\n    if ((image->compression == JPEGCompression) ||\n        (image->compression == JPEG2000Compression))\n      {\n        Image\n          *images;\n\n        ImageInfo\n          *read_info;\n\n        int\n          c;\n\n        /*\n          Read offset table.\n        */\n        for (i=0; i < (ssize_t) stream_info->remaining; i++)\n          if (ReadBlobByte(image) == EOF)\n            break;\n        (void) (((ssize_t) ReadBlobLSBShort(image) << 16) |\n          ReadBlobLSBShort(image));\n        length=(size_t) ReadBlobLSBLong(image);\n        if (length > (size_t) GetBlobSize(image))\n          ThrowDCMException(CorruptImageError,\"InsufficientImageDataInFile\")\n        stream_info->offset_count=length >> 2;\n        if (stream_info->offset_count != 0)\n          {\n            if (stream_info->offsets != (ssize_t *) NULL)\n              stream_info->offsets=(ssize_t *) RelinquishMagickMemory(\n                stream_info->offsets);\n            stream_info->offsets=(ssize_t *) AcquireQuantumMemory(\n              stream_info->offset_count,sizeof(*stream_info->offsets));\n            if (stream_info->offsets == (ssize_t *) NULL)\n              ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\")\n            for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n              stream_info->offsets[i]=(ssize_t) ReadBlobLSBSignedLong(image);\n            offset=TellBlob(image);\n            for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n              stream_info->offsets[i]+=offset;\n          }\n        /*\n          Handle non-native image formats.\n        */\n        read_info=CloneImageInfo(image_info);\n        SetImageInfoBlob(read_info,(void *) NULL,0);\n        images=NewImageList();\n        for (scene=0; scene < (ssize_t) number_scenes; scene++)\n        {\n          char\n            filename[MagickPathExtent];\n\n          const char\n            *property;\n\n          FILE\n            *file;\n\n          Image\n            *jpeg_image;\n\n          int\n            unique_file;\n\n          unsigned int\n            tag;\n\n          tag=((unsigned int) ReadBlobLSBShort(image) << 16) |\n            ReadBlobLSBShort(image);\n          length=(size_t) ReadBlobLSBLong(image);\n          if (length > (size_t) GetBlobSize(image))\n            ThrowDCMException(CorruptImageError,\"InsufficientImageDataInFile\")\n          if (EOFBlob(image) != MagickFalse)\n            {\n              status=MagickFalse;\n              break;\n            }\n          if (tag == 0xFFFEE0DD)\n            break; /* sequence delimiter tag */\n          if (tag != 0xFFFEE000)\n            {\n              status=MagickFalse;\n              break;\n            }\n          file=(FILE *) NULL;\n          unique_file=AcquireUniqueFileResource(filename);\n          if (unique_file != -1)\n            file=fdopen(unique_file,\"wb\");\n          if (file == (FILE *) NULL)\n            {\n              (void) RelinquishUniqueFileResource(filename);\n              ThrowFileException(exception,FileOpenError,\n                \"UnableToCreateTemporaryFile\",filename);\n              break;\n            }\n          for (c=EOF; length != 0; length--)\n          {\n            c=ReadBlobByte(image);\n            if (c == EOF)\n              {\n                ThrowFileException(exception,CorruptImageError,\n                  \"UnexpectedEndOfFile\",image->filename);\n                break;\n              }\n            if (fputc(c,file) != c)\n              break;\n          }\n          (void) fclose(file);\n          if (c == EOF)\n            break;\n          (void) FormatLocaleString(read_info->filename,MagickPathExtent,\n            \"jpeg:%s\",filename);\n          if (image->compression == JPEG2000Compression)\n            (void) FormatLocaleString(read_info->filename,MagickPathExtent,\n              \"j2k:%s\",filename);\n          jpeg_image=ReadImage(read_info,exception);\n          if (jpeg_image != (Image *) NULL)\n            {\n              ResetImagePropertyIterator(image);\n              property=GetNextImageProperty(image);\n              while (property != (const char *) NULL)\n              {\n                (void) SetImageProperty(jpeg_image,property,\n                  GetImageProperty(image,property,exception),exception);\n                property=GetNextImageProperty(image);\n              }\n              AppendImageToList(&images,jpeg_image);\n            }\n          (void) RelinquishUniqueFileResource(filename);\n        }\n        read_info=DestroyImageInfo(read_info);\n        RelinquishDCMMemory(&info,&map,stream_info,stack,data);\n        image=DestroyImageList(image);\n        if ((status == MagickFalse) && (exception->severity < ErrorException))\n          ThrowDCMException(CorruptImageError,\"CorruptImageError\")\n        return(GetFirstImageInList(images));\n      }\n    if (info.depth != (1UL*MAGICKCORE_QUANTUM_DEPTH))\n      {\n        QuantumAny\n          range;\n\n        /*\n          Compute pixel scaling table.\n        */\n        length=(size_t) (GetQuantumRange(info.depth)+1);\n        if (length > (size_t) GetBlobSize(image))\n          ThrowDCMException(CorruptImageError,\"InsufficientImageDataInFile\")\n        if (info.scale != (Quantum *) NULL)\n          info.scale=(Quantum *) RelinquishMagickMemory(info.scale);\n        info.scale_size=MagickMax(length,MaxMap)+1;\n        info.scale=(Quantum *) AcquireQuantumMemory(info.scale_size,\n          sizeof(*info.scale));\n        if (info.scale == (Quantum *) NULL)\n          ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\")\n        (void) memset(info.scale,0,(MagickMax(length,MaxMap)+1)*\n          sizeof(*info.scale));\n        range=GetQuantumRange(info.depth);\n        for (i=0; i <= (ssize_t) GetQuantumRange(info.depth); i++)\n          info.scale[i]=ScaleAnyToQuantum((size_t) i,range);\n      }\n    if (image->compression == RLECompression)\n      {\n        unsigned int\n          tag;\n\n        /*\n          Read RLE offset table.\n        */\n        for (i=0; i < (ssize_t) stream_info->remaining; i++)\n        {\n          int\n            c;\n\n          c=ReadBlobByte(image);\n          if (c == EOF)\n            break;\n        }\n        tag=((unsigned int) ReadBlobLSBShort(image) << 16) |\n          ReadBlobLSBShort(image);\n        (void) tag;\n        length=(size_t) ReadBlobLSBLong(image);\n        if (length > (size_t) GetBlobSize(image))\n          ThrowDCMException(CorruptImageError,\"InsufficientImageDataInFile\")\n        stream_info->offset_count=length >> 2;\n        if (stream_info->offset_count != 0)\n          {\n            if (stream_info->offsets != (ssize_t *) NULL)\n              stream_info->offsets=(ssize_t *)\n                RelinquishMagickMemory(stream_info->offsets);\n            stream_info->offsets=(ssize_t *) AcquireQuantumMemory(\n              stream_info->offset_count,sizeof(*stream_info->offsets));\n            if (stream_info->offsets == (ssize_t *) NULL)\n              ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\")\n            for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n            {\n              offset=(MagickOffsetType) ReadBlobLSBSignedLong(image);\n              if (offset > (MagickOffsetType) GetBlobSize(image))\n                ThrowDCMException(CorruptImageError,\n                  \"InsufficientImageDataInFile\")\n              stream_info->offsets[i]=(ssize_t) offset;\n              if (EOFBlob(image) != MagickFalse)\n                break;\n            }\n            offset=TellBlob(image)+8;\n            for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n              stream_info->offsets[i]+=offset;\n          }\n      }\n    for (scene=0; scene < (ssize_t) number_scenes; scene++)\n    {\n      image->columns=info.width;\n      image->rows=info.height;\n      image->depth=info.depth;\n      status=SetImageExtent(image,image->columns,image->rows,exception);\n      if (status == MagickFalse)\n        break;\n      image->colorspace=RGBColorspace;\n      (void) SetImageBackgroundColor(image,exception);\n      if ((image->colormap == (PixelInfo *) NULL) &&\n          (info.samples_per_pixel == 1))\n        {\n          int\n            index;\n\n          size_t\n            one;\n\n          one=1;\n          if (colors == 0)\n            colors=one << info.depth;\n          if (AcquireImageColormap(image,colors,exception) == MagickFalse)\n            ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\")\n          if (map.red != (int *) NULL)\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              index=map.red[i];\n              if ((info.scale != (Quantum *) NULL) && (index >= 0) &&\n                  (index <= (int) info.max_value))\n                index=(int) info.scale[index];\n              image->colormap[i].red=(MagickRealType) index;\n            }\n          if (map.green != (int *) NULL)\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              index=map.green[i];\n              if ((info.scale != (Quantum *) NULL) && (index >= 0) &&\n                  (index <= (int) info.max_value))\n                index=(int) info.scale[index];\n              image->colormap[i].green=(MagickRealType) index;\n            }\n          if (map.blue != (int *) NULL)\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              index=map.blue[i];\n              if ((info.scale != (Quantum *) NULL) && (index >= 0) &&\n                  (index <= (int) info.max_value))\n                index=(int) info.scale[index];\n              image->colormap[i].blue=(MagickRealType) index;\n            }\n          if (map.gray != (int *) NULL)\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              index=map.gray[i];\n              if ((info.scale != (Quantum *) NULL) && (index >= 0) &&\n                  (index <= (int) info.max_value))\n                index=(int) info.scale[index];\n              image->colormap[i].red=(MagickRealType) index;\n              image->colormap[i].green=(MagickRealType) index;\n              image->colormap[i].blue=(MagickRealType) index;\n            }\n        }\n      if (image->compression == RLECompression)\n        {\n          unsigned int\n            tag;\n\n          /*\n            Read RLE segment table.\n          */\n          for (i=0; i < (ssize_t) stream_info->remaining; i++)\n          {\n            int\n              c;\n\n            c=ReadBlobByte(image);\n            if (c == EOF)\n              break;\n          }\n          tag=((unsigned int) ReadBlobLSBShort(image) << 16) |\n            ReadBlobLSBShort(image);\n          stream_info->remaining=(size_t) ReadBlobLSBLong(image);\n          if ((tag != 0xFFFEE000) || (stream_info->remaining <= 64) ||\n              (EOFBlob(image) != MagickFalse))\n            {\n              if (stream_info->offsets != (ssize_t *) NULL)\n                stream_info->offsets=(ssize_t *)\n                  RelinquishMagickMemory(stream_info->offsets);\n              ThrowDCMException(CorruptImageError,\"ImproperImageHeader\")\n            }\n          stream_info->count=0;\n          stream_info->segment_count=ReadBlobLSBLong(image);\n          for (i=0; i < 15; i++)\n            stream_info->segments[i]=(ssize_t) ReadBlobLSBSignedLong(image);\n          stream_info->remaining-=64;\n          if (stream_info->segment_count > 1)\n            {\n              info.bytes_per_pixel=1;\n              info.depth=8;\n              if (stream_info->offset_count > 0)\n                (void) SeekBlob(image,(MagickOffsetType)\n                  stream_info->offsets[0]+stream_info->segments[0],SEEK_SET);\n            }\n        }\n      if ((info.samples_per_pixel > 1) && (image->interlace == PlaneInterlace))\n        {\n          Quantum\n            *q;\n\n          ssize_t\n            x,\n            y;\n\n          /*\n            Convert Planar RGB DCM Medical image to pixel packets.\n          */\n          for (i=0; i < (ssize_t) info.samples_per_pixel; i++)\n          {\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                switch ((int) i)\n                {\n                  case 0:\n                  {\n                    SetPixelRed(image,ScaleCharToQuantum((unsigned char)\n                      ReadDCMByte(stream_info,image)),q);\n                    break;\n                  }\n                  case 1:\n                  {\n                    SetPixelGreen(image,ScaleCharToQuantum((unsigned char)\n                      ReadDCMByte(stream_info,image)),q);\n                    break;\n                  }\n                  case 2:\n                  {\n                    SetPixelBlue(image,ScaleCharToQuantum((unsigned char)\n                      ReadDCMByte(stream_info,image)),q);\n                    break;\n                  }\n                  case 3:\n                  {\n                    SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)\n                      ReadDCMByte(stream_info,image)),q);\n                    break;\n                  }\n                  default:\n                    break;\n                }\n                q+=GetPixelChannels(image);\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n          }\n        }\n      else\n        {\n          const char\n            *option;\n\n          /*\n            Convert DCM Medical image to pixel packets.\n          */\n          option=GetImageOption(image_info,\"dcm:display-range\");\n          if (option != (const char *) NULL)\n            {\n              if (LocaleCompare(option,\"reset\") == 0)\n                info.window_width=0;\n            }\n          option=GetImageOption(image_info,\"dcm:window\");\n          if (option != (char *) NULL)\n            {\n              GeometryInfo\n                geometry_info;\n\n              MagickStatusType\n                flags;\n\n              flags=ParseGeometry(option,&geometry_info);\n              if (flags & RhoValue)\n                info.window_center=geometry_info.rho;\n              if (flags & SigmaValue)\n                info.window_width=geometry_info.sigma;\n              info.rescale=MagickTrue;\n            }\n          option=GetImageOption(image_info,\"dcm:rescale\");\n          if (option != (char *) NULL)\n            info.rescale=IsStringTrue(option);\n          if ((info.window_center != 0) && (info.window_width == 0))\n            info.window_width=info.window_center;\n          status=ReadDCMPixels(image,&info,stream_info,MagickTrue,exception);\n          if ((status != MagickFalse) && (stream_info->segment_count > 1))\n            {\n              if (stream_info->offset_count > 0)\n                (void) SeekBlob(image,(MagickOffsetType)\n                  stream_info->offsets[0]+stream_info->segments[1],SEEK_SET);\n              (void) ReadDCMPixels(image,&info,stream_info,MagickFalse,\n                exception);\n            }\n        }\n      if (IdentifyImageCoderGray(image,exception) != MagickFalse)\n        (void) SetImageColorspace(image,GRAYColorspace,exception);\n      if (EOFBlob(image) != MagickFalse)\n        {\n          ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n            image->filename);\n          break;\n        }\n      /*\n        Proceed to next image.\n      */\n      if (image_info->number_scenes != 0)\n        if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n          break;\n      if (scene < (ssize_t) (number_scenes-1))\n        {\n          /*\n            Allocate next image structure.\n          */\n          AcquireNextImage(image_info,image,exception);\n          if (GetNextImageInList(image) == (Image *) NULL)\n            {\n              status=MagickFalse;\n              break;\n            }\n          image=SyncNextImageInList(image);\n          status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n            GetBlobSize(image));\n          if (status == MagickFalse)\n            break;\n        }\n    }\n    if (TellBlob(image) < (MagickOffsetType) GetBlobSize(image))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            status=MagickFalse;\n            break;\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n     }\n  }\n  /*\n    Free resources.\n  */\n  RelinquishDCMMemory(&info,&map,stream_info,stack,data);\n  if (image == (Image *) NULL)\n    return(image);\n  (void) CloseBlob(image);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  return(GetFirstImageInList(image));\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147326,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static Image *ReadDCMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define ThrowDCMException(exception,message) \\\n{ \\\n  RelinquishDCMMemory(&info,&map,stream_info,stack,data); \\\n  ThrowReaderException((exception),(message)); \\\n}\n\n  char\n    explicit_vr[MagickPathExtent],\n    implicit_vr[MagickPathExtent],\n    magick[MagickPathExtent],\n    photometric[MagickPathExtent];\n\n  DCMInfo\n    info,\n    *info_copy;\n\n  DCMMap\n    map;\n\n  DCMStreamInfo\n    *stream_info;\n\n  Image\n    *image;\n\n  int\n    datum;\n\n  LinkedListInfo\n    *stack;\n\n  MagickBooleanType\n    explicit_file,\n    explicit_retry,\n    use_explicit;\n\n  MagickOffsetType\n    blob_size,\n    offset;\n\n  unsigned char\n    *p;\n\n  ssize_t\n    i;\n\n  size_t\n    colors,\n    length,\n    number_scenes,\n    quantum,\n    status;\n\n  ssize_t\n    count,\n    scene,\n    sequence_depth;\n\n  unsigned char\n    *data;\n\n  unsigned short\n    group,\n    element;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  image->depth=8UL;\n  image->endian=LSBEndian;\n  /*\n    Read DCM preamble.\n  */\n  (void) memset(&info,0,sizeof(info));\n  (void) memset(&map,0,sizeof(map));\n  data=(unsigned char *) NULL;\n  stream_info=(DCMStreamInfo *) AcquireMagickMemory(sizeof(*stream_info));\n  sequence_depth=0;\n  stack=NewLinkedList(256);\n  if (stream_info == (DCMStreamInfo *) NULL)\n    ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\")\n  (void) memset(stream_info,0,sizeof(*stream_info));\n  count=ReadBlob(image,128,(unsigned char *) magick);\n  if (count != 128)\n    ThrowDCMException(CorruptImageError,\"ImproperImageHeader\")\n  count=ReadBlob(image,4,(unsigned char *) magick);\n  if ((count != 4) || (LocaleNCompare(magick,\"DICM\",4) != 0))\n    {\n      offset=SeekBlob(image,0L,SEEK_SET);\n      if (offset < 0)\n        ThrowDCMException(CorruptImageError,\"ImproperImageHeader\")\n    }\n  /*\n    Read DCM Medical image.\n  */\n  (void) CopyMagickString(photometric,\"MONOCHROME1 \",MagickPathExtent);\n  info.bits_allocated=8;\n  info.bytes_per_pixel=1;\n  info.depth=8;\n  info.mask=0xffff;\n  info.max_value=255UL;\n  info.samples_per_pixel=1;\n  info.signed_data=(~0UL);\n  info.rescale_slope=1.0;\n  element=0;\n  explicit_vr[2]='\\0';\n  explicit_file=MagickFalse;\n  colors=0;\n  number_scenes=1;\n  use_explicit=MagickFalse;\n  explicit_retry=MagickFalse;\n  blob_size=(MagickOffsetType) GetBlobSize(image);\n  while (TellBlob(image) < blob_size)\n  {\n    for (group=0; (group != 0x7FE0) || (element != 0x0010) ; )\n    {\n      /*\n        Read a group.\n      */\n      image->offset=(ssize_t) TellBlob(image);\n      group=ReadBlobLSBShort(image);\n      element=ReadBlobLSBShort(image);\n      if ((group == 0xfffc) && (element == 0xfffc))\n        break;\n      if ((group != 0x0002) && (image->endian == MSBEndian))\n        {\n          group=(unsigned short) ((group << 8) | ((group >> 8) & 0xFF));\n          element=(unsigned short) ((element << 8) | ((element >> 8) & 0xFF));\n        }\n      quantum=0;\n      /*\n        Find corresponding VR for this group and element.\n      */\n      for (i=0; dicom_info[i].group < 0xffff; i++)\n        if ((group == dicom_info[i].group) &&\n            (element == dicom_info[i].element))\n          break;\n      (void) CopyMagickString(implicit_vr,dicom_info[i].vr,MagickPathExtent);\n      count=ReadBlob(image,2,(unsigned char *) explicit_vr);\n      if (count != 2)\n        ThrowDCMException(CorruptImageError,\"ImproperImageHeader\")\n      /*\n        Check for \"explicitness\", but meta-file headers always explicit.\n      */\n      if ((explicit_file == MagickFalse) && (group != 0x0002))\n        explicit_file=(isupper((int) ((unsigned char) *explicit_vr)) != 0) &&\n          (isupper((int) ((unsigned char) *(explicit_vr+1))) != 0) ?\n          MagickTrue : MagickFalse;\n      use_explicit=((group == 0x0002) && (explicit_retry == MagickFalse)) ||\n        (explicit_file != MagickFalse) ? MagickTrue : MagickFalse;\n      if ((use_explicit != MagickFalse) && (strncmp(implicit_vr,\"xs\",2) == 0))\n        (void) CopyMagickString(implicit_vr,explicit_vr,MagickPathExtent);\n      if ((use_explicit == MagickFalse) || (strncmp(implicit_vr,\"!!\",2) == 0))\n        {\n          offset=SeekBlob(image,(MagickOffsetType) -2,SEEK_CUR);\n          if (offset < 0)\n            ThrowDCMException(CorruptImageError,\"ImproperImageHeader\")\n          quantum=4;\n        }\n      else\n        {\n          /*\n            Assume explicit type.\n          */\n          quantum=2;\n          if ((strcmp(explicit_vr,\"OB\") == 0) ||\n              (strcmp(explicit_vr,\"OW\") == 0) ||\n              (strcmp(explicit_vr,\"OF\") == 0) ||\n              (strcmp(explicit_vr,\"SQ\") == 0) ||\n              (strcmp(explicit_vr,\"UN\") == 0) ||\n              (strcmp(explicit_vr,\"UT\") == 0))\n            {\n              (void) ReadBlobLSBShort(image);\n              quantum=4;\n            }\n        }\n      if ((group == 0xFFFE) && (element == 0xE0DD))\n        {\n          /*\n            If we're exiting a sequence, restore the previous image parameters,\n            effectively undoing any parameter changes that happened inside the\n            sequence.\n          */\n          sequence_depth--;\n          info_copy=(DCMInfo *) RemoveLastElementFromLinkedList(stack);\n          if (info_copy == (DCMInfo *)NULL)\n            {\n              /*\n                The sequence's entry and exit points don't line up (tried to\n                exit one more sequence than we entered).\n              */\n              ThrowDCMException(CorruptImageError,\"ImproperImageHeader\")\n            }\n          if (info.scale != (Quantum *) NULL)\n            info.scale=(Quantum *) RelinquishMagickMemory(info.scale);\n          (void) memcpy(&info,info_copy,sizeof(info));\n          info_copy=(DCMInfo *) RelinquishMagickMemory(info_copy);\n        }\n      if (strcmp(explicit_vr,\"SQ\") == 0)\n        {\n          /*\n            If we're entering a sequence, push the current image parameters\n            onto the stack, so we can restore them at the end of the sequence.\n          */\n          info_copy=(DCMInfo *) AcquireMagickMemory(sizeof(info));\n          if (info_copy == (DCMInfo *) NULL)\n            ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\")\n          (void) memcpy(info_copy,&info,sizeof(info));\n          info_copy->scale=(Quantum *) AcquireQuantumMemory(\n            info_copy->scale_size,sizeof(*info_copy->scale));\n          if (info_copy->scale == (Quantum *) NULL)\n            {\n              info_copy=(DCMInfo *) RelinquishMagickMemory(info_copy);\n              ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\")\n            }\n          (void) memcpy(info_copy->scale,info.scale,info_copy->scale_size*\n            sizeof(*info_copy->scale));\n          AppendValueToLinkedList(stack,info_copy);\n          sequence_depth++;\n        }\n      datum=0;\n      if (quantum == 4)\n        {\n          if (group == 0x0002)\n            datum=ReadBlobLSBSignedLong(image);\n          else\n            datum=ReadBlobSignedLong(image);\n        }\n      else\n        if (quantum == 2)\n          {\n            if (group == 0x0002)\n              datum=ReadBlobLSBSignedShort(image);\n            else\n              datum=ReadBlobSignedShort(image);\n          }\n      quantum=0;\n      length=1;\n      if (datum != 0)\n        {\n          if ((strncmp(implicit_vr,\"OW\",2) == 0) ||\n              (strncmp(implicit_vr,\"SS\",2) == 0) ||\n              (strncmp(implicit_vr,\"US\",2) == 0))\n            quantum=2;\n          else\n            if ((strncmp(implicit_vr,\"FL\",2) == 0) ||\n                (strncmp(implicit_vr,\"OF\",2) == 0) ||\n                (strncmp(implicit_vr,\"SL\",2) == 0) ||\n                (strncmp(implicit_vr,\"UL\",2) == 0))\n              quantum=4;\n            else\n              if (strncmp(implicit_vr,\"FD\",2) == 0)\n                quantum=8;\n              else\n                quantum=1;\n          if (datum != ~0)\n            length=(size_t) datum/quantum;\n          else\n            {\n              /*\n                Sequence and item of undefined length.\n              */\n              quantum=0;\n              length=0;\n            }\n        }\n      if (image_info->verbose != MagickFalse)\n        {\n          /*\n            Display Dicom info.\n          */\n          if (use_explicit == MagickFalse)\n            explicit_vr[0]='\\0';\n          for (i=0; dicom_info[i].description != (char *) NULL; i++)\n            if ((group == dicom_info[i].group) &&\n                (element == dicom_info[i].element))\n              break;\n          (void) FormatLocaleFile(stdout,\n            \"0x%04lX %4ld S%ld %s-%s (0x%04lx,0x%04lx)\",\n            (unsigned long) image->offset,(long) length,(long) sequence_depth,\n            implicit_vr,explicit_vr,(unsigned long) group,\n            (unsigned long) element);\n          if (dicom_info[i].description != (char *) NULL)\n            (void) FormatLocaleFile(stdout,\" %s\",dicom_info[i].description);\n          (void) FormatLocaleFile(stdout,\": \");\n        }\n      if ((group == 0x7FE0) && (element == 0x0010))\n        {\n          if (image_info->verbose != MagickFalse)\n            (void) FormatLocaleFile(stdout,\"\\n\");\n          break;\n        }\n      /*\n        Allocate space and read an array.\n      */\n      data=(unsigned char *) NULL;\n      if ((length == 1) && (quantum == 1))\n        datum=ReadBlobByte(image);\n      else\n        if ((length == 1) && (quantum == 2))\n          {\n            if (group == 0x0002)\n              datum=ReadBlobLSBSignedShort(image);\n            else\n              datum=ReadBlobSignedShort(image);\n          }\n        else\n          if ((length == 1) && (quantum == 4))\n            {\n              if (group == 0x0002)\n                datum=ReadBlobLSBSignedLong(image);\n              else\n                datum=ReadBlobSignedLong(image);\n            }\n          else\n            if ((quantum != 0) && (length != 0))\n              {\n                if (length > (size_t) GetBlobSize(image))\n                  ThrowDCMException(CorruptImageError,\n                    \"InsufficientImageDataInFile\")\n                if (~length >= 1)\n                  data=(unsigned char *) AcquireQuantumMemory(length+1,quantum*\n                    sizeof(*data));\n                if (data == (unsigned char *) NULL)\n                  ThrowDCMException(ResourceLimitError,\n                    \"MemoryAllocationFailed\")\n                count=ReadBlob(image,(size_t) quantum*length,data);\n                if (count != (ssize_t) (quantum*length))\n                  {\n                    if (image_info->verbose != MagickFalse)\n                      (void) FormatLocaleFile(stdout,\"count=%d quantum=%d \"\n                        \"length=%d group=%d\\n\",(int) count,(int) quantum,(int)\n                        length,(int) group);\n                     ThrowDCMException(CorruptImageError,\n                       \"InsufficientImageDataInFile\")\n                  }\n                data[length*quantum]='\\0';\n              }\n      if ((((unsigned int) group << 16) | element) == 0xFFFEE0DD)\n        {\n          if (data != (unsigned char *) NULL)\n            data=(unsigned char *) RelinquishMagickMemory(data);\n          continue;\n        }\n      switch (group)\n      {\n        case 0x0002:\n        {\n          switch (element)\n          {\n            case 0x0010:\n            {\n              char\n                transfer_syntax[MagickPathExtent];\n\n              /*\n                Transfer Syntax.\n              */\n              if ((datum == 0) && (explicit_retry == MagickFalse))\n                {\n                  explicit_retry=MagickTrue;\n                  (void) SeekBlob(image,(MagickOffsetType) 0,SEEK_SET);\n                  group=0;\n                  element=0;\n                  if (image_info->verbose != MagickFalse)\n                    (void) FormatLocaleFile(stdout,\n                      \"Corrupted image - trying explicit format\\n\");\n                  break;\n                }\n              *transfer_syntax='\\0';\n              if (data != (unsigned char *) NULL)\n                (void) CopyMagickString(transfer_syntax,(char *) data,\n                  MagickPathExtent);\n              if (image_info->verbose != MagickFalse)\n                (void) FormatLocaleFile(stdout,\"transfer_syntax=%s\\n\",\n                  (const char *) transfer_syntax);\n              if (strncmp(transfer_syntax,\"1.2.840.10008.1.2\",17) == 0)\n                {\n                  int\n                    subtype,\n                    type;\n\n                  type=1;\n                  subtype=0;\n                  if (strlen(transfer_syntax) > 17)\n                    {\n                      count=(ssize_t) sscanf(transfer_syntax+17,\".%d.%d\",&type,\n                        &subtype);\n                      if (count < 1)\n                        ThrowDCMException(CorruptImageError,\n                          \"ImproperImageHeader\")\n                    }\n                  switch (type)\n                  {\n                    case 1:\n                    {\n                      image->endian=LSBEndian;\n                      break;\n                    }\n                    case 2:\n                    {\n                      image->endian=MSBEndian;\n                      break;\n                    }\n                    case 4:\n                    {\n                      if ((subtype >= 80) && (subtype <= 81))\n                        image->compression=JPEGCompression;\n                      else\n                        if ((subtype >= 90) && (subtype <= 93))\n                          image->compression=JPEG2000Compression;\n                        else\n                          image->compression=JPEGCompression;\n                      break;\n                    }\n                    case 5:\n                    {\n                      image->compression=RLECompression;\n                      break;\n                    }\n                  }\n                }\n              break;\n            }\n            default:\n              break;\n          }\n          break;\n        }\n        case 0x0028:\n        {\n          switch (element)\n          {\n            case 0x0002:\n            {\n              /*\n                Samples per pixel.\n              */\n              info.samples_per_pixel=(size_t) datum;\n              if ((info.samples_per_pixel == 0) || (info.samples_per_pixel > 4))\n                ThrowDCMException(CorruptImageError,\"ImproperImageHeader\")\n              break;\n            }\n            case 0x0004:\n            {\n              /*\n                Photometric interpretation.\n              */\n              if (data == (unsigned char *) NULL)\n                break;\n              for (i=0; i < (ssize_t) MagickMin(length,MagickPathExtent-1); i++)\n                photometric[i]=(char) data[i];\n              photometric[i]='\\0';\n              info.polarity=LocaleCompare(photometric,\"MONOCHROME1 \") == 0 ?\n                MagickTrue : MagickFalse;\n              break;\n            }\n            case 0x0006:\n            {\n              /*\n                Planar configuration.\n              */\n              if (datum == 1)\n                image->interlace=PlaneInterlace;\n              break;\n            }\n            case 0x0008:\n            {\n              /*\n                Number of frames.\n              */\n              if (data == (unsigned char *) NULL)\n                break;\n              number_scenes=StringToUnsignedLong((char *) data);\n              break;\n            }\n            case 0x0010:\n            {\n              /*\n                Image rows.\n              */\n              info.height=(size_t) datum;\n              break;\n            }\n            case 0x0011:\n            {\n              /*\n                Image columns.\n              */\n              info.width=(size_t) datum;\n              break;\n            }\n            case 0x0100:\n            {\n              /*\n                Bits allocated.\n              */\n              info.bits_allocated=(size_t) datum;\n              info.bytes_per_pixel=1;\n              if (datum > 8)\n                info.bytes_per_pixel=2;\n              info.depth=info.bits_allocated;\n              if ((info.depth == 0) || (info.depth > 32))\n                ThrowDCMException(CorruptImageError,\"ImproperImageHeader\")\n              info.max_value=(1UL << info.bits_allocated)-1;\n              image->depth=info.depth;\n              break;\n            }\n            case 0x0101:\n            {\n              /*\n                Bits stored.\n              */\n              info.significant_bits=(size_t) datum;\n              info.bytes_per_pixel=1;\n              if (info.significant_bits > 8)\n                info.bytes_per_pixel=2;\n              info.depth=info.significant_bits;\n              if ((info.depth == 0) || (info.depth > 16))\n                ThrowDCMException(CorruptImageError,\"ImproperImageHeader\")\n              info.max_value=(1UL << info.significant_bits)-1;\n              info.mask=(size_t) GetQuantumRange(info.significant_bits);\n              image->depth=info.depth;\n              break;\n            }\n            case 0x0102:\n            {\n              /*\n                High bit.\n              */\n              break;\n            }\n            case 0x0103:\n            {\n              /*\n                Pixel representation.\n              */\n              info.signed_data=(size_t) datum;\n              break;\n            }\n            case 0x1050:\n            {\n              /*\n                Visible pixel range: center.\n              */\n              if (data != (unsigned char *) NULL)\n                info.window_center=StringToDouble((char *) data,(char **) NULL);\n              break;\n            }\n            case 0x1051:\n            {\n              /*\n                Visible pixel range: width.\n              */\n              if (data != (unsigned char *) NULL)\n                info.window_width=StringToDouble((char *) data,(char **) NULL);\n              break;\n            }\n            case 0x1052:\n            {\n              /*\n                Rescale intercept\n              */\n              if (data != (unsigned char *) NULL)\n                info.rescale_intercept=StringToDouble((char *) data,\n                  (char **) NULL);\n              break;\n            }\n            case 0x1053:\n            {\n              /*\n                Rescale slope\n              */\n              if (data != (unsigned char *) NULL)\n                info.rescale_slope=StringToDouble((char *) data,(char **) NULL);\n              break;\n            }\n            case 0x1200:\n            case 0x3006:\n            {\n              /*\n                Populate graymap.\n              */\n              if (data == (unsigned char *) NULL)\n                break;\n              colors=(size_t) (length/info.bytes_per_pixel);\n              datum=(int) colors;\n              if (map.gray != (int *) NULL)\n                map.gray=(int *) RelinquishMagickMemory(map.gray);\n              map.gray=(int *) AcquireQuantumMemory(MagickMax(colors,65536),\n                sizeof(*map.gray));\n              if (map.gray == (int *) NULL)\n                ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\")\n              (void) memset(map.gray,0,MagickMax(colors,65536)*\n                sizeof(*map.gray));\n              for (i=0; i < (ssize_t) colors; i++)\n                if (info.bytes_per_pixel == 1)\n                  map.gray[i]=(int) data[i];\n                else\n                  map.gray[i]=(int) ((short *) data)[i];\n              break;\n            }\n            case 0x1201:\n            {\n              unsigned short\n                index;\n\n              /*\n                Populate redmap.\n              */\n              if (data == (unsigned char *) NULL)\n                break;\n              colors=(size_t) (length/info.bytes_per_pixel);\n              datum=(int) colors;\n              if (map.red != (int *) NULL)\n                map.red=(int *) RelinquishMagickMemory(map.red);\n              map.red=(int *) AcquireQuantumMemory(MagickMax(colors,65536),\n                sizeof(*map.red));\n              if (map.red == (int *) NULL)\n                ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\")\n              (void) memset(map.red,0,MagickMax(colors,65536)*\n                sizeof(*map.red));\n              p=data;\n              for (i=0; i < (ssize_t) colors; i++)\n              {\n                if (image->endian == MSBEndian)\n                  index=(unsigned short) ((*p << 8) | *(p+1));\n                else\n                  index=(unsigned short) (*p | (*(p+1) << 8));\n                map.red[i]=(int) index;\n                p+=2;\n              }\n              break;\n            }\n            case 0x1202:\n            {\n              unsigned short\n                index;\n\n              /*\n                Populate greenmap.\n              */\n              if (data == (unsigned char *) NULL)\n                break;\n              colors=(size_t) (length/info.bytes_per_pixel);\n              datum=(int) colors;\n              if (map.green != (int *) NULL)\n                map.green=(int *) RelinquishMagickMemory(map.green);\n              map.green=(int *) AcquireQuantumMemory(MagickMax(colors,65536),\n                sizeof(*map.green));\n              if (map.green == (int *) NULL)\n                ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\")\n              (void) memset(map.green,0,MagickMax(colors,65536)*\n                sizeof(*map.green));\n              p=data;\n              for (i=0; i < (ssize_t) colors; i++)\n              {\n                if (image->endian == MSBEndian)\n                  index=(unsigned short) ((*p << 8) | *(p+1));\n                else\n                  index=(unsigned short) (*p | (*(p+1) << 8));\n                map.green[i]=(int) index;\n                p+=2;\n              }\n              break;\n            }\n            case 0x1203:\n            {\n              unsigned short\n                index;\n\n              /*\n                Populate bluemap.\n              */\n              if (data == (unsigned char *) NULL)\n                break;\n              colors=(size_t) (length/info.bytes_per_pixel);\n              datum=(int) colors;\n              if (map.blue != (int *) NULL)\n                map.blue=(int *) RelinquishMagickMemory(map.blue);\n              map.blue=(int *) AcquireQuantumMemory(MagickMax(colors,65536),\n                sizeof(*map.blue));\n              if (map.blue == (int *) NULL)\n                ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\")\n              (void) memset(map.blue,0,MagickMax(colors,65536)*\n                sizeof(*map.blue));\n              p=data;\n              for (i=0; i < (ssize_t) colors; i++)\n              {\n                if (image->endian == MSBEndian)\n                  index=(unsigned short) ((*p << 8) | *(p+1));\n                else\n                  index=(unsigned short) (*p | (*(p+1) << 8));\n                map.blue[i]=(int) index;\n                p+=2;\n              }\n              break;\n            }\n            default:\n              break;\n          }\n          break;\n        }\n        case 0x2050:\n        {\n          switch (element)\n          {\n            case 0x0020:\n            {\n              if ((data != (unsigned char *) NULL) &&\n                  (strncmp((char *) data,\"INVERSE\",7) == 0))\n                info.polarity=MagickTrue;\n              break;\n            }\n            default:\n              break;\n          }\n          break;\n        }\n        default:\n          break;\n      }\n      if (data != (unsigned char *) NULL)\n        {\n          char\n            *attribute;\n\n          for (i=0; dicom_info[i].description != (char *) NULL; i++)\n            if ((group == dicom_info[i].group) &&\n                (element == dicom_info[i].element))\n              break;\n          if (dicom_info[i].description != (char *) NULL)\n            {\n              attribute=AcquireString(\"dcm:\");\n              (void) ConcatenateString(&attribute,dicom_info[i].description);\n              for (i=0; i < (ssize_t) MagickMax(length,4); i++)\n                if (isprint((int) data[i]) == 0)\n                  break;\n              if ((i == (ssize_t) length) || (length > 4))\n                {\n                  (void) SubstituteString(&attribute,\" \",\"\");\n                  (void) SetImageProperty(image,attribute,(char *) data,\n                    exception);\n                }\n              attribute=DestroyString(attribute);\n            }\n        }\n      if (image_info->verbose != MagickFalse)\n        {\n          if (data == (unsigned char *) NULL)\n            (void) FormatLocaleFile(stdout,\"%d\\n\",datum);\n          else\n            {\n              /*\n                Display group data.\n              */\n              for (i=0; i < (ssize_t) MagickMax(length,4); i++)\n                if (isprint((int) data[i]) == 0)\n                  break;\n              if ((i != (ssize_t) length) && (length <= 4))\n                {\n                  ssize_t\n                    j;\n\n                  datum=0;\n                  for (j=(ssize_t) length-1; j >= 0; j--)\n                    datum=(256*datum+data[j]);\n                  (void) FormatLocaleFile(stdout,\"%d\",datum);\n                }\n              else\n                for (i=0; i < (ssize_t) length; i++)\n                  if (isprint((int) data[i]) != 0)\n                    (void) FormatLocaleFile(stdout,\"%c\",data[i]);\n                  else\n                    (void) FormatLocaleFile(stdout,\"%c\",'.');\n              (void) FormatLocaleFile(stdout,\"\\n\");\n            }\n        }\n      if (data != (unsigned char *) NULL)\n        data=(unsigned char *) RelinquishMagickMemory(data);\n      if (EOFBlob(image) != MagickFalse)\n        {\n          ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n            image->filename);\n          group=0xfffc;\n          break;\n        }\n    }\n    if ((group == 0xfffc) && (element == 0xfffc))\n      {\n        Image\n          *last;\n\n        last=RemoveLastImageFromList(&image);\n        if (last != (Image *) NULL)\n          last=DestroyImage(last);\n        break;\n      }\n    if ((info.width == 0) || (info.height == 0))\n      ThrowDCMException(CorruptImageError,\"ImproperImageHeader\")\n    image->columns=info.width;\n    image->rows=info.height;\n    if (info.signed_data == 0xffff)\n      info.signed_data=(size_t) (info.significant_bits == 16 ? 1 : 0);\n    if ((image->compression == JPEGCompression) ||\n        (image->compression == JPEG2000Compression))\n      {\n        Image\n          *images;\n\n        ImageInfo\n          *read_info;\n\n        int\n          c;\n\n        /*\n          Read offset table.\n        */\n        for (i=0; i < (ssize_t) stream_info->remaining; i++)\n          if (ReadBlobByte(image) == EOF)\n            break;\n        (void) (((ssize_t) ReadBlobLSBShort(image) << 16) |\n          ReadBlobLSBShort(image));\n        length=(size_t) ReadBlobLSBLong(image);\n        if (length > (size_t) GetBlobSize(image))\n          ThrowDCMException(CorruptImageError,\"InsufficientImageDataInFile\")\n        stream_info->offset_count=length >> 2;\n        if (stream_info->offset_count != 0)\n          {\n            if (stream_info->offsets != (ssize_t *) NULL)\n              stream_info->offsets=(ssize_t *) RelinquishMagickMemory(\n                stream_info->offsets);\n            stream_info->offsets=(ssize_t *) AcquireQuantumMemory(\n              stream_info->offset_count,sizeof(*stream_info->offsets));\n            if (stream_info->offsets == (ssize_t *) NULL)\n              ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\")\n            for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n              stream_info->offsets[i]=(ssize_t) ReadBlobLSBSignedLong(image);\n            offset=TellBlob(image);\n            for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n              stream_info->offsets[i]+=offset;\n          }\n        /*\n          Handle non-native image formats.\n        */\n        read_info=CloneImageInfo(image_info);\n        SetImageInfoBlob(read_info,(void *) NULL,0);\n        images=NewImageList();\n        for (scene=0; scene < (ssize_t) number_scenes; scene++)\n        {\n          char\n            filename[MagickPathExtent];\n\n          const char\n            *property;\n\n          FILE\n            *file;\n\n          Image\n            *jpeg_image;\n\n          int\n            unique_file;\n\n          unsigned int\n            tag;\n\n          tag=((unsigned int) ReadBlobLSBShort(image) << 16) |\n            ReadBlobLSBShort(image);\n          length=(size_t) ReadBlobLSBLong(image);\n          if (length > (size_t) GetBlobSize(image))\n            ThrowDCMException(CorruptImageError,\"InsufficientImageDataInFile\")\n          if (EOFBlob(image) != MagickFalse)\n            {\n              status=MagickFalse;\n              break;\n            }\n          if (tag == 0xFFFEE0DD)\n            break; /* sequence delimiter tag */\n          if (tag != 0xFFFEE000)\n            {\n              status=MagickFalse;\n              break;\n            }\n          file=(FILE *) NULL;\n          unique_file=AcquireUniqueFileResource(filename);\n          if (unique_file != -1)\n            file=fdopen(unique_file,\"wb\");\n          if (file == (FILE *) NULL)\n            {\n              (void) RelinquishUniqueFileResource(filename);\n              ThrowFileException(exception,FileOpenError,\n                \"UnableToCreateTemporaryFile\",filename);\n              break;\n            }\n          for (c=EOF; length != 0; length--)\n          {\n            c=ReadBlobByte(image);\n            if (c == EOF)\n              {\n                ThrowFileException(exception,CorruptImageError,\n                  \"UnexpectedEndOfFile\",image->filename);\n                break;\n              }\n            if (fputc(c,file) != c)\n              break;\n          }\n          (void) fclose(file);\n          if (c == EOF)\n            break;\n          (void) FormatLocaleString(read_info->filename,MagickPathExtent,\n            \"jpeg:%s\",filename);\n          if (image->compression == JPEG2000Compression)\n            (void) FormatLocaleString(read_info->filename,MagickPathExtent,\n              \"j2k:%s\",filename);\n          jpeg_image=ReadImage(read_info,exception);\n          if (jpeg_image != (Image *) NULL)\n            {\n              ResetImagePropertyIterator(image);\n              property=GetNextImageProperty(image);\n              while (property != (const char *) NULL)\n              {\n                (void) SetImageProperty(jpeg_image,property,\n                  GetImageProperty(image,property,exception),exception);\n                property=GetNextImageProperty(image);\n              }\n              AppendImageToList(&images,jpeg_image);\n            }\n          (void) RelinquishUniqueFileResource(filename);\n        }\n        read_info=DestroyImageInfo(read_info);\n        image=DestroyImageList(image);\n        if ((status == MagickFalse) && (exception->severity < ErrorException))\n          ThrowDCMException(CorruptImageError,\"CorruptImageError\")\n        else\n          RelinquishDCMMemory(&info,&map,stream_info,stack,data);\n        return(GetFirstImageInList(images));\n      }\n    if (info.depth != (1UL*MAGICKCORE_QUANTUM_DEPTH))\n      {\n        QuantumAny\n          range;\n\n        /*\n          Compute pixel scaling table.\n        */\n        length=(size_t) (GetQuantumRange(info.depth)+1);\n        if (length > (size_t) GetBlobSize(image))\n          ThrowDCMException(CorruptImageError,\"InsufficientImageDataInFile\")\n        if (info.scale != (Quantum *) NULL)\n          info.scale=(Quantum *) RelinquishMagickMemory(info.scale);\n        info.scale_size=MagickMax(length,MaxMap)+1;\n        info.scale=(Quantum *) AcquireQuantumMemory(info.scale_size,\n          sizeof(*info.scale));\n        if (info.scale == (Quantum *) NULL)\n          ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\")\n        (void) memset(info.scale,0,(MagickMax(length,MaxMap)+1)*\n          sizeof(*info.scale));\n        range=GetQuantumRange(info.depth);\n        for (i=0; i <= (ssize_t) GetQuantumRange(info.depth); i++)\n          info.scale[i]=ScaleAnyToQuantum((size_t) i,range);\n      }\n    if (image->compression == RLECompression)\n      {\n        unsigned int\n          tag;\n\n        /*\n          Read RLE offset table.\n        */\n        for (i=0; i < (ssize_t) stream_info->remaining; i++)\n        {\n          int\n            c;\n\n          c=ReadBlobByte(image);\n          if (c == EOF)\n            break;\n        }\n        tag=((unsigned int) ReadBlobLSBShort(image) << 16) |\n          ReadBlobLSBShort(image);\n        (void) tag;\n        length=(size_t) ReadBlobLSBLong(image);\n        if (length > (size_t) GetBlobSize(image))\n          ThrowDCMException(CorruptImageError,\"InsufficientImageDataInFile\")\n        stream_info->offset_count=length >> 2;\n        if (stream_info->offset_count != 0)\n          {\n            if (stream_info->offsets != (ssize_t *) NULL)\n              stream_info->offsets=(ssize_t *)\n                RelinquishMagickMemory(stream_info->offsets);\n            stream_info->offsets=(ssize_t *) AcquireQuantumMemory(\n              stream_info->offset_count,sizeof(*stream_info->offsets));\n            if (stream_info->offsets == (ssize_t *) NULL)\n              ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\")\n            for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n            {\n              offset=(MagickOffsetType) ReadBlobLSBSignedLong(image);\n              if (offset > (MagickOffsetType) GetBlobSize(image))\n                ThrowDCMException(CorruptImageError,\n                  \"InsufficientImageDataInFile\")\n              stream_info->offsets[i]=(ssize_t) offset;\n              if (EOFBlob(image) != MagickFalse)\n                break;\n            }\n            offset=TellBlob(image)+8;\n            for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n              stream_info->offsets[i]+=offset;\n          }\n      }\n    for (scene=0; scene < (ssize_t) number_scenes; scene++)\n    {\n      image->columns=info.width;\n      image->rows=info.height;\n      image->depth=info.depth;\n      status=SetImageExtent(image,image->columns,image->rows,exception);\n      if (status == MagickFalse)\n        break;\n      image->colorspace=RGBColorspace;\n      (void) SetImageBackgroundColor(image,exception);\n      if ((image->colormap == (PixelInfo *) NULL) &&\n          (info.samples_per_pixel == 1))\n        {\n          int\n            index;\n\n          size_t\n            one;\n\n          one=1;\n          if (colors == 0)\n            colors=one << info.depth;\n          if (AcquireImageColormap(image,colors,exception) == MagickFalse)\n            ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\")\n          if (map.red != (int *) NULL)\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              index=map.red[i];\n              if ((info.scale != (Quantum *) NULL) && (index >= 0) &&\n                  (index <= (int) info.max_value))\n                index=(int) info.scale[index];\n              image->colormap[i].red=(MagickRealType) index;\n            }\n          if (map.green != (int *) NULL)\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              index=map.green[i];\n              if ((info.scale != (Quantum *) NULL) && (index >= 0) &&\n                  (index <= (int) info.max_value))\n                index=(int) info.scale[index];\n              image->colormap[i].green=(MagickRealType) index;\n            }\n          if (map.blue != (int *) NULL)\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              index=map.blue[i];\n              if ((info.scale != (Quantum *) NULL) && (index >= 0) &&\n                  (index <= (int) info.max_value))\n                index=(int) info.scale[index];\n              image->colormap[i].blue=(MagickRealType) index;\n            }\n          if (map.gray != (int *) NULL)\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              index=map.gray[i];\n              if ((info.scale != (Quantum *) NULL) && (index >= 0) &&\n                  (index <= (int) info.max_value))\n                index=(int) info.scale[index];\n              image->colormap[i].red=(MagickRealType) index;\n              image->colormap[i].green=(MagickRealType) index;\n              image->colormap[i].blue=(MagickRealType) index;\n            }\n        }\n      if (image->compression == RLECompression)\n        {\n          unsigned int\n            tag;\n\n          /*\n            Read RLE segment table.\n          */\n          for (i=0; i < (ssize_t) stream_info->remaining; i++)\n          {\n            int\n              c;\n\n            c=ReadBlobByte(image);\n            if (c == EOF)\n              break;\n          }\n          tag=((unsigned int) ReadBlobLSBShort(image) << 16) |\n            ReadBlobLSBShort(image);\n          stream_info->remaining=(size_t) ReadBlobLSBLong(image);\n          if ((tag != 0xFFFEE000) || (stream_info->remaining <= 64) ||\n              (EOFBlob(image) != MagickFalse))\n            {\n              if (stream_info->offsets != (ssize_t *) NULL)\n                stream_info->offsets=(ssize_t *)\n                  RelinquishMagickMemory(stream_info->offsets);\n              ThrowDCMException(CorruptImageError,\"ImproperImageHeader\")\n            }\n          stream_info->count=0;\n          stream_info->segment_count=ReadBlobLSBLong(image);\n          for (i=0; i < 15; i++)\n            stream_info->segments[i]=(ssize_t) ReadBlobLSBSignedLong(image);\n          stream_info->remaining-=64;\n          if (stream_info->segment_count > 1)\n            {\n              info.bytes_per_pixel=1;\n              info.depth=8;\n              if (stream_info->offset_count > 0)\n                (void) SeekBlob(image,(MagickOffsetType)\n                  stream_info->offsets[0]+stream_info->segments[0],SEEK_SET);\n            }\n        }\n      if ((info.samples_per_pixel > 1) && (image->interlace == PlaneInterlace))\n        {\n          Quantum\n            *q;\n\n          ssize_t\n            x,\n            y;\n\n          /*\n            Convert Planar RGB DCM Medical image to pixel packets.\n          */\n          for (i=0; i < (ssize_t) info.samples_per_pixel; i++)\n          {\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                switch ((int) i)\n                {\n                  case 0:\n                  {\n                    SetPixelRed(image,ScaleCharToQuantum((unsigned char)\n                      ReadDCMByte(stream_info,image)),q);\n                    break;\n                  }\n                  case 1:\n                  {\n                    SetPixelGreen(image,ScaleCharToQuantum((unsigned char)\n                      ReadDCMByte(stream_info,image)),q);\n                    break;\n                  }\n                  case 2:\n                  {\n                    SetPixelBlue(image,ScaleCharToQuantum((unsigned char)\n                      ReadDCMByte(stream_info,image)),q);\n                    break;\n                  }\n                  case 3:\n                  {\n                    SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)\n                      ReadDCMByte(stream_info,image)),q);\n                    break;\n                  }\n                  default:\n                    break;\n                }\n                q+=GetPixelChannels(image);\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n          }\n        }\n      else\n        {\n          const char\n            *option;\n\n          /*\n            Convert DCM Medical image to pixel packets.\n          */\n          option=GetImageOption(image_info,\"dcm:display-range\");\n          if (option != (const char *) NULL)\n            {\n              if (LocaleCompare(option,\"reset\") == 0)\n                info.window_width=0;\n            }\n          option=GetImageOption(image_info,\"dcm:window\");\n          if (option != (char *) NULL)\n            {\n              GeometryInfo\n                geometry_info;\n\n              MagickStatusType\n                flags;\n\n              flags=ParseGeometry(option,&geometry_info);\n              if (flags & RhoValue)\n                info.window_center=geometry_info.rho;\n              if (flags & SigmaValue)\n                info.window_width=geometry_info.sigma;\n              info.rescale=MagickTrue;\n            }\n          option=GetImageOption(image_info,\"dcm:rescale\");\n          if (option != (char *) NULL)\n            info.rescale=IsStringTrue(option);\n          if ((info.window_center != 0) && (info.window_width == 0))\n            info.window_width=info.window_center;\n          status=ReadDCMPixels(image,&info,stream_info,MagickTrue,exception);\n          if ((status != MagickFalse) && (stream_info->segment_count > 1))\n            {\n              if (stream_info->offset_count > 0)\n                (void) SeekBlob(image,(MagickOffsetType)\n                  stream_info->offsets[0]+stream_info->segments[1],SEEK_SET);\n              (void) ReadDCMPixels(image,&info,stream_info,MagickFalse,\n                exception);\n            }\n        }\n      if (IdentifyImageCoderGray(image,exception) != MagickFalse)\n        (void) SetImageColorspace(image,GRAYColorspace,exception);\n      if (EOFBlob(image) != MagickFalse)\n        {\n          ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n            image->filename);\n          break;\n        }\n      /*\n        Proceed to next image.\n      */\n      if (image_info->number_scenes != 0)\n        if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n          break;\n      if (scene < (ssize_t) (number_scenes-1))\n        {\n          /*\n            Allocate next image structure.\n          */\n          AcquireNextImage(image_info,image,exception);\n          if (GetNextImageInList(image) == (Image *) NULL)\n            {\n              status=MagickFalse;\n              break;\n            }\n          image=SyncNextImageInList(image);\n          status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n            GetBlobSize(image));\n          if (status == MagickFalse)\n            break;\n        }\n    }\n    if (TellBlob(image) < (MagickOffsetType) GetBlobSize(image))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            status=MagickFalse;\n            break;\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n     }\n  }\n  /*\n    Free resources.\n  */\n  RelinquishDCMMemory(&info,&map,stream_info,stack,data);\n  if (image == (Image *) NULL)\n    return(image);\n  (void) CloseBlob(image);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  return(GetFirstImageInList(image));\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147327,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "xmlXIncludeDoProcess(xmlXIncludeCtxtPtr ctxt, xmlDocPtr doc, xmlNodePtr tree,\n                     int skipRoot) {\n    xmlNodePtr cur;\n    int ret = 0;\n    int i, start;\n\n    if ((doc == NULL) || (tree == NULL) || (tree->type == XML_NAMESPACE_DECL))\n\treturn(-1);\n    if ((skipRoot) && (tree->children == NULL))\n        return(-1);\n    if (ctxt == NULL)\n\treturn(-1);\n\n    if (doc->URL != NULL) {\n\tret = xmlXIncludeURLPush(ctxt, doc->URL);\n\tif (ret < 0)\n\t    return(-1);\n    }\n    start = ctxt->incNr;\n\n    /*\n     * TODO: The phases must run separately for recursive inclusions.\n     *\n     * - Phase 1 should start with top-level XInclude nodes, load documents,\n     *   execute XPointer expressions, then process only the result nodes\n     *   (not whole document, see bug #324081) and only for phase 1\n     *   recursively. We will need a backreference from xmlNodes to\n     *   xmlIncludeRefs to detect references that were already visited.\n     *   This can also be used for proper cycle detection, see bug #344240.\n     *\n     * - Phase 2 should visit all top-level XInclude nodes and expand\n     *   possible subreferences in the replacement recursively.\n     *\n     * - Phase 3 should finally replace the top-level XInclude nodes.\n     *   It could also be run together with phase 2.\n     */\n\n    /*\n     * First phase: lookup the elements in the document\n     */\n    if (skipRoot)\n        cur = tree->children;\n    else\n        cur = tree;\n    do {\n\t/* TODO: need to work on entities -> stack */\n        if (xmlXIncludeTestNode(ctxt, cur) == 1) {\n#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n            /*\n             * Avoid superlinear expansion by limiting the total number\n             * of replacements.\n             */\n            if (ctxt->incTotal >= 20)\n                return(-1);\n#endif\n            ctxt->incTotal++;\n            xmlXIncludePreProcessNode(ctxt, cur);\n        } else if ((cur->children != NULL) &&\n                   (cur->children->type != XML_ENTITY_DECL) &&\n                   (cur->children->type != XML_XINCLUDE_START) &&\n                   (cur->children->type != XML_XINCLUDE_END)) {\n            cur = cur->children;\n            continue;\n        }\n        do {\n            if (cur == tree)\n                break;\n            if (cur->next != NULL) {\n                cur = cur->next;\n                break;\n            }\n            cur = cur->parent;\n        } while (cur != NULL);\n    } while ((cur != NULL) && (cur != tree));\n\n    /*\n     * Second Phase : collect the infosets fragments\n     */\n    for (i = start;i < ctxt->incNr; i++) {\n        xmlXIncludeLoadNode(ctxt, i);\n\tret++;\n    }\n\n    /*\n     * Third phase: extend the original document infoset.\n     *\n     * Originally we bypassed the inclusion if there were any errors\n     * encountered on any of the XIncludes.  A bug was raised (bug\n     * 132588) requesting that we output the XIncludes without error,\n     * so the check for inc!=NULL || xptr!=NULL was put in.  This may\n     * give some other problems in the future, but for now it seems to\n     * work ok.\n     *\n     */\n    for (i = ctxt->incBase;i < ctxt->incNr; i++) {\n\tif ((ctxt->incTab[i]->inc != NULL) ||\n\t    (ctxt->incTab[i]->emptyFb != 0))\t/* (empty fallback) */\n\t    xmlXIncludeIncludeNode(ctxt, i);\n    }\n\n    if (doc->URL != NULL)\n\txmlXIncludeURLPop(ctxt);\n    return(ret);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147332,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "xmlXIncludeDoProcess(xmlXIncludeCtxtPtr ctxt, xmlDocPtr doc, xmlNodePtr tree,\n                     int skipRoot) {\n    xmlNodePtr cur;\n    int ret = 0;\n    int i, start;\n\n    if ((doc == NULL) || (tree == NULL) || (tree->type == XML_NAMESPACE_DECL))\n\treturn(-1);\n    if ((skipRoot) && (tree->children == NULL))\n        return(-1);\n    if (ctxt == NULL)\n\treturn(-1);\n\n    if (doc->URL != NULL) {\n\tret = xmlXIncludeURLPush(ctxt, doc->URL);\n\tif (ret < 0)\n\t    return(-1);\n    }\n    start = ctxt->incNr;\n\n    /*\n     * TODO: The phases must run separately for recursive inclusions.\n     *\n     * - Phase 1 should start with top-level XInclude nodes, load documents,\n     *   execute XPointer expressions, then process only the result nodes\n     *   (not whole document, see bug #324081) and only for phase 1\n     *   recursively. We will need a backreference from xmlNodes to\n     *   xmlIncludeRefs to detect references that were already visited.\n     *   This can also be used for proper cycle detection, see bug #344240.\n     *\n     * - Phase 2 should visit all top-level XInclude nodes and expand\n     *   possible subreferences in the replacement recursively.\n     *\n     * - Phase 3 should finally replace the top-level XInclude nodes.\n     *   It could also be run together with phase 2.\n     */\n\n    /*\n     * First phase: lookup the elements in the document\n     */\n    if (skipRoot)\n        cur = tree->children;\n    else\n        cur = tree;\n    do {\n\t/* TODO: need to work on entities -> stack */\n        if (xmlXIncludeTestNode(ctxt, cur) == 1) {\n#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n            /*\n             * Avoid superlinear expansion by limiting the total number\n             * of replacements.\n             */\n            if (ctxt->incTotal >= 20)\n                return(-1);\n#endif\n            ctxt->incTotal++;\n            xmlXIncludePreProcessNode(ctxt, cur);\n        } else if ((cur->children != NULL) &&\n                   ((cur->type == XML_DOCUMENT_NODE) ||\n                    (cur->type == XML_ELEMENT_NODE))) {\n            cur = cur->children;\n            continue;\n        }\n        do {\n            if (cur == tree)\n                break;\n            if (cur->next != NULL) {\n                cur = cur->next;\n                break;\n            }\n            cur = cur->parent;\n        } while (cur != NULL);\n    } while ((cur != NULL) && (cur != tree));\n\n    /*\n     * Second Phase : collect the infosets fragments\n     */\n    for (i = start;i < ctxt->incNr; i++) {\n        xmlXIncludeLoadNode(ctxt, i);\n\tret++;\n    }\n\n    /*\n     * Third phase: extend the original document infoset.\n     *\n     * Originally we bypassed the inclusion if there were any errors\n     * encountered on any of the XIncludes.  A bug was raised (bug\n     * 132588) requesting that we output the XIncludes without error,\n     * so the check for inc!=NULL || xptr!=NULL was put in.  This may\n     * give some other problems in the future, but for now it seems to\n     * work ok.\n     *\n     */\n    for (i = ctxt->incBase;i < ctxt->incNr; i++) {\n\tif ((ctxt->incTab[i]->inc != NULL) ||\n\t    (ctxt->incTab[i]->emptyFb != 0))\t/* (empty fallback) */\n\t    xmlXIncludeIncludeNode(ctxt, i);\n    }\n\n    if (doc->URL != NULL)\n\txmlXIncludeURLPop(ctxt);\n    return(ret);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147333,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "xfs_fs_fill_super(\n\tstruct super_block\t*sb,\n\tvoid\t\t\t*data,\n\tint\t\t\tsilent)\n{\n\tstruct inode\t\t*root;\n\tstruct xfs_mount\t*mp = NULL;\n\tint\t\t\tflags = 0, error = -ENOMEM;\n\n\t/*\n\t * allocate mp and do all low-level struct initializations before we\n\t * attach it to the super\n\t */\n\tmp = xfs_mount_alloc(sb);\n\tif (!mp)\n\t\tgoto out;\n\tsb->s_fs_info = mp;\n\n\terror = xfs_parseargs(mp, (char *)data);\n\tif (error)\n\t\tgoto out_free_fsname;\n\n\tsb_min_blocksize(sb, BBSIZE);\n\tsb->s_xattr = xfs_xattr_handlers;\n\tsb->s_export_op = &xfs_export_operations;\n#ifdef CONFIG_XFS_QUOTA\n\tsb->s_qcop = &xfs_quotactl_operations;\n\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP | QTYPE_MASK_PRJ;\n#endif\n\tsb->s_op = &xfs_super_operations;\n\n\t/*\n\t * Delay mount work if the debug hook is set. This is debug\n\t * instrumention to coordinate simulation of xfs mount failures with\n\t * VFS superblock operations\n\t */\n\tif (xfs_globals.mount_delay) {\n\t\txfs_notice(mp, \"Delaying mount for %d seconds.\",\n\t\t\txfs_globals.mount_delay);\n\t\tmsleep(xfs_globals.mount_delay * 1000);\n\t}\n\n\tif (silent)\n\t\tflags |= XFS_MFSI_QUIET;\n\n\terror = xfs_open_devices(mp);\n\tif (error)\n\t\tgoto out_free_fsname;\n\n\terror = xfs_init_mount_workqueues(mp);\n\tif (error)\n\t\tgoto out_close_devices;\n\n\terror = xfs_init_percpu_counters(mp);\n\tif (error)\n\t\tgoto out_destroy_workqueues;\n\n\t/* Allocate stats memory before we do operations that might use it */\n\tmp->m_stats.xs_stats = alloc_percpu(struct xfsstats);\n\tif (!mp->m_stats.xs_stats) {\n\t\terror = -ENOMEM;\n\t\tgoto out_destroy_counters;\n\t}\n\n\terror = xfs_readsb(mp, flags);\n\tif (error)\n\t\tgoto out_free_stats;\n\n\terror = xfs_finish_flags(mp);\n\tif (error)\n\t\tgoto out_free_sb;\n\n\terror = xfs_setup_devices(mp);\n\tif (error)\n\t\tgoto out_free_sb;\n\n\terror = xfs_filestream_mount(mp);\n\tif (error)\n\t\tgoto out_free_sb;\n\n\t/*\n\t * we must configure the block size in the superblock before we run the\n\t * full mount process as the mount process can lookup and cache inodes.\n\t */\n\tsb->s_magic = XFS_SB_MAGIC;\n\tsb->s_blocksize = mp->m_sb.sb_blocksize;\n\tsb->s_blocksize_bits = ffs(sb->s_blocksize) - 1;\n\tsb->s_maxbytes = xfs_max_file_offset(sb->s_blocksize_bits);\n\tsb->s_max_links = XFS_MAXLINK;\n\tsb->s_time_gran = 1;\n\tset_posix_acl_flag(sb);\n\n\t/* version 5 superblocks support inode version counters. */\n\tif (XFS_SB_VERSION_NUM(&mp->m_sb) == XFS_SB_VERSION_5)\n\t\tsb->s_flags |= SB_I_VERSION;\n\n\tif (mp->m_flags & XFS_MOUNT_DAX) {\n\t\txfs_warn(mp,\n\t\t\"DAX enabled. Warning: EXPERIMENTAL, use at your own risk\");\n\n\t\terror = bdev_dax_supported(sb, sb->s_blocksize);\n\t\tif (error) {\n\t\t\txfs_alert(mp,\n\t\t\t\"DAX unsupported by block device. Turning off DAX.\");\n\t\t\tmp->m_flags &= ~XFS_MOUNT_DAX;\n\t\t}\n\t\tif (xfs_sb_version_hasreflink(&mp->m_sb)) {\n\t\t\txfs_alert(mp,\n\t\t\"DAX and reflink cannot be used together!\");\n\t\t\terror = -EINVAL;\n\t\t\tgoto out_filestream_unmount;\n\t\t}\n\t}\n\n\tif (mp->m_flags & XFS_MOUNT_DISCARD) {\n\t\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\n\t\tif (!blk_queue_discard(q)) {\n\t\t\txfs_warn(mp, \"mounting with \\\"discard\\\" option, but \"\n\t\t\t\t\t\"the device does not support discard\");\n\t\t\tmp->m_flags &= ~XFS_MOUNT_DISCARD;\n\t\t}\n\t}\n\n\tif (xfs_sb_version_hasreflink(&mp->m_sb) && mp->m_sb.sb_rblocks) {\n\t\txfs_alert(mp,\n\t\"reflink not compatible with realtime device!\");\n\t\terror = -EINVAL;\n\t\tgoto out_filestream_unmount;\n\t}\n\n\tif (xfs_sb_version_hasrmapbt(&mp->m_sb) && mp->m_sb.sb_rblocks) {\n\t\txfs_alert(mp,\n\t\"reverse mapping btree not compatible with realtime device!\");\n\t\terror = -EINVAL;\n\t\tgoto out_filestream_unmount;\n\t}\n\n\terror = xfs_mountfs(mp);\n\tif (error)\n\t\tgoto out_filestream_unmount;\n\n\troot = igrab(VFS_I(mp->m_rootip));\n\tif (!root) {\n\t\terror = -ENOENT;\n\t\tgoto out_unmount;\n\t}\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root) {\n\t\terror = -ENOMEM;\n\t\tgoto out_unmount;\n\t}\n\n\treturn 0;\n\n out_filestream_unmount:\n\txfs_filestream_unmount(mp);\n out_free_sb:\n\txfs_freesb(mp);\n out_free_stats:\n\tfree_percpu(mp->m_stats.xs_stats);\n out_destroy_counters:\n\txfs_destroy_percpu_counters(mp);\n out_destroy_workqueues:\n\txfs_destroy_mount_workqueues(mp);\n out_close_devices:\n\txfs_close_devices(mp);\n out_free_fsname:\n\txfs_free_fsname(mp);\n\tkfree(mp);\n out:\n\treturn error;\n\n out_unmount:\n\txfs_filestream_unmount(mp);\n\txfs_unmountfs(mp);\n\tgoto out_free_sb;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147388,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "xfs_fs_fill_super(\n\tstruct super_block\t*sb,\n\tvoid\t\t\t*data,\n\tint\t\t\tsilent)\n{\n\tstruct inode\t\t*root;\n\tstruct xfs_mount\t*mp = NULL;\n\tint\t\t\tflags = 0, error = -ENOMEM;\n\n\t/*\n\t * allocate mp and do all low-level struct initializations before we\n\t * attach it to the super\n\t */\n\tmp = xfs_mount_alloc(sb);\n\tif (!mp)\n\t\tgoto out;\n\tsb->s_fs_info = mp;\n\n\terror = xfs_parseargs(mp, (char *)data);\n\tif (error)\n\t\tgoto out_free_fsname;\n\n\tsb_min_blocksize(sb, BBSIZE);\n\tsb->s_xattr = xfs_xattr_handlers;\n\tsb->s_export_op = &xfs_export_operations;\n#ifdef CONFIG_XFS_QUOTA\n\tsb->s_qcop = &xfs_quotactl_operations;\n\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP | QTYPE_MASK_PRJ;\n#endif\n\tsb->s_op = &xfs_super_operations;\n\n\t/*\n\t * Delay mount work if the debug hook is set. This is debug\n\t * instrumention to coordinate simulation of xfs mount failures with\n\t * VFS superblock operations\n\t */\n\tif (xfs_globals.mount_delay) {\n\t\txfs_notice(mp, \"Delaying mount for %d seconds.\",\n\t\t\txfs_globals.mount_delay);\n\t\tmsleep(xfs_globals.mount_delay * 1000);\n\t}\n\n\tif (silent)\n\t\tflags |= XFS_MFSI_QUIET;\n\n\terror = xfs_open_devices(mp);\n\tif (error)\n\t\tgoto out_free_fsname;\n\n\terror = xfs_init_mount_workqueues(mp);\n\tif (error)\n\t\tgoto out_close_devices;\n\n\terror = xfs_init_percpu_counters(mp);\n\tif (error)\n\t\tgoto out_destroy_workqueues;\n\n\t/* Allocate stats memory before we do operations that might use it */\n\tmp->m_stats.xs_stats = alloc_percpu(struct xfsstats);\n\tif (!mp->m_stats.xs_stats) {\n\t\terror = -ENOMEM;\n\t\tgoto out_destroy_counters;\n\t}\n\n\terror = xfs_readsb(mp, flags);\n\tif (error)\n\t\tgoto out_free_stats;\n\n\terror = xfs_finish_flags(mp);\n\tif (error)\n\t\tgoto out_free_sb;\n\n\terror = xfs_setup_devices(mp);\n\tif (error)\n\t\tgoto out_free_sb;\n\n\terror = xfs_filestream_mount(mp);\n\tif (error)\n\t\tgoto out_free_sb;\n\n\t/*\n\t * we must configure the block size in the superblock before we run the\n\t * full mount process as the mount process can lookup and cache inodes.\n\t */\n\tsb->s_magic = XFS_SB_MAGIC;\n\tsb->s_blocksize = mp->m_sb.sb_blocksize;\n\tsb->s_blocksize_bits = ffs(sb->s_blocksize) - 1;\n\tsb->s_maxbytes = xfs_max_file_offset(sb->s_blocksize_bits);\n\tsb->s_max_links = XFS_MAXLINK;\n\tsb->s_time_gran = 1;\n\tset_posix_acl_flag(sb);\n\n\t/* version 5 superblocks support inode version counters. */\n\tif (XFS_SB_VERSION_NUM(&mp->m_sb) == XFS_SB_VERSION_5)\n\t\tsb->s_flags |= SB_I_VERSION;\n\n\tif (mp->m_flags & XFS_MOUNT_DAX) {\n\t\txfs_warn(mp,\n\t\t\"DAX enabled. Warning: EXPERIMENTAL, use at your own risk\");\n\n\t\terror = bdev_dax_supported(sb, sb->s_blocksize);\n\t\tif (error) {\n\t\t\txfs_alert(mp,\n\t\t\t\"DAX unsupported by block device. Turning off DAX.\");\n\t\t\tmp->m_flags &= ~XFS_MOUNT_DAX;\n\t\t}\n\t\tif (xfs_sb_version_hasreflink(&mp->m_sb)) {\n\t\t\txfs_alert(mp,\n\t\t\"DAX and reflink cannot be used together!\");\n\t\t\terror = -EINVAL;\n\t\t\tgoto out_filestream_unmount;\n\t\t}\n\t}\n\n\tif (mp->m_flags & XFS_MOUNT_DISCARD) {\n\t\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\n\t\tif (!blk_queue_discard(q)) {\n\t\t\txfs_warn(mp, \"mounting with \\\"discard\\\" option, but \"\n\t\t\t\t\t\"the device does not support discard\");\n\t\t\tmp->m_flags &= ~XFS_MOUNT_DISCARD;\n\t\t}\n\t}\n\n\tif (xfs_sb_version_hasreflink(&mp->m_sb) && mp->m_sb.sb_rblocks) {\n\t\txfs_alert(mp,\n\t\"reflink not compatible with realtime device!\");\n\t\terror = -EINVAL;\n\t\tgoto out_filestream_unmount;\n\t}\n\n\tif (xfs_sb_version_hasrmapbt(&mp->m_sb) && mp->m_sb.sb_rblocks) {\n\t\txfs_alert(mp,\n\t\"reverse mapping btree not compatible with realtime device!\");\n\t\terror = -EINVAL;\n\t\tgoto out_filestream_unmount;\n\t}\n\n\terror = xfs_mountfs(mp);\n\tif (error)\n\t\tgoto out_filestream_unmount;\n\n\troot = igrab(VFS_I(mp->m_rootip));\n\tif (!root) {\n\t\terror = -ENOENT;\n\t\tgoto out_unmount;\n\t}\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root) {\n\t\terror = -ENOMEM;\n\t\tgoto out_unmount;\n\t}\n\n\treturn 0;\n\n out_filestream_unmount:\n\txfs_filestream_unmount(mp);\n out_free_sb:\n\txfs_freesb(mp);\n out_free_stats:\n\tfree_percpu(mp->m_stats.xs_stats);\n out_destroy_counters:\n\txfs_destroy_percpu_counters(mp);\n out_destroy_workqueues:\n\txfs_destroy_mount_workqueues(mp);\n out_close_devices:\n\txfs_close_devices(mp);\n out_free_fsname:\n\tsb->s_fs_info = NULL;\n\txfs_free_fsname(mp);\n\tkfree(mp);\n out:\n\treturn error;\n\n out_unmount:\n\txfs_filestream_unmount(mp);\n\txfs_unmountfs(mp);\n\tgoto out_free_sb;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147389,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static void parseAndPrintFile(char *filename, xmlParserCtxtPtr rectxt) {\n    xmlDocPtr doc = NULL;\n#ifdef LIBXML_TREE_ENABLED\n    xmlDocPtr tmp;\n#endif /* LIBXML_TREE_ENABLED */\n\n    if ((timing) && (!repeat))\n\tstartTimer();\n\n\n#ifdef LIBXML_TREE_ENABLED\n    if (filename == NULL) {\n\tif (generate) {\n\t    xmlNodePtr n;\n\n\t    doc = xmlNewDoc(BAD_CAST \"1.0\");\n\t    n = xmlNewDocNode(doc, NULL, BAD_CAST \"info\", NULL);\n\t    xmlNodeSetContent(n, BAD_CAST \"abc\");\n\t    xmlDocSetRootElement(doc, n);\n\t}\n    }\n#endif /* LIBXML_TREE_ENABLED */\n#ifdef LIBXML_HTML_ENABLED\n#ifdef LIBXML_PUSH_ENABLED\n    else if ((html) && (push)) {\n        FILE *f;\n\n        if ((filename[0] == '-') && (filename[1] == 0)) {\n            f = stdin;\n        } else {\n#if defined(_WIN32) || defined (__DJGPP__) && !defined (__CYGWIN__)\n\t    f = fopen(filename, \"rb\");\n#elif defined(__OS400__)\n\t    f = fopen(filename, \"rb\");\n#else\n\t    f = fopen(filename, \"r\");\n#endif\n        }\n        if (f != NULL) {\n            int res;\n            char chars[4096];\n            htmlParserCtxtPtr ctxt;\n\n            res = fread(chars, 1, 4, f);\n            if (res > 0) {\n                ctxt = htmlCreatePushParserCtxt(NULL, NULL,\n                            chars, res, filename, XML_CHAR_ENCODING_NONE);\n                xmlCtxtUseOptions(ctxt, options);\n                while ((res = fread(chars, 1, pushsize, f)) > 0) {\n                    htmlParseChunk(ctxt, chars, res, 0);\n                }\n                htmlParseChunk(ctxt, chars, 0, 1);\n                doc = ctxt->myDoc;\n                htmlFreeParserCtxt(ctxt);\n            }\n            fclose(f);\n        }\n    }\n#endif /* LIBXML_PUSH_ENABLED */\n#ifdef HAVE_MMAP\n    else if ((html) && (memory)) {\n\tint fd;\n\tstruct stat info;\n\tconst char *base;\n\tif (stat(filename, &info) < 0)\n\t    return;\n\tif ((fd = open(filename, O_RDONLY)) < 0)\n\t    return;\n\tbase = mmap(NULL, info.st_size, PROT_READ, MAP_SHARED, fd, 0) ;\n\tif (base == (void *) MAP_FAILED) {\n\t    close(fd);\n\t    fprintf(stderr, \"mmap failure for file %s\\n\", filename);\n\t    progresult = XMLLINT_ERR_RDFILE;\n\t    return;\n\t}\n\n\tdoc = htmlReadMemory((char *) base, info.st_size, filename,\n\t                     NULL, options);\n\n\tmunmap((char *) base, info.st_size);\n\tclose(fd);\n    }\n#endif\n    else if (html) {\n\tdoc = htmlReadFile(filename, NULL, options);\n    }\n#endif /* LIBXML_HTML_ENABLED */\n    else {\n#ifdef LIBXML_PUSH_ENABLED\n\t/*\n\t * build an XML tree from a string;\n\t */\n\tif (push) {\n\t    FILE *f;\n\n\t    /* '-' Usually means stdin -<sven@zen.org> */\n\t    if ((filename[0] == '-') && (filename[1] == 0)) {\n\t      f = stdin;\n\t    } else {\n#if defined(_WIN32) || defined (__DJGPP__) && !defined (__CYGWIN__)\n\t\tf = fopen(filename, \"rb\");\n#elif defined(__OS400__)\n\t\tf = fopen(filename, \"rb\");\n#else\n\t\tf = fopen(filename, \"r\");\n#endif\n\t    }\n\t    if (f != NULL) {\n\t\tint ret;\n\t        int res, size = 1024;\n\t        char chars[1024];\n                xmlParserCtxtPtr ctxt;\n\n\t\t/* if (repeat) size = 1024; */\n\t\tres = fread(chars, 1, 4, f);\n\t\tif (res > 0) {\n\t\t    ctxt = xmlCreatePushParserCtxt(NULL, NULL,\n\t\t                chars, res, filename);\n\t\t    xmlCtxtUseOptions(ctxt, options);\n\t\t    while ((res = fread(chars, 1, size, f)) > 0) {\n\t\t\txmlParseChunk(ctxt, chars, res, 0);\n\t\t    }\n\t\t    xmlParseChunk(ctxt, chars, 0, 1);\n\t\t    doc = ctxt->myDoc;\n\t\t    ret = ctxt->wellFormed;\n\t\t    xmlFreeParserCtxt(ctxt);\n\t\t    if ((!ret) && (!recovery)) {\n\t\t\txmlFreeDoc(doc);\n\t\t\tdoc = NULL;\n\t\t    }\n\t        }\n                if (f != stdin)\n                    fclose(f);\n\t    }\n\t} else\n#endif /* LIBXML_PUSH_ENABLED */\n        if (testIO) {\n\t    if ((filename[0] == '-') && (filename[1] == 0)) {\n\t        doc = xmlReadFd(0, NULL, NULL, options);\n\t    } else {\n\t        FILE *f;\n\n#if defined(_WIN32) || defined (__DJGPP__) && !defined (__CYGWIN__)\n\t\tf = fopen(filename, \"rb\");\n#elif defined(__OS400__)\n\t\tf = fopen(filename, \"rb\");\n#else\n\t\tf = fopen(filename, \"r\");\n#endif\n\t\tif (f != NULL) {\n\t\t    if (rectxt == NULL)\n\t\t\tdoc = xmlReadIO(myRead, myClose, f, filename, NULL,\n                                        options);\n\t\t    else\n\t\t\tdoc = xmlCtxtReadIO(rectxt, myRead, myClose, f,\n\t\t\t\t\t    filename, NULL, options);\n\t\t} else\n\t\t    doc = NULL;\n\t    }\n\t} else if (htmlout) {\n\t    xmlParserCtxtPtr ctxt;\n\n\t    if (rectxt == NULL)\n\t\tctxt = xmlNewParserCtxt();\n\t    else\n\t        ctxt = rectxt;\n\t    if (ctxt == NULL) {\n\t        doc = NULL;\n\t    } else {\n\t        ctxt->sax->error = xmlHTMLError;\n\t        ctxt->sax->warning = xmlHTMLWarning;\n\t        ctxt->vctxt.error = xmlHTMLValidityError;\n\t        ctxt->vctxt.warning = xmlHTMLValidityWarning;\n\n\t\tdoc = xmlCtxtReadFile(ctxt, filename, NULL, options);\n\n\t\tif (rectxt == NULL)\n\t\t    xmlFreeParserCtxt(ctxt);\n\t    }\n#ifdef HAVE_MMAP\n\t} else if (memory) {\n\t    int fd;\n\t    struct stat info;\n\t    const char *base;\n\t    if (stat(filename, &info) < 0)\n\t\treturn;\n\t    if ((fd = open(filename, O_RDONLY)) < 0)\n\t\treturn;\n\t    base = mmap(NULL, info.st_size, PROT_READ, MAP_SHARED, fd, 0) ;\n\t    if (base == (void *) MAP_FAILED) {\n\t        close(fd);\n\t        fprintf(stderr, \"mmap failure for file %s\\n\", filename);\n\t\tprogresult = XMLLINT_ERR_RDFILE;\n\t        return;\n\t    }\n\n\t    if (rectxt == NULL)\n\t\tdoc = xmlReadMemory((char *) base, info.st_size,\n\t\t                    filename, NULL, options);\n\t    else\n\t\tdoc = xmlCtxtReadMemory(rectxt, (char *) base, info.st_size,\n\t\t\t                filename, NULL, options);\n\n\t    munmap((char *) base, info.st_size);\n\t    close(fd);\n#endif\n#ifdef LIBXML_VALID_ENABLED\n\t} else if (valid) {\n\t    xmlParserCtxtPtr ctxt = NULL;\n\n\t    if (rectxt == NULL)\n\t\tctxt = xmlNewParserCtxt();\n\t    else\n\t        ctxt = rectxt;\n\t    if (ctxt == NULL) {\n\t        doc = NULL;\n\t    } else {\n\t\tdoc = xmlCtxtReadFile(ctxt, filename, NULL, options);\n\n\t\tif (ctxt->valid == 0)\n\t\t    progresult = XMLLINT_ERR_RDFILE;\n\t\tif (rectxt == NULL)\n\t\t    xmlFreeParserCtxt(ctxt);\n\t    }\n#endif /* LIBXML_VALID_ENABLED */\n\t} else {\n\t    if (rectxt != NULL)\n\t        doc = xmlCtxtReadFile(rectxt, filename, NULL, options);\n\t    else {\n#ifdef LIBXML_SAX1_ENABLED\n                if (sax1)\n\t\t    doc = xmlParseFile(filename);\n\t\telse\n#endif /* LIBXML_SAX1_ENABLED */\n\t\tdoc = xmlReadFile(filename, NULL, options);\n\t    }\n\t}\n    }\n\n    /*\n     * If we don't have a document we might as well give up.  Do we\n     * want an error message here?  <sven@zen.org> */\n    if (doc == NULL) {\n\tprogresult = XMLLINT_ERR_UNCLASS;\n\treturn;\n    }\n\n    if ((timing) && (!repeat)) {\n\tendTimer(\"Parsing\");\n    }\n\n    /*\n     * Remove DOCTYPE nodes\n     */\n    if (dropdtd) {\n\txmlDtdPtr dtd;\n\n\tdtd = xmlGetIntSubset(doc);\n\tif (dtd != NULL) {\n\t    xmlUnlinkNode((xmlNodePtr)dtd);\n\t    xmlFreeDtd(dtd);\n\t}\n    }\n\n#ifdef LIBXML_XINCLUDE_ENABLED\n    if (xinclude) {\n\tif ((timing) && (!repeat)) {\n\t    startTimer();\n\t}\n\tif (xmlXIncludeProcessFlags(doc, options) < 0)\n\t    progresult = XMLLINT_ERR_UNCLASS;\n\tif ((timing) && (!repeat)) {\n\t    endTimer(\"Xinclude processing\");\n\t}\n    }\n#endif\n\n#ifdef LIBXML_XPATH_ENABLED\n    if (xpathquery != NULL) {\n        doXPathQuery(doc, xpathquery);\n    }\n#endif\n\n#ifdef LIBXML_DEBUG_ENABLED\n#ifdef LIBXML_XPATH_ENABLED\n    /*\n     * shell interaction\n     */\n    if (shell) {\n        xmlXPathOrderDocElems(doc);\n        xmlShell(doc, filename, xmlShellReadline, stdout);\n    }\n#endif\n#endif\n\n#ifdef LIBXML_TREE_ENABLED\n    /*\n     * test intermediate copy if needed.\n     */\n    if (copy) {\n        tmp = doc;\n\tif (timing) {\n\t    startTimer();\n\t}\n\tdoc = xmlCopyDoc(doc, 1);\n\tif (timing) {\n\t    endTimer(\"Copying\");\n\t}\n\tif (timing) {\n\t    startTimer();\n\t}\n\txmlFreeDoc(tmp);\n\tif (timing) {\n\t    endTimer(\"Freeing original\");\n\t}\n    }\n#endif /* LIBXML_TREE_ENABLED */\n\n#ifdef LIBXML_VALID_ENABLED\n    if ((insert) && (!html)) {\n        const xmlChar* list[256];\n\tint nb, i;\n\txmlNodePtr node;\n\n\tif (doc->children != NULL) {\n\t    node = doc->children;\n\t    while ((node != NULL) && (node->last == NULL)) node = node->next;\n\t    if (node != NULL) {\n\t\tnb = xmlValidGetValidElements(node->last, NULL, list, 256);\n\t\tif (nb < 0) {\n\t\t    fprintf(stderr, \"could not get valid list of elements\\n\");\n\t\t} else if (nb == 0) {\n\t\t    fprintf(stderr, \"No element can be inserted under root\\n\");\n\t\t} else {\n\t\t    fprintf(stderr, \"%d element types can be inserted under root:\\n\",\n\t\t           nb);\n\t\t    for (i = 0;i < nb;i++) {\n\t\t\t fprintf(stderr, \"%s\\n\", (char *) list[i]);\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }else\n#endif /* LIBXML_VALID_ENABLED */\n#ifdef LIBXML_READER_ENABLED\n    if (walker) {\n        walkDoc(doc);\n    }\n#endif /* LIBXML_READER_ENABLED */\n#ifdef LIBXML_OUTPUT_ENABLED\n    if (noout == 0) {\n        int ret;\n\n\t/*\n\t * print it.\n\t */\n#ifdef LIBXML_DEBUG_ENABLED\n\tif (!debug) {\n#endif\n\t    if ((timing) && (!repeat)) {\n\t\tstartTimer();\n\t    }\n#ifdef LIBXML_HTML_ENABLED\n            if ((html) && (!xmlout)) {\n\t\tif (compress) {\n\t\t    htmlSaveFile(output ? output : \"-\", doc);\n\t\t}\n\t\telse if (encoding != NULL) {\n\t\t    if (format == 1) {\n\t\t\thtmlSaveFileFormat(output ? output : \"-\", doc, encoding, 1);\n\t\t    }\n\t\t    else {\n\t\t\thtmlSaveFileFormat(output ? output : \"-\", doc, encoding, 0);\n\t\t    }\n\t\t}\n\t\telse if (format == 1) {\n\t\t    htmlSaveFileFormat(output ? output : \"-\", doc, NULL, 1);\n\t\t}\n\t\telse {\n\t\t    FILE *out;\n\t\t    if (output == NULL)\n\t\t\tout = stdout;\n\t\t    else {\n\t\t\tout = fopen(output,\"wb\");\n\t\t    }\n\t\t    if (out != NULL) {\n\t\t\tif (htmlDocDump(out, doc) < 0)\n\t\t\t    progresult = XMLLINT_ERR_OUT;\n\n\t\t\tif (output != NULL)\n\t\t\t    fclose(out);\n\t\t    } else {\n\t\t\tfprintf(stderr, \"failed to open %s\\n\", output);\n\t\t\tprogresult = XMLLINT_ERR_OUT;\n\t\t    }\n\t\t}\n\t\tif ((timing) && (!repeat)) {\n\t\t    endTimer(\"Saving\");\n\t\t}\n\t    } else\n#endif\n#ifdef LIBXML_C14N_ENABLED\n            if (canonical) {\n\t        xmlChar *result = NULL;\n\t\tint size;\n\n\t\tsize = xmlC14NDocDumpMemory(doc, NULL, XML_C14N_1_0, NULL, 1, &result);\n\t\tif (size >= 0) {\n\t\t    if (write(1, result, size) == -1) {\n\t\t        fprintf(stderr, \"Can't write data\\n\");\n\t\t    }\n\t\t    xmlFree(result);\n\t\t} else {\n\t\t    fprintf(stderr, \"Failed to canonicalize\\n\");\n\t\t    progresult = XMLLINT_ERR_OUT;\n\t\t}\n\t    } else if (canonical_11) {\n\t        xmlChar *result = NULL;\n\t\tint size;\n\n\t\tsize = xmlC14NDocDumpMemory(doc, NULL, XML_C14N_1_1, NULL, 1, &result);\n\t\tif (size >= 0) {\n\t\t    if (write(1, result, size) == -1) {\n\t\t        fprintf(stderr, \"Can't write data\\n\");\n\t\t    }\n\t\t    xmlFree(result);\n\t\t} else {\n\t\t    fprintf(stderr, \"Failed to canonicalize\\n\");\n\t\t    progresult = XMLLINT_ERR_OUT;\n\t\t}\n\t    } else\n            if (exc_canonical) {\n\t        xmlChar *result = NULL;\n\t\tint size;\n\n\t\tsize = xmlC14NDocDumpMemory(doc, NULL, XML_C14N_EXCLUSIVE_1_0, NULL, 1, &result);\n\t\tif (size >= 0) {\n\t\t    if (write(1, result, size) == -1) {\n\t\t        fprintf(stderr, \"Can't write data\\n\");\n\t\t    }\n\t\t    xmlFree(result);\n\t\t} else {\n\t\t    fprintf(stderr, \"Failed to canonicalize\\n\");\n\t\t    progresult = XMLLINT_ERR_OUT;\n\t\t}\n\t    } else\n#endif\n#ifdef HAVE_MMAP\n\t    if (memory) {\n\t\txmlChar *result;\n\t\tint len;\n\n\t\tif (encoding != NULL) {\n\t\t    if (format == 1) {\n\t\t        xmlDocDumpFormatMemoryEnc(doc, &result, &len, encoding, 1);\n\t\t    } else {\n\t\t\txmlDocDumpMemoryEnc(doc, &result, &len, encoding);\n\t\t    }\n\t\t} else {\n\t\t    if (format == 1)\n\t\t\txmlDocDumpFormatMemory(doc, &result, &len, 1);\n\t\t    else\n\t\t\txmlDocDumpMemory(doc, &result, &len);\n\t\t}\n\t\tif (result == NULL) {\n\t\t    fprintf(stderr, \"Failed to save\\n\");\n\t\t    progresult = XMLLINT_ERR_OUT;\n\t\t} else {\n\t\t    if (write(1, result, len) == -1) {\n\t\t        fprintf(stderr, \"Can't write data\\n\");\n\t\t    }\n\t\t    xmlFree(result);\n\t\t}\n\n\t    } else\n#endif /* HAVE_MMAP */\n\t    if (compress) {\n\t\txmlSaveFile(output ? output : \"-\", doc);\n\t    } else if (oldout) {\n\t        if (encoding != NULL) {\n\t\t    if (format == 1) {\n\t\t\tret = xmlSaveFormatFileEnc(output ? output : \"-\", doc,\n\t\t\t\t\t\t   encoding, 1);\n\t\t    }\n\t\t    else {\n\t\t\tret = xmlSaveFileEnc(output ? output : \"-\", doc,\n\t\t\t                     encoding);\n\t\t    }\n\t\t    if (ret < 0) {\n\t\t\tfprintf(stderr, \"failed save to %s\\n\",\n\t\t\t\toutput ? output : \"-\");\n\t\t\tprogresult = XMLLINT_ERR_OUT;\n\t\t    }\n\t\t} else if (format == 1) {\n\t\t    ret = xmlSaveFormatFile(output ? output : \"-\", doc, 1);\n\t\t    if (ret < 0) {\n\t\t\tfprintf(stderr, \"failed save to %s\\n\",\n\t\t\t\toutput ? output : \"-\");\n\t\t\tprogresult = XMLLINT_ERR_OUT;\n\t\t    }\n\t\t} else {\n\t\t    FILE *out;\n\t\t    if (output == NULL)\n\t\t\tout = stdout;\n\t\t    else {\n\t\t\tout = fopen(output,\"wb\");\n\t\t    }\n\t\t    if (out != NULL) {\n\t\t\tif (xmlDocDump(out, doc) < 0)\n\t\t\t    progresult = XMLLINT_ERR_OUT;\n\n\t\t\tif (output != NULL)\n\t\t\t    fclose(out);\n\t\t    } else {\n\t\t\tfprintf(stderr, \"failed to open %s\\n\", output);\n\t\t\tprogresult = XMLLINT_ERR_OUT;\n\t\t    }\n\t\t}\n\t    } else {\n\t        xmlSaveCtxtPtr ctxt;\n\t\tint saveOpts = 0;\n\n                if (format == 1)\n\t\t    saveOpts |= XML_SAVE_FORMAT;\n                else if (format == 2)\n                    saveOpts |= XML_SAVE_WSNONSIG;\n\n#if defined(LIBXML_HTML_ENABLED) || defined(LIBXML_VALID_ENABLED)\n                if (xmlout)\n                    saveOpts |= XML_SAVE_AS_XML;\n#endif\n\n\t\tif (output == NULL)\n\t\t    ctxt = xmlSaveToFd(1, encoding, saveOpts);\n\t\telse\n\t\t    ctxt = xmlSaveToFilename(output, encoding, saveOpts);\n\n\t\tif (ctxt != NULL) {\n\t\t    if (xmlSaveDoc(ctxt, doc) < 0) {\n\t\t\tfprintf(stderr, \"failed save to %s\\n\",\n\t\t\t\toutput ? output : \"-\");\n\t\t\tprogresult = XMLLINT_ERR_OUT;\n\t\t    }\n\t\t    xmlSaveClose(ctxt);\n\t\t} else {\n\t\t    progresult = XMLLINT_ERR_OUT;\n\t\t}\n\t    }\n\t    if ((timing) && (!repeat)) {\n\t\tendTimer(\"Saving\");\n\t    }\n#ifdef LIBXML_DEBUG_ENABLED\n\t} else {\n\t    FILE *out;\n\t    if (output == NULL)\n\t        out = stdout;\n\t    else {\n\t\tout = fopen(output,\"wb\");\n\t    }\n\t    if (out != NULL) {\n\t\txmlDebugDumpDocument(out, doc);\n\n\t\tif (output != NULL)\n\t\t    fclose(out);\n\t    } else {\n\t\tfprintf(stderr, \"failed to open %s\\n\", output);\n\t\tprogresult = XMLLINT_ERR_OUT;\n\t    }\n\t}\n#endif\n    }\n#endif /* LIBXML_OUTPUT_ENABLED */\n\n#ifdef LIBXML_VALID_ENABLED\n    /*\n     * A posteriori validation test\n     */\n    if ((dtdvalid != NULL) || (dtdvalidfpi != NULL)) {\n\txmlDtdPtr dtd;\n\n\tif ((timing) && (!repeat)) {\n\t    startTimer();\n\t}\n\tif (dtdvalid != NULL)\n\t    dtd = xmlParseDTD(NULL, (const xmlChar *)dtdvalid);\n\telse\n\t    dtd = xmlParseDTD((const xmlChar *)dtdvalidfpi, NULL);\n\tif ((timing) && (!repeat)) {\n\t    endTimer(\"Parsing DTD\");\n\t}\n\tif (dtd == NULL) {\n\t    if (dtdvalid != NULL)\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"Could not parse DTD %s\\n\", dtdvalid);\n\t    else\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"Could not parse DTD %s\\n\", dtdvalidfpi);\n\t    progresult = XMLLINT_ERR_DTD;\n\t} else {\n\t    xmlValidCtxtPtr cvp;\n\n\t    if ((cvp = xmlNewValidCtxt()) == NULL) {\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"Couldn't allocate validation context\\n\");\n\t\texit(-1);\n\t    }\n\t    cvp->userData = NULL;\n\t    cvp->error    = xmlGenericError;\n\t    cvp->warning  = xmlGenericError;\n\n\t    if ((timing) && (!repeat)) {\n\t\tstartTimer();\n\t    }\n\t    if (!xmlValidateDtd(cvp, doc, dtd)) {\n\t\tif (dtdvalid != NULL)\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t    \"Document %s does not validate against %s\\n\",\n\t\t\t    filename, dtdvalid);\n\t\telse\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t    \"Document %s does not validate against %s\\n\",\n\t\t\t    filename, dtdvalidfpi);\n\t\tprogresult = XMLLINT_ERR_VALID;\n\t    }\n\t    if ((timing) && (!repeat)) {\n\t\tendTimer(\"Validating against DTD\");\n\t    }\n\t    xmlFreeValidCtxt(cvp);\n\t    xmlFreeDtd(dtd);\n\t}\n    } else if (postvalid) {\n\txmlValidCtxtPtr cvp;\n\n\tif ((cvp = xmlNewValidCtxt()) == NULL) {\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"Couldn't allocate validation context\\n\");\n\t    exit(-1);\n\t}\n\n\tif ((timing) && (!repeat)) {\n\t    startTimer();\n\t}\n\tcvp->userData = NULL;\n\tcvp->error    = xmlGenericError;\n\tcvp->warning  = xmlGenericError;\n\tif (!xmlValidateDocument(cvp, doc)) {\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"Document %s does not validate\\n\", filename);\n\t    progresult = XMLLINT_ERR_VALID;\n\t}\n\tif ((timing) && (!repeat)) {\n\t    endTimer(\"Validating\");\n\t}\n\txmlFreeValidCtxt(cvp);\n    }\n#endif /* LIBXML_VALID_ENABLED */\n#ifdef LIBXML_SCHEMATRON_ENABLED\n    if (wxschematron != NULL) {\n\txmlSchematronValidCtxtPtr ctxt;\n\tint ret;\n\tint flag;\n\n\tif ((timing) && (!repeat)) {\n\t    startTimer();\n\t}\n\n\tif (debug)\n\t    flag = XML_SCHEMATRON_OUT_XML;\n\telse\n\t    flag = XML_SCHEMATRON_OUT_TEXT;\n\tif (noout)\n\t    flag |= XML_SCHEMATRON_OUT_QUIET;\n\tctxt = xmlSchematronNewValidCtxt(wxschematron, flag);\n#if 0\n\txmlSchematronSetValidErrors(ctxt, xmlGenericError, xmlGenericError,\n                NULL);\n#endif\n\tret = xmlSchematronValidateDoc(ctxt, doc);\n\tif (ret == 0) {\n\t    if (!quiet) {\n\t        fprintf(stderr, \"%s validates\\n\", filename);\n\t    }\n\t} else if (ret > 0) {\n\t    fprintf(stderr, \"%s fails to validate\\n\", filename);\n\t    progresult = XMLLINT_ERR_VALID;\n\t} else {\n\t    fprintf(stderr, \"%s validation generated an internal error\\n\",\n\t\t   filename);\n\t    progresult = XMLLINT_ERR_VALID;\n\t}\n\txmlSchematronFreeValidCtxt(ctxt);\n\tif ((timing) && (!repeat)) {\n\t    endTimer(\"Validating\");\n\t}\n    }\n#endif\n#ifdef LIBXML_SCHEMAS_ENABLED\n    if (relaxngschemas != NULL) {\n\txmlRelaxNGValidCtxtPtr ctxt;\n\tint ret;\n\n\tif ((timing) && (!repeat)) {\n\t    startTimer();\n\t}\n\n\tctxt = xmlRelaxNGNewValidCtxt(relaxngschemas);\n\txmlRelaxNGSetValidErrors(ctxt, xmlGenericError, xmlGenericError, NULL);\n\tret = xmlRelaxNGValidateDoc(ctxt, doc);\n\tif (ret == 0) {\n\t    if (!quiet) {\n\t        fprintf(stderr, \"%s validates\\n\", filename);\n\t    }\n\t} else if (ret > 0) {\n\t    fprintf(stderr, \"%s fails to validate\\n\", filename);\n\t    progresult = XMLLINT_ERR_VALID;\n\t} else {\n\t    fprintf(stderr, \"%s validation generated an internal error\\n\",\n\t\t   filename);\n\t    progresult = XMLLINT_ERR_VALID;\n\t}\n\txmlRelaxNGFreeValidCtxt(ctxt);\n\tif ((timing) && (!repeat)) {\n\t    endTimer(\"Validating\");\n\t}\n    } else if (wxschemas != NULL) {\n\txmlSchemaValidCtxtPtr ctxt;\n\tint ret;\n\n\tif ((timing) && (!repeat)) {\n\t    startTimer();\n\t}\n\n\tctxt = xmlSchemaNewValidCtxt(wxschemas);\n\txmlSchemaSetValidErrors(ctxt, xmlGenericError, xmlGenericError, NULL);\n\tret = xmlSchemaValidateDoc(ctxt, doc);\n\tif (ret == 0) {\n\t    if (!quiet) {\n\t        fprintf(stderr, \"%s validates\\n\", filename);\n\t    }\n\t} else if (ret > 0) {\n\t    fprintf(stderr, \"%s fails to validate\\n\", filename);\n\t    progresult = XMLLINT_ERR_VALID;\n\t} else {\n\t    fprintf(stderr, \"%s validation generated an internal error\\n\",\n\t\t   filename);\n\t    progresult = XMLLINT_ERR_VALID;\n\t}\n\txmlSchemaFreeValidCtxt(ctxt);\n\tif ((timing) && (!repeat)) {\n\t    endTimer(\"Validating\");\n\t}\n    }\n#endif\n\n#ifdef LIBXML_DEBUG_ENABLED\n#if defined(LIBXML_HTML_ENABLED) || defined(LIBXML_VALID_ENABLED)\n    if ((debugent) && (!html))\n\txmlDebugDumpEntities(stderr, doc);\n#endif\n#endif\n\n    /*\n     * free it.\n     */\n    if ((timing) && (!repeat)) {\n\tstartTimer();\n    }\n    xmlFreeDoc(doc);\n    if ((timing) && (!repeat)) {\n\tendTimer(\"Freeing\");\n    }\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147400,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static void parseAndPrintFile(char *filename, xmlParserCtxtPtr rectxt) {\n    xmlDocPtr doc = NULL;\n#ifdef LIBXML_TREE_ENABLED\n    xmlDocPtr tmp;\n#endif /* LIBXML_TREE_ENABLED */\n\n    if ((timing) && (!repeat))\n\tstartTimer();\n\n\n#ifdef LIBXML_TREE_ENABLED\n    if (filename == NULL) {\n\tif (generate) {\n\t    xmlNodePtr n;\n\n\t    doc = xmlNewDoc(BAD_CAST \"1.0\");\n\t    n = xmlNewDocNode(doc, NULL, BAD_CAST \"info\", NULL);\n\t    xmlNodeSetContent(n, BAD_CAST \"abc\");\n\t    xmlDocSetRootElement(doc, n);\n\t}\n    }\n#endif /* LIBXML_TREE_ENABLED */\n#ifdef LIBXML_HTML_ENABLED\n#ifdef LIBXML_PUSH_ENABLED\n    else if ((html) && (push)) {\n        FILE *f;\n\n        if ((filename[0] == '-') && (filename[1] == 0)) {\n            f = stdin;\n        } else {\n#if defined(_WIN32) || defined (__DJGPP__) && !defined (__CYGWIN__)\n\t    f = fopen(filename, \"rb\");\n#elif defined(__OS400__)\n\t    f = fopen(filename, \"rb\");\n#else\n\t    f = fopen(filename, \"r\");\n#endif\n        }\n        if (f != NULL) {\n            int res;\n            char chars[4096];\n            htmlParserCtxtPtr ctxt;\n\n            res = fread(chars, 1, 4, f);\n            if (res > 0) {\n                ctxt = htmlCreatePushParserCtxt(NULL, NULL,\n                            chars, res, filename, XML_CHAR_ENCODING_NONE);\n                htmlCtxtUseOptions(ctxt, options);\n                while ((res = fread(chars, 1, pushsize, f)) > 0) {\n                    htmlParseChunk(ctxt, chars, res, 0);\n                }\n                htmlParseChunk(ctxt, chars, 0, 1);\n                doc = ctxt->myDoc;\n                htmlFreeParserCtxt(ctxt);\n            }\n            fclose(f);\n        }\n    }\n#endif /* LIBXML_PUSH_ENABLED */\n#ifdef HAVE_MMAP\n    else if ((html) && (memory)) {\n\tint fd;\n\tstruct stat info;\n\tconst char *base;\n\tif (stat(filename, &info) < 0)\n\t    return;\n\tif ((fd = open(filename, O_RDONLY)) < 0)\n\t    return;\n\tbase = mmap(NULL, info.st_size, PROT_READ, MAP_SHARED, fd, 0) ;\n\tif (base == (void *) MAP_FAILED) {\n\t    close(fd);\n\t    fprintf(stderr, \"mmap failure for file %s\\n\", filename);\n\t    progresult = XMLLINT_ERR_RDFILE;\n\t    return;\n\t}\n\n\tdoc = htmlReadMemory((char *) base, info.st_size, filename,\n\t                     NULL, options);\n\n\tmunmap((char *) base, info.st_size);\n\tclose(fd);\n    }\n#endif\n    else if (html) {\n\tdoc = htmlReadFile(filename, NULL, options);\n    }\n#endif /* LIBXML_HTML_ENABLED */\n    else {\n#ifdef LIBXML_PUSH_ENABLED\n\t/*\n\t * build an XML tree from a string;\n\t */\n\tif (push) {\n\t    FILE *f;\n\n\t    /* '-' Usually means stdin -<sven@zen.org> */\n\t    if ((filename[0] == '-') && (filename[1] == 0)) {\n\t      f = stdin;\n\t    } else {\n#if defined(_WIN32) || defined (__DJGPP__) && !defined (__CYGWIN__)\n\t\tf = fopen(filename, \"rb\");\n#elif defined(__OS400__)\n\t\tf = fopen(filename, \"rb\");\n#else\n\t\tf = fopen(filename, \"r\");\n#endif\n\t    }\n\t    if (f != NULL) {\n\t\tint ret;\n\t        int res, size = 1024;\n\t        char chars[1024];\n                xmlParserCtxtPtr ctxt;\n\n\t\t/* if (repeat) size = 1024; */\n\t\tres = fread(chars, 1, 4, f);\n\t\tif (res > 0) {\n\t\t    ctxt = xmlCreatePushParserCtxt(NULL, NULL,\n\t\t                chars, res, filename);\n\t\t    xmlCtxtUseOptions(ctxt, options);\n\t\t    while ((res = fread(chars, 1, size, f)) > 0) {\n\t\t\txmlParseChunk(ctxt, chars, res, 0);\n\t\t    }\n\t\t    xmlParseChunk(ctxt, chars, 0, 1);\n\t\t    doc = ctxt->myDoc;\n\t\t    ret = ctxt->wellFormed;\n\t\t    xmlFreeParserCtxt(ctxt);\n\t\t    if ((!ret) && (!recovery)) {\n\t\t\txmlFreeDoc(doc);\n\t\t\tdoc = NULL;\n\t\t    }\n\t        }\n                if (f != stdin)\n                    fclose(f);\n\t    }\n\t} else\n#endif /* LIBXML_PUSH_ENABLED */\n        if (testIO) {\n\t    if ((filename[0] == '-') && (filename[1] == 0)) {\n\t        doc = xmlReadFd(0, NULL, NULL, options);\n\t    } else {\n\t        FILE *f;\n\n#if defined(_WIN32) || defined (__DJGPP__) && !defined (__CYGWIN__)\n\t\tf = fopen(filename, \"rb\");\n#elif defined(__OS400__)\n\t\tf = fopen(filename, \"rb\");\n#else\n\t\tf = fopen(filename, \"r\");\n#endif\n\t\tif (f != NULL) {\n\t\t    if (rectxt == NULL)\n\t\t\tdoc = xmlReadIO(myRead, myClose, f, filename, NULL,\n                                        options);\n\t\t    else\n\t\t\tdoc = xmlCtxtReadIO(rectxt, myRead, myClose, f,\n\t\t\t\t\t    filename, NULL, options);\n\t\t} else\n\t\t    doc = NULL;\n\t    }\n\t} else if (htmlout) {\n\t    xmlParserCtxtPtr ctxt;\n\n\t    if (rectxt == NULL)\n\t\tctxt = xmlNewParserCtxt();\n\t    else\n\t        ctxt = rectxt;\n\t    if (ctxt == NULL) {\n\t        doc = NULL;\n\t    } else {\n\t        ctxt->sax->error = xmlHTMLError;\n\t        ctxt->sax->warning = xmlHTMLWarning;\n\t        ctxt->vctxt.error = xmlHTMLValidityError;\n\t        ctxt->vctxt.warning = xmlHTMLValidityWarning;\n\n\t\tdoc = xmlCtxtReadFile(ctxt, filename, NULL, options);\n\n\t\tif (rectxt == NULL)\n\t\t    xmlFreeParserCtxt(ctxt);\n\t    }\n#ifdef HAVE_MMAP\n\t} else if (memory) {\n\t    int fd;\n\t    struct stat info;\n\t    const char *base;\n\t    if (stat(filename, &info) < 0)\n\t\treturn;\n\t    if ((fd = open(filename, O_RDONLY)) < 0)\n\t\treturn;\n\t    base = mmap(NULL, info.st_size, PROT_READ, MAP_SHARED, fd, 0) ;\n\t    if (base == (void *) MAP_FAILED) {\n\t        close(fd);\n\t        fprintf(stderr, \"mmap failure for file %s\\n\", filename);\n\t\tprogresult = XMLLINT_ERR_RDFILE;\n\t        return;\n\t    }\n\n\t    if (rectxt == NULL)\n\t\tdoc = xmlReadMemory((char *) base, info.st_size,\n\t\t                    filename, NULL, options);\n\t    else\n\t\tdoc = xmlCtxtReadMemory(rectxt, (char *) base, info.st_size,\n\t\t\t                filename, NULL, options);\n\n\t    munmap((char *) base, info.st_size);\n\t    close(fd);\n#endif\n#ifdef LIBXML_VALID_ENABLED\n\t} else if (valid) {\n\t    xmlParserCtxtPtr ctxt = NULL;\n\n\t    if (rectxt == NULL)\n\t\tctxt = xmlNewParserCtxt();\n\t    else\n\t        ctxt = rectxt;\n\t    if (ctxt == NULL) {\n\t        doc = NULL;\n\t    } else {\n\t\tdoc = xmlCtxtReadFile(ctxt, filename, NULL, options);\n\n\t\tif (ctxt->valid == 0)\n\t\t    progresult = XMLLINT_ERR_RDFILE;\n\t\tif (rectxt == NULL)\n\t\t    xmlFreeParserCtxt(ctxt);\n\t    }\n#endif /* LIBXML_VALID_ENABLED */\n\t} else {\n\t    if (rectxt != NULL)\n\t        doc = xmlCtxtReadFile(rectxt, filename, NULL, options);\n\t    else {\n#ifdef LIBXML_SAX1_ENABLED\n                if (sax1)\n\t\t    doc = xmlParseFile(filename);\n\t\telse\n#endif /* LIBXML_SAX1_ENABLED */\n\t\tdoc = xmlReadFile(filename, NULL, options);\n\t    }\n\t}\n    }\n\n    /*\n     * If we don't have a document we might as well give up.  Do we\n     * want an error message here?  <sven@zen.org> */\n    if (doc == NULL) {\n\tprogresult = XMLLINT_ERR_UNCLASS;\n\treturn;\n    }\n\n    if ((timing) && (!repeat)) {\n\tendTimer(\"Parsing\");\n    }\n\n    /*\n     * Remove DOCTYPE nodes\n     */\n    if (dropdtd) {\n\txmlDtdPtr dtd;\n\n\tdtd = xmlGetIntSubset(doc);\n\tif (dtd != NULL) {\n\t    xmlUnlinkNode((xmlNodePtr)dtd);\n\t    xmlFreeDtd(dtd);\n\t}\n    }\n\n#ifdef LIBXML_XINCLUDE_ENABLED\n    if (xinclude) {\n\tif ((timing) && (!repeat)) {\n\t    startTimer();\n\t}\n\tif (xmlXIncludeProcessFlags(doc, options) < 0)\n\t    progresult = XMLLINT_ERR_UNCLASS;\n\tif ((timing) && (!repeat)) {\n\t    endTimer(\"Xinclude processing\");\n\t}\n    }\n#endif\n\n#ifdef LIBXML_XPATH_ENABLED\n    if (xpathquery != NULL) {\n        doXPathQuery(doc, xpathquery);\n    }\n#endif\n\n#ifdef LIBXML_DEBUG_ENABLED\n#ifdef LIBXML_XPATH_ENABLED\n    /*\n     * shell interaction\n     */\n    if (shell) {\n        xmlXPathOrderDocElems(doc);\n        xmlShell(doc, filename, xmlShellReadline, stdout);\n    }\n#endif\n#endif\n\n#ifdef LIBXML_TREE_ENABLED\n    /*\n     * test intermediate copy if needed.\n     */\n    if (copy) {\n        tmp = doc;\n\tif (timing) {\n\t    startTimer();\n\t}\n\tdoc = xmlCopyDoc(doc, 1);\n\tif (timing) {\n\t    endTimer(\"Copying\");\n\t}\n\tif (timing) {\n\t    startTimer();\n\t}\n\txmlFreeDoc(tmp);\n\tif (timing) {\n\t    endTimer(\"Freeing original\");\n\t}\n    }\n#endif /* LIBXML_TREE_ENABLED */\n\n#ifdef LIBXML_VALID_ENABLED\n    if ((insert) && (!html)) {\n        const xmlChar* list[256];\n\tint nb, i;\n\txmlNodePtr node;\n\n\tif (doc->children != NULL) {\n\t    node = doc->children;\n\t    while ((node != NULL) && (node->last == NULL)) node = node->next;\n\t    if (node != NULL) {\n\t\tnb = xmlValidGetValidElements(node->last, NULL, list, 256);\n\t\tif (nb < 0) {\n\t\t    fprintf(stderr, \"could not get valid list of elements\\n\");\n\t\t} else if (nb == 0) {\n\t\t    fprintf(stderr, \"No element can be inserted under root\\n\");\n\t\t} else {\n\t\t    fprintf(stderr, \"%d element types can be inserted under root:\\n\",\n\t\t           nb);\n\t\t    for (i = 0;i < nb;i++) {\n\t\t\t fprintf(stderr, \"%s\\n\", (char *) list[i]);\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }else\n#endif /* LIBXML_VALID_ENABLED */\n#ifdef LIBXML_READER_ENABLED\n    if (walker) {\n        walkDoc(doc);\n    }\n#endif /* LIBXML_READER_ENABLED */\n#ifdef LIBXML_OUTPUT_ENABLED\n    if (noout == 0) {\n        int ret;\n\n\t/*\n\t * print it.\n\t */\n#ifdef LIBXML_DEBUG_ENABLED\n\tif (!debug) {\n#endif\n\t    if ((timing) && (!repeat)) {\n\t\tstartTimer();\n\t    }\n#ifdef LIBXML_HTML_ENABLED\n            if ((html) && (!xmlout)) {\n\t\tif (compress) {\n\t\t    htmlSaveFile(output ? output : \"-\", doc);\n\t\t}\n\t\telse if (encoding != NULL) {\n\t\t    if (format == 1) {\n\t\t\thtmlSaveFileFormat(output ? output : \"-\", doc, encoding, 1);\n\t\t    }\n\t\t    else {\n\t\t\thtmlSaveFileFormat(output ? output : \"-\", doc, encoding, 0);\n\t\t    }\n\t\t}\n\t\telse if (format == 1) {\n\t\t    htmlSaveFileFormat(output ? output : \"-\", doc, NULL, 1);\n\t\t}\n\t\telse {\n\t\t    FILE *out;\n\t\t    if (output == NULL)\n\t\t\tout = stdout;\n\t\t    else {\n\t\t\tout = fopen(output,\"wb\");\n\t\t    }\n\t\t    if (out != NULL) {\n\t\t\tif (htmlDocDump(out, doc) < 0)\n\t\t\t    progresult = XMLLINT_ERR_OUT;\n\n\t\t\tif (output != NULL)\n\t\t\t    fclose(out);\n\t\t    } else {\n\t\t\tfprintf(stderr, \"failed to open %s\\n\", output);\n\t\t\tprogresult = XMLLINT_ERR_OUT;\n\t\t    }\n\t\t}\n\t\tif ((timing) && (!repeat)) {\n\t\t    endTimer(\"Saving\");\n\t\t}\n\t    } else\n#endif\n#ifdef LIBXML_C14N_ENABLED\n            if (canonical) {\n\t        xmlChar *result = NULL;\n\t\tint size;\n\n\t\tsize = xmlC14NDocDumpMemory(doc, NULL, XML_C14N_1_0, NULL, 1, &result);\n\t\tif (size >= 0) {\n\t\t    if (write(1, result, size) == -1) {\n\t\t        fprintf(stderr, \"Can't write data\\n\");\n\t\t    }\n\t\t    xmlFree(result);\n\t\t} else {\n\t\t    fprintf(stderr, \"Failed to canonicalize\\n\");\n\t\t    progresult = XMLLINT_ERR_OUT;\n\t\t}\n\t    } else if (canonical_11) {\n\t        xmlChar *result = NULL;\n\t\tint size;\n\n\t\tsize = xmlC14NDocDumpMemory(doc, NULL, XML_C14N_1_1, NULL, 1, &result);\n\t\tif (size >= 0) {\n\t\t    if (write(1, result, size) == -1) {\n\t\t        fprintf(stderr, \"Can't write data\\n\");\n\t\t    }\n\t\t    xmlFree(result);\n\t\t} else {\n\t\t    fprintf(stderr, \"Failed to canonicalize\\n\");\n\t\t    progresult = XMLLINT_ERR_OUT;\n\t\t}\n\t    } else\n            if (exc_canonical) {\n\t        xmlChar *result = NULL;\n\t\tint size;\n\n\t\tsize = xmlC14NDocDumpMemory(doc, NULL, XML_C14N_EXCLUSIVE_1_0, NULL, 1, &result);\n\t\tif (size >= 0) {\n\t\t    if (write(1, result, size) == -1) {\n\t\t        fprintf(stderr, \"Can't write data\\n\");\n\t\t    }\n\t\t    xmlFree(result);\n\t\t} else {\n\t\t    fprintf(stderr, \"Failed to canonicalize\\n\");\n\t\t    progresult = XMLLINT_ERR_OUT;\n\t\t}\n\t    } else\n#endif\n#ifdef HAVE_MMAP\n\t    if (memory) {\n\t\txmlChar *result;\n\t\tint len;\n\n\t\tif (encoding != NULL) {\n\t\t    if (format == 1) {\n\t\t        xmlDocDumpFormatMemoryEnc(doc, &result, &len, encoding, 1);\n\t\t    } else {\n\t\t\txmlDocDumpMemoryEnc(doc, &result, &len, encoding);\n\t\t    }\n\t\t} else {\n\t\t    if (format == 1)\n\t\t\txmlDocDumpFormatMemory(doc, &result, &len, 1);\n\t\t    else\n\t\t\txmlDocDumpMemory(doc, &result, &len);\n\t\t}\n\t\tif (result == NULL) {\n\t\t    fprintf(stderr, \"Failed to save\\n\");\n\t\t    progresult = XMLLINT_ERR_OUT;\n\t\t} else {\n\t\t    if (write(1, result, len) == -1) {\n\t\t        fprintf(stderr, \"Can't write data\\n\");\n\t\t    }\n\t\t    xmlFree(result);\n\t\t}\n\n\t    } else\n#endif /* HAVE_MMAP */\n\t    if (compress) {\n\t\txmlSaveFile(output ? output : \"-\", doc);\n\t    } else if (oldout) {\n\t        if (encoding != NULL) {\n\t\t    if (format == 1) {\n\t\t\tret = xmlSaveFormatFileEnc(output ? output : \"-\", doc,\n\t\t\t\t\t\t   encoding, 1);\n\t\t    }\n\t\t    else {\n\t\t\tret = xmlSaveFileEnc(output ? output : \"-\", doc,\n\t\t\t                     encoding);\n\t\t    }\n\t\t    if (ret < 0) {\n\t\t\tfprintf(stderr, \"failed save to %s\\n\",\n\t\t\t\toutput ? output : \"-\");\n\t\t\tprogresult = XMLLINT_ERR_OUT;\n\t\t    }\n\t\t} else if (format == 1) {\n\t\t    ret = xmlSaveFormatFile(output ? output : \"-\", doc, 1);\n\t\t    if (ret < 0) {\n\t\t\tfprintf(stderr, \"failed save to %s\\n\",\n\t\t\t\toutput ? output : \"-\");\n\t\t\tprogresult = XMLLINT_ERR_OUT;\n\t\t    }\n\t\t} else {\n\t\t    FILE *out;\n\t\t    if (output == NULL)\n\t\t\tout = stdout;\n\t\t    else {\n\t\t\tout = fopen(output,\"wb\");\n\t\t    }\n\t\t    if (out != NULL) {\n\t\t\tif (xmlDocDump(out, doc) < 0)\n\t\t\t    progresult = XMLLINT_ERR_OUT;\n\n\t\t\tif (output != NULL)\n\t\t\t    fclose(out);\n\t\t    } else {\n\t\t\tfprintf(stderr, \"failed to open %s\\n\", output);\n\t\t\tprogresult = XMLLINT_ERR_OUT;\n\t\t    }\n\t\t}\n\t    } else {\n\t        xmlSaveCtxtPtr ctxt;\n\t\tint saveOpts = 0;\n\n                if (format == 1)\n\t\t    saveOpts |= XML_SAVE_FORMAT;\n                else if (format == 2)\n                    saveOpts |= XML_SAVE_WSNONSIG;\n\n#if defined(LIBXML_HTML_ENABLED) || defined(LIBXML_VALID_ENABLED)\n                if (xmlout)\n                    saveOpts |= XML_SAVE_AS_XML;\n#endif\n\n\t\tif (output == NULL)\n\t\t    ctxt = xmlSaveToFd(1, encoding, saveOpts);\n\t\telse\n\t\t    ctxt = xmlSaveToFilename(output, encoding, saveOpts);\n\n\t\tif (ctxt != NULL) {\n\t\t    if (xmlSaveDoc(ctxt, doc) < 0) {\n\t\t\tfprintf(stderr, \"failed save to %s\\n\",\n\t\t\t\toutput ? output : \"-\");\n\t\t\tprogresult = XMLLINT_ERR_OUT;\n\t\t    }\n\t\t    xmlSaveClose(ctxt);\n\t\t} else {\n\t\t    progresult = XMLLINT_ERR_OUT;\n\t\t}\n\t    }\n\t    if ((timing) && (!repeat)) {\n\t\tendTimer(\"Saving\");\n\t    }\n#ifdef LIBXML_DEBUG_ENABLED\n\t} else {\n\t    FILE *out;\n\t    if (output == NULL)\n\t        out = stdout;\n\t    else {\n\t\tout = fopen(output,\"wb\");\n\t    }\n\t    if (out != NULL) {\n\t\txmlDebugDumpDocument(out, doc);\n\n\t\tif (output != NULL)\n\t\t    fclose(out);\n\t    } else {\n\t\tfprintf(stderr, \"failed to open %s\\n\", output);\n\t\tprogresult = XMLLINT_ERR_OUT;\n\t    }\n\t}\n#endif\n    }\n#endif /* LIBXML_OUTPUT_ENABLED */\n\n#ifdef LIBXML_VALID_ENABLED\n    /*\n     * A posteriori validation test\n     */\n    if ((dtdvalid != NULL) || (dtdvalidfpi != NULL)) {\n\txmlDtdPtr dtd;\n\n\tif ((timing) && (!repeat)) {\n\t    startTimer();\n\t}\n\tif (dtdvalid != NULL)\n\t    dtd = xmlParseDTD(NULL, (const xmlChar *)dtdvalid);\n\telse\n\t    dtd = xmlParseDTD((const xmlChar *)dtdvalidfpi, NULL);\n\tif ((timing) && (!repeat)) {\n\t    endTimer(\"Parsing DTD\");\n\t}\n\tif (dtd == NULL) {\n\t    if (dtdvalid != NULL)\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"Could not parse DTD %s\\n\", dtdvalid);\n\t    else\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"Could not parse DTD %s\\n\", dtdvalidfpi);\n\t    progresult = XMLLINT_ERR_DTD;\n\t} else {\n\t    xmlValidCtxtPtr cvp;\n\n\t    if ((cvp = xmlNewValidCtxt()) == NULL) {\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"Couldn't allocate validation context\\n\");\n\t\texit(-1);\n\t    }\n\t    cvp->userData = NULL;\n\t    cvp->error    = xmlGenericError;\n\t    cvp->warning  = xmlGenericError;\n\n\t    if ((timing) && (!repeat)) {\n\t\tstartTimer();\n\t    }\n\t    if (!xmlValidateDtd(cvp, doc, dtd)) {\n\t\tif (dtdvalid != NULL)\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t    \"Document %s does not validate against %s\\n\",\n\t\t\t    filename, dtdvalid);\n\t\telse\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t    \"Document %s does not validate against %s\\n\",\n\t\t\t    filename, dtdvalidfpi);\n\t\tprogresult = XMLLINT_ERR_VALID;\n\t    }\n\t    if ((timing) && (!repeat)) {\n\t\tendTimer(\"Validating against DTD\");\n\t    }\n\t    xmlFreeValidCtxt(cvp);\n\t    xmlFreeDtd(dtd);\n\t}\n    } else if (postvalid) {\n\txmlValidCtxtPtr cvp;\n\n\tif ((cvp = xmlNewValidCtxt()) == NULL) {\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"Couldn't allocate validation context\\n\");\n\t    exit(-1);\n\t}\n\n\tif ((timing) && (!repeat)) {\n\t    startTimer();\n\t}\n\tcvp->userData = NULL;\n\tcvp->error    = xmlGenericError;\n\tcvp->warning  = xmlGenericError;\n\tif (!xmlValidateDocument(cvp, doc)) {\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"Document %s does not validate\\n\", filename);\n\t    progresult = XMLLINT_ERR_VALID;\n\t}\n\tif ((timing) && (!repeat)) {\n\t    endTimer(\"Validating\");\n\t}\n\txmlFreeValidCtxt(cvp);\n    }\n#endif /* LIBXML_VALID_ENABLED */\n#ifdef LIBXML_SCHEMATRON_ENABLED\n    if (wxschematron != NULL) {\n\txmlSchematronValidCtxtPtr ctxt;\n\tint ret;\n\tint flag;\n\n\tif ((timing) && (!repeat)) {\n\t    startTimer();\n\t}\n\n\tif (debug)\n\t    flag = XML_SCHEMATRON_OUT_XML;\n\telse\n\t    flag = XML_SCHEMATRON_OUT_TEXT;\n\tif (noout)\n\t    flag |= XML_SCHEMATRON_OUT_QUIET;\n\tctxt = xmlSchematronNewValidCtxt(wxschematron, flag);\n#if 0\n\txmlSchematronSetValidErrors(ctxt, xmlGenericError, xmlGenericError,\n                NULL);\n#endif\n\tret = xmlSchematronValidateDoc(ctxt, doc);\n\tif (ret == 0) {\n\t    if (!quiet) {\n\t        fprintf(stderr, \"%s validates\\n\", filename);\n\t    }\n\t} else if (ret > 0) {\n\t    fprintf(stderr, \"%s fails to validate\\n\", filename);\n\t    progresult = XMLLINT_ERR_VALID;\n\t} else {\n\t    fprintf(stderr, \"%s validation generated an internal error\\n\",\n\t\t   filename);\n\t    progresult = XMLLINT_ERR_VALID;\n\t}\n\txmlSchematronFreeValidCtxt(ctxt);\n\tif ((timing) && (!repeat)) {\n\t    endTimer(\"Validating\");\n\t}\n    }\n#endif\n#ifdef LIBXML_SCHEMAS_ENABLED\n    if (relaxngschemas != NULL) {\n\txmlRelaxNGValidCtxtPtr ctxt;\n\tint ret;\n\n\tif ((timing) && (!repeat)) {\n\t    startTimer();\n\t}\n\n\tctxt = xmlRelaxNGNewValidCtxt(relaxngschemas);\n\txmlRelaxNGSetValidErrors(ctxt, xmlGenericError, xmlGenericError, NULL);\n\tret = xmlRelaxNGValidateDoc(ctxt, doc);\n\tif (ret == 0) {\n\t    if (!quiet) {\n\t        fprintf(stderr, \"%s validates\\n\", filename);\n\t    }\n\t} else if (ret > 0) {\n\t    fprintf(stderr, \"%s fails to validate\\n\", filename);\n\t    progresult = XMLLINT_ERR_VALID;\n\t} else {\n\t    fprintf(stderr, \"%s validation generated an internal error\\n\",\n\t\t   filename);\n\t    progresult = XMLLINT_ERR_VALID;\n\t}\n\txmlRelaxNGFreeValidCtxt(ctxt);\n\tif ((timing) && (!repeat)) {\n\t    endTimer(\"Validating\");\n\t}\n    } else if (wxschemas != NULL) {\n\txmlSchemaValidCtxtPtr ctxt;\n\tint ret;\n\n\tif ((timing) && (!repeat)) {\n\t    startTimer();\n\t}\n\n\tctxt = xmlSchemaNewValidCtxt(wxschemas);\n\txmlSchemaSetValidErrors(ctxt, xmlGenericError, xmlGenericError, NULL);\n\tret = xmlSchemaValidateDoc(ctxt, doc);\n\tif (ret == 0) {\n\t    if (!quiet) {\n\t        fprintf(stderr, \"%s validates\\n\", filename);\n\t    }\n\t} else if (ret > 0) {\n\t    fprintf(stderr, \"%s fails to validate\\n\", filename);\n\t    progresult = XMLLINT_ERR_VALID;\n\t} else {\n\t    fprintf(stderr, \"%s validation generated an internal error\\n\",\n\t\t   filename);\n\t    progresult = XMLLINT_ERR_VALID;\n\t}\n\txmlSchemaFreeValidCtxt(ctxt);\n\tif ((timing) && (!repeat)) {\n\t    endTimer(\"Validating\");\n\t}\n    }\n#endif\n\n#ifdef LIBXML_DEBUG_ENABLED\n#if defined(LIBXML_HTML_ENABLED) || defined(LIBXML_VALID_ENABLED)\n    if ((debugent) && (!html))\n\txmlDebugDumpEntities(stderr, doc);\n#endif\n#endif\n\n    /*\n     * free it.\n     */\n    if ((timing) && (!repeat)) {\n\tstartTimer();\n    }\n    xmlFreeDoc(doc);\n    if ((timing) && (!repeat)) {\n\tendTimer(\"Freeing\");\n    }\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147401,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int acm_probe(struct usb_interface *intf,\n\t\t     const struct usb_device_id *id)\n{\n\tstruct usb_cdc_union_desc *union_header = NULL;\n\tstruct usb_cdc_call_mgmt_descriptor *cmgmd = NULL;\n\tunsigned char *buffer = intf->altsetting->extra;\n\tint buflen = intf->altsetting->extralen;\n\tstruct usb_interface *control_interface;\n\tstruct usb_interface *data_interface;\n\tstruct usb_endpoint_descriptor *epctrl = NULL;\n\tstruct usb_endpoint_descriptor *epread = NULL;\n\tstruct usb_endpoint_descriptor *epwrite = NULL;\n\tstruct usb_device *usb_dev = interface_to_usbdev(intf);\n\tstruct usb_cdc_parsed_header h;\n\tstruct acm *acm;\n\tint minor;\n\tint ctrlsize, readsize;\n\tu8 *buf;\n\tint call_intf_num = -1;\n\tint data_intf_num = -1;\n\tunsigned long quirks;\n\tint num_rx_buf;\n\tint i;\n\tint combined_interfaces = 0;\n\tstruct device *tty_dev;\n\tint rv = -ENOMEM;\n\tint res;\n\n\t/* normal quirks */\n\tquirks = (unsigned long)id->driver_info;\n\n\tif (quirks == IGNORE_DEVICE)\n\t\treturn -ENODEV;\n\n\tmemset(&h, 0x00, sizeof(struct usb_cdc_parsed_header));\n\n\tnum_rx_buf = (quirks == SINGLE_RX_URB) ? 1 : ACM_NR;\n\n\t/* handle quirks deadly to normal probing*/\n\tif (quirks == NO_UNION_NORMAL) {\n\t\tdata_interface = usb_ifnum_to_if(usb_dev, 1);\n\t\tcontrol_interface = usb_ifnum_to_if(usb_dev, 0);\n\t\t/* we would crash */\n\t\tif (!data_interface || !control_interface)\n\t\t\treturn -ENODEV;\n\t\tgoto skip_normal_probe;\n\t}\n\n\t/* normal probing*/\n\tif (!buffer) {\n\t\tdev_err(&intf->dev, \"Weird descriptor references\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!intf->cur_altsetting)\n\t\treturn -EINVAL;\n\n\tif (!buflen) {\n\t\tif (intf->cur_altsetting->endpoint &&\n\t\t\t\tintf->cur_altsetting->endpoint->extralen &&\n\t\t\t\tintf->cur_altsetting->endpoint->extra) {\n\t\t\tdev_dbg(&intf->dev,\n\t\t\t\t\"Seeking extra descriptors on endpoint\\n\");\n\t\t\tbuflen = intf->cur_altsetting->endpoint->extralen;\n\t\t\tbuffer = intf->cur_altsetting->endpoint->extra;\n\t\t} else {\n\t\t\tdev_err(&intf->dev,\n\t\t\t\t\"Zero length descriptor references\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tcdc_parse_cdc_header(&h, intf, buffer, buflen);\n\tunion_header = h.usb_cdc_union_desc;\n\tcmgmd = h.usb_cdc_call_mgmt_descriptor;\n\tif (cmgmd)\n\t\tcall_intf_num = cmgmd->bDataInterface;\n\n\tif (!union_header) {\n\t\tif (call_intf_num > 0) {\n\t\t\tdev_dbg(&intf->dev, \"No union descriptor, using call management descriptor\\n\");\n\t\t\t/* quirks for Droids MuIn LCD */\n\t\t\tif (quirks & NO_DATA_INTERFACE) {\n\t\t\t\tdata_interface = usb_ifnum_to_if(usb_dev, 0);\n\t\t\t} else {\n\t\t\t\tdata_intf_num = call_intf_num;\n\t\t\t\tdata_interface = usb_ifnum_to_if(usb_dev, data_intf_num);\n\t\t\t}\n\t\t\tcontrol_interface = intf;\n\t\t} else {\n\t\t\tif (intf->cur_altsetting->desc.bNumEndpoints != 3) {\n\t\t\t\tdev_dbg(&intf->dev,\"No union descriptor, giving up\\n\");\n\t\t\t\treturn -ENODEV;\n\t\t\t} else {\n\t\t\t\tdev_warn(&intf->dev,\"No union descriptor, testing for castrated device\\n\");\n\t\t\t\tcombined_interfaces = 1;\n\t\t\t\tcontrol_interface = data_interface = intf;\n\t\t\t\tgoto look_for_collapsed_interface;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tdata_intf_num = union_header->bSlaveInterface0;\n\t\tcontrol_interface = usb_ifnum_to_if(usb_dev, union_header->bMasterInterface0);\n\t\tdata_interface = usb_ifnum_to_if(usb_dev, data_intf_num);\n\t}\n\n\tif (!control_interface || !data_interface) {\n\t\tdev_dbg(&intf->dev, \"no interfaces\\n\");\n\t\treturn -ENODEV;\n\t}\n\tif (!data_interface->cur_altsetting || !control_interface->cur_altsetting)\n\t\treturn -ENODEV;\n\n\tif (data_intf_num != call_intf_num)\n\t\tdev_dbg(&intf->dev, \"Separate call control interface. That is not fully supported.\\n\");\n\n\tif (control_interface == data_interface) {\n\t\t/* some broken devices designed for windows work this way */\n\t\tdev_warn(&intf->dev,\"Control and data interfaces are not separated!\\n\");\n\t\tcombined_interfaces = 1;\n\t\t/* a popular other OS doesn't use it */\n\t\tquirks |= NO_CAP_LINE;\n\t\tif (data_interface->cur_altsetting->desc.bNumEndpoints != 3) {\n\t\t\tdev_err(&intf->dev, \"This needs exactly 3 endpoints\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\nlook_for_collapsed_interface:\n\t\tres = usb_find_common_endpoints(data_interface->cur_altsetting,\n\t\t\t\t&epread, &epwrite, &epctrl, NULL);\n\t\tif (res)\n\t\t\treturn res;\n\n\t\tgoto made_compressed_probe;\n\t}\n\nskip_normal_probe:\n\n\t/*workaround for switched interfaces */\n\tif (data_interface->cur_altsetting->desc.bInterfaceClass\n\t\t\t\t\t\t!= CDC_DATA_INTERFACE_TYPE) {\n\t\tif (control_interface->cur_altsetting->desc.bInterfaceClass\n\t\t\t\t\t\t== CDC_DATA_INTERFACE_TYPE) {\n\t\t\tdev_dbg(&intf->dev,\n\t\t\t\t\"Your device has switched interfaces.\\n\");\n\t\t\tswap(control_interface, data_interface);\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* Accept probe requests only for the control interface */\n\tif (!combined_interfaces && intf != control_interface)\n\t\treturn -ENODEV;\n\n\tif (!combined_interfaces && usb_interface_claimed(data_interface)) {\n\t\t/* valid in this context */\n\t\tdev_dbg(&intf->dev, \"The data interface isn't available\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\n\tif (data_interface->cur_altsetting->desc.bNumEndpoints < 2 ||\n\t    control_interface->cur_altsetting->desc.bNumEndpoints == 0)\n\t\treturn -EINVAL;\n\n\tepctrl = &control_interface->cur_altsetting->endpoint[0].desc;\n\tepread = &data_interface->cur_altsetting->endpoint[0].desc;\n\tepwrite = &data_interface->cur_altsetting->endpoint[1].desc;\n\n\n\t/* workaround for switched endpoints */\n\tif (!usb_endpoint_dir_in(epread)) {\n\t\t/* descriptors are swapped */\n\t\tdev_dbg(&intf->dev,\n\t\t\t\"The data interface has switched endpoints\\n\");\n\t\tswap(epread, epwrite);\n\t}\nmade_compressed_probe:\n\tdev_dbg(&intf->dev, \"interfaces are valid\\n\");\n\n\tacm = kzalloc(sizeof(struct acm), GFP_KERNEL);\n\tif (acm == NULL)\n\t\tgoto alloc_fail;\n\n\ttty_port_init(&acm->port);\n\tacm->port.ops = &acm_port_ops;\n\n\tminor = acm_alloc_minor(acm);\n\tif (minor < 0)\n\t\tgoto alloc_fail1;\n\n\tctrlsize = usb_endpoint_maxp(epctrl);\n\treadsize = usb_endpoint_maxp(epread) *\n\t\t\t\t(quirks == SINGLE_RX_URB ? 1 : 2);\n\tacm->combined_interfaces = combined_interfaces;\n\tacm->writesize = usb_endpoint_maxp(epwrite) * 20;\n\tacm->control = control_interface;\n\tacm->data = data_interface;\n\tacm->minor = minor;\n\tacm->dev = usb_dev;\n\tif (h.usb_cdc_acm_descriptor)\n\t\tacm->ctrl_caps = h.usb_cdc_acm_descriptor->bmCapabilities;\n\tif (quirks & NO_CAP_LINE)\n\t\tacm->ctrl_caps &= ~USB_CDC_CAP_LINE;\n\tacm->ctrlsize = ctrlsize;\n\tacm->readsize = readsize;\n\tacm->rx_buflimit = num_rx_buf;\n\tINIT_WORK(&acm->work, acm_softint);\n\tinit_waitqueue_head(&acm->wioctl);\n\tspin_lock_init(&acm->write_lock);\n\tspin_lock_init(&acm->read_lock);\n\tmutex_init(&acm->mutex);\n\tif (usb_endpoint_xfer_int(epread)) {\n\t\tacm->bInterval = epread->bInterval;\n\t\tacm->in = usb_rcvintpipe(usb_dev, epread->bEndpointAddress);\n\t} else {\n\t\tacm->in = usb_rcvbulkpipe(usb_dev, epread->bEndpointAddress);\n\t}\n\tif (usb_endpoint_xfer_int(epwrite))\n\t\tacm->out = usb_sndintpipe(usb_dev, epwrite->bEndpointAddress);\n\telse\n\t\tacm->out = usb_sndbulkpipe(usb_dev, epwrite->bEndpointAddress);\n\tinit_usb_anchor(&acm->delayed);\n\tacm->quirks = quirks;\n\n\tbuf = usb_alloc_coherent(usb_dev, ctrlsize, GFP_KERNEL, &acm->ctrl_dma);\n\tif (!buf)\n\t\tgoto alloc_fail1;\n\tacm->ctrl_buffer = buf;\n\n\tif (acm_write_buffers_alloc(acm) < 0)\n\t\tgoto alloc_fail2;\n\n\tacm->ctrlurb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!acm->ctrlurb)\n\t\tgoto alloc_fail3;\n\n\tfor (i = 0; i < num_rx_buf; i++) {\n\t\tstruct acm_rb *rb = &(acm->read_buffers[i]);\n\t\tstruct urb *urb;\n\n\t\trb->base = usb_alloc_coherent(acm->dev, readsize, GFP_KERNEL,\n\t\t\t\t\t\t\t\t&rb->dma);\n\t\tif (!rb->base)\n\t\t\tgoto alloc_fail4;\n\t\trb->index = i;\n\t\trb->instance = acm;\n\n\t\turb = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!urb)\n\t\t\tgoto alloc_fail4;\n\n\t\turb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\t\turb->transfer_dma = rb->dma;\n\t\tif (usb_endpoint_xfer_int(epread))\n\t\t\tusb_fill_int_urb(urb, acm->dev, acm->in, rb->base,\n\t\t\t\t\t acm->readsize,\n\t\t\t\t\t acm_read_bulk_callback, rb,\n\t\t\t\t\t acm->bInterval);\n\t\telse\n\t\t\tusb_fill_bulk_urb(urb, acm->dev, acm->in, rb->base,\n\t\t\t\t\t  acm->readsize,\n\t\t\t\t\t  acm_read_bulk_callback, rb);\n\n\t\tacm->read_urbs[i] = urb;\n\t\t__set_bit(i, &acm->read_urbs_free);\n\t}\n\tfor (i = 0; i < ACM_NW; i++) {\n\t\tstruct acm_wb *snd = &(acm->wb[i]);\n\n\t\tsnd->urb = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (snd->urb == NULL)\n\t\t\tgoto alloc_fail5;\n\n\t\tif (usb_endpoint_xfer_int(epwrite))\n\t\t\tusb_fill_int_urb(snd->urb, usb_dev, acm->out,\n\t\t\t\tNULL, acm->writesize, acm_write_bulk, snd, epwrite->bInterval);\n\t\telse\n\t\t\tusb_fill_bulk_urb(snd->urb, usb_dev, acm->out,\n\t\t\t\tNULL, acm->writesize, acm_write_bulk, snd);\n\t\tsnd->urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\t\tif (quirks & SEND_ZERO_PACKET)\n\t\t\tsnd->urb->transfer_flags |= URB_ZERO_PACKET;\n\t\tsnd->instance = acm;\n\t}\n\n\tusb_set_intfdata(intf, acm);\n\n\ti = device_create_file(&intf->dev, &dev_attr_bmCapabilities);\n\tif (i < 0)\n\t\tgoto alloc_fail5;\n\n\tif (h.usb_cdc_country_functional_desc) { /* export the country data */\n\t\tstruct usb_cdc_country_functional_desc * cfd =\n\t\t\t\t\th.usb_cdc_country_functional_desc;\n\n\t\tacm->country_codes = kmalloc(cfd->bLength - 4, GFP_KERNEL);\n\t\tif (!acm->country_codes)\n\t\t\tgoto skip_countries;\n\t\tacm->country_code_size = cfd->bLength - 4;\n\t\tmemcpy(acm->country_codes, (u8 *)&cfd->wCountyCode0,\n\t\t\t\t\t\t\tcfd->bLength - 4);\n\t\tacm->country_rel_date = cfd->iCountryCodeRelDate;\n\n\t\ti = device_create_file(&intf->dev, &dev_attr_wCountryCodes);\n\t\tif (i < 0) {\n\t\t\tkfree(acm->country_codes);\n\t\t\tacm->country_codes = NULL;\n\t\t\tacm->country_code_size = 0;\n\t\t\tgoto skip_countries;\n\t\t}\n\n\t\ti = device_create_file(&intf->dev,\n\t\t\t\t\t\t&dev_attr_iCountryCodeRelDate);\n\t\tif (i < 0) {\n\t\t\tdevice_remove_file(&intf->dev, &dev_attr_wCountryCodes);\n\t\t\tkfree(acm->country_codes);\n\t\t\tacm->country_codes = NULL;\n\t\t\tacm->country_code_size = 0;\n\t\t\tgoto skip_countries;\n\t\t}\n\t}\n\nskip_countries:\n\tusb_fill_int_urb(acm->ctrlurb, usb_dev,\n\t\t\t usb_rcvintpipe(usb_dev, epctrl->bEndpointAddress),\n\t\t\t acm->ctrl_buffer, ctrlsize, acm_ctrl_irq, acm,\n\t\t\t /* works around buggy devices */\n\t\t\t epctrl->bInterval ? epctrl->bInterval : 16);\n\tacm->ctrlurb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\tacm->ctrlurb->transfer_dma = acm->ctrl_dma;\n\tacm->notification_buffer = NULL;\n\tacm->nb_index = 0;\n\tacm->nb_size = 0;\n\n\tdev_info(&intf->dev, \"ttyACM%d: USB ACM device\\n\", minor);\n\n\tacm->line.dwDTERate = cpu_to_le32(9600);\n\tacm->line.bDataBits = 8;\n\tacm_set_line(acm, &acm->line);\n\n\tusb_driver_claim_interface(&acm_driver, data_interface, acm);\n\tusb_set_intfdata(data_interface, acm);\n\n\tusb_get_intf(control_interface);\n\ttty_dev = tty_port_register_device(&acm->port, acm_tty_driver, minor,\n\t\t\t&control_interface->dev);\n\tif (IS_ERR(tty_dev)) {\n\t\trv = PTR_ERR(tty_dev);\n\t\tgoto alloc_fail6;\n\t}\n\n\tif (quirks & CLEAR_HALT_CONDITIONS) {\n\t\tusb_clear_halt(usb_dev, acm->in);\n\t\tusb_clear_halt(usb_dev, acm->out);\n\t}\n\n\treturn 0;\nalloc_fail6:\n\tif (acm->country_codes) {\n\t\tdevice_remove_file(&acm->control->dev,\n\t\t\t\t&dev_attr_wCountryCodes);\n\t\tdevice_remove_file(&acm->control->dev,\n\t\t\t\t&dev_attr_iCountryCodeRelDate);\n\t\tkfree(acm->country_codes);\n\t}\n\tdevice_remove_file(&acm->control->dev, &dev_attr_bmCapabilities);\nalloc_fail5:\n\tusb_set_intfdata(intf, NULL);\n\tfor (i = 0; i < ACM_NW; i++)\n\t\tusb_free_urb(acm->wb[i].urb);\nalloc_fail4:\n\tfor (i = 0; i < num_rx_buf; i++)\n\t\tusb_free_urb(acm->read_urbs[i]);\n\tacm_read_buffers_free(acm);\n\tusb_free_urb(acm->ctrlurb);\nalloc_fail3:\n\tacm_write_buffers_free(acm);\nalloc_fail2:\n\tusb_free_coherent(usb_dev, ctrlsize, acm->ctrl_buffer, acm->ctrl_dma);\nalloc_fail1:\n\ttty_port_put(&acm->port);\nalloc_fail:\n\treturn rv;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147498,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int acm_probe(struct usb_interface *intf,\n\t\t     const struct usb_device_id *id)\n{\n\tstruct usb_cdc_union_desc *union_header = NULL;\n\tstruct usb_cdc_call_mgmt_descriptor *cmgmd = NULL;\n\tunsigned char *buffer = intf->altsetting->extra;\n\tint buflen = intf->altsetting->extralen;\n\tstruct usb_interface *control_interface;\n\tstruct usb_interface *data_interface;\n\tstruct usb_endpoint_descriptor *epctrl = NULL;\n\tstruct usb_endpoint_descriptor *epread = NULL;\n\tstruct usb_endpoint_descriptor *epwrite = NULL;\n\tstruct usb_device *usb_dev = interface_to_usbdev(intf);\n\tstruct usb_cdc_parsed_header h;\n\tstruct acm *acm;\n\tint minor;\n\tint ctrlsize, readsize;\n\tu8 *buf;\n\tint call_intf_num = -1;\n\tint data_intf_num = -1;\n\tunsigned long quirks;\n\tint num_rx_buf;\n\tint i;\n\tint combined_interfaces = 0;\n\tstruct device *tty_dev;\n\tint rv = -ENOMEM;\n\tint res;\n\n\t/* normal quirks */\n\tquirks = (unsigned long)id->driver_info;\n\n\tif (quirks == IGNORE_DEVICE)\n\t\treturn -ENODEV;\n\n\tmemset(&h, 0x00, sizeof(struct usb_cdc_parsed_header));\n\n\tnum_rx_buf = (quirks == SINGLE_RX_URB) ? 1 : ACM_NR;\n\n\t/* handle quirks deadly to normal probing*/\n\tif (quirks == NO_UNION_NORMAL) {\n\t\tdata_interface = usb_ifnum_to_if(usb_dev, 1);\n\t\tcontrol_interface = usb_ifnum_to_if(usb_dev, 0);\n\t\t/* we would crash */\n\t\tif (!data_interface || !control_interface)\n\t\t\treturn -ENODEV;\n\t\tgoto skip_normal_probe;\n\t}\n\n\t/* normal probing*/\n\tif (!buffer) {\n\t\tdev_err(&intf->dev, \"Weird descriptor references\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!intf->cur_altsetting)\n\t\treturn -EINVAL;\n\n\tif (!buflen) {\n\t\tif (intf->cur_altsetting->endpoint &&\n\t\t\t\tintf->cur_altsetting->endpoint->extralen &&\n\t\t\t\tintf->cur_altsetting->endpoint->extra) {\n\t\t\tdev_dbg(&intf->dev,\n\t\t\t\t\"Seeking extra descriptors on endpoint\\n\");\n\t\t\tbuflen = intf->cur_altsetting->endpoint->extralen;\n\t\t\tbuffer = intf->cur_altsetting->endpoint->extra;\n\t\t} else {\n\t\t\tdev_err(&intf->dev,\n\t\t\t\t\"Zero length descriptor references\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tcdc_parse_cdc_header(&h, intf, buffer, buflen);\n\tunion_header = h.usb_cdc_union_desc;\n\tcmgmd = h.usb_cdc_call_mgmt_descriptor;\n\tif (cmgmd)\n\t\tcall_intf_num = cmgmd->bDataInterface;\n\n\tif (!union_header) {\n\t\tif (call_intf_num > 0) {\n\t\t\tdev_dbg(&intf->dev, \"No union descriptor, using call management descriptor\\n\");\n\t\t\t/* quirks for Droids MuIn LCD */\n\t\t\tif (quirks & NO_DATA_INTERFACE) {\n\t\t\t\tdata_interface = usb_ifnum_to_if(usb_dev, 0);\n\t\t\t} else {\n\t\t\t\tdata_intf_num = call_intf_num;\n\t\t\t\tdata_interface = usb_ifnum_to_if(usb_dev, data_intf_num);\n\t\t\t}\n\t\t\tcontrol_interface = intf;\n\t\t} else {\n\t\t\tif (intf->cur_altsetting->desc.bNumEndpoints != 3) {\n\t\t\t\tdev_dbg(&intf->dev,\"No union descriptor, giving up\\n\");\n\t\t\t\treturn -ENODEV;\n\t\t\t} else {\n\t\t\t\tdev_warn(&intf->dev,\"No union descriptor, testing for castrated device\\n\");\n\t\t\t\tcombined_interfaces = 1;\n\t\t\t\tcontrol_interface = data_interface = intf;\n\t\t\t\tgoto look_for_collapsed_interface;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tdata_intf_num = union_header->bSlaveInterface0;\n\t\tcontrol_interface = usb_ifnum_to_if(usb_dev, union_header->bMasterInterface0);\n\t\tdata_interface = usb_ifnum_to_if(usb_dev, data_intf_num);\n\t}\n\n\tif (!control_interface || !data_interface) {\n\t\tdev_dbg(&intf->dev, \"no interfaces\\n\");\n\t\treturn -ENODEV;\n\t}\n\tif (!data_interface->cur_altsetting || !control_interface->cur_altsetting)\n\t\treturn -ENODEV;\n\n\tif (data_intf_num != call_intf_num)\n\t\tdev_dbg(&intf->dev, \"Separate call control interface. That is not fully supported.\\n\");\n\n\tif (control_interface == data_interface) {\n\t\t/* some broken devices designed for windows work this way */\n\t\tdev_warn(&intf->dev,\"Control and data interfaces are not separated!\\n\");\n\t\tcombined_interfaces = 1;\n\t\t/* a popular other OS doesn't use it */\n\t\tquirks |= NO_CAP_LINE;\n\t\tif (data_interface->cur_altsetting->desc.bNumEndpoints != 3) {\n\t\t\tdev_err(&intf->dev, \"This needs exactly 3 endpoints\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\nlook_for_collapsed_interface:\n\t\tres = usb_find_common_endpoints(data_interface->cur_altsetting,\n\t\t\t\t&epread, &epwrite, &epctrl, NULL);\n\t\tif (res)\n\t\t\treturn res;\n\n\t\tgoto made_compressed_probe;\n\t}\n\nskip_normal_probe:\n\n\t/*workaround for switched interfaces */\n\tif (data_interface->cur_altsetting->desc.bInterfaceClass\n\t\t\t\t\t\t!= CDC_DATA_INTERFACE_TYPE) {\n\t\tif (control_interface->cur_altsetting->desc.bInterfaceClass\n\t\t\t\t\t\t== CDC_DATA_INTERFACE_TYPE) {\n\t\t\tdev_dbg(&intf->dev,\n\t\t\t\t\"Your device has switched interfaces.\\n\");\n\t\t\tswap(control_interface, data_interface);\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* Accept probe requests only for the control interface */\n\tif (!combined_interfaces && intf != control_interface)\n\t\treturn -ENODEV;\n\n\tif (!combined_interfaces && usb_interface_claimed(data_interface)) {\n\t\t/* valid in this context */\n\t\tdev_dbg(&intf->dev, \"The data interface isn't available\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\n\tif (data_interface->cur_altsetting->desc.bNumEndpoints < 2 ||\n\t    control_interface->cur_altsetting->desc.bNumEndpoints == 0)\n\t\treturn -EINVAL;\n\n\tepctrl = &control_interface->cur_altsetting->endpoint[0].desc;\n\tepread = &data_interface->cur_altsetting->endpoint[0].desc;\n\tepwrite = &data_interface->cur_altsetting->endpoint[1].desc;\n\n\n\t/* workaround for switched endpoints */\n\tif (!usb_endpoint_dir_in(epread)) {\n\t\t/* descriptors are swapped */\n\t\tdev_dbg(&intf->dev,\n\t\t\t\"The data interface has switched endpoints\\n\");\n\t\tswap(epread, epwrite);\n\t}\nmade_compressed_probe:\n\tdev_dbg(&intf->dev, \"interfaces are valid\\n\");\n\n\tacm = kzalloc(sizeof(struct acm), GFP_KERNEL);\n\tif (acm == NULL)\n\t\tgoto alloc_fail;\n\n\ttty_port_init(&acm->port);\n\tacm->port.ops = &acm_port_ops;\n\n\tctrlsize = usb_endpoint_maxp(epctrl);\n\treadsize = usb_endpoint_maxp(epread) *\n\t\t\t\t(quirks == SINGLE_RX_URB ? 1 : 2);\n\tacm->combined_interfaces = combined_interfaces;\n\tacm->writesize = usb_endpoint_maxp(epwrite) * 20;\n\tacm->control = control_interface;\n\tacm->data = data_interface;\n\n\tusb_get_intf(acm->control); /* undone in destruct() */\n\n\tminor = acm_alloc_minor(acm);\n\tif (minor < 0)\n\t\tgoto alloc_fail1;\n\n\tacm->minor = minor;\n\tacm->dev = usb_dev;\n\tif (h.usb_cdc_acm_descriptor)\n\t\tacm->ctrl_caps = h.usb_cdc_acm_descriptor->bmCapabilities;\n\tif (quirks & NO_CAP_LINE)\n\t\tacm->ctrl_caps &= ~USB_CDC_CAP_LINE;\n\tacm->ctrlsize = ctrlsize;\n\tacm->readsize = readsize;\n\tacm->rx_buflimit = num_rx_buf;\n\tINIT_WORK(&acm->work, acm_softint);\n\tinit_waitqueue_head(&acm->wioctl);\n\tspin_lock_init(&acm->write_lock);\n\tspin_lock_init(&acm->read_lock);\n\tmutex_init(&acm->mutex);\n\tif (usb_endpoint_xfer_int(epread)) {\n\t\tacm->bInterval = epread->bInterval;\n\t\tacm->in = usb_rcvintpipe(usb_dev, epread->bEndpointAddress);\n\t} else {\n\t\tacm->in = usb_rcvbulkpipe(usb_dev, epread->bEndpointAddress);\n\t}\n\tif (usb_endpoint_xfer_int(epwrite))\n\t\tacm->out = usb_sndintpipe(usb_dev, epwrite->bEndpointAddress);\n\telse\n\t\tacm->out = usb_sndbulkpipe(usb_dev, epwrite->bEndpointAddress);\n\tinit_usb_anchor(&acm->delayed);\n\tacm->quirks = quirks;\n\n\tbuf = usb_alloc_coherent(usb_dev, ctrlsize, GFP_KERNEL, &acm->ctrl_dma);\n\tif (!buf)\n\t\tgoto alloc_fail1;\n\tacm->ctrl_buffer = buf;\n\n\tif (acm_write_buffers_alloc(acm) < 0)\n\t\tgoto alloc_fail2;\n\n\tacm->ctrlurb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!acm->ctrlurb)\n\t\tgoto alloc_fail3;\n\n\tfor (i = 0; i < num_rx_buf; i++) {\n\t\tstruct acm_rb *rb = &(acm->read_buffers[i]);\n\t\tstruct urb *urb;\n\n\t\trb->base = usb_alloc_coherent(acm->dev, readsize, GFP_KERNEL,\n\t\t\t\t\t\t\t\t&rb->dma);\n\t\tif (!rb->base)\n\t\t\tgoto alloc_fail4;\n\t\trb->index = i;\n\t\trb->instance = acm;\n\n\t\turb = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!urb)\n\t\t\tgoto alloc_fail4;\n\n\t\turb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\t\turb->transfer_dma = rb->dma;\n\t\tif (usb_endpoint_xfer_int(epread))\n\t\t\tusb_fill_int_urb(urb, acm->dev, acm->in, rb->base,\n\t\t\t\t\t acm->readsize,\n\t\t\t\t\t acm_read_bulk_callback, rb,\n\t\t\t\t\t acm->bInterval);\n\t\telse\n\t\t\tusb_fill_bulk_urb(urb, acm->dev, acm->in, rb->base,\n\t\t\t\t\t  acm->readsize,\n\t\t\t\t\t  acm_read_bulk_callback, rb);\n\n\t\tacm->read_urbs[i] = urb;\n\t\t__set_bit(i, &acm->read_urbs_free);\n\t}\n\tfor (i = 0; i < ACM_NW; i++) {\n\t\tstruct acm_wb *snd = &(acm->wb[i]);\n\n\t\tsnd->urb = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (snd->urb == NULL)\n\t\t\tgoto alloc_fail5;\n\n\t\tif (usb_endpoint_xfer_int(epwrite))\n\t\t\tusb_fill_int_urb(snd->urb, usb_dev, acm->out,\n\t\t\t\tNULL, acm->writesize, acm_write_bulk, snd, epwrite->bInterval);\n\t\telse\n\t\t\tusb_fill_bulk_urb(snd->urb, usb_dev, acm->out,\n\t\t\t\tNULL, acm->writesize, acm_write_bulk, snd);\n\t\tsnd->urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\t\tif (quirks & SEND_ZERO_PACKET)\n\t\t\tsnd->urb->transfer_flags |= URB_ZERO_PACKET;\n\t\tsnd->instance = acm;\n\t}\n\n\tusb_set_intfdata(intf, acm);\n\n\ti = device_create_file(&intf->dev, &dev_attr_bmCapabilities);\n\tif (i < 0)\n\t\tgoto alloc_fail5;\n\n\tif (h.usb_cdc_country_functional_desc) { /* export the country data */\n\t\tstruct usb_cdc_country_functional_desc * cfd =\n\t\t\t\t\th.usb_cdc_country_functional_desc;\n\n\t\tacm->country_codes = kmalloc(cfd->bLength - 4, GFP_KERNEL);\n\t\tif (!acm->country_codes)\n\t\t\tgoto skip_countries;\n\t\tacm->country_code_size = cfd->bLength - 4;\n\t\tmemcpy(acm->country_codes, (u8 *)&cfd->wCountyCode0,\n\t\t\t\t\t\t\tcfd->bLength - 4);\n\t\tacm->country_rel_date = cfd->iCountryCodeRelDate;\n\n\t\ti = device_create_file(&intf->dev, &dev_attr_wCountryCodes);\n\t\tif (i < 0) {\n\t\t\tkfree(acm->country_codes);\n\t\t\tacm->country_codes = NULL;\n\t\t\tacm->country_code_size = 0;\n\t\t\tgoto skip_countries;\n\t\t}\n\n\t\ti = device_create_file(&intf->dev,\n\t\t\t\t\t\t&dev_attr_iCountryCodeRelDate);\n\t\tif (i < 0) {\n\t\t\tdevice_remove_file(&intf->dev, &dev_attr_wCountryCodes);\n\t\t\tkfree(acm->country_codes);\n\t\t\tacm->country_codes = NULL;\n\t\t\tacm->country_code_size = 0;\n\t\t\tgoto skip_countries;\n\t\t}\n\t}\n\nskip_countries:\n\tusb_fill_int_urb(acm->ctrlurb, usb_dev,\n\t\t\t usb_rcvintpipe(usb_dev, epctrl->bEndpointAddress),\n\t\t\t acm->ctrl_buffer, ctrlsize, acm_ctrl_irq, acm,\n\t\t\t /* works around buggy devices */\n\t\t\t epctrl->bInterval ? epctrl->bInterval : 16);\n\tacm->ctrlurb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\tacm->ctrlurb->transfer_dma = acm->ctrl_dma;\n\tacm->notification_buffer = NULL;\n\tacm->nb_index = 0;\n\tacm->nb_size = 0;\n\n\tdev_info(&intf->dev, \"ttyACM%d: USB ACM device\\n\", minor);\n\n\tacm->line.dwDTERate = cpu_to_le32(9600);\n\tacm->line.bDataBits = 8;\n\tacm_set_line(acm, &acm->line);\n\n\tusb_driver_claim_interface(&acm_driver, data_interface, acm);\n\tusb_set_intfdata(data_interface, acm);\n\n\ttty_dev = tty_port_register_device(&acm->port, acm_tty_driver, minor,\n\t\t\t&control_interface->dev);\n\tif (IS_ERR(tty_dev)) {\n\t\trv = PTR_ERR(tty_dev);\n\t\tgoto alloc_fail6;\n\t}\n\n\tif (quirks & CLEAR_HALT_CONDITIONS) {\n\t\tusb_clear_halt(usb_dev, acm->in);\n\t\tusb_clear_halt(usb_dev, acm->out);\n\t}\n\n\treturn 0;\nalloc_fail6:\n\tif (acm->country_codes) {\n\t\tdevice_remove_file(&acm->control->dev,\n\t\t\t\t&dev_attr_wCountryCodes);\n\t\tdevice_remove_file(&acm->control->dev,\n\t\t\t\t&dev_attr_iCountryCodeRelDate);\n\t\tkfree(acm->country_codes);\n\t}\n\tdevice_remove_file(&acm->control->dev, &dev_attr_bmCapabilities);\nalloc_fail5:\n\tusb_set_intfdata(intf, NULL);\n\tfor (i = 0; i < ACM_NW; i++)\n\t\tusb_free_urb(acm->wb[i].urb);\nalloc_fail4:\n\tfor (i = 0; i < num_rx_buf; i++)\n\t\tusb_free_urb(acm->read_urbs[i]);\n\tacm_read_buffers_free(acm);\n\tusb_free_urb(acm->ctrlurb);\nalloc_fail3:\n\tacm_write_buffers_free(acm);\nalloc_fail2:\n\tusb_free_coherent(usb_dev, ctrlsize, acm->ctrl_buffer, acm->ctrl_dma);\nalloc_fail1:\n\ttty_port_put(&acm->port);\nalloc_fail:\n\treturn rv;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147499,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static void mysql_prune_stmt_list(MYSQL *mysql)\n{\n  LIST *element= mysql->stmts;\n  LIST *pruned_list= 0;\n\n  for (; element; element= element->next)\n  {\n    MYSQL_STMT *stmt= (MYSQL_STMT *) element->data;\n    if (stmt->state != MYSQL_STMT_INIT_DONE)\n    {\n      stmt->mysql= 0;\n      stmt->last_errno= CR_SERVER_LOST;\n      strmov(stmt->last_error, ER(CR_SERVER_LOST));\n      strmov(stmt->sqlstate, unknown_sqlstate);\n    }\n    else\n    {\n      pruned_list= list_add(pruned_list, element);\n    }\n  }\n\n  mysql->stmts= pruned_list;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147738,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static void mysql_prune_stmt_list(MYSQL *mysql)\n{\n  LIST *element= mysql->stmts;\n  for (; element; element= element->next)\n  {\n    MYSQL_STMT *stmt= (MYSQL_STMT *) element->data;\n    if (stmt->state != MYSQL_STMT_INIT_DONE)\n    {\n      stmt->mysql= 0;\n      stmt->last_errno= CR_SERVER_LOST;\n      strmov(stmt->last_error, ER(CR_SERVER_LOST));\n      strmov(stmt->sqlstate, unknown_sqlstate);\n      mysql->stmts= list_delete(mysql->stmts, element);\n    }\n  }\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147739,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "int Http2Stream::DoWrite(WriteWrap* req_wrap,\n                         uv_buf_t* bufs,\n                         size_t nbufs,\n                         uv_stream_t* send_handle) {\n  CHECK_NULL(send_handle);\n  Http2Scope h2scope(this);\n  if (!IsWritable() || IsDestroyed()) {\n    req_wrap->Done(UV_EOF);\n    return 0;\n  }\n  Debug(this, \"queuing %d buffers to send\", id_, nbufs);\n  for (size_t i = 0; i < nbufs; ++i) {\n    // Store the req_wrap on the last write info in the queue, so that it is\n    // only marked as finished once all buffers associated with it are finished.\n    queue_.emplace(nghttp2_stream_write {\n      i == nbufs - 1 ? req_wrap : nullptr,\n      bufs[i]\n    });\n    IncrementAvailableOutboundLength(bufs[i].len);\n  }\n  CHECK_NE(nghttp2_session_resume_data(**session_, id_), NGHTTP2_ERR_NOMEM);\n  return 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147774,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "int Http2Stream::DoWrite(std::unique_ptr<WriteWrap>& req_wrap,\n                         uv_buf_t* bufs,\n                         size_t nbufs,\n                         uv_stream_t* send_handle) {\n  CHECK_NULL(send_handle);\n  Http2Scope h2scope(this);\n  if (!IsWritable() || IsDestroyed()) {\n    req_wrap->Done(UV_EOF);\n    return 0;\n  }\n  Debug(this, \"queuing %d buffers to send\", id_, nbufs);\n  for (size_t i = 0; i < nbufs; ++i) {\n    // Store the req_wrap on the last write info in the queue, so that it is\n    // only marked as finished once all buffers associated with it are finished.\n    queue_.emplace(nghttp2_stream_write {\n      i == nbufs - 1 ? req_wrap.get() : nullptr,\n      bufs[i]\n    });\n    IncrementAvailableOutboundLength(bufs[i].len);\n  }\n  CHECK_NE(nghttp2_session_resume_data(**session_, id_), NGHTTP2_ERR_NOMEM);\n  return 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147775,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "  int DoWrite(WriteWrap* w,\n              uv_buf_t* bufs,\n              size_t count,\n              uv_stream_t* send_handle) override {\n    return UV_ENOSYS;  // Not implemented (yet).\n  }",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147776,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "  int DoWrite(std::unique_ptr<WriteWrap>& w,\n              uv_buf_t* bufs,\n              size_t count,\n              uv_stream_t* send_handle) override {\n    return UV_ENOSYS;  // Not implemented (yet).\n  }",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147777,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "int JSStream::DoWrite(WriteWrap* w,\n                      uv_buf_t* bufs,\n                      size_t count,\n                      uv_stream_t* send_handle) {\n  CHECK_NULL(send_handle);\n\n  HandleScope scope(env()->isolate());\n  Context::Scope context_scope(env()->context());\n\n  Local<Array> bufs_arr = Array::New(env()->isolate(), count);\n  Local<Object> buf;\n  for (size_t i = 0; i < count; i++) {\n    buf = Buffer::Copy(env(), bufs[i].base, bufs[i].len).ToLocalChecked();\n    bufs_arr->Set(i, buf);\n  }\n\n  Local<Value> argv[] = {\n    w->object(),\n    bufs_arr\n  };\n\n  TryCatch try_catch(env()->isolate());\n  Local<Value> value;\n  int value_int = UV_EPROTO;\n  if (!MakeCallback(env()->onwrite_string(),\n                    arraysize(argv),\n                    argv).ToLocal(&value) ||\n      !value->Int32Value(env()->context()).To(&value_int)) {\n    if (!try_catch.HasTerminated())\n      FatalException(env()->isolate(), try_catch);\n  }\n  return value_int;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147778,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "int JSStream::DoWrite(std::unique_ptr<WriteWrap>& w,\n                      uv_buf_t* bufs,\n                      size_t count,\n                      uv_stream_t* send_handle) {\n  CHECK_NULL(send_handle);\n\n  HandleScope scope(env()->isolate());\n  Context::Scope context_scope(env()->context());\n\n  Local<Array> bufs_arr = Array::New(env()->isolate(), count);\n  Local<Object> buf;\n  for (size_t i = 0; i < count; i++) {\n    buf = Buffer::Copy(env(), bufs[i].base, bufs[i].len).ToLocalChecked();\n    bufs_arr->Set(i, buf);\n  }\n\n  Local<Value> argv[] = {\n    w.get()->object(),\n    bufs_arr\n  };\n\n  TryCatch try_catch(env()->isolate());\n  Local<Value> value;\n  int value_int = UV_EPROTO;\n  if (!MakeCallback(env()->onwrite_string(),\n                    arraysize(argv),\n                    argv).ToLocal(&value) ||\n      !value->Int32Value(env()->context()).To(&value_int)) {\n    if (!try_catch.HasTerminated())\n      FatalException(env()->isolate(), try_catch);\n  }\n  return value_int;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147779,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "int LibuvStreamWrap::DoWrite(WriteWrap* req_wrap,\n                             uv_buf_t* bufs,\n                             size_t count,\n                             uv_stream_t* send_handle) {\n  LibuvWriteWrap* w = static_cast<LibuvWriteWrap*>(req_wrap);\n  int r;\n  if (send_handle == nullptr) {\n    r = w->Dispatch(uv_write, stream(), bufs, count, AfterUvWrite);\n  } else {\n    r = w->Dispatch(uv_write2,\n                    stream(),\n                    bufs,\n                    count,\n                    send_handle,\n                    AfterUvWrite);\n  }\n\n  if (!r) {\n    size_t bytes = 0;\n    for (size_t i = 0; i < count; i++)\n      bytes += bufs[i].len;\n    if (stream()->type == UV_TCP) {\n      NODE_COUNT_NET_BYTES_SENT(bytes);\n    } else if (stream()->type == UV_NAMED_PIPE) {\n      NODE_COUNT_PIPE_BYTES_SENT(bytes);\n    }\n  }\n\n  return r;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147780,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "int LibuvStreamWrap::DoWrite(std::unique_ptr<WriteWrap>& req_wrap,\n                             uv_buf_t* bufs,\n                             size_t count,\n                             uv_stream_t* send_handle) {\n  LibuvWriteWrap* w = static_cast<LibuvWriteWrap*>(req_wrap.get());\n  int r;\n  if (send_handle == nullptr) {\n    r = w->Dispatch(uv_write, stream(), bufs, count, AfterUvWrite);\n  } else {\n    r = w->Dispatch(uv_write2,\n                    stream(),\n                    bufs,\n                    count,\n                    send_handle,\n                    AfterUvWrite);\n  }\n\n  if (!r) {\n    size_t bytes = 0;\n    for (size_t i = 0; i < count; i++)\n      bytes += bufs[i].len;\n    if (stream()->type == UV_TCP) {\n      NODE_COUNT_NET_BYTES_SENT(bytes);\n    } else if (stream()->type == UV_NAMED_PIPE) {\n      NODE_COUNT_PIPE_BYTES_SENT(bytes);\n    }\n  }\n\n  return r;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147781,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "inline StreamWriteResult StreamBase::Write(\n    uv_buf_t* bufs,\n    size_t count,\n    uv_stream_t* send_handle,\n    v8::Local<v8::Object> req_wrap_obj) {\n  Environment* env = stream_env();\n  int err;\n\n  size_t total_bytes = 0;\n  for (size_t i = 0; i < count; ++i)\n    total_bytes += bufs[i].len;\n  bytes_written_ += total_bytes;\n\n  if (send_handle == nullptr) {\n    err = DoTryWrite(&bufs, &count);\n    if (err != 0 || count == 0) {\n      return StreamWriteResult { false, err, nullptr, total_bytes };\n    }\n  }\n\n  HandleScope handle_scope(env->isolate());\n\n  if (req_wrap_obj.IsEmpty()) {\n    req_wrap_obj =\n        env->write_wrap_template()\n            ->NewInstance(env->context()).ToLocalChecked();\n    StreamReq::ResetObject(req_wrap_obj);\n  }\n\n  AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(GetAsyncWrap());\n  WriteWrap* req_wrap = CreateWriteWrap(req_wrap_obj);\n\n  err = DoWrite(req_wrap, bufs, count, send_handle);\n  bool async = err == 0;\n\n  if (!async) {\n    req_wrap->Dispose();\n    req_wrap = nullptr;\n  }\n\n  const char* msg = Error();\n  if (msg != nullptr) {\n    req_wrap_obj->Set(env->error_string(), OneByteString(env->isolate(), msg));\n    ClearError();\n  }\n\n  return StreamWriteResult { async, err, req_wrap, total_bytes };\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147782,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "inline StreamWriteResult StreamBase::Write(\n    uv_buf_t* bufs,\n    size_t count,\n    uv_stream_t* send_handle,\n    v8::Local<v8::Object> req_wrap_obj) {\n  Environment* env = stream_env();\n  int err;\n\n  size_t total_bytes = 0;\n  for (size_t i = 0; i < count; ++i)\n    total_bytes += bufs[i].len;\n  bytes_written_ += total_bytes;\n\n  if (send_handle == nullptr) {\n    err = DoTryWrite(&bufs, &count);\n    if (err != 0 || count == 0) {\n      return StreamWriteResult { false, err, nullptr, total_bytes };\n    }\n  }\n\n  HandleScope handle_scope(env->isolate());\n\n  if (req_wrap_obj.IsEmpty()) {\n    req_wrap_obj =\n        env->write_wrap_template()\n            ->NewInstance(env->context()).ToLocalChecked();\n    StreamReq::ResetObject(req_wrap_obj);\n  }\n\n  AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(GetAsyncWrap());\n  std::unique_ptr<WriteWrap> req_wrap{CreateWriteWrap(req_wrap_obj)};\n\n  err = DoWrite(req_wrap, bufs, count, send_handle);\n  bool async = err == 0;\n\n  if (!async && req_wrap != nullptr) {\n    req_wrap->Dispose();\n    req_wrap.release();\n  }\n\n  const char* msg = Error();\n  if (msg != nullptr) {\n    req_wrap_obj->Set(env->error_string(), OneByteString(env->isolate(), msg));\n    ClearError();\n  }\n\n  return StreamWriteResult { async, err, req_wrap.release(), total_bytes };\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147783,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "int TLSWrap::DoWrite(WriteWrap* w,\n                     uv_buf_t* bufs,\n                     size_t count,\n                     uv_stream_t* send_handle) {\n  CHECK_NULL(send_handle);\n  Debug(this, \"DoWrite()\");\n\n  if (ssl_ == nullptr) {\n    ClearError();\n    error_ = \"Write after DestroySSL\";\n    return UV_EPROTO;\n  }\n\n  size_t length = 0;\n  size_t i;\n  for (i = 0; i < count; i++)\n    length += bufs[i].len;\n\n  // We want to trigger a Write() on the underlying stream to drive the stream\n  // system, but don't want to encrypt empty buffers into a TLS frame, so see\n  // if we can find something to Write().\n  // First, call ClearOut(). It does an SSL_read(), which might cause handshake\n  // or other internal messages to be encrypted. If it does, write them later\n  // with EncOut().\n  // If there is still no encrypted output, call Write(bufs) on the underlying\n  // stream. Since the bufs are empty, it won't actually write non-TLS data\n  // onto the socket, we just want the side-effects. After, make sure the\n  // WriteWrap was accepted by the stream, or that we call Done() on it.\n  if (length == 0) {\n    Debug(this, \"Empty write\");\n    ClearOut();\n    if (BIO_pending(enc_out_) == 0) {\n      Debug(this, \"No pending encrypted output, writing to underlying stream\");\n      CHECK_NULL(current_empty_write_);\n      current_empty_write_ = w;\n      StreamWriteResult res =\n          underlying_stream()->Write(bufs, count, send_handle);\n      if (!res.async) {\n        env()->SetImmediate([](Environment* env, void* data) {\n          TLSWrap* self = static_cast<TLSWrap*>(data);\n          self->OnStreamAfterWrite(self->current_empty_write_, 0);\n        }, this, object());\n      }\n      return 0;\n    }\n  }\n\n  // Store the current write wrap\n  CHECK_NULL(current_write_);\n  current_write_ = w;\n\n  // Write encrypted data to underlying stream and call Done().\n  if (length == 0) {\n    EncOut();\n    return 0;\n  }\n\n  std::vector<char> data;\n  crypto::MarkPopErrorOnReturn mark_pop_error_on_return;\n\n  int written = 0;\n  if (count != 1) {\n    data = std::vector<char>(length);\n    size_t offset = 0;\n    for (i = 0; i < count; i++) {\n      memcpy(data.data() + offset, bufs[i].base, bufs[i].len);\n      offset += bufs[i].len;\n    }\n    written = SSL_write(ssl_.get(), data.data(), length);\n  } else {\n    // Only one buffer: try to write directly, only store if it fails\n    written = SSL_write(ssl_.get(), bufs[0].base, bufs[0].len);\n    if (written == -1) {\n      data = std::vector<char>(length);\n      memcpy(data.data(), bufs[0].base, bufs[0].len);\n    }\n  }\n\n  CHECK(written == -1 || written == static_cast<int>(length));\n  Debug(this, \"Writing %zu bytes, written = %d\", length, written);\n\n  if (written == -1) {\n    int err;\n    Local<Value> arg = GetSSLError(written, &err, &error_);\n\n    // If we stopped writing because of an error, it's fatal, discard the data.\n    if (!arg.IsEmpty()) {\n      Debug(this, \"Got SSL error (%d), returning UV_EPROTO\", err);\n      current_write_ = nullptr;\n      return UV_EPROTO;\n    }\n\n    Debug(this, \"Saving data for later write\");\n    // Otherwise, save unwritten data so it can be written later by ClearIn().\n    CHECK_EQ(pending_cleartext_input_.size(), 0);\n    pending_cleartext_input_ = std::move(data);\n  }\n\n  // Write any encrypted/handshake output that may be ready.\n  EncOut();\n\n  return 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147784,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "int TLSWrap::DoWrite(std::unique_ptr<WriteWrap>& w,\n                     uv_buf_t* bufs,\n                     size_t count,\n                     uv_stream_t* send_handle) {\n  CHECK_NULL(send_handle);\n  Debug(this, \"DoWrite()\");\n\n  if (ssl_ == nullptr) {\n    ClearError();\n    error_ = \"Write after DestroySSL\";\n    return UV_EPROTO;\n  }\n\n  size_t length = 0;\n  size_t i;\n  for (i = 0; i < count; i++)\n    length += bufs[i].len;\n\n  // We want to trigger a Write() on the underlying stream to drive the stream\n  // system, but don't want to encrypt empty buffers into a TLS frame, so see\n  // if we can find something to Write().\n  // First, call ClearOut(). It does an SSL_read(), which might cause handshake\n  // or other internal messages to be encrypted. If it does, write them later\n  // with EncOut().\n  // If there is still no encrypted output, call Write(bufs) on the underlying\n  // stream. Since the bufs are empty, it won't actually write non-TLS data\n  // onto the socket, we just want the side-effects. After, make sure the\n  // WriteWrap was accepted by the stream, or that we call Done() on it.\n  if (length == 0) {\n    Debug(this, \"Empty write\");\n    ClearOut();\n    if (BIO_pending(enc_out_) == 0) {\n      Debug(this, \"No pending encrypted output, writing to underlying stream\");\n      CHECK_NULL(current_empty_write_);\n      current_empty_write_ = w.get();\n      StreamWriteResult res =\n          underlying_stream()->Write(bufs, count, send_handle);\n      if (!res.async) {\n        env()->SetImmediate([](Environment* env, void* data) {\n          TLSWrap* self = static_cast<TLSWrap*>(data);\n          self->OnStreamAfterWrite(self->current_empty_write_, 0);\n        }, this, object());\n      }\n      return 0;\n    }\n  }\n\n  // Store the current write wrap\n  CHECK_NULL(current_write_);\n  current_write_ = std::move(w);\n\n  // Write encrypted data to underlying stream and call Done().\n  if (length == 0) {\n    EncOut();\n    return 0;\n  }\n\n  std::vector<char> data;\n  crypto::MarkPopErrorOnReturn mark_pop_error_on_return;\n\n  int written = 0;\n  if (count != 1) {\n    data = std::vector<char>(length);\n    size_t offset = 0;\n    for (i = 0; i < count; i++) {\n      memcpy(data.data() + offset, bufs[i].base, bufs[i].len);\n      offset += bufs[i].len;\n    }\n    written = SSL_write(ssl_.get(), data.data(), length);\n  } else {\n    // Only one buffer: try to write directly, only store if it fails\n    written = SSL_write(ssl_.get(), bufs[0].base, bufs[0].len);\n    if (written == -1) {\n      data = std::vector<char>(length);\n      memcpy(data.data(), bufs[0].base, bufs[0].len);\n    }\n  }\n\n  CHECK(written == -1 || written == static_cast<int>(length));\n  Debug(this, \"Writing %zu bytes, written = %d\", length, written);\n\n  if (written == -1) {\n    int err;\n    Local<Value> arg = GetSSLError(written, &err, &error_);\n\n    // If we stopped writing because of an error, it's fatal, discard the data.\n    if (!arg.IsEmpty()) {\n      Debug(this, \"Got SSL error (%d), returning UV_EPROTO\", err);\n      current_write_.release();\n      return UV_EPROTO;\n    }\n\n    Debug(this, \"Saving data for later write\");\n    // Otherwise, save unwritten data so it can be written later by ClearIn().\n    CHECK_EQ(pending_cleartext_input_.size(), 0);\n    pending_cleartext_input_ = std::move(data);\n  }\n\n  // Write any encrypted/handshake output that may be ready.\n  EncOut();\n\n  w.reset(current_write_.get());\n\n  return 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147785,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "StreamWriteResult StreamBase::Write(\n    uv_buf_t* bufs,\n    size_t count,\n    uv_stream_t* send_handle,\n    v8::Local<v8::Object> req_wrap_obj) {\n  Environment* env = stream_env();\n  int err;\n\n  size_t total_bytes = 0;\n  for (size_t i = 0; i < count; ++i)\n    total_bytes += bufs[i].len;\n  bytes_written_ += total_bytes;\n\n  if (send_handle == nullptr) {\n    err = DoTryWrite(&bufs, &count);\n    if (err != 0 || count == 0) {\n      return StreamWriteResult { false, err, nullptr, total_bytes };\n    }\n  }\n\n  v8::HandleScope handle_scope(env->isolate());\n\n  if (req_wrap_obj.IsEmpty()) {\n    if (!env->write_wrap_template()\n             ->NewInstance(env->context())\n             .ToLocal(&req_wrap_obj)) {\n      return StreamWriteResult { false, UV_EBUSY, nullptr, 0 };\n    }\n    StreamReq::ResetObject(req_wrap_obj);\n  }\n\n  AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(GetAsyncWrap());\n  WriteWrap* req_wrap = CreateWriteWrap(req_wrap_obj);\n\n  err = DoWrite(req_wrap, bufs, count, send_handle);\n  bool async = err == 0;\n\n  if (!async) {\n    req_wrap->Dispose();\n    req_wrap = nullptr;\n  }\n\n  const char* msg = Error();\n  if (msg != nullptr) {\n    req_wrap_obj->Set(env->context(),\n                      env->error_string(),\n                      OneByteString(env->isolate(), msg)).Check();\n    ClearError();\n  }\n\n  return StreamWriteResult { async, err, req_wrap, total_bytes };\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147786,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "StreamWriteResult StreamBase::Write(\n    uv_buf_t* bufs,\n    size_t count,\n    uv_stream_t* send_handle,\n    v8::Local<v8::Object> req_wrap_obj) {\n  Environment* env = stream_env();\n  int err;\n\n  size_t total_bytes = 0;\n  for (size_t i = 0; i < count; ++i)\n    total_bytes += bufs[i].len;\n  bytes_written_ += total_bytes;\n\n  if (send_handle == nullptr) {\n    err = DoTryWrite(&bufs, &count);\n    if (err != 0 || count == 0) {\n      return StreamWriteResult { false, err, nullptr, total_bytes, {} };\n    }\n  }\n\n  v8::HandleScope handle_scope(env->isolate());\n\n  if (req_wrap_obj.IsEmpty()) {\n    if (!env->write_wrap_template()\n             ->NewInstance(env->context())\n             .ToLocal(&req_wrap_obj)) {\n      return StreamWriteResult { false, UV_EBUSY, nullptr, 0, {} };\n    }\n    StreamReq::ResetObject(req_wrap_obj);\n  }\n\n  AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(GetAsyncWrap());\n  WriteWrap* req_wrap = CreateWriteWrap(req_wrap_obj);\n  BaseObjectPtr<AsyncWrap> req_wrap_ptr(req_wrap->GetAsyncWrap());\n\n  err = DoWrite(req_wrap, bufs, count, send_handle);\n  bool async = err == 0;\n\n  if (!async) {\n    req_wrap->Dispose();\n    req_wrap = nullptr;\n  }\n\n  const char* msg = Error();\n  if (msg != nullptr) {\n    req_wrap_obj->Set(env->context(),\n                      env->error_string(),\n                      OneByteString(env->isolate(), msg)).Check();\n    ClearError();\n  }\n\n  return StreamWriteResult {\n      async, err, req_wrap, total_bytes, std::move(req_wrap_ptr) };\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147787,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "void Http2Stream::SubmitRstStream(const uint32_t code) {\n  CHECK(!this->is_destroyed());\n  code_ = code;\n\n  // If RST_STREAM frame is received and stream is not writable\n  // because it is busy reading data, don't try force purging it.\n  // Instead add the stream to pending stream list and process\n  // the pending data when it is safe to do so. This is to avoid\n  // double free error due to unwanted behavior of nghttp2.\n  // Ref:https://github.com/nodejs/node/issues/38964\n\n  // Add stream to the pending list if it is received with scope\n  // below in the stack. The pending list may not get processed\n  // if RST_STREAM received is not in scope and added to the list\n  // causing endpoint to hang.\n  if (session_->is_in_scope() &&\n      !is_writable() && is_reading()) {\n    session_->AddPendingRstStream(id_);\n    return;\n  }\n\n\n  // If possible, force a purge of any currently pending data here to make sure\n  // it is sent before closing the stream. If it returns non-zero then we need\n  // to wait until the current write finishes and try again to avoid nghttp2\n  // behaviour where it prioritizes RstStream over everything else.\n  if (session_->SendPendingData() != 0) {\n    session_->AddPendingRstStream(id_);\n    return;\n  }\n\n  FlushRstStream();\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147806,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "void Http2Stream::SubmitRstStream(const uint32_t code) {\n  CHECK(!this->is_destroyed());\n  code_ = code;\n\n  auto is_stream_cancel = [](const uint32_t code) {\n    return code == NGHTTP2_CANCEL;\n  };\n\n  // If RST_STREAM frame is received with error code NGHTTP2_CANCEL,\n  // add it to the pending list and don't force purge the data. It is\n  // to avoids the double free error due to unwanted behavior of nghttp2.\n\n  // Add stream to the pending list only if it is received with scope\n  // below in the stack. The pending list may not get processed\n  // if RST_STREAM received is not in scope and added to the list\n  // causing endpoint to hang.\n  if (session_->is_in_scope() && is_stream_cancel(code)) {\n      session_->AddPendingRstStream(id_);\n      return;\n  }\n\n\n  // If possible, force a purge of any currently pending data here to make sure\n  // it is sent before closing the stream. If it returns non-zero then we need\n  // to wait until the current write finishes and try again to avoid nghttp2\n  // behaviour where it prioritizes RstStream over everything else.\n  if (session_->SendPendingData() != 0) {\n    session_->AddPendingRstStream(id_);\n    return;\n  }\n\n  FlushRstStream();\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147807,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "void handler::print_error(int error, myf errflag)\n{\n  bool fatal_error= 0;\n  DBUG_ENTER(\"handler::print_error\");\n  DBUG_PRINT(\"enter\",(\"error: %d\",error));\n\n  if (ha_thd()->transaction_rollback_request)\n  {\n    /* Ensure this becomes a true error */\n    errflag&= ~(ME_WARNING | ME_NOTE);\n  }\n\n  int textno= -1; // impossible value\n  switch (error) {\n  case EACCES:\n    textno=ER_OPEN_AS_READONLY;\n    break;\n  case EAGAIN:\n    textno=ER_FILE_USED;\n    break;\n  case ENOENT:\n  case ENOTDIR:\n  case ELOOP:\n    textno=ER_FILE_NOT_FOUND;\n    break;\n  case ENOSPC:\n  case HA_ERR_DISK_FULL:\n    textno= ER_DISK_FULL;\n    SET_FATAL_ERROR;                            // Ensure error is logged\n    break;\n  case HA_ERR_KEY_NOT_FOUND:\n  case HA_ERR_NO_ACTIVE_RECORD:\n  case HA_ERR_RECORD_DELETED:\n  case HA_ERR_END_OF_FILE:\n    /*\n      This errors is not not normally fatal (for example for reads). However\n      if you get it during an update or delete, then its fatal.\n      As the user is calling print_error() (which is not done on read), we\n      assume something when wrong with the update or delete.\n    */\n    SET_FATAL_ERROR;\n    textno=ER_KEY_NOT_FOUND;\n    break;\n  case HA_ERR_ABORTED_BY_USER:\n  {\n    DBUG_ASSERT(ha_thd()->killed);\n    ha_thd()->send_kill_message();\n    DBUG_VOID_RETURN;\n  }\n  case HA_ERR_WRONG_MRG_TABLE_DEF:\n    textno=ER_WRONG_MRG_TABLE;\n    break;\n  case HA_ERR_FOUND_DUPP_KEY:\n  {\n    if (table)\n    {\n      uint key_nr=get_dup_key(error);\n      if ((int) key_nr >= 0 && key_nr < table->s->keys)\n      {\n        print_keydup_error(table, &table->key_info[key_nr], errflag);\n        DBUG_VOID_RETURN;\n      }\n    }\n    textno=ER_DUP_KEY;\n    break;\n  }\n  case HA_ERR_FOREIGN_DUPLICATE_KEY:\n  {\n    char rec_buf[MAX_KEY_LENGTH];\n    String rec(rec_buf, sizeof(rec_buf), system_charset_info);\n    /* Table is opened and defined at this point */\n\n    /*\n      Just print the subset of fields that are part of the first index,\n      printing the whole row from there is not easy.\n    */\n    key_unpack(&rec, table, &table->key_info[0]);\n\n    char child_table_name[NAME_LEN + 1];\n    char child_key_name[NAME_LEN + 1];\n    if (get_foreign_dup_key(child_table_name, sizeof(child_table_name),\n                            child_key_name, sizeof(child_key_name)))\n    {\n      my_error(ER_FOREIGN_DUPLICATE_KEY_WITH_CHILD_INFO, errflag,\n               table_share->table_name.str, rec.c_ptr_safe(),\n               child_table_name, child_key_name);\n      }\n    else\n    {\n      my_error(ER_FOREIGN_DUPLICATE_KEY_WITHOUT_CHILD_INFO, errflag,\n               table_share->table_name.str, rec.c_ptr_safe());\n    }\n    DBUG_VOID_RETURN;\n  }\n  case HA_ERR_NULL_IN_SPATIAL:\n    my_error(ER_CANT_CREATE_GEOMETRY_OBJECT, errflag);\n    DBUG_VOID_RETURN;\n  case HA_ERR_FOUND_DUPP_UNIQUE:\n    textno=ER_DUP_UNIQUE;\n    break;\n  case HA_ERR_RECORD_CHANGED:\n    /*\n      This is not fatal error when using HANDLER interface\n      SET_FATAL_ERROR;\n    */\n    textno=ER_CHECKREAD;\n    break;\n  case HA_ERR_CRASHED:\n    SET_FATAL_ERROR;\n    textno=ER_NOT_KEYFILE;\n    break;\n  case HA_ERR_WRONG_IN_RECORD:\n    SET_FATAL_ERROR;\n    textno= ER_CRASHED_ON_USAGE;\n    break;\n  case HA_ERR_CRASHED_ON_USAGE:\n    SET_FATAL_ERROR;\n    textno=ER_CRASHED_ON_USAGE;\n    break;\n  case HA_ERR_NOT_A_TABLE:\n    textno= error;\n    break;\n  case HA_ERR_CRASHED_ON_REPAIR:\n    SET_FATAL_ERROR;\n    textno=ER_CRASHED_ON_REPAIR;\n    break;\n  case HA_ERR_OUT_OF_MEM:\n    textno=ER_OUT_OF_RESOURCES;\n    break;\n  case HA_ERR_WRONG_COMMAND:\n    my_error(ER_ILLEGAL_HA, MYF(0), table_type(), table_share->db.str,\n             table_share->table_name.str);\n    DBUG_VOID_RETURN;\n    break;\n  case HA_ERR_OLD_FILE:\n    textno=ER_OLD_KEYFILE;\n    break;\n  case HA_ERR_UNSUPPORTED:\n    textno=ER_UNSUPPORTED_EXTENSION;\n    break;\n  case HA_ERR_RECORD_FILE_FULL:\n  {\n    textno=ER_RECORD_FILE_FULL;\n    /* Write the error message to error log */\n    errflag|= ME_ERROR_LOG;\n    break;\n  }\n  case HA_ERR_INDEX_FILE_FULL:\n  {\n    textno=ER_INDEX_FILE_FULL;\n    /* Write the error message to error log */\n    errflag|= ME_ERROR_LOG;\n    break;\n  }\n  case HA_ERR_LOCK_WAIT_TIMEOUT:\n    textno=ER_LOCK_WAIT_TIMEOUT;\n    break;\n  case HA_ERR_LOCK_TABLE_FULL:\n    textno=ER_LOCK_TABLE_FULL;\n    break;\n  case HA_ERR_LOCK_DEADLOCK:\n  {\n    String str, full_err_msg(ER_DEFAULT(ER_LOCK_DEADLOCK), system_charset_info);\n\n    get_error_message(error, &str);\n    full_err_msg.append(str);\n    my_printf_error(ER_LOCK_DEADLOCK, \"%s\", errflag, full_err_msg.c_ptr_safe());\n    DBUG_VOID_RETURN;\n  }\n  case HA_ERR_READ_ONLY_TRANSACTION:\n    textno=ER_READ_ONLY_TRANSACTION;\n    break;\n  case HA_ERR_CANNOT_ADD_FOREIGN:\n    textno=ER_CANNOT_ADD_FOREIGN;\n    break;\n  case HA_ERR_ROW_IS_REFERENCED:\n  {\n    String str;\n    get_error_message(error, &str);\n    my_printf_error(ER_ROW_IS_REFERENCED_2,\n                    ER(str.length() ? ER_ROW_IS_REFERENCED_2 : ER_ROW_IS_REFERENCED),\n                    errflag, str.c_ptr_safe());\n    DBUG_VOID_RETURN;\n  }\n  case HA_ERR_NO_REFERENCED_ROW:\n  {\n    String str;\n    get_error_message(error, &str);\n    my_printf_error(ER_NO_REFERENCED_ROW_2,\n                    ER(str.length() ? ER_NO_REFERENCED_ROW_2 : ER_NO_REFERENCED_ROW),\n                    errflag, str.c_ptr_safe());\n    DBUG_VOID_RETURN;\n  }\n  case HA_ERR_TABLE_DEF_CHANGED:\n    textno=ER_TABLE_DEF_CHANGED;\n    break;\n  case HA_ERR_NO_SUCH_TABLE:\n    my_error(ER_NO_SUCH_TABLE_IN_ENGINE, errflag, table_share->db.str,\n             table_share->table_name.str);\n    DBUG_VOID_RETURN;\n  case HA_ERR_RBR_LOGGING_FAILED:\n    textno= ER_BINLOG_ROW_LOGGING_FAILED;\n    break;\n  case HA_ERR_DROP_INDEX_FK:\n  {\n    const char *ptr= \"???\";\n    uint key_nr= get_dup_key(error);\n    if ((int) key_nr >= 0)\n      ptr= table->key_info[key_nr].name.str;\n    my_error(ER_DROP_INDEX_FK, errflag, ptr);\n    DBUG_VOID_RETURN;\n  }\n  case HA_ERR_TABLE_NEEDS_UPGRADE:\n    textno= ER_TABLE_NEEDS_UPGRADE;\n    my_error(ER_TABLE_NEEDS_UPGRADE, errflag,\n             \"TABLE\", table_share->table_name.str);\n    DBUG_VOID_RETURN;\n  case HA_ERR_NO_PARTITION_FOUND:\n    textno=ER_WRONG_PARTITION_NAME;\n    break;\n  case HA_ERR_TABLE_READONLY:\n    textno= ER_OPEN_AS_READONLY;\n    break;\n  case HA_ERR_AUTOINC_READ_FAILED:\n    textno= ER_AUTOINC_READ_FAILED;\n    break;\n  case HA_ERR_AUTOINC_ERANGE:\n    textno= error;\n    my_error(textno, errflag, table->next_number_field->field_name.str,\n             table->in_use->get_stmt_da()->current_row_for_warning());\n    DBUG_VOID_RETURN;\n    break;\n  case HA_ERR_TOO_MANY_CONCURRENT_TRXS:\n    textno= ER_TOO_MANY_CONCURRENT_TRXS;\n    break;\n  case HA_ERR_INDEX_COL_TOO_LONG:\n    textno= ER_INDEX_COLUMN_TOO_LONG;\n    break;\n  case HA_ERR_NOT_IN_LOCK_PARTITIONS:\n    textno=ER_ROW_DOES_NOT_MATCH_GIVEN_PARTITION_SET;\n    break;\n  case HA_ERR_INDEX_CORRUPT:\n    textno= ER_INDEX_CORRUPT;\n    break;\n  case HA_ERR_UNDO_REC_TOO_BIG:\n    textno= ER_UNDO_RECORD_TOO_BIG;\n    break;\n  case HA_ERR_TABLE_IN_FK_CHECK:\n    textno= ER_TABLE_IN_FK_CHECK;\n    break;\n  case HA_ERR_PARTITION_LIST:\n    my_error(ER_VERS_NOT_ALLOWED, errflag, table->s->db.str, table->s->table_name.str);\n    DBUG_VOID_RETURN;\n  default:\n    {\n      /* The error was \"unknown\" to this function.\n\t Ask handler if it has got a message for this error */\n      bool temporary= FALSE;\n      String str;\n      temporary= get_error_message(error, &str);\n      if (!str.is_empty())\n      {\n\tconst char* engine= table_type();\n\tif (temporary)\n\t  my_error(ER_GET_TEMPORARY_ERRMSG, errflag, error, str.c_ptr(),\n                   engine);\n\telse\n        {\n          SET_FATAL_ERROR;\n\t  my_error(ER_GET_ERRMSG, errflag, error, str.c_ptr(), engine);\n        }\n      }\n      else\n        my_error(ER_GET_ERRNO, errflag, error, table_type());\n      DBUG_VOID_RETURN;\n    }\n  }\n  DBUG_ASSERT(textno > 0);\n  if (unlikely(fatal_error))\n  {\n    /* Ensure this becomes a true error */\n    errflag&= ~(ME_WARNING | ME_NOTE);\n    if ((debug_assert_if_crashed_table ||\n                      global_system_variables.log_warnings > 1))\n    {\n      /*\n        Log error to log before we crash or if extended warnings are requested\n      */\n      errflag|= ME_ERROR_LOG;\n    }\n  }\n\n  /* if we got an OS error from a file-based engine, specify a path of error */\n  if (error < HA_ERR_FIRST && bas_ext()[0])\n  {\n    char buff[FN_REFLEN];\n    strxnmov(buff, sizeof(buff),\n             table_share->normalized_path.str, bas_ext()[0], NULL);\n    my_error(textno, errflag, buff, error);\n  }\n  else\n    my_error(textno, errflag, table_share->table_name.str, error);\n  DBUG_VOID_RETURN;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147822,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "void handler::print_error(int error, myf errflag)\n{\n  bool fatal_error= 0;\n  DBUG_ENTER(\"handler::print_error\");\n  DBUG_PRINT(\"enter\",(\"error: %d\",error));\n\n  if (ha_thd()->transaction_rollback_request)\n  {\n    /* Ensure this becomes a true error */\n    errflag&= ~(ME_WARNING | ME_NOTE);\n  }\n\n  int textno= -1; // impossible value\n  switch (error) {\n  case EACCES:\n    textno=ER_OPEN_AS_READONLY;\n    break;\n  case EAGAIN:\n    textno=ER_FILE_USED;\n    break;\n  case ENOENT:\n  case ENOTDIR:\n  case ELOOP:\n    textno=ER_FILE_NOT_FOUND;\n    break;\n  case ENOSPC:\n  case HA_ERR_DISK_FULL:\n    textno= ER_DISK_FULL;\n    SET_FATAL_ERROR;                            // Ensure error is logged\n    break;\n  case HA_ERR_KEY_NOT_FOUND:\n  case HA_ERR_NO_ACTIVE_RECORD:\n  case HA_ERR_RECORD_DELETED:\n  case HA_ERR_END_OF_FILE:\n    /*\n      This errors is not not normally fatal (for example for reads). However\n      if you get it during an update or delete, then its fatal.\n      As the user is calling print_error() (which is not done on read), we\n      assume something when wrong with the update or delete.\n    */\n    SET_FATAL_ERROR;\n    textno=ER_KEY_NOT_FOUND;\n    break;\n  case HA_ERR_ABORTED_BY_USER:\n  {\n    DBUG_ASSERT(ha_thd()->killed);\n    ha_thd()->send_kill_message();\n    DBUG_VOID_RETURN;\n  }\n  case HA_ERR_WRONG_MRG_TABLE_DEF:\n    textno=ER_WRONG_MRG_TABLE;\n    break;\n  case HA_ERR_FOUND_DUPP_KEY:\n  {\n    if (table)\n    {\n      uint key_nr=get_dup_key(error);\n      if ((int) key_nr >= 0 && key_nr < table->s->keys)\n      {\n        print_keydup_error(table, &table->key_info[key_nr], errflag);\n        table->file->errkey= -1;\n        DBUG_VOID_RETURN;\n      }\n    }\n    textno=ER_DUP_KEY;\n    break;\n  }\n  case HA_ERR_FOREIGN_DUPLICATE_KEY:\n  {\n    char rec_buf[MAX_KEY_LENGTH];\n    String rec(rec_buf, sizeof(rec_buf), system_charset_info);\n    /* Table is opened and defined at this point */\n\n    /*\n      Just print the subset of fields that are part of the first index,\n      printing the whole row from there is not easy.\n    */\n    key_unpack(&rec, table, &table->key_info[0]);\n\n    char child_table_name[NAME_LEN + 1];\n    char child_key_name[NAME_LEN + 1];\n    if (get_foreign_dup_key(child_table_name, sizeof(child_table_name),\n                            child_key_name, sizeof(child_key_name)))\n    {\n      my_error(ER_FOREIGN_DUPLICATE_KEY_WITH_CHILD_INFO, errflag,\n               table_share->table_name.str, rec.c_ptr_safe(),\n               child_table_name, child_key_name);\n      }\n    else\n    {\n      my_error(ER_FOREIGN_DUPLICATE_KEY_WITHOUT_CHILD_INFO, errflag,\n               table_share->table_name.str, rec.c_ptr_safe());\n    }\n    DBUG_VOID_RETURN;\n  }\n  case HA_ERR_NULL_IN_SPATIAL:\n    my_error(ER_CANT_CREATE_GEOMETRY_OBJECT, errflag);\n    DBUG_VOID_RETURN;\n  case HA_ERR_FOUND_DUPP_UNIQUE:\n    textno=ER_DUP_UNIQUE;\n    break;\n  case HA_ERR_RECORD_CHANGED:\n    /*\n      This is not fatal error when using HANDLER interface\n      SET_FATAL_ERROR;\n    */\n    textno=ER_CHECKREAD;\n    break;\n  case HA_ERR_CRASHED:\n    SET_FATAL_ERROR;\n    textno=ER_NOT_KEYFILE;\n    break;\n  case HA_ERR_WRONG_IN_RECORD:\n    SET_FATAL_ERROR;\n    textno= ER_CRASHED_ON_USAGE;\n    break;\n  case HA_ERR_CRASHED_ON_USAGE:\n    SET_FATAL_ERROR;\n    textno=ER_CRASHED_ON_USAGE;\n    break;\n  case HA_ERR_NOT_A_TABLE:\n    textno= error;\n    break;\n  case HA_ERR_CRASHED_ON_REPAIR:\n    SET_FATAL_ERROR;\n    textno=ER_CRASHED_ON_REPAIR;\n    break;\n  case HA_ERR_OUT_OF_MEM:\n    textno=ER_OUT_OF_RESOURCES;\n    break;\n  case HA_ERR_WRONG_COMMAND:\n    my_error(ER_ILLEGAL_HA, MYF(0), table_type(), table_share->db.str,\n             table_share->table_name.str);\n    DBUG_VOID_RETURN;\n    break;\n  case HA_ERR_OLD_FILE:\n    textno=ER_OLD_KEYFILE;\n    break;\n  case HA_ERR_UNSUPPORTED:\n    textno=ER_UNSUPPORTED_EXTENSION;\n    break;\n  case HA_ERR_RECORD_FILE_FULL:\n  {\n    textno=ER_RECORD_FILE_FULL;\n    /* Write the error message to error log */\n    errflag|= ME_ERROR_LOG;\n    break;\n  }\n  case HA_ERR_INDEX_FILE_FULL:\n  {\n    textno=ER_INDEX_FILE_FULL;\n    /* Write the error message to error log */\n    errflag|= ME_ERROR_LOG;\n    break;\n  }\n  case HA_ERR_LOCK_WAIT_TIMEOUT:\n    textno=ER_LOCK_WAIT_TIMEOUT;\n    break;\n  case HA_ERR_LOCK_TABLE_FULL:\n    textno=ER_LOCK_TABLE_FULL;\n    break;\n  case HA_ERR_LOCK_DEADLOCK:\n  {\n    String str, full_err_msg(ER_DEFAULT(ER_LOCK_DEADLOCK), system_charset_info);\n\n    get_error_message(error, &str);\n    full_err_msg.append(str);\n    my_printf_error(ER_LOCK_DEADLOCK, \"%s\", errflag, full_err_msg.c_ptr_safe());\n    DBUG_VOID_RETURN;\n  }\n  case HA_ERR_READ_ONLY_TRANSACTION:\n    textno=ER_READ_ONLY_TRANSACTION;\n    break;\n  case HA_ERR_CANNOT_ADD_FOREIGN:\n    textno=ER_CANNOT_ADD_FOREIGN;\n    break;\n  case HA_ERR_ROW_IS_REFERENCED:\n  {\n    String str;\n    get_error_message(error, &str);\n    my_printf_error(ER_ROW_IS_REFERENCED_2,\n                    ER(str.length() ? ER_ROW_IS_REFERENCED_2 : ER_ROW_IS_REFERENCED),\n                    errflag, str.c_ptr_safe());\n    DBUG_VOID_RETURN;\n  }\n  case HA_ERR_NO_REFERENCED_ROW:\n  {\n    String str;\n    get_error_message(error, &str);\n    my_printf_error(ER_NO_REFERENCED_ROW_2,\n                    ER(str.length() ? ER_NO_REFERENCED_ROW_2 : ER_NO_REFERENCED_ROW),\n                    errflag, str.c_ptr_safe());\n    DBUG_VOID_RETURN;\n  }\n  case HA_ERR_TABLE_DEF_CHANGED:\n    textno=ER_TABLE_DEF_CHANGED;\n    break;\n  case HA_ERR_NO_SUCH_TABLE:\n    my_error(ER_NO_SUCH_TABLE_IN_ENGINE, errflag, table_share->db.str,\n             table_share->table_name.str);\n    DBUG_VOID_RETURN;\n  case HA_ERR_RBR_LOGGING_FAILED:\n    textno= ER_BINLOG_ROW_LOGGING_FAILED;\n    break;\n  case HA_ERR_DROP_INDEX_FK:\n  {\n    const char *ptr= \"???\";\n    uint key_nr= get_dup_key(error);\n    if ((int) key_nr >= 0)\n      ptr= table->key_info[key_nr].name.str;\n    my_error(ER_DROP_INDEX_FK, errflag, ptr);\n    DBUG_VOID_RETURN;\n  }\n  case HA_ERR_TABLE_NEEDS_UPGRADE:\n    textno= ER_TABLE_NEEDS_UPGRADE;\n    my_error(ER_TABLE_NEEDS_UPGRADE, errflag,\n             \"TABLE\", table_share->table_name.str);\n    DBUG_VOID_RETURN;\n  case HA_ERR_NO_PARTITION_FOUND:\n    textno=ER_WRONG_PARTITION_NAME;\n    break;\n  case HA_ERR_TABLE_READONLY:\n    textno= ER_OPEN_AS_READONLY;\n    break;\n  case HA_ERR_AUTOINC_READ_FAILED:\n    textno= ER_AUTOINC_READ_FAILED;\n    break;\n  case HA_ERR_AUTOINC_ERANGE:\n    textno= error;\n    my_error(textno, errflag, table->next_number_field->field_name.str,\n             table->in_use->get_stmt_da()->current_row_for_warning());\n    DBUG_VOID_RETURN;\n    break;\n  case HA_ERR_TOO_MANY_CONCURRENT_TRXS:\n    textno= ER_TOO_MANY_CONCURRENT_TRXS;\n    break;\n  case HA_ERR_INDEX_COL_TOO_LONG:\n    textno= ER_INDEX_COLUMN_TOO_LONG;\n    break;\n  case HA_ERR_NOT_IN_LOCK_PARTITIONS:\n    textno=ER_ROW_DOES_NOT_MATCH_GIVEN_PARTITION_SET;\n    break;\n  case HA_ERR_INDEX_CORRUPT:\n    textno= ER_INDEX_CORRUPT;\n    break;\n  case HA_ERR_UNDO_REC_TOO_BIG:\n    textno= ER_UNDO_RECORD_TOO_BIG;\n    break;\n  case HA_ERR_TABLE_IN_FK_CHECK:\n    textno= ER_TABLE_IN_FK_CHECK;\n    break;\n  case HA_ERR_PARTITION_LIST:\n    my_error(ER_VERS_NOT_ALLOWED, errflag, table->s->db.str, table->s->table_name.str);\n    DBUG_VOID_RETURN;\n  default:\n    {\n      /* The error was \"unknown\" to this function.\n\t Ask handler if it has got a message for this error */\n      bool temporary= FALSE;\n      String str;\n      temporary= get_error_message(error, &str);\n      if (!str.is_empty())\n      {\n\tconst char* engine= table_type();\n\tif (temporary)\n\t  my_error(ER_GET_TEMPORARY_ERRMSG, errflag, error, str.c_ptr(),\n                   engine);\n\telse\n        {\n          SET_FATAL_ERROR;\n\t  my_error(ER_GET_ERRMSG, errflag, error, str.c_ptr(), engine);\n        }\n      }\n      else\n        my_error(ER_GET_ERRNO, errflag, error, table_type());\n      DBUG_VOID_RETURN;\n    }\n  }\n  DBUG_ASSERT(textno > 0);\n  if (unlikely(fatal_error))\n  {\n    /* Ensure this becomes a true error */\n    errflag&= ~(ME_WARNING | ME_NOTE);\n    if ((debug_assert_if_crashed_table ||\n                      global_system_variables.log_warnings > 1))\n    {\n      /*\n        Log error to log before we crash or if extended warnings are requested\n      */\n      errflag|= ME_ERROR_LOG;\n    }\n  }\n\n  /* if we got an OS error from a file-based engine, specify a path of error */\n  if (error < HA_ERR_FIRST && bas_ext()[0])\n  {\n    char buff[FN_REFLEN];\n    strxnmov(buff, sizeof(buff),\n             table_share->normalized_path.str, bas_ext()[0], NULL);\n    my_error(textno, errflag, buff, error);\n  }\n  else\n    my_error(textno, errflag, table_share->table_name.str, error);\n  DBUG_VOID_RETURN;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147823,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "void CleanWriters(GF_List *writers)\n{\n\twhile (gf_list_count(writers)) {\n\t\tTrackWriter *writer = (TrackWriter*)gf_list_get(writers, 0);\n\t\tgf_isom_box_del(writer->stco);\n\t\tgf_isom_box_del((GF_Box *)writer->stsc);\n\t\tgf_free(writer);\n\t\tgf_list_rem(writers, 0);\n\t}\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148046,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "void CleanWriters(GF_List *writers)\n{\n\twhile (gf_list_count(writers)) {\n\t\tTrackWriter *writer = (TrackWriter*)gf_list_get(writers, 0);\n\t\t//in case we have an error in the middle of file write, remove our created stco and stsc from sample table\n\t\tgf_list_del_item(writer->stbl->child_boxes, writer->stco);\n\t\tgf_list_del_item(writer->stbl->child_boxes, writer->stsc);\n\t\tgf_isom_box_del(writer->stco);\n\t\tgf_isom_box_del((GF_Box *)writer->stsc);\n\t\tgf_free(writer);\n\t\tgf_list_rem(writers, 0);\n\t}\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148047,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "GF_Err stbl_GetSampleInfos(GF_SampleTableBox *stbl, u32 sampleNumber, u64 *offset, u32 *chunkNumber, u32 *descIndex, GF_StscEntry **out_ent)\n{\n\tGF_Err e;\n\tu32 i, k, offsetInChunk, size, chunk_num;\n\tGF_ChunkOffsetBox *stco;\n\tGF_ChunkLargeOffsetBox *co64;\n\tGF_StscEntry *ent;\n\n\t(*offset) = 0;\n\t(*chunkNumber) = (*descIndex) = 0;\n\tif (out_ent) (*out_ent) = NULL;\n\tif (!stbl || !sampleNumber) return GF_BAD_PARAM;\n\tif (!stbl->ChunkOffset || !stbl->SampleToChunk || !stbl->SampleSize) return GF_ISOM_INVALID_FILE;\n\n\tif (stbl->SampleSize && stbl->SampleToChunk->nb_entries == stbl->SampleSize->sampleCount) {\n\t\tent = &stbl->SampleToChunk->entries[sampleNumber-1];\n\t\tif (!ent) return GF_BAD_PARAM;\n\t\t(*descIndex) = ent->sampleDescriptionIndex;\n\t\t(*chunkNumber) = sampleNumber;\n\t\tif (out_ent) *out_ent = ent;\n\t\tif ( stbl->ChunkOffset->type == GF_ISOM_BOX_TYPE_STCO) {\n\t\t\tstco = (GF_ChunkOffsetBox *)stbl->ChunkOffset;\n\t\t\tif (!stco->offsets) return GF_ISOM_INVALID_FILE;\n\n\t\t\t(*offset) = (u64) stco->offsets[sampleNumber - 1];\n\t\t} else {\n\t\t\tco64 = (GF_ChunkLargeOffsetBox *)stbl->ChunkOffset;\n\t\t\tif (!co64->offsets) return GF_ISOM_INVALID_FILE;\n\n\t\t\t(*offset) = co64->offsets[sampleNumber - 1];\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\t//check our cache: if desired sample is at or above current cache entry, start from here\n\tif (stbl->SampleToChunk->firstSampleInCurrentChunk &&\n\t        (stbl->SampleToChunk->firstSampleInCurrentChunk <= sampleNumber)) {\n\n\t\ti = stbl->SampleToChunk->currentIndex;\n\t\tent = &stbl->SampleToChunk->entries[stbl->SampleToChunk->currentIndex];\n\t\tGetGhostNum(ent, i, stbl->SampleToChunk->nb_entries, stbl);\n\t\tk = stbl->SampleToChunk->currentChunk;\n\t}\n\t//otherwise start from first entry\n\telse {\n\t\ti = 0;\n\t\tstbl->SampleToChunk->currentIndex = 0;\n\t\tstbl->SampleToChunk->currentChunk = 1;\n\t\tstbl->SampleToChunk->ghostNumber = 1;\n\t\tstbl->SampleToChunk->firstSampleInCurrentChunk = 1;\n\t\tent = &stbl->SampleToChunk->entries[0];\n\t\tGetGhostNum(ent, 0, stbl->SampleToChunk->nb_entries, stbl);\n\t\tk = stbl->SampleToChunk->currentChunk;\n\t}\n\n\t//first get the chunk\n\tfor (; i < stbl->SampleToChunk->nb_entries; i++) {\n\t\tassert(stbl->SampleToChunk->firstSampleInCurrentChunk <= sampleNumber);\n\t\t//corrupted file (less sample2chunk info than sample count\n\t\tif (k > stbl->SampleToChunk->ghostNumber) {\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\n\n\t\t//check if sample is in current chunk\n\t\tu32 max_chunks_in_entry = stbl->SampleToChunk->ghostNumber - k;\n\t\tu32 nb_chunks_for_sample = sampleNumber - stbl->SampleToChunk->firstSampleInCurrentChunk;\n\t\tif (ent->samplesPerChunk) \n\t\t\tnb_chunks_for_sample /= ent->samplesPerChunk;\n\n\t\tif (\n\t\t\t(nb_chunks_for_sample <= max_chunks_in_entry)\n\t\t\t&& (stbl->SampleToChunk->firstSampleInCurrentChunk + (nb_chunks_for_sample+1) * ent->samplesPerChunk > sampleNumber)\n\t\t) {\n\n\t\t\tstbl->SampleToChunk->firstSampleInCurrentChunk += nb_chunks_for_sample * ent->samplesPerChunk;\n\t\t\tstbl->SampleToChunk->currentChunk += nb_chunks_for_sample;\n\t\t\tgoto sample_found;\n\t\t}\n\t\tmax_chunks_in_entry += 1;\n\t\tstbl->SampleToChunk->firstSampleInCurrentChunk += max_chunks_in_entry * ent->samplesPerChunk;\n\t\tstbl->SampleToChunk->currentChunk += max_chunks_in_entry;\n\n\t\t//not in this entry, get the next entry if not the last one\n\t\tif (i+1 != stbl->SampleToChunk->nb_entries) {\n\t\t\tent = &stbl->SampleToChunk->entries[i+1];\n\t\t\t//update the GhostNumber\n\t\t\tGetGhostNum(ent, i+1, stbl->SampleToChunk->nb_entries, stbl);\n\t\t\t//update the entry in our cache\n\t\t\tstbl->SampleToChunk->currentIndex = i+1;\n\t\t\tstbl->SampleToChunk->currentChunk = 1;\n\t\t\tk = 1;\n\t\t}\n\t}\n\t//if we get here, gasp, the sample was not found\n\treturn GF_ISOM_INVALID_FILE;\n\nsample_found:\n\n\t(*descIndex) = ent->sampleDescriptionIndex;\n\t(*chunkNumber) = chunk_num = ent->firstChunk + stbl->SampleToChunk->currentChunk - 1;\n\tif (out_ent) *out_ent = ent;\n\tif (! *chunkNumber)\n\t\treturn GF_ISOM_INVALID_FILE;\n\t\n\t//ok, get the size of all the previous samples in the chunk\n\toffsetInChunk = 0;\n\t//constant size\n\tif (stbl->SampleSize && stbl->SampleSize->sampleSize) {\n\t\tu32 diff = sampleNumber - stbl->SampleToChunk->firstSampleInCurrentChunk;\n\t\toffsetInChunk += diff * stbl->SampleSize->sampleSize;\n\t} else if ((stbl->r_last_chunk_num == chunk_num) && (stbl->r_last_sample_num == sampleNumber)) {\n\t\toffsetInChunk = stbl->r_last_offset_in_chunk;\n\t} else if ((stbl->r_last_chunk_num == chunk_num) && (stbl->r_last_sample_num + 1 == sampleNumber)) {\n\t\te = stbl_GetSampleSize(stbl->SampleSize, stbl->r_last_sample_num, &size);\n\t\tif (e) return e;\n\t\tstbl->r_last_offset_in_chunk += size;\n\t\tstbl->r_last_sample_num = sampleNumber;\n\t\toffsetInChunk = stbl->r_last_offset_in_chunk;\n\t} else {\n\t\t//warning, firstSampleInChunk is at least 1 - not 0\n\t\tfor (i = stbl->SampleToChunk->firstSampleInCurrentChunk; i < sampleNumber; i++) {\n\t\t\te = stbl_GetSampleSize(stbl->SampleSize, i, &size);\n\t\t\tif (e) return e;\n\t\t\toffsetInChunk += size;\n\t\t}\n\t\tstbl->r_last_chunk_num = chunk_num;\n\t\tstbl->r_last_sample_num = sampleNumber;\n\t\tstbl->r_last_offset_in_chunk = offsetInChunk;\n\t}\n\t//OK, that's the size of our offset in the chunk\n\t//now get the chunk\n\tif ( stbl->ChunkOffset->type == GF_ISOM_BOX_TYPE_STCO) {\n\t\tstco = (GF_ChunkOffsetBox *)stbl->ChunkOffset;\n\t\tif (stco->nb_entries < (*chunkNumber) ) return GF_ISOM_INVALID_FILE;\n\t\t(*offset) = (u64) stco->offsets[(*chunkNumber) - 1] + (u64) offsetInChunk;\n\t} else {\n\t\tco64 = (GF_ChunkLargeOffsetBox *)stbl->ChunkOffset;\n\t\tif (co64->nb_entries < (*chunkNumber) ) return GF_ISOM_INVALID_FILE;\n\t\t(*offset) = co64->offsets[(*chunkNumber) - 1] + (u64) offsetInChunk;\n\t}\n\treturn GF_OK;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148048,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "GF_Err stbl_GetSampleInfos(GF_SampleTableBox *stbl, u32 sampleNumber, u64 *offset, u32 *chunkNumber, u32 *descIndex, GF_StscEntry **out_ent)\n{\n\tGF_Err e;\n\tu32 i, k, offsetInChunk, size, chunk_num;\n\tGF_ChunkOffsetBox *stco;\n\tGF_ChunkLargeOffsetBox *co64;\n\tGF_StscEntry *ent;\n\n\t(*offset) = 0;\n\t(*chunkNumber) = (*descIndex) = 0;\n\tif (out_ent) (*out_ent) = NULL;\n\tif (!stbl || !sampleNumber) return GF_BAD_PARAM;\n\tif (!stbl->ChunkOffset || !stbl->SampleToChunk || !stbl->SampleSize) return GF_ISOM_INVALID_FILE;\n\n\tif (stbl->SampleSize && stbl->SampleToChunk->nb_entries == stbl->SampleSize->sampleCount) {\n\t\tent = &stbl->SampleToChunk->entries[sampleNumber-1];\n\t\tif (!ent) return GF_BAD_PARAM;\n\t\t(*descIndex) = ent->sampleDescriptionIndex;\n\t\t(*chunkNumber) = sampleNumber;\n\t\tif (out_ent) *out_ent = ent;\n\t\tif ( stbl->ChunkOffset->type == GF_ISOM_BOX_TYPE_STCO) {\n\t\t\tstco = (GF_ChunkOffsetBox *)stbl->ChunkOffset;\n\t\t\tif (!stco->offsets) return GF_ISOM_INVALID_FILE;\n\t\t\tif (stco->nb_entries < sampleNumber) return GF_ISOM_INVALID_FILE;\n\n\t\t\t(*offset) = (u64) stco->offsets[sampleNumber - 1];\n\t\t} else {\n\t\t\tco64 = (GF_ChunkLargeOffsetBox *)stbl->ChunkOffset;\n\t\t\tif (!co64->offsets) return GF_ISOM_INVALID_FILE;\n\t\t\tif (co64->nb_entries < sampleNumber) return GF_ISOM_INVALID_FILE;\n\n\t\t\t(*offset) = co64->offsets[sampleNumber - 1];\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\t//check our cache: if desired sample is at or above current cache entry, start from here\n\tif (stbl->SampleToChunk->firstSampleInCurrentChunk &&\n\t        (stbl->SampleToChunk->firstSampleInCurrentChunk <= sampleNumber)) {\n\n\t\ti = stbl->SampleToChunk->currentIndex;\n\t\tent = &stbl->SampleToChunk->entries[stbl->SampleToChunk->currentIndex];\n\t\tGetGhostNum(ent, i, stbl->SampleToChunk->nb_entries, stbl);\n\t\tk = stbl->SampleToChunk->currentChunk;\n\t}\n\t//otherwise start from first entry\n\telse {\n\t\ti = 0;\n\t\tstbl->SampleToChunk->currentIndex = 0;\n\t\tstbl->SampleToChunk->currentChunk = 1;\n\t\tstbl->SampleToChunk->ghostNumber = 1;\n\t\tstbl->SampleToChunk->firstSampleInCurrentChunk = 1;\n\t\tent = &stbl->SampleToChunk->entries[0];\n\t\tGetGhostNum(ent, 0, stbl->SampleToChunk->nb_entries, stbl);\n\t\tk = stbl->SampleToChunk->currentChunk;\n\t}\n\n\t//first get the chunk\n\tfor (; i < stbl->SampleToChunk->nb_entries; i++) {\n\t\tassert(stbl->SampleToChunk->firstSampleInCurrentChunk <= sampleNumber);\n\t\t//corrupted file (less sample2chunk info than sample count\n\t\tif (k > stbl->SampleToChunk->ghostNumber) {\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\n\n\t\t//check if sample is in current chunk\n\t\tu32 max_chunks_in_entry = stbl->SampleToChunk->ghostNumber - k;\n\t\tu32 nb_chunks_for_sample = sampleNumber - stbl->SampleToChunk->firstSampleInCurrentChunk;\n\t\tif (ent->samplesPerChunk) \n\t\t\tnb_chunks_for_sample /= ent->samplesPerChunk;\n\n\t\tif (\n\t\t\t(nb_chunks_for_sample <= max_chunks_in_entry)\n\t\t\t&& (stbl->SampleToChunk->firstSampleInCurrentChunk + (nb_chunks_for_sample+1) * ent->samplesPerChunk > sampleNumber)\n\t\t) {\n\n\t\t\tstbl->SampleToChunk->firstSampleInCurrentChunk += nb_chunks_for_sample * ent->samplesPerChunk;\n\t\t\tstbl->SampleToChunk->currentChunk += nb_chunks_for_sample;\n\t\t\tgoto sample_found;\n\t\t}\n\t\tmax_chunks_in_entry += 1;\n\t\tstbl->SampleToChunk->firstSampleInCurrentChunk += max_chunks_in_entry * ent->samplesPerChunk;\n\t\tstbl->SampleToChunk->currentChunk += max_chunks_in_entry;\n\n\t\t//not in this entry, get the next entry if not the last one\n\t\tif (i+1 != stbl->SampleToChunk->nb_entries) {\n\t\t\tent = &stbl->SampleToChunk->entries[i+1];\n\t\t\t//update the GhostNumber\n\t\t\tGetGhostNum(ent, i+1, stbl->SampleToChunk->nb_entries, stbl);\n\t\t\t//update the entry in our cache\n\t\t\tstbl->SampleToChunk->currentIndex = i+1;\n\t\t\tstbl->SampleToChunk->currentChunk = 1;\n\t\t\tk = 1;\n\t\t}\n\t}\n\t//if we get here, gasp, the sample was not found\n\treturn GF_ISOM_INVALID_FILE;\n\nsample_found:\n\n\t(*descIndex) = ent->sampleDescriptionIndex;\n\t(*chunkNumber) = chunk_num = ent->firstChunk + stbl->SampleToChunk->currentChunk - 1;\n\tif (out_ent) *out_ent = ent;\n\tif (! *chunkNumber)\n\t\treturn GF_ISOM_INVALID_FILE;\n\t\n\t//ok, get the size of all the previous samples in the chunk\n\toffsetInChunk = 0;\n\t//constant size\n\tif (stbl->SampleSize && stbl->SampleSize->sampleSize) {\n\t\tu32 diff = sampleNumber - stbl->SampleToChunk->firstSampleInCurrentChunk;\n\t\toffsetInChunk += diff * stbl->SampleSize->sampleSize;\n\t} else if ((stbl->r_last_chunk_num == chunk_num) && (stbl->r_last_sample_num == sampleNumber)) {\n\t\toffsetInChunk = stbl->r_last_offset_in_chunk;\n\t} else if ((stbl->r_last_chunk_num == chunk_num) && (stbl->r_last_sample_num + 1 == sampleNumber)) {\n\t\te = stbl_GetSampleSize(stbl->SampleSize, stbl->r_last_sample_num, &size);\n\t\tif (e) return e;\n\t\tstbl->r_last_offset_in_chunk += size;\n\t\tstbl->r_last_sample_num = sampleNumber;\n\t\toffsetInChunk = stbl->r_last_offset_in_chunk;\n\t} else {\n\t\t//warning, firstSampleInChunk is at least 1 - not 0\n\t\tfor (i = stbl->SampleToChunk->firstSampleInCurrentChunk; i < sampleNumber; i++) {\n\t\t\te = stbl_GetSampleSize(stbl->SampleSize, i, &size);\n\t\t\tif (e) return e;\n\t\t\toffsetInChunk += size;\n\t\t}\n\t\tstbl->r_last_chunk_num = chunk_num;\n\t\tstbl->r_last_sample_num = sampleNumber;\n\t\tstbl->r_last_offset_in_chunk = offsetInChunk;\n\t}\n\t//OK, that's the size of our offset in the chunk\n\t//now get the chunk\n\tif ( stbl->ChunkOffset->type == GF_ISOM_BOX_TYPE_STCO) {\n\t\tstco = (GF_ChunkOffsetBox *)stbl->ChunkOffset;\n\t\tif (stco->nb_entries < (*chunkNumber) ) return GF_ISOM_INVALID_FILE;\n\t\t(*offset) = (u64) stco->offsets[(*chunkNumber) - 1] + (u64) offsetInChunk;\n\t} else {\n\t\tco64 = (GF_ChunkLargeOffsetBox *)stbl->ChunkOffset;\n\t\tif (co64->nb_entries < (*chunkNumber) ) return GF_ISOM_INVALID_FILE;\n\t\t(*offset) = co64->offsets[(*chunkNumber) - 1] + (u64) offsetInChunk;\n\t}\n\treturn GF_OK;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148049,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int parse_playlist(HLSContext *c, const char *url,\n                          struct playlist *pls, AVIOContext *in)\n{\n    int ret = 0, is_segment = 0, is_variant = 0;\n    int64_t duration = 0;\n    enum KeyType key_type = KEY_NONE;\n    uint8_t iv[16] = \"\";\n    int has_iv = 0;\n    char key[MAX_URL_SIZE] = \"\";\n    char line[MAX_URL_SIZE];\n    const char *ptr;\n    int close_in = 0;\n    int64_t seg_offset = 0;\n    int64_t seg_size = -1;\n    uint8_t *new_url = NULL;\n    struct variant_info variant_info;\n    char tmp_str[MAX_URL_SIZE];\n    struct segment *cur_init_section = NULL;\n\n    if (!in) {\n#if 1\n        AVDictionary *opts = NULL;\n        close_in = 1;\n        /* Some HLS servers don't like being sent the range header */\n        av_dict_set(&opts, \"seekable\", \"0\", 0);\n\n        // broker prior HTTP options that should be consistent across requests\n        av_dict_set(&opts, \"user-agent\", c->user_agent, 0);\n        av_dict_set(&opts, \"cookies\", c->cookies, 0);\n        av_dict_set(&opts, \"headers\", c->headers, 0);\n\n        ret = avio_open2(&in, url, AVIO_FLAG_READ,\n                         c->interrupt_callback, &opts);\n        av_dict_free(&opts);\n        if (ret < 0)\n            return ret;\n#else\n        ret = open_in(c, &in, url);\n        if (ret < 0)\n            return ret;\n        close_in = 1;\n#endif\n    }\n\n    if (av_opt_get(in, \"location\", AV_OPT_SEARCH_CHILDREN, &new_url) >= 0)\n        url = new_url;\n\n    read_chomp_line(in, line, sizeof(line));\n    if (strcmp(line, \"#EXTM3U\")) {\n        ret = AVERROR_INVALIDDATA;\n        goto fail;\n    }\n\n    if (pls) {\n        free_segment_list(pls);\n        pls->finished = 0;\n        pls->type = PLS_TYPE_UNSPECIFIED;\n    }\n    while (!avio_feof(in)) {\n        read_chomp_line(in, line, sizeof(line));\n        if (av_strstart(line, \"#EXT-X-STREAM-INF:\", &ptr)) {\n            is_variant = 1;\n            memset(&variant_info, 0, sizeof(variant_info));\n            ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_variant_args,\n                               &variant_info);\n        } else if (av_strstart(line, \"#EXT-X-KEY:\", &ptr)) {\n            struct key_info info = {{0}};\n            ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_key_args,\n                               &info);\n            key_type = KEY_NONE;\n            has_iv = 0;\n            if (!strcmp(info.method, \"AES-128\"))\n                key_type = KEY_AES_128;\n            if (!strcmp(info.method, \"SAMPLE-AES\"))\n                key_type = KEY_SAMPLE_AES;\n            if (!strncmp(info.iv, \"0x\", 2) || !strncmp(info.iv, \"0X\", 2)) {\n                ff_hex_to_data(iv, info.iv + 2);\n                has_iv = 1;\n            }\n            av_strlcpy(key, info.uri, sizeof(key));\n        } else if (av_strstart(line, \"#EXT-X-MEDIA:\", &ptr)) {\n            struct rendition_info info = {{0}};\n            ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_rendition_args,\n                               &info);\n            new_rendition(c, &info, url);\n        } else if (av_strstart(line, \"#EXT-X-TARGETDURATION:\", &ptr)) {\n            ret = ensure_playlist(c, &pls, url);\n            if (ret < 0)\n                goto fail;\n            pls->target_duration = atoi(ptr) * AV_TIME_BASE;\n        } else if (av_strstart(line, \"#EXT-X-MEDIA-SEQUENCE:\", &ptr)) {\n            ret = ensure_playlist(c, &pls, url);\n            if (ret < 0)\n                goto fail;\n            pls->start_seq_no = atoi(ptr);\n        } else if (av_strstart(line, \"#EXT-X-PLAYLIST-TYPE:\", &ptr)) {\n            ret = ensure_playlist(c, &pls, url);\n            if (ret < 0)\n                goto fail;\n            if (!strcmp(ptr, \"EVENT\"))\n                pls->type = PLS_TYPE_EVENT;\n            else if (!strcmp(ptr, \"VOD\"))\n                pls->type = PLS_TYPE_VOD;\n        } else if (av_strstart(line, \"#EXT-X-MAP:\", &ptr)) {\n            struct init_section_info info = {{0}};\n            ret = ensure_playlist(c, &pls, url);\n            if (ret < 0)\n                goto fail;\n            ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_init_section_args,\n                               &info);\n            cur_init_section = new_init_section(pls, &info, url);\n        } else if (av_strstart(line, \"#EXT-X-ENDLIST\", &ptr)) {\n            if (pls)\n                pls->finished = 1;\n        } else if (av_strstart(line, \"#EXTINF:\", &ptr)) {\n            is_segment = 1;\n            duration   = atof(ptr) * AV_TIME_BASE;\n        } else if (av_strstart(line, \"#EXT-X-BYTERANGE:\", &ptr)) {\n            seg_size = atoi(ptr);\n            ptr = strchr(ptr, '@');\n            if (ptr)\n                seg_offset = atoi(ptr+1);\n        } else if (av_strstart(line, \"#\", NULL)) {\n            continue;\n        } else if (line[0]) {\n            if (is_variant) {\n                if (!new_variant(c, &variant_info, line, url)) {\n                    ret = AVERROR(ENOMEM);\n                    goto fail;\n                }\n                is_variant = 0;\n            }\n            if (is_segment) {\n                struct segment *seg;\n                if (!pls) {\n                    if (!new_variant(c, 0, url, NULL)) {\n                        ret = AVERROR(ENOMEM);\n                        goto fail;\n                    }\n                    pls = c->playlists[c->n_playlists - 1];\n                }\n                seg = av_malloc(sizeof(struct segment));\n                if (!seg) {\n                    ret = AVERROR(ENOMEM);\n                    goto fail;\n                }\n                seg->duration = duration;\n                seg->key_type = key_type;\n                if (has_iv) {\n                    memcpy(seg->iv, iv, sizeof(iv));\n                } else {\n                    int seq = pls->start_seq_no + pls->n_segments;\n                    memset(seg->iv, 0, sizeof(seg->iv));\n                    AV_WB32(seg->iv + 12, seq);\n                }\n\n                if (key_type != KEY_NONE) {\n                    ff_make_absolute_url(tmp_str, sizeof(tmp_str), url, key);\n                    seg->key = av_strdup(tmp_str);\n                    if (!seg->key) {\n                        av_free(seg);\n                        ret = AVERROR(ENOMEM);\n                        goto fail;\n                    }\n                } else {\n                    seg->key = NULL;\n                }\n\n                ff_make_absolute_url(tmp_str, sizeof(tmp_str), url, line);\n                seg->url = av_strdup(tmp_str);\n                if (!seg->url) {\n                    av_free(seg->key);\n                    av_free(seg);\n                    ret = AVERROR(ENOMEM);\n                    goto fail;\n                }\n\n                dynarray_add(&pls->segments, &pls->n_segments, seg);\n                is_segment = 0;\n\n                seg->size = seg_size;\n                if (seg_size >= 0) {\n                    seg->url_offset = seg_offset;\n                    seg_offset += seg_size;\n                    seg_size = -1;\n                } else {\n                    seg->url_offset = 0;\n                    seg_offset = 0;\n                }\n\n                seg->init_section = cur_init_section;\n            }\n        }\n    }\n    if (pls)\n        pls->last_load_time = av_gettime_relative();\n\nfail:\n    av_free(new_url);\n    if (close_in)\n        avio_close(in);\n    return ret;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148128,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int parse_playlist(HLSContext *c, const char *url,\n                          struct playlist *pls, AVIOContext *in)\n{\n    int ret = 0, is_segment = 0, is_variant = 0;\n    int64_t duration = 0;\n    enum KeyType key_type = KEY_NONE;\n    uint8_t iv[16] = \"\";\n    int has_iv = 0;\n    char key[MAX_URL_SIZE] = \"\";\n    char line[MAX_URL_SIZE];\n    const char *ptr;\n    int close_in = 0;\n    int64_t seg_offset = 0;\n    int64_t seg_size = -1;\n    uint8_t *new_url = NULL;\n    struct variant_info variant_info;\n    char tmp_str[MAX_URL_SIZE];\n    struct segment *cur_init_section = NULL;\n\n    if (!in) {\n#if 1\n        AVDictionary *opts = NULL;\n        close_in = 1;\n        /* Some HLS servers don't like being sent the range header */\n        av_dict_set(&opts, \"seekable\", \"0\", 0);\n\n        // broker prior HTTP options that should be consistent across requests\n        av_dict_set(&opts, \"user-agent\", c->user_agent, 0);\n        av_dict_set(&opts, \"cookies\", c->cookies, 0);\n        av_dict_set(&opts, \"headers\", c->headers, 0);\n\n        ret = avio_open2(&in, url, AVIO_FLAG_READ,\n                         c->interrupt_callback, &opts);\n        av_dict_free(&opts);\n        if (ret < 0)\n            return ret;\n#else\n        ret = open_in(c, &in, url);\n        if (ret < 0)\n            return ret;\n        close_in = 1;\n#endif\n    }\n\n    if (av_opt_get(in, \"location\", AV_OPT_SEARCH_CHILDREN, &new_url) >= 0)\n        url = new_url;\n\n    read_chomp_line(in, line, sizeof(line));\n    if (strcmp(line, \"#EXTM3U\")) {\n        ret = AVERROR_INVALIDDATA;\n        goto fail;\n    }\n\n    if (pls) {\n        free_segment_list(pls);\n        pls->finished = 0;\n        pls->type = PLS_TYPE_UNSPECIFIED;\n    }\n    while (!avio_feof(in)) {\n        read_chomp_line(in, line, sizeof(line));\n        if (av_strstart(line, \"#EXT-X-STREAM-INF:\", &ptr)) {\n            is_variant = 1;\n            memset(&variant_info, 0, sizeof(variant_info));\n            ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_variant_args,\n                               &variant_info);\n        } else if (av_strstart(line, \"#EXT-X-KEY:\", &ptr)) {\n            struct key_info info = {{0}};\n            ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_key_args,\n                               &info);\n            key_type = KEY_NONE;\n            has_iv = 0;\n            if (!strcmp(info.method, \"AES-128\"))\n                key_type = KEY_AES_128;\n            if (!strcmp(info.method, \"SAMPLE-AES\"))\n                key_type = KEY_SAMPLE_AES;\n            if (!strncmp(info.iv, \"0x\", 2) || !strncmp(info.iv, \"0X\", 2)) {\n                ff_hex_to_data(iv, info.iv + 2);\n                has_iv = 1;\n            }\n            av_strlcpy(key, info.uri, sizeof(key));\n        } else if (av_strstart(line, \"#EXT-X-MEDIA:\", &ptr)) {\n            struct rendition_info info = {{0}};\n            ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_rendition_args,\n                               &info);\n            new_rendition(c, &info, url);\n        } else if (av_strstart(line, \"#EXT-X-TARGETDURATION:\", &ptr)) {\n            ret = ensure_playlist(c, &pls, url);\n            if (ret < 0)\n                goto fail;\n            pls->target_duration = atoi(ptr) * AV_TIME_BASE;\n        } else if (av_strstart(line, \"#EXT-X-MEDIA-SEQUENCE:\", &ptr)) {\n            ret = ensure_playlist(c, &pls, url);\n            if (ret < 0)\n                goto fail;\n            pls->start_seq_no = atoi(ptr);\n        } else if (av_strstart(line, \"#EXT-X-PLAYLIST-TYPE:\", &ptr)) {\n            ret = ensure_playlist(c, &pls, url);\n            if (ret < 0)\n                goto fail;\n            if (!strcmp(ptr, \"EVENT\"))\n                pls->type = PLS_TYPE_EVENT;\n            else if (!strcmp(ptr, \"VOD\"))\n                pls->type = PLS_TYPE_VOD;\n        } else if (av_strstart(line, \"#EXT-X-MAP:\", &ptr)) {\n            struct init_section_info info = {{0}};\n            ret = ensure_playlist(c, &pls, url);\n            if (ret < 0)\n                goto fail;\n            ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_init_section_args,\n                               &info);\n            cur_init_section = new_init_section(pls, &info, url);\n        } else if (av_strstart(line, \"#EXT-X-ENDLIST\", &ptr)) {\n            if (pls)\n                pls->finished = 1;\n        } else if (av_strstart(line, \"#EXTINF:\", &ptr)) {\n            is_segment = 1;\n            duration   = atof(ptr) * AV_TIME_BASE;\n        } else if (av_strstart(line, \"#EXT-X-BYTERANGE:\", &ptr)) {\n            seg_size = atoi(ptr);\n            ptr = strchr(ptr, '@');\n            if (ptr)\n                seg_offset = atoi(ptr+1);\n        } else if (av_strstart(line, \"#\", NULL)) {\n            continue;\n        } else if (line[0]) {\n            if (is_variant) {\n                if (!new_variant(c, &variant_info, line, url)) {\n                    ret = AVERROR(ENOMEM);\n                    goto fail;\n                }\n                is_variant = 0;\n            }\n            if (is_segment) {\n                struct segment *seg;\n                if (!pls) {\n                    if (!new_variant(c, 0, url, NULL)) {\n                        ret = AVERROR(ENOMEM);\n                        goto fail;\n                    }\n                    pls = c->playlists[c->n_playlists - 1];\n                }\n                seg = av_malloc(sizeof(struct segment));\n                if (!seg) {\n                    ret = AVERROR(ENOMEM);\n                    goto fail;\n                }\n                if (has_iv) {\n                    memcpy(seg->iv, iv, sizeof(iv));\n                } else {\n                    int seq = pls->start_seq_no + pls->n_segments;\n                    memset(seg->iv, 0, sizeof(seg->iv));\n                    AV_WB32(seg->iv + 12, seq);\n                }\n\n                if (key_type != KEY_NONE) {\n                    ff_make_absolute_url(tmp_str, sizeof(tmp_str), url, key);\n                    seg->key = av_strdup(tmp_str);\n                    if (!seg->key) {\n                        av_free(seg);\n                        ret = AVERROR(ENOMEM);\n                        goto fail;\n                    }\n                } else {\n                    seg->key = NULL;\n                }\n\n                ff_make_absolute_url(tmp_str, sizeof(tmp_str), url, line);\n                seg->url = av_strdup(tmp_str);\n                if (!seg->url) {\n                    av_free(seg->key);\n                    av_free(seg);\n                    ret = AVERROR(ENOMEM);\n                    goto fail;\n                }\n\n                if (duration < 0.001 * AV_TIME_BASE) {\n                    duration = 0.001 * AV_TIME_BASE;\n                }\n                seg->duration = duration;\n                seg->key_type = key_type;\n                dynarray_add(&pls->segments, &pls->n_segments, seg);\n                is_segment = 0;\n\n                seg->size = seg_size;\n                if (seg_size >= 0) {\n                    seg->url_offset = seg_offset;\n                    seg_offset += seg_size;\n                    seg_size = -1;\n                } else {\n                    seg->url_offset = 0;\n                    seg_offset = 0;\n                }\n\n                seg->init_section = cur_init_section;\n            }\n        }\n    }\n    if (pls)\n        pls->last_load_time = av_gettime_relative();\n\nfail:\n    av_free(new_url);\n    if (close_in)\n        avio_close(in);\n    return ret;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148129,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "nosy_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct client *client = file->private_data;\n\tspinlock_t *client_list_lock = &client->lynx->client_list_lock;\n\tstruct nosy_stats stats;\n\n\tswitch (cmd) {\n\tcase NOSY_IOC_GET_STATS:\n\t\tspin_lock_irq(client_list_lock);\n\t\tstats.total_packet_count = client->buffer.total_packet_count;\n\t\tstats.lost_packet_count  = client->buffer.lost_packet_count;\n\t\tspin_unlock_irq(client_list_lock);\n\n\t\tif (copy_to_user((void __user *) arg, &stats, sizeof stats))\n\t\t\treturn -EFAULT;\n\t\telse\n\t\t\treturn 0;\n\n\tcase NOSY_IOC_START:\n\t\tspin_lock_irq(client_list_lock);\n\t\tlist_add_tail(&client->link, &client->lynx->client_list);\n\t\tspin_unlock_irq(client_list_lock);\n\n\t\treturn 0;\n\n\tcase NOSY_IOC_STOP:\n\t\tspin_lock_irq(client_list_lock);\n\t\tlist_del_init(&client->link);\n\t\tspin_unlock_irq(client_list_lock);\n\n\t\treturn 0;\n\n\tcase NOSY_IOC_FILTER:\n\t\tspin_lock_irq(client_list_lock);\n\t\tclient->tcode_mask = arg;\n\t\tspin_unlock_irq(client_list_lock);\n\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t\t/* Flush buffer, configure filter. */\n\t}\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148168,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "nosy_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct client *client = file->private_data;\n\tspinlock_t *client_list_lock = &client->lynx->client_list_lock;\n\tstruct nosy_stats stats;\n\tint ret;\n\n\tswitch (cmd) {\n\tcase NOSY_IOC_GET_STATS:\n\t\tspin_lock_irq(client_list_lock);\n\t\tstats.total_packet_count = client->buffer.total_packet_count;\n\t\tstats.lost_packet_count  = client->buffer.lost_packet_count;\n\t\tspin_unlock_irq(client_list_lock);\n\n\t\tif (copy_to_user((void __user *) arg, &stats, sizeof stats))\n\t\t\treturn -EFAULT;\n\t\telse\n\t\t\treturn 0;\n\n\tcase NOSY_IOC_START:\n\t\tret = -EBUSY;\n\t\tspin_lock_irq(client_list_lock);\n\t\tif (list_empty(&client->link)) {\n\t\t\tlist_add_tail(&client->link, &client->lynx->client_list);\n\t\t\tret = 0;\n\t\t}\n\t\tspin_unlock_irq(client_list_lock);\n\n\t\treturn ret;\n\n\tcase NOSY_IOC_STOP:\n\t\tspin_lock_irq(client_list_lock);\n\t\tlist_del_init(&client->link);\n\t\tspin_unlock_irq(client_list_lock);\n\n\t\treturn 0;\n\n\tcase NOSY_IOC_FILTER:\n\t\tspin_lock_irq(client_list_lock);\n\t\tclient->tcode_mask = arg;\n\t\tspin_unlock_irq(client_list_lock);\n\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t\t/* Flush buffer, configure filter. */\n\t}\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148169,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "void *_zend_shared_memdup(void *source, size_t size, zend_bool free_source TSRMLS_DC)\n{\n\tvoid **old_p, *retval;\n\n\tif (zend_hash_index_find(&xlat_table, (ulong)source, (void **)&old_p) == SUCCESS) {\n\t\t/* we already duplicated this pointer */\n\t\treturn *old_p;\n\t}\n\tretval = ZCG(mem);;\n\tZCG(mem) = (void*)(((char*)ZCG(mem)) + ZEND_ALIGNED_SIZE(size));\n\tmemcpy(retval, source, size);\n\tif (free_source) {\n\t\tinterned_efree((char*)source);\n\t}\n\tzend_shared_alloc_register_xlat_entry(source, retval);\n\treturn retval;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148206,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "void *_zend_shared_memdup(void *source, size_t size, zend_bool free_source TSRMLS_DC)\n{\n\tvoid **old_p, *retval;\n\n\tif (zend_hash_index_find(&xlat_table, (ulong)source, (void **)&old_p) == SUCCESS) {\n\t\t/* we already duplicated this pointer */\n\t\treturn *old_p;\n\t}\n\tretval = ZCG(mem);;\n\tZCG(mem) = (void*)(((char*)ZCG(mem)) + ZEND_ALIGNED_SIZE(size));\n\tmemcpy(retval, source, size);\n\tzend_shared_alloc_register_xlat_entry(source, retval);\n\tif (free_source) {\n\t\tinterned_efree((char*)source);\n\t}\n\treturn retval;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148207,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "void __do_SAK(struct tty_struct *tty)\n{\n#ifdef TTY_SOFT_SAK\n\ttty_hangup(tty);\n#else\n\tstruct task_struct *g, *p;\n\tstruct pid *session;\n\tint\t\ti;\n\n\tif (!tty)\n\t\treturn;\n\tsession = tty->session;\n\n\ttty_ldisc_flush(tty);\n\n\ttty_driver_flush_buffer(tty);\n\n\tread_lock(&tasklist_lock);\n\t/* Kill the entire session */\n\tdo_each_pid_task(session, PIDTYPE_SID, p) {\n\t\ttty_notice(tty, \"SAK: killed process %d (%s): by session\\n\",\n\t\t\t   task_pid_nr(p), p->comm);\n\t\tgroup_send_sig_info(SIGKILL, SEND_SIG_PRIV, p, PIDTYPE_SID);\n\t} while_each_pid_task(session, PIDTYPE_SID, p);\n\n\t/* Now kill any processes that happen to have the tty open */\n\tdo_each_thread(g, p) {\n\t\tif (p->signal->tty == tty) {\n\t\t\ttty_notice(tty, \"SAK: killed process %d (%s): by controlling tty\\n\",\n\t\t\t\t   task_pid_nr(p), p->comm);\n\t\t\tgroup_send_sig_info(SIGKILL, SEND_SIG_PRIV, p, PIDTYPE_SID);\n\t\t\tcontinue;\n\t\t}\n\t\ttask_lock(p);\n\t\ti = iterate_fd(p->files, 0, this_tty, tty);\n\t\tif (i != 0) {\n\t\t\ttty_notice(tty, \"SAK: killed process %d (%s): by fd#%d\\n\",\n\t\t\t\t   task_pid_nr(p), p->comm, i - 1);\n\t\t\tgroup_send_sig_info(SIGKILL, SEND_SIG_PRIV, p, PIDTYPE_SID);\n\t\t}\n\t\ttask_unlock(p);\n\t} while_each_thread(g, p);\n\tread_unlock(&tasklist_lock);\n#endif\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148246,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "void __do_SAK(struct tty_struct *tty)\n{\n#ifdef TTY_SOFT_SAK\n\ttty_hangup(tty);\n#else\n\tstruct task_struct *g, *p;\n\tstruct pid *session;\n\tint\t\ti;\n\tunsigned long flags;\n\n\tif (!tty)\n\t\treturn;\n\n\tspin_lock_irqsave(&tty->ctrl_lock, flags);\n\tsession = get_pid(tty->session);\n\tspin_unlock_irqrestore(&tty->ctrl_lock, flags);\n\n\ttty_ldisc_flush(tty);\n\n\ttty_driver_flush_buffer(tty);\n\n\tread_lock(&tasklist_lock);\n\t/* Kill the entire session */\n\tdo_each_pid_task(session, PIDTYPE_SID, p) {\n\t\ttty_notice(tty, \"SAK: killed process %d (%s): by session\\n\",\n\t\t\t   task_pid_nr(p), p->comm);\n\t\tgroup_send_sig_info(SIGKILL, SEND_SIG_PRIV, p, PIDTYPE_SID);\n\t} while_each_pid_task(session, PIDTYPE_SID, p);\n\n\t/* Now kill any processes that happen to have the tty open */\n\tdo_each_thread(g, p) {\n\t\tif (p->signal->tty == tty) {\n\t\t\ttty_notice(tty, \"SAK: killed process %d (%s): by controlling tty\\n\",\n\t\t\t\t   task_pid_nr(p), p->comm);\n\t\t\tgroup_send_sig_info(SIGKILL, SEND_SIG_PRIV, p, PIDTYPE_SID);\n\t\t\tcontinue;\n\t\t}\n\t\ttask_lock(p);\n\t\ti = iterate_fd(p->files, 0, this_tty, tty);\n\t\tif (i != 0) {\n\t\t\ttty_notice(tty, \"SAK: killed process %d (%s): by fd#%d\\n\",\n\t\t\t\t   task_pid_nr(p), p->comm, i - 1);\n\t\t\tgroup_send_sig_info(SIGKILL, SEND_SIG_PRIV, p, PIDTYPE_SID);\n\t\t}\n\t\ttask_unlock(p);\n\t} while_each_thread(g, p);\n\tread_unlock(&tasklist_lock);\n\tput_pid(session);\n#endif\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148247,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "int do_epoll_ctl(int epfd, int op, int fd, struct epoll_event *epds,\n\t\t bool nonblock)\n{\n\tint error;\n\tint full_check = 0;\n\tstruct fd f, tf;\n\tstruct eventpoll *ep;\n\tstruct epitem *epi;\n\tstruct eventpoll *tep = NULL;\n\n\terror = -EBADF;\n\tf = fdget(epfd);\n\tif (!f.file)\n\t\tgoto error_return;\n\n\t/* Get the \"struct file *\" for the target file */\n\ttf = fdget(fd);\n\tif (!tf.file)\n\t\tgoto error_fput;\n\n\t/* The target file descriptor must support poll */\n\terror = -EPERM;\n\tif (!file_can_poll(tf.file))\n\t\tgoto error_tgt_fput;\n\n\t/* Check if EPOLLWAKEUP is allowed */\n\tif (ep_op_has_event(op))\n\t\tep_take_care_of_epollwakeup(epds);\n\n\t/*\n\t * We have to check that the file structure underneath the file descriptor\n\t * the user passed to us _is_ an eventpoll file. And also we do not permit\n\t * adding an epoll file descriptor inside itself.\n\t */\n\terror = -EINVAL;\n\tif (f.file == tf.file || !is_file_epoll(f.file))\n\t\tgoto error_tgt_fput;\n\n\t/*\n\t * epoll adds to the wakeup queue at EPOLL_CTL_ADD time only,\n\t * so EPOLLEXCLUSIVE is not allowed for a EPOLL_CTL_MOD operation.\n\t * Also, we do not currently supported nested exclusive wakeups.\n\t */\n\tif (ep_op_has_event(op) && (epds->events & EPOLLEXCLUSIVE)) {\n\t\tif (op == EPOLL_CTL_MOD)\n\t\t\tgoto error_tgt_fput;\n\t\tif (op == EPOLL_CTL_ADD && (is_file_epoll(tf.file) ||\n\t\t\t\t(epds->events & ~EPOLLEXCLUSIVE_OK_BITS)))\n\t\t\tgoto error_tgt_fput;\n\t}\n\n\t/*\n\t * At this point it is safe to assume that the \"private_data\" contains\n\t * our own data structure.\n\t */\n\tep = f.file->private_data;\n\n\t/*\n\t * When we insert an epoll file descriptor, inside another epoll file\n\t * descriptor, there is the change of creating closed loops, which are\n\t * better be handled here, than in more critical paths. While we are\n\t * checking for loops we also determine the list of files reachable\n\t * and hang them on the tfile_check_list, so we can check that we\n\t * haven't created too many possible wakeup paths.\n\t *\n\t * We do not need to take the global 'epumutex' on EPOLL_CTL_ADD when\n\t * the epoll file descriptor is attaching directly to a wakeup source,\n\t * unless the epoll file descriptor is nested. The purpose of taking the\n\t * 'epmutex' on add is to prevent complex toplogies such as loops and\n\t * deep wakeup paths from forming in parallel through multiple\n\t * EPOLL_CTL_ADD operations.\n\t */\n\terror = epoll_mutex_lock(&ep->mtx, 0, nonblock);\n\tif (error)\n\t\tgoto error_tgt_fput;\n\tif (op == EPOLL_CTL_ADD) {\n\t\tif (!list_empty(&f.file->f_ep_links) ||\n\t\t\t\t\t\tis_file_epoll(tf.file)) {\n\t\t\tmutex_unlock(&ep->mtx);\n\t\t\terror = epoll_mutex_lock(&epmutex, 0, nonblock);\n\t\t\tif (error)\n\t\t\t\tgoto error_tgt_fput;\n\t\t\tfull_check = 1;\n\t\t\tif (is_file_epoll(tf.file)) {\n\t\t\t\terror = -ELOOP;\n\t\t\t\tif (ep_loop_check(ep, tf.file) != 0) {\n\t\t\t\t\tclear_tfile_check_list();\n\t\t\t\t\tgoto error_tgt_fput;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tget_file(tf.file);\n\t\t\t\tlist_add(&tf.file->f_tfile_llink,\n\t\t\t\t\t\t\t&tfile_check_list);\n\t\t\t}\n\t\t\terror = epoll_mutex_lock(&ep->mtx, 0, nonblock);\n\t\t\tif (error) {\nout_del:\n\t\t\t\tlist_del(&tf.file->f_tfile_llink);\n\t\t\t\tif (!is_file_epoll(tf.file))\n\t\t\t\t\tfput(tf.file);\n\t\t\t\tgoto error_tgt_fput;\n\t\t\t}\n\t\t\tif (is_file_epoll(tf.file)) {\n\t\t\t\ttep = tf.file->private_data;\n\t\t\t\terror = epoll_mutex_lock(&tep->mtx, 1, nonblock);\n\t\t\t\tif (error) {\n\t\t\t\t\tmutex_unlock(&ep->mtx);\n\t\t\t\t\tgoto out_del;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Try to lookup the file inside our RB tree, Since we grabbed \"mtx\"\n\t * above, we can be sure to be able to use the item looked up by\n\t * ep_find() till we release the mutex.\n\t */\n\tepi = ep_find(ep, tf.file, fd);\n\n\terror = -EINVAL;\n\tswitch (op) {\n\tcase EPOLL_CTL_ADD:\n\t\tif (!epi) {\n\t\t\tepds->events |= EPOLLERR | EPOLLHUP;\n\t\t\terror = ep_insert(ep, epds, tf.file, fd, full_check);\n\t\t} else\n\t\t\terror = -EEXIST;\n\t\tif (full_check)\n\t\t\tclear_tfile_check_list();\n\t\tbreak;\n\tcase EPOLL_CTL_DEL:\n\t\tif (epi)\n\t\t\terror = ep_remove(ep, epi);\n\t\telse\n\t\t\terror = -ENOENT;\n\t\tbreak;\n\tcase EPOLL_CTL_MOD:\n\t\tif (epi) {\n\t\t\tif (!(epi->event.events & EPOLLEXCLUSIVE)) {\n\t\t\t\tepds->events |= EPOLLERR | EPOLLHUP;\n\t\t\t\terror = ep_modify(ep, epi, epds);\n\t\t\t}\n\t\t} else\n\t\t\terror = -ENOENT;\n\t\tbreak;\n\t}\n\tif (tep != NULL)\n\t\tmutex_unlock(&tep->mtx);\n\tmutex_unlock(&ep->mtx);\n\nerror_tgt_fput:\n\tif (full_check)\n\t\tmutex_unlock(&epmutex);\n\n\tfdput(tf);\nerror_fput:\n\tfdput(f);\nerror_return:\n\n\treturn error;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148268,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "int do_epoll_ctl(int epfd, int op, int fd, struct epoll_event *epds,\n\t\t bool nonblock)\n{\n\tint error;\n\tint full_check = 0;\n\tstruct fd f, tf;\n\tstruct eventpoll *ep;\n\tstruct epitem *epi;\n\tstruct eventpoll *tep = NULL;\n\n\terror = -EBADF;\n\tf = fdget(epfd);\n\tif (!f.file)\n\t\tgoto error_return;\n\n\t/* Get the \"struct file *\" for the target file */\n\ttf = fdget(fd);\n\tif (!tf.file)\n\t\tgoto error_fput;\n\n\t/* The target file descriptor must support poll */\n\terror = -EPERM;\n\tif (!file_can_poll(tf.file))\n\t\tgoto error_tgt_fput;\n\n\t/* Check if EPOLLWAKEUP is allowed */\n\tif (ep_op_has_event(op))\n\t\tep_take_care_of_epollwakeup(epds);\n\n\t/*\n\t * We have to check that the file structure underneath the file descriptor\n\t * the user passed to us _is_ an eventpoll file. And also we do not permit\n\t * adding an epoll file descriptor inside itself.\n\t */\n\terror = -EINVAL;\n\tif (f.file == tf.file || !is_file_epoll(f.file))\n\t\tgoto error_tgt_fput;\n\n\t/*\n\t * epoll adds to the wakeup queue at EPOLL_CTL_ADD time only,\n\t * so EPOLLEXCLUSIVE is not allowed for a EPOLL_CTL_MOD operation.\n\t * Also, we do not currently supported nested exclusive wakeups.\n\t */\n\tif (ep_op_has_event(op) && (epds->events & EPOLLEXCLUSIVE)) {\n\t\tif (op == EPOLL_CTL_MOD)\n\t\t\tgoto error_tgt_fput;\n\t\tif (op == EPOLL_CTL_ADD && (is_file_epoll(tf.file) ||\n\t\t\t\t(epds->events & ~EPOLLEXCLUSIVE_OK_BITS)))\n\t\t\tgoto error_tgt_fput;\n\t}\n\n\t/*\n\t * At this point it is safe to assume that the \"private_data\" contains\n\t * our own data structure.\n\t */\n\tep = f.file->private_data;\n\n\t/*\n\t * When we insert an epoll file descriptor, inside another epoll file\n\t * descriptor, there is the change of creating closed loops, which are\n\t * better be handled here, than in more critical paths. While we are\n\t * checking for loops we also determine the list of files reachable\n\t * and hang them on the tfile_check_list, so we can check that we\n\t * haven't created too many possible wakeup paths.\n\t *\n\t * We do not need to take the global 'epumutex' on EPOLL_CTL_ADD when\n\t * the epoll file descriptor is attaching directly to a wakeup source,\n\t * unless the epoll file descriptor is nested. The purpose of taking the\n\t * 'epmutex' on add is to prevent complex toplogies such as loops and\n\t * deep wakeup paths from forming in parallel through multiple\n\t * EPOLL_CTL_ADD operations.\n\t */\n\terror = epoll_mutex_lock(&ep->mtx, 0, nonblock);\n\tif (error)\n\t\tgoto error_tgt_fput;\n\tif (op == EPOLL_CTL_ADD) {\n\t\tif (!list_empty(&f.file->f_ep_links) ||\n\t\t\t\t\t\tis_file_epoll(tf.file)) {\n\t\t\tmutex_unlock(&ep->mtx);\n\t\t\terror = epoll_mutex_lock(&epmutex, 0, nonblock);\n\t\t\tif (error)\n\t\t\t\tgoto error_tgt_fput;\n\t\t\tfull_check = 1;\n\t\t\tif (is_file_epoll(tf.file)) {\n\t\t\t\terror = -ELOOP;\n\t\t\t\tif (ep_loop_check(ep, tf.file) != 0)\n\t\t\t\t\tgoto error_tgt_fput;\n\t\t\t} else {\n\t\t\t\tget_file(tf.file);\n\t\t\t\tlist_add(&tf.file->f_tfile_llink,\n\t\t\t\t\t\t\t&tfile_check_list);\n\t\t\t}\n\t\t\terror = epoll_mutex_lock(&ep->mtx, 0, nonblock);\n\t\t\tif (error)\n\t\t\t\tgoto error_tgt_fput;\n\t\t\tif (is_file_epoll(tf.file)) {\n\t\t\t\ttep = tf.file->private_data;\n\t\t\t\terror = epoll_mutex_lock(&tep->mtx, 1, nonblock);\n\t\t\t\tif (error) {\n\t\t\t\t\tmutex_unlock(&ep->mtx);\n\t\t\t\t\tgoto error_tgt_fput;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Try to lookup the file inside our RB tree, Since we grabbed \"mtx\"\n\t * above, we can be sure to be able to use the item looked up by\n\t * ep_find() till we release the mutex.\n\t */\n\tepi = ep_find(ep, tf.file, fd);\n\n\terror = -EINVAL;\n\tswitch (op) {\n\tcase EPOLL_CTL_ADD:\n\t\tif (!epi) {\n\t\t\tepds->events |= EPOLLERR | EPOLLHUP;\n\t\t\terror = ep_insert(ep, epds, tf.file, fd, full_check);\n\t\t} else\n\t\t\terror = -EEXIST;\n\t\tbreak;\n\tcase EPOLL_CTL_DEL:\n\t\tif (epi)\n\t\t\terror = ep_remove(ep, epi);\n\t\telse\n\t\t\terror = -ENOENT;\n\t\tbreak;\n\tcase EPOLL_CTL_MOD:\n\t\tif (epi) {\n\t\t\tif (!(epi->event.events & EPOLLEXCLUSIVE)) {\n\t\t\t\tepds->events |= EPOLLERR | EPOLLHUP;\n\t\t\t\terror = ep_modify(ep, epi, epds);\n\t\t\t}\n\t\t} else\n\t\t\terror = -ENOENT;\n\t\tbreak;\n\t}\n\tif (tep != NULL)\n\t\tmutex_unlock(&tep->mtx);\n\tmutex_unlock(&ep->mtx);\n\nerror_tgt_fput:\n\tif (full_check) {\n\t\tclear_tfile_check_list();\n\t\tmutex_unlock(&epmutex);\n\t}\n\n\tfdput(tf);\nerror_fput:\n\tfdput(f);\nerror_return:\n\n\treturn error;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148269,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int kvm_s390_get_cmma(struct kvm *kvm, struct kvm_s390_cmma_log *args,\n\t\t\t     u8 *res, unsigned long bufsize)\n{\n\tunsigned long mem_end, cur_gfn, next_gfn, hva, pgstev;\n\tstruct kvm_memslots *slots = kvm_memslots(kvm);\n\tstruct kvm_memory_slot *ms;\n\n\tcur_gfn = kvm_s390_next_dirty_cmma(slots, args->start_gfn);\n\tms = gfn_to_memslot(kvm, cur_gfn);\n\targs->count = 0;\n\targs->start_gfn = cur_gfn;\n\tif (!ms)\n\t\treturn 0;\n\tnext_gfn = kvm_s390_next_dirty_cmma(slots, cur_gfn + 1);\n\tmem_end = slots->memslots[0].base_gfn + slots->memslots[0].npages;\n\n\twhile (args->count < bufsize) {\n\t\thva = gfn_to_hva(kvm, cur_gfn);\n\t\tif (kvm_is_error_hva(hva))\n\t\t\treturn 0;\n\t\t/* Decrement only if we actually flipped the bit to 0 */\n\t\tif (test_and_clear_bit(cur_gfn - ms->base_gfn, kvm_second_dirty_bitmap(ms)))\n\t\t\tatomic64_dec(&kvm->arch.cmma_dirty_pages);\n\t\tif (get_pgste(kvm->mm, hva, &pgstev) < 0)\n\t\t\tpgstev = 0;\n\t\t/* Save the value */\n\t\tres[args->count++] = (pgstev >> 24) & 0x43;\n\t\t/* If the next bit is too far away, stop. */\n\t\tif (next_gfn > cur_gfn + KVM_S390_MAX_BIT_DISTANCE)\n\t\t\treturn 0;\n\t\t/* If we reached the previous \"next\", find the next one */\n\t\tif (cur_gfn == next_gfn)\n\t\t\tnext_gfn = kvm_s390_next_dirty_cmma(slots, cur_gfn + 1);\n\t\t/* Reached the end of memory or of the buffer, stop */\n\t\tif ((next_gfn >= mem_end) ||\n\t\t    (next_gfn - args->start_gfn >= bufsize))\n\t\t\treturn 0;\n\t\tcur_gfn++;\n\t\t/* Reached the end of the current memslot, take the next one. */\n\t\tif (cur_gfn - ms->base_gfn >= ms->npages) {\n\t\t\tms = gfn_to_memslot(kvm, cur_gfn);\n\t\t\tif (!ms)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148290,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int kvm_s390_get_cmma(struct kvm *kvm, struct kvm_s390_cmma_log *args,\n\t\t\t     u8 *res, unsigned long bufsize)\n{\n\tunsigned long mem_end, cur_gfn, next_gfn, hva, pgstev;\n\tstruct kvm_memslots *slots = kvm_memslots(kvm);\n\tstruct kvm_memory_slot *ms;\n\n\tif (unlikely(!slots->used_slots))\n\t\treturn 0;\n\n\tcur_gfn = kvm_s390_next_dirty_cmma(slots, args->start_gfn);\n\tms = gfn_to_memslot(kvm, cur_gfn);\n\targs->count = 0;\n\targs->start_gfn = cur_gfn;\n\tif (!ms)\n\t\treturn 0;\n\tnext_gfn = kvm_s390_next_dirty_cmma(slots, cur_gfn + 1);\n\tmem_end = slots->memslots[0].base_gfn + slots->memslots[0].npages;\n\n\twhile (args->count < bufsize) {\n\t\thva = gfn_to_hva(kvm, cur_gfn);\n\t\tif (kvm_is_error_hva(hva))\n\t\t\treturn 0;\n\t\t/* Decrement only if we actually flipped the bit to 0 */\n\t\tif (test_and_clear_bit(cur_gfn - ms->base_gfn, kvm_second_dirty_bitmap(ms)))\n\t\t\tatomic64_dec(&kvm->arch.cmma_dirty_pages);\n\t\tif (get_pgste(kvm->mm, hva, &pgstev) < 0)\n\t\t\tpgstev = 0;\n\t\t/* Save the value */\n\t\tres[args->count++] = (pgstev >> 24) & 0x43;\n\t\t/* If the next bit is too far away, stop. */\n\t\tif (next_gfn > cur_gfn + KVM_S390_MAX_BIT_DISTANCE)\n\t\t\treturn 0;\n\t\t/* If we reached the previous \"next\", find the next one */\n\t\tif (cur_gfn == next_gfn)\n\t\t\tnext_gfn = kvm_s390_next_dirty_cmma(slots, cur_gfn + 1);\n\t\t/* Reached the end of memory or of the buffer, stop */\n\t\tif ((next_gfn >= mem_end) ||\n\t\t    (next_gfn - args->start_gfn >= bufsize))\n\t\t\treturn 0;\n\t\tcur_gfn++;\n\t\t/* Reached the end of the current memslot, take the next one. */\n\t\tif (cur_gfn - ms->base_gfn >= ms->npages) {\n\t\t\tms = gfn_to_memslot(kvm, cur_gfn);\n\t\t\tif (!ms)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148291,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static inline void kvm_memslot_delete(struct kvm_memslots *slots,\n\t\t\t\t      struct kvm_memory_slot *memslot)\n{\n\tstruct kvm_memory_slot *mslots = slots->memslots;\n\tint i;\n\n\tif (WARN_ON(slots->id_to_index[memslot->id] == -1))\n\t\treturn;\n\n\tslots->used_slots--;\n\n\tfor (i = slots->id_to_index[memslot->id]; i < slots->used_slots; i++) {\n\t\tmslots[i] = mslots[i + 1];\n\t\tslots->id_to_index[mslots[i].id] = i;\n\t}\n\tmslots[i] = *memslot;\n\tslots->id_to_index[memslot->id] = -1;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148292,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static inline void kvm_memslot_delete(struct kvm_memslots *slots,\n\t\t\t\t      struct kvm_memory_slot *memslot)\n{\n\tstruct kvm_memory_slot *mslots = slots->memslots;\n\tint i;\n\n\tif (WARN_ON(slots->id_to_index[memslot->id] == -1))\n\t\treturn;\n\n\tslots->used_slots--;\n\n\tif (atomic_read(&slots->lru_slot) >= slots->used_slots)\n\t\tatomic_set(&slots->lru_slot, 0);\n\n\tfor (i = slots->id_to_index[memslot->id]; i < slots->used_slots; i++) {\n\t\tmslots[i] = mslots[i + 1];\n\t\tslots->id_to_index[mslots[i].id] = i;\n\t}\n\tmslots[i] = *memslot;\n\tslots->id_to_index[memslot->id] = -1;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148293,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "search_memslots(struct kvm_memslots *slots, gfn_t gfn)\n{\n\tint start = 0, end = slots->used_slots;\n\tint slot = atomic_read(&slots->lru_slot);\n\tstruct kvm_memory_slot *memslots = slots->memslots;\n\n\tif (gfn >= memslots[slot].base_gfn &&\n\t    gfn < memslots[slot].base_gfn + memslots[slot].npages)\n\t\treturn &memslots[slot];\n\n\twhile (start < end) {\n\t\tslot = start + (end - start) / 2;\n\n\t\tif (gfn >= memslots[slot].base_gfn)\n\t\t\tend = slot;\n\t\telse\n\t\t\tstart = slot + 1;\n\t}\n\n\tif (gfn >= memslots[start].base_gfn &&\n\t    gfn < memslots[start].base_gfn + memslots[start].npages) {\n\t\tatomic_set(&slots->lru_slot, start);\n\t\treturn &memslots[start];\n\t}\n\n\treturn NULL;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148294,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "search_memslots(struct kvm_memslots *slots, gfn_t gfn)\n{\n\tint start = 0, end = slots->used_slots;\n\tint slot = atomic_read(&slots->lru_slot);\n\tstruct kvm_memory_slot *memslots = slots->memslots;\n\n\tif (unlikely(!slots->used_slots))\n\t\treturn NULL;\n\n\tif (gfn >= memslots[slot].base_gfn &&\n\t    gfn < memslots[slot].base_gfn + memslots[slot].npages)\n\t\treturn &memslots[slot];\n\n\twhile (start < end) {\n\t\tslot = start + (end - start) / 2;\n\n\t\tif (gfn >= memslots[slot].base_gfn)\n\t\t\tend = slot;\n\t\telse\n\t\t\tstart = slot + 1;\n\t}\n\n\tif (gfn >= memslots[start].base_gfn &&\n\t    gfn < memslots[start].base_gfn + memslots[start].npages) {\n\t\tatomic_set(&slots->lru_slot, start);\n\t\treturn &memslots[start];\n\t}\n\n\treturn NULL;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148295,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int xdp_umem_reg(struct xdp_umem *umem, struct xdp_umem_reg *mr)\n{\n\tbool unaligned_chunks = mr->flags & XDP_UMEM_UNALIGNED_CHUNK_FLAG;\n\tu32 chunk_size = mr->chunk_size, headroom = mr->headroom;\n\tunsigned int chunks, chunks_per_page;\n\tu64 addr = mr->addr, size = mr->len;\n\tint size_chk, err;\n\n\tif (chunk_size < XDP_UMEM_MIN_CHUNK_SIZE || chunk_size > PAGE_SIZE) {\n\t\t/* Strictly speaking we could support this, if:\n\t\t * - huge pages, or*\n\t\t * - using an IOMMU, or\n\t\t * - making sure the memory area is consecutive\n\t\t * but for now, we simply say \"computer says no\".\n\t\t */\n\t\treturn -EINVAL;\n\t}\n\n\tif (mr->flags & ~(XDP_UMEM_UNALIGNED_CHUNK_FLAG |\n\t\t\tXDP_UMEM_USES_NEED_WAKEUP))\n\t\treturn -EINVAL;\n\n\tif (!unaligned_chunks && !is_power_of_2(chunk_size))\n\t\treturn -EINVAL;\n\n\tif (!PAGE_ALIGNED(addr)) {\n\t\t/* Memory area has to be page size aligned. For\n\t\t * simplicity, this might change.\n\t\t */\n\t\treturn -EINVAL;\n\t}\n\n\tif ((addr + size) < addr)\n\t\treturn -EINVAL;\n\n\tchunks = (unsigned int)div_u64(size, chunk_size);\n\tif (chunks == 0)\n\t\treturn -EINVAL;\n\n\tif (!unaligned_chunks) {\n\t\tchunks_per_page = PAGE_SIZE / chunk_size;\n\t\tif (chunks < chunks_per_page || chunks % chunks_per_page)\n\t\t\treturn -EINVAL;\n\t}\n\n\tsize_chk = chunk_size - headroom - XDP_PACKET_HEADROOM;\n\tif (size_chk < 0)\n\t\treturn -EINVAL;\n\n\tumem->address = (unsigned long)addr;\n\tumem->chunk_mask = unaligned_chunks ? XSK_UNALIGNED_BUF_ADDR_MASK\n\t\t\t\t\t    : ~((u64)chunk_size - 1);\n\tumem->size = size;\n\tumem->headroom = headroom;\n\tumem->chunk_size_nohr = chunk_size - headroom;\n\tumem->npgs = size / PAGE_SIZE;\n\tumem->pgs = NULL;\n\tumem->user = NULL;\n\tumem->flags = mr->flags;\n\tINIT_LIST_HEAD(&umem->xsk_list);\n\tspin_lock_init(&umem->xsk_list_lock);\n\n\trefcount_set(&umem->users, 1);\n\n\terr = xdp_umem_account_pages(umem);\n\tif (err)\n\t\treturn err;\n\n\terr = xdp_umem_pin_pages(umem);\n\tif (err)\n\t\tgoto out_account;\n\n\tumem->pages = kvcalloc(umem->npgs, sizeof(*umem->pages),\n\t\t\t       GFP_KERNEL_ACCOUNT);\n\tif (!umem->pages) {\n\t\terr = -ENOMEM;\n\t\tgoto out_pin;\n\t}\n\n\terr = xdp_umem_map_pages(umem);\n\tif (!err)\n\t\treturn 0;\n\n\tkvfree(umem->pages);\n\nout_pin:\n\txdp_umem_unpin_pages(umem);\nout_account:\n\txdp_umem_unaccount_pages(umem);\n\treturn err;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148316,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int xdp_umem_reg(struct xdp_umem *umem, struct xdp_umem_reg *mr)\n{\n\tbool unaligned_chunks = mr->flags & XDP_UMEM_UNALIGNED_CHUNK_FLAG;\n\tu32 chunk_size = mr->chunk_size, headroom = mr->headroom;\n\tunsigned int chunks, chunks_per_page;\n\tu64 addr = mr->addr, size = mr->len;\n\tint err;\n\n\tif (chunk_size < XDP_UMEM_MIN_CHUNK_SIZE || chunk_size > PAGE_SIZE) {\n\t\t/* Strictly speaking we could support this, if:\n\t\t * - huge pages, or*\n\t\t * - using an IOMMU, or\n\t\t * - making sure the memory area is consecutive\n\t\t * but for now, we simply say \"computer says no\".\n\t\t */\n\t\treturn -EINVAL;\n\t}\n\n\tif (mr->flags & ~(XDP_UMEM_UNALIGNED_CHUNK_FLAG |\n\t\t\tXDP_UMEM_USES_NEED_WAKEUP))\n\t\treturn -EINVAL;\n\n\tif (!unaligned_chunks && !is_power_of_2(chunk_size))\n\t\treturn -EINVAL;\n\n\tif (!PAGE_ALIGNED(addr)) {\n\t\t/* Memory area has to be page size aligned. For\n\t\t * simplicity, this might change.\n\t\t */\n\t\treturn -EINVAL;\n\t}\n\n\tif ((addr + size) < addr)\n\t\treturn -EINVAL;\n\n\tchunks = (unsigned int)div_u64(size, chunk_size);\n\tif (chunks == 0)\n\t\treturn -EINVAL;\n\n\tif (!unaligned_chunks) {\n\t\tchunks_per_page = PAGE_SIZE / chunk_size;\n\t\tif (chunks < chunks_per_page || chunks % chunks_per_page)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (headroom >= chunk_size - XDP_PACKET_HEADROOM)\n\t\treturn -EINVAL;\n\n\tumem->address = (unsigned long)addr;\n\tumem->chunk_mask = unaligned_chunks ? XSK_UNALIGNED_BUF_ADDR_MASK\n\t\t\t\t\t    : ~((u64)chunk_size - 1);\n\tumem->size = size;\n\tumem->headroom = headroom;\n\tumem->chunk_size_nohr = chunk_size - headroom;\n\tumem->npgs = size / PAGE_SIZE;\n\tumem->pgs = NULL;\n\tumem->user = NULL;\n\tumem->flags = mr->flags;\n\tINIT_LIST_HEAD(&umem->xsk_list);\n\tspin_lock_init(&umem->xsk_list_lock);\n\n\trefcount_set(&umem->users, 1);\n\n\terr = xdp_umem_account_pages(umem);\n\tif (err)\n\t\treturn err;\n\n\terr = xdp_umem_pin_pages(umem);\n\tif (err)\n\t\tgoto out_account;\n\n\tumem->pages = kvcalloc(umem->npgs, sizeof(*umem->pages),\n\t\t\t       GFP_KERNEL_ACCOUNT);\n\tif (!umem->pages) {\n\t\terr = -ENOMEM;\n\t\tgoto out_pin;\n\t}\n\n\terr = xdp_umem_map_pages(umem);\n\tif (!err)\n\t\treturn 0;\n\n\tkvfree(umem->pages);\n\nout_pin:\n\txdp_umem_unpin_pages(umem);\nout_account:\n\txdp_umem_unaccount_pages(umem);\n\treturn err;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148317,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "int nested_svm_vmrun(struct vcpu_svm *svm)\n{\n\tint ret;\n\tstruct vmcb *vmcb12;\n\tstruct vmcb *hsave = svm->nested.hsave;\n\tstruct vmcb *vmcb = svm->vmcb;\n\tstruct kvm_host_map map;\n\tu64 vmcb12_gpa;\n\n\tif (is_smm(&svm->vcpu)) {\n\t\tkvm_queue_exception(&svm->vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\tvmcb12_gpa = svm->vmcb->save.rax;\n\tret = kvm_vcpu_map(&svm->vcpu, gpa_to_gfn(vmcb12_gpa), &map);\n\tif (ret == -EINVAL) {\n\t\tkvm_inject_gp(&svm->vcpu, 0);\n\t\treturn 1;\n\t} else if (ret) {\n\t\treturn kvm_skip_emulated_instruction(&svm->vcpu);\n\t}\n\n\tret = kvm_skip_emulated_instruction(&svm->vcpu);\n\n\tvmcb12 = map.hva;\n\n\tif (WARN_ON_ONCE(!svm->nested.initialized))\n\t\treturn -EINVAL;\n\n\tif (!nested_vmcb_checks(svm, vmcb12)) {\n\t\tvmcb12->control.exit_code    = SVM_EXIT_ERR;\n\t\tvmcb12->control.exit_code_hi = 0;\n\t\tvmcb12->control.exit_info_1  = 0;\n\t\tvmcb12->control.exit_info_2  = 0;\n\t\tgoto out;\n\t}\n\n\ttrace_kvm_nested_vmrun(svm->vmcb->save.rip, vmcb12_gpa,\n\t\t\t       vmcb12->save.rip,\n\t\t\t       vmcb12->control.int_ctl,\n\t\t\t       vmcb12->control.event_inj,\n\t\t\t       vmcb12->control.nested_ctl);\n\n\ttrace_kvm_nested_intercepts(vmcb12->control.intercepts[INTERCEPT_CR] & 0xffff,\n\t\t\t\t    vmcb12->control.intercepts[INTERCEPT_CR] >> 16,\n\t\t\t\t    vmcb12->control.intercepts[INTERCEPT_EXCEPTION],\n\t\t\t\t    vmcb12->control.intercepts[INTERCEPT_WORD3],\n\t\t\t\t    vmcb12->control.intercepts[INTERCEPT_WORD4],\n\t\t\t\t    vmcb12->control.intercepts[INTERCEPT_WORD5]);\n\n\t/* Clear internal status */\n\tkvm_clear_exception_queue(&svm->vcpu);\n\tkvm_clear_interrupt_queue(&svm->vcpu);\n\n\t/*\n\t * Save the old vmcb, so we don't need to pick what we save, but can\n\t * restore everything when a VMEXIT occurs\n\t */\n\thsave->save.es     = vmcb->save.es;\n\thsave->save.cs     = vmcb->save.cs;\n\thsave->save.ss     = vmcb->save.ss;\n\thsave->save.ds     = vmcb->save.ds;\n\thsave->save.gdtr   = vmcb->save.gdtr;\n\thsave->save.idtr   = vmcb->save.idtr;\n\thsave->save.efer   = svm->vcpu.arch.efer;\n\thsave->save.cr0    = kvm_read_cr0(&svm->vcpu);\n\thsave->save.cr4    = svm->vcpu.arch.cr4;\n\thsave->save.rflags = kvm_get_rflags(&svm->vcpu);\n\thsave->save.rip    = kvm_rip_read(&svm->vcpu);\n\thsave->save.rsp    = vmcb->save.rsp;\n\thsave->save.rax    = vmcb->save.rax;\n\tif (npt_enabled)\n\t\thsave->save.cr3    = vmcb->save.cr3;\n\telse\n\t\thsave->save.cr3    = kvm_read_cr3(&svm->vcpu);\n\n\tcopy_vmcb_control_area(&hsave->control, &vmcb->control);\n\n\tsvm->nested.nested_run_pending = 1;\n\n\tif (enter_svm_guest_mode(svm, vmcb12_gpa, vmcb12))\n\t\tgoto out_exit_err;\n\n\tif (nested_svm_vmrun_msrpm(svm))\n\t\tgoto out;\n\nout_exit_err:\n\tsvm->nested.nested_run_pending = 0;\n\n\tsvm->vmcb->control.exit_code    = SVM_EXIT_ERR;\n\tsvm->vmcb->control.exit_code_hi = 0;\n\tsvm->vmcb->control.exit_info_1  = 0;\n\tsvm->vmcb->control.exit_info_2  = 0;\n\n\tnested_svm_vmexit(svm);\n\nout:\n\tkvm_vcpu_unmap(&svm->vcpu, &map, true);\n\n\treturn ret;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148358,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "int nested_svm_vmrun(struct vcpu_svm *svm)\n{\n\tint ret;\n\tstruct vmcb *vmcb12;\n\tstruct vmcb *hsave = svm->nested.hsave;\n\tstruct vmcb *vmcb = svm->vmcb;\n\tstruct kvm_host_map map;\n\tu64 vmcb12_gpa;\n\n\tif (is_smm(&svm->vcpu)) {\n\t\tkvm_queue_exception(&svm->vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\tvmcb12_gpa = svm->vmcb->save.rax;\n\tret = kvm_vcpu_map(&svm->vcpu, gpa_to_gfn(vmcb12_gpa), &map);\n\tif (ret == -EINVAL) {\n\t\tkvm_inject_gp(&svm->vcpu, 0);\n\t\treturn 1;\n\t} else if (ret) {\n\t\treturn kvm_skip_emulated_instruction(&svm->vcpu);\n\t}\n\n\tret = kvm_skip_emulated_instruction(&svm->vcpu);\n\n\tvmcb12 = map.hva;\n\n\tif (WARN_ON_ONCE(!svm->nested.initialized))\n\t\treturn -EINVAL;\n\n\tload_nested_vmcb_control(svm, &vmcb12->control);\n\n\tif (!nested_vmcb_check_save(svm, vmcb12) ||\n\t    !nested_vmcb_check_controls(&svm->nested.ctl)) {\n\t\tvmcb12->control.exit_code    = SVM_EXIT_ERR;\n\t\tvmcb12->control.exit_code_hi = 0;\n\t\tvmcb12->control.exit_info_1  = 0;\n\t\tvmcb12->control.exit_info_2  = 0;\n\t\tgoto out;\n\t}\n\n\ttrace_kvm_nested_vmrun(svm->vmcb->save.rip, vmcb12_gpa,\n\t\t\t       vmcb12->save.rip,\n\t\t\t       vmcb12->control.int_ctl,\n\t\t\t       vmcb12->control.event_inj,\n\t\t\t       vmcb12->control.nested_ctl);\n\n\ttrace_kvm_nested_intercepts(vmcb12->control.intercepts[INTERCEPT_CR] & 0xffff,\n\t\t\t\t    vmcb12->control.intercepts[INTERCEPT_CR] >> 16,\n\t\t\t\t    vmcb12->control.intercepts[INTERCEPT_EXCEPTION],\n\t\t\t\t    vmcb12->control.intercepts[INTERCEPT_WORD3],\n\t\t\t\t    vmcb12->control.intercepts[INTERCEPT_WORD4],\n\t\t\t\t    vmcb12->control.intercepts[INTERCEPT_WORD5]);\n\n\t/* Clear internal status */\n\tkvm_clear_exception_queue(&svm->vcpu);\n\tkvm_clear_interrupt_queue(&svm->vcpu);\n\n\t/*\n\t * Save the old vmcb, so we don't need to pick what we save, but can\n\t * restore everything when a VMEXIT occurs\n\t */\n\thsave->save.es     = vmcb->save.es;\n\thsave->save.cs     = vmcb->save.cs;\n\thsave->save.ss     = vmcb->save.ss;\n\thsave->save.ds     = vmcb->save.ds;\n\thsave->save.gdtr   = vmcb->save.gdtr;\n\thsave->save.idtr   = vmcb->save.idtr;\n\thsave->save.efer   = svm->vcpu.arch.efer;\n\thsave->save.cr0    = kvm_read_cr0(&svm->vcpu);\n\thsave->save.cr4    = svm->vcpu.arch.cr4;\n\thsave->save.rflags = kvm_get_rflags(&svm->vcpu);\n\thsave->save.rip    = kvm_rip_read(&svm->vcpu);\n\thsave->save.rsp    = vmcb->save.rsp;\n\thsave->save.rax    = vmcb->save.rax;\n\tif (npt_enabled)\n\t\thsave->save.cr3    = vmcb->save.cr3;\n\telse\n\t\thsave->save.cr3    = kvm_read_cr3(&svm->vcpu);\n\n\tcopy_vmcb_control_area(&hsave->control, &vmcb->control);\n\n\tsvm->nested.nested_run_pending = 1;\n\n\tif (enter_svm_guest_mode(svm, vmcb12_gpa, vmcb12))\n\t\tgoto out_exit_err;\n\n\tif (nested_svm_vmrun_msrpm(svm))\n\t\tgoto out;\n\nout_exit_err:\n\tsvm->nested.nested_run_pending = 0;\n\n\tsvm->vmcb->control.exit_code    = SVM_EXIT_ERR;\n\tsvm->vmcb->control.exit_code_hi = 0;\n\tsvm->vmcb->control.exit_info_1  = 0;\n\tsvm->vmcb->control.exit_info_2  = 0;\n\n\tnested_svm_vmexit(svm);\n\nout:\n\tkvm_vcpu_unmap(&svm->vcpu, &map, true);\n\n\treturn ret;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148359,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\nstatic int\nxmlXPathCompOpEvalPositionalPredicate(xmlXPathParserContextPtr ctxt,\n\t\t\t\t      xmlXPathStepOpPtr op,\n\t\t\t\t      xmlNodeSetPtr set,\n\t\t\t\t      int contextSize,\n\t\t\t\t      int minPos,\n\t\t\t\t      int maxPos,\n\t\t\t\t      int hasNsNodes)\n{\n    if (op->ch1 != -1) {\n\txmlXPathCompExprPtr comp = ctxt->comp;\n\tif (comp->steps[op->ch1].op != XPATH_OP_PREDICATE) {\n\t    /*\n\t    * TODO: raise an internal error.\n\t    */\n\t}\n\tcontextSize = xmlXPathCompOpEvalPredicate(ctxt,\n\t    &comp->steps[op->ch1], set, contextSize, hasNsNodes);\n\tCHECK_ERROR0;\n\tif (contextSize <= 0)\n\t    return(0);\n    }\n    /*\n    * Check if the node set contains a sufficient number of nodes for\n    * the requested range.\n    */\n    if (contextSize < minPos) {\n\txmlXPathNodeSetClear(set, hasNsNodes);\n\treturn(0);\n    }\n    if (op->ch2 == -1) {\n\t/*\n\t* TODO: Can this ever happen?\n\t*/\n\treturn (contextSize);\n    } else {\n\txmlDocPtr oldContextDoc;\n\tint i, pos = 0, newContextSize = 0, contextPos = 0, res;\n\txmlXPathStepOpPtr exprOp;\n\txmlXPathObjectPtr contextObj = NULL, exprRes = NULL;\n\txmlNodePtr oldContextNode, contextNode = NULL;\n\txmlXPathContextPtr xpctxt = ctxt->context;\n        int frame;\n\n#ifdef LIBXML_XPTR_ENABLED\n\t    /*\n\t    * URGENT TODO: Check the following:\n\t    *  We don't expect location sets if evaluating prediates, right?\n\t    *  Only filters should expect location sets, right?\n\t*/\n#endif /* LIBXML_XPTR_ENABLED */\n\n\t/*\n\t* Save old context.\n\t*/\n\toldContextNode = xpctxt->node;\n\toldContextDoc = xpctxt->doc;\n\t/*\n\t* Get the expression of this predicate.\n\t*/\n\texprOp = &ctxt->comp->steps[op->ch2];\n\tfor (i = 0; i < set->nodeNr; i++) {\n            xmlXPathObjectPtr tmp;\n\n\t    if (set->nodeTab[i] == NULL)\n\t\tcontinue;\n\n\t    contextNode = set->nodeTab[i];\n\t    xpctxt->node = contextNode;\n\t    xpctxt->contextSize = contextSize;\n\t    xpctxt->proximityPosition = ++contextPos;\n\n\t    /*\n\t    * Initialize the new set.\n\t    * Also set the xpath document in case things like\n\t    * key() evaluation are attempted on the predicate\n\t    */\n\t    if ((contextNode->type != XML_NAMESPACE_DECL) &&\n\t\t(contextNode->doc != NULL))\n\t\txpctxt->doc = contextNode->doc;\n\t    /*\n\t    * Evaluate the predicate expression with 1 context node\n\t    * at a time; this node is packaged into a node set; this\n\t    * node set is handed over to the evaluation mechanism.\n\t    */\n\t    if (contextObj == NULL)\n\t\tcontextObj = xmlXPathCacheNewNodeSet(xpctxt, contextNode);\n\t    else {\n\t\tif (xmlXPathNodeSetAddUnique(contextObj->nodesetval,\n\t\t    contextNode) < 0) {\n\t\t    ctxt->error = XPATH_MEMORY_ERROR;\n\t\t    goto evaluation_exit;\n\t\t}\n\t    }\n\n            frame = xmlXPathSetFrame(ctxt);\n\t    valuePush(ctxt, contextObj);\n\t    res = xmlXPathCompOpEvalToBoolean(ctxt, exprOp, 1);\n            tmp = valuePop(ctxt);\n            xmlXPathPopFrame(ctxt, frame);\n\n\t    if ((ctxt->error != XPATH_EXPRESSION_OK) || (res == -1)) {\n                while (tmp != contextObj) {\n                    /*\n                     * Free up the result\n                     * then pop off contextObj, which will be freed later\n                     */\n                    xmlXPathReleaseObject(xpctxt, tmp);\n                    tmp = valuePop(ctxt);\n                }\n\t\tgoto evaluation_error;\n\t    }\n            /* push the result back onto the stack */\n            valuePush(ctxt, tmp);\n\n\t    if (res)\n\t\tpos++;\n\n\t    if (res && (pos >= minPos) && (pos <= maxPos)) {\n\t\t/*\n\t\t* Fits in the requested range.\n\t\t*/\n\t\tnewContextSize++;\n\t\tif (minPos == maxPos) {\n\t\t    /*\n\t\t    * Only 1 node was requested.\n\t\t    */\n\t\t    if (contextNode->type == XML_NAMESPACE_DECL) {\n\t\t\t/*\n\t\t\t* As always: take care of those nasty\n\t\t\t* namespace nodes.\n\t\t\t*/\n\t\t\tset->nodeTab[i] = NULL;\n\t\t    }\n\t\t    xmlXPathNodeSetClear(set, hasNsNodes);\n\t\t    set->nodeNr = 1;\n\t\t    set->nodeTab[0] = contextNode;\n\t\t    goto evaluation_exit;\n\t\t}\n\t\tif (pos == maxPos) {\n\t\t    /*\n\t\t    * We are done.\n\t\t    */\n\t\t    xmlXPathNodeSetClearFromPos(set, i +1, hasNsNodes);\n\t\t    goto evaluation_exit;\n\t\t}\n\t    } else {\n\t\t/*\n\t\t* Remove the entry from the initial node set.\n\t\t*/\n\t\tset->nodeTab[i] = NULL;\n\t\tif (contextNode->type == XML_NAMESPACE_DECL)\n\t\t    xmlXPathNodeSetFreeNs((xmlNsPtr) contextNode);\n\t    }\n\t    if (exprRes != NULL) {\n\t\txmlXPathReleaseObject(ctxt->context, exprRes);\n\t\texprRes = NULL;\n\t    }\n\t    if (ctxt->value == contextObj) {\n\t\t/*\n\t\t* Don't free the temporary XPath object holding the\n\t\t* context node, in order to avoid massive recreation\n\t\t* inside this loop.\n\t\t*/\n\t\tvaluePop(ctxt);\n\t\txmlXPathNodeSetClear(contextObj->nodesetval, hasNsNodes);\n\t    } else {\n\t\t/*\n\t\t* The object was lost in the evaluation machinery.\n\t\t* Can this happen? Maybe in case of internal-errors.\n\t\t*/\n\t\tcontextObj = NULL;\n\t    }\n\t}\n\tgoto evaluation_exit;\n\nevaluation_error:\n\txmlXPathNodeSetClear(set, hasNsNodes);\n\tnewContextSize = 0;\n\nevaluation_exit:\n\tif (contextObj != NULL) {\n\t    if (ctxt->value == contextObj)\n\t\tvaluePop(ctxt);\n\t    xmlXPathReleaseObject(xpctxt, contextObj);\n\t}\n\tif (exprRes != NULL)\n\t    xmlXPathReleaseObject(ctxt->context, exprRes);\n\t/*\n\t* Reset/invalidate the context.\n\t*/\n\txpctxt->node = oldContextNode;\n\txpctxt->doc = oldContextDoc;\n\txpctxt->contextSize = -1;\n\txpctxt->proximityPosition = -1;\n\treturn(newContextSize);\n    }",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148400,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\nstatic int\nxmlXPathCompOpEvalPositionalPredicate(xmlXPathParserContextPtr ctxt,\n\t\t\t\t      xmlXPathStepOpPtr op,\n\t\t\t\t      xmlNodeSetPtr set,\n\t\t\t\t      int contextSize,\n\t\t\t\t      int minPos,\n\t\t\t\t      int maxPos,\n\t\t\t\t      int hasNsNodes)\n{\n    if (op->ch1 != -1) {\n\txmlXPathCompExprPtr comp = ctxt->comp;\n\tif (comp->steps[op->ch1].op != XPATH_OP_PREDICATE) {\n\t    /*\n\t    * TODO: raise an internal error.\n\t    */\n\t}\n\tcontextSize = xmlXPathCompOpEvalPredicate(ctxt,\n\t    &comp->steps[op->ch1], set, contextSize, hasNsNodes);\n\tCHECK_ERROR0;\n\tif (contextSize <= 0)\n\t    return(0);\n    }\n    /*\n    * Check if the node set contains a sufficient number of nodes for\n    * the requested range.\n    */\n    if (contextSize < minPos) {\n\txmlXPathNodeSetClear(set, hasNsNodes);\n\treturn(0);\n    }\n    if (op->ch2 == -1) {\n\t/*\n\t* TODO: Can this ever happen?\n\t*/\n\treturn (contextSize);\n    } else {\n\txmlDocPtr oldContextDoc;\n\tint i, pos = 0, newContextSize = 0, contextPos = 0, res;\n\txmlXPathStepOpPtr exprOp;\n\txmlXPathObjectPtr contextObj = NULL, exprRes = NULL;\n\txmlNodePtr oldContextNode, contextNode = NULL;\n\txmlXPathContextPtr xpctxt = ctxt->context;\n        int frame;\n\n#ifdef LIBXML_XPTR_ENABLED\n\t    /*\n\t    * URGENT TODO: Check the following:\n\t    *  We don't expect location sets if evaluating prediates, right?\n\t    *  Only filters should expect location sets, right?\n\t*/\n#endif /* LIBXML_XPTR_ENABLED */\n\n\t/*\n\t* Save old context.\n\t*/\n\toldContextNode = xpctxt->node;\n\toldContextDoc = xpctxt->doc;\n\t/*\n\t* Get the expression of this predicate.\n\t*/\n\texprOp = &ctxt->comp->steps[op->ch2];\n\tfor (i = 0; i < set->nodeNr; i++) {\n            xmlXPathObjectPtr tmp;\n\n\t    if (set->nodeTab[i] == NULL)\n\t\tcontinue;\n\n\t    contextNode = set->nodeTab[i];\n\t    xpctxt->node = contextNode;\n\t    xpctxt->contextSize = contextSize;\n\t    xpctxt->proximityPosition = ++contextPos;\n\n\t    /*\n\t    * Initialize the new set.\n\t    * Also set the xpath document in case things like\n\t    * key() evaluation are attempted on the predicate\n\t    */\n\t    if ((contextNode->type != XML_NAMESPACE_DECL) &&\n\t\t(contextNode->doc != NULL))\n\t\txpctxt->doc = contextNode->doc;\n\t    /*\n\t    * Evaluate the predicate expression with 1 context node\n\t    * at a time; this node is packaged into a node set; this\n\t    * node set is handed over to the evaluation mechanism.\n\t    */\n\t    if (contextObj == NULL)\n\t\tcontextObj = xmlXPathCacheNewNodeSet(xpctxt, contextNode);\n\t    else {\n\t\tif (xmlXPathNodeSetAddUnique(contextObj->nodesetval,\n\t\t    contextNode) < 0) {\n\t\t    ctxt->error = XPATH_MEMORY_ERROR;\n\t\t    goto evaluation_exit;\n\t\t}\n\t    }\n\n\t    valuePush(ctxt, contextObj);\n            frame = xmlXPathSetFrame(ctxt);\n\t    res = xmlXPathCompOpEvalToBoolean(ctxt, exprOp, 1);\n            xmlXPathPopFrame(ctxt, frame);\n            tmp = valuePop(ctxt);\n\n\t    if ((ctxt->error != XPATH_EXPRESSION_OK) || (res == -1)) {\n                while (tmp != contextObj) {\n                    /*\n                     * Free up the result\n                     * then pop off contextObj, which will be freed later\n                     */\n                    xmlXPathReleaseObject(xpctxt, tmp);\n                    tmp = valuePop(ctxt);\n                }\n\t\tgoto evaluation_error;\n\t    }\n            /* push the result back onto the stack */\n            valuePush(ctxt, tmp);\n\n\t    if (res)\n\t\tpos++;\n\n\t    if (res && (pos >= minPos) && (pos <= maxPos)) {\n\t\t/*\n\t\t* Fits in the requested range.\n\t\t*/\n\t\tnewContextSize++;\n\t\tif (minPos == maxPos) {\n\t\t    /*\n\t\t    * Only 1 node was requested.\n\t\t    */\n\t\t    if (contextNode->type == XML_NAMESPACE_DECL) {\n\t\t\t/*\n\t\t\t* As always: take care of those nasty\n\t\t\t* namespace nodes.\n\t\t\t*/\n\t\t\tset->nodeTab[i] = NULL;\n\t\t    }\n\t\t    xmlXPathNodeSetClear(set, hasNsNodes);\n\t\t    set->nodeNr = 1;\n\t\t    set->nodeTab[0] = contextNode;\n\t\t    goto evaluation_exit;\n\t\t}\n\t\tif (pos == maxPos) {\n\t\t    /*\n\t\t    * We are done.\n\t\t    */\n\t\t    xmlXPathNodeSetClearFromPos(set, i +1, hasNsNodes);\n\t\t    goto evaluation_exit;\n\t\t}\n\t    } else {\n\t\t/*\n\t\t* Remove the entry from the initial node set.\n\t\t*/\n\t\tset->nodeTab[i] = NULL;\n\t\tif (contextNode->type == XML_NAMESPACE_DECL)\n\t\t    xmlXPathNodeSetFreeNs((xmlNsPtr) contextNode);\n\t    }\n\t    if (exprRes != NULL) {\n\t\txmlXPathReleaseObject(ctxt->context, exprRes);\n\t\texprRes = NULL;\n\t    }\n\t    if (ctxt->value == contextObj) {\n\t\t/*\n\t\t* Don't free the temporary XPath object holding the\n\t\t* context node, in order to avoid massive recreation\n\t\t* inside this loop.\n\t\t*/\n\t\tvaluePop(ctxt);\n\t\txmlXPathNodeSetClear(contextObj->nodesetval, hasNsNodes);\n\t    } else {\n\t\t/*\n\t\t* The object was lost in the evaluation machinery.\n\t\t* Can this happen? Maybe in case of internal-errors.\n\t\t*/\n\t\tcontextObj = NULL;\n\t    }\n\t}\n\tgoto evaluation_exit;\n\nevaluation_error:\n\txmlXPathNodeSetClear(set, hasNsNodes);\n\tnewContextSize = 0;\n\nevaluation_exit:\n\tif (contextObj != NULL) {\n\t    if (ctxt->value == contextObj)\n\t\tvaluePop(ctxt);\n\t    xmlXPathReleaseObject(xpctxt, contextObj);\n\t}\n\tif (exprRes != NULL)\n\t    xmlXPathReleaseObject(ctxt->context, exprRes);\n\t/*\n\t* Reset/invalidate the context.\n\t*/\n\txpctxt->node = oldContextNode;\n\txpctxt->doc = oldContextDoc;\n\txpctxt->contextSize = -1;\n\txpctxt->proximityPosition = -1;\n\treturn(newContextSize);\n    }",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148401,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int rtsx_usb_ms_drv_remove(struct platform_device *pdev)\n{\n\tstruct rtsx_usb_ms *host = platform_get_drvdata(pdev);\n\tstruct memstick_host *msh = host->msh;\n\tint err;\n\n\thost->eject = true;\n\tcancel_work_sync(&host->handle_req);\n\n\tmutex_lock(&host->host_mutex);\n\tif (host->req) {\n\t\tdev_dbg(ms_dev(host),\n\t\t\t\"%s: Controller removed during transfer\\n\",\n\t\t\tdev_name(&msh->dev));\n\t\thost->req->error = -ENOMEDIUM;\n\t\tdo {\n\t\t\terr = memstick_next_req(msh, &host->req);\n\t\t\tif (!err)\n\t\t\t\thost->req->error = -ENOMEDIUM;\n\t\t} while (!err);\n\t}\n\tmutex_unlock(&host->host_mutex);\n\n\tmemstick_remove_host(msh);\n\tmemstick_free_host(msh);\n\n\t/* Balance possible unbalanced usage count\n\t * e.g. unconditional module removal\n\t */\n\tif (pm_runtime_active(ms_dev(host)))\n\t\tpm_runtime_put(ms_dev(host));\n\n\tpm_runtime_disable(ms_dev(host));\n\tplatform_set_drvdata(pdev, NULL);\n\n\tdev_dbg(ms_dev(host),\n\t\t\": Realtek USB Memstick controller has been removed\\n\");\n\n\treturn 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148408,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int rtsx_usb_ms_drv_remove(struct platform_device *pdev)\n{\n\tstruct rtsx_usb_ms *host = platform_get_drvdata(pdev);\n\tstruct memstick_host *msh = host->msh;\n\tint err;\n\n\thost->eject = true;\n\tcancel_work_sync(&host->handle_req);\n\n\tmutex_lock(&host->host_mutex);\n\tif (host->req) {\n\t\tdev_dbg(ms_dev(host),\n\t\t\t\"%s: Controller removed during transfer\\n\",\n\t\t\tdev_name(&msh->dev));\n\t\thost->req->error = -ENOMEDIUM;\n\t\tdo {\n\t\t\terr = memstick_next_req(msh, &host->req);\n\t\t\tif (!err)\n\t\t\t\thost->req->error = -ENOMEDIUM;\n\t\t} while (!err);\n\t}\n\tmutex_unlock(&host->host_mutex);\n\n\t/* Balance possible unbalanced usage count\n\t * e.g. unconditional module removal\n\t */\n\tif (pm_runtime_active(ms_dev(host)))\n\t\tpm_runtime_put(ms_dev(host));\n\n\tpm_runtime_disable(ms_dev(host));\n\tmemstick_remove_host(msh);\n\tdev_dbg(ms_dev(host),\n\t\t\": Realtek USB Memstick controller has been removed\\n\");\n\tmemstick_free_host(msh);\n\tplatform_set_drvdata(pdev, NULL);\n\n\treturn 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148409,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static void gprinter_free(struct usb_function *f)\n{\n\tstruct printer_dev *dev = func_to_printer(f);\n\tstruct f_printer_opts *opts;\n\n\topts = container_of(f->fi, struct f_printer_opts, func_inst);\n\tkfree(dev);\n\tmutex_lock(&opts->lock);\n\t--opts->refcnt;\n\tmutex_unlock(&opts->lock);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148420,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static void gprinter_free(struct usb_function *f)\n{\n\tstruct printer_dev *dev = func_to_printer(f);\n\tstruct f_printer_opts *opts;\n\n\topts = container_of(f->fi, struct f_printer_opts, func_inst);\n\n\tkref_put(&dev->kref, printer_dev_free);\n\tmutex_lock(&opts->lock);\n\t--opts->refcnt;\n\tmutex_unlock(&opts->lock);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148421,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static void mcba_usb_disconnect(struct usb_interface *intf)\n{\n\tstruct mcba_priv *priv = usb_get_intfdata(intf);\n\n\tusb_set_intfdata(intf, NULL);\n\n\tnetdev_info(priv->netdev, \"device disconnected\\n\");\n\n\tunregister_candev(priv->netdev);\n\tfree_candev(priv->netdev);\n\n\tmcba_urb_unlink(priv);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148448,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static void mcba_usb_disconnect(struct usb_interface *intf)\n{\n\tstruct mcba_priv *priv = usb_get_intfdata(intf);\n\n\tusb_set_intfdata(intf, NULL);\n\n\tnetdev_info(priv->netdev, \"device disconnected\\n\");\n\n\tunregister_candev(priv->netdev);\n\tmcba_urb_unlink(priv);\n\tfree_candev(priv->netdev);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148449,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static zval *phar_rename_archive(phar_archive_data *phar, char *ext, zend_bool compress TSRMLS_DC) /* {{{ */\n{\n\tconst char *oldname = NULL;\n\tchar *oldpath = NULL;\n\tchar *basename = NULL, *basepath = NULL;\n\tchar *newname = NULL, *newpath = NULL;\n\tzval *ret, arg1;\n\tzend_class_entry *ce;\n\tchar *error;\n\tconst char *pcr_error;\n\tint ext_len = ext ? strlen(ext) : 0;\n\tint oldname_len;\n\tphar_archive_data **pphar = NULL;\n\tphp_stream_statbuf ssb;\n\n\tif (!ext) {\n\t\tif (phar->is_zip) {\n\n\t\t\tif (phar->is_data) {\n\t\t\t\text = \"zip\";\n\t\t\t} else {\n\t\t\t\text = \"phar.zip\";\n\t\t\t}\n\n\t\t} else if (phar->is_tar) {\n\n\t\t\tswitch (phar->flags) {\n\t\t\t\tcase PHAR_FILE_COMPRESSED_GZ:\n\t\t\t\t\tif (phar->is_data) {\n\t\t\t\t\t\text = \"tar.gz\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\text = \"phar.tar.gz\";\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase PHAR_FILE_COMPRESSED_BZ2:\n\t\t\t\t\tif (phar->is_data) {\n\t\t\t\t\t\text = \"tar.bz2\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\text = \"phar.tar.bz2\";\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif (phar->is_data) {\n\t\t\t\t\t\text = \"tar\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\text = \"phar.tar\";\n\t\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\n\t\t\tswitch (phar->flags) {\n\t\t\t\tcase PHAR_FILE_COMPRESSED_GZ:\n\t\t\t\t\text = \"phar.gz\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase PHAR_FILE_COMPRESSED_BZ2:\n\t\t\t\t\text = \"phar.bz2\";\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\text = \"phar\";\n\t\t\t}\n\t\t}\n\t} else if (phar_path_check(&ext, &ext_len, &pcr_error) > pcr_is_ok) {\n\n\t\tif (phar->is_data) {\n\t\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"data phar converted from \\\"%s\\\" has invalid extension %s\", phar->fname, ext);\n\t\t} else {\n\t\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"phar converted from \\\"%s\\\" has invalid extension %s\", phar->fname, ext);\n\t\t}\n\t\treturn NULL;\n\t}\n\n\tif (ext[0] == '.') {\n\t\t++ext;\n\t}\n\n\toldpath = estrndup(phar->fname, phar->fname_len);\n\toldname = zend_memrchr(phar->fname, '/', phar->fname_len);\n\t++oldname;\n\toldname_len = strlen(oldname);\n\n\tbasename = estrndup(oldname, oldname_len);\n\tspprintf(&newname, 0, \"%s.%s\", strtok(basename, \".\"), ext);\n\tefree(basename);\n\n\t\n\n\tbasepath = estrndup(oldpath, (strlen(oldpath) - oldname_len));\n\tphar->fname_len = spprintf(&newpath, 0, \"%s%s\", basepath, newname);\n\tphar->fname = newpath;\n\tphar->ext = newpath + phar->fname_len - strlen(ext) - 1;\n\tefree(basepath);\n\tefree(newname);\n\n\tif (PHAR_G(manifest_cached) && SUCCESS == zend_hash_find(&cached_phars, newpath, phar->fname_len, (void **) &pphar)) {\n\t\tefree(oldpath);\n\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"Unable to add newly converted phar \\\"%s\\\" to the list of phars, new phar name is in phar.cache_list\", phar->fname);\n\t\treturn NULL;\n\t}\n\n\tif (SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_fname_map), newpath, phar->fname_len, (void **) &pphar)) {\n\t\tif ((*pphar)->fname_len == phar->fname_len && !memcmp((*pphar)->fname, phar->fname, phar->fname_len)) {\n\t\t\tif (!zend_hash_num_elements(&phar->manifest)) {\n\t\t\t\t(*pphar)->is_tar = phar->is_tar;\n\t\t\t\t(*pphar)->is_zip = phar->is_zip;\n\t\t\t\t(*pphar)->is_data = phar->is_data;\n\t\t\t\t(*pphar)->flags = phar->flags;\n\t\t\t\t(*pphar)->fp = phar->fp;\n\t\t\t\tphar->fp = NULL;\n\t\t\t\tphar_destroy_phar_data(phar TSRMLS_CC);\n\t\t\t\tphar = *pphar;\n\t\t\t\tphar->refcount++;\n\t\t\t\tnewpath = oldpath;\n\t\t\t\tgoto its_ok;\n\t\t\t}\n\t\t}\n\n\t\tefree(oldpath);\n\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"Unable to add newly converted phar \\\"%s\\\" to the list of phars, a phar with that name already exists\", phar->fname);\n\t\treturn NULL;\n\t}\nits_ok:\n\tif (SUCCESS == php_stream_stat_path(newpath, &ssb)) {\n\t\tefree(oldpath);\n\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"phar \\\"%s\\\" exists and must be unlinked prior to conversion\", newpath);\n\t\treturn NULL;\n\t}\n\tif (!phar->is_data) {\n\t\tif (SUCCESS != phar_detect_phar_fname_ext(newpath, phar->fname_len, (const char **) &(phar->ext), &(phar->ext_len), 1, 1, 1 TSRMLS_CC)) {\n\t\t\tefree(oldpath);\n\t\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"phar \\\"%s\\\" has invalid extension %s\", phar->fname, ext);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (phar->alias) {\n\t\t\tif (phar->is_temporary_alias) {\n\t\t\t\tphar->alias = NULL;\n\t\t\t\tphar->alias_len = 0;\n\t\t\t} else {\n\t\t\t\tphar->alias = estrndup(newpath, strlen(newpath));\n\t\t\t\tphar->alias_len = strlen(newpath);\n\t\t\t\tphar->is_temporary_alias = 1;\n\t\t\t\tzend_hash_update(&(PHAR_GLOBALS->phar_alias_map), newpath, phar->fname_len, (void*)&phar, sizeof(phar_archive_data*), NULL);\n\t\t\t}\n\t\t}\n\n\t} else {\n\n\t\tif (SUCCESS != phar_detect_phar_fname_ext(newpath, phar->fname_len, (const char **) &(phar->ext), &(phar->ext_len), 0, 1, 1 TSRMLS_CC)) {\n\t\t\tefree(oldpath);\n\t\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"data phar \\\"%s\\\" has invalid extension %s\", phar->fname, ext);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tphar->alias = NULL;\n\t\tphar->alias_len = 0;\n\t}\n\n\tif ((!pphar || phar == *pphar) && SUCCESS != zend_hash_update(&(PHAR_GLOBALS->phar_fname_map), newpath, phar->fname_len, (void*)&phar, sizeof(phar_archive_data*), NULL)) {\n\t\tefree(oldpath);\n\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"Unable to add newly converted phar \\\"%s\\\" to the list of phars\", phar->fname);\n\t\treturn NULL;\n\t}\n\n\tphar_flush(phar, 0, 0, 1, &error TSRMLS_CC);\n\n\tif (error) {\n\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"%s\", error);\n\t\tefree(error);\n\t\tefree(oldpath);\n\t\treturn NULL;\n\t}\n\n\tefree(oldpath);\n\n\tif (phar->is_data) {\n\t\tce = phar_ce_data;\n\t} else {\n\t\tce = phar_ce_archive;\n\t}\n\n\tMAKE_STD_ZVAL(ret);\n\n\tif (SUCCESS != object_init_ex(ret, ce)) {\n\t\tzval_dtor(ret);\n\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"Unable to instantiate phar object when converting archive \\\"%s\\\"\", phar->fname);\n\t\treturn NULL;\n\t}\n\n\tINIT_PZVAL(&arg1);\n\tZVAL_STRINGL(&arg1, phar->fname, phar->fname_len, 0);\n\n\tzend_call_method_with_1_params(&ret, ce, &ce->constructor, \"__construct\", NULL, &arg1);\n\treturn ret;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148518,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static zval *phar_rename_archive(phar_archive_data *phar, char *ext, zend_bool compress TSRMLS_DC) /* {{{ */\n{\n\tconst char *oldname = NULL;\n\tchar *oldpath = NULL;\n\tchar *basename = NULL, *basepath = NULL;\n\tchar *newname = NULL, *newpath = NULL;\n\tzval *ret, arg1;\n\tzend_class_entry *ce;\n\tchar *error;\n\tconst char *pcr_error;\n\tint ext_len = ext ? strlen(ext) : 0;\n\tint oldname_len;\n\tphar_archive_data **pphar = NULL;\n\tphp_stream_statbuf ssb;\n\n\tif (!ext) {\n\t\tif (phar->is_zip) {\n\n\t\t\tif (phar->is_data) {\n\t\t\t\text = \"zip\";\n\t\t\t} else {\n\t\t\t\text = \"phar.zip\";\n\t\t\t}\n\n\t\t} else if (phar->is_tar) {\n\n\t\t\tswitch (phar->flags) {\n\t\t\t\tcase PHAR_FILE_COMPRESSED_GZ:\n\t\t\t\t\tif (phar->is_data) {\n\t\t\t\t\t\text = \"tar.gz\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\text = \"phar.tar.gz\";\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase PHAR_FILE_COMPRESSED_BZ2:\n\t\t\t\t\tif (phar->is_data) {\n\t\t\t\t\t\text = \"tar.bz2\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\text = \"phar.tar.bz2\";\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif (phar->is_data) {\n\t\t\t\t\t\text = \"tar\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\text = \"phar.tar\";\n\t\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\n\t\t\tswitch (phar->flags) {\n\t\t\t\tcase PHAR_FILE_COMPRESSED_GZ:\n\t\t\t\t\text = \"phar.gz\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase PHAR_FILE_COMPRESSED_BZ2:\n\t\t\t\t\text = \"phar.bz2\";\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\text = \"phar\";\n\t\t\t}\n\t\t}\n\t} else if (phar_path_check(&ext, &ext_len, &pcr_error) > pcr_is_ok) {\n\n\t\tif (phar->is_data) {\n\t\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"data phar converted from \\\"%s\\\" has invalid extension %s\", phar->fname, ext);\n\t\t} else {\n\t\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"phar converted from \\\"%s\\\" has invalid extension %s\", phar->fname, ext);\n\t\t}\n\t\treturn NULL;\n\t}\n\n\tif (ext[0] == '.') {\n\t\t++ext;\n\t}\n\n\toldpath = estrndup(phar->fname, phar->fname_len);\n\toldname = zend_memrchr(phar->fname, '/', phar->fname_len);\n\t++oldname;\n\toldname_len = strlen(oldname);\n\n\tbasename = estrndup(oldname, oldname_len);\n\tspprintf(&newname, 0, \"%s.%s\", strtok(basename, \".\"), ext);\n\tefree(basename);\n\n\t\n\n\tbasepath = estrndup(oldpath, (strlen(oldpath) - oldname_len));\n\tphar->fname_len = spprintf(&newpath, 0, \"%s%s\", basepath, newname);\n\tphar->fname = newpath;\n\tphar->ext = newpath + phar->fname_len - strlen(ext) - 1;\n\tefree(basepath);\n\tefree(newname);\n\n\tif (PHAR_G(manifest_cached) && SUCCESS == zend_hash_find(&cached_phars, newpath, phar->fname_len, (void **) &pphar)) {\n\t\tefree(oldpath);\n\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"Unable to add newly converted phar \\\"%s\\\" to the list of phars, new phar name is in phar.cache_list\", phar->fname);\n\t\treturn NULL;\n\t}\n\n\tif (SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_fname_map), newpath, phar->fname_len, (void **) &pphar)) {\n\t\tif ((*pphar)->fname_len == phar->fname_len && !memcmp((*pphar)->fname, phar->fname, phar->fname_len)) {\n\t\t\tif (!zend_hash_num_elements(&phar->manifest)) {\n\t\t\t\t(*pphar)->is_tar = phar->is_tar;\n\t\t\t\t(*pphar)->is_zip = phar->is_zip;\n\t\t\t\t(*pphar)->is_data = phar->is_data;\n\t\t\t\t(*pphar)->flags = phar->flags;\n\t\t\t\t(*pphar)->fp = phar->fp;\n\t\t\t\tphar->fp = NULL;\n\t\t\t\tphar_destroy_phar_data(phar TSRMLS_CC);\n\t\t\t\tphar = *pphar;\n\t\t\t\tphar->refcount++;\n\t\t\t\tnewpath = oldpath;\n\t\t\t\tgoto its_ok;\n\t\t\t}\n\t\t}\n\n\t\tefree(oldpath);\n\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"Unable to add newly converted phar \\\"%s\\\" to the list of phars, a phar with that name already exists\", phar->fname);\n\t\treturn NULL;\n\t}\nits_ok:\n\tif (SUCCESS == php_stream_stat_path(newpath, &ssb)) {\n\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"phar \\\"%s\\\" exists and must be unlinked prior to conversion\", newpath);\n\t\tefree(oldpath);\n\t\treturn NULL;\n\t}\n\tif (!phar->is_data) {\n\t\tif (SUCCESS != phar_detect_phar_fname_ext(newpath, phar->fname_len, (const char **) &(phar->ext), &(phar->ext_len), 1, 1, 1 TSRMLS_CC)) {\n\t\t\tefree(oldpath);\n\t\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"phar \\\"%s\\\" has invalid extension %s\", phar->fname, ext);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (phar->alias) {\n\t\t\tif (phar->is_temporary_alias) {\n\t\t\t\tphar->alias = NULL;\n\t\t\t\tphar->alias_len = 0;\n\t\t\t} else {\n\t\t\t\tphar->alias = estrndup(newpath, strlen(newpath));\n\t\t\t\tphar->alias_len = strlen(newpath);\n\t\t\t\tphar->is_temporary_alias = 1;\n\t\t\t\tzend_hash_update(&(PHAR_GLOBALS->phar_alias_map), newpath, phar->fname_len, (void*)&phar, sizeof(phar_archive_data*), NULL);\n\t\t\t}\n\t\t}\n\n\t} else {\n\n\t\tif (SUCCESS != phar_detect_phar_fname_ext(newpath, phar->fname_len, (const char **) &(phar->ext), &(phar->ext_len), 0, 1, 1 TSRMLS_CC)) {\n\t\t\tefree(oldpath);\n\t\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"data phar \\\"%s\\\" has invalid extension %s\", phar->fname, ext);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tphar->alias = NULL;\n\t\tphar->alias_len = 0;\n\t}\n\n\tif ((!pphar || phar == *pphar) && SUCCESS != zend_hash_update(&(PHAR_GLOBALS->phar_fname_map), newpath, phar->fname_len, (void*)&phar, sizeof(phar_archive_data*), NULL)) {\n\t\tefree(oldpath);\n\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"Unable to add newly converted phar \\\"%s\\\" to the list of phars\", phar->fname);\n\t\treturn NULL;\n\t}\n\n\tphar_flush(phar, 0, 0, 1, &error TSRMLS_CC);\n\n\tif (error) {\n\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"%s\", error);\n\t\tefree(error);\n\t\tefree(oldpath);\n\t\treturn NULL;\n\t}\n\n\tefree(oldpath);\n\n\tif (phar->is_data) {\n\t\tce = phar_ce_data;\n\t} else {\n\t\tce = phar_ce_archive;\n\t}\n\n\tMAKE_STD_ZVAL(ret);\n\n\tif (SUCCESS != object_init_ex(ret, ce)) {\n\t\tzval_dtor(ret);\n\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"Unable to instantiate phar object when converting archive \\\"%s\\\"\", phar->fname);\n\t\treturn NULL;\n\t}\n\n\tINIT_PZVAL(&arg1);\n\tZVAL_STRINGL(&arg1, phar->fname, phar->fname_len, 0);\n\n\tzend_call_method_with_1_params(&ret, ce, &ce->constructor, \"__construct\", NULL, &arg1);\n\treturn ret;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148519,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static void cil_reset_classperms_set(struct cil_classperms_set *cp_set)\n{\n\tcil_reset_classpermission(cp_set->set);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148524,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static void cil_reset_classpermissionset(struct cil_classpermissionset *cps)\n{\n\tcil_reset_classperms_list(cps->classperms);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148525,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "bool SFD_GetFontMetaData( FILE *sfd,\n\t\t\t  char *tok,\n\t\t\t  SplineFont *sf,\n\t\t\t  SFD_GetFontMetaDataData* d )\n{\n    int ch;\n    int i;\n    KernClass* kc = 0;\n    int old;\n    char val[2000];\n\n    // This allows us to assume we can dereference d\n    // at all times\n    static SFD_GetFontMetaDataData my_static_d;\n    static int my_static_d_is_virgin = 1;\n    if( !d )\n    {\n\tif( my_static_d_is_virgin )\n\t{\n\t    my_static_d_is_virgin = 0;\n\t    SFD_GetFontMetaDataData_Init( &my_static_d );\n\t}\n\td = &my_static_d;\n    }\n\n    if ( strmatch(tok,\"FontName:\")==0 )\n    {\n\tgeteol(sfd,val);\n\tsf->fontname = copy(val);\n    }\n    else if ( strmatch(tok,\"FullName:\")==0 )\n    {\n\tgeteol(sfd,val);\n\tsf->fullname = copy(val);\n    }\n    else if ( strmatch(tok,\"FamilyName:\")==0 )\n    {\n\tgeteol(sfd,val);\n\tsf->familyname = copy(val);\n    }\n    else if ( strmatch(tok,\"DefaultBaseFilename:\")==0 )\n    {\n\tgeteol(sfd,val);\n\tsf->defbasefilename = copy(val);\n    }\n    else if ( strmatch(tok,\"Weight:\")==0 )\n    {\n\tgetprotectedname(sfd,val);\n\tsf->weight = copy(val);\n    }\n    else if ( strmatch(tok,\"Copyright:\")==0 )\n    {\n\tsf->copyright = getquotedeol(sfd);\n    }\n    else if ( strmatch(tok,\"Comments:\")==0 )\n    {\n\tchar *temp = getquotedeol(sfd);\n\tsf->comments = latin1_2_utf8_copy(temp);\n\tfree(temp);\n    }\n    else if ( strmatch(tok,\"UComments:\")==0 )\n    {\n\tsf->comments = SFDReadUTF7Str(sfd);\n    }\n    else if ( strmatch(tok,\"FontLog:\")==0 )\n    {\n\tsf->fontlog = SFDReadUTF7Str(sfd);\n    }\n    else if ( strmatch(tok,\"Version:\")==0 )\n    {\n\tgeteol(sfd,val);\n\tsf->version = copy(val);\n    }\n    else if ( strmatch(tok,\"StyleMapFamilyName:\")==0 )\n    {\n    sf->styleMapFamilyName = SFDReadUTF7Str(sfd);\n    }\n    /* Legacy attribute for StyleMapFamilyName. Deprecated. */\n    else if ( strmatch(tok,\"OS2FamilyName:\")==0 )\n    {\n    if (sf->styleMapFamilyName == NULL)\n        sf->styleMapFamilyName = SFDReadUTF7Str(sfd);\n    }\n    else if ( strmatch(tok,\"FONDName:\")==0 )\n    {\n\tgeteol(sfd,val);\n\tsf->fondname = copy(val);\n    }\n    else if ( strmatch(tok,\"ItalicAngle:\")==0 )\n    {\n\tgetreal(sfd,&sf->italicangle);\n    }\n    else if ( strmatch(tok,\"StrokeWidth:\")==0 )\n    {\n\tgetreal(sfd,&sf->strokewidth);\n    }\n    else if ( strmatch(tok,\"UnderlinePosition:\")==0 )\n    {\n\tgetreal(sfd,&sf->upos);\n    }\n    else if ( strmatch(tok,\"UnderlineWidth:\")==0 )\n    {\n\tgetreal(sfd,&sf->uwidth);\n    }\n    else if ( strmatch(tok,\"ModificationTime:\")==0 )\n    {\n\tgetlonglong(sfd,&sf->modificationtime);\n    }\n    else if ( strmatch(tok,\"CreationTime:\")==0 )\n    {\n\tgetlonglong(sfd,&sf->creationtime);\n\td->hadtimes = true;\n    }\n    else if ( strmatch(tok,\"PfmFamily:\")==0 )\n    {\n\tint temp;\n\tgetint(sfd,&temp);\n\tsf->pfminfo.pfmfamily = temp;\n\tsf->pfminfo.pfmset = true;\n    }\n    else if ( strmatch(tok,\"LangName:\")==0 )\n    {\n\tsf->names = SFDGetLangName(sfd,sf->names);\n    }\n    else if ( strmatch(tok,\"GaspTable:\")==0 )\n    {\n\tSFDGetGasp(sfd,sf);\n    }\n    else if ( strmatch(tok,\"DesignSize:\")==0 )\n    {\n\tSFDGetDesignSize(sfd,sf);\n    }\n    else if ( strmatch(tok,\"OtfFeatName:\")==0 )\n    {\n\tSFDGetOtfFeatName(sfd,sf);\n    }\n    else if ( strmatch(tok,\"PfmWeight:\")==0 || strmatch(tok,\"TTFWeight:\")==0 )\n    {\n\tgetsint(sfd,&sf->pfminfo.weight);\n\tsf->pfminfo.pfmset = true;\n    }\n    else if ( strmatch(tok,\"TTFWidth:\")==0 )\n    {\n\tgetsint(sfd,&sf->pfminfo.width);\n\tsf->pfminfo.pfmset = true;\n    }\n    else if ( strmatch(tok,\"Panose:\")==0 )\n    {\n\tint temp,i;\n\tfor ( i=0; i<10; ++i )\n\t{\n\t    getint(sfd,&temp);\n\t    sf->pfminfo.panose[i] = temp;\n\t}\n\tsf->pfminfo.panose_set = true;\n    }\n    else if ( strmatch(tok,\"LineGap:\")==0 )\n    {\n\tgetsint(sfd,&sf->pfminfo.linegap);\n\tsf->pfminfo.pfmset = true;\n    }\n    else if ( strmatch(tok,\"VLineGap:\")==0 )\n    {\n\tgetsint(sfd,&sf->pfminfo.vlinegap);\n\tsf->pfminfo.pfmset = true;\n    }\n    else if ( strmatch(tok,\"HheadAscent:\")==0 )\n    {\n\tgetsint(sfd,&sf->pfminfo.hhead_ascent);\n    }\n    else if ( strmatch(tok,\"HheadAOffset:\")==0 )\n    {\n\tint temp;\n\tgetint(sfd,&temp); sf->pfminfo.hheadascent_add = temp;\n    }\n    else if ( strmatch(tok,\"HheadDescent:\")==0 )\n    {\n\tgetsint(sfd,&sf->pfminfo.hhead_descent);\n    }\n    else if ( strmatch(tok,\"HheadDOffset:\")==0 )\n    {\n\tint temp;\n\tgetint(sfd,&temp); sf->pfminfo.hheaddescent_add = temp;\n    }\n    else if ( strmatch(tok,\"OS2TypoLinegap:\")==0 )\n    {\n\tgetsint(sfd,&sf->pfminfo.os2_typolinegap);\n    }\n    else if ( strmatch(tok,\"OS2TypoAscent:\")==0 )\n    {\n\tgetsint(sfd,&sf->pfminfo.os2_typoascent);\n    }\n    else if ( strmatch(tok,\"OS2TypoAOffset:\")==0 )\n    {\n\tint temp;\n\tgetint(sfd,&temp); sf->pfminfo.typoascent_add = temp;\n    }\n    else if ( strmatch(tok,\"OS2TypoDescent:\")==0 )\n    {\n\tgetsint(sfd,&sf->pfminfo.os2_typodescent);\n    }\n    else if ( strmatch(tok,\"OS2TypoDOffset:\")==0 )\n    {\n\tint temp;\n\tgetint(sfd,&temp); sf->pfminfo.typodescent_add = temp;\n    }\n    else if ( strmatch(tok,\"OS2WinAscent:\")==0 )\n    {\n\tgetsint(sfd,&sf->pfminfo.os2_winascent);\n    }\n    else if ( strmatch(tok,\"OS2WinDescent:\")==0 )\n    {\n\tgetsint(sfd,&sf->pfminfo.os2_windescent);\n    }\n    else if ( strmatch(tok,\"OS2WinAOffset:\")==0 )\n    {\n\tint temp;\n\tgetint(sfd,&temp); sf->pfminfo.winascent_add = temp;\n    }\n    else if ( strmatch(tok,\"OS2WinDOffset:\")==0 )\n    {\n\tint temp;\n\tgetint(sfd,&temp); sf->pfminfo.windescent_add = temp;\n    }\n    else if ( strmatch(tok,\"HHeadAscent:\")==0 )\n    {\n\t// DUPLICATE OF ABOVE\n\tgetsint(sfd,&sf->pfminfo.hhead_ascent);\n    }\n    else if ( strmatch(tok,\"HHeadDescent:\")==0 )\n    {\n\t// DUPLICATE OF ABOVE\n\tgetsint(sfd,&sf->pfminfo.hhead_descent);\n    }\n\n    else if ( strmatch(tok,\"HHeadAOffset:\")==0 )\n    {\n\t// DUPLICATE OF ABOVE\n\tint temp;\n\tgetint(sfd,&temp); sf->pfminfo.hheadascent_add = temp;\n    }\n    else if ( strmatch(tok,\"HHeadDOffset:\")==0 )\n    {\n\t// DUPLICATE OF ABOVE\n\tint temp;\n\tgetint(sfd,&temp); sf->pfminfo.hheaddescent_add = temp;\n    }\n    else if ( strmatch(tok,\"MacStyle:\")==0 )\n    {\n\tgetsint(sfd,&sf->macstyle);\n    }\n    else if ( strmatch(tok,\"OS2SubXSize:\")==0 )\n    {\n\tgetsint(sfd,&sf->pfminfo.os2_subxsize);\n\tsf->pfminfo.subsuper_set = true;\n    }\n    else if ( strmatch(tok,\"OS2SubYSize:\")==0 )\n    {\n\tgetsint(sfd,&sf->pfminfo.os2_subysize);\n    }\n    else if ( strmatch(tok,\"OS2SubXOff:\")==0 )\n    {\n\tgetsint(sfd,&sf->pfminfo.os2_subxoff);\n    }\n    else if ( strmatch(tok,\"OS2SubYOff:\")==0 )\n    {\n\tgetsint(sfd,&sf->pfminfo.os2_subyoff);\n    }\n    else if ( strmatch(tok,\"OS2SupXSize:\")==0 )\n    {\n\tgetsint(sfd,&sf->pfminfo.os2_supxsize);\n    }\n    else if ( strmatch(tok,\"OS2SupYSize:\")==0 )\n    {\n\tgetsint(sfd,&sf->pfminfo.os2_supysize);\n    }\n    else if ( strmatch(tok,\"OS2SupXOff:\")==0 )\n    {\n\tgetsint(sfd,&sf->pfminfo.os2_supxoff);\n    }\n    else if ( strmatch(tok,\"OS2SupYOff:\")==0 )\n    {\n\tgetsint(sfd,&sf->pfminfo.os2_supyoff);\n    }\n    else if ( strmatch(tok,\"OS2StrikeYSize:\")==0 )\n    {\n\tgetsint(sfd,&sf->pfminfo.os2_strikeysize);\n    }\n    else if ( strmatch(tok,\"OS2StrikeYPos:\")==0 )\n    {\n\tgetsint(sfd,&sf->pfminfo.os2_strikeypos);\n    }\n    else if ( strmatch(tok,\"OS2CapHeight:\")==0 )\n    {\n\tgetsint(sfd,&sf->pfminfo.os2_capheight);\n    }\n    else if ( strmatch(tok,\"OS2XHeight:\")==0 )\n    {\n\tgetsint(sfd,&sf->pfminfo.os2_xheight);\n    }\n    else if ( strmatch(tok,\"OS2FamilyClass:\")==0 )\n    {\n\tgetsint(sfd,&sf->pfminfo.os2_family_class);\n    }\n    else if ( strmatch(tok,\"OS2Vendor:\")==0 )\n    {\n\twhile ( isspace(nlgetc(sfd)));\n\tsf->pfminfo.os2_vendor[0] = nlgetc(sfd);\n\tsf->pfminfo.os2_vendor[1] = nlgetc(sfd);\n\tsf->pfminfo.os2_vendor[2] = nlgetc(sfd);\n\tsf->pfminfo.os2_vendor[3] = nlgetc(sfd);\n\t(void) nlgetc(sfd);\n    }\n    else if ( strmatch(tok,\"OS2CodePages:\")==0 )\n    {\n\tgethexints(sfd,sf->pfminfo.codepages,2);\n\tsf->pfminfo.hascodepages = true;\n    }\n    else if ( strmatch(tok,\"OS2UnicodeRanges:\")==0 )\n    {\n\tgethexints(sfd,sf->pfminfo.unicoderanges,4);\n\tsf->pfminfo.hasunicoderanges = true;\n    }\n    else if ( strmatch(tok,\"TopEncoding:\")==0 )\n    {\n\t/* Obsolete */\n\tgetint(sfd,&sf->top_enc);\n    }\n    else if ( strmatch(tok,\"Ascent:\")==0 )\n    {\n\tgetint(sfd,&sf->ascent);\n    }\n    else if ( strmatch(tok,\"Descent:\")==0 )\n    {\n\tgetint(sfd,&sf->descent);\n    }\n    else if ( strmatch(tok,\"InvalidEm:\")==0 )\n    {\n\tgetint(sfd,&sf->invalidem);\n    }\n    else if ( strmatch(tok,\"woffMajor:\")==0 )\n    {\n\tgetint(sfd,&sf->woffMajor);\n    }\n    else if ( strmatch(tok,\"woffMinor:\")==0 )\n    {\n\tgetint(sfd,&sf->woffMinor);\n    }\n    else if ( strmatch(tok,\"woffMetadata:\")==0 )\n    {\n\tsf->woffMetadata = SFDReadUTF7Str(sfd);\n    }\n    else if ( strmatch(tok,\"UFOAscent:\")==0 )\n    {\n\t    getreal(sfd,&sf->ufo_ascent);\n    }\n    else if ( strmatch(tok,\"UFODescent:\")==0 )\n    {\n\tgetreal(sfd,&sf->ufo_descent);\n    }\n    else if ( strmatch(tok,\"sfntRevision:\")==0 )\n    {\n\tgethex(sfd,(uint32 *)&sf->sfntRevision);\n    }\n    else if ( strmatch(tok,\"LayerCount:\")==0 )\n    {\n\td->had_layer_cnt = true;\n\tgetint(sfd,&sf->layer_cnt);\n\tif ( sf->layer_cnt>2 ) {\n\t    sf->layers = realloc(sf->layers,sf->layer_cnt*sizeof(LayerInfo));\n\t    memset(sf->layers+2,0,(sf->layer_cnt-2)*sizeof(LayerInfo));\n\t}\n    }\n    else if ( strmatch(tok,\"Layer:\")==0 )\n    {\n        // TODO: Read the U. F. O. path.\n\tint layer, o2, bk;\n\tgetint(sfd,&layer);\n\tif ( layer>=sf->layer_cnt ) {\n\t    sf->layers = realloc(sf->layers,(layer+1)*sizeof(LayerInfo));\n\t    memset(sf->layers+sf->layer_cnt,0,((layer+1)-sf->layer_cnt)*sizeof(LayerInfo));\n\t    sf->layer_cnt = layer+1;\n\t}\n\tgetint(sfd,&o2);\n\tsf->layers[layer].order2 = o2;\n\tsf->layers[layer].background = layer==ly_back;\n\t/* Used briefly, now background is after layer name */\n\twhile ( (ch=nlgetc(sfd))==' ' );\n\tungetc(ch,sfd);\n\tif ( ch!='\"' ) {\n\t    getint(sfd,&bk);\n\t    sf->layers[layer].background = bk;\n\t}\n\t/* end of section for obsolete format */\n\tsf->layers[layer].name = SFDReadUTF7Str(sfd);\n\twhile ( (ch=nlgetc(sfd))==' ' );\n\tungetc(ch,sfd);\n\tif ( ch!='\\n' ) {\n\t    getint(sfd,&bk);\n\t    sf->layers[layer].background = bk;\n\t}\n\twhile ( (ch=nlgetc(sfd))==' ' );\n\tungetc(ch,sfd);\n\tif ( ch!='\\n' ) { sf->layers[layer].ufo_path = SFDReadUTF7Str(sfd); }\n    }\n    else if ( strmatch(tok,\"PreferredKerning:\")==0 )\n    {\n\tint temp;\n\tgetint(sfd,&temp);\n\tsf->preferred_kerning = temp;\n    }\n    else if ( strmatch(tok,\"StrokedFont:\")==0 )\n    {\n\tint temp;\n\tgetint(sfd,&temp);\n\tsf->strokedfont = temp;\n    }\n    else if ( strmatch(tok,\"MultiLayer:\")==0 )\n    {\n\tint temp;\n\tgetint(sfd,&temp);\n\tsf->multilayer = temp;\n    }\n    else if ( strmatch(tok,\"NeedsXUIDChange:\")==0 )\n    {\n\tint temp;\n\tgetint(sfd,&temp);\n\tsf->changed_since_xuidchanged = temp;\n    }\n    else if ( strmatch(tok,\"VerticalOrigin:\")==0 )\n    {\n\t// this doesn't seem to be written ever.\n\tint temp;\n\tgetint(sfd,&temp);\n\tsf->hasvmetrics = true;\n    }\n    else if ( strmatch(tok,\"HasVMetrics:\")==0 )\n    {\n\tint temp;\n\tgetint(sfd,&temp);\n\tsf->hasvmetrics = temp;\n    }\n    else if ( strmatch(tok,\"Justify:\")==0 )\n    {\n\tSFDParseJustify(sfd,sf,tok);\n    }\n    else if ( strmatch(tok,\"BaseHoriz:\")==0 )\n    {\n\tsf->horiz_base = SFDParseBase(sfd);\n\td->last_base = sf->horiz_base;\n\td->last_base_script = NULL;\n    }\n    else if ( strmatch(tok,\"BaseVert:\")==0 )\n    {\n\tsf->vert_base = SFDParseBase(sfd);\n\td->last_base = sf->vert_base;\n\td->last_base_script = NULL;\n    }\n    else if ( strmatch(tok,\"BaseScript:\")==0 )\n    {\n\tstruct basescript *bs = SFDParseBaseScript(sfd,d->last_base);\n\tif ( d->last_base==NULL )\n\t{\n\t    BaseScriptFree(bs);\n\t    bs = NULL;\n\t}\n\telse if ( d->last_base_script!=NULL )\n\t    d->last_base_script->next = bs;\n\telse\n\t    d->last_base->scripts = bs;\n\td->last_base_script = bs;\n    }\n    else if ( strmatch(tok,\"StyleMap:\")==0 )\n    {\n    gethex(sfd,(uint32 *)&sf->pfminfo.stylemap);\n    }\n    /* Legacy attribute for StyleMap. Deprecated. */\n    else if ( strmatch(tok,\"OS2StyleName:\")==0 )\n    {\n    char* sname = SFDReadUTF7Str(sfd);\n    if (sf->pfminfo.stylemap == -1) {\n        if (strcmp(sname,\"bold italic\")==0) sf->pfminfo.stylemap = 0x21;\n        else if (strcmp(sname,\"bold\")==0) sf->pfminfo.stylemap = 0x20;\n        else if (strcmp(sname,\"italic\")==0) sf->pfminfo.stylemap = 0x01;\n        else if (strcmp(sname,\"regular\")==0) sf->pfminfo.stylemap = 0x40;\n    }\n    free(sname);\n    }\n    else if ( strmatch(tok,\"FSType:\")==0 )\n    {\n\tgetsint(sfd,&sf->pfminfo.fstype);\n    }\n    else if ( strmatch(tok,\"OS2Version:\")==0 )\n    {\n\tgetsint(sfd,&sf->os2_version);\n    }\n    else if ( strmatch(tok,\"OS2_WeightWidthSlopeOnly:\")==0 )\n    {\n\tint temp;\n\tgetint(sfd,&temp);\n\tsf->weight_width_slope_only = temp;\n    }\n    else if ( strmatch(tok,\"OS2_UseTypoMetrics:\")==0 )\n    {\n\tint temp;\n\tgetint(sfd,&temp);\n\tsf->use_typo_metrics = temp;\n    }\n    else if ( strmatch(tok,\"UseUniqueID:\")==0 )\n    {\n\tint temp;\n\tgetint(sfd,&temp);\n\tsf->use_uniqueid = temp;\n    }\n    else if ( strmatch(tok,\"UseXUID:\")==0 )\n    {\n\tint temp;\n\tgetint(sfd,&temp);\n\tsf->use_xuid = temp;\n    }\n    else if ( strmatch(tok,\"UniqueID:\")==0 )\n    {\n\tgetint(sfd,&sf->uniqueid);\n    }\n    else if ( strmatch(tok,\"XUID:\")==0 )\n    {\n\tgeteol(sfd,tok);\n\tsf->xuid = copy(tok);\n    }\n    else if ( strmatch(tok,\"Lookup:\")==0 )\n    {\n\tOTLookup *otl;\n\tint temp;\n\tif ( sf->sfd_version<2 ) {\n\t    IError( \"Lookups should not happen in version 1 sfd files.\" );\n\t    exit(1);\n\t}\n\totl = chunkalloc(sizeof(OTLookup));\n\tgetint(sfd,&temp); otl->lookup_type = temp;\n\tgetint(sfd,&temp); otl->lookup_flags = temp;\n\tgetint(sfd,&temp); otl->store_in_afm = temp;\n\totl->lookup_name = SFDReadUTF7Str(sfd);\n\tif ( otl->lookup_type<gpos_single ) {\n\t    if ( d->lastsotl==NULL )\n\t\tsf->gsub_lookups = otl;\n\t    else\n\t\td->lastsotl->next = otl;\n\t    d->lastsotl = otl;\n\t} else {\n\t    if ( d->lastpotl==NULL )\n\t\tsf->gpos_lookups = otl;\n\t    else\n\t\td->lastpotl->next = otl;\n\t    d->lastpotl = otl;\n\t}\n\tSFDParseLookup(sfd,otl);\n    }\n    else if ( strmatch(tok,\"MarkAttachClasses:\")==0 )\n    {\n\tgetint(sfd,&sf->mark_class_cnt);\n\tsf->mark_classes = malloc(sf->mark_class_cnt*sizeof(char *));\n\tsf->mark_class_names = malloc(sf->mark_class_cnt*sizeof(char *));\n\tsf->mark_classes[0] = NULL; sf->mark_class_names[0] = NULL;\n\tfor ( i=1; i<sf->mark_class_cnt; ++i )\n\t{\n\t    /* Class 0 is unused */\n\t    int temp;\n\t    while ( (temp=nlgetc(sfd))=='\\n' || temp=='\\r' ); ungetc(temp,sfd);\n\t    sf->mark_class_names[i] = SFDReadUTF7Str(sfd);\n\t    getint(sfd,&temp);\n\t    sf->mark_classes[i] = malloc(temp+1); sf->mark_classes[i][temp] = '\\0';\n\t    nlgetc(sfd);\t/* skip space */\n\t    fread(sf->mark_classes[i],1,temp,sfd);\n\t}\n    }\n    else if ( strmatch(tok,\"MarkAttachSets:\")==0 )\n    {\n\tgetint(sfd,&sf->mark_set_cnt);\n\tsf->mark_sets = malloc(sf->mark_set_cnt*sizeof(char *));\n\tsf->mark_set_names = malloc(sf->mark_set_cnt*sizeof(char *));\n\tfor ( i=0; i<sf->mark_set_cnt; ++i )\n\t{\n\t    /* Set 0 is used */\n\t    int temp;\n\t    while ( (temp=nlgetc(sfd))=='\\n' || temp=='\\r' ); ungetc(temp,sfd);\n\t    sf->mark_set_names[i] = SFDReadUTF7Str(sfd);\n\t    getint(sfd,&temp);\n\t    sf->mark_sets[i] = malloc(temp+1); sf->mark_sets[i][temp] = '\\0';\n\t    nlgetc(sfd);\t/* skip space */\n\t    fread(sf->mark_sets[i],1,temp,sfd);\n\t}\n    }\n    else if ( strmatch(tok,\"KernClass2:\")==0 || strmatch(tok,\"VKernClass2:\")==0 ||\n\t      strmatch(tok,\"KernClass:\")==0 || strmatch(tok,\"VKernClass:\")==0 ||\n\t      strmatch(tok,\"KernClass3:\")==0 || strmatch(tok,\"VKernClass3:\")==0 )\n    {\n\tint kernclassversion = 0;\n\tint isv = tok[0]=='V';\n\tint kcvoffset = (isv ? 10 : 9); //Offset to read kerning class version\n\tif (isdigit(tok[kcvoffset])) kernclassversion = tok[kcvoffset] - '0';\n\tint temp, classstart=1;\n\tint old = (kernclassversion == 0);\n\n\tif ( (sf->sfd_version<2)!=old ) {\n\t    IError( \"Version mixup in Kerning Classes of sfd file.\" );\n\t    exit(1);\n\t}\n\tkc = chunkalloc(old ? sizeof(KernClass1) : sizeof(KernClass));\n\tgetint(sfd,&kc->first_cnt);\n\tch=nlgetc(sfd);\n\tif ( ch=='+' )\n\t    classstart = 0;\n\telse\n\t    ungetc(ch,sfd);\n\tgetint(sfd,&kc->second_cnt);\n\tif ( old ) {\n\t    getint(sfd,&temp); ((KernClass1 *) kc)->sli = temp;\n\t    getint(sfd,&temp); ((KernClass1 *) kc)->flags = temp;\n\t} else {\n\t    kc->subtable = SFFindLookupSubtableAndFreeName(sf,SFDReadUTF7Str(sfd));\n\t    if ( kc->subtable!=NULL && kc->subtable->kc==NULL )\n\t\tkc->subtable->kc = kc;\n\t    else {\n\t\tif ( kc->subtable==NULL )\n\t\t    LogError(_(\"Bad SFD file, missing subtable in kernclass defn.\\n\") );\n\t\telse\n\t\t    LogError(_(\"Bad SFD file, two kerning classes assigned to the same subtable: %s\\n\"), kc->subtable->subtable_name );\n\t\tkc->subtable = NULL;\n\t    }\n\t}\n\tkc->firsts = calloc(kc->first_cnt,sizeof(char *));\n\tkc->seconds = calloc(kc->second_cnt,sizeof(char *));\n\tkc->offsets = calloc(kc->first_cnt*kc->second_cnt,sizeof(int16));\n\tkc->adjusts = calloc(kc->first_cnt*kc->second_cnt,sizeof(DeviceTable));\n\tif (kernclassversion >= 3) {\n\t  kc->firsts_flags = calloc(kc->first_cnt, sizeof(int));\n\t  kc->seconds_flags = calloc(kc->second_cnt, sizeof(int));\n\t  kc->offsets_flags = calloc(kc->first_cnt*kc->second_cnt, sizeof(int));\n\t  kc->firsts_names = calloc(kc->first_cnt, sizeof(char*));\n\t  kc->seconds_names = calloc(kc->second_cnt, sizeof(char*));\n\t}\n\tkc->firsts[0] = NULL;\n\tfor ( i=classstart; i<kc->first_cnt; ++i ) {\n\t  if (kernclassversion < 3) {\n\t    getint(sfd,&temp);\n\t    kc->firsts[i] = malloc(temp+1); kc->firsts[i][temp] = '\\0';\n\t    nlgetc(sfd);\t/* skip space */\n\t    fread(kc->firsts[i],1,temp,sfd);\n\t  } else {\n\t    getint(sfd,&kc->firsts_flags[i]);\n\t    while ((ch=nlgetc(sfd)) == ' '); ungetc(ch, sfd); if (ch == '\\n' || ch == EOF) continue;\n\t    kc->firsts_names[i] = SFDReadUTF7Str(sfd);\n\t    while ((ch=nlgetc(sfd)) == ' '); ungetc(ch, sfd); if (ch == '\\n' || ch == EOF) continue;\n\t    kc->firsts[i] = SFDReadUTF7Str(sfd);\n            if (kc->firsts[i] == NULL) kc->firsts[i] = copy(\"\"); // In certain places, this must be defined.\n\t    while ((ch=nlgetc(sfd)) == ' ' || ch == '\\n'); ungetc(ch, sfd);\n\t  }\n\t}\n\tkc->seconds[0] = NULL;\n\tfor ( i=1; i<kc->second_cnt; ++i ) {\n\t  if (kernclassversion < 3) {\n\t    getint(sfd,&temp);\n\t    kc->seconds[i] = malloc(temp+1); kc->seconds[i][temp] = '\\0';\n\t    nlgetc(sfd);\t/* skip space */\n\t    fread(kc->seconds[i],1,temp,sfd);\n\t  } else {\n\t    getint(sfd,&temp);\n\t    kc->seconds_flags[i] = temp;\n\t    while ((ch=nlgetc(sfd)) == ' '); ungetc(ch, sfd); if (ch == '\\n' || ch == EOF) continue;\n\t    kc->seconds_names[i] = SFDReadUTF7Str(sfd);\n\t    while ((ch=nlgetc(sfd)) == ' '); ungetc(ch, sfd); if (ch == '\\n' || ch == EOF) continue;\n\t    kc->seconds[i] = SFDReadUTF7Str(sfd);\n            if (kc->seconds[i] == NULL) kc->seconds[i] = copy(\"\"); // In certain places, this must be defined.\n\t    while ((ch=nlgetc(sfd)) == ' ' || ch == '\\n'); ungetc(ch, sfd);\n\t  }\n\t}\n\tfor ( i=0; i<kc->first_cnt*kc->second_cnt; ++i ) {\n\t  if (kernclassversion >= 3) {\n\t    getint(sfd,&temp);\n\t    kc->offsets_flags[i] = temp;\n\t  }\n\t    getint(sfd,&temp);\n\t    kc->offsets[i] = temp;\n\t    SFDReadDeviceTable(sfd,&kc->adjusts[i]);\n\t}\n\tif ( !old && kc->subtable == NULL ) {\n\t    /* Error. Ignore it. Free it. Whatever */;\n\t} else if ( !isv ) {\n\t    if ( d->lastkc==NULL )\n\t\tsf->kerns = kc;\n\t    else\n\t\td->lastkc->next = kc;\n\t    d->lastkc = kc;\n\t} else {\n\t    if ( d->lastvkc==NULL )\n\t\tsf->vkerns = kc;\n\t    else\n\t\td->lastvkc->next = kc;\n\t    d->lastvkc = kc;\n\t}\n    }\n    else if ( strmatch(tok,\"ContextPos2:\")==0 || strmatch(tok,\"ContextSub2:\")==0 ||\n\t      strmatch(tok,\"ChainPos2:\")==0 || strmatch(tok,\"ChainSub2:\")==0 ||\n\t      strmatch(tok,\"ReverseChain2:\")==0 ||\n\t      strmatch(tok,\"ContextPos:\")==0 || strmatch(tok,\"ContextSub:\")==0 ||\n\t      strmatch(tok,\"ChainPos:\")==0 || strmatch(tok,\"ChainSub:\")==0 ||\n\t      strmatch(tok,\"ReverseChain:\")==0 )\n    {\n\tFPST *fpst;\n\tint old;\n\tif ( strchr(tok,'2')!=NULL ) {\n\t    old = false;\n\t    fpst = chunkalloc(sizeof(FPST));\n\t} else {\n\t    old = true;\n\t    fpst = chunkalloc(sizeof(FPST1));\n\t}\n\tif ( (sf->sfd_version<2)!=old ) {\n\t    IError( \"Version mixup in FPST of sfd file.\" );\n\t    exit(1);\n\t}\n\tif ( d->lastfp==NULL )\n\t    sf->possub = fpst;\n\telse\n\t    d->lastfp->next = fpst;\n\td->lastfp = fpst;\n\tSFDParseChainContext(sfd,sf,fpst,tok,old);\n    }\n    else if ( strmatch(tok,\"Group:\")==0 ) {\n        struct ff_glyphclasses *grouptmp = calloc(1, sizeof(struct ff_glyphclasses));\n        while ((ch=nlgetc(sfd)) == ' '); ungetc(ch, sfd);\n        grouptmp->classname = SFDReadUTF7Str(sfd);\n        while ((ch=nlgetc(sfd)) == ' '); ungetc(ch, sfd);\n        grouptmp->glyphs = SFDReadUTF7Str(sfd);\n        while ((ch=nlgetc(sfd)) == ' ' || ch == '\\n'); ungetc(ch, sfd);\n        if (d->lastgroup != NULL) d->lastgroup->next = grouptmp; else sf->groups = grouptmp;\n        d->lastgroup = grouptmp;\n    }\n    else if ( strmatch(tok,\"GroupKern:\")==0 ) {\n        int temp = 0;\n        struct ff_rawoffsets *kerntmp = calloc(1, sizeof(struct ff_rawoffsets));\n        while ((ch=nlgetc(sfd)) == ' '); ungetc(ch, sfd);\n        kerntmp->left = SFDReadUTF7Str(sfd);\n        while ((ch=nlgetc(sfd)) == ' '); ungetc(ch, sfd);\n        kerntmp->right = SFDReadUTF7Str(sfd);\n        while ((ch=nlgetc(sfd)) == ' '); ungetc(ch, sfd);\n        getint(sfd,&temp);\n        kerntmp->offset = temp;\n        while ((ch=nlgetc(sfd)) == ' ' || ch == '\\n'); ungetc(ch, sfd);\n        if (d->lastgroupkern != NULL) d->lastgroupkern->next = kerntmp; else sf->groupkerns = kerntmp;\n        d->lastgroupkern = kerntmp;\n    }\n    else if ( strmatch(tok,\"GroupVKern:\")==0 ) {\n        int temp = 0;\n        struct ff_rawoffsets *kerntmp = calloc(1, sizeof(struct ff_rawoffsets));\n        while ((ch=nlgetc(sfd)) == ' '); ungetc(ch, sfd);\n        kerntmp->left = SFDReadUTF7Str(sfd);\n        while ((ch=nlgetc(sfd)) == ' '); ungetc(ch, sfd);\n        kerntmp->right = SFDReadUTF7Str(sfd);\n        while ((ch=nlgetc(sfd)) == ' '); ungetc(ch, sfd);\n        getint(sfd,&temp);\n        kerntmp->offset = temp;\n        while ((ch=nlgetc(sfd)) == ' ' || ch == '\\n'); ungetc(ch, sfd);\n        if (d->lastgroupvkern != NULL) d->lastgroupvkern->next = kerntmp; else sf->groupvkerns = kerntmp;\n        d->lastgroupvkern = kerntmp;\n    }\n    else if ( strmatch(tok,\"MacIndic2:\")==0 || strmatch(tok,\"MacContext2:\")==0 ||\n\t      strmatch(tok,\"MacLigature2:\")==0 || strmatch(tok,\"MacSimple2:\")==0 ||\n\t      strmatch(tok,\"MacKern2:\")==0 || strmatch(tok,\"MacInsert2:\")==0 ||\n\t      strmatch(tok,\"MacIndic:\")==0 || strmatch(tok,\"MacContext:\")==0 ||\n\t      strmatch(tok,\"MacLigature:\")==0 || strmatch(tok,\"MacSimple:\")==0 ||\n\t      strmatch(tok,\"MacKern:\")==0 || strmatch(tok,\"MacInsert:\")==0 )\n    {\n\tASM *sm;\n\tif ( strchr(tok,'2')!=NULL ) {\n\t    old = false;\n\t    sm = chunkalloc(sizeof(ASM));\n\t} else {\n\t    old = true;\n\t    sm = chunkalloc(sizeof(ASM1));\n\t}\n\tif ( (sf->sfd_version<2)!=old ) {\n\t    IError( \"Version mixup in state machine of sfd file.\" );\n\t    exit(1);\n\t}\n\tif ( d->lastsm==NULL )\n\t    sf->sm = sm;\n\telse\n\t    d->lastsm->next = sm;\n\td->lastsm = sm;\n\tSFDParseStateMachine(sfd,sf,sm,tok,old);\n    }\n    else if ( strmatch(tok,\"MacFeat:\")==0 )\n    {\n\tsf->features = SFDParseMacFeatures(sfd,tok);\n    }\n    else if ( strmatch(tok,\"TtfTable:\")==0 )\n    {\n\t/* Old, binary format */\n\t/* still used for maxp and unknown tables */\n\tSFDGetTtfTable(sfd,sf,d->lastttf);\n    }\n    else if ( strmatch(tok,\"TtTable:\")==0 )\n    {\n\t/* text instruction format */\n\tSFDGetTtTable(sfd,sf,d->lastttf);\n    }\n\n\n    ///////////////////\n\n    else if ( strmatch(tok,\"ShortTable:\")==0 )\n    {\n\t// only read, not written.\n\t/* text number format */\n\tSFDGetShortTable(sfd,sf,d->lastttf);\n    }\n    else\n    {\n        //\n        // We didn't have a match ourselves.\n        //\n        return false;\n    }\n    return true;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148528,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "bool SFD_GetFontMetaData( FILE *sfd,\n\t\t\t  char *tok,\n\t\t\t  SplineFont *sf,\n\t\t\t  SFD_GetFontMetaDataData* d )\n{\n    int ch;\n    int i;\n    KernClass* kc = 0;\n    int old;\n    char val[2000];\n\n    // This allows us to assume we can dereference d\n    // at all times\n    static SFD_GetFontMetaDataData my_static_d;\n    static int my_static_d_is_virgin = 1;\n    if( !d )\n    {\n\tif( my_static_d_is_virgin )\n\t{\n\t    my_static_d_is_virgin = 0;\n\t    SFD_GetFontMetaDataData_Init( &my_static_d );\n\t}\n\td = &my_static_d;\n    }\n\n    if ( strmatch(tok,\"FontName:\")==0 )\n    {\n\tgeteol(sfd,val);\n\tsf->fontname = copy(val);\n    }\n    else if ( strmatch(tok,\"FullName:\")==0 )\n    {\n\tgeteol(sfd,val);\n\tsf->fullname = copy(val);\n    }\n    else if ( strmatch(tok,\"FamilyName:\")==0 )\n    {\n\tgeteol(sfd,val);\n\tsf->familyname = copy(val);\n    }\n    else if ( strmatch(tok,\"DefaultBaseFilename:\")==0 )\n    {\n\tgeteol(sfd,val);\n\tsf->defbasefilename = copy(val);\n    }\n    else if ( strmatch(tok,\"Weight:\")==0 )\n    {\n\tgetprotectedname(sfd,val);\n\tsf->weight = copy(val);\n    }\n    else if ( strmatch(tok,\"Copyright:\")==0 )\n    {\n\tsf->copyright = getquotedeol(sfd);\n    }\n    else if ( strmatch(tok,\"Comments:\")==0 )\n    {\n\tchar *temp = getquotedeol(sfd);\n\tsf->comments = latin1_2_utf8_copy(temp);\n\tfree(temp);\n    }\n    else if ( strmatch(tok,\"UComments:\")==0 )\n    {\n\tsf->comments = SFDReadUTF7Str(sfd);\n    }\n    else if ( strmatch(tok,\"FontLog:\")==0 )\n    {\n\tsf->fontlog = SFDReadUTF7Str(sfd);\n    }\n    else if ( strmatch(tok,\"Version:\")==0 )\n    {\n\tgeteol(sfd,val);\n\tsf->version = copy(val);\n    }\n    else if ( strmatch(tok,\"StyleMapFamilyName:\")==0 )\n    {\n    sf->styleMapFamilyName = SFDReadUTF7Str(sfd);\n    }\n    /* Legacy attribute for StyleMapFamilyName. Deprecated. */\n    else if ( strmatch(tok,\"OS2FamilyName:\")==0 )\n    {\n    if (sf->styleMapFamilyName == NULL)\n        sf->styleMapFamilyName = SFDReadUTF7Str(sfd);\n    }\n    else if ( strmatch(tok,\"FONDName:\")==0 )\n    {\n\tgeteol(sfd,val);\n\tsf->fondname = copy(val);\n    }\n    else if ( strmatch(tok,\"ItalicAngle:\")==0 )\n    {\n\tgetreal(sfd,&sf->italicangle);\n    }\n    else if ( strmatch(tok,\"StrokeWidth:\")==0 )\n    {\n\tgetreal(sfd,&sf->strokewidth);\n    }\n    else if ( strmatch(tok,\"UnderlinePosition:\")==0 )\n    {\n\tgetreal(sfd,&sf->upos);\n    }\n    else if ( strmatch(tok,\"UnderlineWidth:\")==0 )\n    {\n\tgetreal(sfd,&sf->uwidth);\n    }\n    else if ( strmatch(tok,\"ModificationTime:\")==0 )\n    {\n\tgetlonglong(sfd,&sf->modificationtime);\n    }\n    else if ( strmatch(tok,\"CreationTime:\")==0 )\n    {\n\tgetlonglong(sfd,&sf->creationtime);\n\td->hadtimes = true;\n    }\n    else if ( strmatch(tok,\"PfmFamily:\")==0 )\n    {\n\tint temp;\n\tgetint(sfd,&temp);\n\tsf->pfminfo.pfmfamily = temp;\n\tsf->pfminfo.pfmset = true;\n    }\n    else if ( strmatch(tok,\"LangName:\")==0 )\n    {\n\tsf->names = SFDGetLangName(sfd,sf->names);\n    }\n    else if ( strmatch(tok,\"GaspTable:\")==0 )\n    {\n\tSFDGetGasp(sfd,sf);\n    }\n    else if ( strmatch(tok,\"DesignSize:\")==0 )\n    {\n\tSFDGetDesignSize(sfd,sf);\n    }\n    else if ( strmatch(tok,\"OtfFeatName:\")==0 )\n    {\n\tSFDGetOtfFeatName(sfd,sf);\n    }\n    else if ( strmatch(tok,\"PfmWeight:\")==0 || strmatch(tok,\"TTFWeight:\")==0 )\n    {\n\tgetsint(sfd,&sf->pfminfo.weight);\n\tsf->pfminfo.pfmset = true;\n    }\n    else if ( strmatch(tok,\"TTFWidth:\")==0 )\n    {\n\tgetsint(sfd,&sf->pfminfo.width);\n\tsf->pfminfo.pfmset = true;\n    }\n    else if ( strmatch(tok,\"Panose:\")==0 )\n    {\n\tint temp,i;\n\tfor ( i=0; i<10; ++i )\n\t{\n\t    getint(sfd,&temp);\n\t    sf->pfminfo.panose[i] = temp;\n\t}\n\tsf->pfminfo.panose_set = true;\n    }\n    else if ( strmatch(tok,\"LineGap:\")==0 )\n    {\n\tgetsint(sfd,&sf->pfminfo.linegap);\n\tsf->pfminfo.pfmset = true;\n    }\n    else if ( strmatch(tok,\"VLineGap:\")==0 )\n    {\n\tgetsint(sfd,&sf->pfminfo.vlinegap);\n\tsf->pfminfo.pfmset = true;\n    }\n    else if ( strmatch(tok,\"HheadAscent:\")==0 )\n    {\n\tgetsint(sfd,&sf->pfminfo.hhead_ascent);\n    }\n    else if ( strmatch(tok,\"HheadAOffset:\")==0 )\n    {\n\tint temp;\n\tgetint(sfd,&temp); sf->pfminfo.hheadascent_add = temp;\n    }\n    else if ( strmatch(tok,\"HheadDescent:\")==0 )\n    {\n\tgetsint(sfd,&sf->pfminfo.hhead_descent);\n    }\n    else if ( strmatch(tok,\"HheadDOffset:\")==0 )\n    {\n\tint temp;\n\tgetint(sfd,&temp); sf->pfminfo.hheaddescent_add = temp;\n    }\n    else if ( strmatch(tok,\"OS2TypoLinegap:\")==0 )\n    {\n\tgetsint(sfd,&sf->pfminfo.os2_typolinegap);\n    }\n    else if ( strmatch(tok,\"OS2TypoAscent:\")==0 )\n    {\n\tgetsint(sfd,&sf->pfminfo.os2_typoascent);\n    }\n    else if ( strmatch(tok,\"OS2TypoAOffset:\")==0 )\n    {\n\tint temp;\n\tgetint(sfd,&temp); sf->pfminfo.typoascent_add = temp;\n    }\n    else if ( strmatch(tok,\"OS2TypoDescent:\")==0 )\n    {\n\tgetsint(sfd,&sf->pfminfo.os2_typodescent);\n    }\n    else if ( strmatch(tok,\"OS2TypoDOffset:\")==0 )\n    {\n\tint temp;\n\tgetint(sfd,&temp); sf->pfminfo.typodescent_add = temp;\n    }\n    else if ( strmatch(tok,\"OS2WinAscent:\")==0 )\n    {\n\tgetsint(sfd,&sf->pfminfo.os2_winascent);\n    }\n    else if ( strmatch(tok,\"OS2WinDescent:\")==0 )\n    {\n\tgetsint(sfd,&sf->pfminfo.os2_windescent);\n    }\n    else if ( strmatch(tok,\"OS2WinAOffset:\")==0 )\n    {\n\tint temp;\n\tgetint(sfd,&temp); sf->pfminfo.winascent_add = temp;\n    }\n    else if ( strmatch(tok,\"OS2WinDOffset:\")==0 )\n    {\n\tint temp;\n\tgetint(sfd,&temp); sf->pfminfo.windescent_add = temp;\n    }\n    else if ( strmatch(tok,\"HHeadAscent:\")==0 )\n    {\n\t// DUPLICATE OF ABOVE\n\tgetsint(sfd,&sf->pfminfo.hhead_ascent);\n    }\n    else if ( strmatch(tok,\"HHeadDescent:\")==0 )\n    {\n\t// DUPLICATE OF ABOVE\n\tgetsint(sfd,&sf->pfminfo.hhead_descent);\n    }\n\n    else if ( strmatch(tok,\"HHeadAOffset:\")==0 )\n    {\n\t// DUPLICATE OF ABOVE\n\tint temp;\n\tgetint(sfd,&temp); sf->pfminfo.hheadascent_add = temp;\n    }\n    else if ( strmatch(tok,\"HHeadDOffset:\")==0 )\n    {\n\t// DUPLICATE OF ABOVE\n\tint temp;\n\tgetint(sfd,&temp); sf->pfminfo.hheaddescent_add = temp;\n    }\n    else if ( strmatch(tok,\"MacStyle:\")==0 )\n    {\n\tgetsint(sfd,&sf->macstyle);\n    }\n    else if ( strmatch(tok,\"OS2SubXSize:\")==0 )\n    {\n\tgetsint(sfd,&sf->pfminfo.os2_subxsize);\n\tsf->pfminfo.subsuper_set = true;\n    }\n    else if ( strmatch(tok,\"OS2SubYSize:\")==0 )\n    {\n\tgetsint(sfd,&sf->pfminfo.os2_subysize);\n    }\n    else if ( strmatch(tok,\"OS2SubXOff:\")==0 )\n    {\n\tgetsint(sfd,&sf->pfminfo.os2_subxoff);\n    }\n    else if ( strmatch(tok,\"OS2SubYOff:\")==0 )\n    {\n\tgetsint(sfd,&sf->pfminfo.os2_subyoff);\n    }\n    else if ( strmatch(tok,\"OS2SupXSize:\")==0 )\n    {\n\tgetsint(sfd,&sf->pfminfo.os2_supxsize);\n    }\n    else if ( strmatch(tok,\"OS2SupYSize:\")==0 )\n    {\n\tgetsint(sfd,&sf->pfminfo.os2_supysize);\n    }\n    else if ( strmatch(tok,\"OS2SupXOff:\")==0 )\n    {\n\tgetsint(sfd,&sf->pfminfo.os2_supxoff);\n    }\n    else if ( strmatch(tok,\"OS2SupYOff:\")==0 )\n    {\n\tgetsint(sfd,&sf->pfminfo.os2_supyoff);\n    }\n    else if ( strmatch(tok,\"OS2StrikeYSize:\")==0 )\n    {\n\tgetsint(sfd,&sf->pfminfo.os2_strikeysize);\n    }\n    else if ( strmatch(tok,\"OS2StrikeYPos:\")==0 )\n    {\n\tgetsint(sfd,&sf->pfminfo.os2_strikeypos);\n    }\n    else if ( strmatch(tok,\"OS2CapHeight:\")==0 )\n    {\n\tgetsint(sfd,&sf->pfminfo.os2_capheight);\n    }\n    else if ( strmatch(tok,\"OS2XHeight:\")==0 )\n    {\n\tgetsint(sfd,&sf->pfminfo.os2_xheight);\n    }\n    else if ( strmatch(tok,\"OS2FamilyClass:\")==0 )\n    {\n\tgetsint(sfd,&sf->pfminfo.os2_family_class);\n    }\n    else if ( strmatch(tok,\"OS2Vendor:\")==0 )\n    {\n\twhile ( isspace(nlgetc(sfd)));\n\tsf->pfminfo.os2_vendor[0] = nlgetc(sfd);\n\tsf->pfminfo.os2_vendor[1] = nlgetc(sfd);\n\tsf->pfminfo.os2_vendor[2] = nlgetc(sfd);\n\tsf->pfminfo.os2_vendor[3] = nlgetc(sfd);\n\t(void) nlgetc(sfd);\n    }\n    else if ( strmatch(tok,\"OS2CodePages:\")==0 )\n    {\n\tgethexints(sfd,sf->pfminfo.codepages,2);\n\tsf->pfminfo.hascodepages = true;\n    }\n    else if ( strmatch(tok,\"OS2UnicodeRanges:\")==0 )\n    {\n\tgethexints(sfd,sf->pfminfo.unicoderanges,4);\n\tsf->pfminfo.hasunicoderanges = true;\n    }\n    else if ( strmatch(tok,\"TopEncoding:\")==0 )\n    {\n\t/* Obsolete */\n\tgetint(sfd,&sf->top_enc);\n    }\n    else if ( strmatch(tok,\"Ascent:\")==0 )\n    {\n\tgetint(sfd,&sf->ascent);\n    }\n    else if ( strmatch(tok,\"Descent:\")==0 )\n    {\n\tgetint(sfd,&sf->descent);\n    }\n    else if ( strmatch(tok,\"InvalidEm:\")==0 )\n    {\n\tgetint(sfd,&sf->invalidem);\n    }\n    else if ( strmatch(tok,\"woffMajor:\")==0 )\n    {\n\tgetint(sfd,&sf->woffMajor);\n    }\n    else if ( strmatch(tok,\"woffMinor:\")==0 )\n    {\n\tgetint(sfd,&sf->woffMinor);\n    }\n    else if ( strmatch(tok,\"woffMetadata:\")==0 )\n    {\n\tsf->woffMetadata = SFDReadUTF7Str(sfd);\n    }\n    else if ( strmatch(tok,\"UFOAscent:\")==0 )\n    {\n\t    getreal(sfd,&sf->ufo_ascent);\n    }\n    else if ( strmatch(tok,\"UFODescent:\")==0 )\n    {\n\tgetreal(sfd,&sf->ufo_descent);\n    }\n    else if ( strmatch(tok,\"sfntRevision:\")==0 )\n    {\n\tgethex(sfd,(uint32 *)&sf->sfntRevision);\n    }\n    else if ( strmatch(tok,\"LayerCount:\")==0 )\n    {\n\td->had_layer_cnt = true;\n\tint layer_cnt_tmp;\n\tgetint(sfd,&layer_cnt_tmp);\n\tif ( layer_cnt_tmp>2 ) {\n\t    sf->layers = realloc(sf->layers,sf->layer_cnt*sizeof(LayerInfo));\n\t    memset(sf->layers+2,0,(sf->layer_cnt-2)*sizeof(LayerInfo));\n\t    sf->layer_cnt = layer_cnt_tmp;\n\t}\n    }\n    else if ( strmatch(tok,\"Layer:\")==0 )\n    {\n        // TODO: Read the U. F. O. path.\n\tint layer, o2, bk;\n\tgetint(sfd,&layer);\n\tif ( layer>=sf->layer_cnt ) {\n\t    sf->layers = realloc(sf->layers,(layer+1)*sizeof(LayerInfo));\n\t    memset(sf->layers+sf->layer_cnt,0,((layer+1)-sf->layer_cnt)*sizeof(LayerInfo));\n\t    sf->layer_cnt = layer+1;\n\t}\n\tgetint(sfd,&o2);\n\tsf->layers[layer].order2 = o2;\n\tsf->layers[layer].background = layer==ly_back;\n\t/* Used briefly, now background is after layer name */\n\twhile ( (ch=nlgetc(sfd))==' ' );\n\tungetc(ch,sfd);\n\tif ( ch!='\"' ) {\n\t    getint(sfd,&bk);\n\t    sf->layers[layer].background = bk;\n\t}\n\t/* end of section for obsolete format */\n\tsf->layers[layer].name = SFDReadUTF7Str(sfd);\n\twhile ( (ch=nlgetc(sfd))==' ' );\n\tungetc(ch,sfd);\n\tif ( ch!='\\n' ) {\n\t    getint(sfd,&bk);\n\t    sf->layers[layer].background = bk;\n\t}\n\twhile ( (ch=nlgetc(sfd))==' ' );\n\tungetc(ch,sfd);\n\tif ( ch!='\\n' ) { sf->layers[layer].ufo_path = SFDReadUTF7Str(sfd); }\n    }\n    else if ( strmatch(tok,\"PreferredKerning:\")==0 )\n    {\n\tint temp;\n\tgetint(sfd,&temp);\n\tsf->preferred_kerning = temp;\n    }\n    else if ( strmatch(tok,\"StrokedFont:\")==0 )\n    {\n\tint temp;\n\tgetint(sfd,&temp);\n\tsf->strokedfont = temp;\n    }\n    else if ( strmatch(tok,\"MultiLayer:\")==0 )\n    {\n\tint temp;\n\tgetint(sfd,&temp);\n\tsf->multilayer = temp;\n    }\n    else if ( strmatch(tok,\"NeedsXUIDChange:\")==0 )\n    {\n\tint temp;\n\tgetint(sfd,&temp);\n\tsf->changed_since_xuidchanged = temp;\n    }\n    else if ( strmatch(tok,\"VerticalOrigin:\")==0 )\n    {\n\t// this doesn't seem to be written ever.\n\tint temp;\n\tgetint(sfd,&temp);\n\tsf->hasvmetrics = true;\n    }\n    else if ( strmatch(tok,\"HasVMetrics:\")==0 )\n    {\n\tint temp;\n\tgetint(sfd,&temp);\n\tsf->hasvmetrics = temp;\n    }\n    else if ( strmatch(tok,\"Justify:\")==0 )\n    {\n\tSFDParseJustify(sfd,sf,tok);\n    }\n    else if ( strmatch(tok,\"BaseHoriz:\")==0 )\n    {\n\tsf->horiz_base = SFDParseBase(sfd);\n\td->last_base = sf->horiz_base;\n\td->last_base_script = NULL;\n    }\n    else if ( strmatch(tok,\"BaseVert:\")==0 )\n    {\n\tsf->vert_base = SFDParseBase(sfd);\n\td->last_base = sf->vert_base;\n\td->last_base_script = NULL;\n    }\n    else if ( strmatch(tok,\"BaseScript:\")==0 )\n    {\n\tstruct basescript *bs = SFDParseBaseScript(sfd,d->last_base);\n\tif ( d->last_base==NULL )\n\t{\n\t    BaseScriptFree(bs);\n\t    bs = NULL;\n\t}\n\telse if ( d->last_base_script!=NULL )\n\t    d->last_base_script->next = bs;\n\telse\n\t    d->last_base->scripts = bs;\n\td->last_base_script = bs;\n    }\n    else if ( strmatch(tok,\"StyleMap:\")==0 )\n    {\n    gethex(sfd,(uint32 *)&sf->pfminfo.stylemap);\n    }\n    /* Legacy attribute for StyleMap. Deprecated. */\n    else if ( strmatch(tok,\"OS2StyleName:\")==0 )\n    {\n    char* sname = SFDReadUTF7Str(sfd);\n    if (sf->pfminfo.stylemap == -1) {\n        if (strcmp(sname,\"bold italic\")==0) sf->pfminfo.stylemap = 0x21;\n        else if (strcmp(sname,\"bold\")==0) sf->pfminfo.stylemap = 0x20;\n        else if (strcmp(sname,\"italic\")==0) sf->pfminfo.stylemap = 0x01;\n        else if (strcmp(sname,\"regular\")==0) sf->pfminfo.stylemap = 0x40;\n    }\n    free(sname);\n    }\n    else if ( strmatch(tok,\"FSType:\")==0 )\n    {\n\tgetsint(sfd,&sf->pfminfo.fstype);\n    }\n    else if ( strmatch(tok,\"OS2Version:\")==0 )\n    {\n\tgetsint(sfd,&sf->os2_version);\n    }\n    else if ( strmatch(tok,\"OS2_WeightWidthSlopeOnly:\")==0 )\n    {\n\tint temp;\n\tgetint(sfd,&temp);\n\tsf->weight_width_slope_only = temp;\n    }\n    else if ( strmatch(tok,\"OS2_UseTypoMetrics:\")==0 )\n    {\n\tint temp;\n\tgetint(sfd,&temp);\n\tsf->use_typo_metrics = temp;\n    }\n    else if ( strmatch(tok,\"UseUniqueID:\")==0 )\n    {\n\tint temp;\n\tgetint(sfd,&temp);\n\tsf->use_uniqueid = temp;\n    }\n    else if ( strmatch(tok,\"UseXUID:\")==0 )\n    {\n\tint temp;\n\tgetint(sfd,&temp);\n\tsf->use_xuid = temp;\n    }\n    else if ( strmatch(tok,\"UniqueID:\")==0 )\n    {\n\tgetint(sfd,&sf->uniqueid);\n    }\n    else if ( strmatch(tok,\"XUID:\")==0 )\n    {\n\tgeteol(sfd,tok);\n\tsf->xuid = copy(tok);\n    }\n    else if ( strmatch(tok,\"Lookup:\")==0 )\n    {\n\tOTLookup *otl;\n\tint temp;\n\tif ( sf->sfd_version<2 ) {\n\t    IError( \"Lookups should not happen in version 1 sfd files.\" );\n\t    exit(1);\n\t}\n\totl = chunkalloc(sizeof(OTLookup));\n\tgetint(sfd,&temp); otl->lookup_type = temp;\n\tgetint(sfd,&temp); otl->lookup_flags = temp;\n\tgetint(sfd,&temp); otl->store_in_afm = temp;\n\totl->lookup_name = SFDReadUTF7Str(sfd);\n\tif ( otl->lookup_type<gpos_single ) {\n\t    if ( d->lastsotl==NULL )\n\t\tsf->gsub_lookups = otl;\n\t    else\n\t\td->lastsotl->next = otl;\n\t    d->lastsotl = otl;\n\t} else {\n\t    if ( d->lastpotl==NULL )\n\t\tsf->gpos_lookups = otl;\n\t    else\n\t\td->lastpotl->next = otl;\n\t    d->lastpotl = otl;\n\t}\n\tSFDParseLookup(sfd,otl);\n    }\n    else if ( strmatch(tok,\"MarkAttachClasses:\")==0 )\n    {\n\tgetint(sfd,&sf->mark_class_cnt);\n\tsf->mark_classes = malloc(sf->mark_class_cnt*sizeof(char *));\n\tsf->mark_class_names = malloc(sf->mark_class_cnt*sizeof(char *));\n\tsf->mark_classes[0] = NULL; sf->mark_class_names[0] = NULL;\n\tfor ( i=1; i<sf->mark_class_cnt; ++i )\n\t{\n\t    /* Class 0 is unused */\n\t    int temp;\n\t    while ( (temp=nlgetc(sfd))=='\\n' || temp=='\\r' ); ungetc(temp,sfd);\n\t    sf->mark_class_names[i] = SFDReadUTF7Str(sfd);\n\t    getint(sfd,&temp);\n\t    sf->mark_classes[i] = malloc(temp+1); sf->mark_classes[i][temp] = '\\0';\n\t    nlgetc(sfd);\t/* skip space */\n\t    fread(sf->mark_classes[i],1,temp,sfd);\n\t}\n    }\n    else if ( strmatch(tok,\"MarkAttachSets:\")==0 )\n    {\n\tgetint(sfd,&sf->mark_set_cnt);\n\tsf->mark_sets = malloc(sf->mark_set_cnt*sizeof(char *));\n\tsf->mark_set_names = malloc(sf->mark_set_cnt*sizeof(char *));\n\tfor ( i=0; i<sf->mark_set_cnt; ++i )\n\t{\n\t    /* Set 0 is used */\n\t    int temp;\n\t    while ( (temp=nlgetc(sfd))=='\\n' || temp=='\\r' ); ungetc(temp,sfd);\n\t    sf->mark_set_names[i] = SFDReadUTF7Str(sfd);\n\t    getint(sfd,&temp);\n\t    sf->mark_sets[i] = malloc(temp+1); sf->mark_sets[i][temp] = '\\0';\n\t    nlgetc(sfd);\t/* skip space */\n\t    fread(sf->mark_sets[i],1,temp,sfd);\n\t}\n    }\n    else if ( strmatch(tok,\"KernClass2:\")==0 || strmatch(tok,\"VKernClass2:\")==0 ||\n\t      strmatch(tok,\"KernClass:\")==0 || strmatch(tok,\"VKernClass:\")==0 ||\n\t      strmatch(tok,\"KernClass3:\")==0 || strmatch(tok,\"VKernClass3:\")==0 )\n    {\n\tint kernclassversion = 0;\n\tint isv = tok[0]=='V';\n\tint kcvoffset = (isv ? 10 : 9); //Offset to read kerning class version\n\tif (isdigit(tok[kcvoffset])) kernclassversion = tok[kcvoffset] - '0';\n\tint temp, classstart=1;\n\tint old = (kernclassversion == 0);\n\n\tif ( (sf->sfd_version<2)!=old ) {\n\t    IError( \"Version mixup in Kerning Classes of sfd file.\" );\n\t    exit(1);\n\t}\n\tkc = chunkalloc(old ? sizeof(KernClass1) : sizeof(KernClass));\n\tgetint(sfd,&kc->first_cnt);\n\tch=nlgetc(sfd);\n\tif ( ch=='+' )\n\t    classstart = 0;\n\telse\n\t    ungetc(ch,sfd);\n\tgetint(sfd,&kc->second_cnt);\n\tif ( old ) {\n\t    getint(sfd,&temp); ((KernClass1 *) kc)->sli = temp;\n\t    getint(sfd,&temp); ((KernClass1 *) kc)->flags = temp;\n\t} else {\n\t    kc->subtable = SFFindLookupSubtableAndFreeName(sf,SFDReadUTF7Str(sfd));\n\t    if ( kc->subtable!=NULL && kc->subtable->kc==NULL )\n\t\tkc->subtable->kc = kc;\n\t    else {\n\t\tif ( kc->subtable==NULL )\n\t\t    LogError(_(\"Bad SFD file, missing subtable in kernclass defn.\\n\") );\n\t\telse\n\t\t    LogError(_(\"Bad SFD file, two kerning classes assigned to the same subtable: %s\\n\"), kc->subtable->subtable_name );\n\t\tkc->subtable = NULL;\n\t    }\n\t}\n\tkc->firsts = calloc(kc->first_cnt,sizeof(char *));\n\tkc->seconds = calloc(kc->second_cnt,sizeof(char *));\n\tkc->offsets = calloc(kc->first_cnt*kc->second_cnt,sizeof(int16));\n\tkc->adjusts = calloc(kc->first_cnt*kc->second_cnt,sizeof(DeviceTable));\n\tif (kernclassversion >= 3) {\n\t  kc->firsts_flags = calloc(kc->first_cnt, sizeof(int));\n\t  kc->seconds_flags = calloc(kc->second_cnt, sizeof(int));\n\t  kc->offsets_flags = calloc(kc->first_cnt*kc->second_cnt, sizeof(int));\n\t  kc->firsts_names = calloc(kc->first_cnt, sizeof(char*));\n\t  kc->seconds_names = calloc(kc->second_cnt, sizeof(char*));\n\t}\n\tkc->firsts[0] = NULL;\n\tfor ( i=classstart; i<kc->first_cnt; ++i ) {\n\t  if (kernclassversion < 3) {\n\t    getint(sfd,&temp);\n\t    kc->firsts[i] = malloc(temp+1); kc->firsts[i][temp] = '\\0';\n\t    nlgetc(sfd);\t/* skip space */\n\t    fread(kc->firsts[i],1,temp,sfd);\n\t  } else {\n\t    getint(sfd,&kc->firsts_flags[i]);\n\t    while ((ch=nlgetc(sfd)) == ' '); ungetc(ch, sfd); if (ch == '\\n' || ch == EOF) continue;\n\t    kc->firsts_names[i] = SFDReadUTF7Str(sfd);\n\t    while ((ch=nlgetc(sfd)) == ' '); ungetc(ch, sfd); if (ch == '\\n' || ch == EOF) continue;\n\t    kc->firsts[i] = SFDReadUTF7Str(sfd);\n            if (kc->firsts[i] == NULL) kc->firsts[i] = copy(\"\"); // In certain places, this must be defined.\n\t    while ((ch=nlgetc(sfd)) == ' ' || ch == '\\n'); ungetc(ch, sfd);\n\t  }\n\t}\n\tkc->seconds[0] = NULL;\n\tfor ( i=1; i<kc->second_cnt; ++i ) {\n\t  if (kernclassversion < 3) {\n\t    getint(sfd,&temp);\n\t    kc->seconds[i] = malloc(temp+1); kc->seconds[i][temp] = '\\0';\n\t    nlgetc(sfd);\t/* skip space */\n\t    fread(kc->seconds[i],1,temp,sfd);\n\t  } else {\n\t    getint(sfd,&temp);\n\t    kc->seconds_flags[i] = temp;\n\t    while ((ch=nlgetc(sfd)) == ' '); ungetc(ch, sfd); if (ch == '\\n' || ch == EOF) continue;\n\t    kc->seconds_names[i] = SFDReadUTF7Str(sfd);\n\t    while ((ch=nlgetc(sfd)) == ' '); ungetc(ch, sfd); if (ch == '\\n' || ch == EOF) continue;\n\t    kc->seconds[i] = SFDReadUTF7Str(sfd);\n            if (kc->seconds[i] == NULL) kc->seconds[i] = copy(\"\"); // In certain places, this must be defined.\n\t    while ((ch=nlgetc(sfd)) == ' ' || ch == '\\n'); ungetc(ch, sfd);\n\t  }\n\t}\n\tfor ( i=0; i<kc->first_cnt*kc->second_cnt; ++i ) {\n\t  if (kernclassversion >= 3) {\n\t    getint(sfd,&temp);\n\t    kc->offsets_flags[i] = temp;\n\t  }\n\t    getint(sfd,&temp);\n\t    kc->offsets[i] = temp;\n\t    SFDReadDeviceTable(sfd,&kc->adjusts[i]);\n\t}\n\tif ( !old && kc->subtable == NULL ) {\n\t    /* Error. Ignore it. Free it. Whatever */;\n\t} else if ( !isv ) {\n\t    if ( d->lastkc==NULL )\n\t\tsf->kerns = kc;\n\t    else\n\t\td->lastkc->next = kc;\n\t    d->lastkc = kc;\n\t} else {\n\t    if ( d->lastvkc==NULL )\n\t\tsf->vkerns = kc;\n\t    else\n\t\td->lastvkc->next = kc;\n\t    d->lastvkc = kc;\n\t}\n    }\n    else if ( strmatch(tok,\"ContextPos2:\")==0 || strmatch(tok,\"ContextSub2:\")==0 ||\n\t      strmatch(tok,\"ChainPos2:\")==0 || strmatch(tok,\"ChainSub2:\")==0 ||\n\t      strmatch(tok,\"ReverseChain2:\")==0 ||\n\t      strmatch(tok,\"ContextPos:\")==0 || strmatch(tok,\"ContextSub:\")==0 ||\n\t      strmatch(tok,\"ChainPos:\")==0 || strmatch(tok,\"ChainSub:\")==0 ||\n\t      strmatch(tok,\"ReverseChain:\")==0 )\n    {\n\tFPST *fpst;\n\tint old;\n\tif ( strchr(tok,'2')!=NULL ) {\n\t    old = false;\n\t    fpst = chunkalloc(sizeof(FPST));\n\t} else {\n\t    old = true;\n\t    fpst = chunkalloc(sizeof(FPST1));\n\t}\n\tif ( (sf->sfd_version<2)!=old ) {\n\t    IError( \"Version mixup in FPST of sfd file.\" );\n\t    exit(1);\n\t}\n\tif ( d->lastfp==NULL )\n\t    sf->possub = fpst;\n\telse\n\t    d->lastfp->next = fpst;\n\td->lastfp = fpst;\n\tSFDParseChainContext(sfd,sf,fpst,tok,old);\n    }\n    else if ( strmatch(tok,\"Group:\")==0 ) {\n        struct ff_glyphclasses *grouptmp = calloc(1, sizeof(struct ff_glyphclasses));\n        while ((ch=nlgetc(sfd)) == ' '); ungetc(ch, sfd);\n        grouptmp->classname = SFDReadUTF7Str(sfd);\n        while ((ch=nlgetc(sfd)) == ' '); ungetc(ch, sfd);\n        grouptmp->glyphs = SFDReadUTF7Str(sfd);\n        while ((ch=nlgetc(sfd)) == ' ' || ch == '\\n'); ungetc(ch, sfd);\n        if (d->lastgroup != NULL) d->lastgroup->next = grouptmp; else sf->groups = grouptmp;\n        d->lastgroup = grouptmp;\n    }\n    else if ( strmatch(tok,\"GroupKern:\")==0 ) {\n        int temp = 0;\n        struct ff_rawoffsets *kerntmp = calloc(1, sizeof(struct ff_rawoffsets));\n        while ((ch=nlgetc(sfd)) == ' '); ungetc(ch, sfd);\n        kerntmp->left = SFDReadUTF7Str(sfd);\n        while ((ch=nlgetc(sfd)) == ' '); ungetc(ch, sfd);\n        kerntmp->right = SFDReadUTF7Str(sfd);\n        while ((ch=nlgetc(sfd)) == ' '); ungetc(ch, sfd);\n        getint(sfd,&temp);\n        kerntmp->offset = temp;\n        while ((ch=nlgetc(sfd)) == ' ' || ch == '\\n'); ungetc(ch, sfd);\n        if (d->lastgroupkern != NULL) d->lastgroupkern->next = kerntmp; else sf->groupkerns = kerntmp;\n        d->lastgroupkern = kerntmp;\n    }\n    else if ( strmatch(tok,\"GroupVKern:\")==0 ) {\n        int temp = 0;\n        struct ff_rawoffsets *kerntmp = calloc(1, sizeof(struct ff_rawoffsets));\n        while ((ch=nlgetc(sfd)) == ' '); ungetc(ch, sfd);\n        kerntmp->left = SFDReadUTF7Str(sfd);\n        while ((ch=nlgetc(sfd)) == ' '); ungetc(ch, sfd);\n        kerntmp->right = SFDReadUTF7Str(sfd);\n        while ((ch=nlgetc(sfd)) == ' '); ungetc(ch, sfd);\n        getint(sfd,&temp);\n        kerntmp->offset = temp;\n        while ((ch=nlgetc(sfd)) == ' ' || ch == '\\n'); ungetc(ch, sfd);\n        if (d->lastgroupvkern != NULL) d->lastgroupvkern->next = kerntmp; else sf->groupvkerns = kerntmp;\n        d->lastgroupvkern = kerntmp;\n    }\n    else if ( strmatch(tok,\"MacIndic2:\")==0 || strmatch(tok,\"MacContext2:\")==0 ||\n\t      strmatch(tok,\"MacLigature2:\")==0 || strmatch(tok,\"MacSimple2:\")==0 ||\n\t      strmatch(tok,\"MacKern2:\")==0 || strmatch(tok,\"MacInsert2:\")==0 ||\n\t      strmatch(tok,\"MacIndic:\")==0 || strmatch(tok,\"MacContext:\")==0 ||\n\t      strmatch(tok,\"MacLigature:\")==0 || strmatch(tok,\"MacSimple:\")==0 ||\n\t      strmatch(tok,\"MacKern:\")==0 || strmatch(tok,\"MacInsert:\")==0 )\n    {\n\tASM *sm;\n\tif ( strchr(tok,'2')!=NULL ) {\n\t    old = false;\n\t    sm = chunkalloc(sizeof(ASM));\n\t} else {\n\t    old = true;\n\t    sm = chunkalloc(sizeof(ASM1));\n\t}\n\tif ( (sf->sfd_version<2)!=old ) {\n\t    IError( \"Version mixup in state machine of sfd file.\" );\n\t    exit(1);\n\t}\n\tif ( d->lastsm==NULL )\n\t    sf->sm = sm;\n\telse\n\t    d->lastsm->next = sm;\n\td->lastsm = sm;\n\tSFDParseStateMachine(sfd,sf,sm,tok,old);\n    }\n    else if ( strmatch(tok,\"MacFeat:\")==0 )\n    {\n\tsf->features = SFDParseMacFeatures(sfd,tok);\n    }\n    else if ( strmatch(tok,\"TtfTable:\")==0 )\n    {\n\t/* Old, binary format */\n\t/* still used for maxp and unknown tables */\n\tSFDGetTtfTable(sfd,sf,d->lastttf);\n    }\n    else if ( strmatch(tok,\"TtTable:\")==0 )\n    {\n\t/* text instruction format */\n\tSFDGetTtTable(sfd,sf,d->lastttf);\n    }\n\n\n    ///////////////////\n\n    else if ( strmatch(tok,\"ShortTable:\")==0 )\n    {\n\t// only read, not written.\n\t/* text number format */\n\tSFDGetShortTable(sfd,sf,d->lastttf);\n    }\n    else\n    {\n        //\n        // We didn't have a match ourselves.\n        //\n        return false;\n    }\n    return true;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148529,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "gst_matroska_demux_add_wvpk_header (GstElement * element,\n    GstMatroskaTrackContext * stream, GstBuffer ** buf)\n{\n  GstMatroskaTrackAudioContext *audiocontext =\n      (GstMatroskaTrackAudioContext *) stream;\n  GstBuffer *newbuf = NULL;\n  GstMapInfo map, outmap;\n  guint8 *buf_data, *data;\n  Wavpack4Header wvh;\n\n  wvh.ck_id[0] = 'w';\n  wvh.ck_id[1] = 'v';\n  wvh.ck_id[2] = 'p';\n  wvh.ck_id[3] = 'k';\n\n  wvh.version = GST_READ_UINT16_LE (stream->codec_priv);\n  wvh.track_no = 0;\n  wvh.index_no = 0;\n  wvh.total_samples = -1;\n  wvh.block_index = audiocontext->wvpk_block_index;\n\n  if (audiocontext->channels <= 2) {\n    guint32 block_samples, tmp;\n    gsize size = gst_buffer_get_size (*buf);\n\n    gst_buffer_extract (*buf, 0, &tmp, sizeof (guint32));\n    block_samples = GUINT32_FROM_LE (tmp);\n    /* we need to reconstruct the header of the wavpack block */\n\n    /* -20 because ck_size is the size of the wavpack block -8\n     * and lace_size is the size of the wavpack block + 12\n     * (the three guint32 of the header that already are in the buffer) */\n    wvh.ck_size = size + sizeof (Wavpack4Header) - 20;\n\n    /* block_samples, flags and crc are already in the buffer */\n    newbuf = gst_buffer_new_allocate (NULL, sizeof (Wavpack4Header) - 12, NULL);\n\n    gst_buffer_map (newbuf, &outmap, GST_MAP_WRITE);\n    data = outmap.data;\n    data[0] = 'w';\n    data[1] = 'v';\n    data[2] = 'p';\n    data[3] = 'k';\n    GST_WRITE_UINT32_LE (data + 4, wvh.ck_size);\n    GST_WRITE_UINT16_LE (data + 8, wvh.version);\n    GST_WRITE_UINT8 (data + 10, wvh.track_no);\n    GST_WRITE_UINT8 (data + 11, wvh.index_no);\n    GST_WRITE_UINT32_LE (data + 12, wvh.total_samples);\n    GST_WRITE_UINT32_LE (data + 16, wvh.block_index);\n    gst_buffer_unmap (newbuf, &outmap);\n\n    /* Append data from buf: */\n    gst_buffer_copy_into (newbuf, *buf, GST_BUFFER_COPY_TIMESTAMPS |\n        GST_BUFFER_COPY_FLAGS | GST_BUFFER_COPY_MEMORY, 0, size);\n\n    gst_buffer_unref (*buf);\n    *buf = newbuf;\n    audiocontext->wvpk_block_index += block_samples;\n  } else {\n    guint8 *outdata = NULL;\n    guint outpos = 0;\n    gsize buf_size, size, out_size = 0;\n    guint32 block_samples, flags, crc, blocksize;\n\n    gst_buffer_map (*buf, &map, GST_MAP_READ);\n    buf_data = map.data;\n    buf_size = map.size;\n\n    if (buf_size < 4) {\n      GST_ERROR_OBJECT (element, \"Too small wavpack buffer\");\n      gst_buffer_unmap (*buf, &map);\n      return GST_FLOW_ERROR;\n    }\n\n    data = buf_data;\n    size = buf_size;\n\n    block_samples = GST_READ_UINT32_LE (data);\n    data += 4;\n    size -= 4;\n\n    while (size > 12) {\n      flags = GST_READ_UINT32_LE (data);\n      data += 4;\n      size -= 4;\n      crc = GST_READ_UINT32_LE (data);\n      data += 4;\n      size -= 4;\n      blocksize = GST_READ_UINT32_LE (data);\n      data += 4;\n      size -= 4;\n\n      if (blocksize == 0 || size < blocksize)\n        break;\n\n      g_assert ((newbuf == NULL) == (outdata == NULL));\n\n      if (newbuf == NULL) {\n        out_size = sizeof (Wavpack4Header) + blocksize;\n        newbuf = gst_buffer_new_allocate (NULL, out_size, NULL);\n\n        gst_buffer_copy_into (newbuf, *buf,\n            GST_BUFFER_COPY_TIMESTAMPS | GST_BUFFER_COPY_FLAGS, 0, -1);\n\n        outpos = 0;\n        gst_buffer_map (newbuf, &outmap, GST_MAP_WRITE);\n        outdata = outmap.data;\n      } else {\n        gst_buffer_unmap (newbuf, &outmap);\n        out_size += sizeof (Wavpack4Header) + blocksize;\n        gst_buffer_set_size (newbuf, out_size);\n        gst_buffer_map (newbuf, &outmap, GST_MAP_WRITE);\n        outdata = outmap.data;\n      }\n\n      outdata[outpos] = 'w';\n      outdata[outpos + 1] = 'v';\n      outdata[outpos + 2] = 'p';\n      outdata[outpos + 3] = 'k';\n      outpos += 4;\n\n      GST_WRITE_UINT32_LE (outdata + outpos,\n          blocksize + sizeof (Wavpack4Header) - 8);\n      GST_WRITE_UINT16_LE (outdata + outpos + 4, wvh.version);\n      GST_WRITE_UINT8 (outdata + outpos + 6, wvh.track_no);\n      GST_WRITE_UINT8 (outdata + outpos + 7, wvh.index_no);\n      GST_WRITE_UINT32_LE (outdata + outpos + 8, wvh.total_samples);\n      GST_WRITE_UINT32_LE (outdata + outpos + 12, wvh.block_index);\n      GST_WRITE_UINT32_LE (outdata + outpos + 16, block_samples);\n      GST_WRITE_UINT32_LE (outdata + outpos + 20, flags);\n      GST_WRITE_UINT32_LE (outdata + outpos + 24, crc);\n      outpos += 28;\n\n      memmove (outdata + outpos, data, blocksize);\n      outpos += blocksize;\n      data += blocksize;\n      size -= blocksize;\n    }\n    gst_buffer_unmap (*buf, &map);\n    gst_buffer_unref (*buf);\n\n    if (newbuf)\n      gst_buffer_unmap (newbuf, &outmap);\n\n    *buf = newbuf;\n    audiocontext->wvpk_block_index += block_samples;\n  }\n\n  return GST_FLOW_OK;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148588,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "gst_matroska_demux_add_wvpk_header (GstElement * element,\n    GstMatroskaTrackContext * stream, GstBuffer ** buf)\n{\n  GstMatroskaTrackAudioContext *audiocontext =\n      (GstMatroskaTrackAudioContext *) stream;\n  GstBuffer *newbuf = NULL;\n  GstMapInfo map, outmap;\n  guint8 *buf_data, *data;\n  Wavpack4Header wvh;\n\n  wvh.ck_id[0] = 'w';\n  wvh.ck_id[1] = 'v';\n  wvh.ck_id[2] = 'p';\n  wvh.ck_id[3] = 'k';\n\n  wvh.version = GST_READ_UINT16_LE (stream->codec_priv);\n  wvh.track_no = 0;\n  wvh.index_no = 0;\n  wvh.total_samples = -1;\n  wvh.block_index = audiocontext->wvpk_block_index;\n\n  if (audiocontext->channels <= 2) {\n    guint32 block_samples, tmp;\n    gsize size = gst_buffer_get_size (*buf);\n\n    if (size < 4) {\n      GST_ERROR_OBJECT (element, \"Too small wavpack buffer\");\n      gst_buffer_unmap (*buf, &map);\n      return GST_FLOW_ERROR;\n    }\n\n    gst_buffer_extract (*buf, 0, &tmp, sizeof (guint32));\n    block_samples = GUINT32_FROM_LE (tmp);\n    /* we need to reconstruct the header of the wavpack block */\n\n    /* -20 because ck_size is the size of the wavpack block -8\n     * and lace_size is the size of the wavpack block + 12\n     * (the three guint32 of the header that already are in the buffer) */\n    wvh.ck_size = size + WAVPACK4_HEADER_SIZE - 20;\n\n    /* block_samples, flags and crc are already in the buffer */\n    newbuf = gst_buffer_new_allocate (NULL, WAVPACK4_HEADER_SIZE - 12, NULL);\n\n    gst_buffer_map (newbuf, &outmap, GST_MAP_WRITE);\n    data = outmap.data;\n    data[0] = 'w';\n    data[1] = 'v';\n    data[2] = 'p';\n    data[3] = 'k';\n    GST_WRITE_UINT32_LE (data + 4, wvh.ck_size);\n    GST_WRITE_UINT16_LE (data + 8, wvh.version);\n    GST_WRITE_UINT8 (data + 10, wvh.track_no);\n    GST_WRITE_UINT8 (data + 11, wvh.index_no);\n    GST_WRITE_UINT32_LE (data + 12, wvh.total_samples);\n    GST_WRITE_UINT32_LE (data + 16, wvh.block_index);\n    gst_buffer_unmap (newbuf, &outmap);\n\n    /* Append data from buf: */\n    gst_buffer_copy_into (newbuf, *buf, GST_BUFFER_COPY_TIMESTAMPS |\n        GST_BUFFER_COPY_FLAGS | GST_BUFFER_COPY_MEMORY, 0, size);\n\n    gst_buffer_unref (*buf);\n    *buf = newbuf;\n    audiocontext->wvpk_block_index += block_samples;\n  } else {\n    guint8 *outdata = NULL;\n    gsize buf_size, size;\n    guint32 block_samples, flags, crc, blocksize;\n    GstAdapter *adapter;\n\n    adapter = gst_adapter_new ();\n\n    gst_buffer_map (*buf, &map, GST_MAP_READ);\n    buf_data = map.data;\n    buf_size = map.size;\n\n    if (buf_size < 4) {\n      GST_ERROR_OBJECT (element, \"Too small wavpack buffer\");\n      gst_buffer_unmap (*buf, &map);\n      g_object_unref (adapter);\n      return GST_FLOW_ERROR;\n    }\n\n    data = buf_data;\n    size = buf_size;\n\n    block_samples = GST_READ_UINT32_LE (data);\n    data += 4;\n    size -= 4;\n\n    while (size > 12) {\n      flags = GST_READ_UINT32_LE (data);\n      data += 4;\n      size -= 4;\n      crc = GST_READ_UINT32_LE (data);\n      data += 4;\n      size -= 4;\n      blocksize = GST_READ_UINT32_LE (data);\n      data += 4;\n      size -= 4;\n\n      if (blocksize == 0 || size < blocksize) {\n        GST_ERROR_OBJECT (element, \"Too small wavpack buffer\");\n        gst_buffer_unmap (*buf, &map);\n        g_object_unref (adapter);\n        return GST_FLOW_ERROR;\n      }\n\n      g_assert (newbuf == NULL);\n\n      newbuf =\n          gst_buffer_new_allocate (NULL, WAVPACK4_HEADER_SIZE + blocksize,\n          NULL);\n      gst_buffer_map (newbuf, &outmap, GST_MAP_WRITE);\n      outdata = outmap.data;\n\n      outdata[0] = 'w';\n      outdata[1] = 'v';\n      outdata[2] = 'p';\n      outdata[3] = 'k';\n      outdata += 4;\n\n      GST_WRITE_UINT32_LE (outdata, blocksize + WAVPACK4_HEADER_SIZE - 8);\n      GST_WRITE_UINT16_LE (outdata + 4, wvh.version);\n      GST_WRITE_UINT8 (outdata + 6, wvh.track_no);\n      GST_WRITE_UINT8 (outdata + 7, wvh.index_no);\n      GST_WRITE_UINT32_LE (outdata + 8, wvh.total_samples);\n      GST_WRITE_UINT32_LE (outdata + 12, wvh.block_index);\n      GST_WRITE_UINT32_LE (outdata + 16, block_samples);\n      GST_WRITE_UINT32_LE (outdata + 20, flags);\n      GST_WRITE_UINT32_LE (outdata + 24, crc);\n      outdata += 28;\n\n      memcpy (outdata, data, blocksize);\n\n      gst_buffer_unmap (newbuf, &outmap);\n      gst_adapter_push (adapter, newbuf);\n      newbuf = NULL;\n\n      data += blocksize;\n      size -= blocksize;\n    }\n    gst_buffer_unmap (*buf, &map);\n\n    newbuf = gst_adapter_take_buffer (adapter, gst_adapter_available (adapter));\n    g_object_unref (adapter);\n\n    gst_buffer_copy_into (newbuf, *buf,\n        GST_BUFFER_COPY_TIMESTAMPS | GST_BUFFER_COPY_FLAGS, 0, -1);\n    gst_buffer_unref (*buf);\n    *buf = newbuf;\n\n    audiocontext->wvpk_block_index += block_samples;\n  }\n\n  return GST_FLOW_OK;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148589,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "\nstatic void bfq_idle_slice_timer_body(struct bfq_queue *bfqq)\n{\n\tstruct bfq_data *bfqd = bfqq->bfqd;\n\tenum bfqq_expiration reason;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&bfqd->lock, flags);\n\tbfq_clear_bfqq_wait_request(bfqq);\n\n\tif (bfqq != bfqd->in_service_queue) {\n\t\tspin_unlock_irqrestore(&bfqd->lock, flags);\n\t\treturn;\n\t}\n\n\tif (bfq_bfqq_budget_timeout(bfqq))\n\t\t/*\n\t\t * Also here the queue can be safely expired\n\t\t * for budget timeout without wasting\n\t\t * guarantees\n\t\t */\n\t\treason = BFQQE_BUDGET_TIMEOUT;\n\telse if (bfqq->queued[0] == 0 && bfqq->queued[1] == 0)\n\t\t/*\n\t\t * The queue may not be empty upon timer expiration,\n\t\t * because we may not disable the timer when the\n\t\t * first request of the in-service queue arrives\n\t\t * during disk idling.\n\t\t */\n\t\treason = BFQQE_TOO_IDLE;\n\telse\n\t\tgoto schedule_dispatch;\n\n\tbfq_bfqq_expire(bfqd, bfqq, true, reason);\n\nschedule_dispatch:\n\tspin_unlock_irqrestore(&bfqd->lock, flags);\n\tbfq_schedule_dispatch(bfqd);",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148616,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static void\nbfq_idle_slice_timer_body(struct bfq_data *bfqd, struct bfq_queue *bfqq)\n{\n\tenum bfqq_expiration reason;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&bfqd->lock, flags);\n\n\t/*\n\t * Considering that bfqq may be in race, we should firstly check\n\t * whether bfqq is in service before doing something on it. If\n\t * the bfqq in race is not in service, it has already been expired\n\t * through __bfq_bfqq_expire func and its wait_request flags has\n\t * been cleared in __bfq_bfqd_reset_in_service func.\n\t */\n\tif (bfqq != bfqd->in_service_queue) {\n\t\tspin_unlock_irqrestore(&bfqd->lock, flags);\n\t\treturn;\n\t}\n\n\tbfq_clear_bfqq_wait_request(bfqq);\n\n\tif (bfq_bfqq_budget_timeout(bfqq))\n\t\t/*\n\t\t * Also here the queue can be safely expired\n\t\t * for budget timeout without wasting\n\t\t * guarantees\n\t\t */\n\t\treason = BFQQE_BUDGET_TIMEOUT;\n\telse if (bfqq->queued[0] == 0 && bfqq->queued[1] == 0)\n\t\t/*\n\t\t * The queue may not be empty upon timer expiration,\n\t\t * because we may not disable the timer when the\n\t\t * first request of the in-service queue arrives\n\t\t * during disk idling.\n\t\t */\n\t\treason = BFQQE_TOO_IDLE;\n\telse\n\t\tgoto schedule_dispatch;\n\n\tbfq_bfqq_expire(bfqd, bfqq, true, reason);\n\nschedule_dispatch:\n\tspin_unlock_irqrestore(&bfqd->lock, flags);\n\tbfq_schedule_dispatch(bfqd);",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148617,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static void io_async_task_func(struct callback_head *cb)\n{\n\tstruct io_kiocb *req = container_of(cb, struct io_kiocb, task_work);\n\tstruct async_poll *apoll = req->apoll;\n\tstruct io_ring_ctx *ctx = req->ctx;\n\n\ttrace_io_uring_task_run(req->ctx, req->opcode, req->user_data);\n\n\tif (io_poll_rewait(req, &apoll->poll)) {\n\t\tspin_unlock_irq(&ctx->completion_lock);\n\t\treturn;\n\t}\n\n\t/* If req is still hashed, it cannot have been canceled. Don't check. */\n\tif (hash_hashed(&req->hash_node))\n\t\thash_del(&req->hash_node);\n\n\tio_poll_remove_double(req, apoll->double_poll);\n\tspin_unlock_irq(&ctx->completion_lock);\n\n\tif (!READ_ONCE(apoll->poll.canceled))\n\t\t__io_req_task_submit(req);\n\telse\n\t\t__io_req_task_cancel(req, -ECANCELED);\n\n\tkfree(apoll->double_poll);\n\tkfree(apoll);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148636,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static void io_async_task_func(struct callback_head *cb)\n{\n\tstruct io_kiocb *req = container_of(cb, struct io_kiocb, task_work);\n\tstruct async_poll *apoll = req->apoll;\n\tstruct io_ring_ctx *ctx = req->ctx;\n\n\ttrace_io_uring_task_run(req->ctx, req->opcode, req->user_data);\n\n\tif (io_poll_rewait(req, &apoll->poll)) {\n\t\tspin_unlock_irq(&ctx->completion_lock);\n\t\tpercpu_ref_put(&ctx->refs);\n\t\treturn;\n\t}\n\n\t/* If req is still hashed, it cannot have been canceled. Don't check. */\n\tif (hash_hashed(&req->hash_node))\n\t\thash_del(&req->hash_node);\n\n\tio_poll_remove_double(req, apoll->double_poll);\n\tspin_unlock_irq(&ctx->completion_lock);\n\n\tif (!READ_ONCE(apoll->poll.canceled))\n\t\t__io_req_task_submit(req);\n\telse\n\t\t__io_req_task_cancel(req, -ECANCELED);\n\n\tpercpu_ref_put(&ctx->refs);\n\tkfree(apoll->double_poll);\n\tkfree(apoll);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148637,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "void rsi_mac80211_detach(struct rsi_hw *adapter)\n{\n\tstruct ieee80211_hw *hw = adapter->hw;\n\tenum nl80211_band band;\n\n\tif (hw) {\n\t\tieee80211_stop_queues(hw);\n\t\tieee80211_unregister_hw(hw);\n\t\tieee80211_free_hw(hw);\n\t}\n\n\tfor (band = 0; band < NUM_NL80211_BANDS; band++) {\n\t\tstruct ieee80211_supported_band *sband =\n\t\t\t\t\t&adapter->sbands[band];\n\n\t\tkfree(sband->channels);\n\t}\n\n#ifdef CONFIG_RSI_DEBUGFS\n\trsi_remove_dbgfs(adapter);\n\tkfree(adapter->dfsentry);\n#endif\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148664,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "human": "Correct. With CWE-416",
    "reason": "It is vulnerable because it leaves a dangling pointer in adapter->hw."
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "void rsi_mac80211_detach(struct rsi_hw *adapter)\n{\n\tstruct ieee80211_hw *hw = adapter->hw;\n\tenum nl80211_band band;\n\n\tif (hw) {\n\t\tieee80211_stop_queues(hw);\n\t\tieee80211_unregister_hw(hw);\n\t\tieee80211_free_hw(hw);\n\t\tadapter->hw = NULL;\n\t}\n\n\tfor (band = 0; band < NUM_NL80211_BANDS; band++) {\n\t\tstruct ieee80211_supported_band *sband =\n\t\t\t\t\t&adapter->sbands[band];\n\n\t\tkfree(sband->channels);\n\t}\n\n#ifdef CONFIG_RSI_DEBUGFS\n\trsi_remove_dbgfs(adapter);\n\tkfree(adapter->dfsentry);\n#endif\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148665,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "human": "Correct. Without CWE-416"
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "int setup_conds(THD *thd, TABLE_LIST *tables, List<TABLE_LIST> &leaves,\n                COND **conds)\n{\n  SELECT_LEX *select_lex= thd->lex->current_select;\n  TABLE_LIST *table= NULL;\t// For HP compilers\n  /*\n    it_is_update set to TRUE when tables of primary SELECT_LEX (SELECT_LEX\n    which belong to LEX, i.e. most up SELECT) will be updated by\n    INSERT/UPDATE/LOAD\n    NOTE: using this condition helps to prevent call of prepare_check_option()\n    from subquery of VIEW, because tables of subquery belongs to VIEW\n    (see condition before prepare_check_option() call)\n  */\n  bool it_is_update= (select_lex == thd->lex->first_select_lex()) &&\n    thd->lex->which_check_option_applicable();\n  bool save_is_item_list_lookup= select_lex->is_item_list_lookup;\n  TABLE_LIST *derived= select_lex->master_unit()->derived;\n  DBUG_ENTER(\"setup_conds\");\n\n  select_lex->is_item_list_lookup= 0;\n\n  thd->column_usage= MARK_COLUMNS_READ;\n  DBUG_PRINT(\"info\", (\"thd->column_usage: %d\", thd->column_usage));\n  select_lex->cond_count= 0;\n  select_lex->between_count= 0;\n  select_lex->max_equal_elems= 0;\n\n  for (table= tables; table; table= table->next_local)\n  {\n    if (select_lex == thd->lex->first_select_lex() &&\n        select_lex->first_cond_optimization &&\n        table->merged_for_insert &&\n        table->prepare_where(thd, conds, FALSE))\n      goto err_no_arena;\n  }\n\n  if (*conds)\n  {\n    thd->where=\"where clause\";\n    DBUG_EXECUTE(\"where\",\n                 print_where(*conds,\n                             \"WHERE in setup_conds\",\n                             QT_ORDINARY););\n    /*\n      Wrap alone field in WHERE clause in case it will be outer field of subquery\n      which need persistent pointer on it, but conds could be changed by optimizer\n    */\n    if ((*conds)->type() == Item::FIELD_ITEM && !derived)\n      wrap_ident(thd, conds);\n    (*conds)->mark_as_condition_AND_part(NO_JOIN_NEST);\n    if ((*conds)->fix_fields_if_needed_for_bool(thd, conds))\n      goto err_no_arena;\n  }\n\n  /*\n    Apply fix_fields() to all ON clauses at all levels of nesting,\n    including the ones inside view definitions.\n  */\n  if (setup_on_expr(thd, tables, it_is_update))\n    goto err_no_arena;\n\n  if (!thd->stmt_arena->is_conventional())\n  {\n    /*\n      We are in prepared statement preparation code => we should store\n      WHERE clause changing for next executions.\n\n      We do this ON -> WHERE transformation only once per PS/SP statement.\n    */\n    select_lex->where= *conds;\n  }\n  thd->lex->current_select->is_item_list_lookup= save_is_item_list_lookup;\n  DBUG_RETURN(thd->is_error());\n\nerr_no_arena:\n  select_lex->is_item_list_lookup= save_is_item_list_lookup;\n  DBUG_RETURN(1);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148764,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "human": "Correct. With CWE-416",
    "reason": "It is vulnerable to CWE-416 by not restoring resolve_in_select_list, leading to potential Use After Free."
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "int setup_conds(THD *thd, TABLE_LIST *tables, List<TABLE_LIST> &leaves,\n                COND **conds)\n{\n  SELECT_LEX *select_lex= thd->lex->current_select;\n  TABLE_LIST *table= NULL;\t// For HP compilers\n  /*\n    it_is_update set to TRUE when tables of primary SELECT_LEX (SELECT_LEX\n    which belong to LEX, i.e. most up SELECT) will be updated by\n    INSERT/UPDATE/LOAD\n    NOTE: using this condition helps to prevent call of prepare_check_option()\n    from subquery of VIEW, because tables of subquery belongs to VIEW\n    (see condition before prepare_check_option() call)\n  */\n  bool it_is_update= (select_lex == thd->lex->first_select_lex()) &&\n    thd->lex->which_check_option_applicable();\n  bool save_is_item_list_lookup= select_lex->is_item_list_lookup;\n  TABLE_LIST *derived= select_lex->master_unit()->derived;\n  bool save_resolve_in_select_list= select_lex->context.resolve_in_select_list;\n  DBUG_ENTER(\"setup_conds\");\n\n  select_lex->is_item_list_lookup= 0;\n  select_lex->context.resolve_in_select_list= false;\n\n  thd->column_usage= MARK_COLUMNS_READ;\n  DBUG_PRINT(\"info\", (\"thd->column_usage: %d\", thd->column_usage));\n  select_lex->cond_count= 0;\n  select_lex->between_count= 0;\n  select_lex->max_equal_elems= 0;\n\n  for (table= tables; table; table= table->next_local)\n  {\n    if (select_lex == thd->lex->first_select_lex() &&\n        select_lex->first_cond_optimization &&\n        table->merged_for_insert &&\n        table->prepare_where(thd, conds, FALSE))\n      goto err_no_arena;\n  }\n\n  if (*conds)\n  {\n    thd->where=\"where clause\";\n    DBUG_EXECUTE(\"where\",\n                 print_where(*conds,\n                             \"WHERE in setup_conds\",\n                             QT_ORDINARY););\n    /*\n      Wrap alone field in WHERE clause in case it will be outer field of subquery\n      which need persistent pointer on it, but conds could be changed by optimizer\n    */\n    if ((*conds)->type() == Item::FIELD_ITEM && !derived)\n      wrap_ident(thd, conds);\n    (*conds)->mark_as_condition_AND_part(NO_JOIN_NEST);\n    if ((*conds)->fix_fields_if_needed_for_bool(thd, conds))\n      goto err_no_arena;\n  }\n\n  /*\n    Apply fix_fields() to all ON clauses at all levels of nesting,\n    including the ones inside view definitions.\n  */\n  if (setup_on_expr(thd, tables, it_is_update))\n    goto err_no_arena;\n\n  if (!thd->stmt_arena->is_conventional())\n  {\n    /*\n      We are in prepared statement preparation code => we should store\n      WHERE clause changing for next executions.\n\n      We do this ON -> WHERE transformation only once per PS/SP statement.\n    */\n    select_lex->where= *conds;\n  }\n  thd->lex->current_select->is_item_list_lookup= save_is_item_list_lookup;\n  select_lex->context.resolve_in_select_list= save_resolve_in_select_list;\n  DBUG_RETURN(thd->is_error());\n\nerr_no_arena:\n  select_lex->is_item_list_lookup= save_is_item_list_lookup;\n  DBUG_RETURN(1);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148765,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "human": "Correct. Without CWE-416"
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static XMLSharedNodeList* find_impl(xmlXPathContext* ctxt, const string& xpath)\n{\n\txmlXPathObject* result = xmlXPathEval((const xmlChar*)xpath.c_str(), ctxt);\n\n\tif (!result) {\n\t\txmlXPathFreeContext(ctxt);\n\t\txmlFreeDoc(ctxt->doc);\n\n\t\tthrow XMLException(\"Invalid XPath: \" + xpath);\n\t}\n\n\tif (result->type != XPATH_NODESET) {\n\t\txmlXPathFreeObject(result);\n\t\txmlXPathFreeContext(ctxt);\n\t\txmlFreeDoc(ctxt->doc);\n\n\t\tthrow XMLException(\"Only nodeset result types are supported.\");\n\t}\n\n\txmlNodeSet* nodeset = result->nodesetval;\n\tXMLSharedNodeList* nodes = new XMLSharedNodeList();\n\tif (nodeset) {\n\t\tfor (int i = 0; i < nodeset->nodeNr; ++i) {\n\t\t\tXMLNode* node = readnode(nodeset->nodeTab[i]);\n\t\t\tnodes->push_back(boost::shared_ptr<XMLNode>(node));\n\t\t}\n\t} else {\n\t\t// return empty set\n\t}\n\n\txmlXPathFreeObject(result);\n\n\treturn nodes;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148794,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "human": "Correct. With CWE-416",
    "reason": "The code is vulnerable to a use-after-free bug because it frees the xmlXPathContext before accessing its doc member, resulting in dereferencing freed memory."
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static XMLSharedNodeList* find_impl(xmlXPathContext* ctxt, const string& xpath)\n{\n\txmlXPathObject* result = xmlXPathEval((const xmlChar*)xpath.c_str(), ctxt);\n\n\tif (!result) {\n\t\txmlFreeDoc(ctxt->doc);\n\t\txmlXPathFreeContext(ctxt);\n\n\t\tthrow XMLException(\"Invalid XPath: \" + xpath);\n\t}\n\n\tif (result->type != XPATH_NODESET) {\n\t\txmlXPathFreeObject(result);\n\t\txmlFreeDoc(ctxt->doc);\n\t\txmlXPathFreeContext(ctxt);\n\n\t\tthrow XMLException(\"Only nodeset result types are supported.\");\n\t}\n\n\txmlNodeSet* nodeset = result->nodesetval;\n\tXMLSharedNodeList* nodes = new XMLSharedNodeList();\n\tif (nodeset) {\n\t\tfor (int i = 0; i < nodeset->nodeNr; ++i) {\n\t\t\tXMLNode* node = readnode(nodeset->nodeTab[i]);\n\t\t\tnodes->push_back(boost::shared_ptr<XMLNode>(node));\n\t\t}\n\t} else {\n\t\t// return empty set\n\t}\n\n\txmlXPathFreeObject(result);\n\n\treturn nodes;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148795,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "human": "Correct. Without CWE-416"
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static void disk_seqf_stop(struct seq_file *seqf, void *v)\n{\n\tstruct class_dev_iter *iter = seqf->private;\n\n\t/* stop is called even after start failed :-( */\n\tif (iter) {\n\t\tclass_dev_iter_exit(iter);\n\t\tkfree(iter);\n\t}\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149822,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static void disk_seqf_stop(struct seq_file *seqf, void *v)\n{\n\tstruct class_dev_iter *iter = seqf->private;\n\n\t/* stop is called even after start failed :-( */\n\tif (iter) {\n\t\tclass_dev_iter_exit(iter);\n\t\tkfree(iter);\n\t\tseqf->private = NULL;\n\t}\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149823,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "dbd_st_fetch(SV *sth, imp_sth_t* imp_sth)\n{\n  dTHX;\n  int num_fields, ChopBlanks, i, rc;\n  unsigned long *lengths;\n  AV *av;\n  int av_length, av_readonly;\n  MYSQL_ROW cols;\n  D_imp_dbh_from_sth;\n  MYSQL* svsock= imp_dbh->pmysql;\n  imp_sth_fbh_t *fbh;\n  D_imp_xxh(sth);\n#if MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n  MYSQL_BIND *buffer;\n#endif\n  MYSQL_FIELD *fields;\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t-> dbd_st_fetch\\n\");\n\n#if MYSQL_ASYNC\n  if(imp_dbh->async_query_in_flight) {\n      if(mysql_db_async_result(sth, &imp_sth->result) <= 0) {\n        return Nullav;\n      }\n  }\n#endif\n\n#if MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n  if (imp_sth->use_server_side_prepare)\n  {\n    if (!DBIc_ACTIVE(imp_sth) )\n    {\n      do_error(sth, JW_ERR_SEQUENCE, \"no statement executing\\n\",NULL);\n      return Nullav;\n    }\n\n    if (imp_sth->fetch_done)\n    {\n      do_error(sth, JW_ERR_SEQUENCE, \"fetch() but fetch already done\",NULL);\n      return Nullav;\n    }\n\n    if (!imp_sth->done_desc)\n    {\n      if (!dbd_describe(sth, imp_sth))\n      {\n        do_error(sth, JW_ERR_SEQUENCE, \"Error while describe result set.\",\n                 NULL);\n        return Nullav;\n      }\n    }\n  }\n#endif\n\n  ChopBlanks = DBIc_is(imp_sth, DBIcf_ChopBlanks);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                  \"\\t\\tdbd_st_fetch for %p, chopblanks %d\\n\",\n                  sth, ChopBlanks);\n\n  if (!imp_sth->result)\n  {\n    do_error(sth, JW_ERR_SEQUENCE, \"fetch() without execute()\" ,NULL);\n    return Nullav;\n  }\n\n  /* fix from 2.9008 */\n  imp_dbh->pmysql->net.last_errno = 0;\n\n#if MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n  if (imp_sth->use_server_side_prepare)\n  {\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tdbd_st_fetch calling mysql_fetch\\n\");\n\n    if ((rc= mysql_stmt_fetch(imp_sth->stmt)))\n    {\n      if (rc == 1)\n        do_error(sth, mysql_stmt_errno(imp_sth->stmt),\n                 mysql_stmt_error(imp_sth->stmt),\n                mysql_stmt_sqlstate(imp_sth->stmt));\n\n#if MYSQL_VERSION_ID >= MYSQL_VERSION_5_0 \n      if (rc == MYSQL_DATA_TRUNCATED) {\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tdbd_st_fetch data truncated\\n\");\n        goto process;\n      }\n#endif\n\n      if (rc == MYSQL_NO_DATA)\n      {\n        /* Update row_num to affected_rows value */\n        imp_sth->row_num= mysql_stmt_affected_rows(imp_sth->stmt);\n        imp_sth->fetch_done=1;\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tdbd_st_fetch no data\\n\");\n      }\n\n      dbd_st_finish(sth, imp_sth);\n\n      return Nullav;\n    }\n\nprocess:\n    imp_sth->currow++;\n\n    av= DBIc_DBISTATE(imp_sth)->get_fbav(imp_sth);\n    num_fields=mysql_stmt_field_count(imp_sth->stmt);\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                    \"\\t\\tdbd_st_fetch called mysql_fetch, rc %d num_fields %d\\n\",\n                    rc, num_fields);\n\n    for (\n         buffer= imp_sth->buffer,\n         fbh= imp_sth->fbh,\n         i= 0;\n         i < num_fields;\n         i++,\n         fbh++,\n         buffer++\n        )\n    {\n      SV *sv= AvARRAY(av)[i]; /* Note: we (re)use the SV in the AV\t*/\n      STRLEN len;\n\n      /* This is wrong, null is not being set correctly\n       * This is not the way to determine length (this would break blobs!)\n       */\n      if (fbh->is_null)\n        (void) SvOK_off(sv);  /*  Field is NULL, return undef  */\n      else\n      {\n        /* In case of BLOB/TEXT fields we allocate only 8192 bytes\n           in dbd_describe() for data. Here we know real size of field\n           so we should increase buffer size and refetch column value\n        */\n        if (fbh->length > buffer->buffer_length || fbh->error)\n        {\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n              \"\\t\\tRefetch BLOB/TEXT column: %d, length: %lu, error: %d\\n\",\n              i, fbh->length, fbh->error);\n\n          Renew(fbh->data, fbh->length, char);\n          buffer->buffer_length= fbh->length;\n          buffer->buffer= (char *) fbh->data;\n\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2) {\n            int j;\n            int m = MIN(*buffer->length, buffer->buffer_length);\n            char *ptr = (char*)buffer->buffer;\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"\\t\\tbefore buffer->buffer: \");\n            for (j = 0; j < m; j++) {\n              PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"%c\", *ptr++);\n            }\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"\\n\");\n          }\n\n          /*TODO: Use offset instead of 0 to fetch only remain part of data*/\n          if (mysql_stmt_fetch_column(imp_sth->stmt, buffer , i, 0))\n            do_error(sth, mysql_stmt_errno(imp_sth->stmt),\n                     mysql_stmt_error(imp_sth->stmt),\n                     mysql_stmt_sqlstate(imp_sth->stmt));\n\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2) {\n            int j;\n            int m = MIN(*buffer->length, buffer->buffer_length);\n            char *ptr = (char*)buffer->buffer;\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"\\t\\tafter buffer->buffer: \");\n            for (j = 0; j < m; j++) {\n              PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"%c\", *ptr++);\n            }\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"\\n\");\n          }\n        }\n\n        /* This does look a lot like Georg's PHP driver doesn't it?  --Brian */\n        /* Credit due to Georg - mysqli_api.c  ;) --PMG */\n        switch (buffer->buffer_type) {\n        case MYSQL_TYPE_DOUBLE:\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tst_fetch double data %f\\n\", fbh->ddata);\n          sv_setnv(sv, fbh->ddata);\n          break;\n\n        case MYSQL_TYPE_LONG:\n        case MYSQL_TYPE_LONGLONG:\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tst_fetch int data %\"IVdf\", unsigned? %d\\n\",\n                          fbh->ldata, buffer->is_unsigned);\n          if (buffer->is_unsigned)\n            sv_setuv(sv, fbh->ldata);\n          else\n            sv_setiv(sv, fbh->ldata);\n\n          break;\n\n        case MYSQL_TYPE_BIT:\n          sv_setpvn(sv, fbh->data, fbh->length);\n\n          break;\n\n        default:\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tERROR IN st_fetch_string\");\n          len= fbh->length;\n\t  /* ChopBlanks server-side prepared statement */\n          if (ChopBlanks)\n          {\n            /* \n              see bottom of:\n              http://www.mysql.org/doc/refman/5.0/en/c-api-datatypes.html\n            */\n            if (fbh->charsetnr != 63)\n              while (len && fbh->data[len-1] == ' ') { --len; }\n          }\n\t  /* END OF ChopBlanks */\n\n          sv_setpvn(sv, fbh->data, len);\n\n\t/* UTF8 */\n        /*HELMUT*/\n#if defined(sv_utf8_decode) && MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n\n#if MYSQL_VERSION_ID >= FIELD_CHARSETNR_VERSION \n  /* SHOW COLLATION WHERE Id = 63; -- 63 == charset binary, collation binary */\n        if ((imp_dbh->enable_utf8 || imp_dbh->enable_utf8mb4) && fbh->charsetnr != 63)\n#else\n\tif ((imp_dbh->enable_utf8 || imp_dbh->enable_utf8mb4) && !(fbh->flags & BINARY_FLAG))\n#endif\n\t  sv_utf8_decode(sv);\n#endif\n\t/* END OF UTF8 */\n          break;\n\n        }\n\n      }\n    }\n\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_fetch, %d cols\\n\", num_fields);\n\n    return av;\n  }\n  else\n  {\n#endif\n\n    imp_sth->currow++;\n\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    {\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tdbd_st_fetch result set details\\n\");\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\timp_sth->result=%p\\n\", imp_sth->result);\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tmysql_num_fields=%u\\n\",\n                    mysql_num_fields(imp_sth->result));\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tmysql_num_rows=%llu\\n\",\n                    mysql_num_rows(imp_sth->result));\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tmysql_affected_rows=%llu\\n\",\n                    mysql_affected_rows(imp_dbh->pmysql));\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tdbd_st_fetch for %p, currow= %d\\n\",\n                    sth,imp_sth->currow);\n    }\n\n    if (!(cols= mysql_fetch_row(imp_sth->result)))\n    {\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      {\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tdbd_st_fetch, no more rows to fetch\");\n      }\n      if (mysql_errno(imp_dbh->pmysql))\n        do_error(sth, mysql_errno(imp_dbh->pmysql),\n                 mysql_error(imp_dbh->pmysql),\n                 mysql_sqlstate(imp_dbh->pmysql));\n\n\n#if MYSQL_VERSION_ID >= MULTIPLE_RESULT_SET_VERSION\n      if (!mysql_more_results(svsock))\n#endif\n        dbd_st_finish(sth, imp_sth);\n      return Nullav;\n    }\n\n    num_fields= mysql_num_fields(imp_sth->result);\n    fields= mysql_fetch_fields(imp_sth->result);\n    lengths= mysql_fetch_lengths(imp_sth->result);\n\n    if ((av= DBIc_FIELDS_AV(imp_sth)) != Nullav)\n    {\n      av_length= av_len(av)+1;\n\n      if (av_length != num_fields)              /* Resize array if necessary */\n      {\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_fetch, size of results array(%d) != num_fields(%d)\\n\",\n                                   av_length, num_fields);\n\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_fetch, result fields(%d)\\n\",\n                                   DBIc_NUM_FIELDS(imp_sth));\n\n        av_readonly = SvREADONLY(av);\n\n        if (av_readonly)\n          SvREADONLY_off( av );              /* DBI sets this readonly */\n\n        while (av_length < num_fields)\n        {\n          av_store(av, av_length++, newSV(0));\n        }\n\n        while (av_length > num_fields)\n        {\n          SvREFCNT_dec(av_pop(av));\n          av_length--;\n        }\n        if (av_readonly)\n          SvREADONLY_on(av);\n      }\n    }\n\n    av= DBIc_DBISTATE(imp_sth)->get_fbav(imp_sth);\n\n    for (i= 0;  i < num_fields; ++i)\n    {\n      char *col= cols[i];\n      SV *sv= AvARRAY(av)[i]; /* Note: we (re)use the SV in the AV\t*/\n\n      if (col)\n      {\n        STRLEN len= lengths[i];\n        if (ChopBlanks)\n        {\n          while (len && col[len-1] == ' ')\n          {\t--len; }\n        }\n\n        /* Set string value returned from mysql server */\n        sv_setpvn(sv, col, len);\n\n        switch (mysql_to_perl_type(fields[i].type)) {\n        case MYSQL_TYPE_DOUBLE:\n          /* Coerce to dobule and set scalar as NV */\n          (void) SvNV(sv);\n          SvNOK_only(sv);\n          break;\n\n        case MYSQL_TYPE_LONG:\n        case MYSQL_TYPE_LONGLONG:\n          /* Coerce to integer and set scalar as UV resp. IV */\n          if (fields[i].flags & UNSIGNED_FLAG)\n          {\n            (void) SvUV(sv);\n            SvIOK_only_UV(sv);\n          }\n          else\n          {\n            (void) SvIV(sv);\n            SvIOK_only(sv);\n          }\n          break;\n\n#if MYSQL_VERSION_ID > NEW_DATATYPE_VERSION\n        case MYSQL_TYPE_BIT:\n          /* Let it as binary string */\n          break;\n#endif\n\n        default:\n\t/* UTF8 */\n        /*HELMUT*/\n#if defined(sv_utf8_decode) && MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n\n  /* see bottom of: http://www.mysql.org/doc/refman/5.0/en/c-api-datatypes.html */\n        if ((imp_dbh->enable_utf8 || imp_dbh->enable_utf8mb4) && fields[i].charsetnr != 63)\n\t  sv_utf8_decode(sv);\n#endif\n\t/* END OF UTF8 */\n          break;\n        }\n      }\n      else\n        (void) SvOK_off(sv);  /*  Field is NULL, return undef  */\n    }\n\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_fetch, %d cols\\n\", num_fields);\n    return av;\n\n#if MYSQL_VERSION_ID  >= SERVER_PREPARE_VERSION\n  }\n#endif\n\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149824,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "dbd_st_fetch(SV *sth, imp_sth_t* imp_sth)\n{\n  dTHX;\n  int num_fields, ChopBlanks, i, rc;\n  unsigned long *lengths;\n  AV *av;\n  int av_length, av_readonly;\n  MYSQL_ROW cols;\n  D_imp_dbh_from_sth;\n  MYSQL* svsock= imp_dbh->pmysql;\n  imp_sth_fbh_t *fbh;\n  D_imp_xxh(sth);\n#if MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n  MYSQL_BIND *buffer;\n#endif\n  MYSQL_FIELD *fields;\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t-> dbd_st_fetch\\n\");\n\n#if MYSQL_ASYNC\n  if(imp_dbh->async_query_in_flight) {\n      if(mysql_db_async_result(sth, &imp_sth->result) <= 0) {\n        return Nullav;\n      }\n  }\n#endif\n\n#if MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n  if (imp_sth->use_server_side_prepare)\n  {\n    if (!DBIc_ACTIVE(imp_sth) )\n    {\n      do_error(sth, JW_ERR_SEQUENCE, \"no statement executing\\n\",NULL);\n      return Nullav;\n    }\n\n    if (imp_sth->fetch_done)\n    {\n      do_error(sth, JW_ERR_SEQUENCE, \"fetch() but fetch already done\",NULL);\n      return Nullav;\n    }\n\n    if (!imp_sth->done_desc)\n    {\n      if (!dbd_describe(sth, imp_sth))\n      {\n        do_error(sth, JW_ERR_SEQUENCE, \"Error while describe result set.\",\n                 NULL);\n        return Nullav;\n      }\n    }\n  }\n#endif\n\n  ChopBlanks = DBIc_is(imp_sth, DBIcf_ChopBlanks);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                  \"\\t\\tdbd_st_fetch for %p, chopblanks %d\\n\",\n                  sth, ChopBlanks);\n\n  if (!imp_sth->result)\n  {\n    do_error(sth, JW_ERR_SEQUENCE, \"fetch() without execute()\" ,NULL);\n    return Nullav;\n  }\n\n  /* fix from 2.9008 */\n  imp_dbh->pmysql->net.last_errno = 0;\n\n#if MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n  if (imp_sth->use_server_side_prepare)\n  {\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tdbd_st_fetch calling mysql_fetch\\n\");\n\n    if ((rc= mysql_stmt_fetch(imp_sth->stmt)))\n    {\n      if (rc == 1)\n        do_error(sth, mysql_stmt_errno(imp_sth->stmt),\n                 mysql_stmt_error(imp_sth->stmt),\n                mysql_stmt_sqlstate(imp_sth->stmt));\n\n#if MYSQL_VERSION_ID >= MYSQL_VERSION_5_0 \n      if (rc == MYSQL_DATA_TRUNCATED) {\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tdbd_st_fetch data truncated\\n\");\n        goto process;\n      }\n#endif\n\n      if (rc == MYSQL_NO_DATA)\n      {\n        /* Update row_num to affected_rows value */\n        imp_sth->row_num= mysql_stmt_affected_rows(imp_sth->stmt);\n        imp_sth->fetch_done=1;\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tdbd_st_fetch no data\\n\");\n      }\n\n      dbd_st_finish(sth, imp_sth);\n\n      return Nullav;\n    }\n\nprocess:\n    imp_sth->currow++;\n\n    av= DBIc_DBISTATE(imp_sth)->get_fbav(imp_sth);\n    num_fields=mysql_stmt_field_count(imp_sth->stmt);\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                    \"\\t\\tdbd_st_fetch called mysql_fetch, rc %d num_fields %d\\n\",\n                    rc, num_fields);\n\n    for (\n         buffer= imp_sth->buffer,\n         fbh= imp_sth->fbh,\n         i= 0;\n         i < num_fields;\n         i++,\n         fbh++,\n         buffer++\n        )\n    {\n      SV *sv= AvARRAY(av)[i]; /* Note: we (re)use the SV in the AV\t*/\n      STRLEN len;\n\n      /* This is wrong, null is not being set correctly\n       * This is not the way to determine length (this would break blobs!)\n       */\n      if (fbh->is_null)\n        (void) SvOK_off(sv);  /*  Field is NULL, return undef  */\n      else\n      {\n        /* In case of BLOB/TEXT fields we allocate only 8192 bytes\n           in dbd_describe() for data. Here we know real size of field\n           so we should increase buffer size and refetch column value\n        */\n        if (fbh->length > buffer->buffer_length || fbh->error)\n        {\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n              \"\\t\\tRefetch BLOB/TEXT column: %d, length: %lu, error: %d\\n\",\n              i, fbh->length, fbh->error);\n\n          Renew(fbh->data, fbh->length, char);\n          buffer->buffer_length= fbh->length;\n          buffer->buffer= (char *) fbh->data;\n          imp_sth->stmt->bind[i].buffer_length = fbh->length;\n          imp_sth->stmt->bind[i].buffer = (char *)fbh->data;\n\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2) {\n            int j;\n            int m = MIN(*buffer->length, buffer->buffer_length);\n            char *ptr = (char*)buffer->buffer;\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"\\t\\tbefore buffer->buffer: \");\n            for (j = 0; j < m; j++) {\n              PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"%c\", *ptr++);\n            }\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"\\n\");\n          }\n\n          /*TODO: Use offset instead of 0 to fetch only remain part of data*/\n          if (mysql_stmt_fetch_column(imp_sth->stmt, buffer , i, 0))\n            do_error(sth, mysql_stmt_errno(imp_sth->stmt),\n                     mysql_stmt_error(imp_sth->stmt),\n                     mysql_stmt_sqlstate(imp_sth->stmt));\n\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2) {\n            int j;\n            int m = MIN(*buffer->length, buffer->buffer_length);\n            char *ptr = (char*)buffer->buffer;\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"\\t\\tafter buffer->buffer: \");\n            for (j = 0; j < m; j++) {\n              PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"%c\", *ptr++);\n            }\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"\\n\");\n          }\n        }\n\n        /* This does look a lot like Georg's PHP driver doesn't it?  --Brian */\n        /* Credit due to Georg - mysqli_api.c  ;) --PMG */\n        switch (buffer->buffer_type) {\n        case MYSQL_TYPE_DOUBLE:\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tst_fetch double data %f\\n\", fbh->ddata);\n          sv_setnv(sv, fbh->ddata);\n          break;\n\n        case MYSQL_TYPE_LONG:\n        case MYSQL_TYPE_LONGLONG:\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tst_fetch int data %\"IVdf\", unsigned? %d\\n\",\n                          fbh->ldata, buffer->is_unsigned);\n          if (buffer->is_unsigned)\n            sv_setuv(sv, fbh->ldata);\n          else\n            sv_setiv(sv, fbh->ldata);\n\n          break;\n\n        case MYSQL_TYPE_BIT:\n          sv_setpvn(sv, fbh->data, fbh->length);\n\n          break;\n\n        default:\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tERROR IN st_fetch_string\");\n          len= fbh->length;\n\t  /* ChopBlanks server-side prepared statement */\n          if (ChopBlanks)\n          {\n            /* \n              see bottom of:\n              http://www.mysql.org/doc/refman/5.0/en/c-api-datatypes.html\n            */\n            if (fbh->charsetnr != 63)\n              while (len && fbh->data[len-1] == ' ') { --len; }\n          }\n\t  /* END OF ChopBlanks */\n\n          sv_setpvn(sv, fbh->data, len);\n\n\t/* UTF8 */\n        /*HELMUT*/\n#if defined(sv_utf8_decode) && MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n\n#if MYSQL_VERSION_ID >= FIELD_CHARSETNR_VERSION \n  /* SHOW COLLATION WHERE Id = 63; -- 63 == charset binary, collation binary */\n        if ((imp_dbh->enable_utf8 || imp_dbh->enable_utf8mb4) && fbh->charsetnr != 63)\n#else\n\tif ((imp_dbh->enable_utf8 || imp_dbh->enable_utf8mb4) && !(fbh->flags & BINARY_FLAG))\n#endif\n\t  sv_utf8_decode(sv);\n#endif\n\t/* END OF UTF8 */\n          break;\n\n        }\n\n      }\n    }\n\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_fetch, %d cols\\n\", num_fields);\n\n    return av;\n  }\n  else\n  {\n#endif\n\n    imp_sth->currow++;\n\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    {\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tdbd_st_fetch result set details\\n\");\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\timp_sth->result=%p\\n\", imp_sth->result);\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tmysql_num_fields=%u\\n\",\n                    mysql_num_fields(imp_sth->result));\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tmysql_num_rows=%llu\\n\",\n                    mysql_num_rows(imp_sth->result));\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tmysql_affected_rows=%llu\\n\",\n                    mysql_affected_rows(imp_dbh->pmysql));\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tdbd_st_fetch for %p, currow= %d\\n\",\n                    sth,imp_sth->currow);\n    }\n\n    if (!(cols= mysql_fetch_row(imp_sth->result)))\n    {\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      {\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tdbd_st_fetch, no more rows to fetch\");\n      }\n      if (mysql_errno(imp_dbh->pmysql))\n        do_error(sth, mysql_errno(imp_dbh->pmysql),\n                 mysql_error(imp_dbh->pmysql),\n                 mysql_sqlstate(imp_dbh->pmysql));\n\n\n#if MYSQL_VERSION_ID >= MULTIPLE_RESULT_SET_VERSION\n      if (!mysql_more_results(svsock))\n#endif\n        dbd_st_finish(sth, imp_sth);\n      return Nullav;\n    }\n\n    num_fields= mysql_num_fields(imp_sth->result);\n    fields= mysql_fetch_fields(imp_sth->result);\n    lengths= mysql_fetch_lengths(imp_sth->result);\n\n    if ((av= DBIc_FIELDS_AV(imp_sth)) != Nullav)\n    {\n      av_length= av_len(av)+1;\n\n      if (av_length != num_fields)              /* Resize array if necessary */\n      {\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_fetch, size of results array(%d) != num_fields(%d)\\n\",\n                                   av_length, num_fields);\n\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_fetch, result fields(%d)\\n\",\n                                   DBIc_NUM_FIELDS(imp_sth));\n\n        av_readonly = SvREADONLY(av);\n\n        if (av_readonly)\n          SvREADONLY_off( av );              /* DBI sets this readonly */\n\n        while (av_length < num_fields)\n        {\n          av_store(av, av_length++, newSV(0));\n        }\n\n        while (av_length > num_fields)\n        {\n          SvREFCNT_dec(av_pop(av));\n          av_length--;\n        }\n        if (av_readonly)\n          SvREADONLY_on(av);\n      }\n    }\n\n    av= DBIc_DBISTATE(imp_sth)->get_fbav(imp_sth);\n\n    for (i= 0;  i < num_fields; ++i)\n    {\n      char *col= cols[i];\n      SV *sv= AvARRAY(av)[i]; /* Note: we (re)use the SV in the AV\t*/\n\n      if (col)\n      {\n        STRLEN len= lengths[i];\n        if (ChopBlanks)\n        {\n          while (len && col[len-1] == ' ')\n          {\t--len; }\n        }\n\n        /* Set string value returned from mysql server */\n        sv_setpvn(sv, col, len);\n\n        switch (mysql_to_perl_type(fields[i].type)) {\n        case MYSQL_TYPE_DOUBLE:\n          /* Coerce to dobule and set scalar as NV */\n          (void) SvNV(sv);\n          SvNOK_only(sv);\n          break;\n\n        case MYSQL_TYPE_LONG:\n        case MYSQL_TYPE_LONGLONG:\n          /* Coerce to integer and set scalar as UV resp. IV */\n          if (fields[i].flags & UNSIGNED_FLAG)\n          {\n            (void) SvUV(sv);\n            SvIOK_only_UV(sv);\n          }\n          else\n          {\n            (void) SvIV(sv);\n            SvIOK_only(sv);\n          }\n          break;\n\n#if MYSQL_VERSION_ID > NEW_DATATYPE_VERSION\n        case MYSQL_TYPE_BIT:\n          /* Let it as binary string */\n          break;\n#endif\n\n        default:\n\t/* UTF8 */\n        /*HELMUT*/\n#if defined(sv_utf8_decode) && MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n\n  /* see bottom of: http://www.mysql.org/doc/refman/5.0/en/c-api-datatypes.html */\n        if ((imp_dbh->enable_utf8 || imp_dbh->enable_utf8mb4) && fields[i].charsetnr != 63)\n\t  sv_utf8_decode(sv);\n#endif\n\t/* END OF UTF8 */\n          break;\n        }\n      }\n      else\n        (void) SvOK_off(sv);  /*  Field is NULL, return undef  */\n    }\n\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_fetch, %d cols\\n\", num_fields);\n    return av;\n\n#if MYSQL_VERSION_ID  >= SERVER_PREPARE_VERSION\n  }\n#endif\n\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149825,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "int sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)\n{\n\tstruct sctp_association *asoc = sctp_id2assoc(sk, id);\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct socket *sock;\n\tint err = 0;\n\n\tif (!asoc)\n\t\treturn -EINVAL;\n\n\t/* If there is a thread waiting on more sndbuf space for\n\t * sending on this asoc, it cannot be peeled.\n\t */\n\tif (waitqueue_active(&asoc->wait))\n\t\treturn -EBUSY;\n\n\t/* An association cannot be branched off from an already peeled-off\n\t * socket, nor is this supported for tcp style sockets.\n\t */\n\tif (!sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\t/* Create a new socket.  */\n\terr = sock_create(sk->sk_family, SOCK_SEQPACKET, IPPROTO_SCTP, &sock);\n\tif (err < 0)\n\t\treturn err;\n\n\tsctp_copy_sock(sock->sk, sk, asoc);\n\n\t/* Make peeled-off sockets more like 1-1 accepted sockets.\n\t * Set the daddr and initialize id to something more random\n\t */\n\tsp->pf->to_sk_daddr(&asoc->peer.primary_addr, sk);\n\n\t/* Populate the fields of the newsk from the oldsk and migrate the\n\t * asoc to the newsk.\n\t */\n\tsctp_sock_migrate(sk, sock->sk, asoc, SCTP_SOCKET_UDP_HIGH_BANDWIDTH);\n\n\t*sockp = sock;\n\n\treturn err;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149828,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "int sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)\n{\n\tstruct sctp_association *asoc = sctp_id2assoc(sk, id);\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct socket *sock;\n\tint err = 0;\n\n\t/* Do not peel off from one netns to another one. */\n\tif (!net_eq(current->nsproxy->net_ns, sock_net(sk)))\n\t\treturn -EINVAL;\n\n\tif (!asoc)\n\t\treturn -EINVAL;\n\n\t/* If there is a thread waiting on more sndbuf space for\n\t * sending on this asoc, it cannot be peeled.\n\t */\n\tif (waitqueue_active(&asoc->wait))\n\t\treturn -EBUSY;\n\n\t/* An association cannot be branched off from an already peeled-off\n\t * socket, nor is this supported for tcp style sockets.\n\t */\n\tif (!sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\t/* Create a new socket.  */\n\terr = sock_create(sk->sk_family, SOCK_SEQPACKET, IPPROTO_SCTP, &sock);\n\tif (err < 0)\n\t\treturn err;\n\n\tsctp_copy_sock(sock->sk, sk, asoc);\n\n\t/* Make peeled-off sockets more like 1-1 accepted sockets.\n\t * Set the daddr and initialize id to something more random\n\t */\n\tsp->pf->to_sk_daddr(&asoc->peer.primary_addr, sk);\n\n\t/* Populate the fields of the newsk from the oldsk and migrate the\n\t * asoc to the newsk.\n\t */\n\tsctp_sock_migrate(sk, sock->sk, asoc, SCTP_SOCKET_UDP_HIGH_BANDWIDTH);\n\n\t*sockp = sock;\n\n\treturn err;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149829,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "AP_CORE_DECLARE_NONSTD(const char *) ap_limit_section(cmd_parms *cmd,\n                                                      void *dummy,\n                                                      const char *arg)\n{\n    const char *endp = ap_strrchr_c(arg, '>');\n    const char *limited_methods;\n    void *tog = cmd->cmd->cmd_data;\n    apr_int64_t limited = 0;\n    apr_int64_t old_limited = cmd->limited;\n    const char *errmsg;\n\n    if (endp == NULL) {\n        return unclosed_directive(cmd);\n    }\n\n    limited_methods = apr_pstrmemdup(cmd->temp_pool, arg, endp - arg);\n\n    if (!limited_methods[0]) {\n        return missing_container_arg(cmd);\n    }\n\n    while (limited_methods[0]) {\n        char *method = ap_getword_conf(cmd->temp_pool, &limited_methods);\n        int methnum;\n\n        /* check for builtin or module registered method number */\n        methnum = ap_method_number_of(method);\n\n        if (methnum == M_TRACE && !tog) {\n            return \"TRACE cannot be controlled by <Limit>, see TraceEnable\";\n        }\n        else if (methnum == M_INVALID) {\n            /* method has not been registered yet, but resource restriction\n             * is always checked before method handling, so register it.\n             */\n            methnum = ap_method_register(cmd->pool,\n                                         apr_pstrdup(cmd->pool, method));\n        }\n\n        limited |= (AP_METHOD_BIT << methnum);\n    }\n\n    /* Killing two features with one function,\n     * if (tog == NULL) <Limit>, else <LimitExcept>\n     */\n    limited = tog ? ~limited : limited;\n\n    if (!(old_limited & limited)) {\n        return apr_pstrcat(cmd->pool, cmd->cmd->name,\n                           \"> directive excludes all methods\", NULL);\n    }\n    else if ((old_limited & limited) == old_limited) {\n        return apr_pstrcat(cmd->pool, cmd->cmd->name,\n                           \"> directive specifies methods already excluded\",\n                           NULL);\n    }\n\n    cmd->limited &= limited;\n\n    errmsg = ap_walk_config(cmd->directive->first_child, cmd, cmd->context);\n\n    cmd->limited = old_limited;\n\n    return errmsg;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149830,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "AP_CORE_DECLARE_NONSTD(const char *) ap_limit_section(cmd_parms *cmd,\n                                                      void *dummy,\n                                                      const char *arg)\n{\n    const char *endp = ap_strrchr_c(arg, '>');\n    const char *limited_methods;\n    void *tog = cmd->cmd->cmd_data;\n    apr_int64_t limited = 0;\n    apr_int64_t old_limited = cmd->limited;\n    const char *errmsg;\n\n    if (endp == NULL) {\n        return unclosed_directive(cmd);\n    }\n\n    limited_methods = apr_pstrmemdup(cmd->temp_pool, arg, endp - arg);\n\n    if (!limited_methods[0]) {\n        return missing_container_arg(cmd);\n    }\n\n    while (limited_methods[0]) {\n        char *method = ap_getword_conf(cmd->temp_pool, &limited_methods);\n        int methnum;\n\n        /* check for builtin or module registered method number */\n        methnum = ap_method_number_of(method);\n\n        if (methnum == M_TRACE && !tog) {\n            return \"TRACE cannot be controlled by <Limit>, see TraceEnable\";\n        }\n        else if (methnum == M_INVALID) {\n            /* method has not been registered yet, but resource restriction\n             * is always checked before method handling, so register it.\n             */\n            if (cmd->pool == cmd->temp_pool) {\n                /* In .htaccess, we can't globally register new methods. */\n                return apr_psprintf(cmd->pool, \"Could not register method '%s' \"\n                                   \"for %s from .htaccess configuration\",\n                                    method, cmd->cmd->name);\n            }\n            methnum = ap_method_register(cmd->pool,\n                                         apr_pstrdup(cmd->pool, method));\n        }\n\n        limited |= (AP_METHOD_BIT << methnum);\n    }\n\n    /* Killing two features with one function,\n     * if (tog == NULL) <Limit>, else <LimitExcept>\n     */\n    limited = tog ? ~limited : limited;\n\n    if (!(old_limited & limited)) {\n        return apr_pstrcat(cmd->pool, cmd->cmd->name,\n                           \"> directive excludes all methods\", NULL);\n    }\n    else if ((old_limited & limited) == old_limited) {\n        return apr_pstrcat(cmd->pool, cmd->cmd->name,\n                           \"> directive specifies methods already excluded\",\n                           NULL);\n    }\n\n    cmd->limited &= limited;\n\n    errmsg = ap_walk_config(cmd->directive->first_child, cmd, cmd->context);\n\n    cmd->limited = old_limited;\n\n    return errmsg;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149831,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "PHP_MINIT_FUNCTION(spl_array)\n{\n\tREGISTER_SPL_STD_CLASS_EX(ArrayObject, spl_array_object_new, spl_funcs_ArrayObject);\n\tREGISTER_SPL_IMPLEMENTS(ArrayObject, Aggregate);\n\tREGISTER_SPL_IMPLEMENTS(ArrayObject, ArrayAccess);\n\tREGISTER_SPL_IMPLEMENTS(ArrayObject, Serializable);\n\tREGISTER_SPL_IMPLEMENTS(ArrayObject, Countable);\n\tmemcpy(&spl_handler_ArrayObject, zend_get_std_object_handlers(), sizeof(zend_object_handlers));\n\n\tspl_handler_ArrayObject.clone_obj = spl_array_object_clone;\n\tspl_handler_ArrayObject.read_dimension = spl_array_read_dimension;\n\tspl_handler_ArrayObject.write_dimension = spl_array_write_dimension;\n\tspl_handler_ArrayObject.unset_dimension = spl_array_unset_dimension;\n\tspl_handler_ArrayObject.has_dimension = spl_array_has_dimension;\n\tspl_handler_ArrayObject.count_elements = spl_array_object_count_elements;\n\n\tspl_handler_ArrayObject.get_properties = spl_array_get_properties;\n\tspl_handler_ArrayObject.get_debug_info = spl_array_get_debug_info;\n\tspl_handler_ArrayObject.get_gc = spl_array_get_gc;\n\tspl_handler_ArrayObject.read_property = spl_array_read_property;\n\tspl_handler_ArrayObject.write_property = spl_array_write_property;\n\tspl_handler_ArrayObject.get_property_ptr_ptr = spl_array_get_property_ptr_ptr;\n\tspl_handler_ArrayObject.has_property = spl_array_has_property;\n\tspl_handler_ArrayObject.unset_property = spl_array_unset_property;\n\n\tspl_handler_ArrayObject.compare_objects = spl_array_compare_objects;\n\n\tREGISTER_SPL_STD_CLASS_EX(ArrayIterator, spl_array_object_new, spl_funcs_ArrayIterator);\n\tREGISTER_SPL_IMPLEMENTS(ArrayIterator, Iterator);\n\tREGISTER_SPL_IMPLEMENTS(ArrayIterator, ArrayAccess);\n\tREGISTER_SPL_IMPLEMENTS(ArrayIterator, SeekableIterator);\n\tREGISTER_SPL_IMPLEMENTS(ArrayIterator, Serializable);\n\tREGISTER_SPL_IMPLEMENTS(ArrayIterator, Countable);\n\tmemcpy(&spl_handler_ArrayIterator, &spl_handler_ArrayObject, sizeof(zend_object_handlers));\n\tspl_ce_ArrayIterator->get_iterator = spl_array_get_iterator;\n\n\tREGISTER_SPL_SUB_CLASS_EX(RecursiveArrayIterator, ArrayIterator, spl_array_object_new, spl_funcs_RecursiveArrayIterator);\n\tREGISTER_SPL_IMPLEMENTS(RecursiveArrayIterator, RecursiveIterator);\n\tspl_ce_RecursiveArrayIterator->get_iterator = spl_array_get_iterator;\n\n\tREGISTER_SPL_CLASS_CONST_LONG(ArrayObject,   \"STD_PROP_LIST\",    SPL_ARRAY_STD_PROP_LIST);\n\tREGISTER_SPL_CLASS_CONST_LONG(ArrayObject,   \"ARRAY_AS_PROPS\",   SPL_ARRAY_ARRAY_AS_PROPS);\n\n\tREGISTER_SPL_CLASS_CONST_LONG(ArrayIterator, \"STD_PROP_LIST\",    SPL_ARRAY_STD_PROP_LIST);\n\tREGISTER_SPL_CLASS_CONST_LONG(ArrayIterator, \"ARRAY_AS_PROPS\",   SPL_ARRAY_ARRAY_AS_PROPS);\n\n\tREGISTER_SPL_CLASS_CONST_LONG(RecursiveArrayIterator, \"CHILD_ARRAYS_ONLY\", SPL_ARRAY_CHILD_ARRAYS_ONLY);\n\n\treturn SUCCESS;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149863,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": " */\nstatic int wddx_stack_destroy(wddx_stack *stack)\n{\n\tregister int i;\n\n\tif (stack->elements) {\n\t\tfor (i = 0; i < stack->top; i++) {\n\t\t\tif (((st_entry *)stack->elements[i])->data\n\t\t\t\t\t&& ((st_entry *)stack->elements[i])->type != ST_FIELD)\t{\n\t\t\t\tzval_ptr_dtor(&((st_entry *)stack->elements[i])->data);\n\t\t\t}\n\t\t\tif (((st_entry *)stack->elements[i])->varname) {\n\t\t\t\tefree(((st_entry *)stack->elements[i])->varname);\n\t\t\t}\n\t\t\tefree(stack->elements[i]);\n\t\t}\n\t\tefree(stack->elements);\n\t}\n\treturn SUCCESS;",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149867,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static PHP_MINIT_FUNCTION(zip)\n{\n#ifdef PHP_ZIP_USE_OO\n\tzend_class_entry ce;\n\n\tmemcpy(&zip_object_handlers, zend_get_std_object_handlers(), sizeof(zend_object_handlers));\n\tzip_object_handlers.clone_obj\t\t= NULL;\n\tzip_object_handlers.get_property_ptr_ptr = php_zip_get_property_ptr_ptr;\n\n\tzip_object_handlers.get_gc          = php_zip_get_gc;\n\tzip_object_handlers.get_properties = php_zip_get_properties;\n\tzip_object_handlers.read_property\t= php_zip_read_property;\n\tzip_object_handlers.has_property\t= php_zip_has_property;\n\n\tINIT_CLASS_ENTRY(ce, \"ZipArchive\", zip_class_functions);\n\tce.create_object = php_zip_object_new;\n\tzip_class_entry = zend_register_internal_class(&ce TSRMLS_CC);\n\n\tzend_hash_init(&zip_prop_handlers, 0, NULL, NULL, 1);\n\tphp_zip_register_prop_handler(&zip_prop_handlers, \"status\",    php_zip_status, NULL, NULL, IS_LONG TSRMLS_CC);\n\tphp_zip_register_prop_handler(&zip_prop_handlers, \"statusSys\", php_zip_status_sys, NULL, NULL, IS_LONG TSRMLS_CC);\n\tphp_zip_register_prop_handler(&zip_prop_handlers, \"numFiles\",  php_zip_get_num_files, NULL, NULL, IS_LONG TSRMLS_CC);\n\tphp_zip_register_prop_handler(&zip_prop_handlers, \"filename\", NULL, NULL, php_zipobj_get_filename, IS_STRING TSRMLS_CC);\n\tphp_zip_register_prop_handler(&zip_prop_handlers, \"comment\", NULL, php_zipobj_get_zip_comment, NULL, IS_STRING TSRMLS_CC);\n\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CREATE\", ZIP_CREATE);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"EXCL\", ZIP_EXCL);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CHECKCONS\", ZIP_CHECKCONS);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OVERWRITE\", ZIP_OVERWRITE);\n\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"FL_NOCASE\", ZIP_FL_NOCASE);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"FL_NODIR\", ZIP_FL_NODIR);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"FL_COMPRESSED\", ZIP_FL_COMPRESSED);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"FL_UNCHANGED\", ZIP_FL_UNCHANGED);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_DEFAULT\", ZIP_CM_DEFAULT);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_STORE\", ZIP_CM_STORE);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_SHRINK\", ZIP_CM_SHRINK);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_REDUCE_1\", ZIP_CM_REDUCE_1);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_REDUCE_2\", ZIP_CM_REDUCE_2);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_REDUCE_3\", ZIP_CM_REDUCE_3);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_REDUCE_4\", ZIP_CM_REDUCE_4);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_IMPLODE\", ZIP_CM_IMPLODE);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_DEFLATE\", ZIP_CM_DEFLATE);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_DEFLATE64\", ZIP_CM_DEFLATE64);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_PKWARE_IMPLODE\", ZIP_CM_PKWARE_IMPLODE);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_BZIP2\", ZIP_CM_BZIP2);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_LZMA\", ZIP_CM_LZMA);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_TERSE\", ZIP_CM_TERSE);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_LZ77\", ZIP_CM_LZ77);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_WAVPACK\", ZIP_CM_WAVPACK);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_PPMD\", ZIP_CM_PPMD);\n\n\t/* Error code */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_OK\",\t\t\tZIP_ER_OK);\t\t\t/* N No error */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_MULTIDISK\",\tZIP_ER_MULTIDISK);\t/* N Multi-disk zip archives not supported */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_RENAME\",\t\tZIP_ER_RENAME);\t\t/* S Renaming temporary file failed */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_CLOSE\",\t\tZIP_ER_CLOSE);\t\t/* S Closing zip archive failed */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_SEEK\",\t\tZIP_ER_SEEK);\t\t/* S Seek error */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_READ\",\t\tZIP_ER_READ);\t\t/* S Read error */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_WRITE\",\t\tZIP_ER_WRITE);\t\t/* S Write error */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_CRC\",\t\t\tZIP_ER_CRC);\t\t/* N CRC error */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_ZIPCLOSED\",\tZIP_ER_ZIPCLOSED);\t/* N Containing zip archive was closed */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_NOENT\",\t\tZIP_ER_NOENT);\t\t/* N No such file */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_EXISTS\",\t\tZIP_ER_EXISTS);\t\t/* N File already exists */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_OPEN\",\t\tZIP_ER_OPEN);\t\t/* S Can't open file */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_TMPOPEN\",\t\tZIP_ER_TMPOPEN);\t/* S Failure to create temporary file */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_ZLIB\",\t\tZIP_ER_ZLIB);\t\t/* Z Zlib error */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_MEMORY\",\t\tZIP_ER_MEMORY);\t\t/* N Malloc failure */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_CHANGED\",\t\tZIP_ER_CHANGED);\t/* N Entry has been changed */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_COMPNOTSUPP\",\tZIP_ER_COMPNOTSUPP);/* N Compression method not supported */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_EOF\",\t\t\tZIP_ER_EOF);\t\t/* N Premature EOF */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_INVAL\",\t\tZIP_ER_INVAL);\t\t/* N Invalid argument */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_NOZIP\",\t\tZIP_ER_NOZIP);\t\t/* N Not a zip archive */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_INTERNAL\",\tZIP_ER_INTERNAL);\t/* N Internal error */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_INCONS\",\t\tZIP_ER_INCONS);\t\t/* N Zip archive inconsistent */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_REMOVE\",\t\tZIP_ER_REMOVE);\t\t/* S Can't remove file */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_DELETED\",  \tZIP_ER_DELETED);\t/* N Entry has been deleted */\n\n\tphp_register_url_stream_wrapper(\"zip\", &php_stream_zip_wrapper TSRMLS_CC);\n#endif\n\n\tle_zip_dir   = zend_register_list_destructors_ex(php_zip_free_dir,   NULL, le_zip_dir_name,   module_number);\n\tle_zip_entry = zend_register_list_destructors_ex(php_zip_free_entry, NULL, le_zip_entry_name, module_number);\n\n\treturn SUCCESS;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149875,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "mrb_io_initialize_copy(mrb_state *mrb, mrb_value copy)\n{\n  mrb_value orig;\n  mrb_value buf;\n  struct mrb_io *fptr_copy;\n  struct mrb_io *fptr_orig;\n  mrb_bool failed = TRUE;\n\n  mrb_get_args(mrb, \"o\", &orig);\n  fptr_copy = (struct mrb_io *)DATA_PTR(copy);\n  if (fptr_copy != NULL) {\n    fptr_finalize(mrb, fptr_copy, FALSE);\n    mrb_free(mrb, fptr_copy);\n  }\n  fptr_copy = (struct mrb_io *)mrb_io_alloc(mrb);\n  fptr_orig = io_get_open_fptr(mrb, orig);\n\n  DATA_TYPE(copy) = &mrb_io_type;\n  DATA_PTR(copy) = fptr_copy;\n\n  buf = mrb_iv_get(mrb, orig, mrb_intern_cstr(mrb, \"@buf\"));\n  mrb_iv_set(mrb, copy, mrb_intern_cstr(mrb, \"@buf\"), buf);\n\n  fptr_copy->fd = mrb_dup(mrb, fptr_orig->fd, &failed);\n  if (failed) {\n    mrb_sys_fail(mrb, 0);\n  }\n  mrb_fd_cloexec(mrb, fptr_copy->fd);\n\n  if (fptr_orig->fd2 != -1) {\n    fptr_copy->fd2 = mrb_dup(mrb, fptr_orig->fd2, &failed);\n    if (failed) {\n      close(fptr_copy->fd);\n      mrb_sys_fail(mrb, 0);\n    }\n    mrb_fd_cloexec(mrb, fptr_copy->fd2);\n  }\n\n  fptr_copy->pid = fptr_orig->pid;\n  fptr_copy->readable = fptr_orig->readable;\n  fptr_copy->writable = fptr_orig->writable;\n  fptr_copy->sync = fptr_orig->sync;\n  fptr_copy->is_socket = fptr_orig->is_socket;\n\n  return copy;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149932,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "mrb_io_initialize_copy(mrb_state *mrb, mrb_value copy)\n{\n  mrb_value orig;\n  mrb_value buf;\n  struct mrb_io *fptr_copy;\n  struct mrb_io *fptr_orig;\n  mrb_bool failed = TRUE;\n\n  mrb_get_args(mrb, \"o\", &orig);\n  fptr_orig = io_get_open_fptr(mrb, orig);\n  fptr_copy = (struct mrb_io *)DATA_PTR(copy);\n  if (fptr_copy != NULL) {\n    fptr_finalize(mrb, fptr_copy, FALSE);\n    mrb_free(mrb, fptr_copy);\n  }\n  fptr_copy = (struct mrb_io *)mrb_io_alloc(mrb);\n\n  DATA_TYPE(copy) = &mrb_io_type;\n  DATA_PTR(copy) = fptr_copy;\n\n  buf = mrb_iv_get(mrb, orig, mrb_intern_cstr(mrb, \"@buf\"));\n  mrb_iv_set(mrb, copy, mrb_intern_cstr(mrb, \"@buf\"), buf);\n\n  fptr_copy->fd = mrb_dup(mrb, fptr_orig->fd, &failed);\n  if (failed) {\n    mrb_sys_fail(mrb, 0);\n  }\n  mrb_fd_cloexec(mrb, fptr_copy->fd);\n\n  if (fptr_orig->fd2 != -1) {\n    fptr_copy->fd2 = mrb_dup(mrb, fptr_orig->fd2, &failed);\n    if (failed) {\n      close(fptr_copy->fd);\n      mrb_sys_fail(mrb, 0);\n    }\n    mrb_fd_cloexec(mrb, fptr_copy->fd2);\n  }\n\n  fptr_copy->pid = fptr_orig->pid;\n  fptr_copy->readable = fptr_orig->readable;\n  fptr_copy->writable = fptr_orig->writable;\n  fptr_copy->sync = fptr_orig->sync;\n  fptr_copy->is_socket = fptr_orig->is_socket;\n\n  return copy;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149933,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "SMB2_write(const unsigned int xid, struct cifs_io_parms *io_parms,\n\t   unsigned int *nbytes, struct kvec *iov, int n_vec)\n{\n\tstruct smb_rqst rqst;\n\tint rc = 0;\n\tstruct smb2_write_req *req = NULL;\n\tstruct smb2_write_rsp *rsp = NULL;\n\tint resp_buftype;\n\tstruct kvec rsp_iov;\n\tint flags = 0;\n\tunsigned int total_len;\n\n\t*nbytes = 0;\n\n\tif (n_vec < 1)\n\t\treturn rc;\n\n\trc = smb2_plain_req_init(SMB2_WRITE, io_parms->tcon, (void **) &req,\n\t\t\t     &total_len);\n\tif (rc)\n\t\treturn rc;\n\n\tif (io_parms->tcon->ses->server == NULL)\n\t\treturn -ECONNABORTED;\n\n\tif (smb3_encryption_required(io_parms->tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\treq->sync_hdr.ProcessId = cpu_to_le32(io_parms->pid);\n\n\treq->PersistentFileId = io_parms->persistent_fid;\n\treq->VolatileFileId = io_parms->volatile_fid;\n\treq->WriteChannelInfoOffset = 0;\n\treq->WriteChannelInfoLength = 0;\n\treq->Channel = 0;\n\treq->Length = cpu_to_le32(io_parms->length);\n\treq->Offset = cpu_to_le64(io_parms->offset);\n\treq->DataOffset = cpu_to_le16(\n\t\t\t\toffsetof(struct smb2_write_req, Buffer));\n\treq->RemainingBytes = 0;\n\n\ttrace_smb3_write_enter(xid, io_parms->persistent_fid,\n\t\tio_parms->tcon->tid, io_parms->tcon->ses->Suid,\n\t\tio_parms->offset, io_parms->length);\n\n\tiov[0].iov_base = (char *)req;\n\t/* 1 for Buffer */\n\tiov[0].iov_len = total_len - 1;\n\n\tmemset(&rqst, 0, sizeof(struct smb_rqst));\n\trqst.rq_iov = iov;\n\trqst.rq_nvec = n_vec + 1;\n\n\trc = cifs_send_recv(xid, io_parms->tcon->ses, &rqst,\n\t\t\t    &resp_buftype, flags, &rsp_iov);\n\tcifs_small_buf_release(req);\n\trsp = (struct smb2_write_rsp *)rsp_iov.iov_base;\n\n\tif (rc) {\n\t\ttrace_smb3_write_err(xid, req->PersistentFileId,\n\t\t\t\t     io_parms->tcon->tid,\n\t\t\t\t     io_parms->tcon->ses->Suid,\n\t\t\t\t     io_parms->offset, io_parms->length, rc);\n\t\tcifs_stats_fail_inc(io_parms->tcon, SMB2_WRITE_HE);\n\t\tcifs_dbg(VFS, \"Send error in write = %d\\n\", rc);\n\t} else {\n\t\t*nbytes = le32_to_cpu(rsp->DataLength);\n\t\ttrace_smb3_write_done(xid, req->PersistentFileId,\n\t\t\t\t     io_parms->tcon->tid,\n\t\t\t\t     io_parms->tcon->ses->Suid,\n\t\t\t\t     io_parms->offset, *nbytes);\n\t}\n\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149934,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "SMB2_write(const unsigned int xid, struct cifs_io_parms *io_parms,\n\t   unsigned int *nbytes, struct kvec *iov, int n_vec)\n{\n\tstruct smb_rqst rqst;\n\tint rc = 0;\n\tstruct smb2_write_req *req = NULL;\n\tstruct smb2_write_rsp *rsp = NULL;\n\tint resp_buftype;\n\tstruct kvec rsp_iov;\n\tint flags = 0;\n\tunsigned int total_len;\n\n\t*nbytes = 0;\n\n\tif (n_vec < 1)\n\t\treturn rc;\n\n\trc = smb2_plain_req_init(SMB2_WRITE, io_parms->tcon, (void **) &req,\n\t\t\t     &total_len);\n\tif (rc)\n\t\treturn rc;\n\n\tif (io_parms->tcon->ses->server == NULL)\n\t\treturn -ECONNABORTED;\n\n\tif (smb3_encryption_required(io_parms->tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\treq->sync_hdr.ProcessId = cpu_to_le32(io_parms->pid);\n\n\treq->PersistentFileId = io_parms->persistent_fid;\n\treq->VolatileFileId = io_parms->volatile_fid;\n\treq->WriteChannelInfoOffset = 0;\n\treq->WriteChannelInfoLength = 0;\n\treq->Channel = 0;\n\treq->Length = cpu_to_le32(io_parms->length);\n\treq->Offset = cpu_to_le64(io_parms->offset);\n\treq->DataOffset = cpu_to_le16(\n\t\t\t\toffsetof(struct smb2_write_req, Buffer));\n\treq->RemainingBytes = 0;\n\n\ttrace_smb3_write_enter(xid, io_parms->persistent_fid,\n\t\tio_parms->tcon->tid, io_parms->tcon->ses->Suid,\n\t\tio_parms->offset, io_parms->length);\n\n\tiov[0].iov_base = (char *)req;\n\t/* 1 for Buffer */\n\tiov[0].iov_len = total_len - 1;\n\n\tmemset(&rqst, 0, sizeof(struct smb_rqst));\n\trqst.rq_iov = iov;\n\trqst.rq_nvec = n_vec + 1;\n\n\trc = cifs_send_recv(xid, io_parms->tcon->ses, &rqst,\n\t\t\t    &resp_buftype, flags, &rsp_iov);\n\trsp = (struct smb2_write_rsp *)rsp_iov.iov_base;\n\n\tif (rc) {\n\t\ttrace_smb3_write_err(xid, req->PersistentFileId,\n\t\t\t\t     io_parms->tcon->tid,\n\t\t\t\t     io_parms->tcon->ses->Suid,\n\t\t\t\t     io_parms->offset, io_parms->length, rc);\n\t\tcifs_stats_fail_inc(io_parms->tcon, SMB2_WRITE_HE);\n\t\tcifs_dbg(VFS, \"Send error in write = %d\\n\", rc);\n\t} else {\n\t\t*nbytes = le32_to_cpu(rsp->DataLength);\n\t\ttrace_smb3_write_done(xid, req->PersistentFileId,\n\t\t\t\t     io_parms->tcon->tid,\n\t\t\t\t     io_parms->tcon->ses->Suid,\n\t\t\t\t     io_parms->offset, *nbytes);\n\t}\n\n\tcifs_small_buf_release(req);\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149935,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static bool __oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)\n{\n\tstruct mmu_gather tlb;\n\tstruct vm_area_struct *vma;\n\tbool ret = true;\n\n\t/*\n\t * We have to make sure to not race with the victim exit path\n\t * and cause premature new oom victim selection:\n\t * __oom_reap_task_mm\t\texit_mm\n\t *   mmget_not_zero\n\t *\t\t\t\t  mmput\n\t *\t\t\t\t    atomic_dec_and_test\n\t *\t\t\t\t  exit_oom_victim\n\t *\t\t\t\t[...]\n\t *\t\t\t\tout_of_memory\n\t *\t\t\t\t  select_bad_process\n\t *\t\t\t\t    # no TIF_MEMDIE task selects new victim\n\t *  unmap_page_range # frees some memory\n\t */\n\tmutex_lock(&oom_lock);\n\n\tif (!down_read_trylock(&mm->mmap_sem)) {\n\t\tret = false;\n\t\ttrace_skip_task_reaping(tsk->pid);\n\t\tgoto unlock_oom;\n\t}\n\n\t/*\n\t * If the mm has notifiers then we would need to invalidate them around\n\t * unmap_page_range and that is risky because notifiers can sleep and\n\t * what they do is basically undeterministic.  So let's have a short\n\t * sleep to give the oom victim some more time.\n\t * TODO: we really want to get rid of this ugly hack and make sure that\n\t * notifiers cannot block for unbounded amount of time and add\n\t * mmu_notifier_invalidate_range_{start,end} around unmap_page_range\n\t */\n\tif (mm_has_notifiers(mm)) {\n\t\tup_read(&mm->mmap_sem);\n\t\tschedule_timeout_idle(HZ);\n\t\tgoto unlock_oom;\n\t}\n\n\t/*\n\t * MMF_OOM_SKIP is set by exit_mmap when the OOM reaper can't\n\t * work on the mm anymore. The check for MMF_OOM_SKIP must run\n\t * under mmap_sem for reading because it serializes against the\n\t * down_write();up_write() cycle in exit_mmap().\n\t */\n\tif (test_bit(MMF_OOM_SKIP, &mm->flags)) {\n\t\tup_read(&mm->mmap_sem);\n\t\ttrace_skip_task_reaping(tsk->pid);\n\t\tgoto unlock_oom;\n\t}\n\n\ttrace_start_task_reaping(tsk->pid);\n\n\t/*\n\t * Tell all users of get_user/copy_from_user etc... that the content\n\t * is no longer stable. No barriers really needed because unmapping\n\t * should imply barriers already and the reader would hit a page fault\n\t * if it stumbled over a reaped memory.\n\t */\n\tset_bit(MMF_UNSTABLE, &mm->flags);\n\n\ttlb_gather_mmu(&tlb, mm, 0, -1);\n\tfor (vma = mm->mmap ; vma; vma = vma->vm_next) {\n\t\tif (!can_madv_dontneed_vma(vma))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Only anonymous pages have a good chance to be dropped\n\t\t * without additional steps which we cannot afford as we\n\t\t * are OOM already.\n\t\t *\n\t\t * We do not even care about fs backed pages because all\n\t\t * which are reclaimable have already been reclaimed and\n\t\t * we do not want to block exit_mmap by keeping mm ref\n\t\t * count elevated without a good reason.\n\t\t */\n\t\tif (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED))\n\t\t\tunmap_page_range(&tlb, vma, vma->vm_start, vma->vm_end,\n\t\t\t\t\t NULL);\n\t}\n\ttlb_finish_mmu(&tlb, 0, -1);\n\tpr_info(\"oom_reaper: reaped process %d (%s), now anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\\n\",\n\t\t\ttask_pid_nr(tsk), tsk->comm,\n\t\t\tK(get_mm_counter(mm, MM_ANONPAGES)),\n\t\t\tK(get_mm_counter(mm, MM_FILEPAGES)),\n\t\t\tK(get_mm_counter(mm, MM_SHMEMPAGES)));\n\tup_read(&mm->mmap_sem);\n\n\ttrace_finish_task_reaping(tsk->pid);\nunlock_oom:\n\tmutex_unlock(&oom_lock);\n\treturn ret;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 150348,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static bool __oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)\n{\n\tstruct mmu_gather tlb;\n\tstruct vm_area_struct *vma;\n\tbool ret = true;\n\n\t/*\n\t * We have to make sure to not race with the victim exit path\n\t * and cause premature new oom victim selection:\n\t * __oom_reap_task_mm\t\texit_mm\n\t *   mmget_not_zero\n\t *\t\t\t\t  mmput\n\t *\t\t\t\t    atomic_dec_and_test\n\t *\t\t\t\t  exit_oom_victim\n\t *\t\t\t\t[...]\n\t *\t\t\t\tout_of_memory\n\t *\t\t\t\t  select_bad_process\n\t *\t\t\t\t    # no TIF_MEMDIE task selects new victim\n\t *  unmap_page_range # frees some memory\n\t */\n\tmutex_lock(&oom_lock);\n\n\tif (!down_read_trylock(&mm->mmap_sem)) {\n\t\tret = false;\n\t\ttrace_skip_task_reaping(tsk->pid);\n\t\tgoto unlock_oom;\n\t}\n\n\t/*\n\t * If the mm has notifiers then we would need to invalidate them around\n\t * unmap_page_range and that is risky because notifiers can sleep and\n\t * what they do is basically undeterministic.  So let's have a short\n\t * sleep to give the oom victim some more time.\n\t * TODO: we really want to get rid of this ugly hack and make sure that\n\t * notifiers cannot block for unbounded amount of time and add\n\t * mmu_notifier_invalidate_range_{start,end} around unmap_page_range\n\t */\n\tif (mm_has_notifiers(mm)) {\n\t\tup_read(&mm->mmap_sem);\n\t\tschedule_timeout_idle(HZ);\n\t\tgoto unlock_oom;\n\t}\n\n\t/*\n\t * MMF_OOM_SKIP is set by exit_mmap when the OOM reaper can't\n\t * work on the mm anymore. The check for MMF_OOM_SKIP must run\n\t * under mmap_sem for reading because it serializes against the\n\t * down_write();up_write() cycle in exit_mmap().\n\t */\n\tif (test_bit(MMF_OOM_SKIP, &mm->flags)) {\n\t\tup_read(&mm->mmap_sem);\n\t\ttrace_skip_task_reaping(tsk->pid);\n\t\tgoto unlock_oom;\n\t}\n\n\ttrace_start_task_reaping(tsk->pid);\n\n\t/*\n\t * Tell all users of get_user/copy_from_user etc... that the content\n\t * is no longer stable. No barriers really needed because unmapping\n\t * should imply barriers already and the reader would hit a page fault\n\t * if it stumbled over a reaped memory.\n\t */\n\tset_bit(MMF_UNSTABLE, &mm->flags);\n\n\tfor (vma = mm->mmap ; vma; vma = vma->vm_next) {\n\t\tif (!can_madv_dontneed_vma(vma))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Only anonymous pages have a good chance to be dropped\n\t\t * without additional steps which we cannot afford as we\n\t\t * are OOM already.\n\t\t *\n\t\t * We do not even care about fs backed pages because all\n\t\t * which are reclaimable have already been reclaimed and\n\t\t * we do not want to block exit_mmap by keeping mm ref\n\t\t * count elevated without a good reason.\n\t\t */\n\t\tif (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED)) {\n\t\t\ttlb_gather_mmu(&tlb, mm, vma->vm_start, vma->vm_end);\n\t\t\tunmap_page_range(&tlb, vma, vma->vm_start, vma->vm_end,\n\t\t\t\t\t NULL);\n\t\t\ttlb_finish_mmu(&tlb, vma->vm_start, vma->vm_end);\n\t\t}\n\t}\n\tpr_info(\"oom_reaper: reaped process %d (%s), now anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\\n\",\n\t\t\ttask_pid_nr(tsk), tsk->comm,\n\t\t\tK(get_mm_counter(mm, MM_ANONPAGES)),\n\t\t\tK(get_mm_counter(mm, MM_FILEPAGES)),\n\t\t\tK(get_mm_counter(mm, MM_SHMEMPAGES)));\n\tup_read(&mm->mmap_sem);\n\n\ttrace_finish_task_reaping(tsk->pid);\nunlock_oom:\n\tmutex_unlock(&oom_lock);\n\treturn ret;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 150349,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static void gf_m2ts_process_pat(GF_M2TS_Demuxer *ts, GF_M2TS_SECTION_ES *ses, GF_List *sections, u8 table_id, u16 ex_table_id, u8 version_number, u8 last_section_number, u32 status)\n{\n\tGF_M2TS_Program *prog;\n\tGF_M2TS_SECTION_ES *pmt;\n\tu32 i, nb_progs, evt_type;\n\tu32 nb_sections;\n\tu32 data_size;\n\tunsigned char *data;\n\tGF_M2TS_Section *section;\n\n\t/*wait for the last section */\n\tif (!(status&GF_M2TS_TABLE_END)) return;\n\n\t/*skip if already received*/\n\tif (status&GF_M2TS_TABLE_REPEAT) {\n\t\tif (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_PAT_REPEAT, NULL);\n\t\treturn;\n\t}\n\n\tnb_sections = gf_list_count(sections);\n\tif (nb_sections > 1) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"PAT on multiple sections not supported\\n\"));\n\t}\n\n\tsection = (GF_M2TS_Section *)gf_list_get(sections, 0);\n\tdata = section->data;\n\tdata_size = section->data_size;\n\n\tif (!(status&GF_M2TS_TABLE_UPDATE) && gf_list_count(ts->programs)) {\n\t\tif (ts->pat->demux_restarted) {\n\t\t\tts->pat->demux_restarted = 0;\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Multiple different PAT on single TS found, ignoring new PAT declaration (table id %d - extended table id %d)\\n\", table_id, ex_table_id));\n\t\t}\n\t\treturn;\n\t}\n\tnb_progs = data_size / 4;\n\n\tfor (i=0; i<nb_progs; i++) {\n\t\tu16 number, pid;\n\t\tnumber = (data[0]<<8) | data[1];\n\t\tpid = (data[2]&0x1f)<<8 | data[3];\n\t\tdata += 4;\n\t\tif (number==0) {\n\t\t\tif (!ts->nit) {\n\t\t\t\tts->nit = gf_m2ts_section_filter_new(gf_m2ts_process_nit, 0);\n\t\t\t}\n\t\t} else {\n\t\t\tGF_SAFEALLOC(prog, GF_M2TS_Program);\n\t\t\tif (!prog) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Fail to allocate program for pid %d\\n\", pid));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tprog->streams = gf_list_new();\n\t\t\tprog->pmt_pid = pid;\n\t\t\tprog->number = number;\n\t\t\tprog->ts = ts;\n\t\t\tgf_list_add(ts->programs, prog);\n\t\t\tGF_SAFEALLOC(pmt, GF_M2TS_SECTION_ES);\n\t\t\tif (!pmt) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Fail to allocate pmt filter for pid %d\\n\", pid));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tpmt->flags = GF_M2TS_ES_IS_SECTION;\n\t\t\tgf_list_add(prog->streams, pmt);\n\t\t\tpmt->pid = prog->pmt_pid;\n\t\t\tpmt->program = prog;\n\t\t\tts->ess[pmt->pid] = (GF_M2TS_ES *)pmt;\n\t\t\tpmt->sec = gf_m2ts_section_filter_new(gf_m2ts_process_pmt, 0);\n\t\t}\n\t}\n\n\tevt_type = (status&GF_M2TS_TABLE_UPDATE) ? GF_M2TS_EVT_PAT_UPDATE : GF_M2TS_EVT_PAT_FOUND;\n\tif (ts->on_event) ts->on_event(ts, evt_type, NULL);\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 150350,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static void gf_m2ts_process_pat(GF_M2TS_Demuxer *ts, GF_M2TS_SECTION_ES *ses, GF_List *sections, u8 table_id, u16 ex_table_id, u8 version_number, u8 last_section_number, u32 status)\n{\n\tGF_M2TS_Program *prog;\n\tGF_M2TS_SECTION_ES *pmt;\n\tu32 i, nb_progs, evt_type;\n\tu32 nb_sections;\n\tu32 data_size;\n\tunsigned char *data;\n\tGF_M2TS_Section *section;\n\n\t/*wait for the last section */\n\tif (!(status&GF_M2TS_TABLE_END)) return;\n\n\t/*skip if already received*/\n\tif (status&GF_M2TS_TABLE_REPEAT) {\n\t\tif (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_PAT_REPEAT, NULL);\n\t\treturn;\n\t}\n\n\tnb_sections = gf_list_count(sections);\n\tif (nb_sections > 1) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"PAT on multiple sections not supported\\n\"));\n\t}\n\n\tsection = (GF_M2TS_Section *)gf_list_get(sections, 0);\n\tdata = section->data;\n\tdata_size = section->data_size;\n\n\tif (!(status&GF_M2TS_TABLE_UPDATE) && gf_list_count(ts->programs)) {\n\t\tif (ts->pat->demux_restarted) {\n\t\t\tts->pat->demux_restarted = 0;\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Multiple different PAT on single TS found, ignoring new PAT declaration (table id %d - extended table id %d)\\n\", table_id, ex_table_id));\n\t\t}\n\t\treturn;\n\t}\n\tnb_progs = data_size / 4;\n\n\tfor (i=0; i<nb_progs; i++) {\n\t\tu16 number, pid;\n\t\tnumber = (data[0]<<8) | data[1];\n\t\tpid = (data[2]&0x1f)<<8 | data[3];\n\t\tdata += 4;\n\t\tif (number==0) {\n\t\t\tif (!ts->nit) {\n\t\t\t\tts->nit = gf_m2ts_section_filter_new(gf_m2ts_process_nit, 0);\n\t\t\t}\n\t\t} else if (!pid) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Broken PAT found reserved PID 0, ignoring\\n\", pid));\n\t\t} else if (! ts->ess[pid]) {\n\t\t\tGF_SAFEALLOC(prog, GF_M2TS_Program);\n\t\t\tif (!prog) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Fail to allocate program for pid %d\\n\", pid));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tprog->streams = gf_list_new();\n\t\t\tprog->pmt_pid = pid;\n\t\t\tprog->number = number;\n\t\t\tprog->ts = ts;\n\t\t\tgf_list_add(ts->programs, prog);\n\t\t\tGF_SAFEALLOC(pmt, GF_M2TS_SECTION_ES);\n\t\t\tif (!pmt) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Fail to allocate pmt filter for pid %d\\n\", pid));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tpmt->flags = GF_M2TS_ES_IS_SECTION;\n\t\t\tgf_list_add(prog->streams, pmt);\n\t\t\tpmt->pid = prog->pmt_pid;\n\t\t\tpmt->program = prog;\n\t\t\tts->ess[pmt->pid] = (GF_M2TS_ES *)pmt;\n\t\t\tpmt->sec = gf_m2ts_section_filter_new(gf_m2ts_process_pmt, 0);\n\t\t}\n\t}\n\n\tevt_type = (status&GF_M2TS_TABLE_UPDATE) ? GF_M2TS_EVT_PAT_UPDATE : GF_M2TS_EVT_PAT_FOUND;\n\tif (ts->on_event) ts->on_event(ts, evt_type, NULL);\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 150351,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static Image *ReadPWPImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  FILE\n    *file;\n\n  Image\n    *image,\n    *next_image,\n    *pwp_image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    c,\n    unique_file;\n\n  MagickBooleanType\n    status;\n\n  register Image\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    filesize,\n    length;\n\n  ssize_t\n    count;\n\n  unsigned char\n    magick[MaxTextExtent];\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  pwp_image=AcquireImage(image_info);\n  image=pwp_image;\n  status=OpenBlob(image_info,pwp_image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return((Image *) NULL);\n  count=ReadBlob(pwp_image,5,magick);\n  if ((count != 5) || (LocaleNCompare((char *) magick,\"SFW95\",5) != 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  read_info=CloneImageInfo(image_info);\n  (void) SetImageInfoProgressMonitor(read_info,(MagickProgressMonitor) NULL,\n    (void *) NULL);\n  SetImageInfoBlob(read_info,(void *) NULL,0);\n  unique_file=AcquireUniqueFileResource(read_info->filename);\n  for ( ; ; )\n  {\n    for (c=ReadBlobByte(pwp_image); c != EOF; c=ReadBlobByte(pwp_image))\n    {\n      for (i=0; i < 17; i++)\n        magick[i]=magick[i+1];\n      magick[17]=(unsigned char) c;\n      if (LocaleNCompare((char *) (magick+12),\"SFW94A\",6) == 0)\n        break;\n    }\n    if (c == EOF)\n      break;\n    if (LocaleNCompare((char *) (magick+12),\"SFW94A\",6) != 0)\n      {\n        (void) RelinquishUniqueFileResource(read_info->filename);\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n    /*\n      Dump SFW image to a temporary file.\n    */\n    file=(FILE *) NULL;\n    if (unique_file != -1)\n      file=fdopen(unique_file,\"wb\");\n    if ((unique_file == -1) || (file == (FILE *) NULL))\n      {\n        (void) RelinquishUniqueFileResource(read_info->filename);\n        ThrowFileException(exception,FileOpenError,\"UnableToWriteFile\",\n          image->filename);\n        image=DestroyImageList(image);\n        return((Image *) NULL);\n      }\n    length=fwrite(\"SFW94A\",1,6,file);\n    (void) length;\n    filesize=65535UL*magick[2]+256L*magick[1]+magick[0];\n    for (i=0; i < (ssize_t) filesize; i++)\n    {\n      c=ReadBlobByte(pwp_image);\n      (void) fputc(c,file);\n    }\n    (void) fclose(file);\n    next_image=ReadImage(read_info,exception);\n    if (next_image == (Image *) NULL)\n      break;\n    (void) FormatLocaleString(next_image->filename,MaxTextExtent,\n      \"slide_%02ld.sfw\",(long) next_image->scene);\n    if (image == (Image *) NULL)\n      image=next_image;\n    else\n      {\n        /*\n          Link image into image list.\n        */\n        for (p=image; p->next != (Image *) NULL; p=GetNextImageInList(p)) ;\n        next_image->previous=p;\n        next_image->scene=p->scene+1;\n        p->next=next_image;\n      }\n    if (image_info->number_scenes != 0)\n      if (next_image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageProgress(image,LoadImagesTag,TellBlob(pwp_image),\n      GetBlobSize(pwp_image));\n    if (status == MagickFalse)\n      break;\n  }\n  if (unique_file != -1)\n    (void) close(unique_file);\n  (void) RelinquishUniqueFileResource(read_info->filename);\n  read_info=DestroyImageInfo(read_info);\n  (void) CloseBlob(pwp_image);\n  pwp_image=DestroyImage(pwp_image);\n  if (EOFBlob(image) != MagickFalse)\n    {\n      char\n        *message;\n\n      message=GetExceptionMessage(errno);\n      (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,\n        \"UnexpectedEndOfFile\",\"`%s': %s\",image->filename,message);\n      message=DestroyString(message);\n    }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 150352,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static Image *ReadPWPImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  FILE\n    *file;\n\n  Image\n    *image,\n    *next_image,\n    *pwp_image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    c,\n    unique_file;\n\n  MagickBooleanType\n    status;\n\n  register Image\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    filesize,\n    length;\n\n  ssize_t\n    count;\n\n  unsigned char\n    magick[MaxTextExtent];\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  pwp_image=AcquireImage(image_info);\n  image=pwp_image;\n  status=OpenBlob(image_info,pwp_image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return((Image *) NULL);\n  count=ReadBlob(pwp_image,5,magick);\n  if ((count != 5) || (LocaleNCompare((char *) magick,\"SFW95\",5) != 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  read_info=CloneImageInfo(image_info);\n  (void) SetImageInfoProgressMonitor(read_info,(MagickProgressMonitor) NULL,\n    (void *) NULL);\n  SetImageInfoBlob(read_info,(void *) NULL,0);\n  unique_file=AcquireUniqueFileResource(read_info->filename);\n  for ( ; ; )\n  {\n    for (c=ReadBlobByte(pwp_image); c != EOF; c=ReadBlobByte(pwp_image))\n    {\n      for (i=0; i < 17; i++)\n        magick[i]=magick[i+1];\n      magick[17]=(unsigned char) c;\n      if (LocaleNCompare((char *) (magick+12),\"SFW94A\",6) == 0)\n        break;\n    }\n    if (c == EOF)\n      break;\n    if (LocaleNCompare((char *) (magick+12),\"SFW94A\",6) != 0)\n      {\n        (void) RelinquishUniqueFileResource(read_info->filename);\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n    /*\n      Dump SFW image to a temporary file.\n    */\n    file=(FILE *) NULL;\n    if (unique_file != -1)\n      file=fdopen(unique_file,\"wb\");\n    if ((unique_file == -1) || (file == (FILE *) NULL))\n      {\n        (void) RelinquishUniqueFileResource(read_info->filename);\n        ThrowFileException(exception,FileOpenError,\"UnableToWriteFile\",\n          image->filename);\n        image=DestroyImageList(image);\n        return((Image *) NULL);\n      }\n    length=fwrite(\"SFW94A\",1,6,file);\n    (void) length;\n    filesize=65535UL*magick[2]+256L*magick[1]+magick[0];\n    for (i=0; i < (ssize_t) filesize; i++)\n    {\n      c=ReadBlobByte(pwp_image);\n      (void) fputc(c,file);\n    }\n    (void) fclose(file);\n    next_image=ReadImage(read_info,exception);\n    if (next_image == (Image *) NULL)\n      break;\n    (void) FormatLocaleString(next_image->filename,MaxTextExtent,\n      \"slide_%02ld.sfw\",(long) next_image->scene);\n    if (image == (Image *) NULL)\n      image=next_image;\n    else\n      {\n        /*\n          Link image into image list.\n        */\n        for (p=image; p->next != (Image *) NULL; p=GetNextImageInList(p)) ;\n        next_image->previous=p;\n        next_image->scene=p->scene+1;\n        p->next=next_image;\n      }\n    if (image_info->number_scenes != 0)\n      if (next_image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageProgress(image,LoadImagesTag,TellBlob(pwp_image),\n      GetBlobSize(pwp_image));\n    if (status == MagickFalse)\n      break;\n  }\n  if (unique_file != -1)\n    (void) close(unique_file);\n  (void) RelinquishUniqueFileResource(read_info->filename);\n  read_info=DestroyImageInfo(read_info);\n  if (EOFBlob(image) != MagickFalse)\n    {\n      char\n        *message;\n\n      message=GetExceptionMessage(errno);\n      (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,\n        \"UnexpectedEndOfFile\",\"`%s': %s\",image->filename,message);\n      message=DestroyString(message);\n    }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 150353,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "struct sk_buff *skb_segment(struct sk_buff *head_skb,\n\t\t\t    netdev_features_t features)\n{\n\tstruct sk_buff *segs = NULL;\n\tstruct sk_buff *tail = NULL;\n\tstruct sk_buff *list_skb = skb_shinfo(head_skb)->frag_list;\n\tskb_frag_t *frag = skb_shinfo(head_skb)->frags;\n\tunsigned int mss = skb_shinfo(head_skb)->gso_size;\n\tunsigned int doffset = head_skb->data - skb_mac_header(head_skb);\n\tunsigned int offset = doffset;\n\tunsigned int tnl_hlen = skb_tnl_header_len(head_skb);\n\tunsigned int headroom;\n\tunsigned int len;\n\t__be16 proto;\n\tbool csum;\n\tint sg = !!(features & NETIF_F_SG);\n\tint nfrags = skb_shinfo(head_skb)->nr_frags;\n\tint err = -ENOMEM;\n\tint i = 0;\n\tint pos;\n\n\tproto = skb_network_protocol(head_skb);\n\tif (unlikely(!proto))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tcsum = !!can_checksum_protocol(features, proto);\n\t__skb_push(head_skb, doffset);\n\theadroom = skb_headroom(head_skb);\n\tpos = skb_headlen(head_skb);\n\n\tdo {\n\t\tstruct sk_buff *nskb;\n\t\tskb_frag_t *nskb_frag;\n\t\tint hsize;\n\t\tint size;\n\n\t\tlen = head_skb->len - offset;\n\t\tif (len > mss)\n\t\t\tlen = mss;\n\n\t\thsize = skb_headlen(head_skb) - offset;\n\t\tif (hsize < 0)\n\t\t\thsize = 0;\n\t\tif (hsize > len || !sg)\n\t\t\thsize = len;\n\n\t\tif (!hsize && i >= nfrags && skb_headlen(list_skb) &&\n\t\t    (skb_headlen(list_skb) == len || sg)) {\n\t\t\tBUG_ON(skb_headlen(list_skb) > len);\n\n\t\t\ti = 0;\n\t\t\tnfrags = skb_shinfo(list_skb)->nr_frags;\n\t\t\tfrag = skb_shinfo(list_skb)->frags;\n\t\t\tpos += skb_headlen(list_skb);\n\n\t\t\twhile (pos < offset + len) {\n\t\t\t\tBUG_ON(i >= nfrags);\n\n\t\t\t\tsize = skb_frag_size(frag);\n\t\t\t\tif (pos + size > offset + len)\n\t\t\t\t\tbreak;\n\n\t\t\t\ti++;\n\t\t\t\tpos += size;\n\t\t\t\tfrag++;\n\t\t\t}\n\n\t\t\tnskb = skb_clone(list_skb, GFP_ATOMIC);\n\t\t\tlist_skb = list_skb->next;\n\n\t\t\tif (unlikely(!nskb))\n\t\t\t\tgoto err;\n\n\t\t\tif (unlikely(pskb_trim(nskb, len))) {\n\t\t\t\tkfree_skb(nskb);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\thsize = skb_end_offset(nskb);\n\t\t\tif (skb_cow_head(nskb, doffset + headroom)) {\n\t\t\t\tkfree_skb(nskb);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tnskb->truesize += skb_end_offset(nskb) - hsize;\n\t\t\tskb_release_head_state(nskb);\n\t\t\t__skb_push(nskb, doffset);\n\t\t} else {\n\t\t\tnskb = __alloc_skb(hsize + doffset + headroom,\n\t\t\t\t\t   GFP_ATOMIC, skb_alloc_rx_flag(head_skb),\n\t\t\t\t\t   NUMA_NO_NODE);\n\n\t\t\tif (unlikely(!nskb))\n\t\t\t\tgoto err;\n\n\t\t\tskb_reserve(nskb, headroom);\n\t\t\t__skb_put(nskb, doffset);\n\t\t}\n\n\t\tif (segs)\n\t\t\ttail->next = nskb;\n\t\telse\n\t\t\tsegs = nskb;\n\t\ttail = nskb;\n\n\t\t__copy_skb_header(nskb, head_skb);\n\t\tnskb->mac_len = head_skb->mac_len;\n\n\t\tskb_headers_offset_update(nskb, skb_headroom(nskb) - headroom);\n\n\t\tskb_copy_from_linear_data_offset(head_skb, -tnl_hlen,\n\t\t\t\t\t\t nskb->data - tnl_hlen,\n\t\t\t\t\t\t doffset + tnl_hlen);\n\n\t\tif (nskb->len == len + doffset)\n\t\t\tgoto perform_csum_check;\n\n\t\tif (!sg) {\n\t\t\tnskb->ip_summed = CHECKSUM_NONE;\n\t\t\tnskb->csum = skb_copy_and_csum_bits(head_skb, offset,\n\t\t\t\t\t\t\t    skb_put(nskb, len),\n\t\t\t\t\t\t\t    len, 0);\n\t\t\tcontinue;\n\t\t}\n\n\t\tnskb_frag = skb_shinfo(nskb)->frags;\n\n\t\tskb_copy_from_linear_data_offset(head_skb, offset,\n\t\t\t\t\t\t skb_put(nskb, hsize), hsize);\n\n\t\tskb_shinfo(nskb)->tx_flags = skb_shinfo(head_skb)->tx_flags &\n\t\t\tSKBTX_SHARED_FRAG;\n\n\t\twhile (pos < offset + len) {\n\t\t\tif (i >= nfrags) {\n\t\t\t\tBUG_ON(skb_headlen(list_skb));\n\n\t\t\t\ti = 0;\n\t\t\t\tnfrags = skb_shinfo(list_skb)->nr_frags;\n\t\t\t\tfrag = skb_shinfo(list_skb)->frags;\n\n\t\t\t\tBUG_ON(!nfrags);\n\n\t\t\t\tlist_skb = list_skb->next;\n\t\t\t}\n\n\t\t\tif (unlikely(skb_shinfo(nskb)->nr_frags >=\n\t\t\t\t     MAX_SKB_FRAGS)) {\n\t\t\t\tnet_warn_ratelimited(\n\t\t\t\t\t\"skb_segment: too many frags: %u %u\\n\",\n\t\t\t\t\tpos, mss);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\t*nskb_frag = *frag;\n\t\t\t__skb_frag_ref(nskb_frag);\n\t\t\tsize = skb_frag_size(nskb_frag);\n\n\t\t\tif (pos < offset) {\n\t\t\t\tnskb_frag->page_offset += offset - pos;\n\t\t\t\tskb_frag_size_sub(nskb_frag, offset - pos);\n\t\t\t}\n\n\t\t\tskb_shinfo(nskb)->nr_frags++;\n\n\t\t\tif (pos + size <= offset + len) {\n\t\t\t\ti++;\n\t\t\t\tfrag++;\n\t\t\t\tpos += size;\n\t\t\t} else {\n\t\t\t\tskb_frag_size_sub(nskb_frag, pos + size - (offset + len));\n\t\t\t\tgoto skip_fraglist;\n\t\t\t}\n\n\t\t\tnskb_frag++;\n\t\t}\n\nskip_fraglist:\n\t\tnskb->data_len = len - hsize;\n\t\tnskb->len += nskb->data_len;\n\t\tnskb->truesize += nskb->data_len;\n\nperform_csum_check:\n\t\tif (!csum) {\n\t\t\tnskb->csum = skb_checksum(nskb, doffset,\n\t\t\t\t\t\t  nskb->len - doffset, 0);\n\t\t\tnskb->ip_summed = CHECKSUM_NONE;\n\t\t}\n\t} while ((offset += len) < head_skb->len);\n\n\treturn segs;\n\nerr:\n\tkfree_skb_list(segs);\n\treturn ERR_PTR(err);\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 150354,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "struct sk_buff *skb_segment(struct sk_buff *head_skb,\n\t\t\t    netdev_features_t features)\n{\n\tstruct sk_buff *segs = NULL;\n\tstruct sk_buff *tail = NULL;\n\tstruct sk_buff *list_skb = skb_shinfo(head_skb)->frag_list;\n\tskb_frag_t *frag = skb_shinfo(head_skb)->frags;\n\tunsigned int mss = skb_shinfo(head_skb)->gso_size;\n\tunsigned int doffset = head_skb->data - skb_mac_header(head_skb);\n\tstruct sk_buff *frag_skb = head_skb;\n\tunsigned int offset = doffset;\n\tunsigned int tnl_hlen = skb_tnl_header_len(head_skb);\n\tunsigned int headroom;\n\tunsigned int len;\n\t__be16 proto;\n\tbool csum;\n\tint sg = !!(features & NETIF_F_SG);\n\tint nfrags = skb_shinfo(head_skb)->nr_frags;\n\tint err = -ENOMEM;\n\tint i = 0;\n\tint pos;\n\n\tproto = skb_network_protocol(head_skb);\n\tif (unlikely(!proto))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tcsum = !!can_checksum_protocol(features, proto);\n\t__skb_push(head_skb, doffset);\n\theadroom = skb_headroom(head_skb);\n\tpos = skb_headlen(head_skb);\n\n\tdo {\n\t\tstruct sk_buff *nskb;\n\t\tskb_frag_t *nskb_frag;\n\t\tint hsize;\n\t\tint size;\n\n\t\tlen = head_skb->len - offset;\n\t\tif (len > mss)\n\t\t\tlen = mss;\n\n\t\thsize = skb_headlen(head_skb) - offset;\n\t\tif (hsize < 0)\n\t\t\thsize = 0;\n\t\tif (hsize > len || !sg)\n\t\t\thsize = len;\n\n\t\tif (!hsize && i >= nfrags && skb_headlen(list_skb) &&\n\t\t    (skb_headlen(list_skb) == len || sg)) {\n\t\t\tBUG_ON(skb_headlen(list_skb) > len);\n\n\t\t\ti = 0;\n\t\t\tnfrags = skb_shinfo(list_skb)->nr_frags;\n\t\t\tfrag = skb_shinfo(list_skb)->frags;\n\t\t\tfrag_skb = list_skb;\n\t\t\tpos += skb_headlen(list_skb);\n\n\t\t\twhile (pos < offset + len) {\n\t\t\t\tBUG_ON(i >= nfrags);\n\n\t\t\t\tsize = skb_frag_size(frag);\n\t\t\t\tif (pos + size > offset + len)\n\t\t\t\t\tbreak;\n\n\t\t\t\ti++;\n\t\t\t\tpos += size;\n\t\t\t\tfrag++;\n\t\t\t}\n\n\t\t\tnskb = skb_clone(list_skb, GFP_ATOMIC);\n\t\t\tlist_skb = list_skb->next;\n\n\t\t\tif (unlikely(!nskb))\n\t\t\t\tgoto err;\n\n\t\t\tif (unlikely(pskb_trim(nskb, len))) {\n\t\t\t\tkfree_skb(nskb);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\thsize = skb_end_offset(nskb);\n\t\t\tif (skb_cow_head(nskb, doffset + headroom)) {\n\t\t\t\tkfree_skb(nskb);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tnskb->truesize += skb_end_offset(nskb) - hsize;\n\t\t\tskb_release_head_state(nskb);\n\t\t\t__skb_push(nskb, doffset);\n\t\t} else {\n\t\t\tnskb = __alloc_skb(hsize + doffset + headroom,\n\t\t\t\t\t   GFP_ATOMIC, skb_alloc_rx_flag(head_skb),\n\t\t\t\t\t   NUMA_NO_NODE);\n\n\t\t\tif (unlikely(!nskb))\n\t\t\t\tgoto err;\n\n\t\t\tskb_reserve(nskb, headroom);\n\t\t\t__skb_put(nskb, doffset);\n\t\t}\n\n\t\tif (segs)\n\t\t\ttail->next = nskb;\n\t\telse\n\t\t\tsegs = nskb;\n\t\ttail = nskb;\n\n\t\t__copy_skb_header(nskb, head_skb);\n\t\tnskb->mac_len = head_skb->mac_len;\n\n\t\tskb_headers_offset_update(nskb, skb_headroom(nskb) - headroom);\n\n\t\tskb_copy_from_linear_data_offset(head_skb, -tnl_hlen,\n\t\t\t\t\t\t nskb->data - tnl_hlen,\n\t\t\t\t\t\t doffset + tnl_hlen);\n\n\t\tif (nskb->len == len + doffset)\n\t\t\tgoto perform_csum_check;\n\n\t\tif (!sg) {\n\t\t\tnskb->ip_summed = CHECKSUM_NONE;\n\t\t\tnskb->csum = skb_copy_and_csum_bits(head_skb, offset,\n\t\t\t\t\t\t\t    skb_put(nskb, len),\n\t\t\t\t\t\t\t    len, 0);\n\t\t\tcontinue;\n\t\t}\n\n\t\tnskb_frag = skb_shinfo(nskb)->frags;\n\n\t\tskb_copy_from_linear_data_offset(head_skb, offset,\n\t\t\t\t\t\t skb_put(nskb, hsize), hsize);\n\n\t\tskb_shinfo(nskb)->tx_flags = skb_shinfo(head_skb)->tx_flags &\n\t\t\tSKBTX_SHARED_FRAG;\n\n\t\twhile (pos < offset + len) {\n\t\t\tif (i >= nfrags) {\n\t\t\t\tBUG_ON(skb_headlen(list_skb));\n\n\t\t\t\ti = 0;\n\t\t\t\tnfrags = skb_shinfo(list_skb)->nr_frags;\n\t\t\t\tfrag = skb_shinfo(list_skb)->frags;\n\t\t\t\tfrag_skb = list_skb;\n\n\t\t\t\tBUG_ON(!nfrags);\n\n\t\t\t\tlist_skb = list_skb->next;\n\t\t\t}\n\n\t\t\tif (unlikely(skb_shinfo(nskb)->nr_frags >=\n\t\t\t\t     MAX_SKB_FRAGS)) {\n\t\t\t\tnet_warn_ratelimited(\n\t\t\t\t\t\"skb_segment: too many frags: %u %u\\n\",\n\t\t\t\t\tpos, mss);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tif (unlikely(skb_orphan_frags(frag_skb, GFP_ATOMIC)))\n\t\t\t\tgoto err;\n\n\t\t\t*nskb_frag = *frag;\n\t\t\t__skb_frag_ref(nskb_frag);\n\t\t\tsize = skb_frag_size(nskb_frag);\n\n\t\t\tif (pos < offset) {\n\t\t\t\tnskb_frag->page_offset += offset - pos;\n\t\t\t\tskb_frag_size_sub(nskb_frag, offset - pos);\n\t\t\t}\n\n\t\t\tskb_shinfo(nskb)->nr_frags++;\n\n\t\t\tif (pos + size <= offset + len) {\n\t\t\t\ti++;\n\t\t\t\tfrag++;\n\t\t\t\tpos += size;\n\t\t\t} else {\n\t\t\t\tskb_frag_size_sub(nskb_frag, pos + size - (offset + len));\n\t\t\t\tgoto skip_fraglist;\n\t\t\t}\n\n\t\t\tnskb_frag++;\n\t\t}\n\nskip_fraglist:\n\t\tnskb->data_len = len - hsize;\n\t\tnskb->len += nskb->data_len;\n\t\tnskb->truesize += nskb->data_len;\n\nperform_csum_check:\n\t\tif (!csum) {\n\t\t\tnskb->csum = skb_checksum(nskb, doffset,\n\t\t\t\t\t\t  nskb->len - doffset, 0);\n\t\t\tnskb->ip_summed = CHECKSUM_NONE;\n\t\t}\n\t} while ((offset += len) < head_skb->len);\n\n\treturn segs;\n\nerr:\n\tkfree_skb_list(segs);\n\treturn ERR_PTR(err);\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 150355,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "void usb_serial_console_disconnect(struct usb_serial *serial)\n{\n\tif (serial->port[0] == usbcons_info.port) {\n\t\tusb_serial_console_exit();\n\t\tusb_serial_put(serial);\n\t}\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 150356,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "void usb_serial_console_disconnect(struct usb_serial *serial)\n{\n\tif (serial->port[0] && serial->port[0] == usbcons_info.port) {\n\t\tusb_serial_console_exit();\n\t\tusb_serial_put(serial);\n\t}\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 150357,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "int blk_init_allocated_queue(struct request_queue *q)\n{\n\tWARN_ON_ONCE(q->mq_ops);\n\n\tq->fq = blk_alloc_flush_queue(q, NUMA_NO_NODE, q->cmd_size);\n\tif (!q->fq)\n\t\treturn -ENOMEM;\n\n\tif (q->init_rq_fn && q->init_rq_fn(q, q->fq->flush_rq, GFP_KERNEL))\n\t\tgoto out_free_flush_queue;\n\n\tif (blk_init_rl(&q->root_rl, q, GFP_KERNEL))\n\t\tgoto out_exit_flush_rq;\n\n\tINIT_WORK(&q->timeout_work, blk_timeout_work);\n\tq->queue_flags\t\t|= QUEUE_FLAG_DEFAULT;\n\n\t/*\n\t * This also sets hw/phys segments, boundary and size\n\t */\n\tblk_queue_make_request(q, blk_queue_bio);\n\n\tq->sg_reserved_size = INT_MAX;\n\n\tif (elevator_init(q))\n\t\tgoto out_exit_flush_rq;\n\treturn 0;\n\nout_exit_flush_rq:\n\tif (q->exit_rq_fn)\n\t\tq->exit_rq_fn(q, q->fq->flush_rq);\nout_free_flush_queue:\n\tblk_free_flush_queue(q->fq);\n\treturn -ENOMEM;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 150358,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "int blk_init_allocated_queue(struct request_queue *q)\n{\n\tWARN_ON_ONCE(q->mq_ops);\n\n\tq->fq = blk_alloc_flush_queue(q, NUMA_NO_NODE, q->cmd_size);\n\tif (!q->fq)\n\t\treturn -ENOMEM;\n\n\tif (q->init_rq_fn && q->init_rq_fn(q, q->fq->flush_rq, GFP_KERNEL))\n\t\tgoto out_free_flush_queue;\n\n\tif (blk_init_rl(&q->root_rl, q, GFP_KERNEL))\n\t\tgoto out_exit_flush_rq;\n\n\tINIT_WORK(&q->timeout_work, blk_timeout_work);\n\tq->queue_flags\t\t|= QUEUE_FLAG_DEFAULT;\n\n\t/*\n\t * This also sets hw/phys segments, boundary and size\n\t */\n\tblk_queue_make_request(q, blk_queue_bio);\n\n\tq->sg_reserved_size = INT_MAX;\n\n\tif (elevator_init(q))\n\t\tgoto out_exit_flush_rq;\n\treturn 0;\n\nout_exit_flush_rq:\n\tif (q->exit_rq_fn)\n\t\tq->exit_rq_fn(q, q->fq->flush_rq);\nout_free_flush_queue:\n\tblk_free_flush_queue(q->fq);\n\tq->fq = NULL;\n\treturn -ENOMEM;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 150359,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "int snd_timer_open(struct snd_timer_instance **ti,\n\t\t   char *owner, struct snd_timer_id *tid,\n\t\t   unsigned int slave_id)\n{\n\tstruct snd_timer *timer;\n\tstruct snd_timer_instance *timeri = NULL;\n\tstruct device *card_dev_to_put = NULL;\n\tint err;\n\n\tmutex_lock(&register_mutex);\n\tif (tid->dev_class == SNDRV_TIMER_CLASS_SLAVE) {\n\t\t/* open a slave instance */\n\t\tif (tid->dev_sclass <= SNDRV_TIMER_SCLASS_NONE ||\n\t\t    tid->dev_sclass > SNDRV_TIMER_SCLASS_OSS_SEQUENCER) {\n\t\t\tpr_debug(\"ALSA: timer: invalid slave class %i\\n\",\n\t\t\t\t tid->dev_sclass);\n\t\t\terr = -EINVAL;\n\t\t\tgoto unlock;\n\t\t}\n\t\ttimeri = snd_timer_instance_new(owner, NULL);\n\t\tif (!timeri) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unlock;\n\t\t}\n\t\ttimeri->slave_class = tid->dev_sclass;\n\t\ttimeri->slave_id = tid->device;\n\t\ttimeri->flags |= SNDRV_TIMER_IFLG_SLAVE;\n\t\tlist_add_tail(&timeri->open_list, &snd_timer_slave_list);\n\t\terr = snd_timer_check_slave(timeri);\n\t\tif (err < 0) {\n\t\t\tsnd_timer_close_locked(timeri, &card_dev_to_put);\n\t\t\ttimeri = NULL;\n\t\t}\n\t\tgoto unlock;\n\t}\n\n\t/* open a master instance */\n\ttimer = snd_timer_find(tid);\n#ifdef CONFIG_MODULES\n\tif (!timer) {\n\t\tmutex_unlock(&register_mutex);\n\t\tsnd_timer_request(tid);\n\t\tmutex_lock(&register_mutex);\n\t\ttimer = snd_timer_find(tid);\n\t}\n#endif\n\tif (!timer) {\n\t\terr = -ENODEV;\n\t\tgoto unlock;\n\t}\n\tif (!list_empty(&timer->open_list_head)) {\n\t\ttimeri = list_entry(timer->open_list_head.next,\n\t\t\t\t    struct snd_timer_instance, open_list);\n\t\tif (timeri->flags & SNDRV_TIMER_IFLG_EXCLUSIVE) {\n\t\t\terr = -EBUSY;\n\t\t\ttimeri = NULL;\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\tif (timer->num_instances >= timer->max_instances) {\n\t\terr = -EBUSY;\n\t\tgoto unlock;\n\t}\n\ttimeri = snd_timer_instance_new(owner, timer);\n\tif (!timeri) {\n\t\terr = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\t/* take a card refcount for safe disconnection */\n\tif (timer->card)\n\t\tget_device(&timer->card->card_dev);\n\ttimeri->slave_class = tid->dev_sclass;\n\ttimeri->slave_id = slave_id;\n\n\tif (list_empty(&timer->open_list_head) && timer->hw.open) {\n\t\terr = timer->hw.open(timer);\n\t\tif (err) {\n\t\t\tkfree(timeri->owner);\n\t\t\tkfree(timeri);\n\t\t\ttimeri = NULL;\n\n\t\t\tif (timer->card)\n\t\t\t\tcard_dev_to_put = &timer->card->card_dev;\n\t\t\tmodule_put(timer->module);\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\tlist_add_tail(&timeri->open_list, &timer->open_list_head);\n\ttimer->num_instances++;\n\terr = snd_timer_check_master(timeri);\n\tif (err < 0) {\n\t\tsnd_timer_close_locked(timeri, &card_dev_to_put);\n\t\ttimeri = NULL;\n\t}\n\n unlock:\n\tmutex_unlock(&register_mutex);\n\t/* put_device() is called after unlock for avoiding deadlock */\n\tif (card_dev_to_put)\n\t\tput_device(card_dev_to_put);\n\t*ti = timeri;\n\treturn err;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 150360,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "int snd_timer_open(struct snd_timer_instance **ti,\n\t\t   char *owner, struct snd_timer_id *tid,\n\t\t   unsigned int slave_id)\n{\n\tstruct snd_timer *timer;\n\tstruct snd_timer_instance *timeri = NULL;\n\tstruct device *card_dev_to_put = NULL;\n\tint err;\n\n\tmutex_lock(&register_mutex);\n\tif (tid->dev_class == SNDRV_TIMER_CLASS_SLAVE) {\n\t\t/* open a slave instance */\n\t\tif (tid->dev_sclass <= SNDRV_TIMER_SCLASS_NONE ||\n\t\t    tid->dev_sclass > SNDRV_TIMER_SCLASS_OSS_SEQUENCER) {\n\t\t\tpr_debug(\"ALSA: timer: invalid slave class %i\\n\",\n\t\t\t\t tid->dev_sclass);\n\t\t\terr = -EINVAL;\n\t\t\tgoto unlock;\n\t\t}\n\t\ttimeri = snd_timer_instance_new(owner, NULL);\n\t\tif (!timeri) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unlock;\n\t\t}\n\t\ttimeri->slave_class = tid->dev_sclass;\n\t\ttimeri->slave_id = tid->device;\n\t\ttimeri->flags |= SNDRV_TIMER_IFLG_SLAVE;\n\t\tlist_add_tail(&timeri->open_list, &snd_timer_slave_list);\n\t\terr = snd_timer_check_slave(timeri);\n\t\tif (err < 0) {\n\t\t\tsnd_timer_close_locked(timeri, &card_dev_to_put);\n\t\t\ttimeri = NULL;\n\t\t}\n\t\tgoto unlock;\n\t}\n\n\t/* open a master instance */\n\ttimer = snd_timer_find(tid);\n#ifdef CONFIG_MODULES\n\tif (!timer) {\n\t\tmutex_unlock(&register_mutex);\n\t\tsnd_timer_request(tid);\n\t\tmutex_lock(&register_mutex);\n\t\ttimer = snd_timer_find(tid);\n\t}\n#endif\n\tif (!timer) {\n\t\terr = -ENODEV;\n\t\tgoto unlock;\n\t}\n\tif (!list_empty(&timer->open_list_head)) {\n\t\tstruct snd_timer_instance *t =\n\t\t\tlist_entry(timer->open_list_head.next,\n\t\t\t\t    struct snd_timer_instance, open_list);\n\t\tif (t->flags & SNDRV_TIMER_IFLG_EXCLUSIVE) {\n\t\t\terr = -EBUSY;\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\tif (timer->num_instances >= timer->max_instances) {\n\t\terr = -EBUSY;\n\t\tgoto unlock;\n\t}\n\ttimeri = snd_timer_instance_new(owner, timer);\n\tif (!timeri) {\n\t\terr = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\t/* take a card refcount for safe disconnection */\n\tif (timer->card)\n\t\tget_device(&timer->card->card_dev);\n\ttimeri->slave_class = tid->dev_sclass;\n\ttimeri->slave_id = slave_id;\n\n\tif (list_empty(&timer->open_list_head) && timer->hw.open) {\n\t\terr = timer->hw.open(timer);\n\t\tif (err) {\n\t\t\tkfree(timeri->owner);\n\t\t\tkfree(timeri);\n\t\t\ttimeri = NULL;\n\n\t\t\tif (timer->card)\n\t\t\t\tcard_dev_to_put = &timer->card->card_dev;\n\t\t\tmodule_put(timer->module);\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\tlist_add_tail(&timeri->open_list, &timer->open_list_head);\n\ttimer->num_instances++;\n\terr = snd_timer_check_master(timeri);\n\tif (err < 0) {\n\t\tsnd_timer_close_locked(timeri, &card_dev_to_put);\n\t\ttimeri = NULL;\n\t}\n\n unlock:\n\tmutex_unlock(&register_mutex);\n\t/* put_device() is called after unlock for avoiding deadlock */\n\tif (card_dev_to_put)\n\t\tput_device(card_dev_to_put);\n\t*ti = timeri;\n\treturn err;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 150361,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "  void DecodePngV2(OpKernelContext* context, StringPiece input) {\n    int channel_bits = (data_type_ == DataType::DT_UINT8) ? 8 : 16;\n    png::DecodeContext decode;\n    OP_REQUIRES(\n        context, png::CommonInitDecode(input, channels_, channel_bits, &decode),\n        errors::InvalidArgument(\"Invalid PNG. Failed to initialize decoder.\"));\n\n    // Verify that width and height are not too large:\n    // - verify width and height don't overflow int.\n    // - width can later be multiplied by channels_ and sizeof(uint16), so\n    //   verify single dimension is not too large.\n    // - verify when width and height are multiplied together, there are a few\n    //   bits to spare as well.\n    const int width = static_cast<int>(decode.width);\n    const int height = static_cast<int>(decode.height);\n    const int64_t total_size =\n        static_cast<int64_t>(width) * static_cast<int64_t>(height);\n    if (width != static_cast<int64_t>(decode.width) || width <= 0 ||\n        width >= (1LL << 27) || height != static_cast<int64_t>(decode.height) ||\n        height <= 0 || height >= (1LL << 27) || total_size >= (1LL << 29)) {\n      OP_REQUIRES(context, false,\n                  errors::InvalidArgument(\"PNG size too large for int: \",\n                                          decode.width, \" by \", decode.height));\n    }\n\n    Tensor* output = nullptr;\n    Status status;\n    // By the existing API, we support decoding PNG with `DecodeGif` op.\n    // We need to make sure to return 4-D shapes when using `DecodeGif`.\n    if (op_type_ == \"DecodeGif\") {\n      status = context->allocate_output(\n          0, TensorShape({1, height, width, decode.channels}), &output);\n    } else {\n      status = context->allocate_output(\n          0, TensorShape({height, width, decode.channels}), &output);\n    }\n\n    if (op_type_ == \"DecodeBmp\") {\n      // TODO(b/171060723): Only DecodeBmp as op_type_ is not acceptable here\n      // because currently `decode_(jpeg|png|gif)` ops can decode any one of\n      // jpeg, png or gif but not bmp. Similarly, `decode_bmp` cannot decode\n      // anything but bmp formats. This behavior needs to be revisited. For more\n      // details, please refer to the bug.\n      OP_REQUIRES(context, false,\n                  errors::InvalidArgument(\n                      \"Trying to decode PNG format using DecodeBmp op. Use \"\n                      \"`decode_png` or `decode_image` instead.\"));\n    } else if (op_type_ == \"DecodeAndCropJpeg\") {\n      OP_REQUIRES(context, false,\n                  errors::InvalidArgument(\n                      \"DecodeAndCropJpeg operation can run on JPEG only, but \"\n                      \"detected PNG.\"));\n    }\n\n    if (!status.ok()) png::CommonFreeDecode(&decode);\n    OP_REQUIRES_OK(context, status);\n\n    if (data_type_ == DataType::DT_UINT8) {\n      OP_REQUIRES(\n          context,\n          png::CommonFinishDecode(\n              reinterpret_cast<png_bytep>(output->flat<uint8>().data()),\n              decode.channels * width * sizeof(uint8), &decode),\n          errors::InvalidArgument(\"Invalid PNG data, size \", input.size()));\n    } else if (data_type_ == DataType::DT_UINT16) {\n      OP_REQUIRES(\n          context,\n          png::CommonFinishDecode(\n              reinterpret_cast<png_bytep>(output->flat<uint16>().data()),\n              decode.channels * width * sizeof(uint16), &decode),\n          errors::InvalidArgument(\"Invalid PNG data, size \", input.size()));\n    } else if (data_type_ == DataType::DT_FLOAT) {\n      // `png::CommonFinishDecode` does not support `float`. First allocate\n      // uint16 buffer for the image and decode in uint16 (lossless). Wrap the\n      // buffer in `unique_ptr` so that we don't forget to delete the buffer.\n      std::unique_ptr<uint16[]> buffer(\n          new uint16[height * width * decode.channels]);\n      OP_REQUIRES(\n          context,\n          png::CommonFinishDecode(reinterpret_cast<png_bytep>(buffer.get()),\n                                  decode.channels * width * sizeof(uint16),\n                                  &decode),\n          errors::InvalidArgument(\"Invalid PNG data, size \", input.size()));\n\n      // Convert uint16 image data to desired data type.\n      // Use eigen threadpooling to speed up the copy operation.\n      const auto& device = context->eigen_device<Eigen::ThreadPoolDevice>();\n      TTypes<uint16, 3>::UnalignedConstTensor buf(buffer.get(), height, width,\n                                                  decode.channels);\n      float scale = 1. / std::numeric_limits<uint16>::max();\n      // Fill output tensor with desired dtype.\n      output->tensor<float, 3>().device(device) = buf.cast<float>() * scale;\n    }\n  }",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 41,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "find_pattern_in_path(\n    char_u\t*ptr,\t\t// pointer to search pattern\n    int\t\tdir UNUSED,\t// direction of expansion\n    int\t\tlen,\t\t// length of search pattern\n    int\t\twhole,\t\t// match whole words only\n    int\t\tskip_comments,\t// don't match inside comments\n    int\t\ttype,\t\t// Type of search; are we looking for a type?\n\t\t\t\t// a macro?\n    long\tcount,\n    int\t\taction,\t\t// What to do when we find it\n    linenr_T\tstart_lnum,\t// first line to start searching\n    linenr_T\tend_lnum)\t// last line for searching\n{\n    SearchedFile *files;\t\t// Stack of included files\n    SearchedFile *bigger;\t\t// When we need more space\n    int\t\tmax_path_depth = 50;\n    long\tmatch_count = 1;\n\n    char_u\t*pat;\n    char_u\t*new_fname;\n    char_u\t*curr_fname = curbuf->b_fname;\n    char_u\t*prev_fname = NULL;\n    linenr_T\tlnum;\n    int\t\tdepth;\n    int\t\tdepth_displayed;\t// For type==CHECK_PATH\n    int\t\told_files;\n    int\t\talready_searched;\n    char_u\t*file_line;\n    char_u\t*line;\n    char_u\t*p;\n    char_u\tsave_char;\n    int\t\tdefine_matched;\n    regmatch_T\tregmatch;\n    regmatch_T\tincl_regmatch;\n    regmatch_T\tdef_regmatch;\n    int\t\tmatched = FALSE;\n    int\t\tdid_show = FALSE;\n    int\t\tfound = FALSE;\n    int\t\ti;\n    char_u\t*already = NULL;\n    char_u\t*startp = NULL;\n    char_u\t*inc_opt = NULL;\n#if defined(FEAT_QUICKFIX)\n    win_T\t*curwin_save = NULL;\n#endif\n\n    regmatch.regprog = NULL;\n    incl_regmatch.regprog = NULL;\n    def_regmatch.regprog = NULL;\n\n    file_line = alloc(LSIZE);\n    if (file_line == NULL)\n\treturn;\n\n    if (type != CHECK_PATH && type != FIND_DEFINE\n\t    // when CONT_SOL is set compare \"ptr\" with the beginning of the\n\t    // line is faster than quote_meta/regcomp/regexec \"ptr\" -- Acevedo\n\t    && !compl_status_sol())\n    {\n\tpat = alloc(len + 5);\n\tif (pat == NULL)\n\t    goto fpip_end;\n\tsprintf((char *)pat, whole ? \"\\\\<%.*s\\\\>\" : \"%.*s\", len, ptr);\n\t// ignore case according to p_ic, p_scs and pat\n\tregmatch.rm_ic = ignorecase(pat);\n\tregmatch.regprog = vim_regcomp(pat, magic_isset() ? RE_MAGIC : 0);\n\tvim_free(pat);\n\tif (regmatch.regprog == NULL)\n\t    goto fpip_end;\n    }\n    inc_opt = (*curbuf->b_p_inc == NUL) ? p_inc : curbuf->b_p_inc;\n    if (*inc_opt != NUL)\n    {\n\tincl_regmatch.regprog = vim_regcomp(inc_opt,\n\t\t\t\t\t\t magic_isset() ? RE_MAGIC : 0);\n\tif (incl_regmatch.regprog == NULL)\n\t    goto fpip_end;\n\tincl_regmatch.rm_ic = FALSE;\t// don't ignore case in incl. pat.\n    }\n    if (type == FIND_DEFINE && (*curbuf->b_p_def != NUL || *p_def != NUL))\n    {\n\tdef_regmatch.regprog = vim_regcomp(*curbuf->b_p_def == NUL\n\t\t\t   ? p_def : curbuf->b_p_def,\n\t\t\t\t\t\t magic_isset() ? RE_MAGIC : 0);\n\tif (def_regmatch.regprog == NULL)\n\t    goto fpip_end;\n\tdef_regmatch.rm_ic = FALSE;\t// don't ignore case in define pat.\n    }\n    files = lalloc_clear(max_path_depth * sizeof(SearchedFile), TRUE);\n    if (files == NULL)\n\tgoto fpip_end;\n    old_files = max_path_depth;\n    depth = depth_displayed = -1;\n\n    lnum = start_lnum;\n    if (end_lnum > curbuf->b_ml.ml_line_count)\n\tend_lnum = curbuf->b_ml.ml_line_count;\n    if (lnum > end_lnum)\t\t// do at least one line\n\tlnum = end_lnum;\n    line = get_line_and_copy(lnum, file_line);\n\n    for (;;)\n    {\n\tif (incl_regmatch.regprog != NULL\n\t\t&& vim_regexec(&incl_regmatch, line, (colnr_T)0))\n\t{\n\t    char_u *p_fname = (curr_fname == curbuf->b_fname)\n\t\t\t\t\t      ? curbuf->b_ffname : curr_fname;\n\n\t    if (inc_opt != NULL && strstr((char *)inc_opt, \"\\\\zs\") != NULL)\n\t\t// Use text from '\\zs' to '\\ze' (or end) of 'include'.\n\t\tnew_fname = find_file_name_in_path(incl_regmatch.startp[0],\n\t\t       (int)(incl_regmatch.endp[0] - incl_regmatch.startp[0]),\n\t\t\t\t FNAME_EXP|FNAME_INCL|FNAME_REL, 1L, p_fname);\n\t    else\n\t\t// Use text after match with 'include'.\n\t\tnew_fname = file_name_in_line(incl_regmatch.endp[0], 0,\n\t\t\t     FNAME_EXP|FNAME_INCL|FNAME_REL, 1L, p_fname, NULL);\n\t    already_searched = FALSE;\n\t    if (new_fname != NULL)\n\t    {\n\t\t// Check whether we have already searched in this file\n\t\tfor (i = 0;; i++)\n\t\t{\n\t\t    if (i == depth + 1)\n\t\t\ti = old_files;\n\t\t    if (i == max_path_depth)\n\t\t\tbreak;\n\t\t    if (fullpathcmp(new_fname, files[i].name, TRUE, TRUE)\n\t\t\t\t\t\t\t\t    & FPC_SAME)\n\t\t    {\n\t\t\tif (type != CHECK_PATH\n\t\t\t\t&& action == ACTION_SHOW_ALL\n\t\t\t\t&& files[i].matched)\n\t\t\t{\n\t\t\t    msg_putchar('\\n');\t    // cursor below last one\n\t\t\t    if (!got_int)\t    // don't display if 'q'\n\t\t\t\t\t\t    // typed at \"--more--\"\n\t\t\t\t\t\t    // message\n\t\t\t    {\n\t\t\t\tmsg_home_replace_hl(new_fname);\n\t\t\t\tmsg_puts(_(\" (includes previously listed match)\"));\n\t\t\t\tprev_fname = NULL;\n\t\t\t    }\n\t\t\t}\n\t\t\tVIM_CLEAR(new_fname);\n\t\t\talready_searched = TRUE;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\n\t    if (type == CHECK_PATH && (action == ACTION_SHOW_ALL\n\t\t\t\t || (new_fname == NULL && !already_searched)))\n\t    {\n\t\tif (did_show)\n\t\t    msg_putchar('\\n');\t    // cursor below last one\n\t\telse\n\t\t{\n\t\t    gotocmdline(TRUE);\t    // cursor at status line\n\t\t    msg_puts_title(_(\"--- Included files \"));\n\t\t    if (action != ACTION_SHOW_ALL)\n\t\t\tmsg_puts_title(_(\"not found \"));\n\t\t    msg_puts_title(_(\"in path ---\\n\"));\n\t\t}\n\t\tdid_show = TRUE;\n\t\twhile (depth_displayed < depth && !got_int)\n\t\t{\n\t\t    ++depth_displayed;\n\t\t    for (i = 0; i < depth_displayed; i++)\n\t\t\tmsg_puts(\"  \");\n\t\t    msg_home_replace(files[depth_displayed].name);\n\t\t    msg_puts(\" -->\\n\");\n\t\t}\n\t\tif (!got_int)\t\t    // don't display if 'q' typed\n\t\t\t\t\t    // for \"--more--\" message\n\t\t{\n\t\t    for (i = 0; i <= depth_displayed; i++)\n\t\t\tmsg_puts(\"  \");\n\t\t    if (new_fname != NULL)\n\t\t    {\n\t\t\t// using \"new_fname\" is more reliable, e.g., when\n\t\t\t// 'includeexpr' is set.\n\t\t\tmsg_outtrans_attr(new_fname, HL_ATTR(HLF_D));\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t/*\n\t\t\t * Isolate the file name.\n\t\t\t * Include the surrounding \"\" or <> if present.\n\t\t\t */\n\t\t\tif (inc_opt != NULL\n\t\t\t\t   && strstr((char *)inc_opt, \"\\\\zs\") != NULL)\n\t\t\t{\n\t\t\t    // pattern contains \\zs, use the match\n\t\t\t    p = incl_regmatch.startp[0];\n\t\t\t    i = (int)(incl_regmatch.endp[0]\n\t\t\t\t\t\t   - incl_regmatch.startp[0]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // find the file name after the end of the match\n\t\t\t    for (p = incl_regmatch.endp[0];\n\t\t\t\t\t\t  *p && !vim_isfilec(*p); p++)\n\t\t\t\t;\n\t\t\t    for (i = 0; vim_isfilec(p[i]); i++)\n\t\t\t\t;\n\t\t\t}\n\n\t\t\tif (i == 0)\n\t\t\t{\n\t\t\t    // Nothing found, use the rest of the line.\n\t\t\t    p = incl_regmatch.endp[0];\n\t\t\t    i = (int)STRLEN(p);\n\t\t\t}\n\t\t\t// Avoid checking before the start of the line, can\n\t\t\t// happen if \\zs appears in the regexp.\n\t\t\telse if (p > line)\n\t\t\t{\n\t\t\t    if (p[-1] == '\"' || p[-1] == '<')\n\t\t\t    {\n\t\t\t\t--p;\n\t\t\t\t++i;\n\t\t\t    }\n\t\t\t    if (p[i] == '\"' || p[i] == '>')\n\t\t\t\t++i;\n\t\t\t}\n\t\t\tsave_char = p[i];\n\t\t\tp[i] = NUL;\n\t\t\tmsg_outtrans_attr(p, HL_ATTR(HLF_D));\n\t\t\tp[i] = save_char;\n\t\t    }\n\n\t\t    if (new_fname == NULL && action == ACTION_SHOW_ALL)\n\t\t    {\n\t\t\tif (already_searched)\n\t\t\t    msg_puts(_(\"  (Already listed)\"));\n\t\t\telse\n\t\t\t    msg_puts(_(\"  NOT FOUND\"));\n\t\t    }\n\t\t}\n\t\tout_flush();\t    // output each line directly\n\t    }\n\n\t    if (new_fname != NULL)\n\t    {\n\t\t// Push the new file onto the file stack\n\t\tif (depth + 1 == old_files)\n\t\t{\n\t\t    bigger = ALLOC_MULT(SearchedFile, max_path_depth * 2);\n\t\t    if (bigger != NULL)\n\t\t    {\n\t\t\tfor (i = 0; i <= depth; i++)\n\t\t\t    bigger[i] = files[i];\n\t\t\tfor (i = depth + 1; i < old_files + max_path_depth; i++)\n\t\t\t{\n\t\t\t    bigger[i].fp = NULL;\n\t\t\t    bigger[i].name = NULL;\n\t\t\t    bigger[i].lnum = 0;\n\t\t\t    bigger[i].matched = FALSE;\n\t\t\t}\n\t\t\tfor (i = old_files; i < max_path_depth; i++)\n\t\t\t    bigger[i + max_path_depth] = files[i];\n\t\t\told_files += max_path_depth;\n\t\t\tmax_path_depth *= 2;\n\t\t\tvim_free(files);\n\t\t\tfiles = bigger;\n\t\t    }\n\t\t}\n\t\tif ((files[depth + 1].fp = mch_fopen((char *)new_fname, \"r\"))\n\t\t\t\t\t\t\t\t    == NULL)\n\t\t    vim_free(new_fname);\n\t\telse\n\t\t{\n\t\t    if (++depth == old_files)\n\t\t    {\n\t\t\t/*\n\t\t\t * lalloc() for 'bigger' must have failed above.  We\n\t\t\t * will forget one of our already visited files now.\n\t\t\t */\n\t\t\tvim_free(files[old_files].name);\n\t\t\t++old_files;\n\t\t    }\n\t\t    files[depth].name = curr_fname = new_fname;\n\t\t    files[depth].lnum = 0;\n\t\t    files[depth].matched = FALSE;\n\t\t    if (action == ACTION_EXPAND)\n\t\t    {\n\t\t\tmsg_hist_off = TRUE;\t// reset in msg_trunc_attr()\n\t\t\tvim_snprintf((char*)IObuff, IOSIZE,\n\t\t\t\t_(\"Scanning included file: %s\"),\n\t\t\t\t(char *)new_fname);\n\t\t\tmsg_trunc_attr((char *)IObuff, TRUE, HL_ATTR(HLF_R));\n\t\t    }\n\t\t    else if (p_verbose >= 5)\n\t\t    {\n\t\t\tverbose_enter();\n\t\t\tsmsg(_(\"Searching included file %s\"),\n\t\t\t\t\t\t\t   (char *)new_fname);\n\t\t\tverbose_leave();\n\t\t    }\n\n\t\t}\n\t    }\n\t}\n\telse\n\t{\n\t    /*\n\t     * Check if the line is a define (type == FIND_DEFINE)\n\t     */\n\t    p = line;\nsearch_line:\n\t    define_matched = FALSE;\n\t    if (def_regmatch.regprog != NULL\n\t\t\t      && vim_regexec(&def_regmatch, line, (colnr_T)0))\n\t    {\n\t\t/*\n\t\t * Pattern must be first identifier after 'define', so skip\n\t\t * to that position before checking for match of pattern.  Also\n\t\t * don't let it match beyond the end of this identifier.\n\t\t */\n\t\tp = def_regmatch.endp[0];\n\t\twhile (*p && !vim_iswordc(*p))\n\t\t    p++;\n\t\tdefine_matched = TRUE;\n\t    }\n\n\t    /*\n\t     * Look for a match.  Don't do this if we are looking for a\n\t     * define and this line didn't match define_prog above.\n\t     */\n\t    if (def_regmatch.regprog == NULL || define_matched)\n\t    {\n\t\tif (define_matched || compl_status_sol())\n\t\t{\n\t\t    // compare the first \"len\" chars from \"ptr\"\n\t\t    startp = skipwhite(p);\n\t\t    if (p_ic)\n\t\t\tmatched = !MB_STRNICMP(startp, ptr, len);\n\t\t    else\n\t\t\tmatched = !STRNCMP(startp, ptr, len);\n\t\t    if (matched && define_matched && whole\n\t\t\t\t\t\t  && vim_iswordc(startp[len]))\n\t\t\tmatched = FALSE;\n\t\t}\n\t\telse if (regmatch.regprog != NULL\n\t\t\t && vim_regexec(&regmatch, line, (colnr_T)(p - line)))\n\t\t{\n\t\t    matched = TRUE;\n\t\t    startp = regmatch.startp[0];\n\t\t    /*\n\t\t     * Check if the line is not a comment line (unless we are\n\t\t     * looking for a define).  A line starting with \"# define\"\n\t\t     * is not considered to be a comment line.\n\t\t     */\n\t\t    if (!define_matched && skip_comments)\n\t\t    {\n\t\t\tif ((*line != '#' ||\n\t\t\t\tSTRNCMP(skipwhite(line + 1), \"define\", 6) != 0)\n\t\t\t\t&& get_leader_len(line, NULL, FALSE, TRUE))\n\t\t\t    matched = FALSE;\n\n\t\t\t/*\n\t\t\t * Also check for a \"/ *\" or \"/ /\" before the match.\n\t\t\t * Skips lines like \"int backwards;  / * normal index\n\t\t\t * * /\" when looking for \"normal\".\n\t\t\t * Note: Doesn't skip \"/ *\" in comments.\n\t\t\t */\n\t\t\tp = skipwhite(line);\n\t\t\tif (matched\n\t\t\t\t|| (p[0] == '/' && p[1] == '*') || p[0] == '*')\n\t\t\t    for (p = line; *p && p < startp; ++p)\n\t\t\t    {\n\t\t\t\tif (matched\n\t\t\t\t\t&& p[0] == '/'\n\t\t\t\t\t&& (p[1] == '*' || p[1] == '/'))\n\t\t\t\t{\n\t\t\t\t    matched = FALSE;\n\t\t\t\t    // After \"//\" all text is comment\n\t\t\t\t    if (p[1] == '/')\n\t\t\t\t\tbreak;\n\t\t\t\t    ++p;\n\t\t\t\t}\n\t\t\t\telse if (!matched && p[0] == '*' && p[1] == '/')\n\t\t\t\t{\n\t\t\t\t    // Can find match after \"* /\".\n\t\t\t\t    matched = TRUE;\n\t\t\t\t    ++p;\n\t\t\t\t}\n\t\t\t    }\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tif (matched)\n\t{\n\t    if (action == ACTION_EXPAND)\n\t    {\n\t\tint\tcont_s_ipos = FALSE;\n\t\tint\tadd_r;\n\t\tchar_u\t*aux;\n\n\t\tif (depth == -1 && lnum == curwin->w_cursor.lnum)\n\t\t    break;\n\t\tfound = TRUE;\n\t\taux = p = startp;\n\t\tif (compl_status_adding())\n\t\t{\n\t\t    p += ins_compl_len();\n\t\t    if (vim_iswordp(p))\n\t\t\tgoto exit_matched;\n\t\t    p = find_word_start(p);\n\t\t}\n\t\tp = find_word_end(p);\n\t\ti = (int)(p - aux);\n\n\t\tif (compl_status_adding() && i == ins_compl_len())\n\t\t{\n\t\t    // IOSIZE > compl_length, so the STRNCPY works\n\t\t    STRNCPY(IObuff, aux, i);\n\n\t\t    // Get the next line: when \"depth\" < 0  from the current\n\t\t    // buffer, otherwise from the included file.  Jump to\n\t\t    // exit_matched when past the last line.\n\t\t    if (depth < 0)\n\t\t    {\n\t\t\tif (lnum >= end_lnum)\n\t\t\t    goto exit_matched;\n\t\t\tline = get_line_and_copy(++lnum, file_line);\n\t\t    }\n\t\t    else if (vim_fgets(line = file_line,\n\t\t\t\t\t\t      LSIZE, files[depth].fp))\n\t\t\tgoto exit_matched;\n\n\t\t    // we read a line, set \"already\" to check this \"line\" later\n\t\t    // if depth >= 0 we'll increase files[depth].lnum far\n\t\t    // below  -- Acevedo\n\t\t    already = aux = p = skipwhite(line);\n\t\t    p = find_word_start(p);\n\t\t    p = find_word_end(p);\n\t\t    if (p > aux)\n\t\t    {\n\t\t\tif (*aux != ')' && IObuff[i-1] != TAB)\n\t\t\t{\n\t\t\t    if (IObuff[i-1] != ' ')\n\t\t\t\tIObuff[i++] = ' ';\n\t\t\t    // IObuf =~ \"\\(\\k\\|\\i\\).* \", thus i >= 2\n\t\t\t    if (p_js\n\t\t\t\t&& (IObuff[i-2] == '.'\n\t\t\t\t    || (vim_strchr(p_cpo, CPO_JOINSP) == NULL\n\t\t\t\t\t&& (IObuff[i-2] == '?'\n\t\t\t\t\t    || IObuff[i-2] == '!'))))\n\t\t\t\tIObuff[i++] = ' ';\n\t\t\t}\n\t\t\t// copy as much as possible of the new word\n\t\t\tif (p - aux >= IOSIZE - i)\n\t\t\t    p = aux + IOSIZE - i - 1;\n\t\t\tSTRNCPY(IObuff + i, aux, p - aux);\n\t\t\ti += (int)(p - aux);\n\t\t\tcont_s_ipos = TRUE;\n\t\t    }\n\t\t    IObuff[i] = NUL;\n\t\t    aux = IObuff;\n\n\t\t    if (i == ins_compl_len())\n\t\t\tgoto exit_matched;\n\t\t}\n\n\t\tadd_r = ins_compl_add_infercase(aux, i, p_ic,\n\t\t\tcurr_fname == curbuf->b_fname ? NULL : curr_fname,\n\t\t\tdir, cont_s_ipos);\n\t\tif (add_r == OK)\n\t\t    // if dir was BACKWARD then honor it just once\n\t\t    dir = FORWARD;\n\t\telse if (add_r == FAIL)\n\t\t    break;\n\t    }\n\t    else if (action == ACTION_SHOW_ALL)\n\t    {\n\t\tfound = TRUE;\n\t\tif (!did_show)\n\t\t    gotocmdline(TRUE);\t\t// cursor at status line\n\t\tif (curr_fname != prev_fname)\n\t\t{\n\t\t    if (did_show)\n\t\t\tmsg_putchar('\\n');\t// cursor below last one\n\t\t    if (!got_int)\t\t// don't display if 'q' typed\n\t\t\t\t\t\t// at \"--more--\" message\n\t\t\tmsg_home_replace_hl(curr_fname);\n\t\t    prev_fname = curr_fname;\n\t\t}\n\t\tdid_show = TRUE;\n\t\tif (!got_int)\n\t\t    show_pat_in_path(line, type, TRUE, action,\n\t\t\t    (depth == -1) ? NULL : files[depth].fp,\n\t\t\t    (depth == -1) ? &lnum : &files[depth].lnum,\n\t\t\t    match_count++);\n\n\t\t// Set matched flag for this file and all the ones that\n\t\t// include it\n\t\tfor (i = 0; i <= depth; ++i)\n\t\t    files[i].matched = TRUE;\n\t    }\n\t    else if (--count <= 0)\n\t    {\n\t\tfound = TRUE;\n\t\tif (depth == -1 && lnum == curwin->w_cursor.lnum\n#if defined(FEAT_QUICKFIX)\n\t\t\t\t\t\t      && g_do_tagpreview == 0\n#endif\n\t\t\t\t\t\t      )\n\t\t    emsg(_(e_match_is_on_current_line));\n\t\telse if (action == ACTION_SHOW)\n\t\t{\n\t\t    show_pat_in_path(line, type, did_show, action,\n\t\t\t(depth == -1) ? NULL : files[depth].fp,\n\t\t\t(depth == -1) ? &lnum : &files[depth].lnum, 1L);\n\t\t    did_show = TRUE;\n\t\t}\n\t\telse\n\t\t{\n#ifdef FEAT_GUI\n\t\t    need_mouse_correct = TRUE;\n#endif\n#if defined(FEAT_QUICKFIX)\n\t\t    // \":psearch\" uses the preview window\n\t\t    if (g_do_tagpreview != 0)\n\t\t    {\n\t\t\tcurwin_save = curwin;\n\t\t\tprepare_tagpreview(TRUE, TRUE, FALSE);\n\t\t    }\n#endif\n\t\t    if (action == ACTION_SPLIT)\n\t\t    {\n\t\t\tif (win_split(0, 0) == FAIL)\n\t\t\t    break;\n\t\t\tRESET_BINDING(curwin);\n\t\t    }\n\t\t    if (depth == -1)\n\t\t    {\n\t\t\t// match in current file\n#if defined(FEAT_QUICKFIX)\n\t\t\tif (g_do_tagpreview != 0)\n\t\t\t{\n\t\t\t    if (!win_valid(curwin_save))\n\t\t\t\tbreak;\n\t\t\t    if (!GETFILE_SUCCESS(getfile(\n\t\t\t\t\t   curwin_save->w_buffer->b_fnum, NULL,\n\t\t\t\t\t\t     NULL, TRUE, lnum, FALSE)))\n\t\t\t\tbreak;\t// failed to jump to file\n\t\t\t}\n\t\t\telse\n#endif\n\t\t\t    setpcmark();\n\t\t\tcurwin->w_cursor.lnum = lnum;\n\t\t\tcheck_cursor();\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (!GETFILE_SUCCESS(getfile(\n\t\t\t\t\t0, files[depth].name, NULL, TRUE,\n\t\t\t\t\t\t    files[depth].lnum, FALSE)))\n\t\t\t    break;\t// failed to jump to file\n\t\t\t// autocommands may have changed the lnum, we don't\n\t\t\t// want that here\n\t\t\tcurwin->w_cursor.lnum = files[depth].lnum;\n\t\t    }\n\t\t}\n\t\tif (action != ACTION_SHOW)\n\t\t{\n\t\t    curwin->w_cursor.col = (colnr_T)(startp - line);\n\t\t    curwin->w_set_curswant = TRUE;\n\t\t}\n\n#if defined(FEAT_QUICKFIX)\n\t\tif (g_do_tagpreview != 0\n\t\t\t   && curwin != curwin_save && win_valid(curwin_save))\n\t\t{\n\t\t    // Return cursor to where we were\n\t\t    validate_cursor();\n\t\t    redraw_later(VALID);\n\t\t    win_enter(curwin_save, TRUE);\n\t\t}\n# ifdef FEAT_PROP_POPUP\n\t\telse if (WIN_IS_POPUP(curwin))\n\t\t    // can't keep focus in popup window\n\t\t    win_enter(firstwin, TRUE);\n# endif\n#endif\n\t\tbreak;\n\t    }\nexit_matched:\n\t    matched = FALSE;\n\t    // look for other matches in the rest of the line if we\n\t    // are not at the end of it already\n\t    if (def_regmatch.regprog == NULL\n\t\t    && action == ACTION_EXPAND\n\t\t    && !compl_status_sol()\n\t\t    && *startp != NUL\n\t\t    && *(p = startp + mb_ptr2len(startp)) != NUL)\n\t\tgoto search_line;\n\t}\n\tline_breakcheck();\n\tif (action == ACTION_EXPAND)\n\t    ins_compl_check_keys(30, FALSE);\n\tif (got_int || ins_compl_interrupted())\n\t    break;\n\n\t/*\n\t * Read the next line.  When reading an included file and encountering\n\t * end-of-file, close the file and continue in the file that included\n\t * it.\n\t */\n\twhile (depth >= 0 && !already\n\t\t&& vim_fgets(line = file_line, LSIZE, files[depth].fp))\n\t{\n\t    fclose(files[depth].fp);\n\t    --old_files;\n\t    files[old_files].name = files[depth].name;\n\t    files[old_files].matched = files[depth].matched;\n\t    --depth;\n\t    curr_fname = (depth == -1) ? curbuf->b_fname\n\t\t\t\t       : files[depth].name;\n\t    if (depth < depth_displayed)\n\t\tdepth_displayed = depth;\n\t}\n\tif (depth >= 0)\t\t// we could read the line\n\t{\n\t    files[depth].lnum++;\n\t    // Remove any CR and LF from the line.\n\t    i = (int)STRLEN(line);\n\t    if (i > 0 && line[i - 1] == '\\n')\n\t\tline[--i] = NUL;\n\t    if (i > 0 && line[i - 1] == '\\r')\n\t\tline[--i] = NUL;\n\t}\n\telse if (!already)\n\t{\n\t    if (++lnum > end_lnum)\n\t\tbreak;\n\t    line = get_line_and_copy(lnum, file_line);\n\t}\n\talready = NULL;\n    }\n    // End of big for (;;) loop.\n\n    // Close any files that are still open.\n    for (i = 0; i <= depth; i++)\n    {\n\tfclose(files[i].fp);\n\tvim_free(files[i].name);\n    }\n    for (i = old_files; i < max_path_depth; i++)\n\tvim_free(files[i].name);\n    vim_free(files);\n\n    if (type == CHECK_PATH)\n    {\n\tif (!did_show)\n\t{\n\t    if (action != ACTION_SHOW_ALL)\n\t\tmsg(_(\"All included files were found\"));\n\t    else\n\t\tmsg(_(\"No included files\"));\n\t}\n    }\n    else if (!found && action != ACTION_EXPAND)\n    {\n\tif (got_int || ins_compl_interrupted())\n\t    emsg(_(e_interrupted));\n\telse if (type == FIND_DEFINE)\n\t    emsg(_(e_couldnt_find_definition));\n\telse\n\t    emsg(_(e_couldnt_find_pattern));\n    }\n    if (action == ACTION_SHOW || action == ACTION_SHOW_ALL)\n\tmsg_end();\n\nfpip_end:\n    vim_free(file_line);\n    vim_regfree(regmatch.regprog);\n    vim_regfree(incl_regmatch.regprog);\n    vim_regfree(def_regmatch.regprog);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 165,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "GF_Err BD_DecMFFieldVec(GF_BifsDecoder * codec, GF_BitStream *bs, GF_Node *node, GF_FieldInfo *field, Bool is_mem_com)\n{\n\tGF_Err e;\n\tu32 NbBits, nbFields;\n\tu32 i;\n\tGF_ChildNodeItem *last;\n\tu8 qp_local, qp_on, initial_qp;\n\tGF_FieldInfo sffield;\n\n\tmemset(&sffield, 0, sizeof(GF_FieldInfo));\n\tsffield.fieldIndex = field->fieldIndex;\n\tsffield.fieldType = gf_sg_vrml_get_sf_type(field->fieldType);\n\tsffield.NDTtype = field->NDTtype;\n\tsffield.name = field->name;\n\n\tinitial_qp = qp_local = qp_on = 0;\n\n\t//vector description - alloc the MF size before\n\tNbBits = gf_bs_read_int(bs, 5);\n\tnbFields = gf_bs_read_int(bs, NbBits);\n\n\tif (codec->ActiveQP) {\n\t\tinitial_qp = 1;\n\t\t/*this is for QP 14*/\n\t\tgf_bifs_dec_qp14_set_length(codec, nbFields);\n\t}\n\n\tif (field->fieldType != GF_SG_VRML_MFNODE) {\n\t\te = gf_sg_vrml_mf_alloc(field->far_ptr, field->fieldType, nbFields);\n\t\tif (e) return e;\n\n\t\tfor (i=0; i<nbFields; i++) {\n\t\t\te = gf_sg_vrml_mf_get_item(field->far_ptr, field->fieldType, & sffield.far_ptr, i);\n\t\t\tif (e) return e;\n\t\t\te = gf_bifs_dec_sf_field(codec, bs, node, &sffield, GF_FALSE);\n\t\t\tif (e) return e;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\te = GF_OK;\n\tlast = NULL;\n\tfor (i=0; i<nbFields; i++) {\n\t\tGF_Node *new_node = gf_bifs_dec_node(codec, bs, field->NDTtype);\n\t\tif (new_node) {\n\t\t\te = gf_node_register(new_node, is_mem_com ? NULL : node);\n\t\t\tif (e) goto exit;\n\n\t\t\tif (node) {\n\t\t\t\t/*special case for QP, register as the current QP*/\n\t\t\t\tif (gf_node_get_tag(new_node) == TAG_MPEG4_QuantizationParameter) {\n\t\t\t\t\tqp_local = ((M_QuantizationParameter *)new_node)->isLocal;\n\t\t\t\t\t/*we have a QP in the same scope, remove previous\n\t\t\t\t\tNB: we assume this is the right behavior, the spec doesn't say\n\t\t\t\t\twhether QP is cumulative or not*/\n\t\t\t\t\tif (qp_on) gf_bifs_dec_qp_remove(codec, GF_FALSE);\n\n\t\t\t\t\te = gf_bifs_dec_qp_set(codec, new_node);\n\t\t\t\t\tif (e) goto exit;\n\t\t\t\t\tqp_on = 1;\n\t\t\t\t\tif (qp_local) qp_local = 2;\n\t\t\t\t\tif (codec->force_keep_qp) {\n\t\t\t\t\t\te = gf_node_list_add_child_last(field->far_ptr, new_node, &last);\n\t\t\t\t\t\tif (e) goto exit;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgf_node_register(new_node, NULL);\n\t\t\t\t\t\tgf_node_unregister(new_node, node);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\te = gf_node_list_add_child_last(field->far_ptr, new_node, &last);\n\t\t\t\t\tif (e) goto exit;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*proto coding*/\n\t\t\telse if (codec->pCurrentProto) {\n\t\t\t\t/*TO DO: what happens if this is a QP node on the interface ?*/\n\t\t\t\te = gf_node_list_add_child_last( (GF_ChildNodeItem **)field->far_ptr, new_node, &last);\n\t\t\t\tif (e)goto exit;\n\t\t\t}\n\t\t} else {\n\t\t\te = codec->LastError ? codec->LastError : GF_NON_COMPLIANT_BITSTREAM;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\nexit:\n\n\t/*according to the spec, the QP applies to the current node itself, not just children.\n\tIf IsLocal is TRUE remove the node*/\n\tif (qp_on && qp_local) {\n\t\tif (qp_local == 2) {\n//\t\t\t\tqp_local = 1;\n\t\t} else {\n\t\t\t//ask to get rid of QP and reactivate if we had a QP when entering the node\n\t\t\tgf_bifs_dec_qp_remove(codec, initial_qp);\n//\t\t\t\tqp_local = 0;\n\t\t}\n\t}\n\n\t/*finally delete the QP if any (local or not) as we get out of this node*/\n\tif (qp_on) gf_bifs_dec_qp_remove(codec, GF_TRUE);\n\treturn e;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 245,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "njs_function_frame_save(njs_vm_t *vm, njs_frame_t *frame, u_char *pc)\n{\n    size_t              value_count, n;\n    njs_value_t         *start, *end, *p, **new, *value, **local;\n    njs_function_t      *function;\n    njs_native_frame_t  *active, *native;\n\n    *frame = *vm->active_frame;\n\n    frame->previous_active_frame = NULL;\n\n    native = &frame->native;\n    native->size = 0;\n    native->free = NULL;\n    native->free_size = 0;\n\n    active = &vm->active_frame->native;\n    value_count = njs_function_frame_value_count(active);\n\n    function = active->function;\n\n    new = (njs_value_t **) ((u_char *) native + NJS_FRAME_SIZE);\n    value = (njs_value_t *) (new + value_count\n                             + function->u.lambda->temp);\n\n\n    native->arguments = value;\n    native->arguments_offset = value + (function->args_offset - 1);\n    native->local = new + njs_function_frame_args_count(active);\n    native->temp = new + value_count;\n    native->pc = pc;\n\n    start = njs_function_frame_values(active, &end);\n    p = native->arguments;\n\n    while (start < end) {\n        *p = *start++;\n        *new++ = p++;\n    }\n\n    /* Move all arguments. */\n\n    p = native->arguments;\n    local = native->local + function->args_offset;\n\n    for (n = 0; n < function->args_count; n++) {\n        if (!njs_is_valid(p)) {\n            njs_set_undefined(p);\n        }\n\n        *local++ = p++;\n    }\n\n    return NJS_OK;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 255,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "net_bind(short unsigned *port, int type, const char *log_service_name)\n{\n  struct addrinfo hints = { 0 };\n  struct addrinfo *servinfo;\n  struct addrinfo *ptr;\n  union net_sockaddr naddr = { 0 };\n  socklen_t naddr_len = sizeof(naddr);\n  const char *cfgaddr;\n  char addr[INET6_ADDRSTRLEN];\n  char strport[8];\n  int yes = 1;\n  int no = 0;\n  int fd;\n  int ret;\n\n  cfgaddr = cfg_getstr(cfg_getsec(cfg, \"general\"), \"bind_address\");\n\n  hints.ai_socktype = (type & (SOCK_STREAM | SOCK_DGRAM)); // filter since type can be SOCK_STREAM | SOCK_NONBLOCK\n  hints.ai_family = (cfg_getbool(cfg_getsec(cfg, \"general\"), \"ipv6\")) ? AF_INET6 : AF_INET;\n  hints.ai_flags = cfgaddr ? 0 : AI_PASSIVE;\n\n  snprintf(strport, sizeof(strport), \"%hu\", *port);\n  ret = getaddrinfo(cfgaddr, strport, &hints, &servinfo);\n  if (ret < 0)\n    {\n      DPRINTF(E_LOG, L_MISC, \"Failure creating '%s' service, could not resolve '%s' (port %s): %s\\n\", log_service_name, cfgaddr ? cfgaddr : \"(ANY)\", strport, gai_strerror(ret));\n      return -1;\n    }\n\n  for (ptr = servinfo, fd = -1; ptr != NULL; ptr = ptr->ai_next)\n    {\n      if (fd >= 0)\n\tclose(fd);\n\n      fd = socket(ptr->ai_family, type | SOCK_CLOEXEC, ptr->ai_protocol);\n      if (fd < 0)\n\tcontinue;\n\n      // TODO libevent sets this, we do the same?\n      ret = setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &yes, sizeof(yes));\n      if (ret < 0)\n\tcontinue;\n\n      ret = setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));\n      if (ret < 0)\n\tcontinue;\n\n      if (ptr->ai_family == AF_INET6)\n\t{\n\t  // We want to be sure the service is dual stack\n\t  ret = setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, &no, sizeof(no));\n\t  if (ret < 0)\n\t    continue;\n\t}\n\n      ret = bind(fd, ptr->ai_addr, ptr->ai_addrlen);\n      if (ret < 0)\n\tcontinue;\n\n      break;\n    }\n\n  freeaddrinfo(servinfo);\n\n  if (!ptr)\n    {\n      DPRINTF(E_LOG, L_MISC, \"Could not create service '%s' with address %s, port %hu: %s\\n\", log_service_name, cfgaddr ? cfgaddr : \"(ANY)\", *port, strerror(errno));\n      goto error;\n    }\n\n  // Get our address (as string) and the port that was assigned (necessary when\n  // caller didn't specify a port)\n  ret = getsockname(fd, &naddr.sa, &naddr_len);\n  if (ret < 0)\n    {\n      DPRINTF(E_LOG, L_MISC, \"Error finding address of service '%s': %s\\n\", log_service_name, strerror(errno));\n      goto error;\n    }\n  else if (naddr_len > sizeof(naddr))\n    {\n      DPRINTF(E_LOG, L_MISC, \"Unexpected address length of service '%s'\\n\", log_service_name);\n      goto error;\n    }\n\n  net_port_get(port, &naddr);\n  net_address_get(addr, sizeof(addr), &naddr);\n\n  DPRINTF(E_DBG, L_MISC, \"Service '%s' bound to %s, port %hu, socket %d\\n\", log_service_name, addr, *port, fd);\n\n  return fd;\n\n error:\n  close(fd);\n  return -1;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 296,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "njs_await_fulfilled(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    njs_int_t           ret;\n    njs_value_t         **cur_local, **cur_closures, **cur_temp, *value;\n    njs_frame_t         *frame, *async_frame;\n    njs_async_ctx_t     *ctx;\n    njs_native_frame_t  *top, *async;\n\n    ctx = vm->top_frame->function->context;\n\n    value = njs_arg(args, nargs, 1);\n    if (njs_is_error(value)) {\n        goto failed;\n    }\n\n    async_frame = ctx->await;\n    async = &async_frame->native;\n    async->previous = vm->top_frame;\n\n    cur_local = vm->levels[NJS_LEVEL_LOCAL];\n    cur_closures = vm->levels[NJS_LEVEL_CLOSURE];\n    cur_temp = vm->levels[NJS_LEVEL_TEMP];\n    top = vm->top_frame;\n    frame = vm->active_frame;\n\n    vm->levels[NJS_LEVEL_LOCAL] = async->local;\n    vm->levels[NJS_LEVEL_CLOSURE] = njs_function_closures(async->function);\n    vm->levels[NJS_LEVEL_TEMP] = async->temp;\n\n    vm->top_frame = async;\n    vm->active_frame = async_frame;\n\n    *njs_scope_value(vm, ctx->index) = *value;\n    vm->retval = *value;\n\n    vm->top_frame->retval = &vm->retval;\n\n    ret = njs_vmcode_interpreter(vm, ctx->pc, ctx->capability, ctx);\n\n    vm->levels[NJS_LEVEL_LOCAL] = cur_local;\n    vm->levels[NJS_LEVEL_CLOSURE] = cur_closures;\n    vm->levels[NJS_LEVEL_TEMP] = cur_temp;\n\n    vm->top_frame = top;\n    vm->active_frame = frame;\n\n    if (ret == NJS_OK) {\n        ret = njs_function_call(vm, njs_function(&ctx->capability->resolve),\n                            &njs_value_undefined, &vm->retval, 1, &vm->retval);\n\n        njs_async_context_free(vm, ctx);\n\n    } else if (ret == NJS_AGAIN) {\n        ret = NJS_OK;\n\n    } else if (ret == NJS_ERROR) {\n        if (njs_is_memory_error(vm, &vm->retval)) {\n            return NJS_ERROR;\n        }\n\n        value = &vm->retval;\n\n        goto failed;\n    }\n\n    return ret;\n\nfailed:\n\n    (void) njs_function_call(vm, njs_function(&ctx->capability->reject),\n                             &njs_value_undefined, value, 1, &vm->retval);\n\n    njs_async_context_free(vm, ctx);\n\n    return NJS_ERROR;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 308,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "  void Compute(OpKernelContext* context) override {\n    // Get the stamp token.\n    const Tensor* stamp_token_t;\n    OP_REQUIRES_OK(context, context->input(\"stamp_token\", &stamp_token_t));\n    int64_t stamp_token = stamp_token_t->scalar<int64>()();\n\n    // Get the tree ensemble proto.\n    const Tensor* tree_ensemble_serialized_t;\n    OP_REQUIRES_OK(context, context->input(\"tree_ensemble_serialized\",\n                                           &tree_ensemble_serialized_t));\n    std::unique_ptr<BoostedTreesEnsembleResource> result(\n        new BoostedTreesEnsembleResource());\n    if (!result->InitFromSerialized(\n            tree_ensemble_serialized_t->scalar<tstring>()(), stamp_token)) {\n      result->Unref();\n      result.release();  // Needed due to the `->Unref` above, to prevent UAF\n      OP_REQUIRES(\n          context, false,\n          errors::InvalidArgument(\"Unable to parse tree ensemble proto.\"));\n    }\n\n    // Only create one, if one does not exist already. Report status for all\n    // other exceptions.\n    auto status =\n        CreateResource(context, HandleFromInput(context, 0), result.release());\n    if (status.code() != tensorflow::error::ALREADY_EXISTS) {\n      OP_REQUIRES_OK(context, status);\n    }\n  }",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 312,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "ex_substitute(exarg_T *eap)\n{\n    linenr_T\tlnum;\n    long\ti = 0;\n    regmmatch_T regmatch;\n    static subflags_T subflags = {FALSE, FALSE, FALSE, TRUE, FALSE,\n\t\t\t\t\t\t\t      FALSE, FALSE, 0};\n#ifdef FEAT_EVAL\n    subflags_T\tsubflags_save;\n#endif\n    int\t\tsave_do_all;\t\t// remember user specified 'g' flag\n    int\t\tsave_do_ask;\t\t// remember user specified 'c' flag\n    char_u\t*pat = NULL, *sub = NULL;\t// init for GCC\n    char_u\t*sub_copy = NULL;\n    int\t\tdelimiter;\n    int\t\tsublen;\n    int\t\tgot_quit = FALSE;\n    int\t\tgot_match = FALSE;\n    int\t\ttemp;\n    int\t\twhich_pat;\n    char_u\t*cmd;\n    int\t\tsave_State;\n    linenr_T\tfirst_line = 0;\t\t// first changed line\n    linenr_T\tlast_line= 0;\t\t// below last changed line AFTER the\n\t\t\t\t\t// change\n    linenr_T\told_line_count = curbuf->b_ml.ml_line_count;\n    linenr_T\tline2;\n    long\tnmatch;\t\t\t// number of lines in match\n    char_u\t*sub_firstline;\t\t// allocated copy of first sub line\n    int\t\tendcolumn = FALSE;\t// cursor in last column when done\n    pos_T\told_cursor = curwin->w_cursor;\n    int\t\tstart_nsubs;\n#ifdef FEAT_EVAL\n    int\t\tsave_ma = 0;\n#endif\n\n    cmd = eap->arg;\n    if (!global_busy)\n    {\n\tsub_nsubs = 0;\n\tsub_nlines = 0;\n    }\n    start_nsubs = sub_nsubs;\n\n    if (eap->cmdidx == CMD_tilde)\n\twhich_pat = RE_LAST;\t// use last used regexp\n    else\n\twhich_pat = RE_SUBST;\t// use last substitute regexp\n\n\t\t\t\t// new pattern and substitution\n    if (eap->cmd[0] == 's' && *cmd != NUL && !VIM_ISWHITE(*cmd)\n\t\t&& vim_strchr((char_u *)\"0123456789cegriIp|\\\"\", *cmd) == NULL)\n    {\n\t\t\t\t// don't accept alphanumeric for separator\n\tif (check_regexp_delim(*cmd) == FAIL)\n\t    return;\n#ifdef FEAT_EVAL\n\tif (in_vim9script() && check_global_and_subst(eap->cmd, eap->arg)\n\t\t\t\t\t\t\t\t      == FAIL)\n\t    return;\n#endif\n\n\t/*\n\t * undocumented vi feature:\n\t *  \"\\/sub/\" and \"\\?sub?\" use last used search pattern (almost like\n\t *  //sub/r).  \"\\&sub&\" use last substitute pattern (like //sub/).\n\t */\n\tif (*cmd == '\\\\')\n\t{\n\t    ++cmd;\n\t    if (vim_strchr((char_u *)\"/?&\", *cmd) == NULL)\n\t    {\n\t\temsg(_(e_backslash_should_be_followed_by));\n\t\treturn;\n\t    }\n\t    if (*cmd != '&')\n\t\twhich_pat = RE_SEARCH;\t    // use last '/' pattern\n\t    pat = (char_u *)\"\";\t\t    // empty search pattern\n\t    delimiter = *cmd++;\t\t    // remember delimiter character\n\t}\n\telse\t\t// find the end of the regexp\n\t{\n\t    which_pat = RE_LAST;\t    // use last used regexp\n\t    delimiter = *cmd++;\t\t    // remember delimiter character\n\t    pat = cmd;\t\t\t    // remember start of search pat\n\t    cmd = skip_regexp_ex(cmd, delimiter, magic_isset(),\n\t\t\t\t\t\t\t&eap->arg, NULL, NULL);\n\t    if (cmd[0] == delimiter)\t    // end delimiter found\n\t\t*cmd++ = NUL;\t\t    // replace it with a NUL\n\t}\n\n\t/*\n\t * Small incompatibility: vi sees '\\n' as end of the command, but in\n\t * Vim we want to use '\\n' to find/substitute a NUL.\n\t */\n\tsub = cmd;\t    // remember the start of the substitution\n\tcmd = skip_substitute(cmd, delimiter);\n\n\tif (!eap->skip)\n\t{\n\t    // In POSIX vi \":s/pat/%/\" uses the previous subst. string.\n\t    if (STRCMP(sub, \"%\") == 0\n\t\t\t\t && vim_strchr(p_cpo, CPO_SUBPERCENT) != NULL)\n\t    {\n\t\tif (old_sub == NULL)\t// there is no previous command\n\t\t{\n\t\t    emsg(_(e_no_previous_substitute_regular_expression));\n\t\t    return;\n\t\t}\n\t\tsub = old_sub;\n\t    }\n\t    else\n\t    {\n\t\tvim_free(old_sub);\n\t\told_sub = vim_strsave(sub);\n\t    }\n\t}\n    }\n    else if (!eap->skip)\t// use previous pattern and substitution\n    {\n\tif (old_sub == NULL)\t// there is no previous command\n\t{\n\t    emsg(_(e_no_previous_substitute_regular_expression));\n\t    return;\n\t}\n\tpat = NULL;\t\t// search_regcomp() will use previous pattern\n\tsub = old_sub;\n\n\t// Vi compatibility quirk: repeating with \":s\" keeps the cursor in the\n\t// last column after using \"$\".\n\tendcolumn = (curwin->w_curswant == MAXCOL);\n    }\n\n    // Recognize \":%s/\\n//\" and turn it into a join command, which is much\n    // more efficient.\n    // TODO: find a generic solution to make line-joining operations more\n    // efficient, avoid allocating a string that grows in size.\n    if (pat != NULL && STRCMP(pat, \"\\\\n\") == 0\n\t    && *sub == NUL\n\t    && (*cmd == NUL || (cmd[1] == NUL && (*cmd == 'g' || *cmd == 'l'\n\t\t\t\t\t     || *cmd == 'p' || *cmd == '#'))))\n    {\n\tlinenr_T    joined_lines_count;\n\n\tif (eap->skip)\n\t    return;\n\tcurwin->w_cursor.lnum = eap->line1;\n\tif (*cmd == 'l')\n\t    eap->flags = EXFLAG_LIST;\n\telse if (*cmd == '#')\n\t    eap->flags = EXFLAG_NR;\n\telse if (*cmd == 'p')\n\t    eap->flags = EXFLAG_PRINT;\n\n\t// The number of lines joined is the number of lines in the range plus\n\t// one.  One less when the last line is included.\n\tjoined_lines_count = eap->line2 - eap->line1 + 1;\n\tif (eap->line2 < curbuf->b_ml.ml_line_count)\n\t    ++joined_lines_count;\n\tif (joined_lines_count > 1)\n\t{\n\t    (void)do_join(joined_lines_count, FALSE, TRUE, FALSE, TRUE);\n\t    sub_nsubs = joined_lines_count - 1;\n\t    sub_nlines = 1;\n\t    (void)do_sub_msg(FALSE);\n\t    ex_may_print(eap);\n\t}\n\n\tif ((cmdmod.cmod_flags & CMOD_KEEPPATTERNS) == 0)\n\t    save_re_pat(RE_SUBST, pat, magic_isset());\n\t// put pattern in history\n\tadd_to_history(HIST_SEARCH, pat, TRUE, NUL);\n\n\treturn;\n    }\n\n    /*\n     * Find trailing options.  When '&' is used, keep old options.\n     */\n    if (*cmd == '&')\n\t++cmd;\n    else\n    {\n#ifdef FEAT_EVAL\n\tif (in_vim9script())\n\t{\n\t    // ignore 'gdefault' and 'edcompatible'\n\t    subflags.do_all = FALSE;\n\t    subflags.do_ask = FALSE;\n\t}\n\telse\n#endif\n\tif (!p_ed)\n\t{\n\t    if (p_gd)\t\t// default is global on\n\t\tsubflags.do_all = TRUE;\n\t    else\n\t\tsubflags.do_all = FALSE;\n\t    subflags.do_ask = FALSE;\n\t}\n\tsubflags.do_error = TRUE;\n\tsubflags.do_print = FALSE;\n\tsubflags.do_list = FALSE;\n\tsubflags.do_count = FALSE;\n\tsubflags.do_number = FALSE;\n\tsubflags.do_ic = 0;\n    }\n    while (*cmd)\n    {\n\t/*\n\t * Note that 'g' and 'c' are always inverted, also when p_ed is off.\n\t * 'r' is never inverted.\n\t */\n\tif (*cmd == 'g')\n\t    subflags.do_all = !subflags.do_all;\n\telse if (*cmd == 'c')\n\t    subflags.do_ask = !subflags.do_ask;\n\telse if (*cmd == 'n')\n\t    subflags.do_count = TRUE;\n\telse if (*cmd == 'e')\n\t    subflags.do_error = !subflags.do_error;\n\telse if (*cmd == 'r')\t    // use last used regexp\n\t    which_pat = RE_LAST;\n\telse if (*cmd == 'p')\n\t    subflags.do_print = TRUE;\n\telse if (*cmd == '#')\n\t{\n\t    subflags.do_print = TRUE;\n\t    subflags.do_number = TRUE;\n\t}\n\telse if (*cmd == 'l')\n\t{\n\t    subflags.do_print = TRUE;\n\t    subflags.do_list = TRUE;\n\t}\n\telse if (*cmd == 'i')\t    // ignore case\n\t    subflags.do_ic = 'i';\n\telse if (*cmd == 'I')\t    // don't ignore case\n\t    subflags.do_ic = 'I';\n\telse\n\t    break;\n\t++cmd;\n    }\n    if (subflags.do_count)\n\tsubflags.do_ask = FALSE;\n\n    save_do_all = subflags.do_all;\n    save_do_ask = subflags.do_ask;\n\n    /*\n     * check for a trailing count\n     */\n    cmd = skipwhite(cmd);\n    if (VIM_ISDIGIT(*cmd))\n    {\n\ti = getdigits(&cmd);\n\tif (i <= 0 && !eap->skip && subflags.do_error)\n\t{\n\t    emsg(_(e_positive_count_required));\n\t    return;\n\t}\n\teap->line1 = eap->line2;\n\teap->line2 += i - 1;\n\tif (eap->line2 > curbuf->b_ml.ml_line_count)\n\t    eap->line2 = curbuf->b_ml.ml_line_count;\n    }\n\n    /*\n     * check for trailing command or garbage\n     */\n    cmd = skipwhite(cmd);\n    if (*cmd && *cmd != '\"')\t    // if not end-of-line or comment\n    {\n\tset_nextcmd(eap, cmd);\n\tif (eap->nextcmd == NULL)\n\t{\n\t    semsg(_(e_trailing_characters_str), cmd);\n\t    return;\n\t}\n    }\n\n    if (eap->skip)\t    // not executing commands, only parsing\n\treturn;\n\n    if (!subflags.do_count && !curbuf->b_p_ma)\n    {\n\t// Substitution is not allowed in non-'modifiable' buffer\n\temsg(_(e_cannot_make_changes_modifiable_is_off));\n\treturn;\n    }\n\n    if (search_regcomp(pat, RE_SUBST, which_pat, SEARCH_HIS, &regmatch) == FAIL)\n    {\n\tif (subflags.do_error)\n\t    emsg(_(e_invalid_command));\n\treturn;\n    }\n\n    // the 'i' or 'I' flag overrules 'ignorecase' and 'smartcase'\n    if (subflags.do_ic == 'i')\n\tregmatch.rmm_ic = TRUE;\n    else if (subflags.do_ic == 'I')\n\tregmatch.rmm_ic = FALSE;\n\n    sub_firstline = NULL;\n\n    /*\n     * If the substitute pattern starts with \"\\=\" then it's an expression.\n     * Make a copy, a recursive function may free it.\n     * Otherwise, '~' in the substitute pattern is replaced with the old\n     * pattern.  We do it here once to avoid it to be replaced over and over\n     * again.\n     */\n    if (sub[0] == '\\\\' && sub[1] == '=')\n    {\n\tsub = vim_strsave(sub);\n\tif (sub == NULL)\n\t    return;\n\tsub_copy = sub;\n    }\n    else\n\tsub = regtilde(sub, magic_isset());\n\n    /*\n     * Check for a match on each line.\n     */\n    line2 = eap->line2;\n    for (lnum = eap->line1; lnum <= line2 && !(got_quit\n#if defined(FEAT_EVAL)\n\t\t|| aborting()\n#endif\n\t\t); ++lnum)\n    {\n\tnmatch = vim_regexec_multi(&regmatch, curwin, curbuf, lnum,\n\t\t\t\t\t\t       (colnr_T)0, NULL, NULL);\n\tif (nmatch)\n\t{\n\t    colnr_T\tcopycol;\n\t    colnr_T\tmatchcol;\n\t    colnr_T\tprev_matchcol = MAXCOL;\n\t    char_u\t*new_end, *new_start = NULL;\n\t    unsigned\tnew_start_len = 0;\n\t    char_u\t*p1;\n\t    int\t\tdid_sub = FALSE;\n\t    int\t\tlastone;\n\t    int\t\tlen, copy_len, needed_len;\n\t    long\tnmatch_tl = 0;\t// nr of lines matched below lnum\n\t    int\t\tdo_again;\t// do it again after joining lines\n\t    int\t\tskip_match = FALSE;\n\t    linenr_T\tsub_firstlnum;\t// nr of first sub line\n#ifdef FEAT_PROP_POPUP\n\t    int\t\tapc_flags = APC_SAVE_FOR_UNDO | APC_SUBSTITUTE;\n\t    colnr_T\ttotal_added =  0;\n#endif\n\n\t    /*\n\t     * The new text is build up step by step, to avoid too much\n\t     * copying.  There are these pieces:\n\t     * sub_firstline\tThe old text, unmodified.\n\t     * copycol\t\tColumn in the old text where we started\n\t     *\t\t\tlooking for a match; from here old text still\n\t     *\t\t\tneeds to be copied to the new text.\n\t     * matchcol\t\tColumn number of the old text where to look\n\t     *\t\t\tfor the next match.  It's just after the\n\t     *\t\t\tprevious match or one further.\n\t     * prev_matchcol\tColumn just after the previous match (if any).\n\t     *\t\t\tMostly equal to matchcol, except for the first\n\t     *\t\t\tmatch and after skipping an empty match.\n\t     * regmatch.*pos\tWhere the pattern matched in the old text.\n\t     * new_start\tThe new text, all that has been produced so\n\t     *\t\t\tfar.\n\t     * new_end\t\tThe new text, where to append new text.\n\t     *\n\t     * lnum\t\tThe line number where we found the start of\n\t     *\t\t\tthe match.  Can be below the line we searched\n\t     *\t\t\twhen there is a \\n before a \\zs in the\n\t     *\t\t\tpattern.\n\t     * sub_firstlnum\tThe line number in the buffer where to look\n\t     *\t\t\tfor a match.  Can be different from \"lnum\"\n\t     *\t\t\twhen the pattern or substitute string contains\n\t     *\t\t\tline breaks.\n\t     *\n\t     * Special situations:\n\t     * - When the substitute string contains a line break, the part up\n\t     *   to the line break is inserted in the text, but the copy of\n\t     *   the original line is kept.  \"sub_firstlnum\" is adjusted for\n\t     *   the inserted lines.\n\t     * - When the matched pattern contains a line break, the old line\n\t     *   is taken from the line at the end of the pattern.  The lines\n\t     *   in the match are deleted later, \"sub_firstlnum\" is adjusted\n\t     *   accordingly.\n\t     *\n\t     * The new text is built up in new_start[].  It has some extra\n\t     * room to avoid using alloc()/free() too often.  new_start_len is\n\t     * the length of the allocated memory at new_start.\n\t     *\n\t     * Make a copy of the old line, so it won't be taken away when\n\t     * updating the screen or handling a multi-line match.  The \"old_\"\n\t     * pointers point into this copy.\n\t     */\n\t    sub_firstlnum = lnum;\n\t    copycol = 0;\n\t    matchcol = 0;\n\n\t    // At first match, remember current cursor position.\n\t    if (!got_match)\n\t    {\n\t\tsetpcmark();\n\t\tgot_match = TRUE;\n\t    }\n\n\t    /*\n\t     * Loop until nothing more to replace in this line.\n\t     * 1. Handle match with empty string.\n\t     * 2. If do_ask is set, ask for confirmation.\n\t     * 3. substitute the string.\n\t     * 4. if do_all is set, find next match\n\t     * 5. break if there isn't another match in this line\n\t     */\n\t    for (;;)\n\t    {\n\t\t// Advance \"lnum\" to the line where the match starts.  The\n\t\t// match does not start in the first line when there is a line\n\t\t// break before \\zs.\n\t\tif (regmatch.startpos[0].lnum > 0)\n\t\t{\n\t\t    lnum += regmatch.startpos[0].lnum;\n\t\t    sub_firstlnum += regmatch.startpos[0].lnum;\n\t\t    nmatch -= regmatch.startpos[0].lnum;\n\t\t    VIM_CLEAR(sub_firstline);\n\t\t}\n\n\t\t// Match might be after the last line for \"\\n\\zs\" matching at\n\t\t// the end of the last line.\n\t\tif (lnum > curbuf->b_ml.ml_line_count)\n\t\t    break;\n\n\t\tif (sub_firstline == NULL)\n\t\t{\n\t\t    sub_firstline = vim_strsave(ml_get(sub_firstlnum));\n\t\t    if (sub_firstline == NULL)\n\t\t    {\n\t\t\tvim_free(new_start);\n\t\t\tgoto outofmem;\n\t\t    }\n\t\t}\n\n\t\t// Save the line number of the last change for the final\n\t\t// cursor position (just like Vi).\n\t\tcurwin->w_cursor.lnum = lnum;\n\t\tdo_again = FALSE;\n\n\t\t/*\n\t\t * 1. Match empty string does not count, except for first\n\t\t * match.  This reproduces the strange vi behaviour.\n\t\t * This also catches endless loops.\n\t\t */\n\t\tif (matchcol == prev_matchcol\n\t\t\t&& regmatch.endpos[0].lnum == 0\n\t\t\t&& matchcol == regmatch.endpos[0].col)\n\t\t{\n\t\t    if (sub_firstline[matchcol] == NUL)\n\t\t\t// We already were at the end of the line.  Don't look\n\t\t\t// for a match in this line again.\n\t\t\tskip_match = TRUE;\n\t\t    else\n\t\t    {\n\t\t\t // search for a match at next column\n\t\t\tif (has_mbyte)\n\t\t\t    matchcol += mb_ptr2len(sub_firstline + matchcol);\n\t\t\telse\n\t\t\t    ++matchcol;\n\t\t    }\n\t\t    goto skip;\n\t\t}\n\n\t\t// Normally we continue searching for a match just after the\n\t\t// previous match.\n\t\tmatchcol = regmatch.endpos[0].col;\n\t\tprev_matchcol = matchcol;\n\n\t\t/*\n\t\t * 2. If do_count is set only increase the counter.\n\t\t *    If do_ask is set, ask for confirmation.\n\t\t */\n\t\tif (subflags.do_count)\n\t\t{\n\t\t    // For a multi-line match, put matchcol at the NUL at\n\t\t    // the end of the line and set nmatch to one, so that\n\t\t    // we continue looking for a match on the next line.\n\t\t    // Avoids that \":s/\\nB\\@=//gc\" get stuck.\n\t\t    if (nmatch > 1)\n\t\t    {\n\t\t\tmatchcol = (colnr_T)STRLEN(sub_firstline);\n\t\t\tnmatch = 1;\n\t\t\tskip_match = TRUE;\n\t\t    }\n\t\t    sub_nsubs++;\n\t\t    did_sub = TRUE;\n#ifdef FEAT_EVAL\n\t\t    // Skip the substitution, unless an expression is used,\n\t\t    // then it is evaluated in the sandbox.\n\t\t    if (!(sub[0] == '\\\\' && sub[1] == '='))\n#endif\n\t\t\tgoto skip;\n\t\t}\n\n\t\tif (subflags.do_ask)\n\t\t{\n\t\t    int typed = 0;\n\n\t\t    // change State to CONFIRM, so that the mouse works\n\t\t    // properly\n\t\t    save_State = State;\n\t\t    State = CONFIRM;\n\t\t    setmouse();\t\t// disable mouse in xterm\n\t\t    curwin->w_cursor.col = regmatch.startpos[0].col;\n\t\t    if (curwin->w_p_crb)\n\t\t\tdo_check_cursorbind();\n\n\t\t    // When 'cpoptions' contains \"u\" don't sync undo when\n\t\t    // asking for confirmation.\n\t\t    if (vim_strchr(p_cpo, CPO_UNDO) != NULL)\n\t\t\t++no_u_sync;\n\n\t\t    /*\n\t\t     * Loop until 'y', 'n', 'q', CTRL-E or CTRL-Y typed.\n\t\t     */\n\t\t    while (subflags.do_ask)\n\t\t    {\n\t\t\tif (exmode_active)\n\t\t\t{\n\t\t\t    char_u\t*resp;\n\t\t\t    colnr_T\tsc, ec;\n\n\t\t\t    print_line_no_prefix(lnum,\n\t\t\t\t\t subflags.do_number, subflags.do_list);\n\n\t\t\t    getvcol(curwin, &curwin->w_cursor, &sc, NULL, NULL);\n\t\t\t    curwin->w_cursor.col = regmatch.endpos[0].col - 1;\n\t\t\t    if (curwin->w_cursor.col < 0)\n\t\t\t\tcurwin->w_cursor.col = 0;\n\t\t\t    getvcol(curwin, &curwin->w_cursor, NULL, NULL, &ec);\n\t\t\t    curwin->w_cursor.col = regmatch.startpos[0].col;\n\t\t\t    if (subflags.do_number || curwin->w_p_nu)\n\t\t\t    {\n\t\t\t\tint numw = number_width(curwin) + 1;\n\t\t\t\tsc += numw;\n\t\t\t\tec += numw;\n\t\t\t    }\n\t\t\t    msg_start();\n\t\t\t    for (i = 0; i < (long)sc; ++i)\n\t\t\t\tmsg_putchar(' ');\n\t\t\t    for ( ; i <= (long)ec; ++i)\n\t\t\t\tmsg_putchar('^');\n\n\t\t\t    resp = getexmodeline('?', NULL, 0, TRUE);\n\t\t\t    if (resp != NULL)\n\t\t\t    {\n\t\t\t\ttyped = *resp;\n\t\t\t\tvim_free(resp);\n\t\t\t    }\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    char_u *orig_line = NULL;\n\t\t\t    int    len_change = 0;\n\t\t\t    int\t   save_p_lz = p_lz;\n#ifdef FEAT_FOLDING\n\t\t\t    int save_p_fen = curwin->w_p_fen;\n\n\t\t\t    curwin->w_p_fen = FALSE;\n#endif\n\t\t\t    // Invert the matched string.\n\t\t\t    // Remove the inversion afterwards.\n\t\t\t    temp = RedrawingDisabled;\n\t\t\t    RedrawingDisabled = 0;\n\n\t\t\t    // avoid calling update_screen() in vgetorpeek()\n\t\t\t    p_lz = FALSE;\n\n\t\t\t    if (new_start != NULL)\n\t\t\t    {\n\t\t\t\t// There already was a substitution, we would\n\t\t\t\t// like to show this to the user.  We cannot\n\t\t\t\t// really update the line, it would change\n\t\t\t\t// what matches.  Temporarily replace the line\n\t\t\t\t// and change it back afterwards.\n\t\t\t\torig_line = vim_strsave(ml_get(lnum));\n\t\t\t\tif (orig_line != NULL)\n\t\t\t\t{\n\t\t\t\t    char_u *new_line = concat_str(new_start,\n\t\t\t\t\t\t     sub_firstline + copycol);\n\n\t\t\t\t    if (new_line == NULL)\n\t\t\t\t\tVIM_CLEAR(orig_line);\n\t\t\t\t    else\n\t\t\t\t    {\n\t\t\t\t\t// Position the cursor relative to the\n\t\t\t\t\t// end of the line, the previous\n\t\t\t\t\t// substitute may have inserted or\n\t\t\t\t\t// deleted characters before the\n\t\t\t\t\t// cursor.\n\t\t\t\t\tlen_change = (int)STRLEN(new_line)\n\t\t\t\t\t\t     - (int)STRLEN(orig_line);\n\t\t\t\t\tcurwin->w_cursor.col += len_change;\n\t\t\t\t\tml_replace(lnum, new_line, FALSE);\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t    }\n\n\t\t\t    search_match_lines = regmatch.endpos[0].lnum\n\t\t\t\t\t\t  - regmatch.startpos[0].lnum;\n\t\t\t    search_match_endcol = regmatch.endpos[0].col\n\t\t\t\t\t\t\t\t + len_change;\n\t\t\t    highlight_match = TRUE;\n\n\t\t\t    update_topline();\n\t\t\t    validate_cursor();\n\t\t\t    update_screen(SOME_VALID);\n\t\t\t    highlight_match = FALSE;\n\t\t\t    redraw_later(SOME_VALID);\n\n#ifdef FEAT_FOLDING\n\t\t\t    curwin->w_p_fen = save_p_fen;\n#endif\n\t\t\t    if (msg_row == Rows - 1)\n\t\t\t\tmsg_didout = FALSE;\t// avoid a scroll-up\n\t\t\t    msg_starthere();\n\t\t\t    i = msg_scroll;\n\t\t\t    msg_scroll = 0;\t\t// truncate msg when\n\t\t\t\t\t\t\t// needed\n\t\t\t    msg_no_more = TRUE;\n\t\t\t    // write message same highlighting as for\n\t\t\t    // wait_return\n\t\t\t    smsg_attr(HL_ATTR(HLF_R),\n\t\t\t\t_(\"replace with %s (y/n/a/q/l/^E/^Y)?\"), sub);\n\t\t\t    msg_no_more = FALSE;\n\t\t\t    msg_scroll = i;\n\t\t\t    showruler(TRUE);\n\t\t\t    windgoto(msg_row, msg_col);\n\t\t\t    RedrawingDisabled = temp;\n\n#ifdef USE_ON_FLY_SCROLL\n\t\t\t    dont_scroll = FALSE; // allow scrolling here\n#endif\n\t\t\t    ++no_mapping;\t// don't map this key\n\t\t\t    ++allow_keys;\t// allow special keys\n\t\t\t    typed = plain_vgetc();\n\t\t\t    --allow_keys;\n\t\t\t    --no_mapping;\n\n\t\t\t    // clear the question\n\t\t\t    msg_didout = FALSE;\t// don't scroll up\n\t\t\t    msg_col = 0;\n\t\t\t    gotocmdline(TRUE);\n\t\t\t    p_lz = save_p_lz;\n\n\t\t\t    // restore the line\n\t\t\t    if (orig_line != NULL)\n\t\t\t\tml_replace(lnum, orig_line, FALSE);\n\t\t\t}\n\n\t\t\tneed_wait_return = FALSE; // no hit-return prompt\n\t\t\tif (typed == 'q' || typed == ESC || typed == Ctrl_C\n#ifdef UNIX\n\t\t\t\t|| typed == intr_char\n#endif\n\t\t\t\t)\n\t\t\t{\n\t\t\t    got_quit = TRUE;\n\t\t\t    break;\n\t\t\t}\n\t\t\tif (typed == 'n')\n\t\t\t    break;\n\t\t\tif (typed == 'y')\n\t\t\t    break;\n\t\t\tif (typed == 'l')\n\t\t\t{\n\t\t\t    // last: replace and then stop\n\t\t\t    subflags.do_all = FALSE;\n\t\t\t    line2 = lnum;\n\t\t\t    break;\n\t\t\t}\n\t\t\tif (typed == 'a')\n\t\t\t{\n\t\t\t    subflags.do_ask = FALSE;\n\t\t\t    break;\n\t\t\t}\n\t\t\tif (typed == Ctrl_E)\n\t\t\t    scrollup_clamp();\n\t\t\telse if (typed == Ctrl_Y)\n\t\t\t    scrolldown_clamp();\n\t\t    }\n\t\t    State = save_State;\n\t\t    setmouse();\n\t\t    if (vim_strchr(p_cpo, CPO_UNDO) != NULL)\n\t\t\t--no_u_sync;\n\n\t\t    if (typed == 'n')\n\t\t    {\n\t\t\t// For a multi-line match, put matchcol at the NUL at\n\t\t\t// the end of the line and set nmatch to one, so that\n\t\t\t// we continue looking for a match on the next line.\n\t\t\t// Avoids that \":%s/\\nB\\@=//gc\" and \":%s/\\n/,\\r/gc\"\n\t\t\t// get stuck when pressing 'n'.\n\t\t\tif (nmatch > 1)\n\t\t\t{\n\t\t\t    matchcol = (colnr_T)STRLEN(sub_firstline);\n\t\t\t    skip_match = TRUE;\n\t\t\t}\n\t\t\tgoto skip;\n\t\t    }\n\t\t    if (got_quit)\n\t\t\tgoto skip;\n\t\t}\n\n\t\t// Move the cursor to the start of the match, so that we can\n\t\t// use \"\\=col(\".\").\n\t\tcurwin->w_cursor.col = regmatch.startpos[0].col;\n\n\t\t/*\n\t\t * 3. substitute the string.\n\t\t */\n#ifdef FEAT_EVAL\n\t\tsave_ma = curbuf->b_p_ma;\n\t\tif (subflags.do_count)\n\t\t{\n\t\t    // prevent accidentally changing the buffer by a function\n\t\t    curbuf->b_p_ma = FALSE;\n\t\t    sandbox++;\n\t\t}\n\t\t// Save flags for recursion.  They can change for e.g.\n\t\t// :s/^/\\=execute(\"s#^##gn\")\n\t\tsubflags_save = subflags;\n#endif\n\t\t// get length of substitution part\n\t\tsublen = vim_regsub_multi(&regmatch,\n\t\t\t\t    sub_firstlnum - regmatch.startpos[0].lnum,\n\t\t\t       sub, sub_firstline, FALSE, magic_isset(), TRUE);\n#ifdef FEAT_EVAL\n\t\t// If getting the substitute string caused an error, don't do\n\t\t// the replacement.\n\t\t// Don't keep flags set by a recursive call.\n\t\tsubflags = subflags_save;\n\t\tif (aborting() || subflags.do_count)\n\t\t{\n\t\t    curbuf->b_p_ma = save_ma;\n\t\t    if (sandbox > 0)\n\t\t\tsandbox--;\n\t\t    goto skip;\n\t\t}\n#endif\n\n\t\t// When the match included the \"$\" of the last line it may\n\t\t// go beyond the last line of the buffer.\n\t\tif (nmatch > curbuf->b_ml.ml_line_count - sub_firstlnum + 1)\n\t\t{\n\t\t    nmatch = curbuf->b_ml.ml_line_count - sub_firstlnum + 1;\n\t\t    skip_match = TRUE;\n\t\t}\n\n\t\t// Need room for:\n\t\t// - result so far in new_start (not for first sub in line)\n\t\t// - original text up to match\n\t\t// - length of substituted part\n\t\t// - original text after match\n\t\t// Adjust text properties here, since we have all information\n\t\t// needed.\n\t\tif (nmatch == 1)\n\t\t{\n\t\t    p1 = sub_firstline;\n#ifdef FEAT_PROP_POPUP\n\t\t    if (curbuf->b_has_textprop)\n\t\t    {\n\t\t\tint bytes_added = sublen - 1 - (regmatch.endpos[0].col\n\t\t\t\t\t\t   - regmatch.startpos[0].col);\n\n\t\t\t// When text properties are changed, need to save for\n\t\t\t// undo first, unless done already.\n\t\t\tif (adjust_prop_columns(lnum,\n\t\t\t\t\ttotal_added + regmatch.startpos[0].col,\n\t\t\t\t\t\t       bytes_added, apc_flags))\n\t\t\t    apc_flags &= ~APC_SAVE_FOR_UNDO;\n\t\t\t// Offset for column byte number of the text property\n\t\t\t// in the resulting buffer afterwards.\n\t\t\ttotal_added += bytes_added;\n\t\t    }\n#endif\n\t\t}\n\t\telse\n\t\t{\n\t\t    p1 = ml_get(sub_firstlnum + nmatch - 1);\n\t\t    nmatch_tl += nmatch - 1;\n\t\t}\n\t\tcopy_len = regmatch.startpos[0].col - copycol;\n\t\tneeded_len = copy_len + ((unsigned)STRLEN(p1)\n\t\t\t\t       - regmatch.endpos[0].col) + sublen + 1;\n\t\tif (new_start == NULL)\n\t\t{\n\t\t    /*\n\t\t     * Get some space for a temporary buffer to do the\n\t\t     * substitution into (and some extra space to avoid\n\t\t     * too many calls to alloc()/free()).\n\t\t     */\n\t\t    new_start_len = needed_len + 50;\n\t\t    if ((new_start = alloc(new_start_len)) == NULL)\n\t\t\tgoto outofmem;\n\t\t    *new_start = NUL;\n\t\t    new_end = new_start;\n\t\t}\n\t\telse\n\t\t{\n\t\t    /*\n\t\t     * Check if the temporary buffer is long enough to do the\n\t\t     * substitution into.  If not, make it larger (with a bit\n\t\t     * extra to avoid too many calls to alloc()/free()).\n\t\t     */\n\t\t    len = (unsigned)STRLEN(new_start);\n\t\t    needed_len += len;\n\t\t    if (needed_len > (int)new_start_len)\n\t\t    {\n\t\t\tnew_start_len = needed_len + 50;\n\t\t\tif ((p1 = alloc(new_start_len)) == NULL)\n\t\t\t{\n\t\t\t    vim_free(new_start);\n\t\t\t    goto outofmem;\n\t\t\t}\n\t\t\tmch_memmove(p1, new_start, (size_t)(len + 1));\n\t\t\tvim_free(new_start);\n\t\t\tnew_start = p1;\n\t\t    }\n\t\t    new_end = new_start + len;\n\t\t}\n\n\t\t/*\n\t\t * copy the text up to the part that matched\n\t\t */\n\t\tmch_memmove(new_end, sub_firstline + copycol, (size_t)copy_len);\n\t\tnew_end += copy_len;\n\n\t\t(void)vim_regsub_multi(&regmatch,\n\t\t\t\t    sub_firstlnum - regmatch.startpos[0].lnum,\n\t\t\t\t      sub, new_end, TRUE, magic_isset(), TRUE);\n\t\tsub_nsubs++;\n\t\tdid_sub = TRUE;\n\n\t\t// Move the cursor to the start of the line, to avoid that it\n\t\t// is beyond the end of the line after the substitution.\n\t\tcurwin->w_cursor.col = 0;\n\n\t\t// For a multi-line match, make a copy of the last matched\n\t\t// line and continue in that one.\n\t\tif (nmatch > 1)\n\t\t{\n\t\t    sub_firstlnum += nmatch - 1;\n\t\t    vim_free(sub_firstline);\n\t\t    sub_firstline = vim_strsave(ml_get(sub_firstlnum));\n\t\t    // When going beyond the last line, stop substituting.\n\t\t    if (sub_firstlnum <= line2)\n\t\t\tdo_again = TRUE;\n\t\t    else\n\t\t\tsubflags.do_all = FALSE;\n\t\t}\n\n\t\t// Remember next character to be copied.\n\t\tcopycol = regmatch.endpos[0].col;\n\n\t\tif (skip_match)\n\t\t{\n\t\t    // Already hit end of the buffer, sub_firstlnum is one\n\t\t    // less than what it ought to be.\n\t\t    vim_free(sub_firstline);\n\t\t    sub_firstline = vim_strsave((char_u *)\"\");\n\t\t    copycol = 0;\n\t\t}\n\n\t\t/*\n\t\t * Now the trick is to replace CTRL-M chars with a real line\n\t\t * break.  This would make it impossible to insert a CTRL-M in\n\t\t * the text.  The line break can be avoided by preceding the\n\t\t * CTRL-M with a backslash.  To be able to insert a backslash,\n\t\t * they must be doubled in the string and are halved here.\n\t\t * That is Vi compatible.\n\t\t */\n\t\tfor (p1 = new_end; *p1; ++p1)\n\t\t{\n\t\t    if (p1[0] == '\\\\' && p1[1] != NUL)  // remove backslash\n\t\t    {\n\t\t\tSTRMOVE(p1, p1 + 1);\n#ifdef FEAT_PROP_POPUP\n\t\t\tif (curbuf->b_has_textprop)\n\t\t\t{\n\t\t\t    // When text properties are changed, need to save\n\t\t\t    // for undo first, unless done already.\n\t\t\t    if (adjust_prop_columns(lnum,\n\t\t\t\t\t(colnr_T)(p1 - new_start), -1,\n\t\t\t\t\tapc_flags))\n\t\t\t\tapc_flags &= ~APC_SAVE_FOR_UNDO;\n\t\t\t}\n#endif\n\t\t    }\n\t\t    else if (*p1 == CAR)\n\t\t    {\n\t\t\tif (u_inssub(lnum) == OK)   // prepare for undo\n\t\t\t{\n\t\t\t    colnr_T\tplen = (colnr_T)(p1 - new_start + 1);\n\n\t\t\t    *p1 = NUL;\t\t    // truncate up to the CR\n\t\t\t    ml_append(lnum - 1, new_start, plen, FALSE);\n\t\t\t    mark_adjust(lnum + 1, (linenr_T)MAXLNUM, 1L, 0L);\n\t\t\t    if (subflags.do_ask)\n\t\t\t\tappended_lines(lnum - 1, 1L);\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tif (first_line == 0)\n\t\t\t\t    first_line = lnum;\n\t\t\t\tlast_line = lnum + 1;\n\t\t\t    }\n#ifdef FEAT_PROP_POPUP\n\t\t\t    adjust_props_for_split(lnum + 1, lnum, plen, 1);\n#endif\n\t\t\t    // all line numbers increase\n\t\t\t    ++sub_firstlnum;\n\t\t\t    ++lnum;\n\t\t\t    ++line2;\n\t\t\t    // move the cursor to the new line, like Vi\n\t\t\t    ++curwin->w_cursor.lnum;\n\t\t\t    // copy the rest\n\t\t\t    STRMOVE(new_start, p1 + 1);\n\t\t\t    p1 = new_start - 1;\n\t\t\t}\n\t\t    }\n\t\t    else if (has_mbyte)\n\t\t\tp1 += (*mb_ptr2len)(p1) - 1;\n\t\t}\n\n\t\t/*\n\t\t * 4. If do_all is set, find next match.\n\t\t * Prevent endless loop with patterns that match empty\n\t\t * strings, e.g. :s/$/pat/g or :s/[a-z]* /(&)/g.\n\t\t * But \":s/\\n/#/\" is OK.\n\t\t */\nskip:\n\t\t// We already know that we did the last subst when we are at\n\t\t// the end of the line, except that a pattern like\n\t\t// \"bar\\|\\nfoo\" may match at the NUL.  \"lnum\" can be below\n\t\t// \"line2\" when there is a \\zs in the pattern after a line\n\t\t// break.\n\t\tlastone = (skip_match\n\t\t\t|| got_int\n\t\t\t|| got_quit\n\t\t\t|| lnum > line2\n\t\t\t|| !(subflags.do_all || do_again)\n\t\t\t|| (sub_firstline[matchcol] == NUL && nmatch <= 1\n\t\t\t\t\t && !re_multiline(regmatch.regprog)));\n\t\tnmatch = -1;\n\n\t\t/*\n\t\t * Replace the line in the buffer when needed.  This is\n\t\t * skipped when there are more matches.\n\t\t * The check for nmatch_tl is needed for when multi-line\n\t\t * matching must replace the lines before trying to do another\n\t\t * match, otherwise \"\\@<=\" won't work.\n\t\t * When the match starts below where we start searching also\n\t\t * need to replace the line first (using \\zs after \\n).\n\t\t */\n\t\tif (lastone\n\t\t\t|| nmatch_tl > 0\n\t\t\t|| (nmatch = vim_regexec_multi(&regmatch, curwin,\n\t\t\t\t\t\t\tcurbuf, sub_firstlnum,\n\t\t\t\t\t\t    matchcol, NULL, NULL)) == 0\n\t\t\t|| regmatch.startpos[0].lnum > 0)\n\t\t{\n\t\t    if (new_start != NULL)\n\t\t    {\n\t\t\t/*\n\t\t\t * Copy the rest of the line, that didn't match.\n\t\t\t * \"matchcol\" has to be adjusted, we use the end of\n\t\t\t * the line as reference, because the substitute may\n\t\t\t * have changed the number of characters.  Same for\n\t\t\t * \"prev_matchcol\".\n\t\t\t */\n\t\t\tSTRCAT(new_start, sub_firstline + copycol);\n\t\t\tmatchcol = (colnr_T)STRLEN(sub_firstline) - matchcol;\n\t\t\tprev_matchcol = (colnr_T)STRLEN(sub_firstline)\n\t\t\t\t\t\t\t      - prev_matchcol;\n\n\t\t\tif (u_savesub(lnum) != OK)\n\t\t\t    break;\n\t\t\tml_replace(lnum, new_start, TRUE);\n\n\t\t\tif (nmatch_tl > 0)\n\t\t\t{\n\t\t\t    /*\n\t\t\t     * Matched lines have now been substituted and are\n\t\t\t     * useless, delete them.  The part after the match\n\t\t\t     * has been appended to new_start, we don't need\n\t\t\t     * it in the buffer.\n\t\t\t     */\n\t\t\t    ++lnum;\n\t\t\t    if (u_savedel(lnum, nmatch_tl) != OK)\n\t\t\t\tbreak;\n\t\t\t    for (i = 0; i < nmatch_tl; ++i)\n\t\t\t\tml_delete(lnum);\n\t\t\t    mark_adjust(lnum, lnum + nmatch_tl - 1,\n\t\t\t\t\t\t   (long)MAXLNUM, -nmatch_tl);\n\t\t\t    if (subflags.do_ask)\n\t\t\t\tdeleted_lines(lnum, nmatch_tl);\n\t\t\t    --lnum;\n\t\t\t    line2 -= nmatch_tl; // nr of lines decreases\n\t\t\t    nmatch_tl = 0;\n\t\t\t}\n\n\t\t\t// When asking, undo is saved each time, must also set\n\t\t\t// changed flag each time.\n\t\t\tif (subflags.do_ask)\n\t\t\t    changed_bytes(lnum, 0);\n\t\t\telse\n\t\t\t{\n\t\t\t    if (first_line == 0)\n\t\t\t\tfirst_line = lnum;\n\t\t\t    last_line = lnum + 1;\n\t\t\t}\n\n\t\t\tsub_firstlnum = lnum;\n\t\t\tvim_free(sub_firstline);    // free the temp buffer\n\t\t\tsub_firstline = new_start;\n\t\t\tnew_start = NULL;\n\t\t\tmatchcol = (colnr_T)STRLEN(sub_firstline) - matchcol;\n\t\t\tprev_matchcol = (colnr_T)STRLEN(sub_firstline)\n\t\t\t\t\t\t\t      - prev_matchcol;\n\t\t\tcopycol = 0;\n\t\t    }\n\t\t    if (nmatch == -1 && !lastone)\n\t\t\tnmatch = vim_regexec_multi(&regmatch, curwin, curbuf,\n\t\t\t\t\t  sub_firstlnum, matchcol, NULL, NULL);\n\n\t\t    /*\n\t\t     * 5. break if there isn't another match in this line\n\t\t     */\n\t\t    if (nmatch <= 0)\n\t\t    {\n\t\t\t// If the match found didn't start where we were\n\t\t\t// searching, do the next search in the line where we\n\t\t\t// found the match.\n\t\t\tif (nmatch == -1)\n\t\t\t    lnum -= regmatch.startpos[0].lnum;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\n\t\tline_breakcheck();\n\t    }\n\n\t    if (did_sub)\n\t\t++sub_nlines;\n\t    vim_free(new_start);\t// for when substitute was cancelled\n\t    VIM_CLEAR(sub_firstline);\t// free the copy of the original line\n\t}\n\n\tline_breakcheck();\n    }\n\n    if (first_line != 0)\n    {\n\t// Need to subtract the number of added lines from \"last_line\" to get\n\t// the line number before the change (same as adding the number of\n\t// deleted lines).\n\ti = curbuf->b_ml.ml_line_count - old_line_count;\n\tchanged_lines(first_line, 0, last_line - i, i);\n    }\n\noutofmem:\n    vim_free(sub_firstline); // may have to free allocated copy of the line\n\n    // \":s/pat//n\" doesn't move the cursor\n    if (subflags.do_count)\n\tcurwin->w_cursor = old_cursor;\n\n    if (sub_nsubs > start_nsubs)\n    {\n\tif ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n\t{\n\t    // Set the '[ and '] marks.\n\t    curbuf->b_op_start.lnum = eap->line1;\n\t    curbuf->b_op_end.lnum = line2;\n\t    curbuf->b_op_start.col = curbuf->b_op_end.col = 0;\n\t}\n\n\tif (!global_busy)\n\t{\n\t    // when interactive leave cursor on the match\n\t    if (!subflags.do_ask)\n\t    {\n\t\tif (endcolumn)\n\t\t    coladvance((colnr_T)MAXCOL);\n\t\telse\n\t\t    beginline(BL_WHITE | BL_FIX);\n\t    }\n\t    if (!do_sub_msg(subflags.do_count) && subflags.do_ask)\n\t\tmsg(\"\");\n\t}\n\telse\n\t    global_need_beginline = TRUE;\n\tif (subflags.do_print)\n\t    print_line(curwin->w_cursor.lnum,\n\t\t\t\t\t subflags.do_number, subflags.do_list);\n    }\n    else if (!global_busy)\n    {\n\tif (got_int)\t\t// interrupted\n\t    emsg(_(e_interrupted));\n\telse if (got_match)\t// did find something but nothing substituted\n\t    msg(\"\");\n\telse if (subflags.do_error)\t// nothing found\n\t    semsg(_(e_pattern_not_found_str), get_search_pat());\n    }\n\n#ifdef FEAT_FOLDING\n    if (subflags.do_ask && hasAnyFolding(curwin))\n\t// Cursor position may require updating\n\tchanged_window_setting();\n#endif\n\n    vim_regfree(regmatch.regprog);\n    vim_free(sub_copy);\n\n    // Restore the flag values, they can be used for \":&&\".\n    subflags.do_all = save_do_all;\n    subflags.do_ask = save_do_ask;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 352,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int selinux_ptrace_traceme(struct task_struct *parent)\n{\n\treturn avc_has_perm(&selinux_state,\n\t\t\t    task_sid_obj(parent), task_sid_obj(current),\n\t\t\t    SECCLASS_PROCESS, PROCESS__PTRACE, NULL);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 380,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "regmatch(\n    char_u\t*scan,\t\t    // Current node.\n    proftime_T\t*tm UNUSED,\t    // timeout limit or NULL\n    int\t\t*timed_out UNUSED)  // flag set on timeout or NULL\n{\n  char_u\t*next;\t\t// Next node.\n  int\t\top;\n  int\t\tc;\n  regitem_T\t*rp;\n  int\t\tno;\n  int\t\tstatus;\t\t// one of the RA_ values:\n#ifdef FEAT_RELTIME\n  int\t\ttm_count = 0;\n#endif\n\n  // Make \"regstack\" and \"backpos\" empty.  They are allocated and freed in\n  // bt_regexec_both() to reduce malloc()/free() calls.\n  regstack.ga_len = 0;\n  backpos.ga_len = 0;\n\n  // Repeat until \"regstack\" is empty.\n  for (;;)\n  {\n    // Some patterns may take a long time to match, e.g., \"\\([a-z]\\+\\)\\+Q\".\n    // Allow interrupting them with CTRL-C.\n    fast_breakcheck();\n\n#ifdef DEBUG\n    if (scan != NULL && regnarrate)\n    {\n\tmch_errmsg((char *)regprop(scan));\n\tmch_errmsg(\"(\\n\");\n    }\n#endif\n\n    // Repeat for items that can be matched sequentially, without using the\n    // regstack.\n    for (;;)\n    {\n\tif (got_int || scan == NULL)\n\t{\n\t    status = RA_FAIL;\n\t    break;\n\t}\n#ifdef FEAT_RELTIME\n\t// Check for timeout once in a 100 times to avoid overhead.\n\tif (tm != NULL && ++tm_count == 100)\n\t{\n\t    tm_count = 0;\n\t    if (profile_passed_limit(tm))\n\t    {\n\t\tif (timed_out != NULL)\n\t\t    *timed_out = TRUE;\n\t\tstatus = RA_FAIL;\n\t\tbreak;\n\t    }\n\t}\n#endif\n\tstatus = RA_CONT;\n\n#ifdef DEBUG\n\tif (regnarrate)\n\t{\n\t    mch_errmsg((char *)regprop(scan));\n\t    mch_errmsg(\"...\\n\");\n# ifdef FEAT_SYN_HL\n\t    if (re_extmatch_in != NULL)\n\t    {\n\t\tint i;\n\n\t\tmch_errmsg(_(\"External submatches:\\n\"));\n\t\tfor (i = 0; i < NSUBEXP; i++)\n\t\t{\n\t\t    mch_errmsg(\"    \\\"\");\n\t\t    if (re_extmatch_in->matches[i] != NULL)\n\t\t\tmch_errmsg((char *)re_extmatch_in->matches[i]);\n\t\t    mch_errmsg(\"\\\"\\n\");\n\t\t}\n\t    }\n# endif\n\t}\n#endif\n\tnext = regnext(scan);\n\n\top = OP(scan);\n\t// Check for character class with NL added.\n\tif (!rex.reg_line_lbr && WITH_NL(op) && REG_MULTI\n\t\t\t     && *rex.input == NUL && rex.lnum <= rex.reg_maxline)\n\t{\n\t    reg_nextline();\n\t}\n\telse if (rex.reg_line_lbr && WITH_NL(op) && *rex.input == '\\n')\n\t{\n\t    ADVANCE_REGINPUT();\n\t}\n\telse\n\t{\n\t  if (WITH_NL(op))\n\t      op -= ADD_NL;\n\t  if (has_mbyte)\n\t      c = (*mb_ptr2char)(rex.input);\n\t  else\n\t      c = *rex.input;\n\t  switch (op)\n\t  {\n\t  case BOL:\n\t    if (rex.input != rex.line)\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case EOL:\n\t    if (c != NUL)\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case RE_BOF:\n\t    // We're not at the beginning of the file when below the first\n\t    // line where we started, not at the start of the line or we\n\t    // didn't start at the first line of the buffer.\n\t    if (rex.lnum != 0 || rex.input != rex.line\n\t\t\t\t       || (REG_MULTI && rex.reg_firstlnum > 1))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case RE_EOF:\n\t    if (rex.lnum != rex.reg_maxline || c != NUL)\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case CURSOR:\n\t    // Check if the buffer is in a window and compare the\n\t    // rex.reg_win->w_cursor position to the match position.\n\t    if (rex.reg_win == NULL\n\t\t    || (rex.lnum + rex.reg_firstlnum\n\t\t\t\t\t\t != rex.reg_win->w_cursor.lnum)\n\t\t    || ((colnr_T)(rex.input - rex.line)\n\t\t\t\t\t\t != rex.reg_win->w_cursor.col))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case RE_MARK:\n\t    // Compare the mark position to the match position.\n\t    {\n\t\tint\tmark = OPERAND(scan)[0];\n\t\tint\tcmp = OPERAND(scan)[1];\n\t\tpos_T\t*pos;\n\t\tsize_t\tcol = REG_MULTI ? rex.input - rex.line : 0;\n\n\t\tpos = getmark_buf(rex.reg_buf, mark, FALSE);\n\n\t\t// Line may have been freed, get it again.\n\t\tif (REG_MULTI)\n\t\t{\n\t\t    rex.line = reg_getline(rex.lnum);\n\t\t    rex.input = rex.line + col;\n\t\t}\n\n\t\tif (pos == NULL\t\t     // mark doesn't exist\n\t\t\t|| pos->lnum <= 0)   // mark isn't set in reg_buf\n\t\t{\n\t\t    status = RA_NOMATCH;\n\t\t}\n\t\telse\n\t\t{\n\t\t    colnr_T pos_col = pos->lnum == rex.lnum + rex.reg_firstlnum\n\t\t\t\t\t\t\t  && pos->col == MAXCOL\n\t\t\t\t      ? (colnr_T)STRLEN(reg_getline(\n\t\t\t\t\t\tpos->lnum - rex.reg_firstlnum))\n\t\t\t\t      : pos->col;\n\n\t\t    if ((pos->lnum == rex.lnum + rex.reg_firstlnum\n\t\t\t\t? (pos_col == (colnr_T)(rex.input - rex.line)\n\t\t\t\t    ? (cmp == '<' || cmp == '>')\n\t\t\t\t    : (pos_col < (colnr_T)(rex.input - rex.line)\n\t\t\t\t\t? cmp != '>'\n\t\t\t\t\t: cmp != '<'))\n\t\t\t\t: (pos->lnum < rex.lnum + rex.reg_firstlnum\n\t\t\t\t    ? cmp != '>'\n\t\t\t\t    : cmp != '<')))\n\t\t    status = RA_NOMATCH;\n\t\t}\n\t    }\n\t    break;\n\n\t  case RE_VISUAL:\n\t    if (!reg_match_visual())\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case RE_LNUM:\n\t    if (!REG_MULTI || !re_num_cmp((long_u)(rex.lnum + rex.reg_firstlnum),\n\t\t\t\t\t\t\t\t\tscan))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case RE_COL:\n\t    if (!re_num_cmp((long_u)(rex.input - rex.line) + 1, scan))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case RE_VCOL:\n\t    if (!re_num_cmp((long_u)win_linetabsize(\n\t\t\t    rex.reg_win == NULL ? curwin : rex.reg_win,\n\t\t\t    rex.line, (colnr_T)(rex.input - rex.line)) + 1, scan))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case BOW:\t// \\<word; rex.input points to w\n\t    if (c == NUL)\t// Can't match at end of line\n\t\tstatus = RA_NOMATCH;\n\t    else if (has_mbyte)\n\t    {\n\t\tint this_class;\n\n\t\t// Get class of current and previous char (if it exists).\n\t\tthis_class = mb_get_class_buf(rex.input, rex.reg_buf);\n\t\tif (this_class <= 1)\n\t\t    status = RA_NOMATCH;  // not on a word at all\n\t\telse if (reg_prev_class() == this_class)\n\t\t    status = RA_NOMATCH;  // previous char is in same word\n\t    }\n\t    else\n\t    {\n\t\tif (!vim_iswordc_buf(c, rex.reg_buf) || (rex.input > rex.line\n\t\t\t\t&& vim_iswordc_buf(rex.input[-1], rex.reg_buf)))\n\t\t    status = RA_NOMATCH;\n\t    }\n\t    break;\n\n\t  case EOW:\t// word\\>; rex.input points after d\n\t    if (rex.input == rex.line)    // Can't match at start of line\n\t\tstatus = RA_NOMATCH;\n\t    else if (has_mbyte)\n\t    {\n\t\tint this_class, prev_class;\n\n\t\t// Get class of current and previous char (if it exists).\n\t\tthis_class = mb_get_class_buf(rex.input, rex.reg_buf);\n\t\tprev_class = reg_prev_class();\n\t\tif (this_class == prev_class\n\t\t\t|| prev_class == 0 || prev_class == 1)\n\t\t    status = RA_NOMATCH;\n\t    }\n\t    else\n\t    {\n\t\tif (!vim_iswordc_buf(rex.input[-1], rex.reg_buf)\n\t\t\t|| (rex.input[0] != NUL\n\t\t\t\t\t   && vim_iswordc_buf(c, rex.reg_buf)))\n\t\t    status = RA_NOMATCH;\n\t    }\n\t    break; // Matched with EOW\n\n\t  case ANY:\n\t    // ANY does not match new lines.\n\t    if (c == NUL)\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case IDENT:\n\t    if (!vim_isIDc(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case SIDENT:\n\t    if (VIM_ISDIGIT(*rex.input) || !vim_isIDc(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case KWORD:\n\t    if (!vim_iswordp_buf(rex.input, rex.reg_buf))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case SKWORD:\n\t    if (VIM_ISDIGIT(*rex.input)\n\t\t\t\t    || !vim_iswordp_buf(rex.input, rex.reg_buf))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case FNAME:\n\t    if (!vim_isfilec(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case SFNAME:\n\t    if (VIM_ISDIGIT(*rex.input) || !vim_isfilec(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case PRINT:\n\t    if (!vim_isprintc(PTR2CHAR(rex.input)))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case SPRINT:\n\t    if (VIM_ISDIGIT(*rex.input) || !vim_isprintc(PTR2CHAR(rex.input)))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case WHITE:\n\t    if (!VIM_ISWHITE(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NWHITE:\n\t    if (c == NUL || VIM_ISWHITE(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case DIGIT:\n\t    if (!ri_digit(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NDIGIT:\n\t    if (c == NUL || ri_digit(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case HEX:\n\t    if (!ri_hex(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NHEX:\n\t    if (c == NUL || ri_hex(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case OCTAL:\n\t    if (!ri_octal(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NOCTAL:\n\t    if (c == NUL || ri_octal(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case WORD:\n\t    if (!ri_word(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NWORD:\n\t    if (c == NUL || ri_word(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case HEAD:\n\t    if (!ri_head(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NHEAD:\n\t    if (c == NUL || ri_head(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case ALPHA:\n\t    if (!ri_alpha(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NALPHA:\n\t    if (c == NUL || ri_alpha(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case LOWER:\n\t    if (!ri_lower(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NLOWER:\n\t    if (c == NUL || ri_lower(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case UPPER:\n\t    if (!ri_upper(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NUPPER:\n\t    if (c == NUL || ri_upper(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case EXACTLY:\n\t    {\n\t\tint\tlen;\n\t\tchar_u\t*opnd;\n\n\t\topnd = OPERAND(scan);\n\t\t// Inline the first byte, for speed.\n\t\tif (*opnd != *rex.input\n\t\t\t&& (!rex.reg_ic\n\t\t\t    || (!enc_utf8\n\t\t\t      && MB_TOLOWER(*opnd) != MB_TOLOWER(*rex.input))))\n\t\t    status = RA_NOMATCH;\n\t\telse if (*opnd == NUL)\n\t\t{\n\t\t    // match empty string always works; happens when \"~\" is\n\t\t    // empty.\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (opnd[1] == NUL && !(enc_utf8 && rex.reg_ic))\n\t\t    {\n\t\t\tlen = 1;\t// matched a single byte above\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// Need to match first byte again for multi-byte.\n\t\t\tlen = (int)STRLEN(opnd);\n\t\t\tif (cstrncmp(opnd, rex.input, &len) != 0)\n\t\t\t    status = RA_NOMATCH;\n\t\t    }\n\t\t    // Check for following composing character, unless %C\n\t\t    // follows (skips over all composing chars).\n\t\t    if (status != RA_NOMATCH\n\t\t\t    && enc_utf8\n\t\t\t    && UTF_COMPOSINGLIKE(rex.input, rex.input + len)\n\t\t\t    && !rex.reg_icombine\n\t\t\t    && OP(next) != RE_COMPOSING)\n\t\t    {\n\t\t\t// raaron: This code makes a composing character get\n\t\t\t// ignored, which is the correct behavior (sometimes)\n\t\t\t// for voweled Hebrew texts.\n\t\t\tstatus = RA_NOMATCH;\n\t\t    }\n\t\t    if (status != RA_NOMATCH)\n\t\t\trex.input += len;\n\t\t}\n\t    }\n\t    break;\n\n\t  case ANYOF:\n\t  case ANYBUT:\n\t    if (c == NUL)\n\t\tstatus = RA_NOMATCH;\n\t    else if ((cstrchr(OPERAND(scan), c) == NULL) == (op == ANYOF))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case MULTIBYTECODE:\n\t    if (has_mbyte)\n\t    {\n\t\tint\ti, len;\n\t\tchar_u\t*opnd;\n\t\tint\topndc = 0, inpc;\n\n\t\topnd = OPERAND(scan);\n\t\t// Safety check (just in case 'encoding' was changed since\n\t\t// compiling the program).\n\t\tif ((len = (*mb_ptr2len)(opnd)) < 2)\n\t\t{\n\t\t    status = RA_NOMATCH;\n\t\t    break;\n\t\t}\n\t\tif (enc_utf8)\n\t\t    opndc = utf_ptr2char(opnd);\n\t\tif (enc_utf8 && utf_iscomposing(opndc))\n\t\t{\n\t\t    // When only a composing char is given match at any\n\t\t    // position where that composing char appears.\n\t\t    status = RA_NOMATCH;\n\t\t    for (i = 0; rex.input[i] != NUL;\n\t\t\t\t\t\ti += utf_ptr2len(rex.input + i))\n\t\t    {\n\t\t\tinpc = utf_ptr2char(rex.input + i);\n\t\t\tif (!utf_iscomposing(inpc))\n\t\t\t{\n\t\t\t    if (i > 0)\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (opndc == inpc)\n\t\t\t{\n\t\t\t    // Include all following composing chars.\n\t\t\t    len = i + utfc_ptr2len(rex.input + i);\n\t\t\t    status = RA_MATCH;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse\n\t\t    for (i = 0; i < len; ++i)\n\t\t\tif (opnd[i] != rex.input[i])\n\t\t\t{\n\t\t\t    status = RA_NOMATCH;\n\t\t\t    break;\n\t\t\t}\n\t\trex.input += len;\n\t    }\n\t    else\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case RE_COMPOSING:\n\t    if (enc_utf8)\n\t    {\n\t\t// Skip composing characters.\n\t\twhile (utf_iscomposing(utf_ptr2char(rex.input)))\n\t\t    MB_CPTR_ADV(rex.input);\n\t    }\n\t    break;\n\n\t  case NOTHING:\n\t    break;\n\n\t  case BACK:\n\t    {\n\t\tint\t\ti;\n\t\tbackpos_T\t*bp;\n\n\t\t// When we run into BACK we need to check if we don't keep\n\t\t// looping without matching any input.  The second and later\n\t\t// times a BACK is encountered it fails if the input is still\n\t\t// at the same position as the previous time.\n\t\t// The positions are stored in \"backpos\" and found by the\n\t\t// current value of \"scan\", the position in the RE program.\n\t\tbp = (backpos_T *)backpos.ga_data;\n\t\tfor (i = 0; i < backpos.ga_len; ++i)\n\t\t    if (bp[i].bp_scan == scan)\n\t\t\tbreak;\n\t\tif (i == backpos.ga_len)\n\t\t{\n\t\t    // First time at this BACK, make room to store the pos.\n\t\t    if (ga_grow(&backpos, 1) == FAIL)\n\t\t\tstatus = RA_FAIL;\n\t\t    else\n\t\t    {\n\t\t\t// get \"ga_data\" again, it may have changed\n\t\t\tbp = (backpos_T *)backpos.ga_data;\n\t\t\tbp[i].bp_scan = scan;\n\t\t\t++backpos.ga_len;\n\t\t    }\n\t\t}\n\t\telse if (reg_save_equal(&bp[i].bp_pos))\n\t\t    // Still at same position as last time, fail.\n\t\t    status = RA_NOMATCH;\n\n\t\tif (status != RA_FAIL && status != RA_NOMATCH)\n\t\t    reg_save(&bp[i].bp_pos, &backpos);\n\t    }\n\t    break;\n\n\t  case MOPEN + 0:   // Match start: \\zs\n\t  case MOPEN + 1:   // \\(\n\t  case MOPEN + 2:\n\t  case MOPEN + 3:\n\t  case MOPEN + 4:\n\t  case MOPEN + 5:\n\t  case MOPEN + 6:\n\t  case MOPEN + 7:\n\t  case MOPEN + 8:\n\t  case MOPEN + 9:\n\t    {\n\t\tno = op - MOPEN;\n\t\tcleanup_subexpr();\n\t\trp = regstack_push(RS_MOPEN, scan);\n\t\tif (rp == NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    rp->rs_no = no;\n\t\t    save_se(&rp->rs_un.sesave, &rex.reg_startpos[no],\n\t\t\t\t\t\t\t  &rex.reg_startp[no]);\n\t\t    // We simply continue and handle the result when done.\n\t\t}\n\t    }\n\t    break;\n\n\t  case NOPEN:\t    // \\%(\n\t  case NCLOSE:\t    // \\) after \\%(\n\t\tif (regstack_push(RS_NOPEN, scan) == NULL)\n\t\t    status = RA_FAIL;\n\t\t// We simply continue and handle the result when done.\n\t\tbreak;\n\n#ifdef FEAT_SYN_HL\n\t  case ZOPEN + 1:\n\t  case ZOPEN + 2:\n\t  case ZOPEN + 3:\n\t  case ZOPEN + 4:\n\t  case ZOPEN + 5:\n\t  case ZOPEN + 6:\n\t  case ZOPEN + 7:\n\t  case ZOPEN + 8:\n\t  case ZOPEN + 9:\n\t    {\n\t\tno = op - ZOPEN;\n\t\tcleanup_zsubexpr();\n\t\trp = regstack_push(RS_ZOPEN, scan);\n\t\tif (rp == NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    rp->rs_no = no;\n\t\t    save_se(&rp->rs_un.sesave, &reg_startzpos[no],\n\t\t\t\t\t\t\t     &reg_startzp[no]);\n\t\t    // We simply continue and handle the result when done.\n\t\t}\n\t    }\n\t    break;\n#endif\n\n\t  case MCLOSE + 0:  // Match end: \\ze\n\t  case MCLOSE + 1:  // \\)\n\t  case MCLOSE + 2:\n\t  case MCLOSE + 3:\n\t  case MCLOSE + 4:\n\t  case MCLOSE + 5:\n\t  case MCLOSE + 6:\n\t  case MCLOSE + 7:\n\t  case MCLOSE + 8:\n\t  case MCLOSE + 9:\n\t    {\n\t\tno = op - MCLOSE;\n\t\tcleanup_subexpr();\n\t\trp = regstack_push(RS_MCLOSE, scan);\n\t\tif (rp == NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    rp->rs_no = no;\n\t\t    save_se(&rp->rs_un.sesave, &rex.reg_endpos[no],\n\t\t\t\t\t\t\t    &rex.reg_endp[no]);\n\t\t    // We simply continue and handle the result when done.\n\t\t}\n\t    }\n\t    break;\n\n#ifdef FEAT_SYN_HL\n\t  case ZCLOSE + 1:  // \\) after \\z(\n\t  case ZCLOSE + 2:\n\t  case ZCLOSE + 3:\n\t  case ZCLOSE + 4:\n\t  case ZCLOSE + 5:\n\t  case ZCLOSE + 6:\n\t  case ZCLOSE + 7:\n\t  case ZCLOSE + 8:\n\t  case ZCLOSE + 9:\n\t    {\n\t\tno = op - ZCLOSE;\n\t\tcleanup_zsubexpr();\n\t\trp = regstack_push(RS_ZCLOSE, scan);\n\t\tif (rp == NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    rp->rs_no = no;\n\t\t    save_se(&rp->rs_un.sesave, &reg_endzpos[no],\n\t\t\t\t\t\t\t      &reg_endzp[no]);\n\t\t    // We simply continue and handle the result when done.\n\t\t}\n\t    }\n\t    break;\n#endif\n\n\t  case BACKREF + 1:\n\t  case BACKREF + 2:\n\t  case BACKREF + 3:\n\t  case BACKREF + 4:\n\t  case BACKREF + 5:\n\t  case BACKREF + 6:\n\t  case BACKREF + 7:\n\t  case BACKREF + 8:\n\t  case BACKREF + 9:\n\t    {\n\t\tint\t\tlen;\n\n\t\tno = op - BACKREF;\n\t\tcleanup_subexpr();\n\t\tif (!REG_MULTI)\t\t// Single-line regexp\n\t\t{\n\t\t    if (rex.reg_startp[no] == NULL || rex.reg_endp[no] == NULL)\n\t\t    {\n\t\t\t// Backref was not set: Match an empty string.\n\t\t\tlen = 0;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// Compare current input with back-ref in the same\n\t\t\t// line.\n\t\t\tlen = (int)(rex.reg_endp[no] - rex.reg_startp[no]);\n\t\t\tif (cstrncmp(rex.reg_startp[no], rex.input, &len) != 0)\n\t\t\t    status = RA_NOMATCH;\n\t\t    }\n\t\t}\n\t\telse\t\t\t\t// Multi-line regexp\n\t\t{\n\t\t    if (rex.reg_startpos[no].lnum < 0\n\t\t\t\t\t\t|| rex.reg_endpos[no].lnum < 0)\n\t\t    {\n\t\t\t// Backref was not set: Match an empty string.\n\t\t\tlen = 0;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (rex.reg_startpos[no].lnum == rex.lnum\n\t\t\t\t&& rex.reg_endpos[no].lnum == rex.lnum)\n\t\t\t{\n\t\t\t    // Compare back-ref within the current line.\n\t\t\t    len = rex.reg_endpos[no].col\n\t\t\t\t\t\t    - rex.reg_startpos[no].col;\n\t\t\t    if (cstrncmp(rex.line + rex.reg_startpos[no].col,\n\t\t\t\t\t\t\t  rex.input, &len) != 0)\n\t\t\t\tstatus = RA_NOMATCH;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // Messy situation: Need to compare between two\n\t\t\t    // lines.\n\t\t\t    int r = match_with_backref(\n\t\t\t\t\t    rex.reg_startpos[no].lnum,\n\t\t\t\t\t    rex.reg_startpos[no].col,\n\t\t\t\t\t    rex.reg_endpos[no].lnum,\n\t\t\t\t\t    rex.reg_endpos[no].col,\n\t\t\t\t\t    &len);\n\n\t\t\t    if (r != RA_MATCH)\n\t\t\t\tstatus = r;\n\t\t\t}\n\t\t    }\n\t\t}\n\n\t\t// Matched the backref, skip over it.\n\t\trex.input += len;\n\t    }\n\t    break;\n\n#ifdef FEAT_SYN_HL\n\t  case ZREF + 1:\n\t  case ZREF + 2:\n\t  case ZREF + 3:\n\t  case ZREF + 4:\n\t  case ZREF + 5:\n\t  case ZREF + 6:\n\t  case ZREF + 7:\n\t  case ZREF + 8:\n\t  case ZREF + 9:\n\t    {\n\t\tint\tlen;\n\n\t\tcleanup_zsubexpr();\n\t\tno = op - ZREF;\n\t\tif (re_extmatch_in != NULL\n\t\t\t&& re_extmatch_in->matches[no] != NULL)\n\t\t{\n\t\t    len = (int)STRLEN(re_extmatch_in->matches[no]);\n\t\t    if (cstrncmp(re_extmatch_in->matches[no],\n\t\t\t\t\t\t\t  rex.input, &len) != 0)\n\t\t\tstatus = RA_NOMATCH;\n\t\t    else\n\t\t\trex.input += len;\n\t\t}\n\t\telse\n\t\t{\n\t\t    // Backref was not set: Match an empty string.\n\t\t}\n\t    }\n\t    break;\n#endif\n\n\t  case BRANCH:\n\t    {\n\t\tif (OP(next) != BRANCH) // No choice.\n\t\t    next = OPERAND(scan);\t// Avoid recursion.\n\t\telse\n\t\t{\n\t\t    rp = regstack_push(RS_BRANCH, scan);\n\t\t    if (rp == NULL)\n\t\t\tstatus = RA_FAIL;\n\t\t    else\n\t\t\tstatus = RA_BREAK;\t// rest is below\n\t\t}\n\t    }\n\t    break;\n\n\t  case BRACE_LIMITS:\n\t    {\n\t\tif (OP(next) == BRACE_SIMPLE)\n\t\t{\n\t\t    bl_minval = OPERAND_MIN(scan);\n\t\t    bl_maxval = OPERAND_MAX(scan);\n\t\t}\n\t\telse if (OP(next) >= BRACE_COMPLEX\n\t\t\t&& OP(next) < BRACE_COMPLEX + 10)\n\t\t{\n\t\t    no = OP(next) - BRACE_COMPLEX;\n\t\t    brace_min[no] = OPERAND_MIN(scan);\n\t\t    brace_max[no] = OPERAND_MAX(scan);\n\t\t    brace_count[no] = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t    internal_error(\"BRACE_LIMITS\");\n\t\t    status = RA_FAIL;\n\t\t}\n\t    }\n\t    break;\n\n\t  case BRACE_COMPLEX + 0:\n\t  case BRACE_COMPLEX + 1:\n\t  case BRACE_COMPLEX + 2:\n\t  case BRACE_COMPLEX + 3:\n\t  case BRACE_COMPLEX + 4:\n\t  case BRACE_COMPLEX + 5:\n\t  case BRACE_COMPLEX + 6:\n\t  case BRACE_COMPLEX + 7:\n\t  case BRACE_COMPLEX + 8:\n\t  case BRACE_COMPLEX + 9:\n\t    {\n\t\tno = op - BRACE_COMPLEX;\n\t\t++brace_count[no];\n\n\t\t// If not matched enough times yet, try one more\n\t\tif (brace_count[no] <= (brace_min[no] <= brace_max[no]\n\t\t\t\t\t     ? brace_min[no] : brace_max[no]))\n\t\t{\n\t\t    rp = regstack_push(RS_BRCPLX_MORE, scan);\n\t\t    if (rp == NULL)\n\t\t\tstatus = RA_FAIL;\n\t\t    else\n\t\t    {\n\t\t\trp->rs_no = no;\n\t\t\treg_save(&rp->rs_un.regsave, &backpos);\n\t\t\tnext = OPERAND(scan);\n\t\t\t// We continue and handle the result when done.\n\t\t    }\n\t\t    break;\n\t\t}\n\n\t\t// If matched enough times, may try matching some more\n\t\tif (brace_min[no] <= brace_max[no])\n\t\t{\n\t\t    // Range is the normal way around, use longest match\n\t\t    if (brace_count[no] <= brace_max[no])\n\t\t    {\n\t\t\trp = regstack_push(RS_BRCPLX_LONG, scan);\n\t\t\tif (rp == NULL)\n\t\t\t    status = RA_FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t    rp->rs_no = no;\n\t\t\t    reg_save(&rp->rs_un.regsave, &backpos);\n\t\t\t    next = OPERAND(scan);\n\t\t\t    // We continue and handle the result when done.\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    // Range is backwards, use shortest match first\n\t\t    if (brace_count[no] <= brace_min[no])\n\t\t    {\n\t\t\trp = regstack_push(RS_BRCPLX_SHORT, scan);\n\t\t\tif (rp == NULL)\n\t\t\t    status = RA_FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t    reg_save(&rp->rs_un.regsave, &backpos);\n\t\t\t    // We continue and handle the result when done.\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    break;\n\n\t  case BRACE_SIMPLE:\n\t  case STAR:\n\t  case PLUS:\n\t    {\n\t\tregstar_T\trst;\n\n\t\t// Lookahead to avoid useless match attempts when we know\n\t\t// what character comes next.\n\t\tif (OP(next) == EXACTLY)\n\t\t{\n\t\t    rst.nextb = *OPERAND(next);\n\t\t    if (rex.reg_ic)\n\t\t    {\n\t\t\tif (MB_ISUPPER(rst.nextb))\n\t\t\t    rst.nextb_ic = MB_TOLOWER(rst.nextb);\n\t\t\telse\n\t\t\t    rst.nextb_ic = MB_TOUPPER(rst.nextb);\n\t\t    }\n\t\t    else\n\t\t\trst.nextb_ic = rst.nextb;\n\t\t}\n\t\telse\n\t\t{\n\t\t    rst.nextb = NUL;\n\t\t    rst.nextb_ic = NUL;\n\t\t}\n\t\tif (op != BRACE_SIMPLE)\n\t\t{\n\t\t    rst.minval = (op == STAR) ? 0 : 1;\n\t\t    rst.maxval = MAX_LIMIT;\n\t\t}\n\t\telse\n\t\t{\n\t\t    rst.minval = bl_minval;\n\t\t    rst.maxval = bl_maxval;\n\t\t}\n\n\t\t// When maxval > minval, try matching as much as possible, up\n\t\t// to maxval.  When maxval < minval, try matching at least the\n\t\t// minimal number (since the range is backwards, that's also\n\t\t// maxval!).\n\t\trst.count = regrepeat(OPERAND(scan), rst.maxval);\n\t\tif (got_int)\n\t\t{\n\t\t    status = RA_FAIL;\n\t\t    break;\n\t\t}\n\t\tif (rst.minval <= rst.maxval\n\t\t\t  ? rst.count >= rst.minval : rst.count >= rst.maxval)\n\t\t{\n\t\t    // It could match.  Prepare for trying to match what\n\t\t    // follows.  The code is below.  Parameters are stored in\n\t\t    // a regstar_T on the regstack.\n\t\t    if ((long)((unsigned)regstack.ga_len >> 10) >= p_mmp)\n\t\t    {\n\t\t\temsg(_(e_pattern_uses_more_memory_than_maxmempattern));\n\t\t\tstatus = RA_FAIL;\n\t\t    }\n\t\t    else if (ga_grow(&regstack, sizeof(regstar_T)) == FAIL)\n\t\t\tstatus = RA_FAIL;\n\t\t    else\n\t\t    {\n\t\t\tregstack.ga_len += sizeof(regstar_T);\n\t\t\trp = regstack_push(rst.minval <= rst.maxval\n\t\t\t\t\t? RS_STAR_LONG : RS_STAR_SHORT, scan);\n\t\t\tif (rp == NULL)\n\t\t\t    status = RA_FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t    *(((regstar_T *)rp) - 1) = rst;\n\t\t\t    status = RA_BREAK;\t    // skip the restore bits\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse\n\t\t    status = RA_NOMATCH;\n\n\t    }\n\t    break;\n\n\t  case NOMATCH:\n\t  case MATCH:\n\t  case SUBPAT:\n\t    rp = regstack_push(RS_NOMATCH, scan);\n\t    if (rp == NULL)\n\t\tstatus = RA_FAIL;\n\t    else\n\t    {\n\t\trp->rs_no = op;\n\t\treg_save(&rp->rs_un.regsave, &backpos);\n\t\tnext = OPERAND(scan);\n\t\t// We continue and handle the result when done.\n\t    }\n\t    break;\n\n\t  case BEHIND:\n\t  case NOBEHIND:\n\t    // Need a bit of room to store extra positions.\n\t    if ((long)((unsigned)regstack.ga_len >> 10) >= p_mmp)\n\t    {\n\t\temsg(_(e_pattern_uses_more_memory_than_maxmempattern));\n\t\tstatus = RA_FAIL;\n\t    }\n\t    else if (ga_grow(&regstack, sizeof(regbehind_T)) == FAIL)\n\t\tstatus = RA_FAIL;\n\t    else\n\t    {\n\t\tregstack.ga_len += sizeof(regbehind_T);\n\t\trp = regstack_push(RS_BEHIND1, scan);\n\t\tif (rp == NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    // Need to save the subexpr to be able to restore them\n\t\t    // when there is a match but we don't use it.\n\t\t    save_subexpr(((regbehind_T *)rp) - 1);\n\n\t\t    rp->rs_no = op;\n\t\t    reg_save(&rp->rs_un.regsave, &backpos);\n\t\t    // First try if what follows matches.  If it does then we\n\t\t    // check the behind match by looping.\n\t\t}\n\t    }\n\t    break;\n\n\t  case BHPOS:\n\t    if (REG_MULTI)\n\t    {\n\t\tif (behind_pos.rs_u.pos.col != (colnr_T)(rex.input - rex.line)\n\t\t\t|| behind_pos.rs_u.pos.lnum != rex.lnum)\n\t\t    status = RA_NOMATCH;\n\t    }\n\t    else if (behind_pos.rs_u.ptr != rex.input)\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case NEWL:\n\t    if ((c != NUL || !REG_MULTI || rex.lnum > rex.reg_maxline\n\t\t\t     || rex.reg_line_lbr)\n\t\t\t\t\t   && (c != '\\n' || !rex.reg_line_lbr))\n\t\tstatus = RA_NOMATCH;\n\t    else if (rex.reg_line_lbr)\n\t\tADVANCE_REGINPUT();\n\t    else\n\t\treg_nextline();\n\t    break;\n\n\t  case END:\n\t    status = RA_MATCH;\t// Success!\n\t    break;\n\n\t  default:\n\t    iemsg(_(e_corrupted_regexp_program));\n#ifdef DEBUG\n\t    printf(\"Illegal op code %d\\n\", op);\n#endif\n\t    status = RA_FAIL;\n\t    break;\n\t  }\n\t}\n\n\t// If we can't continue sequentially, break the inner loop.\n\tif (status != RA_CONT)\n\t    break;\n\n\t// Continue in inner loop, advance to next item.\n\tscan = next;\n\n    } // end of inner loop\n\n    // If there is something on the regstack execute the code for the state.\n    // If the state is popped then loop and use the older state.\n    while (regstack.ga_len > 0 && status != RA_FAIL)\n    {\n\trp = (regitem_T *)((char *)regstack.ga_data + regstack.ga_len) - 1;\n\tswitch (rp->rs_state)\n\t{\n\t  case RS_NOPEN:\n\t    // Result is passed on as-is, simply pop the state.\n\t    regstack_pop(&scan);\n\t    break;\n\n\t  case RS_MOPEN:\n\t    // Pop the state.  Restore pointers when there is no match.\n\t    if (status == RA_NOMATCH)\n\t\trestore_se(&rp->rs_un.sesave, &rex.reg_startpos[rp->rs_no],\n\t\t\t\t\t\t  &rex.reg_startp[rp->rs_no]);\n\t    regstack_pop(&scan);\n\t    break;\n\n#ifdef FEAT_SYN_HL\n\t  case RS_ZOPEN:\n\t    // Pop the state.  Restore pointers when there is no match.\n\t    if (status == RA_NOMATCH)\n\t\trestore_se(&rp->rs_un.sesave, &reg_startzpos[rp->rs_no],\n\t\t\t\t\t\t &reg_startzp[rp->rs_no]);\n\t    regstack_pop(&scan);\n\t    break;\n#endif\n\n\t  case RS_MCLOSE:\n\t    // Pop the state.  Restore pointers when there is no match.\n\t    if (status == RA_NOMATCH)\n\t\trestore_se(&rp->rs_un.sesave, &rex.reg_endpos[rp->rs_no],\n\t\t\t\t\t\t    &rex.reg_endp[rp->rs_no]);\n\t    regstack_pop(&scan);\n\t    break;\n\n#ifdef FEAT_SYN_HL\n\t  case RS_ZCLOSE:\n\t    // Pop the state.  Restore pointers when there is no match.\n\t    if (status == RA_NOMATCH)\n\t\trestore_se(&rp->rs_un.sesave, &reg_endzpos[rp->rs_no],\n\t\t\t\t\t\t   &reg_endzp[rp->rs_no]);\n\t    regstack_pop(&scan);\n\t    break;\n#endif\n\n\t  case RS_BRANCH:\n\t    if (status == RA_MATCH)\n\t\t// this branch matched, use it\n\t\tregstack_pop(&scan);\n\t    else\n\t    {\n\t\tif (status != RA_BREAK)\n\t\t{\n\t\t    // After a non-matching branch: try next one.\n\t\t    reg_restore(&rp->rs_un.regsave, &backpos);\n\t\t    scan = rp->rs_scan;\n\t\t}\n\t\tif (scan == NULL || OP(scan) != BRANCH)\n\t\t{\n\t\t    // no more branches, didn't find a match\n\t\t    status = RA_NOMATCH;\n\t\t    regstack_pop(&scan);\n\t\t}\n\t\telse\n\t\t{\n\t\t    // Prepare to try a branch.\n\t\t    rp->rs_scan = regnext(scan);\n\t\t    reg_save(&rp->rs_un.regsave, &backpos);\n\t\t    scan = OPERAND(scan);\n\t\t}\n\t    }\n\t    break;\n\n\t  case RS_BRCPLX_MORE:\n\t    // Pop the state.  Restore pointers when there is no match.\n\t    if (status == RA_NOMATCH)\n\t    {\n\t\treg_restore(&rp->rs_un.regsave, &backpos);\n\t\t--brace_count[rp->rs_no];\t// decrement match count\n\t    }\n\t    regstack_pop(&scan);\n\t    break;\n\n\t  case RS_BRCPLX_LONG:\n\t    // Pop the state.  Restore pointers when there is no match.\n\t    if (status == RA_NOMATCH)\n\t    {\n\t\t// There was no match, but we did find enough matches.\n\t\treg_restore(&rp->rs_un.regsave, &backpos);\n\t\t--brace_count[rp->rs_no];\n\t\t// continue with the items after \"\\{}\"\n\t\tstatus = RA_CONT;\n\t    }\n\t    regstack_pop(&scan);\n\t    if (status == RA_CONT)\n\t\tscan = regnext(scan);\n\t    break;\n\n\t  case RS_BRCPLX_SHORT:\n\t    // Pop the state.  Restore pointers when there is no match.\n\t    if (status == RA_NOMATCH)\n\t\t// There was no match, try to match one more item.\n\t\treg_restore(&rp->rs_un.regsave, &backpos);\n\t    regstack_pop(&scan);\n\t    if (status == RA_NOMATCH)\n\t    {\n\t\tscan = OPERAND(scan);\n\t\tstatus = RA_CONT;\n\t    }\n\t    break;\n\n\t  case RS_NOMATCH:\n\t    // Pop the state.  If the operand matches for NOMATCH or\n\t    // doesn't match for MATCH/SUBPAT, we fail.  Otherwise backup,\n\t    // except for SUBPAT, and continue with the next item.\n\t    if (status == (rp->rs_no == NOMATCH ? RA_MATCH : RA_NOMATCH))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t    {\n\t\tstatus = RA_CONT;\n\t\tif (rp->rs_no != SUBPAT)\t// zero-width\n\t\t    reg_restore(&rp->rs_un.regsave, &backpos);\n\t    }\n\t    regstack_pop(&scan);\n\t    if (status == RA_CONT)\n\t\tscan = regnext(scan);\n\t    break;\n\n\t  case RS_BEHIND1:\n\t    if (status == RA_NOMATCH)\n\t    {\n\t\tregstack_pop(&scan);\n\t\tregstack.ga_len -= sizeof(regbehind_T);\n\t    }\n\t    else\n\t    {\n\t\t// The stuff after BEHIND/NOBEHIND matches.  Now try if\n\t\t// the behind part does (not) match before the current\n\t\t// position in the input.  This must be done at every\n\t\t// position in the input and checking if the match ends at\n\t\t// the current position.\n\n\t\t// save the position after the found match for next\n\t\treg_save(&(((regbehind_T *)rp) - 1)->save_after, &backpos);\n\n\t\t// Start looking for a match with operand at the current\n\t\t// position.  Go back one character until we find the\n\t\t// result, hitting the start of the line or the previous\n\t\t// line (for multi-line matching).\n\t\t// Set behind_pos to where the match should end, BHPOS\n\t\t// will match it.  Save the current value.\n\t\t(((regbehind_T *)rp) - 1)->save_behind = behind_pos;\n\t\tbehind_pos = rp->rs_un.regsave;\n\n\t\trp->rs_state = RS_BEHIND2;\n\n\t\treg_restore(&rp->rs_un.regsave, &backpos);\n\t\tscan = OPERAND(rp->rs_scan) + 4;\n\t    }\n\t    break;\n\n\t  case RS_BEHIND2:\n\t    // Looping for BEHIND / NOBEHIND match.\n\t    if (status == RA_MATCH && reg_save_equal(&behind_pos))\n\t    {\n\t\t// found a match that ends where \"next\" started\n\t\tbehind_pos = (((regbehind_T *)rp) - 1)->save_behind;\n\t\tif (rp->rs_no == BEHIND)\n\t\t    reg_restore(&(((regbehind_T *)rp) - 1)->save_after,\n\t\t\t\t\t\t\t\t    &backpos);\n\t\telse\n\t\t{\n\t\t    // But we didn't want a match.  Need to restore the\n\t\t    // subexpr, because what follows matched, so they have\n\t\t    // been set.\n\t\t    status = RA_NOMATCH;\n\t\t    restore_subexpr(((regbehind_T *)rp) - 1);\n\t\t}\n\t\tregstack_pop(&scan);\n\t\tregstack.ga_len -= sizeof(regbehind_T);\n\t    }\n\t    else\n\t    {\n\t\tlong limit;\n\n\t\t// No match or a match that doesn't end where we want it: Go\n\t\t// back one character.  May go to previous line once.\n\t\tno = OK;\n\t\tlimit = OPERAND_MIN(rp->rs_scan);\n\t\tif (REG_MULTI)\n\t\t{\n\t\t    if (limit > 0\n\t\t\t    && ((rp->rs_un.regsave.rs_u.pos.lnum\n\t\t\t\t\t\t    < behind_pos.rs_u.pos.lnum\n\t\t\t\t    ? (colnr_T)STRLEN(rex.line)\n\t\t\t\t    : behind_pos.rs_u.pos.col)\n\t\t\t\t- rp->rs_un.regsave.rs_u.pos.col >= limit))\n\t\t\tno = FAIL;\n\t\t    else if (rp->rs_un.regsave.rs_u.pos.col == 0)\n\t\t    {\n\t\t\tif (rp->rs_un.regsave.rs_u.pos.lnum\n\t\t\t\t\t< behind_pos.rs_u.pos.lnum\n\t\t\t\t|| reg_getline(\n\t\t\t\t\t--rp->rs_un.regsave.rs_u.pos.lnum)\n\t\t\t\t\t\t\t\t  == NULL)\n\t\t\t    no = FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t    reg_restore(&rp->rs_un.regsave, &backpos);\n\t\t\t    rp->rs_un.regsave.rs_u.pos.col =\n\t\t\t\t\t\t (colnr_T)STRLEN(rex.line);\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (has_mbyte)\n\t\t\t{\n\t\t\t    char_u *line =\n\t\t\t\t  reg_getline(rp->rs_un.regsave.rs_u.pos.lnum);\n\n\t\t\t    rp->rs_un.regsave.rs_u.pos.col -=\n\t\t\t\t(*mb_head_off)(line, line\n\t\t\t\t    + rp->rs_un.regsave.rs_u.pos.col - 1) + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t    --rp->rs_un.regsave.rs_u.pos.col;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (rp->rs_un.regsave.rs_u.ptr == rex.line)\n\t\t\tno = FAIL;\n\t\t    else\n\t\t    {\n\t\t\tMB_PTR_BACK(rex.line, rp->rs_un.regsave.rs_u.ptr);\n\t\t\tif (limit > 0 && (long)(behind_pos.rs_u.ptr\n\t\t\t\t     - rp->rs_un.regsave.rs_u.ptr) > limit)\n\t\t\t    no = FAIL;\n\t\t    }\n\t\t}\n\t\tif (no == OK)\n\t\t{\n\t\t    // Advanced, prepare for finding match again.\n\t\t    reg_restore(&rp->rs_un.regsave, &backpos);\n\t\t    scan = OPERAND(rp->rs_scan) + 4;\n\t\t    if (status == RA_MATCH)\n\t\t    {\n\t\t\t// We did match, so subexpr may have been changed,\n\t\t\t// need to restore them for the next try.\n\t\t\tstatus = RA_NOMATCH;\n\t\t\trestore_subexpr(((regbehind_T *)rp) - 1);\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    // Can't advance.  For NOBEHIND that's a match.\n\t\t    behind_pos = (((regbehind_T *)rp) - 1)->save_behind;\n\t\t    if (rp->rs_no == NOBEHIND)\n\t\t    {\n\t\t\treg_restore(&(((regbehind_T *)rp) - 1)->save_after,\n\t\t\t\t\t\t\t\t    &backpos);\n\t\t\tstatus = RA_MATCH;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// We do want a proper match.  Need to restore the\n\t\t\t// subexpr if we had a match, because they may have\n\t\t\t// been set.\n\t\t\tif (status == RA_MATCH)\n\t\t\t{\n\t\t\t    status = RA_NOMATCH;\n\t\t\t    restore_subexpr(((regbehind_T *)rp) - 1);\n\t\t\t}\n\t\t    }\n\t\t    regstack_pop(&scan);\n\t\t    regstack.ga_len -= sizeof(regbehind_T);\n\t\t}\n\t    }\n\t    break;\n\n\t  case RS_STAR_LONG:\n\t  case RS_STAR_SHORT:\n\t    {\n\t\tregstar_T\t    *rst = ((regstar_T *)rp) - 1;\n\n\t\tif (status == RA_MATCH)\n\t\t{\n\t\t    regstack_pop(&scan);\n\t\t    regstack.ga_len -= sizeof(regstar_T);\n\t\t    break;\n\t\t}\n\n\t\t// Tried once already, restore input pointers.\n\t\tif (status != RA_BREAK)\n\t\t    reg_restore(&rp->rs_un.regsave, &backpos);\n\n\t\t// Repeat until we found a position where it could match.\n\t\tfor (;;)\n\t\t{\n\t\t    if (status != RA_BREAK)\n\t\t    {\n\t\t\t// Tried first position already, advance.\n\t\t\tif (rp->rs_state == RS_STAR_LONG)\n\t\t\t{\n\t\t\t    // Trying for longest match, but couldn't or\n\t\t\t    // didn't match -- back up one char.\n\t\t\t    if (--rst->count < rst->minval)\n\t\t\t\tbreak;\n\t\t\t    if (rex.input == rex.line)\n\t\t\t    {\n\t\t\t\t// backup to last char of previous line\n\t\t\t\tif (rex.lnum == 0)\n\t\t\t\t{\n\t\t\t\t    status = RA_NOMATCH;\n\t\t\t\t    break;\n\t\t\t\t}\n\t\t\t\t--rex.lnum;\n\t\t\t\trex.line = reg_getline(rex.lnum);\n\t\t\t\t// Just in case regrepeat() didn't count\n\t\t\t\t// right.\n\t\t\t\tif (rex.line == NULL)\n\t\t\t\t    break;\n\t\t\t\trex.input = rex.line + STRLEN(rex.line);\n\t\t\t\tfast_breakcheck();\n\t\t\t    }\n\t\t\t    else\n\t\t\t\tMB_PTR_BACK(rex.line, rex.input);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // Range is backwards, use shortest match first.\n\t\t\t    // Careful: maxval and minval are exchanged!\n\t\t\t    // Couldn't or didn't match: try advancing one\n\t\t\t    // char.\n\t\t\t    if (rst->count == rst->minval\n\t\t\t\t  || regrepeat(OPERAND(rp->rs_scan), 1L) == 0)\n\t\t\t\tbreak;\n\t\t\t    ++rst->count;\n\t\t\t}\n\t\t\tif (got_int)\n\t\t\t    break;\n\t\t    }\n\t\t    else\n\t\t\tstatus = RA_NOMATCH;\n\n\t\t    // If it could match, try it.\n\t\t    if (rst->nextb == NUL || *rex.input == rst->nextb\n\t\t\t\t\t     || *rex.input == rst->nextb_ic)\n\t\t    {\n\t\t\treg_save(&rp->rs_un.regsave, &backpos);\n\t\t\tscan = regnext(rp->rs_scan);\n\t\t\tstatus = RA_CONT;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\tif (status != RA_CONT)\n\t\t{\n\t\t    // Failed.\n\t\t    regstack_pop(&scan);\n\t\t    regstack.ga_len -= sizeof(regstar_T);\n\t\t    status = RA_NOMATCH;\n\t\t}\n\t    }\n\t    break;\n\t}\n\n\t// If we want to continue the inner loop or didn't pop a state\n\t// continue matching loop\n\tif (status == RA_CONT || rp == (regitem_T *)\n\t\t\t     ((char *)regstack.ga_data + regstack.ga_len) - 1)\n\t    break;\n    }\n\n    // May need to continue with the inner loop, starting at \"scan\".\n    if (status == RA_CONT)\n\tcontinue;\n\n    // If the regstack is empty or something failed we are done.\n    if (regstack.ga_len == 0 || status == RA_FAIL)\n    {\n\tif (scan == NULL)\n\t{\n\t    // We get here only if there's trouble -- normally \"case END\" is\n\t    // the terminating point.\n\t    iemsg(_(e_corrupted_regexp_program));\n#ifdef DEBUG\n\t    printf(\"Premature EOL\\n\");\n#endif\n\t}\n\treturn (status == RA_MATCH);\n    }\n\n  } // End of loop until the regstack is empty.\n\n  // NOTREACHED\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 390,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int em28xx_usb_probe(struct usb_interface *intf,\n\t\t\t    const struct usb_device_id *id)\n{\n\tstruct usb_device *udev;\n\tstruct em28xx *dev = NULL;\n\tint retval;\n\tbool has_vendor_audio = false, has_video = false, has_dvb = false;\n\tint i, nr, try_bulk;\n\tconst int ifnum = intf->altsetting[0].desc.bInterfaceNumber;\n\tchar *speed;\n\n\tudev = usb_get_dev(interface_to_usbdev(intf));\n\n\t/* Check to see next free device and mark as used */\n\tdo {\n\t\tnr = find_first_zero_bit(em28xx_devused, EM28XX_MAXBOARDS);\n\t\tif (nr >= EM28XX_MAXBOARDS) {\n\t\t\t/* No free device slots */\n\t\t\tdev_err(&intf->dev,\n\t\t\t\t\"Driver supports up to %i em28xx boards.\\n\",\n\t\t\t       EM28XX_MAXBOARDS);\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto err_no_slot;\n\t\t}\n\t} while (test_and_set_bit(nr, em28xx_devused));\n\n\t/* Don't register audio interfaces */\n\tif (intf->altsetting[0].desc.bInterfaceClass == USB_CLASS_AUDIO) {\n\t\tdev_info(&intf->dev,\n\t\t\t\"audio device (%04x:%04x): interface %i, class %i\\n\",\n\t\t\tle16_to_cpu(udev->descriptor.idVendor),\n\t\t\tle16_to_cpu(udev->descriptor.idProduct),\n\t\t\tifnum,\n\t\t\tintf->altsetting[0].desc.bInterfaceClass);\n\n\t\tretval = -ENODEV;\n\t\tgoto err;\n\t}\n\n\t/* allocate memory for our device state and initialize it */\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev) {\n\t\tretval = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\t/* compute alternate max packet sizes */\n\tdev->alt_max_pkt_size_isoc = kcalloc(intf->num_altsetting,\n\t\t\t\t\t     sizeof(dev->alt_max_pkt_size_isoc[0]),\n\t\t\t\t\t     GFP_KERNEL);\n\tif (!dev->alt_max_pkt_size_isoc) {\n\t\tkfree(dev);\n\t\tretval = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\t/* Get endpoints */\n\tfor (i = 0; i < intf->num_altsetting; i++) {\n\t\tint ep;\n\n\t\tfor (ep = 0;\n\t\t     ep < intf->altsetting[i].desc.bNumEndpoints;\n\t\t     ep++)\n\t\t\tem28xx_check_usb_descriptor(dev, udev, intf,\n\t\t\t\t\t\t    i, ep,\n\t\t\t\t\t\t    &has_vendor_audio,\n\t\t\t\t\t\t    &has_video,\n\t\t\t\t\t\t    &has_dvb);\n\t}\n\n\tif (!(has_vendor_audio || has_video || has_dvb)) {\n\t\tretval = -ENODEV;\n\t\tgoto err_free;\n\t}\n\n\tswitch (udev->speed) {\n\tcase USB_SPEED_LOW:\n\t\tspeed = \"1.5\";\n\t\tbreak;\n\tcase USB_SPEED_UNKNOWN:\n\tcase USB_SPEED_FULL:\n\t\tspeed = \"12\";\n\t\tbreak;\n\tcase USB_SPEED_HIGH:\n\t\tspeed = \"480\";\n\t\tbreak;\n\tdefault:\n\t\tspeed = \"unknown\";\n\t}\n\n\tdev_info(&intf->dev,\n\t\t\"New device %s %s @ %s Mbps (%04x:%04x, interface %d, class %d)\\n\",\n\t\tudev->manufacturer ? udev->manufacturer : \"\",\n\t\tudev->product ? udev->product : \"\",\n\t\tspeed,\n\t\tle16_to_cpu(udev->descriptor.idVendor),\n\t\tle16_to_cpu(udev->descriptor.idProduct),\n\t\tifnum,\n\t\tintf->altsetting->desc.bInterfaceNumber);\n\n\t/*\n\t * Make sure we have 480 Mbps of bandwidth, otherwise things like\n\t * video stream wouldn't likely work, since 12 Mbps is generally\n\t * not enough even for most Digital TV streams.\n\t */\n\tif (udev->speed != USB_SPEED_HIGH && disable_usb_speed_check == 0) {\n\t\tdev_err(&intf->dev, \"Device initialization failed.\\n\");\n\t\tdev_err(&intf->dev,\n\t\t\t\"Device must be connected to a high-speed USB 2.0 port.\\n\");\n\t\tretval = -ENODEV;\n\t\tgoto err_free;\n\t}\n\n\tkref_init(&dev->ref);\n\n\tdev->devno = nr;\n\tdev->model = id->driver_info;\n\tdev->alt   = -1;\n\tdev->is_audio_only = has_vendor_audio && !(has_video || has_dvb);\n\tdev->has_video = has_video;\n\tdev->ifnum = ifnum;\n\n\tdev->ts = PRIMARY_TS;\n\tsnprintf(dev->name, 28, \"em28xx\");\n\tdev->dev_next = NULL;\n\n\tif (has_vendor_audio) {\n\t\tdev_info(&intf->dev,\n\t\t\t\"Audio interface %i found (Vendor Class)\\n\", ifnum);\n\t\tdev->usb_audio_type = EM28XX_USB_AUDIO_VENDOR;\n\t}\n\t/* Checks if audio is provided by a USB Audio Class intf */\n\tfor (i = 0; i < udev->config->desc.bNumInterfaces; i++) {\n\t\tstruct usb_interface *uif = udev->config->interface[i];\n\n\t\tif (uif->altsetting[0].desc.bInterfaceClass == USB_CLASS_AUDIO) {\n\t\t\tif (has_vendor_audio)\n\t\t\t\tdev_err(&intf->dev,\n\t\t\t\t\t\"em28xx: device seems to have vendor AND usb audio class interfaces !\\n\"\n\t\t\t\t\t\"\\t\\tThe vendor interface will be ignored. Please contact the developers <linux-media@vger.kernel.org>\\n\");\n\t\t\tdev->usb_audio_type = EM28XX_USB_AUDIO_CLASS;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (has_video)\n\t\tdev_info(&intf->dev, \"Video interface %i found:%s%s\\n\",\n\t\t\tifnum,\n\t\t\tdev->analog_ep_bulk ? \" bulk\" : \"\",\n\t\t\tdev->analog_ep_isoc ? \" isoc\" : \"\");\n\tif (has_dvb)\n\t\tdev_info(&intf->dev, \"DVB interface %i found:%s%s\\n\",\n\t\t\tifnum,\n\t\t\tdev->dvb_ep_bulk ? \" bulk\" : \"\",\n\t\t\tdev->dvb_ep_isoc ? \" isoc\" : \"\");\n\n\tdev->num_alt = intf->num_altsetting;\n\n\tif ((unsigned int)card[nr] < em28xx_bcount)\n\t\tdev->model = card[nr];\n\n\t/* save our data pointer in this intf device */\n\tusb_set_intfdata(intf, dev);\n\n\t/* allocate device struct and check if the device is a webcam */\n\tmutex_init(&dev->lock);\n\tretval = em28xx_init_dev(dev, udev, intf, nr);\n\tif (retval)\n\t\tgoto err_free;\n\n\tif (usb_xfer_mode < 0) {\n\t\tif (dev->is_webcam)\n\t\t\ttry_bulk = 1;\n\t\telse\n\t\t\ttry_bulk = 0;\n\t} else {\n\t\ttry_bulk = usb_xfer_mode > 0;\n\t}\n\n\t/* Disable V4L2 if the device doesn't have a decoder or image sensor */\n\tif (has_video &&\n\t    dev->board.decoder == EM28XX_NODECODER &&\n\t    dev->em28xx_sensor == EM28XX_NOSENSOR) {\n\t\tdev_err(&intf->dev,\n\t\t\t\"Currently, V4L2 is not supported on this model\\n\");\n\t\thas_video = false;\n\t\tdev->has_video = false;\n\t}\n\n\tif (dev->board.has_dual_ts &&\n\t    (dev->tuner_type != TUNER_ABSENT || INPUT(0)->type)) {\n\t\t/*\n\t\t * The logic with sets alternate is not ready for dual-tuners\n\t\t * which analog modes.\n\t\t */\n\t\tdev_err(&intf->dev,\n\t\t\t\"We currently don't support analog TV or stream capture on dual tuners.\\n\");\n\t\thas_video = false;\n\t}\n\n\t/* Select USB transfer types to use */\n\tif (has_video) {\n\t\tif (!dev->analog_ep_isoc || (try_bulk && dev->analog_ep_bulk))\n\t\t\tdev->analog_xfer_bulk = 1;\n\t\tdev_info(&intf->dev, \"analog set to %s mode.\\n\",\n\t\t\tdev->analog_xfer_bulk ? \"bulk\" : \"isoc\");\n\t}\n\tif (has_dvb) {\n\t\tif (!dev->dvb_ep_isoc || (try_bulk && dev->dvb_ep_bulk))\n\t\t\tdev->dvb_xfer_bulk = 1;\n\t\tdev_info(&intf->dev, \"dvb set to %s mode.\\n\",\n\t\t\tdev->dvb_xfer_bulk ? \"bulk\" : \"isoc\");\n\t}\n\n\tif (dev->board.has_dual_ts && em28xx_duplicate_dev(dev) == 0) {\n\t\tkref_init(&dev->dev_next->ref);\n\n\t\tdev->dev_next->ts = SECONDARY_TS;\n\t\tdev->dev_next->alt   = -1;\n\t\tdev->dev_next->is_audio_only = has_vendor_audio &&\n\t\t\t\t\t\t!(has_video || has_dvb);\n\t\tdev->dev_next->has_video = false;\n\t\tdev->dev_next->ifnum = ifnum;\n\t\tdev->dev_next->model = id->driver_info;\n\n\t\tmutex_init(&dev->dev_next->lock);\n\t\tretval = em28xx_init_dev(dev->dev_next, udev, intf,\n\t\t\t\t\t dev->dev_next->devno);\n\t\tif (retval)\n\t\t\tgoto err_free;\n\n\t\tdev->dev_next->board.ir_codes = NULL; /* No IR for 2nd tuner */\n\t\tdev->dev_next->board.has_ir_i2c = 0; /* No IR for 2nd tuner */\n\n\t\tif (usb_xfer_mode < 0) {\n\t\t\tif (dev->dev_next->is_webcam)\n\t\t\t\ttry_bulk = 1;\n\t\t\telse\n\t\t\t\ttry_bulk = 0;\n\t\t} else {\n\t\t\ttry_bulk = usb_xfer_mode > 0;\n\t\t}\n\n\t\t/* Select USB transfer types to use */\n\t\tif (has_dvb) {\n\t\t\tif (!dev->dvb_ep_isoc_ts2 ||\n\t\t\t    (try_bulk && dev->dvb_ep_bulk_ts2))\n\t\t\t\tdev->dev_next->dvb_xfer_bulk = 1;\n\t\t\tdev_info(&dev->intf->dev, \"dvb ts2 set to %s mode.\\n\",\n\t\t\t\t dev->dev_next->dvb_xfer_bulk ? \"bulk\" : \"isoc\");\n\t\t}\n\n\t\tdev->dev_next->dvb_ep_isoc = dev->dvb_ep_isoc_ts2;\n\t\tdev->dev_next->dvb_ep_bulk = dev->dvb_ep_bulk_ts2;\n\t\tdev->dev_next->dvb_max_pkt_size_isoc = dev->dvb_max_pkt_size_isoc_ts2;\n\t\tdev->dev_next->dvb_alt_isoc = dev->dvb_alt_isoc;\n\n\t\t/* Configure hardware to support TS2*/\n\t\tif (dev->dvb_xfer_bulk) {\n\t\t\t/* The ep4 and ep5 are configured for BULK */\n\t\t\tem28xx_write_reg(dev, 0x0b, 0x96);\n\t\t\tmdelay(100);\n\t\t\tem28xx_write_reg(dev, 0x0b, 0x80);\n\t\t\tmdelay(100);\n\t\t} else {\n\t\t\t/* The ep4 and ep5 are configured for ISO */\n\t\t\tem28xx_write_reg(dev, 0x0b, 0x96);\n\t\t\tmdelay(100);\n\t\t\tem28xx_write_reg(dev, 0x0b, 0x82);\n\t\t\tmdelay(100);\n\t\t}\n\t}\n\n\trequest_modules(dev);\n\n\t/*\n\t * Do it at the end, to reduce dynamic configuration changes during\n\t * the device init. Yet, as request_modules() can be async, the\n\t * topology will likely change after the load of the em28xx subdrivers.\n\t */\n#ifdef CONFIG_MEDIA_CONTROLLER\n\tretval = media_device_register(dev->media_dev);\n#endif\n\n\treturn 0;\n\nerr_free:\n\tkfree(dev->alt_max_pkt_size_isoc);\n\tkfree(dev);\n\nerr:\n\tclear_bit(nr, em28xx_devused);\n\nerr_no_slot:\n\tusb_put_dev(udev);\n\treturn retval;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 474,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static void extract_arg(RAnal *anal, RAnalFunction *fcn, RAnalOp *op, const char *reg, const char *sign, char type) {\n\tst64 ptr = 0;\n\tchar *addr, *esil_buf = NULL;\n\tconst st64 maxstackframe = 1024 * 8; \n\n\tr_return_if_fail (anal && fcn && op && reg);\n\n\tsize_t i;\n\tfor (i = 0; i < R_ARRAY_SIZE (op->src); i++) {\n\t\tif (op->src[i] && op->src[i]->reg && op->src[i]->reg->name) {\n\t\t\tif (!strcmp (reg, op->src[i]->reg->name)) {\n\t\t\t\tst64 delta = op->src[i]->delta;\n\t\t\t\tif ((delta > 0 && *sign == '+') || (delta < 0 && *sign == '-')) {\n\t\t\t\t\tptr = R_ABS (op->src[i]->delta);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!ptr) {\n\t\tconst char *op_esil = r_strbuf_get (&op->esil);\n\t\tif (!op_esil) {\n\t\t\treturn;\n\t\t}\n\t\tesil_buf = strdup (op_esil);\n\t\tif (!esil_buf) {\n\t\t\treturn;\n\t\t}\n\t\tr_strf_var (esilexpr, 64, \",%s,%s,\", reg, sign);\n\t\tchar *ptr_end = strstr (esil_buf, esilexpr);\n\t\tif (!ptr_end) {\n\t\t\tfree (esil_buf);\n\t\t\treturn;\n\t\t}\n\t\t*ptr_end = 0;\n\t\taddr = ptr_end;\n\t\twhile ((addr[0] != '0' || addr[1] != 'x') && addr >= esil_buf + 1 && *addr != ',') {\n\t\t\taddr--;\n\t\t}\n\t\tif (strncmp (addr, \"0x\", 2)) {\n\t\t\t//XXX: This is a workaround for inconsistent esil\n\t\t\tif (!op->stackop && op->dst) {\n\t\t\t\tconst char *sp = r_reg_get_name (anal->reg, R_REG_NAME_SP);\n\t\t\t\tconst char *bp = r_reg_get_name (anal->reg, R_REG_NAME_BP);\n\t\t\t\tconst char *rn = op->dst->reg ? op->dst->reg->name : NULL;\n\t\t\t\tif (rn && ((bp && !strcmp (bp, rn)) || (sp && !strcmp (sp, rn)))) {\n\t\t\t\t\tif (anal->verbose) {\n\t\t\t\t\t\teprintf (\"Warning: Analysis didn't fill op->stackop for instruction that alters stack at 0x%\" PFMT64x \".\\n\", op->addr);\n\t\t\t\t\t}\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (*addr == ',') {\n\t\t\t\taddr++;\n\t\t\t}\n\t\t\tif (!op->stackop && op->type != R_ANAL_OP_TYPE_PUSH && op->type != R_ANAL_OP_TYPE_POP\n\t\t\t\t&& op->type != R_ANAL_OP_TYPE_RET && r_str_isnumber (addr)) {\n\t\t\t\tptr = (st64)r_num_get (NULL, addr);\n\t\t\t\tif (ptr && op->src[0] && ptr == op->src[0]->imm) {\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t} else if ((op->stackop == R_ANAL_STACK_SET) || (op->stackop == R_ANAL_STACK_GET)) {\n\t\t\t\tif (op->ptr % 4) {\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t\tptr = R_ABS (op->ptr);\n\t\t\t} else {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t} else {\n\t\t\tptr = (st64)r_num_get (NULL, addr);\n\t\t}\n\t}\n\n\tif (anal->verbose && (!op->src[0] || !op->dst)) {\n\t\teprintf (\"Warning: Analysis didn't fill op->src/dst at 0x%\" PFMT64x \".\\n\", op->addr);\n\t}\n\n\tint rw = (op->direction == R_ANAL_OP_DIR_WRITE) ? R_ANAL_VAR_ACCESS_TYPE_WRITE : R_ANAL_VAR_ACCESS_TYPE_READ;\n\tif (*sign == '+') {\n\t\tconst bool isarg = type == R_ANAL_VAR_KIND_SPV ? ptr >= fcn->stack : ptr >= fcn->bp_off;\n\t\tconst char *pfx = isarg ? ARGPREFIX : VARPREFIX;\n\t\tst64 frame_off;\n\t\tif (type == R_ANAL_VAR_KIND_SPV) {\n\t\t\tframe_off = ptr - fcn->stack;\n\t\t} else {\n\t\t\tframe_off = ptr - fcn->bp_off;\n\t\t}\n\t\tif (maxstackframe != 0 && (frame_off > maxstackframe || frame_off < -maxstackframe)) {\n\t\t\tgoto beach;\n\t\t}\n\t\tRAnalVar *var = get_stack_var (fcn, frame_off);\n\t\tif (var) {\n\t\t\tr_anal_var_set_access (var, reg, op->addr, rw, ptr);\n\t\t\tgoto beach;\n\t\t}\n\t\tchar *varname = NULL, *vartype = NULL;\n\t\tif (isarg) {\n\t\t\tconst char *place = fcn->cc ? r_anal_cc_arg (anal, fcn->cc, ST32_MAX) : NULL;\n\t\t\tbool stack_rev = place ? !strcmp (place, \"stack_rev\") : false;\n\t\t\tchar *fname = r_type_func_guess (anal->sdb_types, fcn->name);\n\t\t\tif (fname) {\n\t\t\t\tut64 sum_sz = 0;\n\t\t\t\tsize_t from, to, i;\n\t\t\t\tif (stack_rev) {\n\t\t\t\t\tconst size_t cnt = r_type_func_args_count (anal->sdb_types, fname);\n\t\t\t\t\tfrom = cnt ? cnt - 1 : cnt;\n\t\t\t\t\tto = fcn->cc ? r_anal_cc_max_arg (anal, fcn->cc) : 0;\n\t\t\t\t} else {\n\t\t\t\t\tfrom = fcn->cc ? r_anal_cc_max_arg (anal, fcn->cc) : 0;\n\t\t\t\t\tto = r_type_func_args_count (anal->sdb_types, fname);\n\t\t\t\t}\n\t\t\t\tconst int bytes = (fcn->bits ? fcn->bits : anal->bits) / 8;\n\t\t\t\tfor (i = from; stack_rev ? i >= to : i < to; stack_rev ? i-- : i++) {\n\t\t\t\t\tchar *tp = r_type_func_args_type (anal->sdb_types, fname, i);\n\t\t\t\t\tif (!tp) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (sum_sz == frame_off) {\n\t\t\t\t\t\tvartype = tp;\n\t\t\t\t\t\tvarname = strdup (r_type_func_args_name (anal->sdb_types, fname, i));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tut64 bit_sz = r_type_get_bitsize (anal->sdb_types, tp);\n\t\t\t\t\tsum_sz += bit_sz ? bit_sz / 8 : bytes;\n\t\t\t\t\tsum_sz = R_ROUND (sum_sz, bytes);\n\t\t\t\t\tfree (tp);\n\t\t\t\t}\n\t\t\t\tfree (fname);\n\t\t\t}\n\t\t}\n\t\tif (!varname) {\n\t\t\tif (anal->opt.varname_stack) {\n\t\t\t\tvarname = r_str_newf (\"%s_%\" PFMT64x \"h\", pfx, R_ABS (frame_off));\n\t\t\t} else {\n\t\t\t\tvarname = r_anal_function_autoname_var (fcn, type, pfx, ptr);\n\t\t\t}\n\t\t}\n\t\tif (varname) {\n#if 0\n\t\t\tif (isarg && frame_off > 48) {\n\t\t\t\tfree (varname);\n\t\t\t\tgoto beach;\n\t\t\t}\n#endif\n\t\t\tRAnalVar *var = r_anal_function_set_var (fcn, frame_off, type, vartype, anal->bits / 8, isarg, varname);\n\t\t\tif (var) {\n\t\t\t\tr_anal_var_set_access (var, reg, op->addr, rw, ptr);\n\t\t\t}\n\t\t\tfree (varname);\n\t\t}\n\t\tfree (vartype);\n\t} else {\n\t\tst64 frame_off = -(ptr + fcn->bp_off);\n\t\tif (maxstackframe > 0 && (frame_off > maxstackframe || frame_off < -maxstackframe)) {\n\t\t\tgoto beach;\n\t\t}\n\t\tRAnalVar *var = get_stack_var (fcn, frame_off);\n\t\tif (var) {\n\t\t\tr_anal_var_set_access (var, reg, op->addr, rw, -ptr);\n\t\t\tgoto beach;\n\t\t}\n\t\tchar *varname = anal->opt.varname_stack\n\t\t\t? r_str_newf (\"%s_%\" PFMT64x \"h\", VARPREFIX, R_ABS (frame_off))\n\t\t\t: r_anal_function_autoname_var (fcn, type, VARPREFIX, -ptr);\n\t\tif (varname) {\n\t\t\tRAnalVar *var = r_anal_function_set_var (fcn, frame_off, type, NULL, anal->bits / 8, false, varname);\n\t\t\tif (var) {\n\t\t\t\tr_anal_var_set_access (var, reg, op->addr, rw, -ptr);\n\t\t\t}\n\t\t\tfree (varname);\n\t\t}\n\t}\nbeach:\n\tfree (esil_buf);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 498,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "PHP_MINIT_FUNCTION(snmp)\n{\n\tnetsnmp_log_handler *logh;\n\tzend_class_entry ce, cex;\n\n\tle_snmp_session = zend_register_list_destructors_ex(php_snmp_session_destructor, NULL, PHP_SNMP_SESSION_RES_NAME, module_number);\n\n\tinit_snmp(\"snmpapp\");\n\n#ifdef NETSNMP_DS_LIB_DONT_PERSIST_STATE\n\t/* Prevent update of the snmpapp.conf file */\n\tnetsnmp_ds_set_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_DONT_PERSIST_STATE, 1);\n#endif\n\n\t/* Disable logging, use exit status'es and related variabled to detect errors */\n\tshutdown_snmp_logging();\n\tlogh = netsnmp_register_loghandler(NETSNMP_LOGHANDLER_NONE, LOG_ERR);\n\tif (logh) {\n\t\tlogh->pri_max = LOG_ERR;\n\t}\n\n\tmemcpy(&php_snmp_object_handlers, zend_get_std_object_handlers(), sizeof(zend_object_handlers));\n\tphp_snmp_object_handlers.read_property = php_snmp_read_property;\n\tphp_snmp_object_handlers.write_property = php_snmp_write_property;\n\tphp_snmp_object_handlers.has_property = php_snmp_has_property;\n\tphp_snmp_object_handlers.get_properties = php_snmp_get_properties;\n\tphp_snmp_object_handlers.get_gc = php_snmp_get_gc;\n\n\t/* Register SNMP Class */\n\tINIT_CLASS_ENTRY(ce, \"SNMP\", php_snmp_class_methods);\n\tce.create_object = php_snmp_object_new;\n\tphp_snmp_object_handlers.clone_obj = NULL;\n\tphp_snmp_ce = zend_register_internal_class(&ce TSRMLS_CC);\n\n\t/* Register SNMP Class properties */\n\tzend_hash_init(&php_snmp_properties, 0, NULL, NULL, 1);\n\tPHP_SNMP_ADD_PROPERTIES(&php_snmp_properties, php_snmp_property_entries);\n\n\tREGISTER_LONG_CONSTANT(\"SNMP_OID_OUTPUT_SUFFIX\",\tNETSNMP_OID_OUTPUT_SUFFIX,\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SNMP_OID_OUTPUT_MODULE\",\tNETSNMP_OID_OUTPUT_MODULE,\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SNMP_OID_OUTPUT_FULL\",\t\tNETSNMP_OID_OUTPUT_FULL,\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SNMP_OID_OUTPUT_NUMERIC\",\tNETSNMP_OID_OUTPUT_NUMERIC,\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SNMP_OID_OUTPUT_UCD\",\t\tNETSNMP_OID_OUTPUT_UCD,\t\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SNMP_OID_OUTPUT_NONE\",\t\tNETSNMP_OID_OUTPUT_NONE,\tCONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"SNMP_VALUE_LIBRARY\",\tSNMP_VALUE_LIBRARY,\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SNMP_VALUE_PLAIN\",\tSNMP_VALUE_PLAIN,\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SNMP_VALUE_OBJECT\",\tSNMP_VALUE_OBJECT,\tCONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"SNMP_BIT_STR\",\t\tASN_BIT_STR,\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SNMP_OCTET_STR\",\tASN_OCTET_STR,\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SNMP_OPAQUE\",\t\tASN_OPAQUE,\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SNMP_NULL\",\t\tASN_NULL,\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SNMP_OBJECT_ID\",\tASN_OBJECT_ID,\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SNMP_IPADDRESS\",\tASN_IPADDRESS,\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SNMP_COUNTER\",\t\tASN_GAUGE,\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SNMP_UNSIGNED\",\t\tASN_UNSIGNED,\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SNMP_TIMETICKS\",\tASN_TIMETICKS,\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SNMP_UINTEGER\",\t\tASN_UINTEGER,\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SNMP_INTEGER\",\t\tASN_INTEGER,\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SNMP_COUNTER64\",\tASN_COUNTER64,\tCONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_SNMP_CLASS_CONST_LONG(\"VERSION_1\",\t\t\tSNMP_VERSION_1);\n\tREGISTER_SNMP_CLASS_CONST_LONG(\"VERSION_2c\",\t\t\tSNMP_VERSION_2c);\n\tREGISTER_SNMP_CLASS_CONST_LONG(\"VERSION_2C\",\t\t\tSNMP_VERSION_2c);\n\tREGISTER_SNMP_CLASS_CONST_LONG(\"VERSION_3\",\t\t\tSNMP_VERSION_3);\n\n\tREGISTER_SNMP_CLASS_CONST_LONG(\"ERRNO_NOERROR\",\t\t\tPHP_SNMP_ERRNO_NOERROR);\n\tREGISTER_SNMP_CLASS_CONST_LONG(\"ERRNO_ANY\",\t\t\tPHP_SNMP_ERRNO_ANY);\n\tREGISTER_SNMP_CLASS_CONST_LONG(\"ERRNO_GENERIC\",\t\t\tPHP_SNMP_ERRNO_GENERIC);\n\tREGISTER_SNMP_CLASS_CONST_LONG(\"ERRNO_TIMEOUT\",\t\t\tPHP_SNMP_ERRNO_TIMEOUT);\n\tREGISTER_SNMP_CLASS_CONST_LONG(\"ERRNO_ERROR_IN_REPLY\",\t\tPHP_SNMP_ERRNO_ERROR_IN_REPLY);\n\tREGISTER_SNMP_CLASS_CONST_LONG(\"ERRNO_OID_NOT_INCREASING\",\tPHP_SNMP_ERRNO_OID_NOT_INCREASING);\n\tREGISTER_SNMP_CLASS_CONST_LONG(\"ERRNO_OID_PARSING_ERROR\",\tPHP_SNMP_ERRNO_OID_PARSING_ERROR);\n\tREGISTER_SNMP_CLASS_CONST_LONG(\"ERRNO_MULTIPLE_SET_QUERIES\",\tPHP_SNMP_ERRNO_MULTIPLE_SET_QUERIES);\n\n\t/* Register SNMPException class */\n\tINIT_CLASS_ENTRY(cex, \"SNMPException\", NULL);\n#ifdef HAVE_SPL\n\tphp_snmp_exception_ce = zend_register_internal_class_ex(&cex, spl_ce_RuntimeException, NULL TSRMLS_CC);\n#else\n\tphp_snmp_exception_ce = zend_register_internal_class_ex(&cex, zend_exception_get_default(TSRMLS_C), NULL TSRMLS_CC);\n#endif\n\n\treturn SUCCESS;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 576,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "R_API void r_core_anal_esil(RCore *core, const char *str, const char *target) {\n\tbool cfg_anal_strings = r_config_get_i (core->config, \"anal.strings\");\n\tbool emu_lazy = r_config_get_i (core->config, \"emu.lazy\");\n\tbool gp_fixed = r_config_get_i (core->config, \"anal.gpfixed\");\n\tRAnalEsil *ESIL = core->anal->esil;\n\tut64 refptr = 0LL;\n\tchar *pcname = NULL;\n\tRAnalOp op = R_EMPTY;\n\tut8 *buf = NULL;\n\tbool end_address_set = false;\n\tint iend;\n\tint minopsize = 4; // XXX this depends on asm->mininstrsize\n\tbool archIsArm = false;\n\tut64 addr = core->offset;\n\tut64 start = addr;\n\tut64 end = 0LL;\n\tut64 cur;\n\tif (esil_anal_stop || r_cons_is_breaked ()) {\n\t\t// faster ^C\n\t\treturn;\n\t}\n\n\tmycore = core;\n\tif (!strcmp (str, \"?\")) {\n\t\teprintf (\"Usage: aae[f] [len] [addr] - analyze refs in function, section or len bytes with esil\\n\");\n\t\teprintf (\"  aae $SS @ $S             - analyze the whole section\\n\");\n\t\teprintf (\"  aae $SS str.Hello @ $S   - find references for str.Hellow\\n\");\n\t\teprintf (\"  aaef                     - analyze functions discovered with esil\\n\");\n\t\treturn;\n\t}\n#define CHECKREF(x) ((refptr && (x) == refptr) || !refptr)\n\tif (target) {\n\t\tconst char *expr = r_str_trim_head_ro (target);\n\t\tif (*expr) {\n\t\t\trefptr = ntarget = r_num_math (core->num, expr);\n\t\t\tif (!refptr) {\n\t\t\t\tntarget = refptr = addr;\n\t\t\t}\n\t\t} else {\n\t\t\tntarget = UT64_MAX;\n\t\t\trefptr = 0LL;\n\t\t}\n\t} else {\n\t\tntarget = UT64_MAX;\n\t\trefptr = 0LL;\n\t}\n\tRAnalFunction *fcn = NULL;\n\tif (!strcmp (str, \"f\")) {\n\t\tfcn = r_anal_get_fcn_in (core->anal, core->offset, 0);\n\t\tif (fcn) {\n\t\t\tstart = r_anal_function_min_addr (fcn);\n\t\t\taddr = fcn->addr;\n\t\t\tend = r_anal_function_max_addr (fcn);\n\t\t\tend_address_set = true;\n\t\t}\n\t}\n\n\tif (!end_address_set) {\n\t\tif (str[0] == ' ') {\n\t\t\tend = addr + r_num_math (core->num, str + 1);\n\t\t} else {\n\t\t\tRIOMap *map = r_io_map_get_at (core->io, addr);\n\t\t\tif (map) {\n\t\t\t\tend = r_io_map_end (map);\n\t\t\t} else {\n\t\t\t\tend = addr + core->blocksize;\n\t\t\t}\n\t\t}\n\t}\n\n\tiend = end - start;\n\tif (iend < 0) {\n\t\treturn;\n\t}\n\tif (iend > MAX_SCAN_SIZE) {\n\t\teprintf (\"Warning: Not going to analyze 0x%08\"PFMT64x\" bytes.\\n\", (ut64)iend);\n\t\treturn;\n\t}\n\tbuf = malloc ((size_t)iend + 2);\n\tif (!buf) {\n\t\tperror (\"malloc\");\n\t\treturn;\n\t}\n\tesilbreak_last_read = UT64_MAX;\n\tr_io_read_at (core->io, start, buf, iend + 1);\n\tif (!ESIL) {\n\t\tr_core_cmd0 (core, \"aei\");\n\t\tESIL = core->anal->esil;\n\t\tif (!ESIL) {\n\t\t\teprintf (\"ESIL not initialized\\n\");\n\t\t\treturn;\n\t\t}\n\t\tr_core_cmd0 (core, \"aeim\");\n\t\tESIL = core->anal->esil;\n\t}\n\tconst char *kspname = r_reg_get_name (core->anal->reg, R_REG_NAME_SP);\n\tif (R_STR_ISEMPTY (kspname)) {\n\t\teprintf (\"Error: No =SP defined in the reg profile.\\n\");\n\t\treturn;\n\t}\n\tchar *spname = strdup (kspname);\n\tEsilBreakCtx ctx = {\n\t\t&op,\n\t\tfcn,\n\t\tspname,\n\t\tr_reg_getv (core->anal->reg, spname)\n\t};\n\tESIL->cb.hook_reg_write = &esilbreak_reg_write;\n\t//this is necessary for the hook to read the id of analop\n\tESIL->user = &ctx;\n\tESIL->cb.hook_mem_read = &esilbreak_mem_read;\n\tESIL->cb.hook_mem_write = &esilbreak_mem_write;\n\n\tif (fcn && fcn->reg_save_area) {\n\t\tr_reg_setv (core->anal->reg, ctx.spname, ctx.initial_sp - fcn->reg_save_area);\n\t}\n\t//eprintf (\"Analyzing ESIL refs from 0x%\"PFMT64x\" - 0x%\"PFMT64x\"\\n\", addr, end);\n\t// TODO: backup/restore register state before/after analysis\n\tconst char *kpcname = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);\n\tif (!kpcname || !*kpcname) {\n\t\teprintf (\"Cannot find program counter register in the current profile.\\n\");\n\t\treturn;\n\t}\n\tpcname = strdup (kpcname);\n\tesil_anal_stop = false;\n\tr_cons_break_push (cccb, core);\n\n\tint arch = -1;\n\tif (!strcmp (core->anal->cur->arch, \"arm\")) {\n\t\tswitch (core->anal->cur->bits) {\n\t\tcase 64: arch = R2_ARCH_ARM64; break;\n\t\tcase 32: arch = R2_ARCH_ARM32; break;\n\t\tcase 16: arch = R2_ARCH_THUMB; break;\n\t\t}\n\t\tarchIsArm = true;\n\t}\n\n\tut64 gp = r_config_get_i (core->config, \"anal.gp\");\n\tconst char *gp_reg = NULL;\n\tif (!strcmp (core->anal->cur->arch, \"mips\")) {\n\t\tgp_reg = \"gp\";\n\t\tarch = R2_ARCH_MIPS;\n\t}\n\n\tconst char *sn = r_reg_get_name (core->anal->reg, R_REG_NAME_SN);\n\tif (!sn) {\n\t\teprintf (\"Warning: No SN reg alias for current architecture.\\n\");\n\t}\n\tr_reg_arena_push (core->anal->reg);\n\n\tIterCtx ictx = { start, end, fcn, NULL };\n\tsize_t i = addr - start;\n\tsize_t i_old = 0;\n\tdo {\n\t\tif (esil_anal_stop || r_cons_is_breaked ()) {\n\t\t\tbreak;\n\t\t}\n\t\tcur = start + i;\n\t\tif (!r_io_is_valid_offset (core->io, cur, 0)) {\n\t\t\tbreak;\n\t\t}\n#if 0\n\t\t// disabled because it causes some tests to fail\n\t\t{\n\t\t\tRPVector *list = r_meta_get_all_in (core->anal, cur, R_META_TYPE_ANY);\n\t\t\tvoid **it;\n\t\t\tr_pvector_foreach (list, it) {\n\t\t\t\tRIntervalNode *node = *it;\n\t\t\t\tRAnalMetaItem *meta = node->data;\n\t\t\t\tswitch (meta->type) {\n\t\t\t\tcase R_META_TYPE_DATA:\n\t\t\t\tcase R_META_TYPE_STRING:\n\t\t\t\tcase R_META_TYPE_FORMAT:\n#if 0\n\t\t\t\t\t{\n\t\t\t\t\t\tint msz = r_meta_get_size (core->anal, meta->type);\n\t\t\t\t\t\ti += (msz > 0)? msz: minopsize;\n\t\t\t\t\t}\n\t\t\t\t\tr_pvector_free (list);\n\t\t\t\t\tgoto loopback;\n#elif 0\n\t\t\t\t\t{\n\t\t\t\t\t\tint msz = r_meta_get_size (core->anal, meta->type);\n\t\t\t\t\t\ti += (msz > 0)? msz: minopsize;\n\t\t\t\t\t\ti--;\n\t\t\t\t\t}\n#else\n\t\t\t\t\ti += 4;\n\t\t\t\t\tgoto repeat;\n#endif\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_pvector_free (list);\n\t\t}\n#endif\n\n\t\t/* realign address if needed */\n\t\tr_core_seek_arch_bits (core, cur);\n\t\tint opalign = core->anal->pcalign;\n\t\tif (opalign > 0) {\n\t\t\tcur -= (cur % opalign);\n\t\t}\n\n\t\tr_anal_op_fini (&op);\n\t\tr_asm_set_pc (core->rasm, cur);\n\t\ti_old = i;\n\t\tif (i > iend) {\n\t\t\tgoto repeat;\n\t\t}\n\t\tif (!r_anal_op (core->anal, &op, cur, buf + i, iend - i, R_ANAL_OP_MASK_ESIL | R_ANAL_OP_MASK_VAL | R_ANAL_OP_MASK_HINT)) {\n\t\t\ti += minopsize - 1; //   XXX dupe in op.size below\n\t\t}\n\t\tif (op.type == R_ANAL_OP_TYPE_ILL || op.type == R_ANAL_OP_TYPE_UNK) {\n\t\t\t// i += 2\n\t\t\tr_anal_op_fini (&op);\n\t\t\tgoto repeat;\n\t\t}\n\t\t//we need to check again i because buf+i may goes beyond its boundaries\n\t\t//because of i+= minopsize - 1\n\t\tif (op.size < 1) {\n\t\t\ti += minopsize - 1;\n\t\t\tgoto repeat;\n\t\t}\n\t\tif (emu_lazy) {\n\t\t\tif (op.type & R_ANAL_OP_TYPE_REP) {\n\t\t\t\ti += op.size - 1;\n\t\t\t\tgoto repeat;\n\t\t\t}\n\t\t\tswitch (op.type & R_ANAL_OP_TYPE_MASK) {\n\t\t\tcase R_ANAL_OP_TYPE_JMP:\n\t\t\tcase R_ANAL_OP_TYPE_CJMP:\n\t\t\tcase R_ANAL_OP_TYPE_CALL:\n\t\t\tcase R_ANAL_OP_TYPE_RET:\n\t\t\tcase R_ANAL_OP_TYPE_ILL:\n\t\t\tcase R_ANAL_OP_TYPE_NOP:\n\t\t\tcase R_ANAL_OP_TYPE_UJMP:\n\t\t\tcase R_ANAL_OP_TYPE_IO:\n\t\t\tcase R_ANAL_OP_TYPE_LEAVE:\n\t\t\tcase R_ANAL_OP_TYPE_CRYPTO:\n\t\t\tcase R_ANAL_OP_TYPE_CPL:\n\t\t\tcase R_ANAL_OP_TYPE_SYNC:\n\t\t\tcase R_ANAL_OP_TYPE_SWI:\n\t\t\tcase R_ANAL_OP_TYPE_CMP:\n\t\t\tcase R_ANAL_OP_TYPE_ACMP:\n\t\t\tcase R_ANAL_OP_TYPE_NULL:\n\t\t\tcase R_ANAL_OP_TYPE_CSWI:\n\t\t\tcase R_ANAL_OP_TYPE_TRAP:\n\t\t\t\ti += op.size - 1;\n\t\t\t\tgoto repeat;\n\t\t\t//  those require write support\n\t\t\tcase R_ANAL_OP_TYPE_PUSH:\n\t\t\tcase R_ANAL_OP_TYPE_POP:\n\t\t\t\ti += op.size - 1;\n\t\t\t\tgoto repeat;\n\t\t\t}\n\t\t}\n\t\tif (sn && op.type == R_ANAL_OP_TYPE_SWI) {\n\t\t\tr_strf_buffer (64);\n\t\t\tr_flag_space_set (core->flags, R_FLAGS_FS_SYSCALLS);\n\t\t\tint snv = (arch == R2_ARCH_THUMB)? op.val: (int)r_reg_getv (core->anal->reg, sn);\n\t\t\tRSyscallItem *si = r_syscall_get (core->anal->syscall, snv, -1);\n\t\t\tif (si) {\n\t\t\t//\teprintf (\"0x%08\"PFMT64x\" SYSCALL %-4d %s\\n\", cur, snv, si->name);\n\t\t\t\tr_flag_set_next (core->flags, r_strf (\"syscall.%s\", si->name), cur, 1);\n\t\t\t} else {\n\t\t\t\t//todo were doing less filtering up top because we can't match against 80 on all platforms\n\t\t\t\t// might get too many of this path now..\n\t\t\t//\teprintf (\"0x%08\"PFMT64x\" SYSCALL %d\\n\", cur, snv);\n\t\t\t\tr_flag_set_next (core->flags, r_strf (\"syscall.%d\", snv), cur, 1);\n\t\t\t}\n\t\t\tr_flag_space_set (core->flags, NULL);\n\t\t\tr_syscall_item_free (si);\n\t\t}\n\t\tconst char *esilstr = R_STRBUF_SAFEGET (&op.esil);\n\t\ti += op.size - 1;\n\t\tif (R_STR_ISEMPTY (esilstr)) {\n\t\t\tgoto repeat;\n\t\t}\n\t\tr_anal_esil_set_pc (ESIL, cur);\n\t\tr_reg_setv (core->anal->reg, pcname, cur + op.size);\n\t\tif (gp_fixed && gp_reg) {\n\t\t\tr_reg_setv (core->anal->reg, gp_reg, gp);\n\t\t}\n\t\t(void)r_anal_esil_parse (ESIL, esilstr);\n\t\t// looks like ^C is handled by esil_parse !!!!\n\t\t//r_anal_esil_dumpstack (ESIL);\n\t\t//r_anal_esil_stack_free (ESIL);\n\t\tswitch (op.type) {\n\t\tcase R_ANAL_OP_TYPE_LEA:\n\t\t\t// arm64\n\t\t\tif (core->anal->cur && arch == R2_ARCH_ARM64) {\n\t\t\t\tif (CHECKREF (ESIL->cur)) {\n\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, ESIL->cur, R_ANAL_REF_TYPE_STRING);\n\t\t\t\t}\n\t\t\t} else if ((target && op.ptr == ntarget) || !target) {\n\t\t\t\tif (CHECKREF (ESIL->cur)) {\n\t\t\t\t\tif (op.ptr && r_io_is_valid_offset (core->io, op.ptr, !core->anal->opt.noncode)) {\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, op.ptr, R_ANAL_REF_TYPE_STRING);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, ESIL->cur, R_ANAL_REF_TYPE_STRING);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (cfg_anal_strings) {\n\t\t\t\tadd_string_ref (core, op.addr, op.ptr);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_ADD:\n\t\t\t/* TODO: test if this is valid for other archs too */\n\t\t\tif (core->anal->cur && archIsArm) {\n\t\t\t\t/* This code is known to work on Thumb, ARM and ARM64 */\n\t\t\t\tut64 dst = ESIL->cur;\n\t\t\t\tif ((target && dst == ntarget) || !target) {\n\t\t\t\t\tif (CHECKREF (dst)) {\n\t\t\t\t\t\tint type = core_type_by_addr (core, dst); // R_ANAL_REF_TYPE_DATA;\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, type);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (cfg_anal_strings) {\n\t\t\t\t\tadd_string_ref (core, op.addr, dst);\n\t\t\t\t}\n\t\t\t} else if ((core->anal->bits == 32 && core->anal->cur && arch == R2_ARCH_MIPS)) {\n\t\t\t\tut64 dst = ESIL->cur;\n\t\t\t\tif (!op.src[0] || !op.src[0]->reg || !op.src[0]->reg->name) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!strcmp (op.src[0]->reg->name, \"sp\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!strcmp (op.src[0]->reg->name, \"zero\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif ((target && dst == ntarget) || !target) {\n\t\t\t\t\tif (dst > 0xffff && op.src[1] && (dst & 0xffff) == (op.src[1]->imm & 0xffff) && myvalid (mycore->io, dst)) {\n\t\t\t\t\t\tRFlagItem *f;\n\t\t\t\t\t\tchar *str;\n\t\t\t\t\t\tif (CHECKREF (dst) || CHECKREF (cur)) {\n\t\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_DATA);\n\t\t\t\t\t\t\tif (cfg_anal_strings) {\n\t\t\t\t\t\t\t\tadd_string_ref (core, op.addr, dst);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ((f = r_core_flag_get_by_spaces (core->flags, dst))) {\n\t\t\t\t\t\t\t\tr_meta_set_string (core->anal, R_META_TYPE_COMMENT, cur, f->name);\n\t\t\t\t\t\t\t} else if ((str = is_string_at (mycore, dst, NULL))) {\n\t\t\t\t\t\t\t\tchar *str2 = r_str_newf (\"esilref: '%s'\", str);\n\t\t\t\t\t\t\t\t// HACK avoid format string inside string used later as format\n\t\t\t\t\t\t\t\t// string crashes disasm inside agf under some conditions.\n\t\t\t\t\t\t\t\t// https://github.com/radareorg/radare2/issues/6937\n\t\t\t\t\t\t\t\tr_str_replace_char (str2, '%', '&');\n\t\t\t\t\t\t\t\tr_meta_set_string (core->anal, R_META_TYPE_COMMENT, cur, str2);\n\t\t\t\t\t\t\t\tfree (str2);\n\t\t\t\t\t\t\t\tfree (str);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_LOAD:\n\t\t\t{\n\t\t\t\tut64 dst = esilbreak_last_read;\n\t\t\t\tif (dst != UT64_MAX && CHECKREF (dst)) {\n\t\t\t\t\tif (myvalid (mycore->io, dst)) {\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_DATA);\n\t\t\t\t\t\tif (cfg_anal_strings) {\n\t\t\t\t\t\t\tadd_string_ref (core, op.addr, dst);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdst = esilbreak_last_data;\n\t\t\t\tif (dst != UT64_MAX && CHECKREF (dst)) {\n\t\t\t\t\tif (myvalid (mycore->io, dst)) {\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_DATA);\n\t\t\t\t\t\tif (cfg_anal_strings) {\n\t\t\t\t\t\t\tadd_string_ref (core, op.addr, dst);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_JMP:\n\t\t\t{\n\t\t\t\tut64 dst = op.jump;\n\t\t\t\tif (CHECKREF (dst)) {\n\t\t\t\t\tif (myvalid (core->io, dst)) {\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_CODE);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_CALL:\n\t\t\t{\n\t\t\t\tut64 dst = op.jump;\n\t\t\t\tif (CHECKREF (dst)) {\n\t\t\t\t\tif (myvalid (core->io, dst)) {\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_CALL);\n\t\t\t\t\t}\n\t\t\t\t\tESIL->old = cur + op.size;\n\t\t\t\t\tgetpcfromstack (core, ESIL);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_UJMP:\n\t\tcase R_ANAL_OP_TYPE_UCALL:\n\t\tcase R_ANAL_OP_TYPE_ICALL:\n\t\tcase R_ANAL_OP_TYPE_RCALL:\n\t\tcase R_ANAL_OP_TYPE_IRCALL:\n\t\tcase R_ANAL_OP_TYPE_MJMP:\n\t\t\t{\n\t\t\t\tut64 dst = core->anal->esil->jump_target;\n\t\t\t\tif (dst == 0 || dst == UT64_MAX) {\n\t\t\t\t\tdst = r_reg_getv (core->anal->reg, pcname);\n\t\t\t\t}\n\t\t\t\tif (CHECKREF (dst)) {\n\t\t\t\t\tif (myvalid (core->io, dst)) {\n\t\t\t\t\t\tRAnalRefType ref =\n\t\t\t\t\t\t\t(op.type & R_ANAL_OP_TYPE_MASK) == R_ANAL_OP_TYPE_UCALL\n\t\t\t\t\t\t\t? R_ANAL_REF_TYPE_CALL\n\t\t\t\t\t\t\t: R_ANAL_REF_TYPE_CODE;\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, ref);\n\t\t\t\t\t\tr_core_anal_fcn (core, dst, UT64_MAX, R_ANAL_REF_TYPE_NULL, 1);\n// analyze function here\n#if 0\n\t\t\t\t\t\tif (op.type == R_ANAL_OP_TYPE_UCALL || op.type == R_ANAL_OP_TYPE_RCALL) {\n\t\t\t\t\t\t\teprintf (\"0x%08\"PFMT64x\"  RCALL TO %llx\\n\", cur, dst);\n\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tr_anal_esil_stack_free (ESIL);\nrepeat:\n\t\tif (!r_anal_get_block_at (core->anal, cur)) {\n\t\t\tsize_t fcn_i;\n\t\t\tfor (fcn_i = i_old + 1; fcn_i <= i; fcn_i++) {\n\t\t\t\tif (r_anal_get_function_at (core->anal, start + fcn_i)) {\n\t\t\t\t\ti = fcn_i - 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (i >= iend) {\n\t\t\tbreak;\n\t\t}\n\t} while (get_next_i (&ictx, &i));\n\tfree (pcname);\n\tfree (spname);\n\tr_list_free (ictx.bbl);\n\tr_list_free (ictx.path);\n\tr_list_free (ictx.switch_path);\n\tfree (buf);\n\tESIL->cb.hook_mem_read = NULL;\n\tESIL->cb.hook_mem_write = NULL;\n\tESIL->cb.hook_reg_write = NULL;\n\tESIL->user = NULL;\n\tr_anal_op_fini (&op);\n\tr_cons_break_pop ();\n\t// restore register\n\tr_reg_arena_pop (core->anal->reg);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 578,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "getcmdline_int(\n    int\t\tfirstc,\n    long\tcount UNUSED,\t// only used for incremental search\n    int\t\tindent,\t\t// indent for inside conditionals\n    int\t\tclear_ccline)\t// clear ccline first\n{\n    static int\tdepth = 0;\t    // call depth\n    int\t\tc;\n    int\t\ti;\n    int\t\tj;\n    int\t\tgotesc = FALSE;\t\t// TRUE when <ESC> just typed\n    int\t\tdo_abbr;\t\t// when TRUE check for abbr.\n    char_u\t*lookfor = NULL;\t// string to match\n    int\t\thiscnt;\t\t\t// current history line in use\n    int\t\thistype;\t\t// history type to be used\n#ifdef FEAT_SEARCH_EXTRA\n    incsearch_state_T\tis_state;\n#endif\n    int\t\tdid_wild_list = FALSE;\t// did wild_list() recently\n    int\t\twim_index = 0;\t\t// index in wim_flags[]\n    int\t\tres;\n    int\t\tsave_msg_scroll = msg_scroll;\n    int\t\tsave_State = State;\t// remember State when called\n    int\t\tsome_key_typed = FALSE;\t// one of the keys was typed\n    // mouse drag and release events are ignored, unless they are\n    // preceded with a mouse down event\n    int\t\tignore_drag_release = TRUE;\n#ifdef FEAT_EVAL\n    int\t\tbreak_ctrl_c = FALSE;\n#endif\n    expand_T\txpc;\n    long\t*b_im_ptr = NULL;\n    buf_T\t*b_im_ptr_buf = NULL;\t// buffer where b_im_ptr is valid\n    cmdline_info_T save_ccline;\n    int\t\tdid_save_ccline = FALSE;\n    int\t\tcmdline_type;\n    int\t\twild_type;\n\n    // one recursion level deeper\n    ++depth;\n\n    if (ccline.cmdbuff != NULL)\n    {\n\t// Being called recursively.  Since ccline is global, we need to save\n\t// the current buffer and restore it when returning.\n\tsave_cmdline(&save_ccline);\n\tdid_save_ccline = TRUE;\n    }\n    if (clear_ccline)\n\tCLEAR_FIELD(ccline);\n\n#ifdef FEAT_EVAL\n    if (firstc == -1)\n    {\n\tfirstc = NUL;\n\tbreak_ctrl_c = TRUE;\n    }\n#endif\n#ifdef FEAT_RIGHTLEFT\n    // start without Hebrew mapping for a command line\n    if (firstc == ':' || firstc == '=' || firstc == '>')\n\tcmd_hkmap = 0;\n#endif\n\n#ifdef FEAT_SEARCH_EXTRA\n    init_incsearch_state(&is_state);\n#endif\n\n    if (init_ccline(firstc, indent) != OK)\n\tgoto theend;\t// out of memory\n\n    if (depth == 50)\n    {\n\t// Somehow got into a loop recursively calling getcmdline(), bail out.\n\temsg(_(e_command_too_recursive));\n\tgoto theend;\n    }\n\n    ExpandInit(&xpc);\n    ccline.xpc = &xpc;\n\n#ifdef FEAT_RIGHTLEFT\n    if (curwin->w_p_rl && *curwin->w_p_rlc == 's'\n\t\t\t\t\t  && (firstc == '/' || firstc == '?'))\n\tcmdmsg_rl = TRUE;\n    else\n\tcmdmsg_rl = FALSE;\n#endif\n\n    redir_off = TRUE;\t\t// don't redirect the typed command\n    if (!cmd_silent)\n    {\n\ti = msg_scrolled;\n\tmsg_scrolled = 0;\t\t// avoid wait_return() message\n\tgotocmdline(TRUE);\n\tmsg_scrolled += i;\n\tredrawcmdprompt();\t\t// draw prompt or indent\n\tset_cmdspos();\n    }\n    xpc.xp_context = EXPAND_NOTHING;\n    xpc.xp_backslash = XP_BS_NONE;\n#ifndef BACKSLASH_IN_FILENAME\n    xpc.xp_shell = FALSE;\n#endif\n\n#if defined(FEAT_EVAL)\n    if (ccline.input_fn)\n    {\n\txpc.xp_context = ccline.xp_context;\n\txpc.xp_pattern = ccline.cmdbuff;\n\txpc.xp_arg = ccline.xp_arg;\n    }\n#endif\n\n    /*\n     * Avoid scrolling when called by a recursive do_cmdline(), e.g. when\n     * doing \":@0\" when register 0 doesn't contain a CR.\n     */\n    msg_scroll = FALSE;\n\n    State = MODE_CMDLINE;\n\n    if (firstc == '/' || firstc == '?' || firstc == '@')\n    {\n\t// Use \":lmap\" mappings for search pattern and input().\n\tif (curbuf->b_p_imsearch == B_IMODE_USE_INSERT)\n\t    b_im_ptr = &curbuf->b_p_iminsert;\n\telse\n\t    b_im_ptr = &curbuf->b_p_imsearch;\n\tb_im_ptr_buf = curbuf;\n\tif (*b_im_ptr == B_IMODE_LMAP)\n\t    State |= MODE_LANGMAP;\n#ifdef HAVE_INPUT_METHOD\n\tim_set_active(*b_im_ptr == B_IMODE_IM);\n#endif\n    }\n#ifdef HAVE_INPUT_METHOD\n    else if (p_imcmdline)\n\tim_set_active(TRUE);\n#endif\n\n    setmouse();\n#ifdef CURSOR_SHAPE\n    ui_cursor_shape();\t\t// may show different cursor shape\n#endif\n\n    // When inside an autocommand for writing \"exiting\" may be set and\n    // terminal mode set to cooked.  Need to set raw mode here then.\n    settmode(TMODE_RAW);\n\n    // Trigger CmdlineEnter autocommands.\n    cmdline_type = firstc == NUL ? '-' : firstc;\n    trigger_cmd_autocmd(cmdline_type, EVENT_CMDLINEENTER);\n#ifdef FEAT_EVAL\n    if (!debug_mode)\n\tmay_trigger_modechanged();\n#endif\n\n    init_history();\n    hiscnt = get_hislen();\t// set hiscnt to impossible history value\n    histype = hist_char2type(firstc);\n\n#ifdef FEAT_DIGRAPHS\n    do_digraph(-1);\t\t// init digraph typeahead\n#endif\n\n    // If something above caused an error, reset the flags, we do want to type\n    // and execute commands. Display may be messed up a bit.\n    if (did_emsg)\n\tredrawcmd();\n\n#ifdef FEAT_STL_OPT\n    // Redraw the statusline in case it uses the current mode using the mode()\n    // function.\n    if (!cmd_silent && msg_scrolled == 0)\n    {\n\tint\tfound_one = FALSE;\n\twin_T\t*wp;\n\n\tFOR_ALL_WINDOWS(wp)\n\t    if (*p_stl != NUL || *wp->w_p_stl != NUL)\n\t    {\n\t\twp->w_redr_status = TRUE;\n\t\tfound_one = TRUE;\n\t    }\n\n\tif (*p_tal != NUL)\n\t{\n\t    redraw_tabline = TRUE;\n\t    found_one = TRUE;\n\t}\n\n\tif (found_one)\n\t    redraw_statuslines();\n    }\n#endif\n\n    did_emsg = FALSE;\n    got_int = FALSE;\n\n    /*\n     * Collect the command string, handling editing keys.\n     */\n    for (;;)\n    {\n\tint trigger_cmdlinechanged = TRUE;\n\tint end_wildmenu;\n\n\tredir_off = TRUE;\t// Don't redirect the typed command.\n\t\t\t\t// Repeated, because a \":redir\" inside\n\t\t\t\t// completion may switch it on.\n#ifdef USE_ON_FLY_SCROLL\n\tdont_scroll = FALSE;\t// allow scrolling here\n#endif\n\tquit_more = FALSE;\t// reset after CTRL-D which had a more-prompt\n\n\tdid_emsg = FALSE;\t// There can't really be a reason why an error\n\t\t\t\t// that occurs while typing a command should\n\t\t\t\t// cause the command not to be executed.\n\n\t// Trigger SafeState if nothing is pending.\n\tmay_trigger_safestate(xpc.xp_numfiles <= 0);\n\n\t// Get a character.  Ignore K_IGNORE and K_NOP, they should not do\n\t// anything, such as stop completion.\n\tdo\n\t{\n\t    cursorcmd();\t\t// set the cursor on the right spot\n\t    c = safe_vgetc();\n\t} while (c == K_IGNORE || c == K_NOP);\n\n\tif (c == K_COMMAND || c == K_SCRIPT_COMMAND)\n\t{\n\t    int\t    clen = ccline.cmdlen;\n\n\t    if (do_cmdkey_command(c, DOCMD_NOWAIT) == OK)\n\t    {\n\t\tif (clen == ccline.cmdlen)\n\t\t    trigger_cmdlinechanged = FALSE;\n\t\tgoto cmdline_changed;\n\t    }\n\t}\n\n\tif (KeyTyped)\n\t{\n\t    some_key_typed = TRUE;\n#ifdef FEAT_RIGHTLEFT\n\t    if (cmd_hkmap)\n\t\tc = hkmap(c);\n\t    if (cmdmsg_rl && !KeyStuffed)\n\t    {\n\t\t// Invert horizontal movements and operations.  Only when\n\t\t// typed by the user directly, not when the result of a\n\t\t// mapping.\n\t\tswitch (c)\n\t\t{\n\t\t    case K_RIGHT:   c = K_LEFT; break;\n\t\t    case K_S_RIGHT: c = K_S_LEFT; break;\n\t\t    case K_C_RIGHT: c = K_C_LEFT; break;\n\t\t    case K_LEFT:    c = K_RIGHT; break;\n\t\t    case K_S_LEFT:  c = K_S_RIGHT; break;\n\t\t    case K_C_LEFT:  c = K_C_RIGHT; break;\n\t\t}\n\t    }\n#endif\n\t}\n\n\t/*\n\t * Ignore got_int when CTRL-C was typed here.\n\t * Don't ignore it in :global, we really need to break then, e.g., for\n\t * \":g/pat/normal /pat\" (without the <CR>).\n\t * Don't ignore it for the input() function.\n\t */\n\tif ((c == Ctrl_C\n#ifdef UNIX\n\t\t|| c == intr_char\n#endif\n\t\t\t\t)\n#if defined(FEAT_EVAL) || defined(FEAT_CRYPT)\n\t\t&& firstc != '@'\n#endif\n#ifdef FEAT_EVAL\n\t\t// do clear got_int in Ex mode to avoid infinite Ctrl-C loop\n\t\t&& (!break_ctrl_c || exmode_active)\n#endif\n\t\t&& !global_busy)\n\t    got_int = FALSE;\n\n\t// free old command line when finished moving around in the history\n\t// list\n\tif (lookfor != NULL\n\t\t&& c != K_S_DOWN && c != K_S_UP\n\t\t&& c != K_DOWN && c != K_UP\n\t\t&& c != K_PAGEDOWN && c != K_PAGEUP\n\t\t&& c != K_KPAGEDOWN && c != K_KPAGEUP\n\t\t&& c != K_LEFT && c != K_RIGHT\n\t\t&& (xpc.xp_numfiles > 0 || (c != Ctrl_P && c != Ctrl_N)))\n\t    VIM_CLEAR(lookfor);\n\n\t/*\n\t * When there are matching completions to select <S-Tab> works like\n\t * CTRL-P (unless 'wc' is <S-Tab>).\n\t */\n\tif (c != p_wc && c == K_S_TAB && xpc.xp_numfiles > 0)\n\t    c = Ctrl_P;\n\n\tif (p_wmnu)\n\t    c = wildmenu_translate_key(&ccline, c, &xpc, did_wild_list);\n\n\tif (cmdline_pum_active())\n\t{\n\t    // Ctrl-Y: Accept the current selection and close the popup menu.\n\t    // Ctrl-E: cancel the cmdline popup menu and return the original\n\t    // text.\n\t    if (c == Ctrl_E || c == Ctrl_Y)\n\t    {\n\t\twild_type = (c == Ctrl_E) ? WILD_CANCEL : WILD_APPLY;\n\t\tif (nextwild(&xpc, wild_type, WILD_NO_BEEP,\n\t\t\t\t\t\t\tfirstc != '@') == FAIL)\n\t\t    break;\n\t\tc = Ctrl_E;\n\t    }\n\t}\n\n\t// The wildmenu is cleared if the pressed key is not used for\n\t// navigating the wild menu (i.e. the key is not 'wildchar' or\n\t// 'wildcharm' or Ctrl-N or Ctrl-P or Ctrl-A or Ctrl-L).\n\t// If the popup menu is displayed, then PageDown and PageUp keys are\n\t// also used to navigate the menu.\n\tend_wildmenu = (!(c == p_wc && KeyTyped) && c != p_wcm\n\t\t&& c != Ctrl_N && c != Ctrl_P && c != Ctrl_A && c != Ctrl_L);\n\tend_wildmenu = end_wildmenu && (!cmdline_pum_active() ||\n\t\t\t    (c != K_PAGEDOWN && c != K_PAGEUP\n\t\t\t     && c != K_KPAGEDOWN && c != K_KPAGEUP));\n\n\t// free expanded names when finished walking through matches\n\tif (end_wildmenu)\n\t{\n\t    if (cmdline_pum_active())\n\t\tcmdline_pum_remove();\n\t    if (xpc.xp_numfiles != -1)\n\t\t(void)ExpandOne(&xpc, NULL, NULL, 0, WILD_FREE);\n\t    did_wild_list = FALSE;\n\t    if (!p_wmnu || (c != K_UP && c != K_DOWN))\n\t\txpc.xp_context = EXPAND_NOTHING;\n\t    wim_index = 0;\n\t    wildmenu_cleanup(&ccline);\n\t}\n\n\tif (p_wmnu)\n\t    c = wildmenu_process_key(&ccline, c, &xpc);\n\n\t// CTRL-\\ CTRL-N goes to Normal mode, CTRL-\\ CTRL-G goes to Insert\n\t// mode when 'insertmode' is set, CTRL-\\ e prompts for an expression.\n\tif (c == Ctrl_BSL)\n\t{\n\t    res = cmdline_handle_backslash_key(c, &gotesc);\n\t    if (res == CMDLINE_CHANGED)\n\t\tgoto cmdline_changed;\n\t    else if (res == CMDLINE_NOT_CHANGED)\n\t\tgoto cmdline_not_changed;\n\t    else if (res == GOTO_NORMAL_MODE)\n\t\tgoto returncmd;\t\t// back to cmd mode\n\t    c = Ctrl_BSL;\t\t// backslash key not processed by\n\t\t\t\t\t// cmdline_handle_backslash_key()\n\t}\n\n#ifdef FEAT_CMDWIN\n\tif (c == cedit_key || c == K_CMDWIN)\n\t{\n\t    // TODO: why is ex_normal_busy checked here?\n\t    if ((c == K_CMDWIN || ex_normal_busy == 0) && got_int == FALSE)\n\t    {\n\t\t/*\n\t\t * Open a window to edit the command line (and history).\n\t\t */\n\t\tc = open_cmdwin();\n\t\tsome_key_typed = TRUE;\n\t    }\n\t}\n# ifdef FEAT_DIGRAPHS\n\telse\n# endif\n#endif\n#ifdef FEAT_DIGRAPHS\n\t    c = do_digraph(c);\n#endif\n\n\tif (c == '\\n' || c == '\\r' || c == K_KENTER || (c == ESC\n\t\t\t&& (!KeyTyped || vim_strchr(p_cpo, CPO_ESC) != NULL)))\n\t{\n\t    // In Ex mode a backslash escapes a newline.\n\t    if (exmode_active\n\t\t    && c != ESC\n\t\t    && ccline.cmdpos == ccline.cmdlen\n\t\t    && ccline.cmdpos > 0\n\t\t    && ccline.cmdbuff[ccline.cmdpos - 1] == '\\\\')\n\t    {\n\t\tif (c == K_KENTER)\n\t\t    c = '\\n';\n\t    }\n\t    else\n\t    {\n\t\tgotesc = FALSE;\t// Might have typed ESC previously, don't\n\t\t\t\t// truncate the cmdline now.\n\t\tif (ccheck_abbr(c + ABBR_OFF))\n\t\t    goto cmdline_changed;\n\t\tif (!cmd_silent)\n\t\t{\n\t\t    windgoto(msg_row, 0);\n\t\t    out_flush();\n\t\t}\n\t\tbreak;\n\t    }\n\t}\n\n\t// Completion for 'wildchar' or 'wildcharm' key.\n\tif ((c == p_wc && !gotesc && KeyTyped) || c == p_wcm)\n\t{\n\t    res = cmdline_wildchar_complete(c, firstc != '@', &did_wild_list,\n\t\t    &wim_index, &xpc, &gotesc);\n\t    if (res == CMDLINE_CHANGED)\n\t\tgoto cmdline_changed;\n\t}\n\n\tgotesc = FALSE;\n\n\t// <S-Tab> goes to last match, in a clumsy way\n\tif (c == K_S_TAB && KeyTyped)\n\t{\n\t    if (nextwild(&xpc, WILD_EXPAND_KEEP, 0, firstc != '@') == OK)\n\t    {\n\t\tif (xpc.xp_numfiles > 1\n\t\t    && ((!did_wild_list && (wim_flags[wim_index] & WIM_LIST))\n\t\t\t    || p_wmnu))\n\t\t{\n\t\t    // Trigger the popup menu when wildoptions=pum\n\t\t    showmatches(&xpc, p_wmnu\n\t\t\t    && ((wim_flags[wim_index] & WIM_LIST) == 0));\n\t\t}\n\t\tif (nextwild(&xpc, WILD_PREV, 0, firstc != '@') == OK\n\t\t\t&& nextwild(&xpc, WILD_PREV, 0, firstc != '@') == OK)\n\t\t    goto cmdline_changed;\n\t    }\n\t}\n\n\tif (c == NUL || c == K_ZERO)\t    // NUL is stored as NL\n\t    c = NL;\n\n\tdo_abbr = TRUE;\t\t// default: check for abbreviation\n\n\t/*\n\t * Big switch for a typed command line character.\n\t */\n\tswitch (c)\n\t{\n\tcase K_BS:\n\tcase Ctrl_H:\n\tcase K_DEL:\n\tcase K_KDEL:\n\tcase Ctrl_W:\n\t    res = cmdline_erase_chars(c, indent\n#ifdef FEAT_SEARCH_EXTRA\n\t\t    , &is_state\n#endif\n\t\t    );\n\t    if (res == CMDLINE_NOT_CHANGED)\n\t\tgoto cmdline_not_changed;\n\t    else if (res == GOTO_NORMAL_MODE)\n\t\tgoto returncmd;\t\t// back to cmd mode\n\t    goto cmdline_changed;\n\n\tcase K_INS:\n\tcase K_KINS:\n\t\tccline.overstrike = !ccline.overstrike;\n#ifdef CURSOR_SHAPE\n\t\tui_cursor_shape();\t// may show different cursor shape\n#endif\n\t\tgoto cmdline_not_changed;\n\n\tcase Ctrl_HAT:\n\t\tcmdline_toggle_langmap(\n\t\t\t\t    buf_valid(b_im_ptr_buf) ? b_im_ptr : NULL);\n\t\tgoto cmdline_not_changed;\n\n//\tcase '@':   only in very old vi\n\tcase Ctrl_U:\n\t\t// delete all characters left of the cursor\n\t\tj = ccline.cmdpos;\n\t\tccline.cmdlen -= j;\n\t\ti = ccline.cmdpos = 0;\n\t\twhile (i < ccline.cmdlen)\n\t\t    ccline.cmdbuff[i++] = ccline.cmdbuff[j++];\n\t\t// Truncate at the end, required for multi-byte chars.\n\t\tccline.cmdbuff[ccline.cmdlen] = NUL;\n#ifdef FEAT_SEARCH_EXTRA\n\t\tif (ccline.cmdlen == 0)\n\t\t    is_state.search_start = is_state.save_cursor;\n#endif\n\t\tredrawcmd();\n\t\tgoto cmdline_changed;\n\n#ifdef FEAT_CLIPBOARD\n\tcase Ctrl_Y:\n\t\t// Copy the modeless selection, if there is one.\n\t\tif (clip_star.state != SELECT_CLEARED)\n\t\t{\n\t\t    if (clip_star.state == SELECT_DONE)\n\t\t\tclip_copy_modeless_selection(TRUE);\n\t\t    goto cmdline_not_changed;\n\t\t}\n\t\tbreak;\n#endif\n\n\tcase ESC:\t// get here if p_wc != ESC or when ESC typed twice\n\tcase Ctrl_C:\n\t\t// In exmode it doesn't make sense to return.  Except when\n\t\t// \":normal\" runs out of characters.\n\t\tif (exmode_active\n\t\t\t       && (ex_normal_busy == 0 || typebuf.tb_len > 0))\n\t\t    goto cmdline_not_changed;\n\n\t\tgotesc = TRUE;\t\t// will free ccline.cmdbuff after\n\t\t\t\t\t// putting it in history\n\t\tgoto returncmd;\t\t// back to cmd mode\n\n\tcase Ctrl_R:\t\t\t// insert register\n\t\tres = cmdline_insert_reg(&gotesc);\n\t\tif (res == CMDLINE_NOT_CHANGED)\n\t\t    goto cmdline_not_changed;\n\t\telse if (res == GOTO_NORMAL_MODE)\n\t\t    goto returncmd;\n\t\tgoto cmdline_changed;\n\n\tcase Ctrl_D:\n\t\tif (showmatches(&xpc, FALSE) == EXPAND_NOTHING)\n\t\t    break;\t// Use ^D as normal char instead\n\n\t\tredrawcmd();\n\t\tcontinue;\t// don't do incremental search now\n\n\tcase K_RIGHT:\n\tcase K_S_RIGHT:\n\tcase K_C_RIGHT:\n\t\tdo\n\t\t{\n\t\t    if (ccline.cmdpos >= ccline.cmdlen)\n\t\t\tbreak;\n\t\t    i = cmdline_charsize(ccline.cmdpos);\n\t\t    if (KeyTyped && ccline.cmdspos + i >= Columns * Rows)\n\t\t\tbreak;\n\t\t    ccline.cmdspos += i;\n\t\t    if (has_mbyte)\n\t\t\tccline.cmdpos += (*mb_ptr2len)(ccline.cmdbuff\n\t\t\t\t\t\t\t     + ccline.cmdpos);\n\t\t    else\n\t\t\t++ccline.cmdpos;\n\t\t}\n\t\twhile ((c == K_S_RIGHT || c == K_C_RIGHT\n\t\t\t       || (mod_mask & (MOD_MASK_SHIFT|MOD_MASK_CTRL)))\n\t\t\t&& ccline.cmdbuff[ccline.cmdpos] != ' ');\n\t\tif (has_mbyte)\n\t\t    set_cmdspos_cursor();\n\t\tgoto cmdline_not_changed;\n\n\tcase K_LEFT:\n\tcase K_S_LEFT:\n\tcase K_C_LEFT:\n\t\tif (ccline.cmdpos == 0)\n\t\t    goto cmdline_not_changed;\n\t\tdo\n\t\t{\n\t\t    --ccline.cmdpos;\n\t\t    if (has_mbyte)\t// move to first byte of char\n\t\t\tccline.cmdpos -= (*mb_head_off)(ccline.cmdbuff,\n\t\t\t\t\t      ccline.cmdbuff + ccline.cmdpos);\n\t\t    ccline.cmdspos -= cmdline_charsize(ccline.cmdpos);\n\t\t}\n\t\twhile (ccline.cmdpos > 0\n\t\t\t&& (c == K_S_LEFT || c == K_C_LEFT\n\t\t\t       || (mod_mask & (MOD_MASK_SHIFT|MOD_MASK_CTRL)))\n\t\t\t&& ccline.cmdbuff[ccline.cmdpos - 1] != ' ');\n\t\tif (has_mbyte)\n\t\t    set_cmdspos_cursor();\n\t\tgoto cmdline_not_changed;\n\n\tcase K_IGNORE:\n\t\t// Ignore mouse event or open_cmdwin() result.\n\t\tgoto cmdline_not_changed;\n\n#ifdef FEAT_GUI_MSWIN\n\t    // On MS-Windows ignore <M-F4>, we get it when closing the window\n\t    // was cancelled.\n\tcase K_F4:\n\t    if (mod_mask == MOD_MASK_ALT)\n\t    {\n\t\tredrawcmd();\t    // somehow the cmdline is cleared\n\t\tgoto cmdline_not_changed;\n\t    }\n\t    break;\n#endif\n\n\tcase K_MIDDLEDRAG:\n\tcase K_MIDDLERELEASE:\n\t\tgoto cmdline_not_changed;\t// Ignore mouse\n\n\tcase K_MIDDLEMOUSE:\n# ifdef FEAT_GUI\n\t\t// When GUI is active, also paste when 'mouse' is empty\n\t\tif (!gui.in_use)\n# endif\n\t\t    if (!mouse_has(MOUSE_COMMAND))\n\t\t\tgoto cmdline_not_changed;   // Ignore mouse\n# ifdef FEAT_CLIPBOARD\n\t\tif (clip_star.available)\n\t\t    cmdline_paste('*', TRUE, TRUE);\n\t\telse\n# endif\n\t\t    cmdline_paste(0, TRUE, TRUE);\n\t\tredrawcmd();\n\t\tgoto cmdline_changed;\n\n# ifdef FEAT_DND\n\tcase K_DROP:\n\t\tcmdline_paste('~', TRUE, FALSE);\n\t\tredrawcmd();\n\t\tgoto cmdline_changed;\n# endif\n\n\tcase K_LEFTDRAG:\n\tcase K_LEFTRELEASE:\n\tcase K_RIGHTDRAG:\n\tcase K_RIGHTRELEASE:\n\t\t// Ignore drag and release events when the button-down wasn't\n\t\t// seen before.\n\t\tif (ignore_drag_release)\n\t\t    goto cmdline_not_changed;\n\t\t// FALLTHROUGH\n\tcase K_LEFTMOUSE:\n\tcase K_RIGHTMOUSE:\n\t\tcmdline_left_right_mouse(c, &ignore_drag_release);\n\t\tgoto cmdline_not_changed;\n\n\t// Mouse scroll wheel: ignored here\n\tcase K_MOUSEDOWN:\n\tcase K_MOUSEUP:\n\tcase K_MOUSELEFT:\n\tcase K_MOUSERIGHT:\n\t// Alternate buttons ignored here\n\tcase K_X1MOUSE:\n\tcase K_X1DRAG:\n\tcase K_X1RELEASE:\n\tcase K_X2MOUSE:\n\tcase K_X2DRAG:\n\tcase K_X2RELEASE:\n\tcase K_MOUSEMOVE:\n\t\tgoto cmdline_not_changed;\n\n#ifdef FEAT_GUI\n\tcase K_LEFTMOUSE_NM:\t// mousefocus click, ignored\n\tcase K_LEFTRELEASE_NM:\n\t\tgoto cmdline_not_changed;\n\n\tcase K_VER_SCROLLBAR:\n\t\tif (msg_scrolled == 0)\n\t\t{\n\t\t    gui_do_scroll();\n\t\t    redrawcmd();\n\t\t}\n\t\tgoto cmdline_not_changed;\n\n\tcase K_HOR_SCROLLBAR:\n\t\tif (msg_scrolled == 0)\n\t\t{\n\t\t    gui_do_horiz_scroll(scrollbar_value, FALSE);\n\t\t    redrawcmd();\n\t\t}\n\t\tgoto cmdline_not_changed;\n#endif\n#ifdef FEAT_GUI_TABLINE\n\tcase K_TABLINE:\n\tcase K_TABMENU:\n\t\t// Don't want to change any tabs here.  Make sure the same tab\n\t\t// is still selected.\n\t\tif (gui_use_tabline())\n\t\t    gui_mch_set_curtab(tabpage_index(curtab));\n\t\tgoto cmdline_not_changed;\n#endif\n\n\tcase K_SELECT:\t    // end of Select mode mapping - ignore\n\t\tgoto cmdline_not_changed;\n\n\tcase Ctrl_B:\t    // begin of command line\n\tcase K_HOME:\n\tcase K_KHOME:\n\tcase K_S_HOME:\n\tcase K_C_HOME:\n\t\tccline.cmdpos = 0;\n\t\tset_cmdspos();\n\t\tgoto cmdline_not_changed;\n\n\tcase Ctrl_E:\t    // end of command line\n\tcase K_END:\n\tcase K_KEND:\n\tcase K_S_END:\n\tcase K_C_END:\n\t\tccline.cmdpos = ccline.cmdlen;\n\t\tset_cmdspos_cursor();\n\t\tgoto cmdline_not_changed;\n\n\tcase Ctrl_A:\t    // all matches\n\t\tif (cmdline_pum_active())\n\t\t    // As Ctrl-A completes all the matches, close the popup\n\t\t    // menu (if present)\n\t\t    cmdline_pum_cleanup(&ccline);\n\n\t\tif (nextwild(&xpc, WILD_ALL, 0, firstc != '@') == FAIL)\n\t\t    break;\n\t\txpc.xp_context = EXPAND_NOTHING;\n\t\tdid_wild_list = FALSE;\n\t\tgoto cmdline_changed;\n\n\tcase Ctrl_L:\n#ifdef FEAT_SEARCH_EXTRA\n\t\tif (may_add_char_to_search(firstc, &c, &is_state) == OK)\n\t\t    goto cmdline_not_changed;\n#endif\n\n\t\t// completion: longest common part\n\t\tif (nextwild(&xpc, WILD_LONGEST, 0, firstc != '@') == FAIL)\n\t\t    break;\n\t\tgoto cmdline_changed;\n\n\tcase Ctrl_N:\t    // next match\n\tcase Ctrl_P:\t    // previous match\n\t\tif (xpc.xp_numfiles > 0)\n\t\t{\n\t\t    wild_type = (c == Ctrl_P) ? WILD_PREV : WILD_NEXT;\n\t\t    if (nextwild(&xpc, wild_type, 0, firstc != '@') == FAIL)\n\t\t\tbreak;\n\t\t    goto cmdline_not_changed;\n\t\t}\n\t\t// FALLTHROUGH\n\tcase K_UP:\n\tcase K_DOWN:\n\tcase K_S_UP:\n\tcase K_S_DOWN:\n\tcase K_PAGEUP:\n\tcase K_KPAGEUP:\n\tcase K_PAGEDOWN:\n\tcase K_KPAGEDOWN:\n\t\tif (cmdline_pum_active()\n\t\t\t&& (c == K_PAGEUP || c == K_PAGEDOWN ||\n\t\t\t    c == K_KPAGEUP || c == K_KPAGEDOWN))\n\t\t{\n\t\t    // If the popup menu is displayed, then PageUp and PageDown\n\t\t    // are used to scroll the menu.\n\t\t    wild_type = WILD_PAGEUP;\n\t\t    if (c == K_PAGEDOWN || c == K_KPAGEDOWN)\n\t\t\twild_type = WILD_PAGEDOWN;\n\t\t    if (nextwild(&xpc, wild_type, 0, firstc != '@') == FAIL)\n\t\t\tbreak;\n\t\t    goto cmdline_not_changed;\n\t\t}\n\t\telse\n\t\t{\n\t\t    res = cmdline_browse_history(c, firstc, &lookfor, histype,\n\t\t\t    &hiscnt, &xpc);\n\t\t    if (res == CMDLINE_CHANGED)\n\t\t\tgoto cmdline_changed;\n\t\t    else if (res == GOTO_NORMAL_MODE)\n\t\t\tgoto returncmd;\n\t\t}\n\t\tgoto cmdline_not_changed;\n\n#ifdef FEAT_SEARCH_EXTRA\n\tcase Ctrl_G:\t    // next match\n\tcase Ctrl_T:\t    // previous match\n\t\tif (may_adjust_incsearch_highlighting(\n\t\t\t\t\t  firstc, count, &is_state, c) == FAIL)\n\t\t    goto cmdline_not_changed;\n\t\tbreak;\n#endif\n\n\tcase Ctrl_V:\n\tcase Ctrl_Q:\n\t\t{\n\t\t    ignore_drag_release = TRUE;\n\t\t    putcmdline('^', TRUE);\n\n\t\t    // Get next (two) character(s).  Do not change any\n\t\t    // modifyOtherKeys ESC sequence to a normal key for\n\t\t    // CTRL-SHIFT-V.\n\t\t    c = get_literal(mod_mask & MOD_MASK_SHIFT);\n\n\t\t    do_abbr = FALSE;\t    // don't do abbreviation now\n\t\t    extra_char = NUL;\n\t\t    // may need to remove ^ when composing char was typed\n\t\t    if (enc_utf8 && utf_iscomposing(c) && !cmd_silent)\n\t\t    {\n\t\t\tdraw_cmdline(ccline.cmdpos,\n\t\t\t\t\t\tccline.cmdlen - ccline.cmdpos);\n\t\t\tmsg_putchar(' ');\n\t\t\tcursorcmd();\n\t\t    }\n\t\t}\n\n\t\tbreak;\n\n#ifdef FEAT_DIGRAPHS\n\tcase Ctrl_K:\n\t\tignore_drag_release = TRUE;\n\t\tputcmdline('?', TRUE);\n# ifdef USE_ON_FLY_SCROLL\n\t\tdont_scroll = TRUE;\t    // disallow scrolling here\n# endif\n\t\tc = get_digraph(TRUE);\n\t\textra_char = NUL;\n\t\tif (c != NUL)\n\t\t    break;\n\n\t\tredrawcmd();\n\t\tgoto cmdline_not_changed;\n#endif // FEAT_DIGRAPHS\n\n#ifdef FEAT_RIGHTLEFT\n\tcase Ctrl__:\t    // CTRL-_: switch language mode\n\t\tif (!p_ari)\n\t\t    break;\n\t\tcmd_hkmap = !cmd_hkmap;\n\t\tgoto cmdline_not_changed;\n#endif\n\n\tcase K_PS:\n\t\tbracketed_paste(PASTE_CMDLINE, FALSE, NULL);\n\t\tgoto cmdline_changed;\n\n\tdefault:\n#ifdef UNIX\n\t\tif (c == intr_char)\n\t\t{\n\t\t    gotesc = TRUE;\t// will free ccline.cmdbuff after\n\t\t\t\t\t// putting it in history\n\t\t    goto returncmd;\t// back to Normal mode\n\t\t}\n#endif\n\t\t/*\n\t\t * Normal character with no special meaning.  Just set mod_mask\n\t\t * to 0x0 so that typing Shift-Space in the GUI doesn't enter\n\t\t * the string <S-Space>.  This should only happen after ^V.\n\t\t */\n\t\tif (!IS_SPECIAL(c))\n\t\t    mod_mask = 0x0;\n\t\tbreak;\n\t}\n\t/*\n\t * End of switch on command line character.\n\t * We come here if we have a normal character.\n\t */\n\n\tif (do_abbr && (IS_SPECIAL(c) || !vim_iswordc(c))\n\t\t&& (ccheck_abbr(\n\t\t\t// Add ABBR_OFF for characters above 0x100, this is\n\t\t\t// what check_abbr() expects.\n\t\t\t\t(has_mbyte && c >= 0x100) ? (c + ABBR_OFF) : c)\n\t\t    || c == Ctrl_RSB))\n\t    goto cmdline_changed;\n\n\t/*\n\t * put the character in the command line\n\t */\n\tif (IS_SPECIAL(c) || mod_mask != 0)\n\t    put_on_cmdline(get_special_key_name(c, mod_mask), -1, TRUE);\n\telse\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tj = (*mb_char2bytes)(c, IObuff);\n\t\tIObuff[j] = NUL;\t// exclude composing chars\n\t\tput_on_cmdline(IObuff, j, TRUE);\n\t    }\n\t    else\n\t    {\n\t\tIObuff[0] = c;\n\t\tput_on_cmdline(IObuff, 1, TRUE);\n\t    }\n\t}\n\tgoto cmdline_changed;\n\n/*\n * This part implements incremental searches for \"/\" and \"?\"\n * Jump to cmdline_not_changed when a character has been read but the command\n * line did not change. Then we only search and redraw if something changed in\n * the past.\n * Jump to cmdline_changed when the command line did change.\n * (Sorry for the goto's, I know it is ugly).\n */\ncmdline_not_changed:\n#ifdef FEAT_SEARCH_EXTRA\n\tif (!is_state.incsearch_postponed)\n\t    continue;\n#endif\n\ncmdline_changed:\n#ifdef FEAT_SEARCH_EXTRA\n\t// If the window changed incremental search state is not valid.\n\tif (is_state.winid != curwin->w_id)\n\t    init_incsearch_state(&is_state);\n#endif\n\tif (trigger_cmdlinechanged)\n\t    // Trigger CmdlineChanged autocommands.\n\t    trigger_cmd_autocmd(cmdline_type, EVENT_CMDLINECHANGED);\n\n#ifdef FEAT_SEARCH_EXTRA\n\tif (xpc.xp_context == EXPAND_NOTHING && (KeyTyped || vpeekc() == NUL))\n\t    may_do_incsearch_highlighting(firstc, count, &is_state);\n#endif\n\n#ifdef FEAT_RIGHTLEFT\n\tif (cmdmsg_rl\n# ifdef FEAT_ARABIC\n\t\t|| (p_arshape && !p_tbidi\n\t\t\t\t       && cmdline_has_arabic(0, ccline.cmdlen))\n# endif\n\t\t)\n\t    // Always redraw the whole command line to fix shaping and\n\t    // right-left typing.  Not efficient, but it works.\n\t    // Do it only when there are no characters left to read\n\t    // to avoid useless intermediate redraws.\n\t    if (vpeekc() == NUL)\n\t\tredrawcmd();\n#endif\n    }\n\nreturncmd:\n\n#ifdef FEAT_RIGHTLEFT\n    cmdmsg_rl = FALSE;\n#endif\n\n    ExpandCleanup(&xpc);\n    ccline.xpc = NULL;\n\n#ifdef FEAT_SEARCH_EXTRA\n    finish_incsearch_highlighting(gotesc, &is_state, FALSE);\n#endif\n\n    if (ccline.cmdbuff != NULL)\n    {\n\t/*\n\t * Put line in history buffer (\":\" and \"=\" only when it was typed).\n\t */\n\tif (ccline.cmdlen && firstc != NUL\n\t\t&& (some_key_typed || histype == HIST_SEARCH))\n\t{\n\t    add_to_history(histype, ccline.cmdbuff, TRUE,\n\t\t\t\t       histype == HIST_SEARCH ? firstc : NUL);\n\t    if (firstc == ':')\n\t    {\n\t\tvim_free(new_last_cmdline);\n\t\tnew_last_cmdline = vim_strsave(ccline.cmdbuff);\n\t    }\n\t}\n\n\tif (gotesc)\n\t    abandon_cmdline();\n    }\n\n    /*\n     * If the screen was shifted up, redraw the whole screen (later).\n     * If the line is too long, clear it, so ruler and shown command do\n     * not get printed in the middle of it.\n     */\n    msg_check();\n    msg_scroll = save_msg_scroll;\n    redir_off = FALSE;\n\n    // When the command line was typed, no need for a wait-return prompt.\n    if (some_key_typed)\n\tneed_wait_return = FALSE;\n\n    // Trigger CmdlineLeave autocommands.\n    trigger_cmd_autocmd(cmdline_type, EVENT_CMDLINELEAVE);\n\n    State = save_State;\n\n#ifdef FEAT_EVAL\n    if (!debug_mode)\n\tmay_trigger_modechanged();\n#endif\n\n#ifdef HAVE_INPUT_METHOD\n    if (b_im_ptr != NULL && buf_valid(b_im_ptr_buf)\n\t\t\t\t\t\t  && *b_im_ptr != B_IMODE_LMAP)\n\tim_save_status(b_im_ptr);\n    im_set_active(FALSE);\n#endif\n    setmouse();\n#ifdef CURSOR_SHAPE\n    ui_cursor_shape();\t\t// may show different cursor shape\n#endif\n    sb_text_end_cmdline();\n\ntheend:\n    {\n\tchar_u *p = ccline.cmdbuff;\n\n\t--depth;\n\tif (did_save_ccline)\n\t    restore_cmdline(&save_ccline);\n\telse\n\t    ccline.cmdbuff = NULL;\n\treturn p;\n    }\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 580,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "PlayerGeneric::~PlayerGeneric()\n{\n\n\tif (player)\n\t{\n\t\tif (mixer && mixer->isActive() && !mixer->isDeviceRemoved(player))\n\t\t\tmixer->removeDevice(player);\n\t\tdelete player;\n\t}\n\t\n\tif (mixer)\n\t\tdelete mixer;\n\n\tdelete[] audioDriverName;\n\t\n\tdelete listener;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 582,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "do_arg_all(\n    int\tcount,\n    int\tforceit,\t\t// hide buffers in current windows\n    int keep_tabs)\t\t// keep current tabs, for \":tab drop file\"\n{\n    int\t\ti;\n    win_T\t*wp, *wpnext;\n    char_u\t*opened;\t// Array of weight for which args are open:\n\t\t\t\t//  0: not opened\n\t\t\t\t//  1: opened in other tab\n\t\t\t\t//  2: opened in curtab\n\t\t\t\t//  3: opened in curtab and curwin\n\t\t\t\t//\n    int\t\topened_len;\t// length of opened[]\n    int\t\tuse_firstwin = FALSE;\t// use first window for arglist\n    int\t\ttab_drop_empty_window = FALSE;\n    int\t\tsplit_ret = OK;\n    int\t\tp_ea_save;\n    alist_T\t*alist;\t\t// argument list to be used\n    buf_T\t*buf;\n    tabpage_T\t*tpnext;\n    int\t\thad_tab = cmdmod.cmod_tab;\n    win_T\t*old_curwin, *last_curwin;\n    tabpage_T\t*old_curtab, *last_curtab;\n    win_T\t*new_curwin = NULL;\n    tabpage_T\t*new_curtab = NULL;\n    int\t\tprev_arglist_locked = arglist_locked;\n\n#ifdef FEAT_CMDWIN\n    if (cmdwin_type != 0)\n    {\n\temsg(_(e_invalid_in_cmdline_window));\n\treturn;\n    }\n#endif\n    if (ARGCOUNT <= 0)\n    {\n\t// Don't give an error message.  We don't want it when the \":all\"\n\t// command is in the .vimrc.\n\treturn;\n    }\n    setpcmark();\n\n    opened_len = ARGCOUNT;\n    opened = alloc_clear(opened_len);\n    if (opened == NULL)\n\treturn;\n\n    // Autocommands may do anything to the argument list.  Make sure it's not\n    // freed while we are working here by \"locking\" it.  We still have to\n    // watch out for its size to be changed.\n    alist = curwin->w_alist;\n    ++alist->al_refcount;\n    arglist_locked = TRUE;\n\n    old_curwin = curwin;\n    old_curtab = curtab;\n\n# ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n# endif\n\n    // Try closing all windows that are not in the argument list.\n    // Also close windows that are not full width;\n    // When 'hidden' or \"forceit\" set the buffer becomes hidden.\n    // Windows that have a changed buffer and can't be hidden won't be closed.\n    // When the \":tab\" modifier was used do this for all tab pages.\n    if (had_tab > 0)\n\tgoto_tabpage_tp(first_tabpage, TRUE, TRUE);\n    for (;;)\n    {\n\ttpnext = curtab->tp_next;\n\tfor (wp = firstwin; wp != NULL; wp = wpnext)\n\t{\n\t    wpnext = wp->w_next;\n\t    buf = wp->w_buffer;\n\t    if (buf->b_ffname == NULL\n\t\t    || (!keep_tabs && (buf->b_nwindows > 1\n\t\t\t    || wp->w_width != Columns)))\n\t\ti = opened_len;\n\t    else\n\t    {\n\t\t// check if the buffer in this window is in the arglist\n\t\tfor (i = 0; i < opened_len; ++i)\n\t\t{\n\t\t    if (i < alist->al_ga.ga_len\n\t\t\t    && (AARGLIST(alist)[i].ae_fnum == buf->b_fnum\n\t\t\t\t|| fullpathcmp(alist_name(&AARGLIST(alist)[i]),\n\t\t\t\t\tbuf->b_ffname, TRUE, TRUE) & FPC_SAME))\n\t\t    {\n\t\t\tint weight = 1;\n\n\t\t\tif (old_curtab == curtab)\n\t\t\t{\n\t\t\t    ++weight;\n\t\t\t    if (old_curwin == wp)\n\t\t\t\t++weight;\n\t\t\t}\n\n\t\t\tif (weight > (int)opened[i])\n\t\t\t{\n\t\t\t    opened[i] = (char_u)weight;\n\t\t\t    if (i == 0)\n\t\t\t    {\n\t\t\t\tif (new_curwin != NULL)\n\t\t\t\t    new_curwin->w_arg_idx = opened_len;\n\t\t\t\tnew_curwin = wp;\n\t\t\t\tnew_curtab = curtab;\n\t\t\t    }\n\t\t\t}\n\t\t\telse if (keep_tabs)\n\t\t\t    i = opened_len;\n\n\t\t\tif (wp->w_alist != alist)\n\t\t\t{\n\t\t\t    // Use the current argument list for all windows\n\t\t\t    // containing a file from it.\n\t\t\t    alist_unlink(wp->w_alist);\n\t\t\t    wp->w_alist = alist;\n\t\t\t    ++wp->w_alist->al_refcount;\n\t\t\t}\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t    wp->w_arg_idx = i;\n\n\t    if (i == opened_len && !keep_tabs)// close this window\n\t    {\n\t\tif (buf_hide(buf) || forceit || buf->b_nwindows > 1\n\t\t\t\t\t\t\t|| !bufIsChanged(buf))\n\t\t{\n\t\t    // If the buffer was changed, and we would like to hide it,\n\t\t    // try autowriting.\n\t\t    if (!buf_hide(buf) && buf->b_nwindows <= 1\n\t\t\t\t\t\t\t && bufIsChanged(buf))\n\t\t    {\n\t\t\tbufref_T    bufref;\n\n\t\t\tset_bufref(&bufref, buf);\n\n\t\t\t(void)autowrite(buf, FALSE);\n\n\t\t\t// check if autocommands removed the window\n\t\t\tif (!win_valid(wp) || !bufref_valid(&bufref))\n\t\t\t{\n\t\t\t    wpnext = firstwin;\t// start all over...\n\t\t\t    continue;\n\t\t\t}\n\t\t    }\n\t\t    // don't close last window\n\t\t    if (ONE_WINDOW\n\t\t\t    && (first_tabpage->tp_next == NULL || !had_tab))\n\t\t\tuse_firstwin = TRUE;\n\t\t    else\n\t\t    {\n\t\t\twin_close(wp, !buf_hide(buf) && !bufIsChanged(buf));\n\n\t\t\t// check if autocommands removed the next window\n\t\t\tif (!win_valid(wpnext))\n\t\t\t    wpnext = firstwin;\t// start all over...\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n\t// Without the \":tab\" modifier only do the current tab page.\n\tif (had_tab == 0 || tpnext == NULL)\n\t    break;\n\n\t// check if autocommands removed the next tab page\n\tif (!valid_tabpage(tpnext))\n\t    tpnext = first_tabpage;\t// start all over...\n\n\tgoto_tabpage_tp(tpnext, TRUE, TRUE);\n    }\n\n    // Open a window for files in the argument list that don't have one.\n    // ARGCOUNT may change while doing this, because of autocommands.\n    if (count > opened_len || count <= 0)\n\tcount = opened_len;\n\n    // Don't execute Win/Buf Enter/Leave autocommands here.\n    ++autocmd_no_enter;\n    ++autocmd_no_leave;\n    last_curwin = curwin;\n    last_curtab = curtab;\n    win_enter(lastwin, FALSE);\n    // \":tab drop file\" should re-use an empty window to avoid \"--remote-tab\"\n    // leaving an empty tab page when executed locally.\n    if (keep_tabs && BUFEMPTY() && curbuf->b_nwindows == 1\n\t\t\t    && curbuf->b_ffname == NULL && !curbuf->b_changed)\n    {\n\tuse_firstwin = TRUE;\n\ttab_drop_empty_window = TRUE;\n    }\n\n    for (i = 0; i < count && !got_int; ++i)\n    {\n\tif (alist == &global_alist && i == global_alist.al_ga.ga_len - 1)\n\t    arg_had_last = TRUE;\n\tif (opened[i] > 0)\n\t{\n\t    // Move the already present window to below the current window\n\t    if (curwin->w_arg_idx != i)\n\t    {\n\t\tFOR_ALL_WINDOWS(wpnext)\n\t\t{\n\t\t    if (wpnext->w_arg_idx == i)\n\t\t    {\n\t\t\tif (keep_tabs)\n\t\t\t{\n\t\t\t    new_curwin = wpnext;\n\t\t\t    new_curtab = curtab;\n\t\t\t}\n\t\t\telse if (wpnext->w_frame->fr_parent\n\t\t\t\t\t\t != curwin->w_frame->fr_parent)\n\t\t\t{\n\t\t\t    emsg(_(\"E249: window layout changed unexpectedly\"));\n\t\t\t    i = count;\n\t\t\t    break;\n\t\t\t}\n\t\t\telse\n\t\t\t    win_move_after(wpnext, curwin);\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\telse if (split_ret == OK)\n\t{\n\t    // trigger events for tab drop\n\t    if (tab_drop_empty_window && i == count - 1)\n\t\t--autocmd_no_enter;\n\t    if (!use_firstwin)\t\t// split current window\n\t    {\n\t\tp_ea_save = p_ea;\n\t\tp_ea = TRUE;\t\t// use space from all windows\n\t\tsplit_ret = win_split(0, WSP_ROOM | WSP_BELOW);\n\t\tp_ea = p_ea_save;\n\t\tif (split_ret == FAIL)\n\t\t    continue;\n\t    }\n\t    else    // first window: do autocmd for leaving this buffer\n\t\t--autocmd_no_leave;\n\n\t    // edit file \"i\"\n\t    curwin->w_arg_idx = i;\n\t    if (i == 0)\n\t    {\n\t\tnew_curwin = curwin;\n\t\tnew_curtab = curtab;\n\t    }\n\t    (void)do_ecmd(0, alist_name(&AARGLIST(alist)[i]), NULL, NULL,\n\t\t      ECMD_ONE,\n\t\t      ((buf_hide(curwin->w_buffer)\n\t\t\t   || bufIsChanged(curwin->w_buffer)) ? ECMD_HIDE : 0)\n\t\t\t\t\t\t       + ECMD_OLDBUF, curwin);\n\t    if (tab_drop_empty_window && i == count - 1)\n\t\t++autocmd_no_enter;\n\t    if (use_firstwin)\n\t\t++autocmd_no_leave;\n\t    use_firstwin = FALSE;\n\t}\n\tui_breakcheck();\n\n\t// When \":tab\" was used open a new tab for a new window repeatedly.\n\tif (had_tab > 0 && tabpage_index(NULL) <= p_tpm)\n\t    cmdmod.cmod_tab = 9999;\n    }\n\n    // Remove the \"lock\" on the argument list.\n    alist_unlink(alist);\n    arglist_locked = prev_arglist_locked;\n\n    --autocmd_no_enter;\n\n    // restore last referenced tabpage's curwin\n    if (last_curtab != new_curtab)\n    {\n\tif (valid_tabpage(last_curtab))\n\t    goto_tabpage_tp(last_curtab, TRUE, TRUE);\n\tif (win_valid(last_curwin))\n\t    win_enter(last_curwin, FALSE);\n    }\n    // to window with first arg\n    if (valid_tabpage(new_curtab))\n\tgoto_tabpage_tp(new_curtab, TRUE, TRUE);\n    if (win_valid(new_curwin))\n\twin_enter(new_curwin, FALSE);\n\n    --autocmd_no_leave;\n    vim_free(opened);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 618,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static void mkiss_close(struct tty_struct *tty)\n{\n\tstruct mkiss *ax;\n\n\twrite_lock_irq(&disc_data_lock);\n\tax = tty->disc_data;\n\ttty->disc_data = NULL;\n\twrite_unlock_irq(&disc_data_lock);\n\n\tif (!ax)\n\t\treturn;\n\n\t/*\n\t * We have now ensured that nobody can start using ap from now on, but\n\t * we have to wait for all existing users to finish.\n\t */\n\tif (!refcount_dec_and_test(&ax->refcnt))\n\t\twait_for_completion(&ax->dead);\n\t/*\n\t * Halt the transmit queue so that a new transmit cannot scribble\n\t * on our buffers\n\t */\n\tnetif_stop_queue(ax->dev);\n\n\tunregister_netdev(ax->dev);\n\n\t/* Free all AX25 frame buffers after unreg. */\n\tkfree(ax->rbuff);\n\tkfree(ax->xbuff);\n\n\tax->tty = NULL;\n\n\tfree_netdev(ax->dev);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 638,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "do_cmdline(\n    char_u\t*cmdline,\n    char_u\t*(*fgetline)(int, void *, int, getline_opt_T),\n    void\t*cookie,\t\t// argument for fgetline()\n    int\t\tflags)\n{\n    char_u\t*next_cmdline;\t\t// next cmd to execute\n    char_u\t*cmdline_copy = NULL;\t// copy of cmd line\n    int\t\tused_getline = FALSE;\t// used \"fgetline\" to obtain command\n    static int\trecursive = 0;\t\t// recursive depth\n    int\t\tmsg_didout_before_start = 0;\n    int\t\tcount = 0;\t\t// line number count\n    int\t\tdid_inc = FALSE;\t// incremented RedrawingDisabled\n    int\t\tretval = OK;\n#ifdef FEAT_EVAL\n    cstack_T\tcstack;\t\t\t// conditional stack\n    garray_T\tlines_ga;\t\t// keep lines for \":while\"/\":for\"\n    int\t\tcurrent_line = 0;\t// active line in lines_ga\n    int\t\tcurrent_line_before = 0;\n    char_u\t*fname = NULL;\t\t// function or script name\n    linenr_T\t*breakpoint = NULL;\t// ptr to breakpoint field in cookie\n    int\t\t*dbg_tick = NULL;\t// ptr to dbg_tick field in cookie\n    struct dbg_stuff debug_saved;\t// saved things for debug mode\n    int\t\tinitial_trylevel;\n    msglist_T\t**saved_msg_list = NULL;\n    msglist_T\t*private_msg_list = NULL;\n\n    // \"fgetline\" and \"cookie\" passed to do_one_cmd()\n    char_u\t*(*cmd_getline)(int, void *, int, getline_opt_T);\n    void\t*cmd_cookie;\n    struct loop_cookie cmd_loop_cookie;\n    void\t*real_cookie;\n    int\t\tgetline_is_func;\n#else\n# define cmd_getline fgetline\n# define cmd_cookie cookie\n#endif\n    static int\tcall_depth = 0;\t\t// recursiveness\n#ifdef FEAT_EVAL\n    // For every pair of do_cmdline()/do_one_cmd() calls, use an extra memory\n    // location for storing error messages to be converted to an exception.\n    // This ensures that the do_errthrow() call in do_one_cmd() does not\n    // combine the messages stored by an earlier invocation of do_one_cmd()\n    // with the command name of the later one.  This would happen when\n    // BufWritePost autocommands are executed after a write error.\n    saved_msg_list = msg_list;\n    msg_list = &private_msg_list;\n#endif\n\n    // It's possible to create an endless loop with \":execute\", catch that\n    // here.  The value of 200 allows nested function calls, \":source\", etc.\n    // Allow 200 or 'maxfuncdepth', whatever is larger.\n    if (call_depth >= 200\n#ifdef FEAT_EVAL\n\t    && call_depth >= p_mfd\n#endif\n\t    )\n    {\n\temsg(_(e_command_too_recursive));\n#ifdef FEAT_EVAL\n\t// When converting to an exception, we do not include the command name\n\t// since this is not an error of the specific command.\n\tdo_errthrow((cstack_T *)NULL, (char_u *)NULL);\n\tmsg_list = saved_msg_list;\n#endif\n\treturn FAIL;\n    }\n    ++call_depth;\n\n#ifdef FEAT_EVAL\n    CLEAR_FIELD(cstack);\n    cstack.cs_idx = -1;\n    ga_init2(&lines_ga, sizeof(wcmd_T), 10);\n\n    real_cookie = getline_cookie(fgetline, cookie);\n\n    // Inside a function use a higher nesting level.\n    getline_is_func = getline_equal(fgetline, cookie, get_func_line);\n    if (getline_is_func && ex_nesting_level == func_level(real_cookie))\n\t++ex_nesting_level;\n\n    // Get the function or script name and the address where the next breakpoint\n    // line and the debug tick for a function or script are stored.\n    if (getline_is_func)\n    {\n\tfname = func_name(real_cookie);\n\tbreakpoint = func_breakpoint(real_cookie);\n\tdbg_tick = func_dbg_tick(real_cookie);\n    }\n    else if (getline_equal(fgetline, cookie, getsourceline))\n    {\n\tfname = SOURCING_NAME;\n\tbreakpoint = source_breakpoint(real_cookie);\n\tdbg_tick = source_dbg_tick(real_cookie);\n    }\n\n    /*\n     * Initialize \"force_abort\"  and \"suppress_errthrow\" at the top level.\n     */\n    if (!recursive)\n    {\n\tforce_abort = FALSE;\n\tsuppress_errthrow = FALSE;\n    }\n\n    /*\n     * If requested, store and reset the global values controlling the\n     * exception handling (used when debugging).  Otherwise clear it to avoid\n     * a bogus compiler warning when the optimizer uses inline functions...\n     */\n    if (flags & DOCMD_EXCRESET)\n\tsave_dbg_stuff(&debug_saved);\n    else\n\tCLEAR_FIELD(debug_saved);\n\n    initial_trylevel = trylevel;\n\n    /*\n     * \"did_throw\" will be set to TRUE when an exception is being thrown.\n     */\n    did_throw = FALSE;\n#endif\n    /*\n     * \"did_emsg\" will be set to TRUE when emsg() is used, in which case we\n     * cancel the whole command line, and any if/endif or loop.\n     * If force_abort is set, we cancel everything.\n     */\n#ifdef FEAT_EVAL\n    did_emsg_cumul += did_emsg;\n#endif\n    did_emsg = FALSE;\n\n    /*\n     * KeyTyped is only set when calling vgetc().  Reset it here when not\n     * calling vgetc() (sourced command lines).\n     */\n    if (!(flags & DOCMD_KEYTYPED)\n\t\t\t       && !getline_equal(fgetline, cookie, getexline))\n\tKeyTyped = FALSE;\n\n    /*\n     * Continue executing command lines:\n     * - when inside an \":if\", \":while\" or \":for\"\n     * - for multiple commands on one line, separated with '|'\n     * - when repeating until there are no more lines (for \":source\")\n     */\n    next_cmdline = cmdline;\n    do\n    {\n#ifdef FEAT_EVAL\n\tgetline_is_func = getline_equal(fgetline, cookie, get_func_line);\n#endif\n\n\t// stop skipping cmds for an error msg after all endif/while/for\n\tif (next_cmdline == NULL\n#ifdef FEAT_EVAL\n\t\t&& !force_abort\n\t\t&& cstack.cs_idx < 0\n\t\t&& !(getline_is_func && func_has_abort(real_cookie))\n#endif\n\t\t\t\t\t\t\t)\n\t{\n#ifdef FEAT_EVAL\n\t    did_emsg_cumul += did_emsg;\n#endif\n\t    did_emsg = FALSE;\n\t}\n\n\t/*\n\t * 1. If repeating a line in a loop, get a line from lines_ga.\n\t * 2. If no line given: Get an allocated line with fgetline().\n\t * 3. If a line is given: Make a copy, so we can mess with it.\n\t */\n\n#ifdef FEAT_EVAL\n\t// 1. If repeating, get a previous line from lines_ga.\n\tif (cstack.cs_looplevel > 0 && current_line < lines_ga.ga_len)\n\t{\n\t    // Each '|' separated command is stored separately in lines_ga, to\n\t    // be able to jump to it.  Don't use next_cmdline now.\n\t    VIM_CLEAR(cmdline_copy);\n\n\t    // Check if a function has returned or, unless it has an unclosed\n\t    // try conditional, aborted.\n\t    if (getline_is_func)\n\t    {\n# ifdef FEAT_PROFILE\n\t\tif (do_profiling == PROF_YES)\n\t\t    func_line_end(real_cookie);\n# endif\n\t\tif (func_has_ended(real_cookie))\n\t\t{\n\t\t    retval = FAIL;\n\t\t    break;\n\t\t}\n\t    }\n#ifdef FEAT_PROFILE\n\t    else if (do_profiling == PROF_YES\n\t\t\t    && getline_equal(fgetline, cookie, getsourceline))\n\t\tscript_line_end();\n#endif\n\n\t    // Check if a sourced file hit a \":finish\" command.\n\t    if (source_finished(fgetline, cookie))\n\t    {\n\t\tretval = FAIL;\n\t\tbreak;\n\t    }\n\n\t    // If breakpoints have been added/deleted need to check for it.\n\t    if (breakpoint != NULL && dbg_tick != NULL\n\t\t\t\t\t\t   && *dbg_tick != debug_tick)\n\t    {\n\t\t*breakpoint = dbg_find_breakpoint(\n\t\t\t\tgetline_equal(fgetline, cookie, getsourceline),\n\t\t\t\t\t\t\tfname, SOURCING_LNUM);\n\t\t*dbg_tick = debug_tick;\n\t    }\n\n\t    next_cmdline = ((wcmd_T *)(lines_ga.ga_data))[current_line].line;\n\t    SOURCING_LNUM = ((wcmd_T *)(lines_ga.ga_data))[current_line].lnum;\n\n\t    // Did we encounter a breakpoint?\n\t    if (breakpoint != NULL && *breakpoint != 0\n\t\t\t\t\t      && *breakpoint <= SOURCING_LNUM)\n\t    {\n\t\tdbg_breakpoint(fname, SOURCING_LNUM);\n\t\t// Find next breakpoint.\n\t\t*breakpoint = dbg_find_breakpoint(\n\t\t\t       getline_equal(fgetline, cookie, getsourceline),\n\t\t\t\t\t\t\tfname, SOURCING_LNUM);\n\t\t*dbg_tick = debug_tick;\n\t    }\n# ifdef FEAT_PROFILE\n\t    if (do_profiling == PROF_YES)\n\t    {\n\t\tif (getline_is_func)\n\t\t    func_line_start(real_cookie, SOURCING_LNUM);\n\t\telse if (getline_equal(fgetline, cookie, getsourceline))\n\t\t    script_line_start();\n\t    }\n# endif\n\t}\n#endif\n\n\t// 2. If no line given, get an allocated line with fgetline().\n\tif (next_cmdline == NULL)\n\t{\n\t    /*\n\t     * Need to set msg_didout for the first line after an \":if\",\n\t     * otherwise the \":if\" will be overwritten.\n\t     */\n\t    if (count == 1 && getline_equal(fgetline, cookie, getexline))\n\t\tmsg_didout = TRUE;\n\t    if (fgetline == NULL || (next_cmdline = fgetline(':', cookie,\n#ifdef FEAT_EVAL\n\t\t    cstack.cs_idx < 0 ? 0 : (cstack.cs_idx + 1) * 2\n#else\n\t\t    0\n#endif\n\t\t    , in_vim9script() ? GETLINE_CONCAT_CONTBAR\n\t\t\t\t\t       : GETLINE_CONCAT_CONT)) == NULL)\n\t    {\n\t\t// Don't call wait_return() for aborted command line.  The NULL\n\t\t// returned for the end of a sourced file or executed function\n\t\t// doesn't do this.\n\t\tif (KeyTyped && !(flags & DOCMD_REPEAT))\n\t\t    need_wait_return = FALSE;\n\t\tretval = FAIL;\n\t\tbreak;\n\t    }\n\t    used_getline = TRUE;\n\n\t    /*\n\t     * Keep the first typed line.  Clear it when more lines are typed.\n\t     */\n\t    if (flags & DOCMD_KEEPLINE)\n\t    {\n\t\tvim_free(repeat_cmdline);\n\t\tif (count == 0)\n\t\t    repeat_cmdline = vim_strsave(next_cmdline);\n\t\telse\n\t\t    repeat_cmdline = NULL;\n\t    }\n\t}\n\n\t// 3. Make a copy of the command so we can mess with it.\n\telse if (cmdline_copy == NULL)\n\t{\n\t    next_cmdline = vim_strsave(next_cmdline);\n\t    if (next_cmdline == NULL)\n\t    {\n\t\temsg(_(e_out_of_memory));\n\t\tretval = FAIL;\n\t\tbreak;\n\t    }\n\t}\n\tcmdline_copy = next_cmdline;\n\n#ifdef FEAT_EVAL\n\t/*\n\t * Inside a while/for loop, and when the command looks like a \":while\"\n\t * or \":for\", the line is stored, because we may need it later when\n\t * looping.\n\t *\n\t * When there is a '|' and another command, it is stored separately,\n\t * because we need to be able to jump back to it from an\n\t * :endwhile/:endfor.\n\t *\n\t * Pass a different \"fgetline\" function to do_one_cmd() below,\n\t * that it stores lines in or reads them from \"lines_ga\".  Makes it\n\t * possible to define a function inside a while/for loop and handles\n\t * line continuation.\n\t */\n\tif ((cstack.cs_looplevel > 0 || has_loop_cmd(next_cmdline)))\n\t{\n\t    cmd_getline = get_loop_line;\n\t    cmd_cookie = (void *)&cmd_loop_cookie;\n\t    cmd_loop_cookie.lines_gap = &lines_ga;\n\t    cmd_loop_cookie.current_line = current_line;\n\t    cmd_loop_cookie.getline = fgetline;\n\t    cmd_loop_cookie.cookie = cookie;\n\t    cmd_loop_cookie.repeating = (current_line < lines_ga.ga_len);\n\n\t    // Save the current line when encountering it the first time.\n\t    if (current_line == lines_ga.ga_len\n\t\t    && store_loop_line(&lines_ga, next_cmdline) == FAIL)\n\t    {\n\t\tretval = FAIL;\n\t\tbreak;\n\t    }\n\t    current_line_before = current_line;\n\t}\n\telse\n\t{\n\t    cmd_getline = fgetline;\n\t    cmd_cookie = cookie;\n\t}\n\n\tdid_endif = FALSE;\n#endif\n\n\tif (count++ == 0)\n\t{\n\t    /*\n\t     * All output from the commands is put below each other, without\n\t     * waiting for a return. Don't do this when executing commands\n\t     * from a script or when being called recursive (e.g. for \":e\n\t     * +command file\").\n\t     */\n\t    if (!(flags & DOCMD_NOWAIT) && !recursive)\n\t    {\n\t\tmsg_didout_before_start = msg_didout;\n\t\tmsg_didany = FALSE; // no output yet\n\t\tmsg_start();\n\t\tmsg_scroll = TRUE;  // put messages below each other\n\t\t++no_wait_return;   // don't wait for return until finished\n\t\t++RedrawingDisabled;\n\t\tdid_inc = TRUE;\n\t    }\n\t}\n\n\tif ((p_verbose >= 15 && SOURCING_NAME != NULL) || p_verbose >= 16)\n\t    msg_verbose_cmd(SOURCING_LNUM, cmdline_copy);\n\n\t/*\n\t * 2. Execute one '|' separated command.\n\t *    do_one_cmd() will return NULL if there is no trailing '|'.\n\t *    \"cmdline_copy\" can change, e.g. for '%' and '#' expansion.\n\t */\n\t++recursive;\n\tnext_cmdline = do_one_cmd(&cmdline_copy, flags,\n#ifdef FEAT_EVAL\n\t\t\t\t&cstack,\n#endif\n\t\t\t\tcmd_getline, cmd_cookie);\n\t--recursive;\n\n#ifdef FEAT_EVAL\n\tif (cmd_cookie == (void *)&cmd_loop_cookie)\n\t    // Use \"current_line\" from \"cmd_loop_cookie\", it may have been\n\t    // incremented when defining a function.\n\t    current_line = cmd_loop_cookie.current_line;\n#endif\n\n\tif (next_cmdline == NULL)\n\t{\n\t    VIM_CLEAR(cmdline_copy);\n\n\t    /*\n\t     * If the command was typed, remember it for the ':' register.\n\t     * Do this AFTER executing the command to make :@: work.\n\t     */\n\t    if (getline_equal(fgetline, cookie, getexline)\n\t\t\t\t\t\t  && new_last_cmdline != NULL)\n\t    {\n\t\tvim_free(last_cmdline);\n\t\tlast_cmdline = new_last_cmdline;\n\t\tnew_last_cmdline = NULL;\n\t    }\n\t}\n\telse\n\t{\n\t    // need to copy the command after the '|' to cmdline_copy, for the\n\t    // next do_one_cmd()\n\t    STRMOVE(cmdline_copy, next_cmdline);\n\t    next_cmdline = cmdline_copy;\n\t}\n\n\n#ifdef FEAT_EVAL\n\t// reset did_emsg for a function that is not aborted by an error\n\tif (did_emsg && !force_abort\n\t\t&& getline_equal(fgetline, cookie, get_func_line)\n\t\t\t\t\t      && !func_has_abort(real_cookie))\n\t{\n\t    // did_emsg_cumul is not set here\n\t    did_emsg = FALSE;\n\t}\n\n\tif (cstack.cs_looplevel > 0)\n\t{\n\t    ++current_line;\n\n\t    /*\n\t     * An \":endwhile\", \":endfor\" and \":continue\" is handled here.\n\t     * If we were executing commands, jump back to the \":while\" or\n\t     * \":for\".\n\t     * If we were not executing commands, decrement cs_looplevel.\n\t     */\n\t    if (cstack.cs_lflags & (CSL_HAD_CONT | CSL_HAD_ENDLOOP))\n\t    {\n\t\tcstack.cs_lflags &= ~(CSL_HAD_CONT | CSL_HAD_ENDLOOP);\n\n\t\t// Jump back to the matching \":while\" or \":for\".  Be careful\n\t\t// not to use a cs_line[] from an entry that isn't a \":while\"\n\t\t// or \":for\": It would make \"current_line\" invalid and can\n\t\t// cause a crash.\n\t\tif (!did_emsg && !got_int && !did_throw\n\t\t\t&& cstack.cs_idx >= 0\n\t\t\t&& (cstack.cs_flags[cstack.cs_idx]\n\t\t\t\t\t\t      & (CSF_WHILE | CSF_FOR))\n\t\t\t&& cstack.cs_line[cstack.cs_idx] >= 0\n\t\t\t&& (cstack.cs_flags[cstack.cs_idx] & CSF_ACTIVE))\n\t\t{\n\t\t    current_line = cstack.cs_line[cstack.cs_idx];\n\t\t\t\t\t\t// remember we jumped there\n\t\t    cstack.cs_lflags |= CSL_HAD_LOOP;\n\t\t    line_breakcheck();\t\t// check if CTRL-C typed\n\n\t\t    // Check for the next breakpoint at or after the \":while\"\n\t\t    // or \":for\".\n\t\t    if (breakpoint != NULL && lines_ga.ga_len > current_line)\n\t\t    {\n\t\t\t*breakpoint = dbg_find_breakpoint(\n\t\t\t       getline_equal(fgetline, cookie, getsourceline),\n\t\t\t\t\t\t\t\t\tfname,\n\t\t\t   ((wcmd_T *)lines_ga.ga_data)[current_line].lnum-1);\n\t\t\t*dbg_tick = debug_tick;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    // can only get here with \":endwhile\" or \":endfor\"\n\t\t    if (cstack.cs_idx >= 0)\n\t\t\trewind_conditionals(&cstack, cstack.cs_idx - 1,\n\t\t\t\t   CSF_WHILE | CSF_FOR, &cstack.cs_looplevel);\n\t\t}\n\t    }\n\n\t    /*\n\t     * For a \":while\" or \":for\" we need to remember the line number.\n\t     */\n\t    else if (cstack.cs_lflags & CSL_HAD_LOOP)\n\t    {\n\t\tcstack.cs_lflags &= ~CSL_HAD_LOOP;\n\t\tcstack.cs_line[cstack.cs_idx] = current_line_before;\n\t    }\n\t}\n\n\t// Check for the next breakpoint after a watchexpression\n\tif (breakpoint != NULL && has_watchexpr())\n\t{\n\t    *breakpoint = dbg_find_breakpoint(FALSE, fname, SOURCING_LNUM);\n\t    *dbg_tick = debug_tick;\n\t}\n\n\t/*\n\t * When not inside any \":while\" loop, clear remembered lines.\n\t */\n\tif (cstack.cs_looplevel == 0)\n\t{\n\t    if (lines_ga.ga_len > 0)\n\t    {\n\t\tSOURCING_LNUM =\n\t\t       ((wcmd_T *)lines_ga.ga_data)[lines_ga.ga_len - 1].lnum;\n\t\tfree_cmdlines(&lines_ga);\n\t    }\n\t    current_line = 0;\n\t}\n\n\t/*\n\t * A \":finally\" makes did_emsg, got_int, and did_throw pending for\n\t * being restored at the \":endtry\".  Reset them here and set the\n\t * ACTIVE and FINALLY flags, so that the finally clause gets executed.\n\t * This includes the case where a missing \":endif\", \":endwhile\" or\n\t * \":endfor\" was detected by the \":finally\" itself.\n\t */\n\tif (cstack.cs_lflags & CSL_HAD_FINA)\n\t{\n\t    cstack.cs_lflags &= ~CSL_HAD_FINA;\n\t    report_make_pending(cstack.cs_pending[cstack.cs_idx]\n\t\t    & (CSTP_ERROR | CSTP_INTERRUPT | CSTP_THROW),\n\t\t    did_throw ? (void *)current_exception : NULL);\n\t    did_emsg = got_int = did_throw = FALSE;\n\t    cstack.cs_flags[cstack.cs_idx] |= CSF_ACTIVE | CSF_FINALLY;\n\t}\n\n\t// Update global \"trylevel\" for recursive calls to do_cmdline() from\n\t// within this loop.\n\ttrylevel = initial_trylevel + cstack.cs_trylevel;\n\n\t/*\n\t * If the outermost try conditional (across function calls and sourced\n\t * files) is aborted because of an error, an interrupt, or an uncaught\n\t * exception, cancel everything.  If it is left normally, reset\n\t * force_abort to get the non-EH compatible abortion behavior for\n\t * the rest of the script.\n\t */\n\tif (trylevel == 0 && !did_emsg && !got_int && !did_throw)\n\t    force_abort = FALSE;\n\n\t// Convert an interrupt to an exception if appropriate.\n\t(void)do_intthrow(&cstack);\n#endif // FEAT_EVAL\n\n    }\n    /*\n     * Continue executing command lines when:\n     * - no CTRL-C typed, no aborting error, no exception thrown or try\n     *   conditionals need to be checked for executing finally clauses or\n     *   catching an interrupt exception\n     * - didn't get an error message or lines are not typed\n     * - there is a command after '|', inside a :if, :while, :for or :try, or\n     *   looping for \":source\" command or function call.\n     */\n    while (!((got_int\n#ifdef FEAT_EVAL\n\t\t    || (did_emsg && (force_abort || in_vim9script()))\n\t\t    || did_throw\n#endif\n\t     )\n#ifdef FEAT_EVAL\n\t\t&& cstack.cs_trylevel == 0\n#endif\n\t    )\n\t    && !(did_emsg\n#ifdef FEAT_EVAL\n\t\t// Keep going when inside try/catch, so that the error can be\n\t\t// deal with, except when it is a syntax error, it may cause\n\t\t// the :endtry to be missed.\n\t\t&& (cstack.cs_trylevel == 0 || did_emsg_syntax)\n#endif\n\t\t&& used_getline\n\t\t\t    && (getline_equal(fgetline, cookie, getexmodeline)\n\t\t\t       || getline_equal(fgetline, cookie, getexline)))\n\t    && (next_cmdline != NULL\n#ifdef FEAT_EVAL\n\t\t\t|| cstack.cs_idx >= 0\n#endif\n\t\t\t|| (flags & DOCMD_REPEAT)));\n\n    vim_free(cmdline_copy);\n    did_emsg_syntax = FALSE;\n#ifdef FEAT_EVAL\n    free_cmdlines(&lines_ga);\n    ga_clear(&lines_ga);\n\n    if (cstack.cs_idx >= 0)\n    {\n\t/*\n\t * If a sourced file or executed function ran to its end, report the\n\t * unclosed conditional.\n\t * In Vim9 script do not give a second error, executing aborts after\n\t * the first one.\n\t */\n\tif (!got_int && !did_throw && !aborting()\n\t\t&& !(did_emsg && in_vim9script())\n\t\t&& ((getline_equal(fgetline, cookie, getsourceline)\n\t\t\t&& !source_finished(fgetline, cookie))\n\t\t    || (getline_equal(fgetline, cookie, get_func_line)\n\t\t\t\t\t    && !func_has_ended(real_cookie))))\n\t{\n\t    if (cstack.cs_flags[cstack.cs_idx] & CSF_TRY)\n\t\temsg(_(e_missing_endtry));\n\t    else if (cstack.cs_flags[cstack.cs_idx] & CSF_WHILE)\n\t\temsg(_(e_missing_endwhile));\n\t    else if (cstack.cs_flags[cstack.cs_idx] & CSF_FOR)\n\t\temsg(_(e_missing_endfor));\n\t    else\n\t\temsg(_(e_missing_endif));\n\t}\n\n\t/*\n\t * Reset \"trylevel\" in case of a \":finish\" or \":return\" or a missing\n\t * \":endtry\" in a sourced file or executed function.  If the try\n\t * conditional is in its finally clause, ignore anything pending.\n\t * If it is in a catch clause, finish the caught exception.\n\t * Also cleanup any \"cs_forinfo\" structures.\n\t */\n\tdo\n\t{\n\t    int idx = cleanup_conditionals(&cstack, 0, TRUE);\n\n\t    if (idx >= 0)\n\t\t--idx;\t    // remove try block not in its finally clause\n\t    rewind_conditionals(&cstack, idx, CSF_WHILE | CSF_FOR,\n\t\t\t\t\t\t\t&cstack.cs_looplevel);\n\t}\n\twhile (cstack.cs_idx >= 0);\n\ttrylevel = initial_trylevel;\n    }\n\n    // If a missing \":endtry\", \":endwhile\", \":endfor\", or \":endif\" or a memory\n    // lack was reported above and the error message is to be converted to an\n    // exception, do this now after rewinding the cstack.\n    do_errthrow(&cstack, getline_equal(fgetline, cookie, get_func_line)\n\t\t\t\t  ? (char_u *)\"endfunction\" : (char_u *)NULL);\n\n    if (trylevel == 0)\n    {\n\t// Just in case did_throw got set but current_exception wasn't.\n\tif (current_exception == NULL)\n\t    did_throw = FALSE;\n\n\t/*\n\t * When an exception is being thrown out of the outermost try\n\t * conditional, discard the uncaught exception, disable the conversion\n\t * of interrupts or errors to exceptions, and ensure that no more\n\t * commands are executed.\n\t */\n\tif (did_throw)\n\t    handle_did_throw();\n\n\t/*\n\t * On an interrupt or an aborting error not converted to an exception,\n\t * disable the conversion of errors to exceptions.  (Interrupts are not\n\t * converted anymore, here.) This enables also the interrupt message\n\t * when force_abort is set and did_emsg unset in case of an interrupt\n\t * from a finally clause after an error.\n\t */\n\telse if (got_int || (did_emsg && force_abort))\n\t    suppress_errthrow = TRUE;\n    }\n\n    /*\n     * The current cstack will be freed when do_cmdline() returns.  An uncaught\n     * exception will have to be rethrown in the previous cstack.  If a function\n     * has just returned or a script file was just finished and the previous\n     * cstack belongs to the same function or, respectively, script file, it\n     * will have to be checked for finally clauses to be executed due to the\n     * \":return\" or \":finish\".  This is done in do_one_cmd().\n     */\n    if (did_throw)\n\tneed_rethrow = TRUE;\n    if ((getline_equal(fgetline, cookie, getsourceline)\n\t\t&& ex_nesting_level > source_level(real_cookie))\n\t    || (getline_equal(fgetline, cookie, get_func_line)\n\t\t&& ex_nesting_level > func_level(real_cookie) + 1))\n    {\n\tif (!did_throw)\n\t    check_cstack = TRUE;\n    }\n    else\n    {\n\t// When leaving a function, reduce nesting level.\n\tif (getline_equal(fgetline, cookie, get_func_line))\n\t    --ex_nesting_level;\n\t/*\n\t * Go to debug mode when returning from a function in which we are\n\t * single-stepping.\n\t */\n\tif ((getline_equal(fgetline, cookie, getsourceline)\n\t\t    || getline_equal(fgetline, cookie, get_func_line))\n\t\t&& ex_nesting_level + 1 <= debug_break_level)\n\t    do_debug(getline_equal(fgetline, cookie, getsourceline)\n\t\t    ? (char_u *)_(\"End of sourced file\")\n\t\t    : (char_u *)_(\"End of function\"));\n    }\n\n    /*\n     * Restore the exception environment (done after returning from the\n     * debugger).\n     */\n    if (flags & DOCMD_EXCRESET)\n\trestore_dbg_stuff(&debug_saved);\n\n    msg_list = saved_msg_list;\n\n    // Cleanup if \"cs_emsg_silent_list\" remains.\n    if (cstack.cs_emsg_silent_list != NULL)\n    {\n\teslist_T *elem, *temp;\n\n\tfor (elem = cstack.cs_emsg_silent_list; elem != NULL; elem = temp)\n\t{\n\t    temp = elem->next;\n\t    vim_free(elem);\n\t}\n    }\n#endif // FEAT_EVAL\n\n    /*\n     * If there was too much output to fit on the command line, ask the user to\n     * hit return before redrawing the screen. With the \":global\" command we do\n     * this only once after the command is finished.\n     */\n    if (did_inc)\n    {\n\t--RedrawingDisabled;\n\t--no_wait_return;\n\tmsg_scroll = FALSE;\n\n\t/*\n\t * When just finished an \":if\"-\":else\" which was typed, no need to\n\t * wait for hit-return.  Also for an error situation.\n\t */\n\tif (retval == FAIL\n#ifdef FEAT_EVAL\n\t\t|| (did_endif && KeyTyped && !did_emsg)\n#endif\n\t\t\t\t\t    )\n\t{\n\t    need_wait_return = FALSE;\n\t    msg_didany = FALSE;\t\t// don't wait when restarting edit\n\t}\n\telse if (need_wait_return)\n\t{\n\t    /*\n\t     * The msg_start() above clears msg_didout. The wait_return() we do\n\t     * here should not overwrite the command that may be shown before\n\t     * doing that.\n\t     */\n\t    msg_didout |= msg_didout_before_start;\n\t    wait_return(FALSE);\n\t}\n    }\n\n#ifdef FEAT_EVAL\n    did_endif = FALSE;  // in case do_cmdline used recursively\n#else\n    /*\n     * Reset if_level, in case a sourced script file contains more \":if\" than\n     * \":endif\" (could be \":if x | foo | endif\").\n     */\n    if_level = 0;\n#endif\n\n    --call_depth;\n    return retval;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 664,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static void atusb_disconnect(struct usb_interface *interface)\n{\n\tstruct atusb *atusb = usb_get_intfdata(interface);\n\n\tdev_dbg(&atusb->usb_dev->dev, \"%s\\n\", __func__);\n\n\tatusb->shutdown = 1;\n\tcancel_delayed_work_sync(&atusb->work);\n\n\tusb_kill_anchored_urbs(&atusb->rx_urbs);\n\tatusb_free_urbs(atusb);\n\tusb_kill_urb(atusb->tx_urb);\n\tusb_free_urb(atusb->tx_urb);\n\n\tieee802154_unregister_hw(atusb->hw);\n\n\tusb_put_dev(atusb->usb_dev);\n\n\tieee802154_free_hw(atusb->hw);\n\n\tusb_set_intfdata(interface, NULL);\n\n\tpr_debug(\"%s done\\n\", __func__);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 674,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "reg_match_visual(void)\n{\n    pos_T\ttop, bot;\n    linenr_T    lnum;\n    colnr_T\tcol;\n    win_T\t*wp = rex.reg_win == NULL ? curwin : rex.reg_win;\n    int\t\tmode;\n    colnr_T\tstart, end;\n    colnr_T\tstart2, end2;\n    colnr_T\tcols;\n    colnr_T\tcurswant;\n\n    // Check if the buffer is the current buffer.\n    if (rex.reg_buf != curbuf || VIsual.lnum == 0)\n\treturn FALSE;\n\n    if (VIsual_active)\n    {\n\tif (LT_POS(VIsual, wp->w_cursor))\n\t{\n\t    top = VIsual;\n\t    bot = wp->w_cursor;\n\t}\n\telse\n\t{\n\t    top = wp->w_cursor;\n\t    bot = VIsual;\n\t}\n\tmode = VIsual_mode;\n\tcurswant = wp->w_curswant;\n    }\n    else\n    {\n\tif (LT_POS(curbuf->b_visual.vi_start, curbuf->b_visual.vi_end))\n\t{\n\t    top = curbuf->b_visual.vi_start;\n\t    bot = curbuf->b_visual.vi_end;\n\t}\n\telse\n\t{\n\t    top = curbuf->b_visual.vi_end;\n\t    bot = curbuf->b_visual.vi_start;\n\t}\n\tmode = curbuf->b_visual.vi_mode;\n\tcurswant = curbuf->b_visual.vi_curswant;\n    }\n    lnum = rex.lnum + rex.reg_firstlnum;\n    if (lnum < top.lnum || lnum > bot.lnum)\n\treturn FALSE;\n\n    col = (colnr_T)(rex.input - rex.line);\n    if (mode == 'v')\n    {\n\tif ((lnum == top.lnum && col < top.col)\n\t\t|| (lnum == bot.lnum && col >= bot.col + (*p_sel != 'e')))\n\t    return FALSE;\n    }\n    else if (mode == Ctrl_V)\n    {\n\tgetvvcol(wp, &top, &start, NULL, &end);\n\tgetvvcol(wp, &bot, &start2, NULL, &end2);\n\tif (start2 < start)\n\t    start = start2;\n\tif (end2 > end)\n\t    end = end2;\n\tif (top.col == MAXCOL || bot.col == MAXCOL || curswant == MAXCOL)\n\t    end = MAXCOL;\n\n\t// getvvcol() flushes rex.line, need to get it again\n\trex.line = reg_getline(rex.lnum);\n\trex.input = rex.line + col;\n\n\tcols = win_linetabsize(wp, rex.line, col);\n\tif (cols < start || cols > end - (*p_sel == 'e'))\n\t    return FALSE;\n    }\n    return TRUE;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 688,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static int tc_new_tfilter(struct sk_buff *skb, struct nlmsghdr *n,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nlattr *tca[TCA_MAX + 1];\n\tchar name[IFNAMSIZ];\n\tstruct tcmsg *t;\n\tu32 protocol;\n\tu32 prio;\n\tbool prio_allocate;\n\tu32 parent;\n\tu32 chain_index;\n\tstruct Qdisc *q;\n\tstruct tcf_chain_info chain_info;\n\tstruct tcf_chain *chain;\n\tstruct tcf_block *block;\n\tstruct tcf_proto *tp;\n\tunsigned long cl;\n\tvoid *fh;\n\tint err;\n\tint tp_created;\n\tbool rtnl_held = false;\n\tu32 flags;\n\n\tif (!netlink_ns_capable(skb, net->user_ns, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\nreplay:\n\ttp_created = 0;\n\n\terr = nlmsg_parse_deprecated(n, sizeof(*t), tca, TCA_MAX,\n\t\t\t\t     rtm_tca_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tt = nlmsg_data(n);\n\tprotocol = TC_H_MIN(t->tcm_info);\n\tprio = TC_H_MAJ(t->tcm_info);\n\tprio_allocate = false;\n\tparent = t->tcm_parent;\n\ttp = NULL;\n\tcl = 0;\n\tblock = NULL;\n\tq = NULL;\n\tchain = NULL;\n\tflags = 0;\n\n\tif (prio == 0) {\n\t\t/* If no priority is provided by the user,\n\t\t * we allocate one.\n\t\t */\n\t\tif (n->nlmsg_flags & NLM_F_CREATE) {\n\t\t\tprio = TC_H_MAKE(0x80000000U, 0U);\n\t\t\tprio_allocate = true;\n\t\t} else {\n\t\t\tNL_SET_ERR_MSG(extack, \"Invalid filter command with priority of zero\");\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\n\t/* Find head of filter chain. */\n\n\terr = __tcf_qdisc_find(net, &q, &parent, t->tcm_ifindex, false, extack);\n\tif (err)\n\t\treturn err;\n\n\tif (tcf_proto_check_kind(tca[TCA_KIND], name)) {\n\t\tNL_SET_ERR_MSG(extack, \"Specified TC filter name too long\");\n\t\terr = -EINVAL;\n\t\tgoto errout;\n\t}\n\n\t/* Take rtnl mutex if rtnl_held was set to true on previous iteration,\n\t * block is shared (no qdisc found), qdisc is not unlocked, classifier\n\t * type is not specified, classifier is not unlocked.\n\t */\n\tif (rtnl_held ||\n\t    (q && !(q->ops->cl_ops->flags & QDISC_CLASS_OPS_DOIT_UNLOCKED)) ||\n\t    !tcf_proto_is_unlocked(name)) {\n\t\trtnl_held = true;\n\t\trtnl_lock();\n\t}\n\n\terr = __tcf_qdisc_cl_find(q, parent, &cl, t->tcm_ifindex, extack);\n\tif (err)\n\t\tgoto errout;\n\n\tblock = __tcf_block_find(net, q, cl, t->tcm_ifindex, t->tcm_block_index,\n\t\t\t\t extack);\n\tif (IS_ERR(block)) {\n\t\terr = PTR_ERR(block);\n\t\tgoto errout;\n\t}\n\tblock->classid = parent;\n\n\tchain_index = tca[TCA_CHAIN] ? nla_get_u32(tca[TCA_CHAIN]) : 0;\n\tif (chain_index > TC_ACT_EXT_VAL_MASK) {\n\t\tNL_SET_ERR_MSG(extack, \"Specified chain index exceeds upper limit\");\n\t\terr = -EINVAL;\n\t\tgoto errout;\n\t}\n\tchain = tcf_chain_get(block, chain_index, true);\n\tif (!chain) {\n\t\tNL_SET_ERR_MSG(extack, \"Cannot create specified filter chain\");\n\t\terr = -ENOMEM;\n\t\tgoto errout;\n\t}\n\n\tmutex_lock(&chain->filter_chain_lock);\n\ttp = tcf_chain_tp_find(chain, &chain_info, protocol,\n\t\t\t       prio, prio_allocate);\n\tif (IS_ERR(tp)) {\n\t\tNL_SET_ERR_MSG(extack, \"Filter with specified priority/protocol not found\");\n\t\terr = PTR_ERR(tp);\n\t\tgoto errout_locked;\n\t}\n\n\tif (tp == NULL) {\n\t\tstruct tcf_proto *tp_new = NULL;\n\n\t\tif (chain->flushing) {\n\t\t\terr = -EAGAIN;\n\t\t\tgoto errout_locked;\n\t\t}\n\n\t\t/* Proto-tcf does not exist, create new one */\n\n\t\tif (tca[TCA_KIND] == NULL || !protocol) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Filter kind and protocol must be specified\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto errout_locked;\n\t\t}\n\n\t\tif (!(n->nlmsg_flags & NLM_F_CREATE)) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Need both RTM_NEWTFILTER and NLM_F_CREATE to create a new filter\");\n\t\t\terr = -ENOENT;\n\t\t\tgoto errout_locked;\n\t\t}\n\n\t\tif (prio_allocate)\n\t\t\tprio = tcf_auto_prio(tcf_chain_tp_prev(chain,\n\t\t\t\t\t\t\t       &chain_info));\n\n\t\tmutex_unlock(&chain->filter_chain_lock);\n\t\ttp_new = tcf_proto_create(name, protocol, prio, chain,\n\t\t\t\t\t  rtnl_held, extack);\n\t\tif (IS_ERR(tp_new)) {\n\t\t\terr = PTR_ERR(tp_new);\n\t\t\tgoto errout_tp;\n\t\t}\n\n\t\ttp_created = 1;\n\t\ttp = tcf_chain_tp_insert_unique(chain, tp_new, protocol, prio,\n\t\t\t\t\t\trtnl_held);\n\t\tif (IS_ERR(tp)) {\n\t\t\terr = PTR_ERR(tp);\n\t\t\tgoto errout_tp;\n\t\t}\n\t} else {\n\t\tmutex_unlock(&chain->filter_chain_lock);\n\t}\n\n\tif (tca[TCA_KIND] && nla_strcmp(tca[TCA_KIND], tp->ops->kind)) {\n\t\tNL_SET_ERR_MSG(extack, \"Specified filter kind does not match existing one\");\n\t\terr = -EINVAL;\n\t\tgoto errout;\n\t}\n\n\tfh = tp->ops->get(tp, t->tcm_handle);\n\n\tif (!fh) {\n\t\tif (!(n->nlmsg_flags & NLM_F_CREATE)) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Need both RTM_NEWTFILTER and NLM_F_CREATE to create a new filter\");\n\t\t\terr = -ENOENT;\n\t\t\tgoto errout;\n\t\t}\n\t} else if (n->nlmsg_flags & NLM_F_EXCL) {\n\t\ttfilter_put(tp, fh);\n\t\tNL_SET_ERR_MSG(extack, \"Filter already exists\");\n\t\terr = -EEXIST;\n\t\tgoto errout;\n\t}\n\n\tif (chain->tmplt_ops && chain->tmplt_ops != tp->ops) {\n\t\tNL_SET_ERR_MSG(extack, \"Chain template is set to a different filter kind\");\n\t\terr = -EINVAL;\n\t\tgoto errout;\n\t}\n\n\tif (!(n->nlmsg_flags & NLM_F_CREATE))\n\t\tflags |= TCA_ACT_FLAGS_REPLACE;\n\tif (!rtnl_held)\n\t\tflags |= TCA_ACT_FLAGS_NO_RTNL;\n\terr = tp->ops->change(net, skb, tp, cl, t->tcm_handle, tca, &fh,\n\t\t\t      flags, extack);\n\tif (err == 0) {\n\t\ttfilter_notify(net, skb, n, tp, block, q, parent, fh,\n\t\t\t       RTM_NEWTFILTER, false, rtnl_held);\n\t\ttfilter_put(tp, fh);\n\t\t/* q pointer is NULL for shared blocks */\n\t\tif (q)\n\t\t\tq->flags &= ~TCQ_F_CAN_BYPASS;\n\t}\n\nerrout:\n\tif (err && tp_created)\n\t\ttcf_chain_tp_delete_empty(chain, tp, rtnl_held, NULL);\nerrout_tp:\n\tif (chain) {\n\t\tif (tp && !IS_ERR(tp))\n\t\t\ttcf_proto_put(tp, rtnl_held, NULL);\n\t\tif (!tp_created)\n\t\t\ttcf_chain_put(chain);\n\t}\n\ttcf_block_release(q, block, rtnl_held);\n\n\tif (rtnl_held)\n\t\trtnl_unlock();\n\n\tif (err == -EAGAIN) {\n\t\t/* Take rtnl lock in case EAGAIN is caused by concurrent flush\n\t\t * of target chain.\n\t\t */\n\t\trtnl_held = true;\n\t\t/* Replay the request. */\n\t\tgoto replay;\n\t}\n\treturn err;\n\nerrout_locked:\n\tmutex_unlock(&chain->filter_chain_lock);\n\tgoto errout;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 718,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "do_tag(\n    char_u\t*tag,\t\t// tag (pattern) to jump to\n    int\t\ttype,\n    int\t\tcount,\n    int\t\tforceit,\t// :ta with !\n    int\t\tverbose)\t// print \"tag not found\" message\n{\n    taggy_T\t*tagstack = curwin->w_tagstack;\n    int\t\ttagstackidx = curwin->w_tagstackidx;\n    int\t\ttagstacklen = curwin->w_tagstacklen;\n    int\t\tcur_match = 0;\n    int\t\tcur_fnum = curbuf->b_fnum;\n    int\t\toldtagstackidx = tagstackidx;\n    int\t\tprevtagstackidx = tagstackidx;\n    int\t\tprev_num_matches;\n    int\t\tnew_tag = FALSE;\n    int\t\ti;\n    int\t\tic;\n    int\t\tno_regexp = FALSE;\n    int\t\terror_cur_match = 0;\n    int\t\tsave_pos = FALSE;\n    fmark_T\tsaved_fmark;\n#ifdef FEAT_CSCOPE\n    int\t\tjumped_to_tag = FALSE;\n#endif\n    int\t\tnew_num_matches;\n    char_u\t**new_matches;\n    int\t\tuse_tagstack;\n    int\t\tskip_msg = FALSE;\n    char_u\t*buf_ffname = curbuf->b_ffname;\t    // name to use for\n\t\t\t\t\t\t    // priority computation\n    int\t\tuse_tfu = 1;\n    char_u\t*tofree = NULL;\n\n    // remember the matches for the last used tag\n    static int\t\tnum_matches = 0;\n    static int\t\tmax_num_matches = 0;  // limit used for match search\n    static char_u\t**matches = NULL;\n    static int\t\tflags;\n\n#ifdef FEAT_EVAL\n    if (tfu_in_use)\n    {\n\temsg(_(e_cannot_modify_tag_stack_within_tagfunc));\n\treturn FALSE;\n    }\n#endif\n\n#ifdef EXITFREE\n    if (type == DT_FREE)\n    {\n\t// remove the list of matches\n\tFreeWild(num_matches, matches);\n# ifdef FEAT_CSCOPE\n\tcs_free_tags();\n# endif\n\tnum_matches = 0;\n\treturn FALSE;\n    }\n#endif\n\n    if (type == DT_HELP)\n    {\n\ttype = DT_TAG;\n\tno_regexp = TRUE;\n\tuse_tfu = 0;\n    }\n\n    prev_num_matches = num_matches;\n    free_string_option(nofile_fname);\n    nofile_fname = NULL;\n\n    CLEAR_POS(&saved_fmark.mark);\t// shutup gcc 4.0\n    saved_fmark.fnum = 0;\n\n    /*\n     * Don't add a tag to the tagstack if 'tagstack' has been reset.\n     */\n    if ((!p_tgst && *tag != NUL))\n    {\n\tuse_tagstack = FALSE;\n\tnew_tag = TRUE;\n#if defined(FEAT_QUICKFIX)\n\tif (g_do_tagpreview != 0)\n\t{\n\t    tagstack_clear_entry(&ptag_entry);\n\t    if ((ptag_entry.tagname = vim_strsave(tag)) == NULL)\n\t\tgoto end_do_tag;\n\t}\n#endif\n    }\n    else\n    {\n#if defined(FEAT_QUICKFIX)\n\tif (g_do_tagpreview != 0)\n\t    use_tagstack = FALSE;\n\telse\n#endif\n\t    use_tagstack = TRUE;\n\n\t// new pattern, add to the tag stack\n\tif (*tag != NUL\n\t\t&& (type == DT_TAG || type == DT_SELECT || type == DT_JUMP\n#ifdef FEAT_QUICKFIX\n\t\t    || type == DT_LTAG\n#endif\n#ifdef FEAT_CSCOPE\n\t\t    || type == DT_CSCOPE\n#endif\n\t\t    ))\n\t{\n#if defined(FEAT_QUICKFIX)\n\t    if (g_do_tagpreview != 0)\n\t    {\n\t\tif (ptag_entry.tagname != NULL\n\t\t\t&& STRCMP(ptag_entry.tagname, tag) == 0)\n\t\t{\n\t\t    // Jumping to same tag: keep the current match, so that\n\t\t    // the CursorHold autocommand example works.\n\t\t    cur_match = ptag_entry.cur_match;\n\t\t    cur_fnum = ptag_entry.cur_fnum;\n\t\t}\n\t\telse\n\t\t{\n\t\t    tagstack_clear_entry(&ptag_entry);\n\t\t    if ((ptag_entry.tagname = vim_strsave(tag)) == NULL)\n\t\t\tgoto end_do_tag;\n\t\t}\n\t    }\n\t    else\n#endif\n\t    {\n\t\t/*\n\t\t * If the last used entry is not at the top, delete all tag\n\t\t * stack entries above it.\n\t\t */\n\t\twhile (tagstackidx < tagstacklen)\n\t\t    tagstack_clear_entry(&tagstack[--tagstacklen]);\n\n\t\t// if the tagstack is full: remove oldest entry\n\t\tif (++tagstacklen > TAGSTACKSIZE)\n\t\t{\n\t\t    tagstacklen = TAGSTACKSIZE;\n\t\t    tagstack_clear_entry(&tagstack[0]);\n\t\t    for (i = 1; i < tagstacklen; ++i)\n\t\t\ttagstack[i - 1] = tagstack[i];\n\t\t    --tagstackidx;\n\t\t}\n\n\t\t/*\n\t\t * put the tag name in the tag stack\n\t\t */\n\t\tif ((tagstack[tagstackidx].tagname = vim_strsave(tag)) == NULL)\n\t\t{\n\t\t    curwin->w_tagstacklen = tagstacklen - 1;\n\t\t    goto end_do_tag;\n\t\t}\n\t\tcurwin->w_tagstacklen = tagstacklen;\n\n\t\tsave_pos = TRUE;\t// save the cursor position below\n\t    }\n\n\t    new_tag = TRUE;\n\t}\n\telse\n\t{\n\t    if (\n#if defined(FEAT_QUICKFIX)\n\t\t    g_do_tagpreview != 0 ? ptag_entry.tagname == NULL :\n#endif\n\t\t    tagstacklen == 0)\n\t    {\n\t\t// empty stack\n\t\temsg(_(e_tag_stack_empty));\n\t\tgoto end_do_tag;\n\t    }\n\n\t    if (type == DT_POP)\t\t// go to older position\n\t    {\n#ifdef FEAT_FOLDING\n\t\tint\told_KeyTyped = KeyTyped;\n#endif\n\t\tif ((tagstackidx -= count) < 0)\n\t\t{\n\t\t    emsg(_(e_at_bottom_of_tag_stack));\n\t\t    if (tagstackidx + count == 0)\n\t\t    {\n\t\t\t// We did [num]^T from the bottom of the stack\n\t\t\ttagstackidx = 0;\n\t\t\tgoto end_do_tag;\n\t\t    }\n\t\t    // We weren't at the bottom of the stack, so jump all the\n\t\t    // way to the bottom now.\n\t\t    tagstackidx = 0;\n\t\t}\n\t\telse if (tagstackidx >= tagstacklen)    // count == 0?\n\t\t{\n\t\t    emsg(_(e_at_top_of_tag_stack));\n\t\t    goto end_do_tag;\n\t\t}\n\n\t\t// Make a copy of the fmark, autocommands may invalidate the\n\t\t// tagstack before it's used.\n\t\tsaved_fmark = tagstack[tagstackidx].fmark;\n\t\tif (saved_fmark.fnum != curbuf->b_fnum)\n\t\t{\n\t\t    /*\n\t\t     * Jump to other file. If this fails (e.g. because the\n\t\t     * file was changed) keep original position in tag stack.\n\t\t     */\n\t\t    if (buflist_getfile(saved_fmark.fnum, saved_fmark.mark.lnum,\n\t\t\t\t\t       GETF_SETMARK, forceit) == FAIL)\n\t\t    {\n\t\t\ttagstackidx = oldtagstackidx;  // back to old posn\n\t\t\tgoto end_do_tag;\n\t\t    }\n\t\t    // An BufReadPost autocommand may jump to the '\" mark, but\n\t\t    // we don't what that here.\n\t\t    curwin->w_cursor.lnum = saved_fmark.mark.lnum;\n\t\t}\n\t\telse\n\t\t{\n\t\t    setpcmark();\n\t\t    curwin->w_cursor.lnum = saved_fmark.mark.lnum;\n\t\t}\n\t\tcurwin->w_cursor.col = saved_fmark.mark.col;\n\t\tcurwin->w_set_curswant = TRUE;\n\t\tcheck_cursor();\n#ifdef FEAT_FOLDING\n\t\tif ((fdo_flags & FDO_TAG) && old_KeyTyped)\n\t\t    foldOpenCursor();\n#endif\n\n\t\t// remove the old list of matches\n\t\tFreeWild(num_matches, matches);\n#ifdef FEAT_CSCOPE\n\t\tcs_free_tags();\n#endif\n\t\tnum_matches = 0;\n\t\ttag_freematch();\n\t\tgoto end_do_tag;\n\t    }\n\n\t    if (type == DT_TAG\n#if defined(FEAT_QUICKFIX)\n\t\t    || type == DT_LTAG\n#endif\n\t       )\n\t    {\n#if defined(FEAT_QUICKFIX)\n\t\tif (g_do_tagpreview != 0)\n\t\t{\n\t\t    cur_match = ptag_entry.cur_match;\n\t\t    cur_fnum = ptag_entry.cur_fnum;\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t    // \":tag\" (no argument): go to newer pattern\n\t\t    save_pos = TRUE;\t// save the cursor position below\n\t\t    if ((tagstackidx += count - 1) >= tagstacklen)\n\t\t    {\n\t\t\t/*\n\t\t\t * Beyond the last one, just give an error message and\n\t\t\t * go to the last one.  Don't store the cursor\n\t\t\t * position.\n\t\t\t */\n\t\t\ttagstackidx = tagstacklen - 1;\n\t\t\temsg(_(e_at_top_of_tag_stack));\n\t\t\tsave_pos = FALSE;\n\t\t    }\n\t\t    else if (tagstackidx < 0)\t// must have been count == 0\n\t\t    {\n\t\t\temsg(_(e_at_bottom_of_tag_stack));\n\t\t\ttagstackidx = 0;\n\t\t\tgoto end_do_tag;\n\t\t    }\n\t\t    cur_match = tagstack[tagstackidx].cur_match;\n\t\t    cur_fnum = tagstack[tagstackidx].cur_fnum;\n\t\t}\n\t\tnew_tag = TRUE;\n\t    }\n\t    else\t\t\t\t// go to other matching tag\n\t    {\n\t\t// Save index for when selection is cancelled.\n\t\tprevtagstackidx = tagstackidx;\n\n#if defined(FEAT_QUICKFIX)\n\t\tif (g_do_tagpreview != 0)\n\t\t{\n\t\t    cur_match = ptag_entry.cur_match;\n\t\t    cur_fnum = ptag_entry.cur_fnum;\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t    if (--tagstackidx < 0)\n\t\t\ttagstackidx = 0;\n\t\t    cur_match = tagstack[tagstackidx].cur_match;\n\t\t    cur_fnum = tagstack[tagstackidx].cur_fnum;\n\t\t}\n\t\tswitch (type)\n\t\t{\n\t\t    case DT_FIRST: cur_match = count - 1; break;\n\t\t    case DT_SELECT:\n\t\t    case DT_JUMP:\n#ifdef FEAT_CSCOPE\n\t\t    case DT_CSCOPE:\n#endif\n\t\t    case DT_LAST:  cur_match = MAXCOL - 1; break;\n\t\t    case DT_NEXT:  cur_match += count; break;\n\t\t    case DT_PREV:  cur_match -= count; break;\n\t\t}\n\t\tif (cur_match >= MAXCOL)\n\t\t    cur_match = MAXCOL - 1;\n\t\telse if (cur_match < 0)\n\t\t{\n\t\t    emsg(_(e_cannot_go_before_first_matching_tag));\n\t\t    skip_msg = TRUE;\n\t\t    cur_match = 0;\n\t\t    cur_fnum = curbuf->b_fnum;\n\t\t}\n\t    }\n\t}\n\n#if defined(FEAT_QUICKFIX)\n\tif (g_do_tagpreview != 0)\n\t{\n\t    if (type != DT_SELECT && type != DT_JUMP)\n\t    {\n\t\tptag_entry.cur_match = cur_match;\n\t\tptag_entry.cur_fnum = cur_fnum;\n\t    }\n\t}\n\telse\n#endif\n\t{\n\t    /*\n\t     * For \":tag [arg]\" or \":tselect\" remember position before the jump.\n\t     */\n\t    saved_fmark = tagstack[tagstackidx].fmark;\n\t    if (save_pos)\n\t    {\n\t\ttagstack[tagstackidx].fmark.mark = curwin->w_cursor;\n\t\ttagstack[tagstackidx].fmark.fnum = curbuf->b_fnum;\n\t    }\n\n\t    // Curwin will change in the call to jumpto_tag() if \":stag\" was\n\t    // used or an autocommand jumps to another window; store value of\n\t    // tagstackidx now.\n\t    curwin->w_tagstackidx = tagstackidx;\n\t    if (type != DT_SELECT && type != DT_JUMP)\n\t    {\n\t\tcurwin->w_tagstack[tagstackidx].cur_match = cur_match;\n\t\tcurwin->w_tagstack[tagstackidx].cur_fnum = cur_fnum;\n\t    }\n\t}\n    }\n\n    // When not using the current buffer get the name of buffer \"cur_fnum\".\n    // Makes sure that the tag order doesn't change when using a remembered\n    // position for \"cur_match\".\n    if (cur_fnum != curbuf->b_fnum)\n    {\n\tbuf_T *buf = buflist_findnr(cur_fnum);\n\n\tif (buf != NULL)\n\t    buf_ffname = buf->b_ffname;\n    }\n\n    /*\n     * Repeat searching for tags, when a file has not been found.\n     */\n    for (;;)\n    {\n\tint\tother_name;\n\tchar_u\t*name;\n\n\t/*\n\t * When desired match not found yet, try to find it (and others).\n\t */\n\tif (use_tagstack)\n\t{\n\t    // make a copy, the tagstack may change in 'tagfunc'\n\t    name = vim_strsave(tagstack[tagstackidx].tagname);\n\t    vim_free(tofree);\n\t    tofree = name;\n\t}\n#if defined(FEAT_QUICKFIX)\n\telse if (g_do_tagpreview != 0)\n\t    name = ptag_entry.tagname;\n#endif\n\telse\n\t    name = tag;\n\tother_name = (tagmatchname == NULL || STRCMP(tagmatchname, name) != 0);\n\tif (new_tag\n\t\t|| (cur_match >= num_matches && max_num_matches != MAXCOL)\n\t\t|| other_name)\n\t{\n\t    if (other_name)\n\t    {\n\t\tvim_free(tagmatchname);\n\t\ttagmatchname = vim_strsave(name);\n\t    }\n\n\t    if (type == DT_SELECT || type == DT_JUMP\n#if defined(FEAT_QUICKFIX)\n\t\t|| type == DT_LTAG\n#endif\n\t\t)\n\t\tcur_match = MAXCOL - 1;\n\t    if (type == DT_TAG)\n\t\tmax_num_matches = MAXCOL;\n\t    else\n\t\tmax_num_matches = cur_match + 1;\n\n\t    // when the argument starts with '/', use it as a regexp\n\t    if (!no_regexp && *name == '/')\n\t    {\n\t\tflags = TAG_REGEXP;\n\t\t++name;\n\t    }\n\t    else\n\t\tflags = TAG_NOIC;\n\n#ifdef FEAT_CSCOPE\n\t    if (type == DT_CSCOPE)\n\t\tflags = TAG_CSCOPE;\n#endif\n\t    if (verbose)\n\t\tflags |= TAG_VERBOSE;\n\n\t    if (!use_tfu)\n\t\tflags |= TAG_NO_TAGFUNC;\n\n\t    if (find_tags(name, &new_num_matches, &new_matches, flags,\n\t\t\t\t\t    max_num_matches, buf_ffname) == OK\n\t\t    && new_num_matches < max_num_matches)\n\t\tmax_num_matches = MAXCOL; // If less than max_num_matches\n\t\t\t\t\t  // found: all matches found.\n\n\t    // A tag function may do anything, which may cause various\n\t    // information to become invalid.  At least check for the tagstack\n\t    // to still be the same.\n\t    if (tagstack != curwin->w_tagstack)\n\t    {\n\t\temsg(_(e_window_unexpectedly_close_while_searching_for_tags));\n\t\tFreeWild(new_num_matches, new_matches);\n\t\tbreak;\n\t    }\n\n\t    // If there already were some matches for the same name, move them\n\t    // to the start.  Avoids that the order changes when using\n\t    // \":tnext\" and jumping to another file.\n\t    if (!new_tag && !other_name)\n\t    {\n\t\tint\t    j, k;\n\t\tint\t    idx = 0;\n\t\ttagptrs_T   tagp, tagp2;\n\n\t\t// Find the position of each old match in the new list.  Need\n\t\t// to use parse_match() to find the tag line.\n\t\tfor (j = 0; j < num_matches; ++j)\n\t\t{\n\t\t    parse_match(matches[j], &tagp);\n\t\t    for (i = idx; i < new_num_matches; ++i)\n\t\t    {\n\t\t\tparse_match(new_matches[i], &tagp2);\n\t\t\tif (STRCMP(tagp.tagname, tagp2.tagname) == 0)\n\t\t\t{\n\t\t\t    char_u *p = new_matches[i];\n\t\t\t    for (k = i; k > idx; --k)\n\t\t\t\tnew_matches[k] = new_matches[k - 1];\n\t\t\t    new_matches[idx++] = p;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    FreeWild(num_matches, matches);\n\t    num_matches = new_num_matches;\n\t    matches = new_matches;\n\t}\n\n\tif (num_matches <= 0)\n\t{\n\t    if (verbose)\n\t\tsemsg(_(e_tag_not_found_str), name);\n#if defined(FEAT_QUICKFIX)\n\t    g_do_tagpreview = 0;\n#endif\n\t}\n\telse\n\t{\n\t    int ask_for_selection = FALSE;\n\n#ifdef FEAT_CSCOPE\n\t    if (type == DT_CSCOPE && num_matches > 1)\n\t    {\n\t\tcs_print_tags();\n\t\task_for_selection = TRUE;\n\t    }\n\t    else\n#endif\n\t    if (type == DT_TAG && *tag != NUL)\n\t\t// If a count is supplied to the \":tag <name>\" command, then\n\t\t// jump to count'th matching tag.\n\t\tcur_match = count > 0 ? count - 1 : 0;\n\t    else if (type == DT_SELECT || (type == DT_JUMP && num_matches > 1))\n\t    {\n\t\tprint_tag_list(new_tag, use_tagstack, num_matches, matches);\n\t\task_for_selection = TRUE;\n\t    }\n#if defined(FEAT_QUICKFIX) && defined(FEAT_EVAL)\n\t    else if (type == DT_LTAG)\n\t    {\n\t\tif (add_llist_tags(tag, num_matches, matches) == FAIL)\n\t\t    goto end_do_tag;\n\t\tcur_match = 0;\t\t// Jump to the first tag\n\t    }\n#endif\n\n\t    if (ask_for_selection == TRUE)\n\t    {\n\t\t/*\n\t\t * Ask to select a tag from the list.\n\t\t */\n\t\ti = prompt_for_number(NULL);\n\t\tif (i <= 0 || i > num_matches || got_int)\n\t\t{\n\t\t    // no valid choice: don't change anything\n\t\t    if (use_tagstack)\n\t\t    {\n\t\t\ttagstack[tagstackidx].fmark = saved_fmark;\n\t\t\ttagstackidx = prevtagstackidx;\n\t\t    }\n#ifdef FEAT_CSCOPE\n\t\t    cs_free_tags();\n\t\t    jumped_to_tag = TRUE;\n#endif\n\t\t    break;\n\t\t}\n\t\tcur_match = i - 1;\n\t    }\n\n\t    if (cur_match >= num_matches)\n\t    {\n\t\t// Avoid giving this error when a file wasn't found and we're\n\t\t// looking for a match in another file, which wasn't found.\n\t\t// There will be an emsg(\"file doesn't exist\") below then.\n\t\tif ((type == DT_NEXT || type == DT_FIRST)\n\t\t\t\t\t\t      && nofile_fname == NULL)\n\t\t{\n\t\t    if (num_matches == 1)\n\t\t\temsg(_(e_there_is_only_one_matching_tag));\n\t\t    else\n\t\t\temsg(_(e_cannot_go_beyond_last_matching_tag));\n\t\t    skip_msg = TRUE;\n\t\t}\n\t\tcur_match = num_matches - 1;\n\t    }\n\t    if (use_tagstack)\n\t    {\n\t\ttagptrs_T   tagp;\n\n\t\ttagstack[tagstackidx].cur_match = cur_match;\n\t\ttagstack[tagstackidx].cur_fnum = cur_fnum;\n\n\t\t// store user-provided data originating from tagfunc\n\t\tif (use_tfu && parse_match(matches[cur_match], &tagp) == OK\n\t\t\t&& tagp.user_data)\n\t\t{\n\t\t    VIM_CLEAR(tagstack[tagstackidx].user_data);\n\t\t    tagstack[tagstackidx].user_data = vim_strnsave(\n\t\t\t  tagp.user_data, tagp.user_data_end - tagp.user_data);\n\t\t}\n\n\t\t++tagstackidx;\n\t    }\n#if defined(FEAT_QUICKFIX)\n\t    else if (g_do_tagpreview != 0)\n\t    {\n\t\tptag_entry.cur_match = cur_match;\n\t\tptag_entry.cur_fnum = cur_fnum;\n\t    }\n#endif\n\n\t    /*\n\t     * Only when going to try the next match, report that the previous\n\t     * file didn't exist.  Otherwise an emsg() is given below.\n\t     */\n\t    if (nofile_fname != NULL && error_cur_match != cur_match)\n\t\tsmsg(_(\"File \\\"%s\\\" does not exist\"), nofile_fname);\n\n\n\t    ic = (matches[cur_match][0] & MT_IC_OFF);\n\t    if (type != DT_TAG && type != DT_SELECT && type != DT_JUMP\n#ifdef FEAT_CSCOPE\n\t\t&& type != DT_CSCOPE\n#endif\n\t\t&& (num_matches > 1 || ic)\n\t\t&& !skip_msg)\n\t    {\n\t\t// Give an indication of the number of matching tags\n\t\tsprintf((char *)IObuff, _(\"tag %d of %d%s\"),\n\t\t\t\tcur_match + 1,\n\t\t\t\tnum_matches,\n\t\t\t\tmax_num_matches != MAXCOL ? _(\" or more\") : \"\");\n\t\tif (ic)\n\t\t    STRCAT(IObuff, _(\"  Using tag with different case!\"));\n\t\tif ((num_matches > prev_num_matches || new_tag)\n\t\t\t\t\t\t\t   && num_matches > 1)\n\t\t{\n\t\t    if (ic)\n\t\t\tmsg_attr((char *)IObuff, HL_ATTR(HLF_W));\n\t\t    else\n\t\t\tmsg((char *)IObuff);\n\t\t    msg_scroll = TRUE;\t// don't overwrite this message\n\t\t}\n\t\telse\n\t\t    give_warning(IObuff, ic);\n\t\tif (ic && !msg_scrolled && msg_silent == 0)\n\t\t{\n\t\t    out_flush();\n\t\t    ui_delay(1007L, TRUE);\n\t\t}\n\t    }\n\n#if defined(FEAT_EVAL)\n\t    // Let the SwapExists event know what tag we are jumping to.\n\t    vim_snprintf((char *)IObuff, IOSIZE, \":ta %s\\r\", name);\n\t    set_vim_var_string(VV_SWAPCOMMAND, IObuff, -1);\n#endif\n\n\t    /*\n\t     * Jump to the desired match.\n\t     */\n\t    i = jumpto_tag(matches[cur_match], forceit, type != DT_CSCOPE);\n\n#if defined(FEAT_EVAL)\n\t    set_vim_var_string(VV_SWAPCOMMAND, NULL, -1);\n#endif\n\n\t    if (i == NOTAGFILE)\n\t    {\n\t\t// File not found: try again with another matching tag\n\t\tif ((type == DT_PREV && cur_match > 0)\n\t\t\t|| ((type == DT_TAG || type == DT_NEXT\n\t\t\t\t\t\t\t  || type == DT_FIRST)\n\t\t\t    && (max_num_matches != MAXCOL\n\t\t\t\t\t     || cur_match < num_matches - 1)))\n\t\t{\n\t\t    error_cur_match = cur_match;\n\t\t    if (use_tagstack)\n\t\t\t--tagstackidx;\n\t\t    if (type == DT_PREV)\n\t\t\t--cur_match;\n\t\t    else\n\t\t    {\n\t\t\ttype = DT_NEXT;\n\t\t\t++cur_match;\n\t\t    }\n\t\t    continue;\n\t\t}\n\t\tsemsg(_(e_file_str_does_not_exist), nofile_fname);\n\t    }\n\t    else\n\t    {\n\t\t// We may have jumped to another window, check that\n\t\t// tagstackidx is still valid.\n\t\tif (use_tagstack && tagstackidx > curwin->w_tagstacklen)\n\t\t    tagstackidx = curwin->w_tagstackidx;\n#ifdef FEAT_CSCOPE\n\t\tjumped_to_tag = TRUE;\n#endif\n\t    }\n\t}\n\tbreak;\n    }\n\nend_do_tag:\n    // Only store the new index when using the tagstack and it's valid.\n    if (use_tagstack && tagstackidx <= curwin->w_tagstacklen)\n\tcurwin->w_tagstackidx = tagstackidx;\n    postponed_split = 0;\t// don't split next time\n# ifdef FEAT_QUICKFIX\n    g_do_tagpreview = 0;\t// don't do tag preview next time\n# endif\n\n    vim_free(tofree);\n#ifdef FEAT_CSCOPE\n    return jumped_to_tag;\n#else\n    return FALSE;\n#endif\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 720,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "qf_fill_buffer(qf_list_T *qfl, buf_T *buf, qfline_T *old_last, int qf_winid)\n{\n    linenr_T\tlnum;\n    qfline_T\t*qfp;\n    int\t\told_KeyTyped = KeyTyped;\n    list_T\t*qftf_list = NULL;\n    listitem_T\t*qftf_li = NULL;\n\n    if (old_last == NULL)\n    {\n\tif (buf != curbuf)\n\t{\n\t    internal_error(\"qf_fill_buffer()\");\n\t    return;\n\t}\n\n\t// delete all existing lines\n\twhile ((curbuf->b_ml.ml_flags & ML_EMPTY) == 0)\n\t    (void)ml_delete((linenr_T)1);\n    }\n\n    // Check if there is anything to display\n    if (qfl != NULL && qfl->qf_start != NULL)\n    {\n\tchar_u\t\tdirname[MAXPATHL];\n\tint\t\tinvalid_val = FALSE;\n\tint\t\tprev_bufnr = -1;\n\n\t*dirname = NUL;\n\n\t// Add one line for each error\n\tif (old_last == NULL)\n\t{\n\t    qfp = qfl->qf_start;\n\t    lnum = 0;\n\t}\n\telse\n\t{\n\t    if (old_last->qf_next != NULL)\n\t\tqfp = old_last->qf_next;\n\t    else\n\t\tqfp = old_last;\n\t    lnum = buf->b_ml.ml_line_count;\n\t}\n\n\tqftf_list = call_qftf_func(qfl, qf_winid, (long)(lnum + 1),\n\t\t\t\t\t\t\t(long)qfl->qf_count);\n\tif (qftf_list != NULL)\n\t    qftf_li = qftf_list->lv_first;\n\n\twhile (lnum < qfl->qf_count)\n\t{\n\t    char_u\t*qftf_str = NULL;\n\n\t    // Use the text supplied by the user defined function (if any).\n\t    // If the returned value is not string, then ignore the rest\n\t    // of the returned values and use the default.\n\t    if (qftf_li != NULL && !invalid_val)\n\t    {\n\t\tqftf_str = tv_get_string_chk(&qftf_li->li_tv);\n\t\tif (qftf_str == NULL)\n\t\t    invalid_val = TRUE;\n\t    }\n\n\t    if (qf_buf_add_line(buf, lnum, qfp, dirname,\n\t\t\tprev_bufnr != qfp->qf_fnum, qftf_str) == FAIL)\n\t\tbreak;\n\n\t    prev_bufnr = qfp->qf_fnum;\n\t    ++lnum;\n\t    qfp = qfp->qf_next;\n\t    if (qfp == NULL)\n\t\tbreak;\n\n\t    if (qftf_li != NULL)\n\t\tqftf_li = qftf_li->li_next;\n\t}\n\n\tif (old_last == NULL)\n\t    // Delete the empty line which is now at the end\n\t    (void)ml_delete(lnum + 1);\n    }\n\n    // correct cursor position\n    check_lnums(TRUE);\n\n    if (old_last == NULL)\n    {\n\t// Set the 'filetype' to \"qf\" each time after filling the buffer.\n\t// This resembles reading a file into a buffer, it's more logical when\n\t// using autocommands.\n\t++curbuf_lock;\n\tset_option_value_give_err((char_u *)\"ft\",\n\t\t\t\t\t\t0L, (char_u *)\"qf\", OPT_LOCAL);\n\tcurbuf->b_p_ma = FALSE;\n\n\tkeep_filetype = TRUE;\t\t// don't detect 'filetype'\n\tapply_autocmds(EVENT_BUFREADPOST, (char_u *)\"quickfix\", NULL,\n\t\t\t\t\t\t\t       FALSE, curbuf);\n\tapply_autocmds(EVENT_BUFWINENTER, (char_u *)\"quickfix\", NULL,\n\t\t\t\t\t\t\t       FALSE, curbuf);\n\tkeep_filetype = FALSE;\n\t--curbuf_lock;\n\n\t// make sure it will be redrawn\n\tredraw_curbuf_later(UPD_NOT_VALID);\n    }\n\n    // Restore KeyTyped, setting 'filetype' may reset it.\n    KeyTyped = old_KeyTyped;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 732,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "void nfcmrvl_nci_unregister_dev(struct nfcmrvl_private *priv)\n{\n\tstruct nci_dev *ndev = priv->ndev;\n\n\tnci_unregister_device(ndev);\n\tif (priv->ndev->nfc_dev->fw_download_in_progress)\n\t\tnfcmrvl_fw_dnld_abort(priv);\n\n\tnfcmrvl_fw_dnld_deinit(priv);\n\n\tif (gpio_is_valid(priv->config.reset_n_io))\n\t\tgpio_free(priv->config.reset_n_io);\n\n\tnci_free_device(ndev);\n\tkfree(priv);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 744,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "int cgroup1_parse_param(struct fs_context *fc, struct fs_parameter *param)\n{\n\tstruct cgroup_fs_context *ctx = cgroup_fc2context(fc);\n\tstruct cgroup_subsys *ss;\n\tstruct fs_parse_result result;\n\tint opt, i;\n\n\topt = fs_parse(fc, cgroup1_fs_parameters, param, &result);\n\tif (opt == -ENOPARAM) {\n\t\tif (strcmp(param->key, \"source\") == 0) {\n\t\t\tif (param->type != fs_value_is_string)\n\t\t\t\treturn invalf(fc, \"Non-string source\");\n\t\t\tif (fc->source)\n\t\t\t\treturn invalf(fc, \"Multiple sources not supported\");\n\t\t\tfc->source = param->string;\n\t\t\tparam->string = NULL;\n\t\t\treturn 0;\n\t\t}\n\t\tfor_each_subsys(ss, i) {\n\t\t\tif (strcmp(param->key, ss->legacy_name))\n\t\t\t\tcontinue;\n\t\t\tif (!cgroup_ssid_enabled(i) || cgroup1_ssid_disabled(i))\n\t\t\t\treturn invalfc(fc, \"Disabled controller '%s'\",\n\t\t\t\t\t       param->key);\n\t\t\tctx->subsys_mask |= (1 << i);\n\t\t\treturn 0;\n\t\t}\n\t\treturn invalfc(fc, \"Unknown subsys name '%s'\", param->key);\n\t}\n\tif (opt < 0)\n\t\treturn opt;\n\n\tswitch (opt) {\n\tcase Opt_none:\n\t\t/* Explicitly have no subsystems */\n\t\tctx->none = true;\n\t\tbreak;\n\tcase Opt_all:\n\t\tctx->all_ss = true;\n\t\tbreak;\n\tcase Opt_noprefix:\n\t\tctx->flags |= CGRP_ROOT_NOPREFIX;\n\t\tbreak;\n\tcase Opt_clone_children:\n\t\tctx->cpuset_clone_children = true;\n\t\tbreak;\n\tcase Opt_cpuset_v2_mode:\n\t\tctx->flags |= CGRP_ROOT_CPUSET_V2_MODE;\n\t\tbreak;\n\tcase Opt_xattr:\n\t\tctx->flags |= CGRP_ROOT_XATTR;\n\t\tbreak;\n\tcase Opt_release_agent:\n\t\t/* Specifying two release agents is forbidden */\n\t\tif (ctx->release_agent)\n\t\t\treturn invalfc(fc, \"release_agent respecified\");\n\t\tctx->release_agent = param->string;\n\t\tparam->string = NULL;\n\t\tbreak;\n\tcase Opt_name:\n\t\t/* blocked by boot param? */\n\t\tif (cgroup_no_v1_named)\n\t\t\treturn -ENOENT;\n\t\t/* Can't specify an empty name */\n\t\tif (!param->size)\n\t\t\treturn invalfc(fc, \"Empty name\");\n\t\tif (param->size > MAX_CGROUP_ROOT_NAMELEN - 1)\n\t\t\treturn invalfc(fc, \"Name too long\");\n\t\t/* Must match [\\w.-]+ */\n\t\tfor (i = 0; i < param->size; i++) {\n\t\t\tchar c = param->string[i];\n\t\t\tif (isalnum(c))\n\t\t\t\tcontinue;\n\t\t\tif ((c == '.') || (c == '-') || (c == '_'))\n\t\t\t\tcontinue;\n\t\t\treturn invalfc(fc, \"Invalid name\");\n\t\t}\n\t\t/* Specifying two names is forbidden */\n\t\tif (ctx->name)\n\t\t\treturn invalfc(fc, \"name respecified\");\n\t\tctx->name = param->string;\n\t\tparam->string = NULL;\n\t\tbreak;\n\t}\n\treturn 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 750,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "bool open_table(THD *thd, TABLE_LIST *table_list, Open_table_context *ot_ctx)\n{\n  TABLE *table;\n  const char *key;\n  uint\tkey_length;\n  const char *alias= table_list->alias.str;\n  uint flags= ot_ctx->get_flags();\n  MDL_ticket *mdl_ticket;\n  TABLE_SHARE *share;\n  uint gts_flags;\n  bool from_share= false;\n#ifdef WITH_PARTITION_STORAGE_ENGINE\n  int part_names_error=0;\n#endif\n  DBUG_ENTER(\"open_table\");\n\n  /*\n    The table must not be opened already. The table can be pre-opened for\n    some statements if it is a temporary table.\n\n    open_temporary_table() must be used to open temporary tables.\n  */\n  DBUG_ASSERT(!table_list->table);\n\n  /* an open table operation needs a lot of the stack space */\n  if (check_stack_overrun(thd, STACK_MIN_SIZE_FOR_OPEN, (uchar *)&alias))\n    DBUG_RETURN(TRUE);\n\n  if (!(flags & MYSQL_OPEN_IGNORE_KILLED) && thd->killed)\n  {\n    thd->send_kill_message();\n    DBUG_RETURN(TRUE);\n  }\n\n  /*\n    Check if we're trying to take a write lock in a read only transaction.\n\n    Note that we allow write locks on log tables as otherwise logging\n    to general/slow log would be disabled in read only transactions.\n  */\n  if (table_list->mdl_request.is_write_lock_request() &&\n      thd->tx_read_only &&\n      !(flags & (MYSQL_LOCK_LOG_TABLE | MYSQL_OPEN_HAS_MDL_LOCK)))\n  {\n    my_error(ER_CANT_EXECUTE_IN_READ_ONLY_TRANSACTION, MYF(0));\n    DBUG_RETURN(true);\n  }\n\n  if (!table_list->db.str)\n  {\n    my_error(ER_NO_DB_ERROR, MYF(0));\n    DBUG_RETURN(true);\n  }\n\n  key_length= get_table_def_key(table_list, &key);\n\n  /*\n    If we're in pre-locked or LOCK TABLES mode, let's try to find the\n    requested table in the list of pre-opened and locked tables. If the\n    table is not there, return an error - we can't open not pre-opened\n    tables in pre-locked/LOCK TABLES mode.\n    TODO: move this block into a separate function.\n  */\n  if (thd->locked_tables_mode &&\n      ! (flags & MYSQL_OPEN_GET_NEW_TABLE))\n  {\t\t\t\t\t\t// Using table locks\n    TABLE *best_table= 0;\n    int best_distance= INT_MIN;\n    for (table=thd->open_tables; table ; table=table->next)\n    {\n      if (table->s->table_cache_key.length == key_length &&\n\t  !memcmp(table->s->table_cache_key.str, key, key_length))\n      {\n        if (!my_strcasecmp(system_charset_info, table->alias.c_ptr(), alias) &&\n            table->query_id != thd->query_id && /* skip tables already used */\n            (thd->locked_tables_mode == LTM_LOCK_TABLES ||\n             table->query_id == 0))\n        {\n          int distance= ((int) table->reginfo.lock_type -\n                         (int) table_list->lock_type);\n\n          /*\n            Find a table that either has the exact lock type requested,\n            or has the best suitable lock. In case there is no locked\n            table that has an equal or higher lock than requested,\n            we us the closest matching lock to be able to produce an error\n            message about wrong lock mode on the table. The best_table\n            is changed if bd < 0 <= d or bd < d < 0 or 0 <= d < bd.\n\n            distance <  0 - No suitable lock found\n            distance >  0 - we have lock mode higher then we require\n            distance == 0 - we have lock mode exactly which we need\n          */\n          if ((best_distance < 0 && distance > best_distance) ||\n              (distance >= 0 && distance < best_distance))\n          {\n            best_distance= distance;\n            best_table= table;\n            if (best_distance == 0)\n            {\n              /*\n                We have found a perfect match and can finish iterating\n                through open tables list. Check for table use conflict\n                between calling statement and SP/trigger is done in\n                lock_tables().\n              */\n              break;\n            }\n          }\n        }\n      }\n    }\n    if (best_table)\n    {\n      table= best_table;\n      table->query_id= thd->query_id;\n      table->init(thd, table_list);\n      DBUG_PRINT(\"info\",(\"Using locked table\"));\n#ifdef WITH_PARTITION_STORAGE_ENGINE\n      part_names_error= set_partitions_as_used(table_list, table);\n#endif\n      goto reset;\n    }\n\n    if (is_locked_view(thd, table_list))\n    {\n      if (table_list->sequence)\n      {\n        my_error(ER_NOT_SEQUENCE, MYF(0), table_list->db.str, table_list->alias.str);\n        DBUG_RETURN(true);\n      }\n      DBUG_RETURN(FALSE); // VIEW\n    }\n\n    /*\n      No table in the locked tables list. In case of explicit LOCK TABLES\n      this can happen if a user did not include the table into the list.\n      In case of pre-locked mode locked tables list is generated automatically,\n      so we may only end up here if the table did not exist when\n      locked tables list was created.\n    */\n    if (thd->locked_tables_mode == LTM_PRELOCKED)\n      my_error(ER_NO_SUCH_TABLE, MYF(0), table_list->db.str, table_list->alias.str);\n    else\n      my_error(ER_TABLE_NOT_LOCKED, MYF(0), alias);\n    DBUG_RETURN(TRUE);\n  }\n\n  /*\n    Non pre-locked/LOCK TABLES mode, and the table is not temporary.\n    This is the normal use case.\n  */\n\n  if (! (flags & MYSQL_OPEN_HAS_MDL_LOCK))\n  {\n    /*\n      We are not under LOCK TABLES and going to acquire write-lock/\n      modify the base table. We need to acquire protection against\n      global read lock until end of this statement in order to have\n      this statement blocked by active FLUSH TABLES WITH READ LOCK.\n\n      We don't need to acquire this protection under LOCK TABLES as\n      such protection already acquired at LOCK TABLES time and\n      not released until UNLOCK TABLES.\n\n      We don't block statements which modify only temporary tables\n      as these tables are not preserved by any form of\n      backup which uses FLUSH TABLES WITH READ LOCK.\n\n      TODO: The fact that we sometimes acquire protection against\n            GRL only when we encounter table to be write-locked\n            slightly increases probability of deadlock.\n            This problem will be solved once Alik pushes his\n            temporary table refactoring patch and we can start\n            pre-acquiring metadata locks at the beggining of\n            open_tables() call.\n    */\n    if (table_list->mdl_request.is_write_lock_request() &&\n        ! (flags & (MYSQL_OPEN_IGNORE_GLOBAL_READ_LOCK |\n                    MYSQL_OPEN_FORCE_SHARED_MDL |\n                    MYSQL_OPEN_FORCE_SHARED_HIGH_PRIO_MDL |\n                    MYSQL_OPEN_SKIP_SCOPED_MDL_LOCK)) &&\n        ! ot_ctx->has_protection_against_grl())\n    {\n      MDL_request protection_request;\n      MDL_deadlock_handler mdl_deadlock_handler(ot_ctx);\n\n      if (thd->global_read_lock.can_acquire_protection())\n        DBUG_RETURN(TRUE);\n\n      protection_request.init(MDL_key::GLOBAL, \"\", \"\", MDL_INTENTION_EXCLUSIVE,\n                              MDL_STATEMENT);\n\n      /*\n        Install error handler which if possible will convert deadlock error\n        into request to back-off and restart process of opening tables.\n      */\n      thd->push_internal_handler(&mdl_deadlock_handler);\n      bool result= thd->mdl_context.acquire_lock(&protection_request,\n                                                 ot_ctx->get_timeout());\n      thd->pop_internal_handler();\n\n      if (result)\n        DBUG_RETURN(TRUE);\n\n      ot_ctx->set_has_protection_against_grl();\n    }\n\n    if (open_table_get_mdl_lock(thd, ot_ctx, &table_list->mdl_request,\n                                flags, &mdl_ticket) ||\n        mdl_ticket == NULL)\n    {\n      DEBUG_SYNC(thd, \"before_open_table_wait_refresh\");\n      DBUG_RETURN(TRUE);\n    }\n    DEBUG_SYNC(thd, \"after_open_table_mdl_shared\");\n  }\n  else\n  {\n    /*\n      Grab reference to the MDL lock ticket that was acquired\n      by the caller.\n    */\n    mdl_ticket= table_list->mdl_request.ticket;\n  }\n\n  if (table_list->open_strategy == TABLE_LIST::OPEN_IF_EXISTS)\n  {\n    if (!ha_table_exists(thd, &table_list->db, &table_list->table_name))\n      DBUG_RETURN(FALSE);\n  }\n  else if (table_list->open_strategy == TABLE_LIST::OPEN_STUB)\n    DBUG_RETURN(FALSE);\n\n  /* Table exists. Let us try to open it. */\n\n  if (table_list->i_s_requested_object & OPEN_TABLE_ONLY)\n    gts_flags= GTS_TABLE;\n  else if (table_list->i_s_requested_object &  OPEN_VIEW_ONLY)\n    gts_flags= GTS_VIEW;\n  else\n    gts_flags= GTS_TABLE | GTS_VIEW;\n\nretry_share:\n\n  share= tdc_acquire_share(thd, table_list, gts_flags, &table);\n\n  if (unlikely(!share))\n  {\n    /*\n      Hide \"Table doesn't exist\" errors if the table belongs to a view.\n      The check for thd->is_error() is necessary to not push an\n      unwanted error in case the error was already silenced.\n      @todo Rework the alternative ways to deal with ER_NO_SUCH TABLE.\n    */\n    if (thd->is_error())\n    {\n      if (table_list->parent_l)\n      {\n        thd->clear_error();\n        my_error(ER_WRONG_MRG_TABLE, MYF(0));\n      }\n      else if (table_list->belong_to_view)\n      {\n        TABLE_LIST *view= table_list->belong_to_view;\n        thd->clear_error();\n        my_error(ER_VIEW_INVALID, MYF(0),\n                 view->view_db.str, view->view_name.str);\n      }\n    }\n    DBUG_RETURN(TRUE);\n  }\n\n  /*\n    Check if this TABLE_SHARE-object corresponds to a view. Note, that there is\n    no need to check TABLE_SHARE::tdc.flushed as we do for regular tables,\n    because view shares are always up to date.\n  */\n  if (share->is_view)\n  {\n    /*\n      If parent_l of the table_list is non null then a merge table\n      has this view as child table, which is not supported.\n    */\n    if (table_list->parent_l)\n    {\n      my_error(ER_WRONG_MRG_TABLE, MYF(0));\n      goto err_lock;\n    }\n    if (table_list->sequence)\n    {\n      my_error(ER_NOT_SEQUENCE, MYF(0), table_list->db.str,\n               table_list->alias.str);\n      goto err_lock;\n    }\n    /*\n      This table is a view. Validate its metadata version: in particular,\n      that it was a view when the statement was prepared.\n    */\n    if (check_and_update_table_version(thd, table_list, share))\n      goto err_lock;\n\n    /* Open view */\n    if (mysql_make_view(thd, share, table_list, false))\n      goto err_lock;\n\n\n    /* TODO: Don't free this */\n    tdc_release_share(share);\n\n    DBUG_ASSERT(table_list->view);\n\n    DBUG_RETURN(FALSE);\n  }\n\n#ifdef WITH_WSREP\n  if (!((flags & MYSQL_OPEN_IGNORE_FLUSH) ||\n        (thd->wsrep_applier)))\n#else\n  if (!(flags & MYSQL_OPEN_IGNORE_FLUSH))\n#endif\n  {\n    if (share->tdc->flushed)\n    {\n      DBUG_PRINT(\"info\", (\"Found old share version: %lld  current: %lld\",\n                          share->tdc->version, tdc_refresh_version()));\n      /*\n        We already have an MDL lock. But we have encountered an old\n        version of table in the table definition cache which is possible\n        when someone changes the table version directly in the cache\n        without acquiring a metadata lock (e.g. this can happen during\n        \"rolling\" FLUSH TABLE(S)).\n        Release our reference to share, wait until old version of\n        share goes away and then try to get new version of table share.\n      */\n      if (table)\n        tc_release_table(table);\n      else\n        tdc_release_share(share);\n\n      MDL_deadlock_handler mdl_deadlock_handler(ot_ctx);\n      bool wait_result;\n\n      thd->push_internal_handler(&mdl_deadlock_handler);\n      wait_result= tdc_wait_for_old_version(thd, table_list->db.str,\n                                            table_list->table_name.str,\n                                            ot_ctx->get_timeout(),\n                                            mdl_ticket->get_deadlock_weight());\n      thd->pop_internal_handler();\n\n      if (wait_result)\n        DBUG_RETURN(TRUE);\n\n      goto retry_share;\n    }\n\n    if (thd->open_tables && thd->open_tables->s->tdc->flushed)\n    {\n      /*\n        If the version changes while we're opening the tables,\n        we have to back off, close all the tables opened-so-far,\n        and try to reopen them. Note: refresh_version is currently\n        changed only during FLUSH TABLES.\n      */\n      if (table)\n        tc_release_table(table);\n      else\n        tdc_release_share(share);\n      (void)ot_ctx->request_backoff_action(Open_table_context::OT_REOPEN_TABLES,\n                                           NULL);\n      DBUG_RETURN(TRUE);\n    }\n  }\n\n  if (table)\n  {\n    DBUG_ASSERT(table->file != NULL);\n    MYSQL_REBIND_TABLE(table->file);\n#ifdef WITH_PARTITION_STORAGE_ENGINE\n    part_names_error= set_partitions_as_used(table_list, table);\n#endif\n  }\n  else\n  {\n    enum open_frm_error error;\n\n    /* make a new table */\n    if (!(table=(TABLE*) my_malloc(sizeof(*table),MYF(MY_WME))))\n      goto err_lock;\n\n    error= open_table_from_share(thd, share, &table_list->alias,\n                                 HA_OPEN_KEYFILE | HA_TRY_READ_ONLY,\n                                 EXTRA_RECORD,\n                                 thd->open_options, table, FALSE,\n                                 IF_PARTITIONING(table_list->partition_names,0));\n\n    if (unlikely(error))\n    {\n      my_free(table);\n\n      if (error == OPEN_FRM_DISCOVER)\n        (void) ot_ctx->request_backoff_action(Open_table_context::OT_DISCOVER,\n                                              table_list);\n      else if (share->crashed)\n      {\n        if (!(flags & MYSQL_OPEN_IGNORE_REPAIR))\n          (void) ot_ctx->request_backoff_action(Open_table_context::OT_REPAIR,\n                                                table_list);\n        else\n          table_list->crashed= 1;  /* Mark that table was crashed */\n      }\n      goto err_lock;\n    }\n    if (open_table_entry_fini(thd, share, table))\n    {\n      closefrm(table);\n      my_free(table);\n      goto err_lock;\n    }\n\n    /* Add table to the share's used tables list. */\n    tc_add_table(thd, table);\n    from_share= true;\n  }\n\n  table->mdl_ticket= mdl_ticket;\n  table->reginfo.lock_type=TL_READ;\t\t/* Assume read */\n\n  table->init(thd, table_list);\n\n  table->next= thd->open_tables;\t\t/* Link into simple list */\n  thd->set_open_tables(table);\n\n reset:\n  /*\n    Check that there is no reference to a condition from an earlier query\n    (cf. Bug#58553). \n  */\n  DBUG_ASSERT(table->file->pushed_cond == NULL);\n  table_list->updatable= 1; // It is not derived table nor non-updatable VIEW\n  table_list->table= table;\n\n  if (!from_share && table->vcol_fix_expr(thd))\n    DBUG_RETURN(true);\n\n#ifdef WITH_PARTITION_STORAGE_ENGINE\n  if (unlikely(table->part_info))\n  {\n    /* Partitions specified were incorrect.*/\n    if (part_names_error)\n    {\n      table->file->print_error(part_names_error, MYF(0));\n      DBUG_RETURN(true);\n    }\n  }\n  else if (table_list->partition_names)\n  {\n    /* Don't allow PARTITION () clause on a nonpartitioned table */\n    my_error(ER_PARTITION_CLAUSE_ON_NONPARTITIONED, MYF(0));\n    DBUG_RETURN(true);\n  }\n#endif\n  if (table_list->sequence && table->s->table_type != TABLE_TYPE_SEQUENCE)\n  {\n    my_error(ER_NOT_SEQUENCE, MYF(0), table_list->db.str, table_list->alias.str);\n    DBUG_RETURN(true);\n  }\n\n  DBUG_RETURN(FALSE);\n\nerr_lock:\n  tdc_release_share(share);\n\n  DBUG_PRINT(\"exit\", (\"failed\"));\n  DBUG_RETURN(TRUE);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 828,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "code": "static void fix_dl_name(MEM_ROOT *root, LEX_STRING *dl)\n{\n  const size_t so_ext_len= sizeof(SO_EXT) - 1;\n  if (dl->length < so_ext_len ||\n      my_strcasecmp(&my_charset_latin1, dl->str + dl->length - so_ext_len,\n                    SO_EXT))\n  {\n    char *s= (char*)alloc_root(root, dl->length + so_ext_len + 1);\n    memcpy(s, dl->str, dl->length);\n    strcpy(s + dl->length, SO_EXT);\n    dl->str= s;\n    dl->length+= so_ext_len;\n  }\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 832,
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ]
  }
]