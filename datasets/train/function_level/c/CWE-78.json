[
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": " gs_nulldevice(gs_gstate * pgs)\n {\n     int code = 0;\n     if (pgs->device == 0 || !gx_device_is_null(pgs->device)) {\n         gx_device *ndev;\n         code = gs_copydevice(&ndev, (const gx_device *)&gs_null_device,\n                                 pgs->memory);\n \n         if (code < 0)\n             return code;\n         /*\n          * Internal devices have a reference count of 0, not 1,\n          * aside from references from graphics states.\n           to sort out how the icc profile is best handled with this device.\n           It seems to inherit properties from the current device if there\n           is one */\n        rc_init(ndev, pgs->memory, 0);\n        if (pgs->device != NULL) {\n            if ((code = dev_proc(pgs->device, get_profile)(pgs->device,\n                                               &(ndev->icc_struct))) < 0)\n                return code;\n            rc_increment(ndev->icc_struct);\n            set_dev_proc(ndev, get_profile, gx_default_get_profile);\n        }\n\n        if ((code = gs_setdevice_no_erase(pgs, ndev)) < 0)\n \n         if ((code = gs_setdevice_no_erase(pgs, ndev)) < 0)\n             gs_free_object(pgs->memory, ndev, \"gs_copydevice(device)\");\n     }\n     return code;\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141395,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": " gs_nulldevice(gs_gstate * pgs)\n {\n     int code = 0;\n    bool saveLockSafety = false;\n     if (pgs->device == 0 || !gx_device_is_null(pgs->device)) {\n         gx_device *ndev;\n         code = gs_copydevice(&ndev, (const gx_device *)&gs_null_device,\n                                 pgs->memory);\n \n         if (code < 0)\n             return code;\n        if (gs_currentdevice_inline(pgs) != NULL)\n            saveLockSafety = gs_currentdevice_inline(pgs)->LockSafetyParams;\n         /*\n          * Internal devices have a reference count of 0, not 1,\n          * aside from references from graphics states.\n           to sort out how the icc profile is best handled with this device.\n           It seems to inherit properties from the current device if there\n           is one */\n        rc_init(ndev, pgs->memory, 0);\n        if (pgs->device != NULL) {\n            if ((code = dev_proc(pgs->device, get_profile)(pgs->device,\n                                               &(ndev->icc_struct))) < 0)\n                return code;\n            rc_increment(ndev->icc_struct);\n            set_dev_proc(ndev, get_profile, gx_default_get_profile);\n        }\n\n        if ((code = gs_setdevice_no_erase(pgs, ndev)) < 0)\n \n         if ((code = gs_setdevice_no_erase(pgs, ndev)) < 0)\n             gs_free_object(pgs->memory, ndev, \"gs_copydevice(device)\");\n        gs_currentdevice_inline(pgs)->LockSafetyParams = saveLockSafety;\n     }\n     return code;\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141396,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "zrestore(i_ctx_t *i_ctx_p)\n {\n     os_ptr op = osp;\n    alloc_save_t *asave;\n    bool last;\n    vm_save_t *vmsave;\n    int code = restore_check_operand(op, &asave, idmemory);\n \n     if (code < 0)\n         return code;\n     if_debug2m('u', imemory, \"[u]vmrestore 0x%lx, id = %lu\\n\",\n               (ulong) alloc_save_client_data(asave),\n                (ulong) op->value.saveid);\n     if (I_VALIDATE_BEFORE_RESTORE)\n         ivalidate_clean_spaces(i_ctx_p);\n        ivalidate_clean_spaces(i_ctx_p);\n    /* Check the contents of the stacks. */\n     {\n         int code;\n \n        if ((code = restore_check_stack(i_ctx_p, &o_stack, asave, false)) < 0 ||\n            (code = restore_check_stack(i_ctx_p, &e_stack, asave, true)) < 0 ||\n            (code = restore_check_stack(i_ctx_p, &d_stack, asave, false)) < 0\n             ) {\n             osp++;\n             return code;\n         }\n     }\n     /* Reset l_new in all stack entries if the new save level is zero. */\n     /* Also do some special fixing on the e-stack. */\n     restore_fix_stack(i_ctx_p, &o_stack, asave, false);\n    }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141397,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "zrestore(i_ctx_t *i_ctx_p)\nrestore_check_save(i_ctx_t *i_ctx_p, alloc_save_t **asave)\n {\n     os_ptr op = osp;\n    int code = restore_check_operand(op, asave, idmemory);\n \n     if (code < 0)\n         return code;\n     if_debug2m('u', imemory, \"[u]vmrestore 0x%lx, id = %lu\\n\",\n               (ulong) alloc_save_client_data(*asave),\n                (ulong) op->value.saveid);\n     if (I_VALIDATE_BEFORE_RESTORE)\n         ivalidate_clean_spaces(i_ctx_p);\n        ivalidate_clean_spaces(i_ctx_p);\n    /* Check the contents of the stacks. */\n     {\n         int code;\n \n        if ((code = restore_check_stack(i_ctx_p, &o_stack, *asave, false)) < 0 ||\n            (code = restore_check_stack(i_ctx_p, &e_stack, *asave, true)) < 0 ||\n            (code = restore_check_stack(i_ctx_p, &d_stack, *asave, false)) < 0\n             ) {\n             osp++;\n             return code;\n         }\n     }\n    osp++;\n    return 0;\n}\n\n/* the semantics of restore differ slightly between Level 1 and\n   Level 2 and later - the latter includes restoring the device\n   state (whilst Level 1 didn't have \"page devices\" as such).\n   Hence we have two restore operators - one here (Level 1)\n   and one in zdevice2.c (Level 2+). For that reason, the\n   operand checking and guts of the restore operation are\n   separated so both implementations can use them to best\n   effect.\n */\nint\ndorestore(i_ctx_t *i_ctx_p, alloc_save_t *asave)\n{\n    os_ptr op = osp;\n    bool last;\n    vm_save_t *vmsave;\n    int code;\n\n    osp--;\n\n     /* Reset l_new in all stack entries if the new save level is zero. */\n     /* Also do some special fixing on the e-stack. */\n     restore_fix_stack(i_ctx_p, &o_stack, asave, false);\n    }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141398,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "void Part::slotOpenExtractedEntry(KJob *job)\n{\n    if (!job->error()) {\n\n        OpenJob *openJob = qobject_cast<OpenJob*>(job);\n        Q_ASSERT(openJob);\n\n        m_tmpExtractDirList << openJob->tempDir();\n\n        const QString fullName = openJob->validatedFilePath();\n\n        bool isWritable = m_model->archive() && !m_model->archive()->isReadOnly();\n\n        if (!isWritable) {\n            QFile::setPermissions(fullName, QFileDevice::ReadOwner | QFileDevice::ReadGroup | QFileDevice::ReadOther);\n        }\n\n        if (isWritable) {\n            m_fileWatcher = new QFileSystemWatcher;\n            connect(m_fileWatcher, &QFileSystemWatcher::fileChanged, this, &Part::slotWatchedFileModified);\n            m_fileWatcher->addPath(fullName);\n        }\n\n        if (qobject_cast<OpenWithJob*>(job)) {\n            const QList<QUrl> urls = {QUrl::fromUserInput(fullName, QString(), QUrl::AssumeLocalFile)};\n            KRun::displayOpenWithDialog(urls, widget());\n         } else {\n             KRun::runUrl(QUrl::fromUserInput(fullName, QString(), QUrl::AssumeLocalFile),\n                          QMimeDatabase().mimeTypeForFile(fullName).name(),\n                         widget());\n         }\n     } else if (job->error() != KJob::KilledJobError) {\n         KMessageBox::error(widget(), job->errorString());\n    }\n    setReadyGui();\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141521,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "void Part::slotOpenExtractedEntry(KJob *job)\n{\n    if (!job->error()) {\n\n        OpenJob *openJob = qobject_cast<OpenJob*>(job);\n        Q_ASSERT(openJob);\n\n        m_tmpExtractDirList << openJob->tempDir();\n\n        const QString fullName = openJob->validatedFilePath();\n\n        bool isWritable = m_model->archive() && !m_model->archive()->isReadOnly();\n\n        if (!isWritable) {\n            QFile::setPermissions(fullName, QFileDevice::ReadOwner | QFileDevice::ReadGroup | QFileDevice::ReadOther);\n        }\n\n        if (isWritable) {\n            m_fileWatcher = new QFileSystemWatcher;\n            connect(m_fileWatcher, &QFileSystemWatcher::fileChanged, this, &Part::slotWatchedFileModified);\n            m_fileWatcher->addPath(fullName);\n        }\n\n        if (qobject_cast<OpenWithJob*>(job)) {\n            const QList<QUrl> urls = {QUrl::fromUserInput(fullName, QString(), QUrl::AssumeLocalFile)};\n            KRun::displayOpenWithDialog(urls, widget());\n         } else {\n             KRun::runUrl(QUrl::fromUserInput(fullName, QString(), QUrl::AssumeLocalFile),\n                          QMimeDatabase().mimeTypeForFile(fullName).name(),\n                         widget(), false, false);\n         }\n     } else if (job->error() != KJob::KilledJobError) {\n         KMessageBox::error(widget(), job->errorString());\n    }\n    setReadyGui();\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141522,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "void DelayedExecutor::delayedExecute(const QString &udi)\n{\n    Solid::Device device(udi);\n \n     QString exec = m_service.exec();\n     MacroExpander mx(device);\n    mx.expandMacros(exec);\n \n     KRun::runCommand(exec, QString(), m_service.icon(), 0);\n     deleteLater();\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141535,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "void DelayedExecutor::delayedExecute(const QString &udi)\n{\n    Solid::Device device(udi);\n \n     QString exec = m_service.exec();\n     MacroExpander mx(device);\n    mx.expandMacrosShellQuote(exec);\n \n     KRun::runCommand(exec, QString(), m_service.icon(), 0);\n     deleteLater();\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141536,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "build_config(char *prefix, struct server *server)\n {\n     char *path    = NULL;\n     int path_size = strlen(prefix) + strlen(server->port) + 20;\n\n    path = ss_malloc(path_size);\n    snprintf(path, path_size, \"%s/.shadowsocks_%s.conf\", prefix, server->port);\n    FILE *f = fopen(path, \"w+\");\n    if (f == NULL) {\n        if (verbose) {\n            LOGE(\"unable to open config file\");\n        }\n        ss_free(path);\n        return;\n    }\n     fprintf(f, \"{\\n\");\n     fprintf(f, \"\\\"server_port\\\":%d,\\n\", atoi(server->port));\n     fprintf(f, \"\\\"password\\\":\\\"%s\\\"\", server->password);\n    if (server->fast_open[0]) fprintf(f, \",\\n\\\"fast_open\\\": %s\", server->fast_open);\n    if (server->mode)   fprintf(f, \",\\n\\\"mode\\\":\\\"%s\\\"\", server->mode);\n    if (server->method) fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", server->method);\n    if (server->plugin) fprintf(f, \",\\n\\\"plugin\\\":\\\"%s\\\"\", server->plugin);\n    if (server->plugin_opts) fprintf(f, \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\", server->plugin_opts);\n     fprintf(f, \"\\n}\\n\");\n     fclose(f);\n     ss_free(path);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142293,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "build_config(char *prefix, struct server *server)\nbuild_config(char *prefix, struct manager_ctx *manager, struct server *server)\n {\n     char *path    = NULL;\n     int path_size = strlen(prefix) + strlen(server->port) + 20;\n\n    path = ss_malloc(path_size);\n    snprintf(path, path_size, \"%s/.shadowsocks_%s.conf\", prefix, server->port);\n    FILE *f = fopen(path, \"w+\");\n    if (f == NULL) {\n        if (verbose) {\n            LOGE(\"unable to open config file\");\n        }\n        ss_free(path);\n        return;\n    }\n     fprintf(f, \"{\\n\");\n     fprintf(f, \"\\\"server_port\\\":%d,\\n\", atoi(server->port));\n     fprintf(f, \"\\\"password\\\":\\\"%s\\\"\", server->password);\n    if (server->method)\n        fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", server->method);\n    else if (manager->method)\n        fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", manager->method);\n    if (server->fast_open[0])\n        fprintf(f, \",\\n\\\"fast_open\\\": %s\", server->fast_open);\n    if (server->mode)\n        fprintf(f, \",\\n\\\"mode\\\":\\\"%s\\\"\", server->mode);\n    if (server->plugin)\n        fprintf(f, \",\\n\\\"plugin\\\":\\\"%s\\\"\", server->plugin);\n    if (server->plugin_opts)\n        fprintf(f, \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\", server->plugin_opts);\n     fprintf(f, \"\\n}\\n\");\n     fclose(f);\n     ss_free(path);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142294,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": " construct_command_line(struct manager_ctx *manager, struct server *server)\n {\n     static char cmd[BUF_SIZE];\n    char *method = manager->method;\n     int i;\n \n    build_config(working_dir, server);\n \n    if (server->method) method = server->method;\n     memset(cmd, 0, BUF_SIZE);\n     snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n \n     if (manager->acl != NULL) {\n         int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n    }\n    if (manager->timeout != NULL) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n    }\n#ifdef HAVE_SETRLIMIT\n    if (manager->nofile) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n    }\n#endif\n    if (manager->user != NULL) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n    }\n    if (manager->verbose) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n    }\n    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n    }\n    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n    }\n    if (server->fast_open[0] == 0 && manager->fast_open) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n    }\n    if (manager->ipv6first) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n    }\n    if (manager->mtu) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n    }\n    if (server->plugin == NULL && manager->plugin) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n    }\n    if (server->plugin_opts == NULL && manager->plugin_opts) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n    }\n    for (i = 0; i < manager->nameserver_num; i++) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n    }\n    for (i = 0; i < manager->host_num; i++) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n    }\n    {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n    }\n\n    if (verbose) {\n        LOGI(\"cmd: %s\", cmd);\n    }\n\n    return cmd;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142295,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": " construct_command_line(struct manager_ctx *manager, struct server *server)\n {\n     static char cmd[BUF_SIZE];\n     int i;\n    int port;\n \n    port = atoi(server->port);\n\n    build_config(working_dir, manager, server);\n \n     memset(cmd, 0, BUF_SIZE);\n     snprintf(cmd, BUF_SIZE,\n             \"%s --manager-address %s -f %s/.shadowsocks_%d.pid -c %s/.shadowsocks_%d.conf\",\n             executable, manager->manager_address, working_dir, port, working_dir, port);\n \n     if (manager->acl != NULL) {\n         int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n    }\n    if (manager->timeout != NULL) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n    }\n#ifdef HAVE_SETRLIMIT\n    if (manager->nofile) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n    }\n#endif\n    if (manager->user != NULL) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n    }\n    if (manager->verbose) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n    }\n    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n    }\n    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n    }\n    if (server->fast_open[0] == 0 && manager->fast_open) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n    }\n    if (manager->ipv6first) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n    }\n    if (manager->mtu) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n    }\n    if (server->plugin == NULL && manager->plugin) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n    }\n    if (server->plugin_opts == NULL && manager->plugin_opts) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n    }\n    for (i = 0; i < manager->nameserver_num; i++) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n    }\n    for (i = 0; i < manager->host_num; i++) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n    }\n    {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n    }\n\n    if (verbose) {\n        LOGI(\"cmd: %s\", cmd);\n    }\n\n    return cmd;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142296,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "static int bin_symbols(RCore *r, int mode, ut64 laddr, int va, ut64 at, const char *name, bool exponly, const char *args) {\n\tRBinInfo *info = r_bin_get_info (r->bin);\n\tRList *entries = r_bin_get_entries (r->bin);\n\tRBinSymbol *symbol;\n\tRBinAddr *entry;\n\tRListIter *iter;\n\tbool firstexp = true;\n\tbool printHere = false;\n\tint i = 0, lastfs = 's';\n\tbool bin_demangle = r_config_get_i (r->config, \"bin.demangle\");\n\tif (!info) {\n\t\treturn 0;\n\t}\n\n\tif (args && *args == '.') {\n\t\tprintHere = true;\n\t}\n\n\tbool is_arm = info && info->arch && !strncmp (info->arch, \"arm\", 3);\n\tconst char *lang = bin_demangle ? r_config_get (r->config, \"bin.lang\") : NULL;\n\n\tRList *symbols = r_bin_get_symbols (r->bin);\n\tr_spaces_push (&r->anal->meta_spaces, \"bin\");\n\n\tif (IS_MODE_JSON (mode) && !printHere) {\n\t\tr_cons_printf (\"[\");\n\t} else if (IS_MODE_SET (mode)) {\n\t\tr_flag_space_set (r->flags, R_FLAGS_FS_SYMBOLS);\n\t} else if (!at && exponly) {\n\t\tif (IS_MODE_RAD (mode)) {\n\t\t\tr_cons_printf (\"fs exports\\n\");\n\t\t} else if (IS_MODE_NORMAL (mode)) {\n\t\t\tr_cons_printf (printHere ? \"\" : \"[Exports]\\n\");\n\t\t}\n\t} else if (!at && !exponly) {\n\t\tif (IS_MODE_RAD (mode)) {\n\t\t\tr_cons_printf (\"fs symbols\\n\");\n\t\t} else if (IS_MODE_NORMAL (mode)) {\n\t\t\tr_cons_printf (printHere ? \"\" : \"[Symbols]\\n\");\n\t\t}\n\t}\n\tif (IS_MODE_NORMAL (mode)) {\n\t\tr_cons_printf (\"Num Paddr      Vaddr      Bind     Type Size Name\\n\");\n\t}\n\n\n\tsize_t count = 0;\n\tr_list_foreach (symbols, iter, symbol) {\n\t\tif (!symbol->name) {\n\t\t\tcontinue;\n\t\t}\n\t\tchar *r_symbol_name = r_str_escape_utf8 (symbol->name, false, true);\n\t\tut64 addr = compute_addr (r->bin, symbol->paddr, symbol->vaddr, va);\n\t\tint len = symbol->size ? symbol->size : 32;\n\t\tSymName sn = {0};\n\n\t\tif (exponly && !isAnExport (symbol)) {\n\t\t\tfree (r_symbol_name);\n\t\t\tcontinue;\n\t\t}\n\t\tif (name && strcmp (r_symbol_name, name)) {\n\t\t\tfree (r_symbol_name);\n\t\t\tcontinue;\n\t\t}\n\t\tif (at && (!symbol->size || !is_in_range (at, addr, symbol->size))) {\n\t\t\tfree (r_symbol_name);\n\t\t\tcontinue;\n\t\t}\n\t\tif ((printHere && !is_in_range (r->offset, symbol->paddr, len))\n\t\t\t\t&& (printHere && !is_in_range (r->offset, addr, len))) {\n\t\t\tfree (r_symbol_name);\n\t\t\tcontinue;\n\t\t}\n\t\tcount ++;\n\t\tsnInit (r, &sn, symbol, lang);\n\n\t\tif (IS_MODE_SET (mode) && (is_section_symbol (symbol) || is_file_symbol (symbol))) {\n\t\t\t/*\n\t\t\t * Skip section symbols because they will have their own flag.\n\t\t\t * Skip also file symbols because not useful for now.\n\t\t\t */\n\t\t} else if (IS_MODE_SET (mode) && is_special_symbol (symbol)) {\n\t\t\tif (is_arm) {\n\t\t\t\thandle_arm_special_symbol (r, symbol, va);\n\t\t\t}\n\t\t} else if (IS_MODE_SET (mode)) {\n\t\t\tif (is_arm) {\n\t\t\t\thandle_arm_symbol (r, symbol, info, va);\n\t\t\t}\n\t\t\tselect_flag_space (r, symbol);\n\t\t\t/* If that's a Classed symbol (method or so) */\n\t\t\tif (sn.classname) {\n\t\t\t\tRFlagItem *fi = r_flag_get (r->flags, sn.methflag);\n\t\t\t\tif (r->bin->prefix) {\n\t\t\t\t\tchar *prname = r_str_newf (\"%s.%s\", r->bin->prefix, sn.methflag);\n\t\t\t\t\tr_name_filter (sn.methflag, -1);\n\t\t\t\t\tfree (sn.methflag);\n\t\t\t\t\tsn.methflag = prname;\n\t\t\t\t}\n\t\t\t\tif (fi) {\n\t\t\t\t\tr_flag_item_set_realname (fi, sn.methname);\n\t\t\t\t\tif ((fi->offset - r->flags->base) == addr) {\n\t\t\t\t\t\tr_flag_unset (r->flags, fi);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfi = r_flag_set (r->flags, sn.methflag, addr, symbol->size);\n\t\t\t\t\tchar *comment = fi->comment ? strdup (fi->comment) : NULL;\n\t\t\t\t\tif (comment) {\n\t\t\t\t\t\tr_flag_item_set_comment (fi, comment);\n\t\t\t\t\t\tR_FREE (comment);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst char *n = sn.demname ? sn.demname : sn.name;\n\t\t\t\tconst char *fn = sn.demflag ? sn.demflag : sn.nameflag;\n\t\t\t\tchar *fnp = (r->bin->prefix) ?\n\t\t\t\t\tr_str_newf (\"%s.%s\", r->bin->prefix, fn):\n\t\t\t\t\tstrdup (fn);\n\t\t\t\tRFlagItem *fi = r_flag_set (r->flags, fnp, addr, symbol->size);\n\t\t\t\tif (fi) {\n\t\t\t\t\tr_flag_item_set_realname (fi, n);\n\t\t\t\t\tfi->demangled = (bool)(size_t)sn.demname;\n\t\t\t\t} else {\n\t\t\t\t\tif (fn) {\n\t\t\t\t\t\teprintf (\"[Warning] Can't find flag (%s)\\n\", fn);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree (fnp);\n\t\t\t}\n\t\t\tif (sn.demname) {\n\t\t\t\tr_meta_add (r->anal, R_META_TYPE_COMMENT,\n\t\t\t\t\taddr, symbol->size, sn.demname);\n\t\t\t}\n\t\t\tr_flag_space_pop (r->flags);\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tchar *str = r_str_escape_utf8_for_json (r_symbol_name, -1);\n\t\t\tr_cons_printf (\"%s{\\\"name\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"demname\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"flagname\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"ordinal\\\":%d,\"\n\t\t\t\t\"\\\"bind\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"size\\\":%d,\"\n\t\t\t\t\"\\\"type\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"vaddr\\\":%\"PFMT64d\",\"\n\t\t\t\t\"\\\"paddr\\\":%\"PFMT64d\"}\",\n\t\t\t\t((exponly && firstexp) || printHere) ? \"\" : (iter->p ? \",\" : \"\"),\n\t\t\t\tstr,\n\t\t\t\tsn.demname? sn.demname: \"\",\n\t\t\t\tsn.nameflag,\n\t\t\t\tsymbol->ordinal,\n\t\t\t\tsymbol->bind,\n\t\t\t\t(int)symbol->size,\n\t\t\t\tsymbol->type,\n\t\t\t\t(ut64)addr, (ut64)symbol->paddr);\n\t\t\tfree (str);\n\t\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\t\tconst char *name = sn.demname? sn.demname: r_symbol_name;\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\" %d %s\\n\",\n\t\t\t\taddr, (int)symbol->size, name);\n\t\t} else if (IS_MODE_SIMPLEST (mode)) {\n\t\t\tconst char *name = sn.demname? sn.demname: r_symbol_name;\n\t\t\tr_cons_printf (\"%s\\n\", name);\n\t\t} else if (IS_MODE_RAD (mode)) {\n\t\t\t/* Skip special symbols because we do not flag them and\n\t\t\t * they shouldn't be printed in the rad format either */\n\t\t\tif (is_special_symbol (symbol)) {\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tRBinFile *binfile;\n\t\t\tRBinPlugin *plugin;\n\t\t\tconst char *name = sn.demname? sn.demname: r_symbol_name;\n\t\t\tif (!name) {\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tif (!strncmp (name, \"imp.\", 4)) {\n\t\t\t\tif (lastfs != 'i') {\n\t\t\t\t\tr_cons_printf (\"fs imports\\n\");\n\t\t\t\t}\n\t\t\t\tlastfs = 'i';\n\t\t\t} else {\n\t\t\t\tif (lastfs != 's') {\n\t\t\t\t\tconst char *fs = exponly? \"exports\": \"symbols\";\n\t\t\t\t\tr_cons_printf (\"fs %s\\n\", fs);\n\t\t\t\t}\n\t\t\t\tlastfs = 's';\n\t\t\t}\n\t\t\tif (r->bin->prefix || *name) { // we don't want unnamed symbol flags\n\t\t\t\tchar *flagname = construct_symbol_flagname (\"sym\", name, MAXFLAG_LEN_DEFAULT);\n\t\t\t\tif (!flagname) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\t\t\t\tr_cons_printf (\"\\\"f %s%s%s %u 0x%08\" PFMT64x \"\\\"\\n\",\n\t\t\t\t\tr->bin->prefix ? r->bin->prefix : \"\", r->bin->prefix ? \".\" : \"\",\n\t\t\t\t\tflagname, symbol->size, addr);\n\t\t\t\tfree (flagname);\n\t\t\t}\n\t\t\tbinfile = r_bin_cur (r->bin);\n\t\t\tplugin = r_bin_file_cur_plugin (binfile);\n\t\t\tif (plugin && plugin->name) {\n\t\t\t\tif (r_str_startswith (plugin->name, \"pe\")) {\n\t\t\t\t\tchar *module = strdup (r_symbol_name);\n\t\t\t\t\tchar *p = strstr (module, \".dll_\");\n\t\t\t\t\tif (p && strstr (module, \"imp.\")) {\n\t\t\t\t\t\tchar *symname = __filterShell (p + 5);\n \t\t\t\t\t\tchar *m = __filterShell (module);\n \t\t\t\t\t\t*p = 0;\n \t\t\t\t\t\tif (r->bin->prefix) {\n\t\t\t\t\t\t\tr_cons_printf (\"k bin/pe/%s/%d=%s.%s\\n\",\n \t\t\t\t\t\t\t\tmodule, symbol->ordinal, r->bin->prefix, symname);\n \t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tr_cons_printf (\"k bin/pe/%s/%d=%s\\n\",\n \t\t\t\t\t\t\t\tmodule, symbol->ordinal, symname);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tfree (symname);\n\t\t\t\t\t\tfree (m);\n\t\t\t\t\t}\n\t\t\t\t\tfree (module);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tconst char *bind = symbol->bind? symbol->bind: \"NONE\";\n\t\t\tconst char *type = symbol->type? symbol->type: \"NONE\";\n\t\t\tconst char *name = r_str_get (sn.demname? sn.demname: r_symbol_name);\n\t\t\tr_cons_printf (\"%03u\", symbol->ordinal);\n\t\t\tif (symbol->paddr == UT64_MAX) {\n\t\t\t\tr_cons_printf (\" ----------\");\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\" 0x%08\"PFMT64x, symbol->paddr);\n\t\t\t}\n\t\t\tr_cons_printf (\" 0x%08\"PFMT64x\" %6s %6s %4d%s%s\\n\",\n\t\t\t               addr, bind, type, symbol->size, *name? \" \": \"\", name);\n\t\t}\nnext:\n\t\tsnFini (&sn);\n\t\ti++;\n\t\tfree (r_symbol_name);\n\t\tif (exponly && firstexp) {\n\t\t\tfirstexp = false;\n\t\t}\n\t\tif (printHere) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (count == 0 && IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"{}\");\n\t}\n\n\n\tif (is_arm) {\n\t\tr_list_foreach (entries, iter, entry) {\n\t\t\tif (IS_MODE_SET (mode)) {\n\t\t\t\thandle_arm_entry (r, entry, info, va);\n\t\t\t}\n\t\t}\n\t}\n\tif (IS_MODE_JSON (mode) && !printHere) {\n\t\tr_cons_printf (\"]\");\n\t}\n\n\tr_spaces_pop (&r->anal->meta_spaces);\n\treturn true;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143513,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "static int bin_symbols(RCore *r, int mode, ut64 laddr, int va, ut64 at, const char *name, bool exponly, const char *args) {\n\tRBinInfo *info = r_bin_get_info (r->bin);\n\tRList *entries = r_bin_get_entries (r->bin);\n\tRBinSymbol *symbol;\n\tRBinAddr *entry;\n\tRListIter *iter;\n\tbool firstexp = true;\n\tbool printHere = false;\n\tint i = 0, lastfs = 's';\n\tbool bin_demangle = r_config_get_i (r->config, \"bin.demangle\");\n\tif (!info) {\n\t\treturn 0;\n\t}\n\n\tif (args && *args == '.') {\n\t\tprintHere = true;\n\t}\n\n\tbool is_arm = info && info->arch && !strncmp (info->arch, \"arm\", 3);\n\tconst char *lang = bin_demangle ? r_config_get (r->config, \"bin.lang\") : NULL;\n\n\tRList *symbols = r_bin_get_symbols (r->bin);\n\tr_spaces_push (&r->anal->meta_spaces, \"bin\");\n\n\tif (IS_MODE_JSON (mode) && !printHere) {\n\t\tr_cons_printf (\"[\");\n\t} else if (IS_MODE_SET (mode)) {\n\t\tr_flag_space_set (r->flags, R_FLAGS_FS_SYMBOLS);\n\t} else if (!at && exponly) {\n\t\tif (IS_MODE_RAD (mode)) {\n\t\t\tr_cons_printf (\"fs exports\\n\");\n\t\t} else if (IS_MODE_NORMAL (mode)) {\n\t\t\tr_cons_printf (printHere ? \"\" : \"[Exports]\\n\");\n\t\t}\n\t} else if (!at && !exponly) {\n\t\tif (IS_MODE_RAD (mode)) {\n\t\t\tr_cons_printf (\"fs symbols\\n\");\n\t\t} else if (IS_MODE_NORMAL (mode)) {\n\t\t\tr_cons_printf (printHere ? \"\" : \"[Symbols]\\n\");\n\t\t}\n\t}\n\tif (IS_MODE_NORMAL (mode)) {\n\t\tr_cons_printf (\"Num Paddr      Vaddr      Bind     Type Size Name\\n\");\n\t}\n\n\n\tsize_t count = 0;\n\tr_list_foreach (symbols, iter, symbol) {\n\t\tif (!symbol->name) {\n\t\t\tcontinue;\n\t\t}\n\t\tchar *r_symbol_name = r_str_escape_utf8 (symbol->name, false, true);\n\t\tut64 addr = compute_addr (r->bin, symbol->paddr, symbol->vaddr, va);\n\t\tint len = symbol->size ? symbol->size : 32;\n\t\tSymName sn = {0};\n\n\t\tif (exponly && !isAnExport (symbol)) {\n\t\t\tfree (r_symbol_name);\n\t\t\tcontinue;\n\t\t}\n\t\tif (name && strcmp (r_symbol_name, name)) {\n\t\t\tfree (r_symbol_name);\n\t\t\tcontinue;\n\t\t}\n\t\tif (at && (!symbol->size || !is_in_range (at, addr, symbol->size))) {\n\t\t\tfree (r_symbol_name);\n\t\t\tcontinue;\n\t\t}\n\t\tif ((printHere && !is_in_range (r->offset, symbol->paddr, len))\n\t\t\t\t&& (printHere && !is_in_range (r->offset, addr, len))) {\n\t\t\tfree (r_symbol_name);\n\t\t\tcontinue;\n\t\t}\n\t\tcount ++;\n\t\tsnInit (r, &sn, symbol, lang);\n\n\t\tif (IS_MODE_SET (mode) && (is_section_symbol (symbol) || is_file_symbol (symbol))) {\n\t\t\t/*\n\t\t\t * Skip section symbols because they will have their own flag.\n\t\t\t * Skip also file symbols because not useful for now.\n\t\t\t */\n\t\t} else if (IS_MODE_SET (mode) && is_special_symbol (symbol)) {\n\t\t\tif (is_arm) {\n\t\t\t\thandle_arm_special_symbol (r, symbol, va);\n\t\t\t}\n\t\t} else if (IS_MODE_SET (mode)) {\n\t\t\tif (is_arm) {\n\t\t\t\thandle_arm_symbol (r, symbol, info, va);\n\t\t\t}\n\t\t\tselect_flag_space (r, symbol);\n\t\t\t/* If that's a Classed symbol (method or so) */\n\t\t\tif (sn.classname) {\n\t\t\t\tRFlagItem *fi = r_flag_get (r->flags, sn.methflag);\n\t\t\t\tif (r->bin->prefix) {\n\t\t\t\t\tchar *prname = r_str_newf (\"%s.%s\", r->bin->prefix, sn.methflag);\n\t\t\t\t\tr_name_filter (sn.methflag, -1);\n\t\t\t\t\tfree (sn.methflag);\n\t\t\t\t\tsn.methflag = prname;\n\t\t\t\t}\n\t\t\t\tif (fi) {\n\t\t\t\t\tr_flag_item_set_realname (fi, sn.methname);\n\t\t\t\t\tif ((fi->offset - r->flags->base) == addr) {\n\t\t\t\t\t\tr_flag_unset (r->flags, fi);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfi = r_flag_set (r->flags, sn.methflag, addr, symbol->size);\n\t\t\t\t\tchar *comment = fi->comment ? strdup (fi->comment) : NULL;\n\t\t\t\t\tif (comment) {\n\t\t\t\t\t\tr_flag_item_set_comment (fi, comment);\n\t\t\t\t\t\tR_FREE (comment);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst char *n = sn.demname ? sn.demname : sn.name;\n\t\t\t\tconst char *fn = sn.demflag ? sn.demflag : sn.nameflag;\n\t\t\t\tchar *fnp = (r->bin->prefix) ?\n\t\t\t\t\tr_str_newf (\"%s.%s\", r->bin->prefix, fn):\n\t\t\t\t\tstrdup (fn);\n\t\t\t\tRFlagItem *fi = r_flag_set (r->flags, fnp, addr, symbol->size);\n\t\t\t\tif (fi) {\n\t\t\t\t\tr_flag_item_set_realname (fi, n);\n\t\t\t\t\tfi->demangled = (bool)(size_t)sn.demname;\n\t\t\t\t} else {\n\t\t\t\t\tif (fn) {\n\t\t\t\t\t\teprintf (\"[Warning] Can't find flag (%s)\\n\", fn);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree (fnp);\n\t\t\t}\n\t\t\tif (sn.demname) {\n\t\t\t\tr_meta_add (r->anal, R_META_TYPE_COMMENT,\n\t\t\t\t\taddr, symbol->size, sn.demname);\n\t\t\t}\n\t\t\tr_flag_space_pop (r->flags);\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tchar *str = r_str_escape_utf8_for_json (r_symbol_name, -1);\n\t\t\tr_cons_printf (\"%s{\\\"name\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"demname\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"flagname\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"ordinal\\\":%d,\"\n\t\t\t\t\"\\\"bind\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"size\\\":%d,\"\n\t\t\t\t\"\\\"type\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"vaddr\\\":%\"PFMT64d\",\"\n\t\t\t\t\"\\\"paddr\\\":%\"PFMT64d\"}\",\n\t\t\t\t((exponly && firstexp) || printHere) ? \"\" : (iter->p ? \",\" : \"\"),\n\t\t\t\tstr,\n\t\t\t\tsn.demname? sn.demname: \"\",\n\t\t\t\tsn.nameflag,\n\t\t\t\tsymbol->ordinal,\n\t\t\t\tsymbol->bind,\n\t\t\t\t(int)symbol->size,\n\t\t\t\tsymbol->type,\n\t\t\t\t(ut64)addr, (ut64)symbol->paddr);\n\t\t\tfree (str);\n\t\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\t\tconst char *name = sn.demname? sn.demname: r_symbol_name;\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\" %d %s\\n\",\n\t\t\t\taddr, (int)symbol->size, name);\n\t\t} else if (IS_MODE_SIMPLEST (mode)) {\n\t\t\tconst char *name = sn.demname? sn.demname: r_symbol_name;\n\t\t\tr_cons_printf (\"%s\\n\", name);\n\t\t} else if (IS_MODE_RAD (mode)) {\n\t\t\t/* Skip special symbols because we do not flag them and\n\t\t\t * they shouldn't be printed in the rad format either */\n\t\t\tif (is_special_symbol (symbol)) {\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tRBinFile *binfile;\n\t\t\tRBinPlugin *plugin;\n\t\t\tconst char *name = sn.demname? sn.demname: r_symbol_name;\n\t\t\tif (!name) {\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tif (!strncmp (name, \"imp.\", 4)) {\n\t\t\t\tif (lastfs != 'i') {\n\t\t\t\t\tr_cons_printf (\"fs imports\\n\");\n\t\t\t\t}\n\t\t\t\tlastfs = 'i';\n\t\t\t} else {\n\t\t\t\tif (lastfs != 's') {\n\t\t\t\t\tconst char *fs = exponly? \"exports\": \"symbols\";\n\t\t\t\t\tr_cons_printf (\"fs %s\\n\", fs);\n\t\t\t\t}\n\t\t\t\tlastfs = 's';\n\t\t\t}\n\t\t\tif (r->bin->prefix || *name) { // we don't want unnamed symbol flags\n\t\t\t\tchar *flagname = construct_symbol_flagname (\"sym\", name, MAXFLAG_LEN_DEFAULT);\n\t\t\t\tif (!flagname) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\t\t\t\tr_cons_printf (\"\\\"f %s%s%s %u 0x%08\" PFMT64x \"\\\"\\n\",\n\t\t\t\t\tr->bin->prefix ? r->bin->prefix : \"\", r->bin->prefix ? \".\" : \"\",\n\t\t\t\t\tflagname, symbol->size, addr);\n\t\t\t\tfree (flagname);\n\t\t\t}\n\t\t\tbinfile = r_bin_cur (r->bin);\n\t\t\tplugin = r_bin_file_cur_plugin (binfile);\n\t\t\tif (plugin && plugin->name) {\n\t\t\t\tif (r_str_startswith (plugin->name, \"pe\")) {\n\t\t\t\t\tchar *module = strdup (r_symbol_name);\n\t\t\t\t\tchar *p = strstr (module, \".dll_\");\n\t\t\t\t\tif (p && strstr (module, \"imp.\")) {\n\t\t\t\t\t\tchar *symname = __filterShell (p + 5);\n \t\t\t\t\t\tchar *m = __filterShell (module);\n \t\t\t\t\t\t*p = 0;\n \t\t\t\t\t\tif (r->bin->prefix) {\n\t\t\t\t\t\t\tr_cons_printf (\"\\\"k bin/pe/%s/%d=%s.%s\\\"\\n\",\n \t\t\t\t\t\t\t\tmodule, symbol->ordinal, r->bin->prefix, symname);\n \t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tr_cons_printf (\"\\\"k bin/pe/%s/%d=%s\\\"\\n\",\n \t\t\t\t\t\t\t\tmodule, symbol->ordinal, symname);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tfree (symname);\n\t\t\t\t\t\tfree (m);\n\t\t\t\t\t}\n\t\t\t\t\tfree (module);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tconst char *bind = symbol->bind? symbol->bind: \"NONE\";\n\t\t\tconst char *type = symbol->type? symbol->type: \"NONE\";\n\t\t\tconst char *name = r_str_get (sn.demname? sn.demname: r_symbol_name);\n\t\t\tr_cons_printf (\"%03u\", symbol->ordinal);\n\t\t\tif (symbol->paddr == UT64_MAX) {\n\t\t\t\tr_cons_printf (\" ----------\");\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\" 0x%08\"PFMT64x, symbol->paddr);\n\t\t\t}\n\t\t\tr_cons_printf (\" 0x%08\"PFMT64x\" %6s %6s %4d%s%s\\n\",\n\t\t\t               addr, bind, type, symbol->size, *name? \" \": \"\", name);\n\t\t}\nnext:\n\t\tsnFini (&sn);\n\t\ti++;\n\t\tfree (r_symbol_name);\n\t\tif (exponly && firstexp) {\n\t\t\tfirstexp = false;\n\t\t}\n\t\tif (printHere) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (count == 0 && IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"{}\");\n\t}\n\n\n\tif (is_arm) {\n\t\tr_list_foreach (entries, iter, entry) {\n\t\t\tif (IS_MODE_SET (mode)) {\n\t\t\t\thandle_arm_entry (r, entry, info, va);\n\t\t\t}\n\t\t}\n\t}\n\tif (IS_MODE_JSON (mode) && !printHere) {\n\t\tr_cons_printf (\"]\");\n\t}\n\n\tr_spaces_pop (&r->anal->meta_spaces);\n\treturn true;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143514,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "do_ed_script (char const *inname, char const *outname,\n\t      bool *outname_needs_removal, FILE *ofp)\n{\n    static char const editor_program[] = EDITOR_PROGRAM;\n\n    file_offset beginning_of_this_line;\n    size_t chars_read;\n    FILE *tmpfp = 0;\n    char const *tmpname;\n    int tmpfd;\n    pid_t pid;\n\n    if (! dry_run && ! skip_rest_of_patch)\n      {\n\t/* Write ed script to a temporary file.  This causes ed to abort on\n\t   invalid commands such as when line numbers or ranges exceed the\n\t   number of available lines.  When ed reads from a pipe, it rejects\n\t   invalid commands and treats the next line as a new command, which\n\t   can lead to arbitrary command execution.  */\n\n\ttmpfd = make_tempfile (&tmpname, 'e', NULL, O_RDWR | O_BINARY, 0);\n\tif (tmpfd == -1)\n\t  pfatal (\"Can't create temporary file %s\", quotearg (tmpname));\n\ttmpfp = fdopen (tmpfd, \"w+b\");\n\tif (! tmpfp)\n\t  pfatal (\"Can't open stream for file %s\", quotearg (tmpname));\n      }\n\n    for (;;) {\n\tchar ed_command_letter;\n\tbeginning_of_this_line = file_tell (pfp);\n\tchars_read = get_line ();\n\tif (! chars_read) {\n\t    next_intuit_at(beginning_of_this_line,p_input_line);\n\t    break;\n\t}\n\ted_command_letter = get_ed_command_letter (buf);\n\tif (ed_command_letter) {\n\t    if (tmpfp)\n\t\tif (! fwrite (buf, sizeof *buf, chars_read, tmpfp))\n\t\t    write_fatal ();\n\t    if (ed_command_letter != 'd' && ed_command_letter != 's') {\n\t        p_pass_comments_through = true;\n\t\twhile ((chars_read = get_line ()) != 0) {\n\t\t    if (tmpfp)\n\t\t\tif (! fwrite (buf, sizeof *buf, chars_read, tmpfp))\n\t\t\t    write_fatal ();\n\t\t    if (chars_read == 2  &&  strEQ (buf, \".\\n\"))\n\t\t\tbreak;\n\t\t}\n\t\tp_pass_comments_through = false;\n\t    }\n\t}\n\telse {\n\t    next_intuit_at(beginning_of_this_line,p_input_line);\n\t    break;\n\t}\n    }\n    if (!tmpfp)\n      return;\n    if (fwrite (\"w\\nq\\n\", sizeof (char), (size_t) 4, tmpfp) == 0\n\t|| fflush (tmpfp) != 0)\n      write_fatal ();\n\n    if (lseek (tmpfd, 0, SEEK_SET) == -1)\n      pfatal (\"Can't rewind to the beginning of file %s\", quotearg (tmpname));\n\n    if (! dry_run && ! skip_rest_of_patch) {\n\tint exclusive = *outname_needs_removal ? 0 : O_EXCL;\n\t*outname_needs_removal = true;\n\tif (inerrno != ENOENT)\n\t  {\n \t    *outname_needs_removal = true;\n \t    copy_file (inname, outname, 0, exclusive, instat.st_mode, true);\n \t  }\n\tsprintf (buf, \"%s %s%s\", editor_program,\n\t\t verbosity == VERBOSE ? \"\" : \"- \",\n\t\t outname);\n \tfflush (stdout);\n \n \tpid = fork();\n\tfflush (stdout);\n\n \telse if (pid == 0)\n \t  {\n \t    dup2 (tmpfd, 0);\n\t    execl (\"/bin/sh\", \"sh\", \"-c\", buf, (char *) 0);\n \t    _exit (2);\n \t  }\n \telse\n\t  }\n\telse\n\t  {\n\t    int wstatus;\n\t    if (waitpid (pid, &wstatus, 0) == -1\n\t        || ! WIFEXITED (wstatus)\n\t\t|| WEXITSTATUS (wstatus) != 0)\n\t      fatal (\"%s FAILED\", editor_program);\n\t  }\n    }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143975,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "do_ed_script (char const *inname, char const *outname,\n\t      bool *outname_needs_removal, FILE *ofp)\n{\n    static char const editor_program[] = EDITOR_PROGRAM;\n\n    file_offset beginning_of_this_line;\n    size_t chars_read;\n    FILE *tmpfp = 0;\n    char const *tmpname;\n    int tmpfd;\n    pid_t pid;\n\n    if (! dry_run && ! skip_rest_of_patch)\n      {\n\t/* Write ed script to a temporary file.  This causes ed to abort on\n\t   invalid commands such as when line numbers or ranges exceed the\n\t   number of available lines.  When ed reads from a pipe, it rejects\n\t   invalid commands and treats the next line as a new command, which\n\t   can lead to arbitrary command execution.  */\n\n\ttmpfd = make_tempfile (&tmpname, 'e', NULL, O_RDWR | O_BINARY, 0);\n\tif (tmpfd == -1)\n\t  pfatal (\"Can't create temporary file %s\", quotearg (tmpname));\n\ttmpfp = fdopen (tmpfd, \"w+b\");\n\tif (! tmpfp)\n\t  pfatal (\"Can't open stream for file %s\", quotearg (tmpname));\n      }\n\n    for (;;) {\n\tchar ed_command_letter;\n\tbeginning_of_this_line = file_tell (pfp);\n\tchars_read = get_line ();\n\tif (! chars_read) {\n\t    next_intuit_at(beginning_of_this_line,p_input_line);\n\t    break;\n\t}\n\ted_command_letter = get_ed_command_letter (buf);\n\tif (ed_command_letter) {\n\t    if (tmpfp)\n\t\tif (! fwrite (buf, sizeof *buf, chars_read, tmpfp))\n\t\t    write_fatal ();\n\t    if (ed_command_letter != 'd' && ed_command_letter != 's') {\n\t        p_pass_comments_through = true;\n\t\twhile ((chars_read = get_line ()) != 0) {\n\t\t    if (tmpfp)\n\t\t\tif (! fwrite (buf, sizeof *buf, chars_read, tmpfp))\n\t\t\t    write_fatal ();\n\t\t    if (chars_read == 2  &&  strEQ (buf, \".\\n\"))\n\t\t\tbreak;\n\t\t}\n\t\tp_pass_comments_through = false;\n\t    }\n\t}\n\telse {\n\t    next_intuit_at(beginning_of_this_line,p_input_line);\n\t    break;\n\t}\n    }\n    if (!tmpfp)\n      return;\n    if (fwrite (\"w\\nq\\n\", sizeof (char), (size_t) 4, tmpfp) == 0\n\t|| fflush (tmpfp) != 0)\n      write_fatal ();\n\n    if (lseek (tmpfd, 0, SEEK_SET) == -1)\n      pfatal (\"Can't rewind to the beginning of file %s\", quotearg (tmpname));\n\n    if (! dry_run && ! skip_rest_of_patch) {\n\tint exclusive = *outname_needs_removal ? 0 : O_EXCL;\n\t*outname_needs_removal = true;\n\tif (inerrno != ENOENT)\n\t  {\n \t    *outname_needs_removal = true;\n \t    copy_file (inname, outname, 0, exclusive, instat.st_mode, true);\n \t  }\n \tfflush (stdout);\n \n \tpid = fork();\n\tfflush (stdout);\n\n \telse if (pid == 0)\n \t  {\n \t    dup2 (tmpfd, 0);\n\t    assert (outname[0] != '!' && outname[0] != '-');\n\t    execlp (editor_program, editor_program, \"-\", outname, (char  *) NULL);\n \t    _exit (2);\n \t  }\n \telse\n\t  }\n\telse\n\t  {\n\t    int wstatus;\n\t    if (waitpid (pid, &wstatus, 0) == -1\n\t        || ! WIFEXITED (wstatus)\n\t\t|| WEXITSTATUS (wstatus) != 0)\n\t      fatal (\"%s FAILED\", editor_program);\n\t  }\n    }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143976,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "PHPAPI char *php_escape_shell_arg(char *str)\n{\n\tint x, y = 0, l = strlen(str);\n\tchar *cmd;\n\tsize_t estimate = (4 * l) + 3;\n\n\tTSRMLS_FETCH();\n\n\tcmd = safe_emalloc(4, l, 3); /* worst case */\n\n#ifdef PHP_WIN32\n\tcmd[y++] = '\"';\n#else\n\tcmd[y++] = '\\'';\n#endif\n\n\tfor (x = 0; x < l; x++) {\n\t\tint mb_len = php_mblen(str + x, (l - x));\n\n\t\t/* skip non-valid multibyte characters */\n\t\tif (mb_len < 0) {\n\t\t\tcontinue;\n\t\t} else if (mb_len > 1) {\n\t\t\tmemcpy(cmd + y, str + x, mb_len);\n\t\t\ty += mb_len;\n\t\t\tx += mb_len - 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (str[x]) {\n#ifdef PHP_WIN32\n\t\tcase '\"':\n\t\tcase '%':\n\t\t\tcmd[y++] = ' ';\n\t\t\tbreak;\n#else\n\t\tcase '\\'':\n\t\t\tcmd[y++] = '\\'';\n\t\t\tcmd[y++] = '\\\\';\n\t\t\tcmd[y++] = '\\'';\n#endif\n\t\t\t/* fall-through */\n\t\tdefault:\n\t\t\tcmd[y++] = str[x];\n                }\n        }\n #ifdef PHP_WIN32\n        cmd[y++] = '\"';\n #else\n        cmd[y++] = '\\'';\n\treturn cmd;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144383,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "PHPAPI char *php_escape_shell_arg(char *str)\n{\n\tint x, y = 0, l = strlen(str);\n\tchar *cmd;\n\tsize_t estimate = (4 * l) + 3;\n\n\tTSRMLS_FETCH();\n\n\tcmd = safe_emalloc(4, l, 3); /* worst case */\n\n#ifdef PHP_WIN32\n\tcmd[y++] = '\"';\n#else\n\tcmd[y++] = '\\'';\n#endif\n\n\tfor (x = 0; x < l; x++) {\n\t\tint mb_len = php_mblen(str + x, (l - x));\n\n\t\t/* skip non-valid multibyte characters */\n\t\tif (mb_len < 0) {\n\t\t\tcontinue;\n\t\t} else if (mb_len > 1) {\n\t\t\tmemcpy(cmd + y, str + x, mb_len);\n\t\t\ty += mb_len;\n\t\t\tx += mb_len - 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (str[x]) {\n#ifdef PHP_WIN32\n\t\tcase '\"':\n\t\tcase '%':\n\t\t\tcmd[y++] = ' ';\n\t\t\tbreak;\n#else\n\t\tcase '\\'':\n\t\t\tcmd[y++] = '\\'';\n\t\t\tcmd[y++] = '\\\\';\n\t\t\tcmd[y++] = '\\'';\n#endif\n\t\t\t/* fall-through */\n\t\tdefault:\n\t\t\tcmd[y++] = str[x];\n                }\n        }\n #ifdef PHP_WIN32\n       if (y > 0 && '\\\\' == cmd[y - 1]) {\n               int k = 0, n = y - 1;\n               for (; n >= 0 && '\\\\' == cmd[n]; n--, k++);\n               if (k % 2) {\n                       cmd[y++] = '\\\\';\n               }\n       }\n\n        cmd[y++] = '\"';\n #else\n        cmd[y++] = '\\'';\n\treturn cmd;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144384,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "std::string queueloader::get_filename(const std::string& str) {\n\tstd::string fn = ctrl->get_dlpath();\n\n\tif (fn[fn.length()-1] != NEWSBEUTER_PATH_SEP[0])\n\t\tfn.append(NEWSBEUTER_PATH_SEP);\n\tchar buf[1024];\n\tsnprintf(buf, sizeof(buf), \"%s\", str.c_str());\n\tchar * base = basename(buf);\n\tif (!base || strlen(base) == 0) {\n\t\tchar lbuf[128];\n\t\ttime_t t = time(nullptr);\n\t\tstrftime(lbuf, sizeof(lbuf), \"%Y-%b-%d-%H%M%S.unknown\", localtime(&t));\n\t\tfn.append(lbuf);\n\t} else {\n\t\tfn.append(base);\n\t}\n\treturn fn;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144986,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "std::string queueloader::get_filename(const std::string& str) {\n\tstd::string fn = ctrl->get_dlpath();\n\n\tif (fn[fn.length()-1] != NEWSBEUTER_PATH_SEP[0])\n\t\tfn.append(NEWSBEUTER_PATH_SEP);\n\tchar buf[1024];\n\tsnprintf(buf, sizeof(buf), \"%s\", str.c_str());\n\tchar * base = basename(buf);\n\tif (!base || strlen(base) == 0) {\n\t\tchar lbuf[128];\n\t\ttime_t t = time(nullptr);\n\t\tstrftime(lbuf, sizeof(lbuf), \"%Y-%b-%d-%H%M%S.unknown\", localtime(&t));\n\t\tfn.append(lbuf);\n\t} else {\n\t\tfn.append(utils::replace_all(base, \"'\", \"%27\"));\n\t}\n\treturn fn;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144987,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "void pb_controller::play_file(const std::string& file) {\n\tstd::string cmdline;\n\tstd::string player = cfg->get_configvalue(\"player\");\n\tif (player == \"\")\n\t\treturn;\n\tcmdline.append(player);\n\tcmdline.append(\" \\\"\");\n\tcmdline.append(utils::replace_all(file,\"\\\"\", \"\\\\\\\"\"));\n\tcmdline.append(\"\\\"\");\n\tstfl::reset();\n\tutils::run_interactively(cmdline, \"pb_controller::play_file\");\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144988,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "void pb_controller::play_file(const std::string& file) {\n\tstd::string cmdline;\n\tstd::string player = cfg->get_configvalue(\"player\");\n\tif (player == \"\")\n\t\treturn;\n\tcmdline.append(player);\n\tcmdline.append(\" '\");\n\tcmdline.append(utils::replace_all(file,\"'\", \"%27\"));\n\tcmdline.append(\"'\");\n\tstfl::reset();\n\tutils::run_interactively(cmdline, \"pb_controller::play_file\");\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144989,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "  void DefaultEnv::Initialize()\n  {\n    sLog           = new Log();\n    SetUpLog();\n\n    sEnv           = new DefaultEnv();\n    sForkHandler   = new ForkHandler();\n    sFileTimer     = new FileTimer();\n    sPlugInManager = new PlugInManager();\n\n    sPlugInManager->ProcessEnvironmentSettings();\n    sForkHandler->RegisterFileTimer( sFileTimer );\n\n    //--------------------------------------------------------------------------\n    // MacOSX library loading is completely moronic. We cannot dlopen a library\n    // from a thread other than a main thread, so we-pre dlopen all the\n    // libraries that we may potentially want.\n    //--------------------------------------------------------------------------\n#ifdef __APPLE__\n    char *errBuff = new char[1024];\n\n    const char *libs[] =\n    {\n      \"libXrdSeckrb5.so\",\n      \"libXrdSecgsi.so\",\n      \"libXrdSecgsiAuthzVO.so\",\n      \"libXrdSecgsiGMAPDN.so\",\n      \"libXrdSecgsiGMAPLDAP.so\",\n      \"libXrdSecpwd.so\",\n      \"libXrdSecsss.so\",\n      \"libXrdSecunix.so\",\n      0\n    };\n\n    for( int i = 0; libs[i]; ++i )\n    {\n      sLog->Debug( UtilityMsg, \"Attempting to pre-load: %s\", libs[i] );\n      bool ok = XrdOucPreload( libs[i], errBuff, 1024 );\n      if( !ok )\n        sLog->Error( UtilityMsg, \"Unable to pre-load %s: %s\", libs[i], errBuff );\n    }\n    delete [] errBuff;\n#endif\n  }",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145114,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "  void DefaultEnv::Initialize()\n  {\n    sLog           = new Log();\n    SetUpLog();\n\n    sEnv           = new DefaultEnv();\n    sForkHandler   = new ForkHandler();\n    sFileTimer     = new FileTimer();\n    sPlugInManager = new PlugInManager();\n\n    sPlugInManager->ProcessEnvironmentSettings();\n    sForkHandler->RegisterFileTimer( sFileTimer );\n\n    //--------------------------------------------------------------------------\n    // MacOSX library loading is completely moronic. We cannot dlopen a library\n    // from a thread other than a main thread, so we-pre dlopen all the\n    // libraries that we may potentially want.\n    //--------------------------------------------------------------------------\n#ifdef __APPLE__\n    char *errBuff = new char[1024];\n\n    const char *libs[] =\n    {\n      \"libXrdSeckrb5.so\",\n      \"libXrdSecgsi.so\",\n      \"libXrdSecgsiAuthzVO.so\",\n      \"libXrdSecgsiGMAPDN.so\",\n      \"libXrdSecpwd.so\",\n      \"libXrdSecsss.so\",\n      \"libXrdSecunix.so\",\n      0\n    };\n\n    for( int i = 0; libs[i]; ++i )\n    {\n      sLog->Debug( UtilityMsg, \"Attempting to pre-load: %s\", libs[i] );\n      bool ok = XrdOucPreload( libs[i], errBuff, 1024 );\n      if( !ok )\n        sLog->Error( UtilityMsg, \"Unable to pre-load %s: %s\", libs[i], errBuff );\n    }\n    delete [] errBuff;\n#endif\n  }",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145115,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "openscript(\n    char_u\t*name,\n    int\t\tdirectly)\t/* when TRUE execute directly */\n{\n    if (curscript + 1 == NSCRIPT)\n    {\n\temsg(_(e_nesting));\n\treturn;\n    }\n#ifdef FEAT_EVAL\n    if (ignore_script)\n\t/* Not reading from script, also don't open one.  Warning message? */\n\treturn;\n#endif\n\n    if (scriptin[curscript] != NULL)\t/* already reading script */\n\t++curscript;\n\t\t\t\t/* use NameBuff for expanded name */\n    expand_env(name, NameBuff, MAXPATHL);\n    if ((scriptin[curscript] = mch_fopen((char *)NameBuff, READBIN)) == NULL)\n    {\n\tsemsg(_(e_notopen), name);\n\tif (curscript)\n\t    --curscript;\n\treturn;\n    }\n    if (save_typebuf() == FAIL)\n\treturn;\n\n    /*\n     * Execute the commands from the file right now when using \":source!\"\n     * after \":global\" or \":argdo\" or in a loop.  Also when another command\n     * follows.  This means the display won't be updated.  Don't do this\n     * always, \"make test\" would fail.\n     */\n    if (directly)\n    {\n\toparg_T\toa;\n\tint\toldcurscript;\n\tint\tsave_State = State;\n\tint\tsave_restart_edit = restart_edit;\n\tint\tsave_insertmode = p_im;\n\tint\tsave_finish_op = finish_op;\n\tint\tsave_msg_scroll = msg_scroll;\n\n\tState = NORMAL;\n\tmsg_scroll = FALSE;\t/* no msg scrolling in Normal mode */\n\trestart_edit = 0;\t/* don't go to Insert mode */\n\tp_im = FALSE;\t\t/* don't use 'insertmode' */\n\tclear_oparg(&oa);\n\tfinish_op = FALSE;\n\n\toldcurscript = curscript;\n\tdo\n\t{\n\t    update_topline_cursor();\t// update cursor position and topline\n\t    normal_cmd(&oa, FALSE);\t// execute one command\n\t    vpeekc();\t\t\t// check for end of file\n\t}\n\twhile (scriptin[oldcurscript] != NULL);\n\n\tState = save_State;\n\tmsg_scroll = save_msg_scroll;\n\trestart_edit = save_restart_edit;\n\tp_im = save_insertmode;\n\tfinish_op = save_finish_op;\n    }\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145472,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "openscript(\n    char_u\t*name,\n    int\t\tdirectly)\t/* when TRUE execute directly */\n{\n    if (curscript + 1 == NSCRIPT)\n    {\n\temsg(_(e_nesting));\n\treturn;\n    }\n\n    // Disallow sourcing a file in the sandbox, the commands would be executed\n    // later, possibly outside of the sandbox.\n    if (check_secure())\n\treturn;\n\n#ifdef FEAT_EVAL\n    if (ignore_script)\n\t/* Not reading from script, also don't open one.  Warning message? */\n\treturn;\n#endif\n\n    if (scriptin[curscript] != NULL)\t/* already reading script */\n\t++curscript;\n\t\t\t\t/* use NameBuff for expanded name */\n    expand_env(name, NameBuff, MAXPATHL);\n    if ((scriptin[curscript] = mch_fopen((char *)NameBuff, READBIN)) == NULL)\n    {\n\tsemsg(_(e_notopen), name);\n\tif (curscript)\n\t    --curscript;\n\treturn;\n    }\n    if (save_typebuf() == FAIL)\n\treturn;\n\n    /*\n     * Execute the commands from the file right now when using \":source!\"\n     * after \":global\" or \":argdo\" or in a loop.  Also when another command\n     * follows.  This means the display won't be updated.  Don't do this\n     * always, \"make test\" would fail.\n     */\n    if (directly)\n    {\n\toparg_T\toa;\n\tint\toldcurscript;\n\tint\tsave_State = State;\n\tint\tsave_restart_edit = restart_edit;\n\tint\tsave_insertmode = p_im;\n\tint\tsave_finish_op = finish_op;\n\tint\tsave_msg_scroll = msg_scroll;\n\n\tState = NORMAL;\n\tmsg_scroll = FALSE;\t/* no msg scrolling in Normal mode */\n\trestart_edit = 0;\t/* don't go to Insert mode */\n\tp_im = FALSE;\t\t/* don't use 'insertmode' */\n\tclear_oparg(&oa);\n\tfinish_op = FALSE;\n\n\toldcurscript = curscript;\n\tdo\n\t{\n\t    update_topline_cursor();\t// update cursor position and topline\n\t    normal_cmd(&oa, FALSE);\t// execute one command\n\t    vpeekc();\t\t\t// check for end of file\n\t}\n\twhile (scriptin[oldcurscript] != NULL);\n\n\tState = save_State;\n\tmsg_scroll = save_msg_scroll;\n\trestart_edit = save_restart_edit;\n\tp_im = save_insertmode;\n\tfinish_op = save_finish_op;\n    }\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145473,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "call_hook(struct module_qstate* qstate, struct ipsecmod_qstate* iq,\n\tstruct ipsecmod_env* ATTR_UNUSED(ie))\n{\n\tsize_t slen, tempdata_len, tempstring_len, i;\n\tchar str[65535], *s, *tempstring;\n\tint w;\n\tstruct ub_packed_rrset_key* rrset_key;\n\tstruct packed_rrset_data* rrset_data;\n\tuint8_t *tempdata;\n\n\t/* Check if a shell is available */\n\tif(system(NULL) == 0) {\n\t\tlog_err(\"ipsecmod: no shell available for ipsecmod-hook\");\n\t\treturn 0;\n\t}\n\n\t/* Zero the buffer. */\n\ts = str;\n\tslen = sizeof(str);\n\tmemset(s, 0, slen);\n\n\t/* Copy the hook into the buffer. */\n\tsldns_str_print(&s, &slen, \"%s\", qstate->env->cfg->ipsecmod_hook);\n\t/* Put space into the buffer. */\n\tsldns_str_print(&s, &slen, \" \");\n\t/* Copy the qname into the buffer. */\n\ttempstring = sldns_wire2str_dname(qstate->qinfo.qname,\n\t\tqstate->qinfo.qname_len);\n\tif(!tempstring) {\n\t\tlog_err(\"ipsecmod: out of memory when calling the hook\");\n\t\treturn 0;\n\t}\n\tsldns_str_print(&s, &slen, \"\\\"%s\\\"\", tempstring);\n\tfree(tempstring);\n\t/* Put space into the buffer. */\n\tsldns_str_print(&s, &slen, \" \");\n\t/* Copy the IPSECKEY TTL into the buffer. */\n\trrset_data = (struct packed_rrset_data*)iq->ipseckey_rrset->entry.data;\n\tsldns_str_print(&s, &slen, \"\\\"%ld\\\"\", (long)rrset_data->ttl);\n\t/* Put space into the buffer. */\n\tsldns_str_print(&s, &slen, \" \");\n\t/* Copy the A/AAAA record(s) into the buffer. Start and end this section\n\t * with a double quote. */\n\trrset_key = reply_find_answer_rrset(&qstate->return_msg->qinfo,\n\t\tqstate->return_msg->rep);\n\trrset_data = (struct packed_rrset_data*)rrset_key->entry.data;\n\tsldns_str_print(&s, &slen, \"\\\"\");\n\tfor(i=0; i<rrset_data->count; i++) {\n\t\tif(i > 0) {\n\t\t\t/* Put space into the buffer. */\n\t\t\tsldns_str_print(&s, &slen, \" \");\n\t\t}\n\t\t/* Ignore the first two bytes, they are the rr_data len. */\n\t\tw = sldns_wire2str_rdata_buf(rrset_data->rr_data[i] + 2,\n\t\t\trrset_data->rr_len[i] - 2, s, slen, qstate->qinfo.qtype);\n\t\tif(w < 0) {\n\t\t\t/* Error in printout. */\n\t\t\treturn -1;\n\t\t} else if((size_t)w >= slen) {\n\t\t\ts = NULL; /* We do not want str to point outside of buffer. */\n\t\t\tslen = 0;\n\t\t\treturn -1;\n\t\t} else {\n\t\t\ts += w;\n\t\t\tslen -= w;\n\t\t}\n\t}\n\tsldns_str_print(&s, &slen, \"\\\"\");\n\t/* Put space into the buffer. */\n\tsldns_str_print(&s, &slen, \" \");\n\t/* Copy the IPSECKEY record(s) into the buffer. Start and end this section\n\t * with a double quote. */\n\tsldns_str_print(&s, &slen, \"\\\"\");\n\trrset_data = (struct packed_rrset_data*)iq->ipseckey_rrset->entry.data;\n\tfor(i=0; i<rrset_data->count; i++) {\n\t\tif(i > 0) {\n\t\t\t/* Put space into the buffer. */\n\t\t\tsldns_str_print(&s, &slen, \" \");\n\t\t}\n\t\t/* Ignore the first two bytes, they are the rr_data len. */\n\t\ttempdata = rrset_data->rr_data[i] + 2;\n\t\ttempdata_len = rrset_data->rr_len[i] - 2;\n\t\t/* Save the buffer pointers. */\n\t\ttempstring = s; tempstring_len = slen;\n\t\tw = sldns_wire2str_ipseckey_scan(&tempdata, &tempdata_len, &s, &slen,\n\t\t\tNULL, 0);\n\t\t/* There was an error when parsing the IPSECKEY; reset the buffer\n\t\t * pointers to their previous values. */\n\t\tif(w == -1){\n\t\t\ts = tempstring; slen = tempstring_len;\n\t\t}\n\t}\n\tsldns_str_print(&s, &slen, \"\\\"\");\n\tverbose(VERB_ALGO, \"ipsecmod: hook command: '%s'\", str);\n\t/* ipsecmod-hook should return 0 on success. */\n\tif(system(str) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145630,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "call_hook(struct module_qstate* qstate, struct ipsecmod_qstate* iq,\n\tstruct ipsecmod_env* ATTR_UNUSED(ie))\n{\n\tsize_t slen, tempdata_len, tempstring_len, i;\n\tchar str[65535], *s, *tempstring;\n\tint w = 0, w_temp, qtype;\n\tstruct ub_packed_rrset_key* rrset_key;\n\tstruct packed_rrset_data* rrset_data;\n\tuint8_t *tempdata;\n\n\t/* Check if a shell is available */\n\tif(system(NULL) == 0) {\n\t\tlog_err(\"ipsecmod: no shell available for ipsecmod-hook\");\n\t\treturn 0;\n\t}\n\n\t/* Zero the buffer. */\n\ts = str;\n\tslen = sizeof(str);\n\tmemset(s, 0, slen);\n\n\t/* Copy the hook into the buffer. */\n\tw += sldns_str_print(&s, &slen, \"%s\", qstate->env->cfg->ipsecmod_hook);\n\t/* Put space into the buffer. */\n\tw += sldns_str_print(&s, &slen, \" \");\n\t/* Copy the qname into the buffer. */\n\ttempstring = sldns_wire2str_dname(qstate->qinfo.qname,\n\t\tqstate->qinfo.qname_len);\n\tif(!tempstring) {\n\t\tlog_err(\"ipsecmod: out of memory when calling the hook\");\n\t\treturn 0;\n\t}\n\tif(!domainname_has_safe_characters(tempstring, strlen(tempstring))) {\n\t\tlog_err(\"ipsecmod: qname has unsafe characters\");\n\t\tfree(tempstring);\n\t\treturn 0;\n\t}\n\tw += sldns_str_print(&s, &slen, \"\\\"%s\\\"\", tempstring);\n\tfree(tempstring);\n\t/* Put space into the buffer. */\n\tw += sldns_str_print(&s, &slen, \" \");\n\t/* Copy the IPSECKEY TTL into the buffer. */\n\trrset_data = (struct packed_rrset_data*)iq->ipseckey_rrset->entry.data;\n\tw += sldns_str_print(&s, &slen, \"\\\"%ld\\\"\", (long)rrset_data->ttl);\n\t/* Put space into the buffer. */\n\tw += sldns_str_print(&s, &slen, \" \");\n\trrset_key = reply_find_answer_rrset(&qstate->return_msg->qinfo,\n\t\tqstate->return_msg->rep);\n\t/* Double check that the records are indeed A/AAAA.\n\t * This should never happen as this function is only executed for A/AAAA\n\t * queries but make sure we don't pass anything other than A/AAAA to the\n\t * shell. */\n\tqtype = ntohs(rrset_key->rk.type);\n\tif(qtype != LDNS_RR_TYPE_AAAA && qtype != LDNS_RR_TYPE_A) {\n\t\tlog_err(\"ipsecmod: Answer is not of A or AAAA type\");\n\t\treturn 0;\n\t}\n\trrset_data = (struct packed_rrset_data*)rrset_key->entry.data;\n\t/* Copy the A/AAAA record(s) into the buffer. Start and end this section\n\t * with a double quote. */\n\tw += sldns_str_print(&s, &slen, \"\\\"\");\n\tfor(i=0; i<rrset_data->count; i++) {\n\t\tif(i > 0) {\n\t\t\t/* Put space into the buffer. */\n\t\t\tw += sldns_str_print(&s, &slen, \" \");\n\t\t}\n\t\t/* Ignore the first two bytes, they are the rr_data len. */\n\t\tw_temp = sldns_wire2str_rdata_buf(rrset_data->rr_data[i] + 2,\n\t\t\trrset_data->rr_len[i] - 2, s, slen, qstate->qinfo.qtype);\n\t\tif(w_temp < 0) {\n\t\t\t/* Error in printout. */\n\t\t\tlog_err(\"ipsecmod: Error in printing IP address\");\n\t\t\treturn 0;\n\t\t} else if((size_t)w_temp >= slen) {\n\t\t\ts = NULL; /* We do not want str to point outside of buffer. */\n\t\t\tslen = 0;\n\t\t\tlog_err(\"ipsecmod: shell command too long\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\ts += w_temp;\n\t\t\tslen -= w_temp;\n\t\t\tw += w_temp;\n\t\t}\n\t}\n\tw += sldns_str_print(&s, &slen, \"\\\"\");\n\t/* Put space into the buffer. */\n\tw += sldns_str_print(&s, &slen, \" \");\n\t/* Copy the IPSECKEY record(s) into the buffer. Start and end this section\n\t * with a double quote. */\n\tw += sldns_str_print(&s, &slen, \"\\\"\");\n\trrset_data = (struct packed_rrset_data*)iq->ipseckey_rrset->entry.data;\n\tfor(i=0; i<rrset_data->count; i++) {\n\t\tif(i > 0) {\n\t\t\t/* Put space into the buffer. */\n\t\t\tw += sldns_str_print(&s, &slen, \" \");\n\t\t}\n\t\t/* Ignore the first two bytes, they are the rr_data len. */\n\t\ttempdata = rrset_data->rr_data[i] + 2;\n\t\ttempdata_len = rrset_data->rr_len[i] - 2;\n\t\t/* Save the buffer pointers. */\n\t\ttempstring = s; tempstring_len = slen;\n\t\tw_temp = sldns_wire2str_ipseckey_scan(&tempdata, &tempdata_len, &s,\n\t\t\t&slen, NULL, 0);\n\t\t/* There was an error when parsing the IPSECKEY; reset the buffer\n\t\t * pointers to their previous values. */\n\t\tif(w_temp == -1) {\n\t\t\ts = tempstring; slen = tempstring_len;\n\t\t} else if(w_temp > 0) {\n\t\t\tif(!ipseckey_has_safe_characters(\n\t\t\t\t\ttempstring, tempstring_len - slen)) {\n\t\t\t\tlog_err(\"ipsecmod: ipseckey has unsafe characters\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tw += w_temp;\n\t\t}\n\t}\n\tw += sldns_str_print(&s, &slen, \"\\\"\");\n\tif(w >= (int)sizeof(str)) {\n\t\tlog_err(\"ipsecmod: shell command too long\");\n\t\treturn 0;\n\t}\n\tverbose(VERB_ALGO, \"ipsecmod: shell command: '%s'\", str);\n\t/* ipsecmod-hook should return 0 on success. */\n\tif(system(str) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145631,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "static int parse_config(const char *var, const char *value, void *data)\n{\n\tstruct parse_config_parameter *me = data;\n\tstruct submodule *submodule;\n\tstruct strbuf name = STRBUF_INIT, item = STRBUF_INIT;\n\tint ret = 0;\n\n\t/* this also ensures that we only parse submodule entries */\n\tif (!name_and_item_from_var(var, &name, &item))\n\t\treturn 0;\n\n\tsubmodule = lookup_or_create_by_name(me->cache,\n\t\t\t\t\t     me->gitmodules_sha1,\n\t\t\t\t\t     name.buf);\n\n\tif (!strcmp(item.buf, \"path\")) {\n\t\tif (!value)\n\t\t\tret = config_error_nonbool(var);\n\t\telse if (looks_like_command_line_option(value))\n\t\t\twarn_command_line_option(var, value);\n\t\telse if (!me->overwrite && submodule->path)\n\t\t\twarn_multiple_config(me->treeish_name, submodule->name,\n\t\t\t\t\t\"path\");\n\t\telse {\n\t\t\tif (submodule->path)\n\t\t\t\tcache_remove_path(me->cache, submodule);\n\t\t\tfree((void *) submodule->path);\n\t\t\tsubmodule->path = xstrdup(value);\n\t\t\tcache_put_path(me->cache, submodule);\n\t\t}\n\t} else if (!strcmp(item.buf, \"fetchrecursesubmodules\")) {\n\t\t/* when parsing worktree configurations we can die early */\n\t\tint die_on_error = is_null_sha1(me->gitmodules_sha1);\n\t\tif (!me->overwrite &&\n\t\t    submodule->fetch_recurse != RECURSE_SUBMODULES_NONE)\n\t\t\twarn_multiple_config(me->treeish_name, submodule->name,\n\t\t\t\t\t\"fetchrecursesubmodules\");\n\t\telse\n\t\t\tsubmodule->fetch_recurse = parse_fetch_recurse(\n\t\t\t\t\t\t\t\tvar, value,\n\t\t\t\t\t\t\t\tdie_on_error);\n\t} else if (!strcmp(item.buf, \"ignore\")) {\n\t\tif (!value)\n\t\t\tret = config_error_nonbool(var);\n\t\telse if (!me->overwrite && submodule->ignore)\n\t\t\twarn_multiple_config(me->treeish_name, submodule->name,\n\t\t\t\t\t\"ignore\");\n\t\telse if (strcmp(value, \"untracked\") &&\n\t\t\t strcmp(value, \"dirty\") &&\n\t\t\t strcmp(value, \"all\") &&\n\t\t\t strcmp(value, \"none\"))\n\t\t\twarning(\"Invalid parameter '%s' for config option \"\n\t\t\t\t\t\"'submodule.%s.ignore'\", value, name.buf);\n\t\telse {\n\t\t\tfree((void *) submodule->ignore);\n\t\t\tsubmodule->ignore = xstrdup(value);\n\t\t}\n\t} else if (!strcmp(item.buf, \"url\")) {\n\t\tif (!value) {\n\t\t\tret = config_error_nonbool(var);\n\t\t} else if (looks_like_command_line_option(value)) {\n\t\t\twarn_command_line_option(var, value);\n\t\t} else if (!me->overwrite && submodule->url) {\n\t\t\twarn_multiple_config(me->treeish_name, submodule->name,\n\t\t\t\t\t\"url\");\n\t\t} else {\n\t\t\tfree((void *) submodule->url);\n\t\t\tsubmodule->url = xstrdup(value);\n\t\t}\n\t} else if (!strcmp(item.buf, \"update\")) {\n\t\tif (!value)\n\t\t\tret = config_error_nonbool(var);\n\t\telse if (!me->overwrite &&\n\t\t\t submodule->update_strategy.type != SM_UPDATE_UNSPECIFIED)\n\t\t\twarn_multiple_config(me->treeish_name, submodule->name,\n\t\t\t\t\t     \"update\");\n\t\telse if (parse_submodule_update_strategy(value,\n\t\t\t &submodule->update_strategy) < 0)\n\t\t\t\tdie(_(\"invalid value for %s\"), var);\n\t} else if (!strcmp(item.buf, \"shallow\")) {\n\t\tif (!me->overwrite && submodule->recommend_shallow != -1)\n\t\t\twarn_multiple_config(me->treeish_name, submodule->name,\n\t\t\t\t\t     \"shallow\");\n\t\telse\n\t\t\tsubmodule->recommend_shallow =\n\t\t\t\tgit_config_bool(var, value);\n\t} else if (!strcmp(item.buf, \"branch\")) {\n\t\tif (!me->overwrite && submodule->branch)\n\t\t\twarn_multiple_config(me->treeish_name, submodule->name,\n\t\t\t\t\t     \"branch\");\n\t\telse {\n\t\t\tfree((void *)submodule->branch);\n\t\t\tsubmodule->branch = xstrdup(value);\n\t\t}\n\t}\n\n\tstrbuf_release(&name);\n\tstrbuf_release(&item);\n\n\treturn ret;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146090,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "static int parse_config(const char *var, const char *value, void *data)\n{\n\tstruct parse_config_parameter *me = data;\n\tstruct submodule *submodule;\n\tstruct strbuf name = STRBUF_INIT, item = STRBUF_INIT;\n\tint ret = 0;\n\n\t/* this also ensures that we only parse submodule entries */\n\tif (!name_and_item_from_var(var, &name, &item))\n\t\treturn 0;\n\n\tsubmodule = lookup_or_create_by_name(me->cache,\n\t\t\t\t\t     me->gitmodules_sha1,\n\t\t\t\t\t     name.buf);\n\n\tif (!strcmp(item.buf, \"path\")) {\n\t\tif (!value)\n\t\t\tret = config_error_nonbool(var);\n\t\telse if (looks_like_command_line_option(value))\n\t\t\twarn_command_line_option(var, value);\n\t\telse if (!me->overwrite && submodule->path)\n\t\t\twarn_multiple_config(me->treeish_name, submodule->name,\n\t\t\t\t\t\"path\");\n\t\telse {\n\t\t\tif (submodule->path)\n\t\t\t\tcache_remove_path(me->cache, submodule);\n\t\t\tfree((void *) submodule->path);\n\t\t\tsubmodule->path = xstrdup(value);\n\t\t\tcache_put_path(me->cache, submodule);\n\t\t}\n\t} else if (!strcmp(item.buf, \"fetchrecursesubmodules\")) {\n\t\t/* when parsing worktree configurations we can die early */\n\t\tint die_on_error = is_null_sha1(me->gitmodules_sha1);\n\t\tif (!me->overwrite &&\n\t\t    submodule->fetch_recurse != RECURSE_SUBMODULES_NONE)\n\t\t\twarn_multiple_config(me->treeish_name, submodule->name,\n\t\t\t\t\t\"fetchrecursesubmodules\");\n\t\telse\n\t\t\tsubmodule->fetch_recurse = parse_fetch_recurse(\n\t\t\t\t\t\t\t\tvar, value,\n\t\t\t\t\t\t\t\tdie_on_error);\n\t} else if (!strcmp(item.buf, \"ignore\")) {\n\t\tif (!value)\n\t\t\tret = config_error_nonbool(var);\n\t\telse if (!me->overwrite && submodule->ignore)\n\t\t\twarn_multiple_config(me->treeish_name, submodule->name,\n\t\t\t\t\t\"ignore\");\n\t\telse if (strcmp(value, \"untracked\") &&\n\t\t\t strcmp(value, \"dirty\") &&\n\t\t\t strcmp(value, \"all\") &&\n\t\t\t strcmp(value, \"none\"))\n\t\t\twarning(\"Invalid parameter '%s' for config option \"\n\t\t\t\t\t\"'submodule.%s.ignore'\", value, name.buf);\n\t\telse {\n\t\t\tfree((void *) submodule->ignore);\n\t\t\tsubmodule->ignore = xstrdup(value);\n\t\t}\n\t} else if (!strcmp(item.buf, \"url\")) {\n\t\tif (!value) {\n\t\t\tret = config_error_nonbool(var);\n\t\t} else if (looks_like_command_line_option(value)) {\n\t\t\twarn_command_line_option(var, value);\n\t\t} else if (!me->overwrite && submodule->url) {\n\t\t\twarn_multiple_config(me->treeish_name, submodule->name,\n\t\t\t\t\t\"url\");\n\t\t} else {\n\t\t\tfree((void *) submodule->url);\n\t\t\tsubmodule->url = xstrdup(value);\n\t\t}\n\t} else if (!strcmp(item.buf, \"update\")) {\n\t\tif (!value)\n\t\t\tret = config_error_nonbool(var);\n\t\telse if (!me->overwrite &&\n\t\t\t submodule->update_strategy.type != SM_UPDATE_UNSPECIFIED)\n\t\t\twarn_multiple_config(me->treeish_name, submodule->name,\n\t\t\t\t\t     \"update\");\n\t\telse if (parse_submodule_update_strategy(value,\n\t\t\t &submodule->update_strategy) < 0 ||\n\t\t\t submodule->update_strategy.type == SM_UPDATE_COMMAND)\n\t\t\tdie(_(\"invalid value for %s\"), var);\n\t} else if (!strcmp(item.buf, \"shallow\")) {\n\t\tif (!me->overwrite && submodule->recommend_shallow != -1)\n\t\t\twarn_multiple_config(me->treeish_name, submodule->name,\n\t\t\t\t\t     \"shallow\");\n\t\telse\n\t\t\tsubmodule->recommend_shallow =\n\t\t\t\tgit_config_bool(var, value);\n\t} else if (!strcmp(item.buf, \"branch\")) {\n\t\tif (!me->overwrite && submodule->branch)\n\t\t\twarn_multiple_config(me->treeish_name, submodule->name,\n\t\t\t\t\t     \"branch\");\n\t\telse {\n\t\t\tfree((void *)submodule->branch);\n\t\t\tsubmodule->branch = xstrdup(value);\n\t\t}\n\t}\n\n\tstrbuf_release(&name);\n\tstrbuf_release(&item);\n\n\treturn ret;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146091,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "std::string queueloader::get_filename(const std::string& str) {\n\tstd::string fn = ctrl->get_dlpath();\n\n\tif (fn[fn.length()-1] != NEWSBEUTER_PATH_SEP[0])\n\t\tfn.append(NEWSBEUTER_PATH_SEP);\n\tchar buf[1024];\n\tsnprintf(buf, sizeof(buf), \"%s\", str.c_str());\n\tchar * base = basename(buf);\n\tif (!base || strlen(base) == 0) {\n\t\tchar lbuf[128];\n\t\ttime_t t = time(NULL);\n\t\tstrftime(lbuf, sizeof(lbuf), \"%Y-%b-%d-%H%M%S.unknown\", localtime(&t));\n\t\tfn.append(lbuf);\n\t} else {\n\t\tfn.append(base);\n\t}\n\treturn fn;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146246,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "std::string queueloader::get_filename(const std::string& str) {\n\tstd::string fn = ctrl->get_dlpath();\n\n\tif (fn[fn.length()-1] != NEWSBEUTER_PATH_SEP[0])\n\t\tfn.append(NEWSBEUTER_PATH_SEP);\n\tchar buf[1024];\n\tsnprintf(buf, sizeof(buf), \"%s\", str.c_str());\n\tchar * base = basename(buf);\n\tif (!base || strlen(base) == 0) {\n\t\tchar lbuf[128];\n\t\ttime_t t = time(NULL);\n\t\tstrftime(lbuf, sizeof(lbuf), \"%Y-%b-%d-%H%M%S.unknown\", localtime(&t));\n\t\tfn.append(lbuf);\n\t} else {\n\t\tfn.append(utils::replace_all(base, \"'\", \"%27\"));\n\t}\n\treturn fn;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146247,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "void pb_controller::play_file(const std::string& file) {\n\tstd::string cmdline;\n\tstd::string player = cfg->get_configvalue(\"player\");\n\tif (player == \"\")\n\t\treturn;\n\tcmdline.append(player);\n\tcmdline.append(\" \\\"\");\n\tcmdline.append(utils::replace_all(file,\"\\\"\", \"\\\\\\\"\"));\n\tcmdline.append(\"\\\"\");\n\tstfl::reset();\n\tLOG(LOG_DEBUG, \"pb_controller::play_file: running `%s'\", cmdline.c_str());\n\t::system(cmdline.c_str());\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146248,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "void pb_controller::play_file(const std::string& file) {\n\tstd::string cmdline;\n\tstd::string player = cfg->get_configvalue(\"player\");\n\tif (player == \"\")\n\t\treturn;\n\tcmdline.append(player);\n\tcmdline.append(\" \\'\");\n\tcmdline.append(utils::replace_all(file,\"'\", \"%27\"));\n\tcmdline.append(\"\\'\");\n\tstfl::reset();\n\tLOG(LOG_DEBUG, \"pb_controller::play_file: running `%s'\", cmdline.c_str());\n\t::system(cmdline.c_str());\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146249,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "deliver_message(uschar *id, BOOL forced, BOOL give_up)\n{\nint i, rc;\nint final_yield = DELIVER_ATTEMPTED_NORMAL;\ntime_t now = time(NULL);\naddress_item *addr_last = NULL;\nuschar *filter_message = NULL;\nint process_recipients = RECIP_ACCEPT;\nopen_db dbblock;\nopen_db *dbm_file;\nextern int acl_where;\n\nuschar *info = queue_run_pid == (pid_t)0\n  ? string_sprintf(\"delivering %s\", id)\n  : string_sprintf(\"delivering %s (queue run pid %d)\", id, queue_run_pid);\n\n/* If the D_process_info bit is on, set_process_info() will output debugging\ninformation. If not, we want to show this initial information if D_deliver or\nD_queue_run is set or in verbose mode. */\n\nset_process_info(\"%s\", info);\n\nif (  !(debug_selector & D_process_info)\n   && (debug_selector & (D_deliver|D_queue_run|D_v))\n   )\n  debug_printf(\"%s\\n\", info);\n\n/* Ensure that we catch any subprocesses that are created. Although Exim\nsets SIG_DFL as its initial default, some routes through the code end up\nhere with it set to SIG_IGN - cases where a non-synchronous delivery process\nhas been forked, but no re-exec has been done. We use sigaction rather than\nplain signal() on those OS where SA_NOCLDWAIT exists, because we want to be\nsure it is turned off. (There was a problem on AIX with this.) */\n\n#ifdef SA_NOCLDWAIT\n  {\n  struct sigaction act;\n  act.sa_handler = SIG_DFL;\n  sigemptyset(&(act.sa_mask));\n  act.sa_flags = 0;\n  sigaction(SIGCHLD, &act, NULL);\n  }\n#else\nsignal(SIGCHLD, SIG_DFL);\n#endif\n\n/* Make the forcing flag available for routers and transports, set up the\nglobal message id field, and initialize the count for returned files and the\nmessage size. This use of strcpy() is OK because the length id is checked when\nit is obtained from a command line (the -M or -q options), and otherwise it is\nknown to be a valid message id. */\n\nif (id != message_id)\n  Ustrcpy(message_id, id);\ndeliver_force = forced;\nreturn_count = 0;\nmessage_size = 0;\n\n/* Initialize some flags */\n\nupdate_spool = FALSE;\nremove_journal = TRUE;\n\n/* Set a known context for any ACLs we call via expansions */\nacl_where = ACL_WHERE_DELIVERY;\n\n/* Reset the random number generator, so that if several delivery processes are\nstarted from a queue runner that has already used random numbers (for sorting),\nthey don't all get the same sequence. */\n\nrandom_seed = 0;\n\n/* Open and lock the message's data file. Exim locks on this one because the\nheader file may get replaced as it is re-written during the delivery process.\nAny failures cause messages to be written to the log, except for missing files\nwhile queue running - another process probably completed delivery. As part of\nopening the data file, message_subdir gets set. */\n\nif ((deliver_datafile = spool_open_datafile(id)) < 0)\n  return continue_closedown();  /* yields DELIVER_NOT_ATTEMPTED */\n\n/* The value of message_size at this point has been set to the data length,\nplus one for the blank line that notionally precedes the data. */\n\n/* Now read the contents of the header file, which will set up the headers in\nstore, and also the list of recipients and the tree of non-recipients and\nassorted flags. It updates message_size. If there is a reading or format error,\ngive up; if the message has been around for sufficiently long, remove it. */\n\n  {\n  uschar * spoolname = string_sprintf(\"%s-H\", id);\n  if ((rc = spool_read_header(spoolname, TRUE, TRUE)) != spool_read_OK)\n    {\n    if (errno == ERRNO_SPOOLFORMAT)\n      {\n      struct stat statbuf;\n      if (Ustat(spool_fname(US\"input\", message_subdir, spoolname, US\"\"),\n\t\t&statbuf) == 0)\n\tlog_write(0, LOG_MAIN, \"Format error in spool file %s: \"\n\t  \"size=\" OFF_T_FMT, spoolname, statbuf.st_size);\n      else\n\tlog_write(0, LOG_MAIN, \"Format error in spool file %s\", spoolname);\n      }\n    else\n      log_write(0, LOG_MAIN, \"Error reading spool file %s: %s\", spoolname,\n\tstrerror(errno));\n\n    /* If we managed to read the envelope data, received_time contains the\n    time the message was received. Otherwise, we can calculate it from the\n    message id. */\n\n    if (rc != spool_read_hdrerror)\n      {\n      received_time.tv_sec = received_time.tv_usec = 0;\n      /*XXX subsec precision?*/\n      for (i = 0; i < 6; i++)\n\treceived_time.tv_sec = received_time.tv_sec * BASE_62 + tab62[id[i] - '0'];\n      }\n\n    /* If we've had this malformed message too long, sling it. */\n\n    if (now - received_time.tv_sec > keep_malformed)\n      {\n      Uunlink(spool_fname(US\"msglog\", message_subdir, id, US\"\"));\n      Uunlink(spool_fname(US\"input\", message_subdir, id, US\"-D\"));\n      Uunlink(spool_fname(US\"input\", message_subdir, id, US\"-H\"));\n      Uunlink(spool_fname(US\"input\", message_subdir, id, US\"-J\"));\n      log_write(0, LOG_MAIN, \"Message removed because older than %s\",\n\treadconf_printtime(keep_malformed));\n      }\n\n    (void)close(deliver_datafile);\n    deliver_datafile = -1;\n    return continue_closedown();   /* yields DELIVER_NOT_ATTEMPTED */\n    }\n  }\n\n/* The spool header file has been read. Look to see if there is an existing\njournal file for this message. If there is, it means that a previous delivery\nattempt crashed (program or host) before it could update the spool header file.\nRead the list of delivered addresses from the journal and add them to the\nnonrecipients tree. Then update the spool file. We can leave the journal in\nexistence, as it will get further successful deliveries added to it in this\nrun, and it will be deleted if this function gets to its end successfully.\nOtherwise it might be needed again. */\n\n  {\n  uschar * fname = spool_fname(US\"input\", message_subdir, id, US\"-J\");\n  FILE * jread;\n\n  if (  (journal_fd = Uopen(fname, O_RDWR|O_APPEND\n#ifdef O_CLOEXEC\n\t\t\t\t    | O_CLOEXEC\n#endif\n#ifdef O_NOFOLLOW\n\t\t\t\t    | O_NOFOLLOW\n#endif\n\t, SPOOL_MODE)) >= 0\n     && lseek(journal_fd, 0, SEEK_SET) == 0\n     && (jread = fdopen(journal_fd, \"rb\"))\n     )\n    {\n    while (Ufgets(big_buffer, big_buffer_size, jread))\n      {\n      int n = Ustrlen(big_buffer);\n      big_buffer[n-1] = 0;\n      tree_add_nonrecipient(big_buffer);\n      DEBUG(D_deliver) debug_printf(\"Previously delivered address %s taken from \"\n\t\"journal file\\n\", big_buffer);\n      }\n    rewind(jread);\n    if ((journal_fd = dup(fileno(jread))) < 0)\n      journal_fd = fileno(jread);\n    else\n      (void) fclose(jread);\t/* Try to not leak the FILE resource */\n\n    /* Panic-dies on error */\n    (void)spool_write_header(message_id, SW_DELIVERING, NULL);\n    }\n  else if (errno != ENOENT)\n    {\n    log_write(0, LOG_MAIN|LOG_PANIC, \"attempt to open journal for reading gave: \"\n      \"%s\", strerror(errno));\n    return continue_closedown();   /* yields DELIVER_NOT_ATTEMPTED */\n    }\n\n  /* A null recipients list indicates some kind of disaster. */\n\n  if (!recipients_list)\n    {\n    (void)close(deliver_datafile);\n    deliver_datafile = -1;\n    log_write(0, LOG_MAIN, \"Spool error: no recipients for %s\", fname);\n    return continue_closedown();   /* yields DELIVER_NOT_ATTEMPTED */\n    }\n  }\n\n\n/* Handle a message that is frozen. There are a number of different things that\ncan happen, but in the default situation, unless forced, no delivery is\nattempted. */\n\nif (deliver_freeze)\n  {\n#ifdef SUPPORT_MOVE_FROZEN_MESSAGES\n  /* Moving to another directory removes the message from Exim's view. Other\n  tools must be used to deal with it. Logging of this action happens in\n  spool_move_message() and its subfunctions. */\n\n  if (  move_frozen_messages\n     && spool_move_message(id, message_subdir, US\"\", US\"F\")\n     )\n    return continue_closedown();   /* yields DELIVER_NOT_ATTEMPTED */\n#endif\n\n  /* For all frozen messages (bounces or not), timeout_frozen_after sets the\n  maximum time to keep messages that are frozen. Thaw if we reach it, with a\n  flag causing all recipients to be failed. The time is the age of the\n  message, not the time since freezing. */\n\n  if (timeout_frozen_after > 0 && message_age >= timeout_frozen_after)\n    {\n    log_write(0, LOG_MAIN, \"cancelled by timeout_frozen_after\");\n    process_recipients = RECIP_FAIL_TIMEOUT;\n    }\n\n  /* For bounce messages (and others with no sender), thaw if the error message\n  ignore timer is exceeded. The message will be discarded if this delivery\n  fails. */\n\n  else if (!*sender_address && message_age >= ignore_bounce_errors_after)\n    log_write(0, LOG_MAIN, \"Unfrozen by errmsg timer\");\n\n  /* If this is a bounce message, or there's no auto thaw, or we haven't\n  reached the auto thaw time yet, and this delivery is not forced by an admin\n  user, do not attempt delivery of this message. Note that forced is set for\n  continuing messages down the same channel, in order to skip load checking and\n  ignore hold domains, but we don't want unfreezing in that case. */\n\n  else\n    {\n    if (  (  sender_address[0] == 0\n\t  || auto_thaw <= 0\n\t  || now <= deliver_frozen_at + auto_thaw\n          )\n       && (  !forced || !deliver_force_thaw\n\t  || !admin_user || continue_hostname\n       )  )\n      {\n      (void)close(deliver_datafile);\n      deliver_datafile = -1;\n      log_write(L_skip_delivery, LOG_MAIN, \"Message is frozen\");\n      return continue_closedown();   /* yields DELIVER_NOT_ATTEMPTED */\n      }\n\n    /* If delivery was forced (by an admin user), assume a manual thaw.\n    Otherwise it's an auto thaw. */\n\n    if (forced)\n      {\n      deliver_manual_thaw = TRUE;\n      log_write(0, LOG_MAIN, \"Unfrozen by forced delivery\");\n      }\n    else log_write(0, LOG_MAIN, \"Unfrozen by auto-thaw\");\n    }\n\n  /* We get here if any of the rules for unfreezing have triggered. */\n\n  deliver_freeze = FALSE;\n  update_spool = TRUE;\n  }\n\n\n/* Open the message log file if we are using them. This records details of\ndeliveries, deferments, and failures for the benefit of the mail administrator.\nThe log is not used by exim itself to track the progress of a message; that is\ndone by rewriting the header spool file. */\n\nif (message_logs)\n  {\n  uschar * fname = spool_fname(US\"msglog\", message_subdir, id, US\"\");\n  uschar * error;\n  int fd;\n\n  if ((fd = open_msglog_file(fname, SPOOL_MODE, &error)) < 0)\n    {\n    log_write(0, LOG_MAIN|LOG_PANIC, \"Couldn't %s message log %s: %s\", error,\n      fname, strerror(errno));\n    return continue_closedown();   /* yields DELIVER_NOT_ATTEMPTED */\n    }\n\n  /* Make a C stream out of it. */\n\n  if (!(message_log = fdopen(fd, \"a\")))\n    {\n    log_write(0, LOG_MAIN|LOG_PANIC, \"Couldn't fdopen message log %s: %s\",\n      fname, strerror(errno));\n    return continue_closedown();   /* yields DELIVER_NOT_ATTEMPTED */\n    }\n  }\n\n\n/* If asked to give up on a message, log who did it, and set the action for all\nthe addresses. */\n\nif (give_up)\n  {\n  struct passwd *pw = getpwuid(real_uid);\n  log_write(0, LOG_MAIN, \"cancelled by %s\",\n      pw ? US pw->pw_name : string_sprintf(\"uid %ld\", (long int)real_uid));\n  process_recipients = RECIP_FAIL;\n  }\n\n/* Otherwise, if there are too many Received: headers, fail all recipients. */\n\nelse if (received_count > received_headers_max)\n  process_recipients = RECIP_FAIL_LOOP;\n\n/* Otherwise, if a system-wide, address-independent message filter is\nspecified, run it now, except in the case when we are failing all recipients as\na result of timeout_frozen_after. If the system filter yields \"delivered\", then\nignore the true recipients of the message. Failure of the filter file is\nlogged, and the delivery attempt fails. */\n\nelse if (system_filter && process_recipients != RECIP_FAIL_TIMEOUT)\n  {\n  int rc;\n  int filtertype;\n  ugid_block ugid;\n  redirect_block redirect;\n\n  if (system_filter_uid_set)\n    {\n    ugid.uid = system_filter_uid;\n    ugid.gid = system_filter_gid;\n    ugid.uid_set = ugid.gid_set = TRUE;\n    }\n  else\n    {\n    ugid.uid_set = ugid.gid_set = FALSE;\n    }\n\n  return_path = sender_address;\n  enable_dollar_recipients = TRUE;   /* Permit $recipients in system filter */\n  system_filtering = TRUE;\n\n  /* Any error in the filter file causes a delivery to be abandoned. */\n\n  redirect.string = system_filter;\n  redirect.isfile = TRUE;\n  redirect.check_owner = redirect.check_group = FALSE;\n  redirect.owners = NULL;\n  redirect.owngroups = NULL;\n  redirect.pw = NULL;\n  redirect.modemask = 0;\n\n  DEBUG(D_deliver|D_filter) debug_printf(\"running system filter\\n\");\n\n  rc = rda_interpret(\n    &redirect,              /* Where the data is */\n    RDO_DEFER |             /* Turn on all the enabling options */\n      RDO_FAIL |            /* Leave off all the disabling options */\n      RDO_FILTER |\n      RDO_FREEZE |\n      RDO_REALLOG |\n      RDO_REWRITE,\n    NULL,                   /* No :include: restriction (not used in filter) */\n    NULL,                   /* No sieve vacation directory (not sieve!) */\n    NULL,                   /* No sieve enotify mailto owner (not sieve!) */\n    NULL,                   /* No sieve user address (not sieve!) */\n    NULL,                   /* No sieve subaddress (not sieve!) */\n    &ugid,                  /* uid/gid data */\n    &addr_new,              /* Where to hang generated addresses */\n    &filter_message,        /* Where to put error message */\n    NULL,                   /* Don't skip syntax errors */\n    &filtertype,            /* Will always be set to FILTER_EXIM for this call */\n    US\"system filter\");     /* For error messages */\n\n  DEBUG(D_deliver|D_filter) debug_printf(\"system filter returned %d\\n\", rc);\n\n  if (rc == FF_ERROR || rc == FF_NONEXIST)\n    {\n    (void)close(deliver_datafile);\n    deliver_datafile = -1;\n    log_write(0, LOG_MAIN|LOG_PANIC, \"Error in system filter: %s\",\n      string_printing(filter_message));\n    return continue_closedown();   /* yields DELIVER_NOT_ATTEMPTED */\n    }\n\n  /* Reset things. If the filter message is an empty string, which can happen\n  for a filter \"fail\" or \"freeze\" command with no text, reset it to NULL. */\n\n  system_filtering = FALSE;\n  enable_dollar_recipients = FALSE;\n  if (filter_message && filter_message[0] == 0) filter_message = NULL;\n\n  /* Save the values of the system filter variables so that user filters\n  can use them. */\n\n  memcpy(filter_sn, filter_n, sizeof(filter_sn));\n\n  /* The filter can request that delivery of the original addresses be\n  deferred. */\n\n  if (rc == FF_DEFER)\n    {\n    process_recipients = RECIP_DEFER;\n    deliver_msglog(\"Delivery deferred by system filter\\n\");\n    log_write(0, LOG_MAIN, \"Delivery deferred by system filter\");\n    }\n\n  /* The filter can request that a message be frozen, but this does not\n  take place if the message has been manually thawed. In that case, we must\n  unset \"delivered\", which is forced by the \"freeze\" command to make -bF\n  work properly. */\n\n  else if (rc == FF_FREEZE && !deliver_manual_thaw)\n    {\n    deliver_freeze = TRUE;\n    deliver_frozen_at = time(NULL);\n    process_recipients = RECIP_DEFER;\n    frozen_info = string_sprintf(\" by the system filter%s%s\",\n      filter_message ? US\": \" : US\"\",\n      filter_message ? filter_message : US\"\");\n    }\n\n  /* The filter can request that a message be failed. The error message may be\n  quite long - it is sent back to the sender in the bounce - but we don't want\n  to fill up the log with repetitions of it. If it starts with << then the text\n  between << and >> is written to the log, with the rest left for the bounce\n  message. */\n\n  else if (rc == FF_FAIL)\n    {\n    uschar *colon = US\"\";\n    uschar *logmsg = US\"\";\n    int loglen = 0;\n\n    process_recipients = RECIP_FAIL_FILTER;\n\n    if (filter_message)\n      {\n      uschar *logend;\n      colon = US\": \";\n      if (  filter_message[0] == '<'\n         && filter_message[1] == '<'\n\t && (logend = Ustrstr(filter_message, \">>\"))\n\t )\n        {\n        logmsg = filter_message + 2;\n        loglen = logend - logmsg;\n        filter_message = logend + 2;\n        if (filter_message[0] == 0) filter_message = NULL;\n        }\n      else\n        {\n        logmsg = filter_message;\n        loglen = Ustrlen(filter_message);\n        }\n      }\n\n    log_write(0, LOG_MAIN, \"cancelled by system filter%s%.*s\", colon, loglen,\n      logmsg);\n    }\n\n  /* Delivery can be restricted only to those recipients (if any) that the\n  filter specified. */\n\n  else if (rc == FF_DELIVERED)\n    {\n    process_recipients = RECIP_IGNORE;\n    if (addr_new)\n      log_write(0, LOG_MAIN, \"original recipients ignored (system filter)\");\n    else\n      log_write(0, LOG_MAIN, \"=> discarded (system filter)\");\n    }\n\n  /* If any new addresses were created by the filter, fake up a \"parent\"\n  for them. This is necessary for pipes, etc., which are expected to have\n  parents, and it also gives some sensible logging for others. Allow\n  pipes, files, and autoreplies, and run them as the filter uid if set,\n  otherwise as the current uid. */\n\n  if (addr_new)\n    {\n    int uid = (system_filter_uid_set)? system_filter_uid : geteuid();\n    int gid = (system_filter_gid_set)? system_filter_gid : getegid();\n\n    /* The text \"system-filter\" is tested in transport_set_up_command() and in\n    set_up_shell_command() in the pipe transport, to enable them to permit\n    $recipients, so don't change it here without also changing it there. */\n\n    address_item *p = addr_new;\n    address_item *parent = deliver_make_addr(US\"system-filter\", FALSE);\n\n    parent->domain = string_copylc(qualify_domain_recipient);\n    parent->local_part = US\"system-filter\";\n\n    /* As part of this loop, we arrange for addr_last to end up pointing\n    at the final address. This is used if we go on to add addresses for the\n    original recipients. */\n\n    while (p)\n      {\n      if (parent->child_count == USHRT_MAX)\n        log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"system filter generated more \"\n          \"than %d delivery addresses\", USHRT_MAX);\n      parent->child_count++;\n      p->parent = parent;\n\n      if (testflag(p, af_pfr))\n        {\n        uschar *tpname;\n        uschar *type;\n        p->uid = uid;\n        p->gid = gid;\n        setflag(p, af_uid_set);\n        setflag(p, af_gid_set);\n        setflag(p, af_allow_file);\n        setflag(p, af_allow_pipe);\n        setflag(p, af_allow_reply);\n\n        /* Find the name of the system filter's appropriate pfr transport */\n\n        if (p->address[0] == '|')\n          {\n          type = US\"pipe\";\n          tpname = system_filter_pipe_transport;\n          address_pipe = p->address;\n          }\n        else if (p->address[0] == '>')\n          {\n          type = US\"reply\";\n          tpname = system_filter_reply_transport;\n          }\n        else\n          {\n          if (p->address[Ustrlen(p->address)-1] == '/')\n            {\n            type = US\"directory\";\n            tpname = system_filter_directory_transport;\n            }\n          else\n            {\n            type = US\"file\";\n            tpname = system_filter_file_transport;\n            }\n          address_file = p->address;\n          }\n\n        /* Now find the actual transport, first expanding the name. We have\n        set address_file or address_pipe above. */\n\n        if (tpname)\n          {\n          uschar *tmp = expand_string(tpname);\n          address_file = address_pipe = NULL;\n          if (!tmp)\n            p->message = string_sprintf(\"failed to expand \\\"%s\\\" as a \"\n              \"system filter transport name\", tpname);\n          tpname = tmp;\n          }\n        else\n          p->message = string_sprintf(\"system_filter_%s_transport is unset\",\n            type);\n\n        if (tpname)\n          {\n          transport_instance *tp;\n          for (tp = transports; tp; tp = tp->next)\n            if (Ustrcmp(tp->name, tpname) == 0)\n              {\n              p->transport = tp;\n              break;\n              }\n          if (!tp)\n            p->message = string_sprintf(\"failed to find \\\"%s\\\" transport \"\n              \"for system filter delivery\", tpname);\n          }\n\n        /* If we couldn't set up a transport, defer the delivery, putting the\n        error on the panic log as well as the main log. */\n\n        if (!p->transport)\n          {\n          address_item *badp = p;\n          p = p->next;\n          if (!addr_last) addr_new = p; else addr_last->next = p;\n          badp->local_part = badp->address;   /* Needed for log line */\n          post_process_one(badp, DEFER, LOG_MAIN|LOG_PANIC, EXIM_DTYPE_ROUTER, 0);\n          continue;\n          }\n        }    /* End of pfr handling */\n\n      /* Either a non-pfr delivery, or we found a transport */\n\n      DEBUG(D_deliver|D_filter)\n        debug_printf(\"system filter added %s\\n\", p->address);\n\n      addr_last = p;\n      p = p->next;\n      }    /* Loop through all addr_new addresses */\n    }\n  }\n\n\n/* Scan the recipients list, and for every one that is not in the non-\nrecipients tree, add an addr item to the chain of new addresses. If the pno\nvalue is non-negative, we must set the onetime parent from it. This which\npoints to the relevant entry in the recipients list.\n\nThis processing can be altered by the setting of the process_recipients\nvariable, which is changed if recipients are to be ignored, failed, or\ndeferred. This can happen as a result of system filter activity, or if the -Mg\noption is used to fail all of them.\n\nDuplicate addresses are handled later by a different tree structure; we can't\njust extend the non-recipients tree, because that will be re-written to the\nspool if the message is deferred, and in any case there are casing\ncomplications for local addresses. */\n\nif (process_recipients != RECIP_IGNORE)\n  for (i = 0; i < recipients_count; i++)\n    if (!tree_search(tree_nonrecipients, recipients_list[i].address))\n      {\n      recipient_item *r = recipients_list + i;\n      address_item *new = deliver_make_addr(r->address, FALSE);\n      new->prop.errors_address = r->errors_to;\n#ifdef SUPPORT_I18N\n      if ((new->prop.utf8_msg = message_smtputf8))\n\t{\n\tnew->prop.utf8_downcvt =       message_utf8_downconvert == 1;\n\tnew->prop.utf8_downcvt_maybe = message_utf8_downconvert == -1;\n\tDEBUG(D_deliver) debug_printf(\"utf8, downconvert %s\\n\",\n\t  new->prop.utf8_downcvt ? \"yes\"\n\t  : new->prop.utf8_downcvt_maybe ? \"ifneeded\"\n\t  : \"no\");\n\t}\n#endif\n\n      if (r->pno >= 0)\n        new->onetime_parent = recipients_list[r->pno].address;\n\n      /* If DSN support is enabled, set the dsn flags and the original receipt\n         to be passed on to other DSN enabled MTAs */\n      new->dsn_flags = r->dsn_flags & rf_dsnflags;\n      new->dsn_orcpt = r->orcpt;\n      DEBUG(D_deliver) debug_printf(\"DSN: set orcpt: %s  flags: %d\\n\",\n\tnew->dsn_orcpt ? new->dsn_orcpt : US\"\", new->dsn_flags);\n\n      switch (process_recipients)\n        {\n        /* RECIP_DEFER is set when a system filter freezes a message. */\n\n        case RECIP_DEFER:\n        new->next = addr_defer;\n        addr_defer = new;\n        break;\n\n\n        /* RECIP_FAIL_FILTER is set when a system filter has obeyed a \"fail\"\n        command. */\n\n        case RECIP_FAIL_FILTER:\n        new->message =\n          filter_message ? filter_message : US\"delivery cancelled\";\n        setflag(new, af_pass_message);\n        goto RECIP_QUEUE_FAILED;   /* below */\n\n\n        /* RECIP_FAIL_TIMEOUT is set when a message is frozen, but is older\n        than the value in timeout_frozen_after. Treat non-bounce messages\n        similarly to -Mg; for bounce messages we just want to discard, so\n        don't put the address on the failed list. The timeout has already\n        been logged. */\n\n        case RECIP_FAIL_TIMEOUT:\n        new->message  = US\"delivery cancelled; message timed out\";\n        goto RECIP_QUEUE_FAILED;   /* below */\n\n\n        /* RECIP_FAIL is set when -Mg has been used. */\n\n        case RECIP_FAIL:\n        new->message  = US\"delivery cancelled by administrator\";\n        /* Fall through */\n\n        /* Common code for the failure cases above. If this is not a bounce\n        message, put the address on the failed list so that it is used to\n        create a bounce. Otherwise do nothing - this just discards the address.\n        The incident has already been logged. */\n\n        RECIP_QUEUE_FAILED:\n        if (sender_address[0] != 0)\n          {\n          new->next = addr_failed;\n          addr_failed = new;\n          }\n        break;\n\n\n        /* RECIP_FAIL_LOOP is set when there are too many Received: headers\n        in the message. Process each address as a routing failure; if this\n        is a bounce message, it will get frozen. */\n\n        case RECIP_FAIL_LOOP:\n        new->message = US\"Too many \\\"Received\\\" headers - suspected mail loop\";\n        post_process_one(new, FAIL, LOG_MAIN, EXIM_DTYPE_ROUTER, 0);\n        break;\n\n\n        /* Value should be RECIP_ACCEPT; take this as the safe default. */\n\n        default:\n        if (!addr_new) addr_new = new; else addr_last->next = new;\n        addr_last = new;\n        break;\n        }\n\n#ifndef DISABLE_EVENT\n      if (process_recipients != RECIP_ACCEPT)\n\t{\n\tuschar * save_local =  deliver_localpart;\n\tconst uschar * save_domain = deliver_domain;\n\n\tdeliver_localpart = expand_string(\n\t\t      string_sprintf(\"${local_part:%s}\", new->address));\n\tdeliver_domain =    expand_string(\n\t\t      string_sprintf(\"${domain:%s}\", new->address));\n\n\t(void) event_raise(event_action,\n\t\t      US\"msg:fail:internal\", new->message);\n\n\tdeliver_localpart = save_local;\n\tdeliver_domain =    save_domain;\n\t}\n#endif\n      }\n\nDEBUG(D_deliver)\n  {\n  address_item *p;\n  debug_printf(\"Delivery address list:\\n\");\n  for (p = addr_new; p; p = p->next)\n    debug_printf(\"  %s %s\\n\", p->address,\n      p->onetime_parent ? p->onetime_parent : US\"\");\n  }\n\n/* Set up the buffers used for copying over the file when delivering. */\n\ndeliver_in_buffer = store_malloc(DELIVER_IN_BUFFER_SIZE);\ndeliver_out_buffer = store_malloc(DELIVER_OUT_BUFFER_SIZE);\n\n\n\n/* Until there are no more new addresses, handle each one as follows:\n\n . If this is a generated address (indicated by the presence of a parent\n   pointer) then check to see whether it is a pipe, file, or autoreply, and\n   if so, handle it directly here. The router that produced the address will\n   have set the allow flags into the address, and also set the uid/gid required.\n   Having the routers generate new addresses and then checking them here at\n   the outer level is tidier than making each router do the checking, and\n   means that routers don't need access to the failed address queue.\n\n . Break up the address into local part and domain, and make lowercased\n   versions of these strings. We also make unquoted versions of the local part.\n\n . Handle the percent hack for those domains for which it is valid.\n\n . For child addresses, determine if any of the parents have the same address.\n   If so, generate a different string for previous delivery checking. Without\n   this code, if the address spqr generates spqr via a forward or alias file,\n   delivery of the generated spqr stops further attempts at the top level spqr,\n   which is not what is wanted - it may have generated other addresses.\n\n . Check on the retry database to see if routing was previously deferred, but\n   only if in a queue run. Addresses that are to be routed are put on the\n   addr_route chain. Addresses that are to be deferred are put on the\n   addr_defer chain. We do all the checking first, so as not to keep the\n   retry database open any longer than necessary.\n\n . Now we run the addresses through the routers. A router may put the address\n   on either the addr_local or the addr_remote chain for local or remote\n   delivery, respectively, or put it on the addr_failed chain if it is\n   undeliveable, or it may generate child addresses and put them on the\n   addr_new chain, or it may defer an address. All the chain anchors are\n   passed as arguments so that the routers can be called for verification\n   purposes as well.\n\n . If new addresses have been generated by the routers, da capo.\n*/\n\nheader_rewritten = FALSE;          /* No headers rewritten yet */\nwhile (addr_new)           /* Loop until all addresses dealt with */\n  {\n  address_item *addr, *parent;\n\n  /* Failure to open the retry database is treated the same as if it does\n  not exist. In both cases, dbm_file is NULL. */\n\n  if (!(dbm_file = dbfn_open(US\"retry\", O_RDONLY, &dbblock, FALSE)))\n    DEBUG(D_deliver|D_retry|D_route|D_hints_lookup)\n      debug_printf(\"no retry data available\\n\");\n\n  /* Scan the current batch of new addresses, to handle pipes, files and\n  autoreplies, and determine which others are ready for routing. */\n\n  while (addr_new)\n    {\n    int rc;\n    uschar *p;\n    tree_node *tnode;\n    dbdata_retry *domain_retry_record;\n    dbdata_retry *address_retry_record;\n\n    addr = addr_new;\n    addr_new = addr->next;\n\n    DEBUG(D_deliver|D_retry|D_route)\n      {\n      debug_printf(\">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\\n\");\n      debug_printf(\"Considering: %s\\n\", addr->address);\n      }\n\n    /* Handle generated address that is a pipe or a file or an autoreply. */\n\n    if (testflag(addr, af_pfr))\n      {\n      /* If an autoreply in a filter could not generate a syntactically valid\n      address, give up forthwith. Set af_ignore_error so that we don't try to\n      generate a bounce. */\n\n      if (testflag(addr, af_bad_reply))\n        {\n        addr->basic_errno = ERRNO_BADADDRESS2;\n        addr->local_part = addr->address;\n        addr->message =\n          US\"filter autoreply generated syntactically invalid recipient\";\n        addr->prop.ignore_error = TRUE;\n        (void) post_process_one(addr, FAIL, LOG_MAIN, EXIM_DTYPE_ROUTER, 0);\n        continue;   /* with the next new address */\n        }\n\n      /* If two different users specify delivery to the same pipe or file or\n      autoreply, there should be two different deliveries, so build a unique\n      string that incorporates the original address, and use this for\n      duplicate testing and recording delivery, and also for retrying. */\n\n      addr->unique =\n        string_sprintf(\"%s:%s\", addr->address, addr->parent->unique +\n          (testflag(addr->parent, af_homonym)? 3:0));\n\n      addr->address_retry_key = addr->domain_retry_key =\n        string_sprintf(\"T:%s\", addr->unique);\n\n      /* If a filter file specifies two deliveries to the same pipe or file,\n      we want to de-duplicate, but this is probably not wanted for two mail\n      commands to the same address, where probably both should be delivered.\n      So, we have to invent a different unique string in that case. Just\n      keep piling '>' characters on the front. */\n\n      if (addr->address[0] == '>')\n        {\n        while (tree_search(tree_duplicates, addr->unique))\n          addr->unique = string_sprintf(\">%s\", addr->unique);\n        }\n\n      else if ((tnode = tree_search(tree_duplicates, addr->unique)))\n        {\n        DEBUG(D_deliver|D_route)\n          debug_printf(\"%s is a duplicate address: discarded\\n\", addr->address);\n        addr->dupof = tnode->data.ptr;\n        addr->next = addr_duplicate;\n        addr_duplicate = addr;\n        continue;\n        }\n\n      DEBUG(D_deliver|D_route) debug_printf(\"unique = %s\\n\", addr->unique);\n\n      /* Check for previous delivery */\n\n      if (tree_search(tree_nonrecipients, addr->unique))\n        {\n        DEBUG(D_deliver|D_route)\n          debug_printf(\"%s was previously delivered: discarded\\n\", addr->address);\n        child_done(addr, tod_stamp(tod_log));\n        continue;\n        }\n\n      /* Save for checking future duplicates */\n\n      tree_add_duplicate(addr->unique, addr);\n\n      /* Set local part and domain */\n\n      addr->local_part = addr->address;\n      addr->domain = addr->parent->domain;\n\n      /* Ensure that the delivery is permitted. */\n\n      if (testflag(addr, af_file))\n        {\n        if (!testflag(addr, af_allow_file))\n          {\n          addr->basic_errno = ERRNO_FORBIDFILE;\n          addr->message = US\"delivery to file forbidden\";\n          (void)post_process_one(addr, FAIL, LOG_MAIN, EXIM_DTYPE_ROUTER, 0);\n          continue;   /* with the next new address */\n          }\n        }\n      else if (addr->address[0] == '|')\n        {\n        if (!testflag(addr, af_allow_pipe))\n          {\n          addr->basic_errno = ERRNO_FORBIDPIPE;\n          addr->message = US\"delivery to pipe forbidden\";\n          (void)post_process_one(addr, FAIL, LOG_MAIN, EXIM_DTYPE_ROUTER, 0);\n          continue;   /* with the next new address */\n          }\n        }\n      else if (!testflag(addr, af_allow_reply))\n        {\n        addr->basic_errno = ERRNO_FORBIDREPLY;\n        addr->message = US\"autoreply forbidden\";\n        (void)post_process_one(addr, FAIL, LOG_MAIN, EXIM_DTYPE_ROUTER, 0);\n        continue;     /* with the next new address */\n        }\n\n      /* If the errno field is already set to BADTRANSPORT, it indicates\n      failure to expand a transport string, or find the associated transport,\n      or an unset transport when one is required. Leave this test till now so\n      that the forbid errors are given in preference. */\n\n      if (addr->basic_errno == ERRNO_BADTRANSPORT)\n        {\n        (void)post_process_one(addr, DEFER, LOG_MAIN, EXIM_DTYPE_ROUTER, 0);\n        continue;\n        }\n\n      /* Treat /dev/null as a special case and abandon the delivery. This\n      avoids having to specify a uid on the transport just for this case.\n      Arrange for the transport name to be logged as \"**bypassed**\". */\n\n      if (Ustrcmp(addr->address, \"/dev/null\") == 0)\n        {\n        uschar *save = addr->transport->name;\n        addr->transport->name = US\"**bypassed**\";\n        (void)post_process_one(addr, OK, LOG_MAIN, EXIM_DTYPE_TRANSPORT, '=');\n        addr->transport->name = save;\n        continue;   /* with the next new address */\n        }\n\n      /* Pipe, file, or autoreply delivery is to go ahead as a normal local\n      delivery. */\n\n      DEBUG(D_deliver|D_route)\n        debug_printf(\"queued for %s transport\\n\", addr->transport->name);\n      addr->next = addr_local;\n      addr_local = addr;\n      continue;       /* with the next new address */\n      }\n\n    /* Handle normal addresses. First, split up into local part and domain,\n    handling the %-hack if necessary. There is the possibility of a defer from\n    a lookup in percent_hack_domains. */\n\n    if ((rc = deliver_split_address(addr)) == DEFER)\n      {\n      addr->message = US\"cannot check percent_hack_domains\";\n      addr->basic_errno = ERRNO_LISTDEFER;\n      (void)post_process_one(addr, DEFER, LOG_MAIN, EXIM_DTYPE_NONE, 0);\n      continue;\n      }\n\n    /* Check to see if the domain is held. If so, proceed only if the\n    delivery was forced by hand. */\n\n    deliver_domain = addr->domain;  /* set $domain */\n    if (  !forced && hold_domains\n       && (rc = match_isinlist(addr->domain, (const uschar **)&hold_domains, 0,\n           &domainlist_anchor, addr->domain_cache, MCL_DOMAIN, TRUE,\n           NULL)) != FAIL\n       )\n      {\n      if (rc == DEFER)\n        {\n        addr->message = US\"hold_domains lookup deferred\";\n        addr->basic_errno = ERRNO_LISTDEFER;\n        }\n      else\n        {\n        addr->message = US\"domain is held\";\n        addr->basic_errno = ERRNO_HELD;\n        }\n      (void)post_process_one(addr, DEFER, LOG_MAIN, EXIM_DTYPE_NONE, 0);\n      continue;\n      }\n\n    /* Now we can check for duplicates and previously delivered addresses. In\n    order to do this, we have to generate a \"unique\" value for each address,\n    because there may be identical actual addresses in a line of descendents.\n    The \"unique\" field is initialized to the same value as the \"address\" field,\n    but gets changed here to cope with identically-named descendents. */\n\n    for (parent = addr->parent; parent; parent = parent->parent)\n      if (strcmpic(addr->address, parent->address) == 0) break;\n\n    /* If there's an ancestor with the same name, set the homonym flag. This\n    influences how deliveries are recorded. Then add a prefix on the front of\n    the unique address. We use \\n\\ where n starts at 0 and increases each time.\n    It is unlikely to pass 9, but if it does, it may look odd but will still\n    work. This means that siblings or cousins with the same names are treated\n    as duplicates, which is what we want. */\n\n    if (parent)\n      {\n      setflag(addr, af_homonym);\n      if (parent->unique[0] != '\\\\')\n        addr->unique = string_sprintf(\"\\\\0\\\\%s\", addr->address);\n      else\n        addr->unique = string_sprintf(\"\\\\%c\\\\%s\", parent->unique[1] + 1,\n          addr->address);\n      }\n\n    /* Ensure that the domain in the unique field is lower cased, because\n    domains are always handled caselessly. */\n\n    p = Ustrrchr(addr->unique, '@');\n    while (*p != 0) { *p = tolower(*p); p++; }\n\n    DEBUG(D_deliver|D_route) debug_printf(\"unique = %s\\n\", addr->unique);\n\n    if (tree_search(tree_nonrecipients, addr->unique))\n      {\n      DEBUG(D_deliver|D_route)\n        debug_printf(\"%s was previously delivered: discarded\\n\", addr->unique);\n      child_done(addr, tod_stamp(tod_log));\n      continue;\n      }\n\n    /* Get the routing retry status, saving the two retry keys (with and\n    without the local part) for subsequent use. If there is no retry record for\n    the standard address routing retry key, we look for the same key with the\n    sender attached, because this form is used by the smtp transport after a\n    4xx response to RCPT when address_retry_include_sender is true. */\n\n    addr->domain_retry_key = string_sprintf(\"R:%s\", addr->domain);\n    addr->address_retry_key = string_sprintf(\"R:%s@%s\", addr->local_part,\n      addr->domain);\n\n    if (dbm_file)\n      {\n      domain_retry_record = dbfn_read(dbm_file, addr->domain_retry_key);\n      if (  domain_retry_record\n         && now - domain_retry_record->time_stamp > retry_data_expire\n\t )\n        domain_retry_record = NULL;    /* Ignore if too old */\n\n      address_retry_record = dbfn_read(dbm_file, addr->address_retry_key);\n      if (  address_retry_record\n         && now - address_retry_record->time_stamp > retry_data_expire\n\t )\n        address_retry_record = NULL;   /* Ignore if too old */\n\n      if (!address_retry_record)\n        {\n        uschar *altkey = string_sprintf(\"%s:<%s>\", addr->address_retry_key,\n          sender_address);\n        address_retry_record = dbfn_read(dbm_file, altkey);\n        if (  address_retry_record\n\t   && now - address_retry_record->time_stamp > retry_data_expire)\n          address_retry_record = NULL;   /* Ignore if too old */\n        }\n      }\n    else\n      domain_retry_record = address_retry_record = NULL;\n\n    DEBUG(D_deliver|D_retry)\n      {\n      if (!domain_retry_record)\n        debug_printf(\"no domain retry record\\n\");\n      if (!address_retry_record)\n        debug_printf(\"no address retry record\\n\");\n      }\n\n    /* If we are sending a message down an existing SMTP connection, we must\n    assume that the message which created the connection managed to route\n    an address to that connection. We do not want to run the risk of taking\n    a long time over routing here, because if we do, the server at the other\n    end of the connection may time it out. This is especially true for messages\n    with lots of addresses. For this kind of delivery, queue_running is not\n    set, so we would normally route all addresses. We take a pragmatic approach\n    and defer routing any addresses that have any kind of domain retry record.\n    That is, we don't even look at their retry times. It doesn't matter if this\n    doesn't work occasionally. This is all just an optimization, after all.\n\n    The reason for not doing the same for address retries is that they normally\n    arise from 4xx responses, not DNS timeouts. */\n\n    if (continue_hostname && domain_retry_record)\n      {\n      addr->message = US\"reusing SMTP connection skips previous routing defer\";\n      addr->basic_errno = ERRNO_RRETRY;\n      (void)post_process_one(addr, DEFER, LOG_MAIN, EXIM_DTYPE_ROUTER, 0);\n      }\n\n    /* If we are in a queue run, defer routing unless there is no retry data or\n    we've passed the next retry time, or this message is forced. In other\n    words, ignore retry data when not in a queue run.\n\n    However, if the domain retry time has expired, always allow the routing\n    attempt. If it fails again, the address will be failed. This ensures that\n    each address is routed at least once, even after long-term routing\n    failures.\n\n    If there is an address retry, check that too; just wait for the next\n    retry time. This helps with the case when the temporary error on the\n    address was really message-specific rather than address specific, since\n    it allows other messages through.\n\n    We also wait for the next retry time if this is a message sent down an\n    existing SMTP connection (even though that will be forced). Otherwise there\n    will be far too many attempts for an address that gets a 4xx error. In\n    fact, after such an error, we should not get here because, the host should\n    not be remembered as one this message needs. However, there was a bug that\n    used to cause this to  happen, so it is best to be on the safe side.\n\n    Even if we haven't reached the retry time in the hints, there is one more\n    check to do, which is for the ultimate address timeout. We only do this\n    check if there is an address retry record and there is not a domain retry\n    record; this implies that previous attempts to handle the address had the\n    retry_use_local_parts option turned on. We use this as an approximation\n    for the destination being like a local delivery, for example delivery over\n    LMTP to an IMAP message store. In this situation users are liable to bump\n    into their quota and thereby have intermittently successful deliveries,\n    which keep the retry record fresh, which can lead to us perpetually\n    deferring messages. */\n\n    else if (  (  queue_running && !deliver_force\n\t       || continue_hostname\n\t       )\n            && (  (  domain_retry_record\n\t\t  && now < domain_retry_record->next_try\n\t\t  && !domain_retry_record->expired\n\t\t  )\n\t       || (  address_retry_record\n\t\t  && now < address_retry_record->next_try\n\t       )  )\n            && (  domain_retry_record\n\t       || !address_retry_record\n\t       || !retry_ultimate_address_timeout(addr->address_retry_key,\n\t\t\t\t addr->domain, address_retry_record, now)\n\t    )  )\n      {\n      addr->message = US\"retry time not reached\";\n      addr->basic_errno = ERRNO_RRETRY;\n      (void)post_process_one(addr, DEFER, LOG_MAIN, EXIM_DTYPE_ROUTER, 0);\n      }\n\n    /* The domain is OK for routing. Remember if retry data exists so it\n    can be cleaned up after a successful delivery. */\n\n    else\n      {\n      if (domain_retry_record || address_retry_record)\n        setflag(addr, af_dr_retry_exists);\n      addr->next = addr_route;\n      addr_route = addr;\n      DEBUG(D_deliver|D_route)\n        debug_printf(\"%s: queued for routing\\n\", addr->address);\n      }\n    }\n\n  /* The database is closed while routing is actually happening. Requests to\n  update it are put on a chain and all processed together at the end. */\n\n  if (dbm_file) dbfn_close(dbm_file);\n\n  /* If queue_domains is set, we don't even want to try routing addresses in\n  those domains. During queue runs, queue_domains is forced to be unset.\n  Optimize by skipping this pass through the addresses if nothing is set. */\n\n  if (!deliver_force && queue_domains)\n    {\n    address_item *okaddr = NULL;\n    while (addr_route)\n      {\n      address_item *addr = addr_route;\n      addr_route = addr->next;\n\n      deliver_domain = addr->domain;  /* set $domain */\n      if ((rc = match_isinlist(addr->domain, (const uschar **)&queue_domains, 0,\n            &domainlist_anchor, addr->domain_cache, MCL_DOMAIN, TRUE, NULL))\n              != OK)\n        if (rc == DEFER)\n          {\n          addr->basic_errno = ERRNO_LISTDEFER;\n          addr->message = US\"queue_domains lookup deferred\";\n          (void)post_process_one(addr, DEFER, LOG_MAIN, EXIM_DTYPE_ROUTER, 0);\n          }\n        else\n          {\n          addr->next = okaddr;\n          okaddr = addr;\n          }\n      else\n        {\n        addr->basic_errno = ERRNO_QUEUE_DOMAIN;\n        addr->message = US\"domain is in queue_domains\";\n        (void)post_process_one(addr, DEFER, LOG_MAIN, EXIM_DTYPE_ROUTER, 0);\n        }\n      }\n\n    addr_route = okaddr;\n    }\n\n  /* Now route those addresses that are not deferred. */\n\n  while (addr_route)\n    {\n    int rc;\n    address_item *addr = addr_route;\n    const uschar *old_domain = addr->domain;\n    uschar *old_unique = addr->unique;\n    addr_route = addr->next;\n    addr->next = NULL;\n\n    /* Just in case some router parameter refers to it. */\n\n    if (!(return_path = addr->prop.errors_address))\n      return_path = sender_address;\n\n    /* If a router defers an address, add a retry item. Whether or not to\n    use the local part in the key is a property of the router. */\n\n    if ((rc = route_address(addr, &addr_local, &addr_remote, &addr_new,\n         &addr_succeed, v_none)) == DEFER)\n      retry_add_item(addr,\n        addr->router->retry_use_local_part\n        ? string_sprintf(\"R:%s@%s\", addr->local_part, addr->domain)\n\t: string_sprintf(\"R:%s\", addr->domain),\n\t0);\n\n    /* Otherwise, if there is an existing retry record in the database, add\n    retry items to delete both forms. We must also allow for the possibility\n    of a routing retry that includes the sender address. Since the domain might\n    have been rewritten (expanded to fully qualified) as a result of routing,\n    ensure that the rewritten form is also deleted. */\n\n    else if (testflag(addr, af_dr_retry_exists))\n      {\n      uschar *altkey = string_sprintf(\"%s:<%s>\", addr->address_retry_key,\n        sender_address);\n      retry_add_item(addr, altkey, rf_delete);\n      retry_add_item(addr, addr->address_retry_key, rf_delete);\n      retry_add_item(addr, addr->domain_retry_key, rf_delete);\n      if (Ustrcmp(addr->domain, old_domain) != 0)\n        retry_add_item(addr, string_sprintf(\"R:%s\", old_domain), rf_delete);\n      }\n\n    /* DISCARD is given for :blackhole: and \"seen finish\". The event has been\n    logged, but we need to ensure the address (and maybe parents) is marked\n    done. */\n\n    if (rc == DISCARD)\n      {\n      address_done(addr, tod_stamp(tod_log));\n      continue;  /* route next address */\n      }\n\n    /* The address is finished with (failed or deferred). */\n\n    if (rc != OK)\n      {\n      (void)post_process_one(addr, rc, LOG_MAIN, EXIM_DTYPE_ROUTER, 0);\n      continue;  /* route next address */\n      }\n\n    /* The address has been routed. If the router changed the domain, it will\n    also have changed the unique address. We have to test whether this address\n    has already been delivered, because it's the unique address that finally\n    gets recorded. */\n\n    if (  addr->unique != old_unique\n       && tree_search(tree_nonrecipients, addr->unique) != 0\n       )\n      {\n      DEBUG(D_deliver|D_route) debug_printf(\"%s was previously delivered: \"\n        \"discarded\\n\", addr->address);\n      if (addr_remote == addr) addr_remote = addr->next;\n      else if (addr_local == addr) addr_local = addr->next;\n      }\n\n    /* If the router has same_domain_copy_routing set, we are permitted to copy\n    the routing for any other addresses with the same domain. This is an\n    optimisation to save repeated DNS lookups for \"standard\" remote domain\n    routing. The option is settable only on routers that generate host lists.\n    We play it very safe, and do the optimization only if the address is routed\n    to a remote transport, there are no header changes, and the domain was not\n    modified by the router. */\n\n    if (  addr_remote == addr\n       && addr->router->same_domain_copy_routing\n       && !addr->prop.extra_headers\n       && !addr->prop.remove_headers\n       && old_domain == addr->domain\n       )\n      {\n      address_item **chain = &addr_route;\n      while (*chain)\n        {\n        address_item *addr2 = *chain;\n        if (Ustrcmp(addr2->domain, addr->domain) != 0)\n          {\n          chain = &(addr2->next);\n          continue;\n          }\n\n        /* Found a suitable address; take it off the routing list and add it to\n        the remote delivery list. */\n\n        *chain = addr2->next;\n        addr2->next = addr_remote;\n        addr_remote = addr2;\n\n        /* Copy the routing data */\n\n        addr2->domain = addr->domain;\n        addr2->router = addr->router;\n        addr2->transport = addr->transport;\n        addr2->host_list = addr->host_list;\n        addr2->fallback_hosts = addr->fallback_hosts;\n        addr2->prop.errors_address = addr->prop.errors_address;\n        copyflag(addr2, addr, af_hide_child);\n        copyflag(addr2, addr, af_local_host_removed);\n\n        DEBUG(D_deliver|D_route)\n          debug_printf(\">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\\n\"\n                       \"routing %s\\n\"\n                       \"Routing for %s copied from %s\\n\",\n            addr2->address, addr2->address, addr->address);\n        }\n      }\n    }  /* Continue with routing the next address. */\n  }    /* Loop to process any child addresses that the routers created, and\n          any rerouted addresses that got put back on the new chain. */\n\n\n/* Debugging: show the results of the routing */\n\nDEBUG(D_deliver|D_retry|D_route)\n  {\n  address_item *p;\n  debug_printf(\">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\\n\");\n  debug_printf(\"After routing:\\n  Local deliveries:\\n\");\n  for (p = addr_local; p; p = p->next)\n    debug_printf(\"    %s\\n\", p->address);\n\n  debug_printf(\"  Remote deliveries:\\n\");\n  for (p = addr_remote; p; p = p->next)\n    debug_printf(\"    %s\\n\", p->address);\n\n  debug_printf(\"  Failed addresses:\\n\");\n  for (p = addr_failed; p; p = p->next)\n    debug_printf(\"    %s\\n\", p->address);\n\n  debug_printf(\"  Deferred addresses:\\n\");\n  for (p = addr_defer; p; p = p->next)\n    debug_printf(\"    %s\\n\", p->address);\n  }\n\n/* Free any resources that were cached during routing. */\n\nsearch_tidyup();\nroute_tidyup();\n\n/* These two variables are set only during routing, after check_local_user.\nEnsure they are not set in transports. */\n\nlocal_user_gid = (gid_t)(-1);\nlocal_user_uid = (uid_t)(-1);\n\n/* Check for any duplicate addresses. This check is delayed until after\nrouting, because the flexibility of the routing configuration means that\nidentical addresses with different parentage may end up being redirected to\ndifferent addresses. Checking for duplicates too early (as we previously used\nto) makes this kind of thing not work. */\n\ndo_duplicate_check(&addr_local);\ndo_duplicate_check(&addr_remote);\n\n/* When acting as an MUA wrapper, we proceed only if all addresses route to a\nremote transport. The check that they all end up in one transaction happens in\nthe do_remote_deliveries() function. */\n\nif (  mua_wrapper\n   && (addr_local || addr_failed || addr_defer)\n   )\n  {\n  address_item *addr;\n  uschar *which, *colon, *msg;\n\n  if (addr_local)\n    {\n    addr = addr_local;\n    which = US\"local\";\n    }\n  else if (addr_defer)\n    {\n    addr = addr_defer;\n    which = US\"deferred\";\n    }\n  else\n    {\n    addr = addr_failed;\n    which = US\"failed\";\n    }\n\n  while (addr->parent) addr = addr->parent;\n\n  if (addr->message)\n    {\n    colon = US\": \";\n    msg = addr->message;\n    }\n  else colon = msg = US\"\";\n\n  /* We don't need to log here for a forced failure as it will already\n  have been logged. Defer will also have been logged, but as a defer, so we do\n  need to do the failure logging. */\n\n  if (addr != addr_failed)\n    log_write(0, LOG_MAIN, \"** %s routing yielded a %s delivery\",\n      addr->address, which);\n\n  /* Always write an error to the caller */\n\n  fprintf(stderr, \"routing %s yielded a %s delivery%s%s\\n\", addr->address,\n    which, colon, msg);\n\n  final_yield = DELIVER_MUA_FAILED;\n  addr_failed = addr_defer = NULL;   /* So that we remove the message */\n  goto DELIVERY_TIDYUP;\n  }\n\n\n/* If this is a run to continue deliveries to an external channel that is\nalready set up, defer any local deliveries. */\n\nif (continue_transport)\n  {\n  if (addr_defer)\n    {\n    address_item *addr = addr_defer;\n    while (addr->next) addr = addr->next;\n    addr->next = addr_local;\n    }\n  else\n    addr_defer = addr_local;\n  addr_local = NULL;\n  }\n\n\n/* Because address rewriting can happen in the routers, we should not really do\nANY deliveries until all addresses have been routed, so that all recipients of\nthe message get the same headers. However, this is in practice not always\npossible, since sometimes remote addresses give DNS timeouts for days on end.\nThe pragmatic approach is to deliver what we can now, saving any rewritten\nheaders so that at least the next lot of recipients benefit from the rewriting\nthat has already been done.\n\nIf any headers have been rewritten during routing, update the spool file to\nremember them for all subsequent deliveries. This can be delayed till later if\nthere is only address to be delivered - if it succeeds the spool write need not\nhappen. */\n\nif (  header_rewritten\n   && (  addr_local && (addr_local->next || addr_remote)\n      || addr_remote && addr_remote->next\n   )  )\n  {\n  /* Panic-dies on error */\n  (void)spool_write_header(message_id, SW_DELIVERING, NULL);\n  header_rewritten = FALSE;\n  }\n\n\n/* If there are any deliveries to be and we do not already have the journal\nfile, create it. This is used to record successful deliveries as soon as\npossible after each delivery is known to be complete. A file opened with\nO_APPEND is used so that several processes can run simultaneously.\n\nThe journal is just insurance against crashes. When the spool file is\nultimately updated at the end of processing, the journal is deleted. If a\njournal is found to exist at the start of delivery, the addresses listed\ntherein are added to the non-recipients. */\n\nif (addr_local || addr_remote)\n  {\n  if (journal_fd < 0)\n    {\n    uschar * fname = spool_fname(US\"input\", message_subdir, id, US\"-J\");\n\n    if ((journal_fd = Uopen(fname,\n#ifdef O_CLOEXEC\n\t\t\tO_CLOEXEC |\n#endif\n\t\t\tO_WRONLY|O_APPEND|O_CREAT|O_EXCL, SPOOL_MODE)) < 0)\n      {\n      log_write(0, LOG_MAIN|LOG_PANIC, \"Couldn't open journal file %s: %s\",\n\tfname, strerror(errno));\n      return DELIVER_NOT_ATTEMPTED;\n      }\n\n    /* Set the close-on-exec flag, make the file owned by Exim, and ensure\n    that the mode is correct - the group setting doesn't always seem to get\n    set automatically. */\n\n    if(  fchown(journal_fd, exim_uid, exim_gid)\n      || fchmod(journal_fd, SPOOL_MODE)\n#ifndef O_CLOEXEC\n      || fcntl(journal_fd, F_SETFD, fcntl(journal_fd, F_GETFD) | FD_CLOEXEC)\n#endif\n      )\n      {\n      int ret = Uunlink(fname);\n      log_write(0, LOG_MAIN|LOG_PANIC, \"Couldn't set perms on journal file %s: %s\",\n\tfname, strerror(errno));\n      if(ret  &&  errno != ENOENT)\n\tlog_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to unlink %s: %s\",\n\t  fname, strerror(errno));\n      return DELIVER_NOT_ATTEMPTED;\n      }\n    }\n  }\nelse if (journal_fd >= 0)\n  {\n  close(journal_fd);\n  journal_fd = -1;\n  }\n\n\n\n/* Now we can get down to the business of actually doing deliveries. Local\ndeliveries are done first, then remote ones. If ever the problems of how to\nhandle fallback transports are figured out, this section can be put into a loop\nfor handling fallbacks, though the uid switching will have to be revised. */\n\n/* Precompile a regex that is used to recognize a parameter in response\nto an LHLO command, if is isn't already compiled. This may be used on both\nlocal and remote LMTP deliveries. */\n\nif (!regex_IGNOREQUOTA)\n  regex_IGNOREQUOTA =\n    regex_must_compile(US\"\\\\n250[\\\\s\\\\-]IGNOREQUOTA(\\\\s|\\\\n|$)\", FALSE, TRUE);\n\n/* Handle local deliveries */\n\nif (addr_local)\n  {\n  DEBUG(D_deliver|D_transport)\n    debug_printf(\">>>>>>>>>>>>>>>> Local deliveries >>>>>>>>>>>>>>>>\\n\");\n  do_local_deliveries();\n  disable_logging = FALSE;\n  }\n\n/* If queue_run_local is set, we do not want to attempt any remote deliveries,\nso just queue them all. */\n\nif (queue_run_local)\n  while (addr_remote)\n    {\n    address_item *addr = addr_remote;\n    addr_remote = addr->next;\n    addr->next = NULL;\n    addr->basic_errno = ERRNO_LOCAL_ONLY;\n    addr->message = US\"remote deliveries suppressed\";\n    (void)post_process_one(addr, DEFER, LOG_MAIN, EXIM_DTYPE_TRANSPORT, 0);\n    }\n\n/* Handle remote deliveries */\n\nif (addr_remote)\n  {\n  DEBUG(D_deliver|D_transport)\n    debug_printf(\">>>>>>>>>>>>>>>> Remote deliveries >>>>>>>>>>>>>>>>\\n\");\n\n  /* Precompile some regex that are used to recognize parameters in response\n  to an EHLO command, if they aren't already compiled. */\n\n  deliver_init();\n\n  /* Now sort the addresses if required, and do the deliveries. The yield of\n  do_remote_deliveries is FALSE when mua_wrapper is set and all addresses\n  cannot be delivered in one transaction. */\n\n  if (remote_sort_domains) sort_remote_deliveries();\n  if (!do_remote_deliveries(FALSE))\n    {\n    log_write(0, LOG_MAIN, \"** mua_wrapper is set but recipients cannot all \"\n      \"be delivered in one transaction\");\n    fprintf(stderr, \"delivery to smarthost failed (configuration problem)\\n\");\n\n    final_yield = DELIVER_MUA_FAILED;\n    addr_failed = addr_defer = NULL;   /* So that we remove the message */\n    goto DELIVERY_TIDYUP;\n    }\n\n  /* See if any of the addresses that failed got put on the queue for delivery\n  to their fallback hosts. We do it this way because often the same fallback\n  host is used for many domains, so all can be sent in a single transaction\n  (if appropriately configured). */\n\n  if (addr_fallback && !mua_wrapper)\n    {\n    DEBUG(D_deliver) debug_printf(\"Delivering to fallback hosts\\n\");\n    addr_remote = addr_fallback;\n    addr_fallback = NULL;\n    if (remote_sort_domains) sort_remote_deliveries();\n    do_remote_deliveries(TRUE);\n    }\n  disable_logging = FALSE;\n  }\n\n\n/* All deliveries are now complete. Ignore SIGTERM during this tidying up\nphase, to minimize cases of half-done things. */\n\nDEBUG(D_deliver)\n  debug_printf(\">>>>>>>>>>>>>>>> deliveries are done >>>>>>>>>>>>>>>>\\n\");\ncancel_cutthrough_connection(TRUE, US\"deliveries are done\");\n\n/* Root privilege is no longer needed */\n\nexim_setugid(exim_uid, exim_gid, FALSE, US\"post-delivery tidying\");\n\nset_process_info(\"tidying up after delivering %s\", message_id);\nsignal(SIGTERM, SIG_IGN);\n\n/* When we are acting as an MUA wrapper, the smtp transport will either have\nsucceeded for all addresses, or failed them all in normal cases. However, there\nare some setup situations (e.g. when a named port does not exist) that cause an\nimmediate exit with deferral of all addresses. Convert those into failures. We\ndo not ever want to retry, nor do we want to send a bounce message. */\n\nif (mua_wrapper)\n  {\n  if (addr_defer)\n    {\n    address_item *addr, *nextaddr;\n    for (addr = addr_defer; addr; addr = nextaddr)\n      {\n      log_write(0, LOG_MAIN, \"** %s mua_wrapper forced failure for deferred \"\n        \"delivery\", addr->address);\n      nextaddr = addr->next;\n      addr->next = addr_failed;\n      addr_failed = addr;\n      }\n    addr_defer = NULL;\n    }\n\n  /* Now all should either have succeeded or failed. */\n\n  if (!addr_failed)\n    final_yield = DELIVER_MUA_SUCCEEDED;\n  else\n    {\n    host_item * host;\n    uschar *s = addr_failed->user_message;\n\n    if (!s) s = addr_failed->message;\n\n    fprintf(stderr, \"Delivery failed: \");\n    if (addr_failed->basic_errno > 0)\n      {\n      fprintf(stderr, \"%s\", strerror(addr_failed->basic_errno));\n      if (s) fprintf(stderr, \": \");\n      }\n    if ((host = addr_failed->host_used))\n      fprintf(stderr, \"H=%s [%s]: \", host->name, host->address);\n    if (s)\n      fprintf(stderr, \"%s\", CS s);\n    else if (addr_failed->basic_errno <= 0)\n      fprintf(stderr, \"unknown error\");\n    fprintf(stderr, \"\\n\");\n\n    final_yield = DELIVER_MUA_FAILED;\n    addr_failed = NULL;\n    }\n  }\n\n/* In a normal configuration, we now update the retry database. This is done in\none fell swoop at the end in order not to keep opening and closing (and\nlocking) the database. The code for handling retries is hived off into a\nseparate module for convenience. We pass it the addresses of the various\nchains, because deferred addresses can get moved onto the failed chain if the\nretry cutoff time has expired for all alternative destinations. Bypass the\nupdating of the database if the -N flag is set, which is a debugging thing that\nprevents actual delivery. */\n\nelse if (!dont_deliver)\n  retry_update(&addr_defer, &addr_failed, &addr_succeed);\n\n/* Send DSN for successful messages if requested */\naddr_senddsn = NULL;\n\nfor (addr_dsntmp = addr_succeed; addr_dsntmp; addr_dsntmp = addr_dsntmp->next)\n  {\n  /* af_ignore_error not honored here. it's not an error */\n  DEBUG(D_deliver) debug_printf(\"DSN: processing router : %s\\n\"\n      \"DSN: processing successful delivery address: %s\\n\"\n      \"DSN: Sender_address: %s\\n\"\n      \"DSN: orcpt: %s  flags: %d\\n\"\n      \"DSN: envid: %s  ret: %d\\n\"\n      \"DSN: Final recipient: %s\\n\"\n      \"DSN: Remote SMTP server supports DSN: %d\\n\",\n      addr_dsntmp->router ? addr_dsntmp->router->name : US\"(unknown)\",\n      addr_dsntmp->address,\n      sender_address,\n      addr_dsntmp->dsn_orcpt ? addr_dsntmp->dsn_orcpt : US\"NULL\",\n      addr_dsntmp->dsn_flags,\n      dsn_envid ? dsn_envid : US\"NULL\", dsn_ret,\n      addr_dsntmp->address,\n      addr_dsntmp->dsn_aware\n      );\n\n  /* send report if next hop not DSN aware or a router flagged \"last DSN hop\"\n     and a report was requested */\n  if (  (  addr_dsntmp->dsn_aware != dsn_support_yes\n\t|| addr_dsntmp->dsn_flags & rf_dsnlasthop\n        )\n     && addr_dsntmp->dsn_flags & rf_dsnflags\n     && addr_dsntmp->dsn_flags & rf_notify_success\n     )\n    {\n    /* copy and relink address_item and send report with all of them at once later */\n    address_item * addr_next = addr_senddsn;\n    addr_senddsn = store_get(sizeof(address_item));\n    *addr_senddsn = *addr_dsntmp;\n    addr_senddsn->next = addr_next;\n    }\n  else\n    DEBUG(D_deliver) debug_printf(\"DSN: not sending DSN success message\\n\");\n  }\n\nif (addr_senddsn)\n  {\n  pid_t pid;\n  int fd;\n\n  /* create exim process to send message */\n  pid = child_open_exim(&fd);\n\n  DEBUG(D_deliver) debug_printf(\"DSN: child_open_exim returns: %d\\n\", pid);\n\n  if (pid < 0)  /* Creation of child failed */\n    {\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"Process %d (parent %d) failed to \"\n      \"create child process to send failure message: %s\", getpid(),\n      getppid(), strerror(errno));\n\n    DEBUG(D_deliver) debug_printf(\"DSN: child_open_exim failed\\n\");\n    }\n  else  /* Creation of child succeeded */\n    {\n    FILE *f = fdopen(fd, \"wb\");\n    /* header only as required by RFC. only failure DSN needs to honor RET=FULL */\n    uschar * bound;\n    transport_ctx tctx = {{0}};\n\n    DEBUG(D_deliver)\n      debug_printf(\"sending error message to: %s\\n\", sender_address);\n\n    /* build unique id for MIME boundary */\n    bound = string_sprintf(TIME_T_FMT \"-eximdsn-%d\", time(NULL), rand());\n    DEBUG(D_deliver) debug_printf(\"DSN: MIME boundary: %s\\n\", bound);\n\n    if (errors_reply_to)\n      fprintf(f, \"Reply-To: %s\\n\", errors_reply_to);\n\n    fprintf(f, \"Auto-Submitted: auto-generated\\n\"\n\t\"From: Mail Delivery System <Mailer-Daemon@%s>\\n\"\n\t\"To: %s\\n\"\n\t\"Subject: Delivery Status Notification\\n\"\n\t\"Content-Type: multipart/report; report-type=delivery-status; boundary=%s\\n\"\n\t\"MIME-Version: 1.0\\n\\n\"\n\n\t\"--%s\\n\"\n\t\"Content-type: text/plain; charset=us-ascii\\n\\n\"\n\n\t\"This message was created automatically by mail delivery software.\\n\"\n\t\" ----- The following addresses had successful delivery notifications -----\\n\",\n      qualify_domain_sender, sender_address, bound, bound);\n\n    for (addr_dsntmp = addr_senddsn; addr_dsntmp;\n\t addr_dsntmp = addr_dsntmp->next)\n      fprintf(f, \"<%s> (relayed %s)\\n\\n\",\n\taddr_dsntmp->address,\n\t(addr_dsntmp->dsn_flags & rf_dsnlasthop) == 1\n\t  ? \"via non DSN router\"\n\t  : addr_dsntmp->dsn_aware == dsn_support_no\n\t  ? \"to non-DSN-aware mailer\"\n\t  : \"via non \\\"Remote SMTP\\\" router\"\n\t);\n\n    fprintf(f, \"--%s\\n\"\n\t\"Content-type: message/delivery-status\\n\\n\"\n\t\"Reporting-MTA: dns; %s\\n\",\n      bound, smtp_active_hostname);\n\n    if (dsn_envid)\n      {\t\t\t/* must be decoded from xtext: see RFC 3461:6.3a */\n      uschar *xdec_envid;\n      if (auth_xtextdecode(dsn_envid, &xdec_envid) > 0)\n        fprintf(f, \"Original-Envelope-ID: %s\\n\", dsn_envid);\n      else\n        fprintf(f, \"X-Original-Envelope-ID: error decoding xtext formatted ENVID\\n\");\n      }\n    fputc('\\n', f);\n\n    for (addr_dsntmp = addr_senddsn;\n\t addr_dsntmp;\n\t addr_dsntmp = addr_dsntmp->next)\n      {\n      if (addr_dsntmp->dsn_orcpt)\n        fprintf(f,\"Original-Recipient: %s\\n\", addr_dsntmp->dsn_orcpt);\n\n      fprintf(f, \"Action: delivered\\n\"\n\t  \"Final-Recipient: rfc822;%s\\n\"\n\t  \"Status: 2.0.0\\n\",\n\taddr_dsntmp->address);\n\n      if (addr_dsntmp->host_used && addr_dsntmp->host_used->name)\n        fprintf(f, \"Remote-MTA: dns; %s\\nDiagnostic-Code: smtp; 250 Ok\\n\\n\",\n\t  addr_dsntmp->host_used->name);\n      else\n\tfprintf(f, \"Diagnostic-Code: X-Exim; relayed via non %s router\\n\\n\",\n\t  (addr_dsntmp->dsn_flags & rf_dsnlasthop) == 1 ? \"DSN\" : \"SMTP\");\n      }\n\n    fprintf(f, \"--%s\\nContent-type: text/rfc822-headers\\n\\n\", bound);\n\n    fflush(f);\n    transport_filter_argv = NULL;   /* Just in case */\n    return_path = sender_address;   /* In case not previously set */\n\n    /* Write the original email out */\n\n    tctx.u.fd = fileno(f);\n    tctx.options = topt_add_return_path | topt_no_body;\n    transport_write_message(&tctx, 0);\n    fflush(f);\n\n    fprintf(f,\"\\n--%s--\\n\", bound);\n\n    fflush(f);\n    fclose(f);\n    rc = child_close(pid, 0);     /* Waits for child to close, no timeout */\n    }\n  }\n\n/* If any addresses failed, we must send a message to somebody, unless\naf_ignore_error is set, in which case no action is taken. It is possible for\nseveral messages to get sent if there are addresses with different\nrequirements. */\n\nwhile (addr_failed)\n  {\n  pid_t pid;\n  int fd;\n  uschar *logtod = tod_stamp(tod_log);\n  address_item *addr;\n  address_item *handled_addr = NULL;\n  address_item **paddr;\n  address_item *msgchain = NULL;\n  address_item **pmsgchain = &msgchain;\n\n  /* There are weird cases when logging is disabled in the transport. However,\n  there may not be a transport (address failed by a router). */\n\n  disable_logging = FALSE;\n  if (addr_failed->transport)\n    disable_logging = addr_failed->transport->disable_logging;\n\n  DEBUG(D_deliver)\n    debug_printf(\"processing failed address %s\\n\", addr_failed->address);\n\n  /* There are only two ways an address in a bounce message can get here:\n\n  (1) When delivery was initially deferred, but has now timed out (in the call\n      to retry_update() above). We can detect this by testing for\n      af_retry_timedout. If the address does not have its own errors address,\n      we arrange to ignore the error.\n\n  (2) If delivery failures for bounce messages are being ignored. We can detect\n      this by testing for af_ignore_error. This will also be set if a bounce\n      message has been autothawed and the ignore_bounce_errors_after time has\n      passed. It might also be set if a router was explicitly configured to\n      ignore errors (errors_to = \"\").\n\n  If neither of these cases obtains, something has gone wrong. Log the\n  incident, but then ignore the error. */\n\n  if (sender_address[0] == 0 && !addr_failed->prop.errors_address)\n    {\n    if (  !testflag(addr_failed, af_retry_timedout)\n       && !addr_failed->prop.ignore_error)\n      log_write(0, LOG_MAIN|LOG_PANIC, \"internal error: bounce message \"\n        \"failure is neither frozen nor ignored (it's been ignored)\");\n\n    addr_failed->prop.ignore_error = TRUE;\n    }\n\n  /* If the first address on the list has af_ignore_error set, just remove\n  it from the list, throw away any saved message file, log it, and\n  mark the recipient done. */\n\n  if (  addr_failed->prop.ignore_error\n     || (  addr_failed->dsn_flags & rf_dsnflags\n        && (addr_failed->dsn_flags & rf_notify_failure) != rf_notify_failure\n     )  )\n    {\n    addr = addr_failed;\n    addr_failed = addr->next;\n    if (addr->return_filename) Uunlink(addr->return_filename);\n\n    log_write(0, LOG_MAIN, \"%s%s%s%s: error ignored\",\n      addr->address,\n      !addr->parent ? US\"\" : US\" <\",\n      !addr->parent ? US\"\" : addr->parent->address,\n      !addr->parent ? US\"\" : US\">\");\n\n    address_done(addr, logtod);\n    child_done(addr, logtod);\n    /* Panic-dies on error */\n    (void)spool_write_header(message_id, SW_DELIVERING, NULL);\n    }\n\n  /* Otherwise, handle the sending of a message. Find the error address for\n  the first address, then send a message that includes all failed addresses\n  that have the same error address. Note the bounce_recipient is a global so\n  that it can be accessed by $bounce_recipient while creating a customized\n  error message. */\n\n  else\n    {\n    if (!(bounce_recipient = addr_failed->prop.errors_address))\n      bounce_recipient = sender_address;\n\n    /* Make a subprocess to send a message */\n\n    if ((pid = child_open_exim(&fd)) < 0)\n      log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"Process %d (parent %d) failed to \"\n        \"create child process to send failure message: %s\", getpid(),\n        getppid(), strerror(errno));\n\n    /* Creation of child succeeded */\n\n    else\n      {\n      int ch, rc;\n      int filecount = 0;\n      int rcount = 0;\n      uschar *bcc, *emf_text;\n      FILE *f = fdopen(fd, \"wb\");\n      FILE *emf = NULL;\n      BOOL to_sender = strcmpic(sender_address, bounce_recipient) == 0;\n      int max = (bounce_return_size_limit/DELIVER_IN_BUFFER_SIZE + 1) *\n        DELIVER_IN_BUFFER_SIZE;\n      uschar * bound;\n      uschar *dsnlimitmsg;\n      uschar *dsnnotifyhdr;\n      int topt;\n\n      DEBUG(D_deliver)\n        debug_printf(\"sending error message to: %s\\n\", bounce_recipient);\n\n      /* Scan the addresses for all that have the same errors address, removing\n      them from the addr_failed chain, and putting them on msgchain. */\n\n      paddr = &addr_failed;\n      for (addr = addr_failed; addr; addr = *paddr)\n        if (Ustrcmp(bounce_recipient, addr->prop.errors_address\n\t      ? addr->prop.errors_address : sender_address) == 0)\n          {                          /* The same - dechain */\n          *paddr = addr->next;\n          *pmsgchain = addr;\n          addr->next = NULL;\n          pmsgchain = &(addr->next);\n          }\n        else\n          paddr = &addr->next;        /* Not the same; skip */\n\n      /* Include X-Failed-Recipients: for automatic interpretation, but do\n      not let any one header line get too long. We do this by starting a\n      new header every 50 recipients. Omit any addresses for which the\n      \"hide_child\" flag is set. */\n\n      for (addr = msgchain; addr; addr = addr->next)\n        {\n        if (testflag(addr, af_hide_child)) continue;\n        if (rcount >= 50)\n          {\n          fprintf(f, \"\\n\");\n          rcount = 0;\n          }\n        fprintf(f, \"%s%s\",\n          rcount++ == 0\n\t  ? \"X-Failed-Recipients: \"\n\t  : \",\\n  \",\n          testflag(addr, af_pfr) && addr->parent\n\t  ? string_printing(addr->parent->address)\n\t  : string_printing(addr->address));\n        }\n      if (rcount > 0) fprintf(f, \"\\n\");\n\n      /* Output the standard headers */\n\n      if (errors_reply_to)\n        fprintf(f, \"Reply-To: %s\\n\", errors_reply_to);\n      fprintf(f, \"Auto-Submitted: auto-replied\\n\");\n      moan_write_from(f);\n      fprintf(f, \"To: %s\\n\", bounce_recipient);\n\n      /* generate boundary string and output MIME-Headers */\n      bound = string_sprintf(TIME_T_FMT \"-eximdsn-%d\", time(NULL), rand());\n\n      fprintf(f, \"Content-Type: multipart/report;\"\n\t    \" report-type=delivery-status; boundary=%s\\n\"\n\t  \"MIME-Version: 1.0\\n\",\n\tbound);\n\n      /* Open a template file if one is provided. Log failure to open, but\n      carry on - default texts will be used. */\n\n      if (bounce_message_file)\n        if (!(emf = Ufopen(bounce_message_file, \"rb\")))\n          log_write(0, LOG_MAIN|LOG_PANIC, \"Failed to open %s for error \"\n            \"message texts: %s\", bounce_message_file, strerror(errno));\n\n      /* Quietly copy to configured additional addresses if required. */\n\n      if ((bcc = moan_check_errorcopy(bounce_recipient)))\n\tfprintf(f, \"Bcc: %s\\n\", bcc);\n\n      /* The texts for the message can be read from a template file; if there\n      isn't one, or if it is too short, built-in texts are used. The first\n      emf text is a Subject: and any other headers. */\n\n      if ((emf_text = next_emf(emf, US\"header\")))\n\tfprintf(f, \"%s\\n\", emf_text);\n      else\n        fprintf(f, \"Subject: Mail delivery failed%s\\n\\n\",\n          to_sender? \": returning message to sender\" : \"\");\n\n      /* output human readable part as text/plain section */\n      fprintf(f, \"--%s\\n\"\n\t  \"Content-type: text/plain; charset=us-ascii\\n\\n\",\n\tbound);\n\n      if ((emf_text = next_emf(emf, US\"intro\")))\n\tfprintf(f, \"%s\", CS emf_text);\n      else\n        {\n        fprintf(f,\n/* This message has been reworded several times. It seems to be confusing to\nsomebody, however it is worded. I have retreated to the original, simple\nwording. */\n\"This message was created automatically by mail delivery software.\\n\");\n\n        if (bounce_message_text)\n\t  fprintf(f, \"%s\", CS bounce_message_text);\n        if (to_sender)\n          fprintf(f,\n\"\\nA message that you sent could not be delivered to one or more of its\\n\"\n\"recipients. This is a permanent error. The following address(es) failed:\\n\");\n        else\n          fprintf(f,\n\"\\nA message sent by\\n\\n  <%s>\\n\\n\"\n\"could not be delivered to one or more of its recipients. The following\\n\"\n\"address(es) failed:\\n\", sender_address);\n        }\n      fputc('\\n', f);\n\n      /* Process the addresses, leaving them on the msgchain if they have a\n      file name for a return message. (There has already been a check in\n      post_process_one() for the existence of data in the message file.) A TRUE\n      return from print_address_information() means that the address is not\n      hidden. */\n\n      paddr = &msgchain;\n      for (addr = msgchain; addr; addr = *paddr)\n        {\n        if (print_address_information(addr, f, US\"  \", US\"\\n    \", US\"\"))\n          print_address_error(addr, f, US\"\");\n\n        /* End the final line for the address */\n\n        fputc('\\n', f);\n\n        /* Leave on msgchain if there's a return file. */\n\n        if (addr->return_file >= 0)\n          {\n          paddr = &(addr->next);\n          filecount++;\n          }\n\n        /* Else save so that we can tick off the recipient when the\n        message is sent. */\n\n        else\n          {\n          *paddr = addr->next;\n          addr->next = handled_addr;\n          handled_addr = addr;\n          }\n        }\n\n      fputc('\\n', f);\n\n      /* Get the next text, whether we need it or not, so as to be\n      positioned for the one after. */\n\n      emf_text = next_emf(emf, US\"generated text\");\n\n      /* If there were any file messages passed by the local transports,\n      include them in the message. Then put the address on the handled chain.\n      In the case of a batch of addresses that were all sent to the same\n      transport, the return_file field in all of them will contain the same\n      fd, and the return_filename field in the *last* one will be set (to the\n      name of the file). */\n\n      if (msgchain)\n        {\n        address_item *nextaddr;\n\n        if (emf_text)\n\t  fprintf(f, \"%s\", CS emf_text);\n\telse\n          fprintf(f,\n            \"The following text was generated during the delivery \"\n            \"attempt%s:\\n\", (filecount > 1)? \"s\" : \"\");\n\n        for (addr = msgchain; addr; addr = nextaddr)\n          {\n          FILE *fm;\n          address_item *topaddr = addr;\n\n          /* List all the addresses that relate to this file */\n\n\t  fputc('\\n', f);\n          while(addr)                   /* Insurance */\n            {\n            print_address_information(addr, f, US\"------ \",  US\"\\n       \",\n              US\" ------\\n\");\n            if (addr->return_filename) break;\n            addr = addr->next;\n            }\n\t  fputc('\\n', f);\n\n          /* Now copy the file */\n\n          if (!(fm = Ufopen(addr->return_filename, \"rb\")))\n            fprintf(f, \"    +++ Exim error... failed to open text file: %s\\n\",\n              strerror(errno));\n          else\n            {\n            while ((ch = fgetc(fm)) != EOF) fputc(ch, f);\n            (void)fclose(fm);\n            }\n          Uunlink(addr->return_filename);\n\n          /* Can now add to handled chain, first fishing off the next\n          address on the msgchain. */\n\n          nextaddr = addr->next;\n          addr->next = handled_addr;\n          handled_addr = topaddr;\n          }\n\tfputc('\\n', f);\n        }\n\n      /* output machine readable part */\n#ifdef SUPPORT_I18N\n      if (message_smtputf8)\n\tfprintf(f, \"--%s\\n\"\n\t    \"Content-type: message/global-delivery-status\\n\\n\"\n\t    \"Reporting-MTA: dns; %s\\n\",\n\t  bound, smtp_active_hostname);\n      else\n#endif\n\tfprintf(f, \"--%s\\n\"\n\t    \"Content-type: message/delivery-status\\n\\n\"\n\t    \"Reporting-MTA: dns; %s\\n\",\n\t  bound, smtp_active_hostname);\n\n      if (dsn_envid)\n\t{\n        /* must be decoded from xtext: see RFC 3461:6.3a */\n        uschar *xdec_envid;\n        if (auth_xtextdecode(dsn_envid, &xdec_envid) > 0)\n          fprintf(f, \"Original-Envelope-ID: %s\\n\", dsn_envid);\n        else\n          fprintf(f, \"X-Original-Envelope-ID: error decoding xtext formatted ENVID\\n\");\n        }\n      fputc('\\n', f);\n\n      for (addr = handled_addr; addr; addr = addr->next)\n        {\n\thost_item * hu;\n        fprintf(f, \"Action: failed\\n\"\n\t    \"Final-Recipient: rfc822;%s\\n\"\n\t    \"Status: 5.0.0\\n\",\n\t    addr->address);\n        if ((hu = addr->host_used) && hu->name)\n\t  {\n\t  const uschar * s;\n\t  fprintf(f, \"Remote-MTA: dns; %s\\n\", hu->name);\n#ifdef EXPERIMENTAL_DSN_INFO\n\t  if (hu->address)\n\t    {\n\t    uschar * p = hu->port == 25\n\t      ? US\"\" : string_sprintf(\":%d\", hu->port);\n\t    fprintf(f, \"Remote-MTA: X-ip; [%s]%s\\n\", hu->address, p);\n\t    }\n\t  if ((s = addr->smtp_greeting) && *s)\n\t    fprintf(f, \"X-Remote-MTA-smtp-greeting: X-str; %s\\n\", s);\n\t  if ((s = addr->helo_response) && *s)\n\t    fprintf(f, \"X-Remote-MTA-helo-response: X-str; %s\\n\", s);\n\t  if ((s = addr->message) && *s)\n\t    fprintf(f, \"X-Exim-Diagnostic: X-str; %s\\n\", s);\n#endif\n\t  print_dsn_diagnostic_code(addr, f);\n\t  }\n\tfputc('\\n', f);\n        }\n\n      /* Now copy the message, trying to give an intelligible comment if\n      it is too long for it all to be copied. The limit isn't strictly\n      applied because of the buffering. There is, however, an option\n      to suppress copying altogether. */\n\n      emf_text = next_emf(emf, US\"copy\");\n\n      /* add message body\n         we ignore the intro text from template and add\n         the text for bounce_return_size_limit at the end.\n\n         bounce_return_message is ignored\n         in case RET= is defined we honor these values\n         otherwise bounce_return_body is honored.\n\n         bounce_return_size_limit is always honored.\n      */\n\n      fprintf(f, \"--%s\\n\", bound);\n\n      dsnlimitmsg = US\"X-Exim-DSN-Information: Due to administrative limits only headers are returned\";\n      dsnnotifyhdr = NULL;\n      topt = topt_add_return_path;\n\n      /* RET=HDRS? top priority */\n      if (dsn_ret == dsn_ret_hdrs)\n        topt |= topt_no_body;\n      else\n\t{\n\tstruct stat statbuf;\n\n        /* no full body return at all? */\n        if (!bounce_return_body)\n          {\n          topt |= topt_no_body;\n          /* add header if we overrule RET=FULL */\n          if (dsn_ret == dsn_ret_full)\n            dsnnotifyhdr = dsnlimitmsg;\n          }\n\t/* line length limited... return headers only if oversize */\n        /* size limited ... return headers only if limit reached */\n\telse if (  max_received_linelength > bounce_return_linesize_limit\n\t\t|| (  bounce_return_size_limit > 0\n\t\t   && fstat(deliver_datafile, &statbuf) == 0\n\t\t   && statbuf.st_size > max\n\t\t)  )\n\t  {\n\t  topt |= topt_no_body;\n\t  dsnnotifyhdr = dsnlimitmsg;\n          }\n\t}\n\n#ifdef SUPPORT_I18N\n      if (message_smtputf8)\n\tfputs(topt & topt_no_body ? \"Content-type: message/global-headers\\n\\n\"\n\t\t\t\t  : \"Content-type: message/global\\n\\n\",\n\t      f);\n      else\n#endif\n\tfputs(topt & topt_no_body ? \"Content-type: text/rfc822-headers\\n\\n\"\n\t\t\t\t  : \"Content-type: message/rfc822\\n\\n\",\n\t      f);\n\n      fflush(f);\n      transport_filter_argv = NULL;   /* Just in case */\n      return_path = sender_address;   /* In case not previously set */\n\t{\t\t\t      /* Dummy transport for headers add */\n\ttransport_ctx tctx = {{0}};\n\ttransport_instance tb = {0};\n\n\ttctx.u.fd = fileno(f);\n\ttctx.tblock = &tb;\n\ttctx.options = topt;\n\ttb.add_headers = dsnnotifyhdr;\n\n\ttransport_write_message(&tctx, 0);\n\t}\n      fflush(f);\n\n      /* we never add the final text. close the file */\n      if (emf)\n        (void)fclose(emf);\n\n      fprintf(f, \"\\n--%s--\\n\", bound);\n\n      /* Close the file, which should send an EOF to the child process\n      that is receiving the message. Wait for it to finish. */\n\n      (void)fclose(f);\n      rc = child_close(pid, 0);     /* Waits for child to close, no timeout */\n\n      /* In the test harness, let the child do it's thing first. */\n\n      if (running_in_test_harness) millisleep(500);\n\n      /* If the process failed, there was some disaster in setting up the\n      error message. Unless the message is very old, ensure that addr_defer\n      is non-null, which will have the effect of leaving the message on the\n      spool. The failed addresses will get tried again next time. However, we\n      don't really want this to happen too often, so freeze the message unless\n      there are some genuine deferred addresses to try. To do this we have\n      to call spool_write_header() here, because with no genuine deferred\n      addresses the normal code below doesn't get run. */\n\n      if (rc != 0)\n        {\n        uschar *s = US\"\";\n        if (now - received_time.tv_sec < retry_maximum_timeout && !addr_defer)\n          {\n          addr_defer = (address_item *)(+1);\n          deliver_freeze = TRUE;\n          deliver_frozen_at = time(NULL);\n          /* Panic-dies on error */\n          (void)spool_write_header(message_id, SW_DELIVERING, NULL);\n          s = US\" (frozen)\";\n          }\n        deliver_msglog(\"Process failed (%d) when writing error message \"\n          \"to %s%s\", rc, bounce_recipient, s);\n        log_write(0, LOG_MAIN, \"Process failed (%d) when writing error message \"\n          \"to %s%s\", rc, bounce_recipient, s);\n        }\n\n      /* The message succeeded. Ensure that the recipients that failed are\n      now marked finished with on the spool and their parents updated. */\n\n      else\n        {\n        for (addr = handled_addr; addr; addr = addr->next)\n          {\n          address_done(addr, logtod);\n          child_done(addr, logtod);\n          }\n        /* Panic-dies on error */\n        (void)spool_write_header(message_id, SW_DELIVERING, NULL);\n        }\n      }\n    }\n  }\n\ndisable_logging = FALSE;  /* In case left set */\n\n/* Come here from the mua_wrapper case if routing goes wrong */\n\nDELIVERY_TIDYUP:\n\n/* If there are now no deferred addresses, we are done. Preserve the\nmessage log if so configured, and we are using them. Otherwise, sling it.\nThen delete the message itself. */\n\nif (!addr_defer)\n  {\n  uschar * fname;\n\n  if (message_logs)\n    {\n    fname = spool_fname(US\"msglog\", message_subdir, id, US\"\");\n    if (preserve_message_logs)\n      {\n      int rc;\n      uschar * moname = spool_fname(US\"msglog.OLD\", US\"\", id, US\"\");\n\n      if ((rc = Urename(fname, moname)) < 0)\n        {\n        (void)directory_make(spool_directory,\n\t\t\t      spool_sname(US\"msglog.OLD\", US\"\"),\n\t\t\t      MSGLOG_DIRECTORY_MODE, TRUE);\n        rc = Urename(fname, moname);\n        }\n      if (rc < 0)\n        log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to move %s to the \"\n          \"msglog.OLD directory\", fname);\n      }\n    else\n      if (Uunlink(fname) < 0)\n        log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to unlink %s: %s\",\n\t\t  fname, strerror(errno));\n    }\n\n  /* Remove the two message files. */\n\n  fname = spool_fname(US\"input\", message_subdir, id, US\"-D\");\n  if (Uunlink(fname) < 0)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to unlink %s: %s\",\n      fname, strerror(errno));\n  fname = spool_fname(US\"input\", message_subdir, id, US\"-H\");\n  if (Uunlink(fname) < 0)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to unlink %s: %s\",\n      fname, strerror(errno));\n\n  /* Log the end of this message, with queue time if requested. */\n\n  if (LOGGING(queue_time_overall))\n    log_write(0, LOG_MAIN, \"Completed QT=%s\", string_timesince(&received_time));\n  else\n    log_write(0, LOG_MAIN, \"Completed\");\n\n  /* Unset deliver_freeze so that we won't try to move the spool files further down */\n  deliver_freeze = FALSE;\n\n#ifndef DISABLE_EVENT\n  (void) event_raise(event_action, US\"msg:complete\", NULL);\n#endif\n  }\n\n/* If there are deferred addresses, we are keeping this message because it is\nnot yet completed. Lose any temporary files that were catching output from\npipes for any of the deferred addresses, handle one-time aliases, and see if\nthe message has been on the queue for so long that it is time to send a warning\nmessage to the sender, unless it is a mailer-daemon. If all deferred addresses\nhave the same domain, we can set deliver_domain for the expansion of\ndelay_warning_ condition - if any of them are pipes, files, or autoreplies, use\nthe parent's domain.\n\nIf all the deferred addresses have an error number that indicates \"retry time\nnot reached\", skip sending the warning message, because it won't contain the\nreason for the delay. It will get sent at the next real delivery attempt.\nHowever, if at least one address has tried, we'd better include all of them in\nthe message.\n\nIf we can't make a process to send the message, don't worry.\n\nFor mailing list expansions we want to send the warning message to the\nmailing list manager. We can't do a perfect job here, as some addresses may\nhave different errors addresses, but if we take the errors address from\neach deferred address it will probably be right in most cases.\n\nIf addr_defer == +1, it means there was a problem sending an error message\nfor failed addresses, and there were no \"real\" deferred addresses. The value\nwas set just to keep the message on the spool, so there is nothing to do here.\n*/\n\nelse if (addr_defer != (address_item *)(+1))\n  {\n  address_item *addr;\n  uschar *recipients = US\"\";\n  BOOL delivery_attempted = FALSE;\n\n  deliver_domain = testflag(addr_defer, af_pfr)\n    ? addr_defer->parent->domain : addr_defer->domain;\n\n  for (addr = addr_defer; addr; addr = addr->next)\n    {\n    address_item *otaddr;\n\n    if (addr->basic_errno > ERRNO_RETRY_BASE) delivery_attempted = TRUE;\n\n    if (deliver_domain)\n      {\n      const uschar *d = testflag(addr, af_pfr)\n\t? addr->parent->domain : addr->domain;\n\n      /* The domain may be unset for an address that has never been routed\n      because the system filter froze the message. */\n\n      if (!d || Ustrcmp(d, deliver_domain) != 0)\n        deliver_domain = NULL;\n      }\n\n    if (addr->return_filename) Uunlink(addr->return_filename);\n\n    /* Handle the case of one-time aliases. If any address in the ancestry\n    of this one is flagged, ensure it is in the recipients list, suitably\n    flagged, and that its parent is marked delivered. */\n\n    for (otaddr = addr; otaddr; otaddr = otaddr->parent)\n      if (otaddr->onetime_parent) break;\n\n    if (otaddr)\n      {\n      int i;\n      int t = recipients_count;\n\n      for (i = 0; i < recipients_count; i++)\n        {\n        uschar *r = recipients_list[i].address;\n        if (Ustrcmp(otaddr->onetime_parent, r) == 0) t = i;\n        if (Ustrcmp(otaddr->address, r) == 0) break;\n        }\n\n      /* Didn't find the address already in the list, and did find the\n      ultimate parent's address in the list, and they really are different\n      (i.e. not from an identity-redirect). After adding the recipient,\n      update the errors address in the recipients list. */\n\n      if (  i >= recipients_count && t < recipients_count\n         && Ustrcmp(otaddr->address, otaddr->parent->address) != 0)\n        {\n        DEBUG(D_deliver) debug_printf(\"one_time: adding %s in place of %s\\n\",\n          otaddr->address, otaddr->parent->address);\n        receive_add_recipient(otaddr->address, t);\n        recipients_list[recipients_count-1].errors_to = otaddr->prop.errors_address;\n        tree_add_nonrecipient(otaddr->parent->address);\n        update_spool = TRUE;\n        }\n      }\n\n    /* Except for error messages, ensure that either the errors address for\n    this deferred address or, if there is none, the sender address, is on the\n    list of recipients for a warning message. */\n\n    if (sender_address[0])\n      {\n      uschar * s = addr->prop.errors_address;\n      if (!s) s = sender_address;\n      if (Ustrstr(recipients, s) == NULL)\n\trecipients = string_sprintf(\"%s%s%s\", recipients,\n\t  recipients[0] ? \",\" : \"\", s);\n      }\n    }\n\n  /* Send a warning message if the conditions are right. If the condition check\n  fails because of a lookup defer, there is nothing we can do. The warning\n  is not sent. Another attempt will be made at the next delivery attempt (if\n  it also defers). */\n\n  if (  !queue_2stage\n     && delivery_attempted\n     && (  ((addr_defer->dsn_flags & rf_dsnflags) == 0)\n        || (addr_defer->dsn_flags & rf_notify_delay) == rf_notify_delay\n\t)\n     && delay_warning[1] > 0\n     && sender_address[0] != 0\n     && (  !delay_warning_condition\n        || expand_check_condition(delay_warning_condition,\n            US\"delay_warning\", US\"option\")\n\t)\n     )\n    {\n    int count;\n    int show_time;\n    int queue_time = time(NULL) - received_time.tv_sec;\n\n    /* When running in the test harness, there's an option that allows us to\n    fudge this time so as to get repeatability of the tests. Take the first\n    time off the list. In queue runs, the list pointer gets updated in the\n    calling process. */\n\n    if (running_in_test_harness && fudged_queue_times[0] != 0)\n      {\n      int qt = readconf_readtime(fudged_queue_times, '/', FALSE);\n      if (qt >= 0)\n        {\n        DEBUG(D_deliver) debug_printf(\"fudged queue_times = %s\\n\",\n          fudged_queue_times);\n        queue_time = qt;\n        }\n      }\n\n    /* See how many warnings we should have sent by now */\n\n    for (count = 0; count < delay_warning[1]; count++)\n      if (queue_time < delay_warning[count+2]) break;\n\n    show_time = delay_warning[count+1];\n\n    if (count >= delay_warning[1])\n      {\n      int extra;\n      int last_gap = show_time;\n      if (count > 1) last_gap -= delay_warning[count];\n      extra = (queue_time - delay_warning[count+1])/last_gap;\n      show_time += last_gap * extra;\n      count += extra;\n      }\n\n    DEBUG(D_deliver)\n      {\n      debug_printf(\"time on queue = %s\\n\", readconf_printtime(queue_time));\n      debug_printf(\"warning counts: required %d done %d\\n\", count,\n        warning_count);\n      }\n\n    /* We have computed the number of warnings there should have been by now.\n    If there haven't been enough, send one, and up the count to what it should\n    have been. */\n\n    if (warning_count < count)\n      {\n      header_line *h;\n      int fd;\n      pid_t pid = child_open_exim(&fd);\n\n      if (pid > 0)\n        {\n        uschar *wmf_text;\n        FILE *wmf = NULL;\n        FILE *f = fdopen(fd, \"wb\");\n\tuschar * bound;\n\ttransport_ctx tctx = {{0}};\n\n        if (warn_message_file)\n          if (!(wmf = Ufopen(warn_message_file, \"rb\")))\n            log_write(0, LOG_MAIN|LOG_PANIC, \"Failed to open %s for warning \"\n              \"message texts: %s\", warn_message_file, strerror(errno));\n\n        warnmsg_recipients = recipients;\n        warnmsg_delay = queue_time < 120*60\n\t  ? string_sprintf(\"%d minutes\", show_time/60)\n\t  : string_sprintf(\"%d hours\", show_time/3600);\n\n        if (errors_reply_to)\n          fprintf(f, \"Reply-To: %s\\n\", errors_reply_to);\n        fprintf(f, \"Auto-Submitted: auto-replied\\n\");\n        moan_write_from(f);\n        fprintf(f, \"To: %s\\n\", recipients);\n\n        /* generated boundary string and output MIME-Headers */\n        bound = string_sprintf(TIME_T_FMT \"-eximdsn-%d\", time(NULL), rand());\n\n        fprintf(f, \"Content-Type: multipart/report;\"\n\t    \" report-type=delivery-status; boundary=%s\\n\"\n\t    \"MIME-Version: 1.0\\n\",\n\t  bound);\n\n        if ((wmf_text = next_emf(wmf, US\"header\")))\n          fprintf(f, \"%s\\n\", wmf_text);\n        else\n          fprintf(f, \"Subject: Warning: message %s delayed %s\\n\\n\",\n            message_id, warnmsg_delay);\n\n        /* output human readable part as text/plain section */\n        fprintf(f, \"--%s\\n\"\n\t    \"Content-type: text/plain; charset=us-ascii\\n\\n\",\n\t  bound);\n\n        if ((wmf_text = next_emf(wmf, US\"intro\")))\n\t  fprintf(f, \"%s\", CS wmf_text);\n\telse\n          {\n          fprintf(f,\n\"This message was created automatically by mail delivery software.\\n\");\n\n          if (Ustrcmp(recipients, sender_address) == 0)\n            fprintf(f,\n\"A message that you sent has not yet been delivered to one or more of its\\n\"\n\"recipients after more than \");\n\n          else\n\t    fprintf(f,\n\"A message sent by\\n\\n  <%s>\\n\\n\"\n\"has not yet been delivered to one or more of its recipients after more than \\n\",\n\t      sender_address);\n\n          fprintf(f, \"%s on the queue on %s.\\n\\n\"\n\t      \"The message identifier is:     %s\\n\",\n\t    warnmsg_delay, primary_hostname, message_id);\n\n          for (h = header_list; h; h = h->next)\n            if (strncmpic(h->text, US\"Subject:\", 8) == 0)\n              fprintf(f, \"The subject of the message is: %s\", h->text + 9);\n            else if (strncmpic(h->text, US\"Date:\", 5) == 0)\n              fprintf(f, \"The date of the message is:    %s\", h->text + 6);\n          fputc('\\n', f);\n\n          fprintf(f, \"The address%s to which the message has not yet been \"\n            \"delivered %s:\\n\",\n            !addr_defer->next ? \"\" : \"es\",\n            !addr_defer->next ? \"is\": \"are\");\n          }\n\n        /* List the addresses, with error information if allowed */\n\n        /* store addr_defer for machine readable part */\n        address_item *addr_dsndefer = addr_defer;\n        fputc('\\n', f);\n        while (addr_defer)\n          {\n          address_item *addr = addr_defer;\n          addr_defer = addr->next;\n          if (print_address_information(addr, f, US\"  \", US\"\\n    \", US\"\"))\n            print_address_error(addr, f, US\"Delay reason: \");\n          fputc('\\n', f);\n          }\n        fputc('\\n', f);\n\n        /* Final text */\n\n        if (wmf)\n          {\n          if ((wmf_text = next_emf(wmf, US\"final\")))\n\t    fprintf(f, \"%s\", CS wmf_text);\n          (void)fclose(wmf);\n          }\n        else\n          {\n          fprintf(f,\n\"No action is required on your part. Delivery attempts will continue for\\n\"\n\"some time, and this warning may be repeated at intervals if the message\\n\"\n\"remains undelivered. Eventually the mail delivery software will give up,\\n\"\n\"and when that happens, the message will be returned to you.\\n\");\n          }\n\n        /* output machine readable part */\n        fprintf(f, \"\\n--%s\\n\"\n\t    \"Content-type: message/delivery-status\\n\\n\"\n\t    \"Reporting-MTA: dns; %s\\n\",\n\t  bound,\n\t  smtp_active_hostname);\n\n\n        if (dsn_envid)\n\t  {\n          /* must be decoded from xtext: see RFC 3461:6.3a */\n          uschar *xdec_envid;\n          if (auth_xtextdecode(dsn_envid, &xdec_envid) > 0)\n            fprintf(f,\"Original-Envelope-ID: %s\\n\", dsn_envid);\n          else\n            fprintf(f,\"X-Original-Envelope-ID: error decoding xtext formatted ENVID\\n\");\n          }\n        fputc('\\n', f);\n\n        for ( ; addr_dsndefer; addr_dsndefer = addr_dsndefer->next)\n          {\n          if (addr_dsndefer->dsn_orcpt)\n            fprintf(f, \"Original-Recipient: %s\\n\", addr_dsndefer->dsn_orcpt);\n\n          fprintf(f, \"Action: delayed\\n\"\n\t      \"Final-Recipient: rfc822;%s\\n\"\n\t      \"Status: 4.0.0\\n\",\n\t    addr_dsndefer->address);\n          if (addr_dsndefer->host_used && addr_dsndefer->host_used->name)\n            {\n            fprintf(f, \"Remote-MTA: dns; %s\\n\",\n\t\t    addr_dsndefer->host_used->name);\n            print_dsn_diagnostic_code(addr_dsndefer, f);\n            }\n\t  fputc('\\n', f);\n          }\n\n        fprintf(f, \"--%s\\n\"\n\t    \"Content-type: text/rfc822-headers\\n\\n\",\n\t  bound);\n\n        fflush(f);\n        /* header only as required by RFC. only failure DSN needs to honor RET=FULL */\n\ttctx.u.fd = fileno(f);\n        tctx.options = topt_add_return_path | topt_no_body;\n        transport_filter_argv = NULL;   /* Just in case */\n        return_path = sender_address;   /* In case not previously set */\n\n        /* Write the original email out */\n        transport_write_message(&tctx, 0);\n        fflush(f);\n\n        fprintf(f,\"\\n--%s--\\n\", bound);\n\n        fflush(f);\n\n        /* Close and wait for child process to complete, without a timeout.\n        If there's an error, don't update the count. */\n\n        (void)fclose(f);\n        if (child_close(pid, 0) == 0)\n          {\n          warning_count = count;\n          update_spool = TRUE;    /* Ensure spool rewritten */\n          }\n        }\n      }\n    }\n\n  /* Clear deliver_domain */\n\n  deliver_domain = NULL;\n\n  /* If this was a first delivery attempt, unset the first time flag, and\n  ensure that the spool gets updated. */\n\n  if (deliver_firsttime)\n    {\n    deliver_firsttime = FALSE;\n    update_spool = TRUE;\n    }\n\n  /* If delivery was frozen and freeze_tell is set, generate an appropriate\n  message, unless the message is a local error message (to avoid loops). Then\n  log the freezing. If the text in \"frozen_info\" came from a system filter,\n  it has been escaped into printing characters so as not to mess up log lines.\n  For the \"tell\" message, we turn \\n back into newline. Also, insert a newline\n  near the start instead of the \": \" string. */\n\n  if (deliver_freeze)\n    {\n    if (freeze_tell && freeze_tell[0] != 0 && !local_error_message)\n      {\n      uschar *s = string_copy(frozen_info);\n      uschar *ss = Ustrstr(s, \" by the system filter: \");\n\n      if (ss != NULL)\n        {\n        ss[21] = '.';\n        ss[22] = '\\n';\n        }\n\n      ss = s;\n      while (*ss != 0)\n        {\n        if (*ss == '\\\\' && ss[1] == 'n')\n          {\n          *ss++ = ' ';\n          *ss++ = '\\n';\n          }\n        else ss++;\n        }\n      moan_tell_someone(freeze_tell, addr_defer, US\"Message frozen\",\n        \"Message %s has been frozen%s.\\nThe sender is <%s>.\\n\", message_id,\n        s, sender_address);\n      }\n\n    /* Log freezing just before we update the -H file, to minimize the chance\n    of a race problem. */\n\n    deliver_msglog(\"*** Frozen%s\\n\", frozen_info);\n    log_write(0, LOG_MAIN, \"Frozen%s\", frozen_info);\n    }\n\n  /* If there have been any updates to the non-recipients list, or other things\n  that get written to the spool, we must now update the spool header file so\n  that it has the right information for the next delivery attempt. If there\n  was more than one address being delivered, the header_change update is done\n  earlier, in case one succeeds and then something crashes. */\n\n  DEBUG(D_deliver)\n    debug_printf(\"delivery deferred: update_spool=%d header_rewritten=%d\\n\",\n      update_spool, header_rewritten);\n\n  if (update_spool || header_rewritten)\n    /* Panic-dies on error */\n    (void)spool_write_header(message_id, SW_DELIVERING, NULL);\n  }\n\n/* Finished with the message log. If the message is complete, it will have\nbeen unlinked or renamed above. */\n\nif (message_logs) (void)fclose(message_log);\n\n/* Now we can close and remove the journal file. Its only purpose is to record\nsuccessfully completed deliveries asap so that this information doesn't get\nlost if Exim (or the machine) crashes. Forgetting about a failed delivery is\nnot serious, as trying it again is not harmful. The journal might not be open\nif all addresses were deferred at routing or directing. Nevertheless, we must\nremove it if it exists (may have been lying around from a crash during the\nprevious delivery attempt). We don't remove the journal if a delivery\nsubprocess failed to pass back delivery information; this is controlled by\nthe remove_journal flag. When the journal is left, we also don't move the\nmessage off the main spool if frozen and the option is set. It should get moved\nat the next attempt, after the journal has been inspected. */\n\nif (journal_fd >= 0) (void)close(journal_fd);\n\nif (remove_journal)\n  {\n  uschar * fname = spool_fname(US\"input\", message_subdir, id, US\"-J\");\n\n  if (Uunlink(fname) < 0 && errno != ENOENT)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to unlink %s: %s\", fname,\n      strerror(errno));\n\n  /* Move the message off the spool if requested */\n\n#ifdef SUPPORT_MOVE_FROZEN_MESSAGES\n  if (deliver_freeze && move_frozen_messages)\n    (void)spool_move_message(id, message_subdir, US\"\", US\"F\");\n#endif\n  }\n\n/* Closing the data file frees the lock; if the file has been unlinked it\nwill go away. Otherwise the message becomes available for another process\nto try delivery. */\n\n(void)close(deliver_datafile);\ndeliver_datafile = -1;\nDEBUG(D_deliver) debug_printf(\"end delivery of %s\\n\", id);\n\n/* It is unlikely that there will be any cached resources, since they are\nreleased after routing, and in the delivery subprocesses. However, it's\npossible for an expansion for something afterwards (for example,\nexpand_check_condition) to do a lookup. We must therefore be sure everything is\nreleased. */\n\nsearch_tidyup();\nacl_where = ACL_WHERE_UNKNOWN;\nreturn final_yield;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146458,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "deliver_message(uschar *id, BOOL forced, BOOL give_up)\n{\nint i, rc;\nint final_yield = DELIVER_ATTEMPTED_NORMAL;\ntime_t now = time(NULL);\naddress_item *addr_last = NULL;\nuschar *filter_message = NULL;\nint process_recipients = RECIP_ACCEPT;\nopen_db dbblock;\nopen_db *dbm_file;\nextern int acl_where;\n\nuschar *info = queue_run_pid == (pid_t)0\n  ? string_sprintf(\"delivering %s\", id)\n  : string_sprintf(\"delivering %s (queue run pid %d)\", id, queue_run_pid);\n\n/* If the D_process_info bit is on, set_process_info() will output debugging\ninformation. If not, we want to show this initial information if D_deliver or\nD_queue_run is set or in verbose mode. */\n\nset_process_info(\"%s\", info);\n\nif (  !(debug_selector & D_process_info)\n   && (debug_selector & (D_deliver|D_queue_run|D_v))\n   )\n  debug_printf(\"%s\\n\", info);\n\n/* Ensure that we catch any subprocesses that are created. Although Exim\nsets SIG_DFL as its initial default, some routes through the code end up\nhere with it set to SIG_IGN - cases where a non-synchronous delivery process\nhas been forked, but no re-exec has been done. We use sigaction rather than\nplain signal() on those OS where SA_NOCLDWAIT exists, because we want to be\nsure it is turned off. (There was a problem on AIX with this.) */\n\n#ifdef SA_NOCLDWAIT\n  {\n  struct sigaction act;\n  act.sa_handler = SIG_DFL;\n  sigemptyset(&(act.sa_mask));\n  act.sa_flags = 0;\n  sigaction(SIGCHLD, &act, NULL);\n  }\n#else\nsignal(SIGCHLD, SIG_DFL);\n#endif\n\n/* Make the forcing flag available for routers and transports, set up the\nglobal message id field, and initialize the count for returned files and the\nmessage size. This use of strcpy() is OK because the length id is checked when\nit is obtained from a command line (the -M or -q options), and otherwise it is\nknown to be a valid message id. */\n\nif (id != message_id)\n  Ustrcpy(message_id, id);\ndeliver_force = forced;\nreturn_count = 0;\nmessage_size = 0;\n\n/* Initialize some flags */\n\nupdate_spool = FALSE;\nremove_journal = TRUE;\n\n/* Set a known context for any ACLs we call via expansions */\nacl_where = ACL_WHERE_DELIVERY;\n\n/* Reset the random number generator, so that if several delivery processes are\nstarted from a queue runner that has already used random numbers (for sorting),\nthey don't all get the same sequence. */\n\nrandom_seed = 0;\n\n/* Open and lock the message's data file. Exim locks on this one because the\nheader file may get replaced as it is re-written during the delivery process.\nAny failures cause messages to be written to the log, except for missing files\nwhile queue running - another process probably completed delivery. As part of\nopening the data file, message_subdir gets set. */\n\nif ((deliver_datafile = spool_open_datafile(id)) < 0)\n  return continue_closedown();  /* yields DELIVER_NOT_ATTEMPTED */\n\n/* The value of message_size at this point has been set to the data length,\nplus one for the blank line that notionally precedes the data. */\n\n/* Now read the contents of the header file, which will set up the headers in\nstore, and also the list of recipients and the tree of non-recipients and\nassorted flags. It updates message_size. If there is a reading or format error,\ngive up; if the message has been around for sufficiently long, remove it. */\n\n  {\n  uschar * spoolname = string_sprintf(\"%s-H\", id);\n  if ((rc = spool_read_header(spoolname, TRUE, TRUE)) != spool_read_OK)\n    {\n    if (errno == ERRNO_SPOOLFORMAT)\n      {\n      struct stat statbuf;\n      if (Ustat(spool_fname(US\"input\", message_subdir, spoolname, US\"\"),\n\t\t&statbuf) == 0)\n\tlog_write(0, LOG_MAIN, \"Format error in spool file %s: \"\n\t  \"size=\" OFF_T_FMT, spoolname, statbuf.st_size);\n      else\n\tlog_write(0, LOG_MAIN, \"Format error in spool file %s\", spoolname);\n      }\n    else\n      log_write(0, LOG_MAIN, \"Error reading spool file %s: %s\", spoolname,\n\tstrerror(errno));\n\n    /* If we managed to read the envelope data, received_time contains the\n    time the message was received. Otherwise, we can calculate it from the\n    message id. */\n\n    if (rc != spool_read_hdrerror)\n      {\n      received_time.tv_sec = received_time.tv_usec = 0;\n      /*XXX subsec precision?*/\n      for (i = 0; i < 6; i++)\n\treceived_time.tv_sec = received_time.tv_sec * BASE_62 + tab62[id[i] - '0'];\n      }\n\n    /* If we've had this malformed message too long, sling it. */\n\n    if (now - received_time.tv_sec > keep_malformed)\n      {\n      Uunlink(spool_fname(US\"msglog\", message_subdir, id, US\"\"));\n      Uunlink(spool_fname(US\"input\", message_subdir, id, US\"-D\"));\n      Uunlink(spool_fname(US\"input\", message_subdir, id, US\"-H\"));\n      Uunlink(spool_fname(US\"input\", message_subdir, id, US\"-J\"));\n      log_write(0, LOG_MAIN, \"Message removed because older than %s\",\n\treadconf_printtime(keep_malformed));\n      }\n\n    (void)close(deliver_datafile);\n    deliver_datafile = -1;\n    return continue_closedown();   /* yields DELIVER_NOT_ATTEMPTED */\n    }\n  }\n\n/* The spool header file has been read. Look to see if there is an existing\njournal file for this message. If there is, it means that a previous delivery\nattempt crashed (program or host) before it could update the spool header file.\nRead the list of delivered addresses from the journal and add them to the\nnonrecipients tree. Then update the spool file. We can leave the journal in\nexistence, as it will get further successful deliveries added to it in this\nrun, and it will be deleted if this function gets to its end successfully.\nOtherwise it might be needed again. */\n\n  {\n  uschar * fname = spool_fname(US\"input\", message_subdir, id, US\"-J\");\n  FILE * jread;\n\n  if (  (journal_fd = Uopen(fname, O_RDWR|O_APPEND\n#ifdef O_CLOEXEC\n\t\t\t\t    | O_CLOEXEC\n#endif\n#ifdef O_NOFOLLOW\n\t\t\t\t    | O_NOFOLLOW\n#endif\n\t, SPOOL_MODE)) >= 0\n     && lseek(journal_fd, 0, SEEK_SET) == 0\n     && (jread = fdopen(journal_fd, \"rb\"))\n     )\n    {\n    while (Ufgets(big_buffer, big_buffer_size, jread))\n      {\n      int n = Ustrlen(big_buffer);\n      big_buffer[n-1] = 0;\n      tree_add_nonrecipient(big_buffer);\n      DEBUG(D_deliver) debug_printf(\"Previously delivered address %s taken from \"\n\t\"journal file\\n\", big_buffer);\n      }\n    rewind(jread);\n    if ((journal_fd = dup(fileno(jread))) < 0)\n      journal_fd = fileno(jread);\n    else\n      (void) fclose(jread);\t/* Try to not leak the FILE resource */\n\n    /* Panic-dies on error */\n    (void)spool_write_header(message_id, SW_DELIVERING, NULL);\n    }\n  else if (errno != ENOENT)\n    {\n    log_write(0, LOG_MAIN|LOG_PANIC, \"attempt to open journal for reading gave: \"\n      \"%s\", strerror(errno));\n    return continue_closedown();   /* yields DELIVER_NOT_ATTEMPTED */\n    }\n\n  /* A null recipients list indicates some kind of disaster. */\n\n  if (!recipients_list)\n    {\n    (void)close(deliver_datafile);\n    deliver_datafile = -1;\n    log_write(0, LOG_MAIN, \"Spool error: no recipients for %s\", fname);\n    return continue_closedown();   /* yields DELIVER_NOT_ATTEMPTED */\n    }\n  }\n\n\n/* Handle a message that is frozen. There are a number of different things that\ncan happen, but in the default situation, unless forced, no delivery is\nattempted. */\n\nif (deliver_freeze)\n  {\n#ifdef SUPPORT_MOVE_FROZEN_MESSAGES\n  /* Moving to another directory removes the message from Exim's view. Other\n  tools must be used to deal with it. Logging of this action happens in\n  spool_move_message() and its subfunctions. */\n\n  if (  move_frozen_messages\n     && spool_move_message(id, message_subdir, US\"\", US\"F\")\n     )\n    return continue_closedown();   /* yields DELIVER_NOT_ATTEMPTED */\n#endif\n\n  /* For all frozen messages (bounces or not), timeout_frozen_after sets the\n  maximum time to keep messages that are frozen. Thaw if we reach it, with a\n  flag causing all recipients to be failed. The time is the age of the\n  message, not the time since freezing. */\n\n  if (timeout_frozen_after > 0 && message_age >= timeout_frozen_after)\n    {\n    log_write(0, LOG_MAIN, \"cancelled by timeout_frozen_after\");\n    process_recipients = RECIP_FAIL_TIMEOUT;\n    }\n\n  /* For bounce messages (and others with no sender), thaw if the error message\n  ignore timer is exceeded. The message will be discarded if this delivery\n  fails. */\n\n  else if (!*sender_address && message_age >= ignore_bounce_errors_after)\n    log_write(0, LOG_MAIN, \"Unfrozen by errmsg timer\");\n\n  /* If this is a bounce message, or there's no auto thaw, or we haven't\n  reached the auto thaw time yet, and this delivery is not forced by an admin\n  user, do not attempt delivery of this message. Note that forced is set for\n  continuing messages down the same channel, in order to skip load checking and\n  ignore hold domains, but we don't want unfreezing in that case. */\n\n  else\n    {\n    if (  (  sender_address[0] == 0\n\t  || auto_thaw <= 0\n\t  || now <= deliver_frozen_at + auto_thaw\n          )\n       && (  !forced || !deliver_force_thaw\n\t  || !admin_user || continue_hostname\n       )  )\n      {\n      (void)close(deliver_datafile);\n      deliver_datafile = -1;\n      log_write(L_skip_delivery, LOG_MAIN, \"Message is frozen\");\n      return continue_closedown();   /* yields DELIVER_NOT_ATTEMPTED */\n      }\n\n    /* If delivery was forced (by an admin user), assume a manual thaw.\n    Otherwise it's an auto thaw. */\n\n    if (forced)\n      {\n      deliver_manual_thaw = TRUE;\n      log_write(0, LOG_MAIN, \"Unfrozen by forced delivery\");\n      }\n    else log_write(0, LOG_MAIN, \"Unfrozen by auto-thaw\");\n    }\n\n  /* We get here if any of the rules for unfreezing have triggered. */\n\n  deliver_freeze = FALSE;\n  update_spool = TRUE;\n  }\n\n\n/* Open the message log file if we are using them. This records details of\ndeliveries, deferments, and failures for the benefit of the mail administrator.\nThe log is not used by exim itself to track the progress of a message; that is\ndone by rewriting the header spool file. */\n\nif (message_logs)\n  {\n  uschar * fname = spool_fname(US\"msglog\", message_subdir, id, US\"\");\n  uschar * error;\n  int fd;\n\n  if ((fd = open_msglog_file(fname, SPOOL_MODE, &error)) < 0)\n    {\n    log_write(0, LOG_MAIN|LOG_PANIC, \"Couldn't %s message log %s: %s\", error,\n      fname, strerror(errno));\n    return continue_closedown();   /* yields DELIVER_NOT_ATTEMPTED */\n    }\n\n  /* Make a C stream out of it. */\n\n  if (!(message_log = fdopen(fd, \"a\")))\n    {\n    log_write(0, LOG_MAIN|LOG_PANIC, \"Couldn't fdopen message log %s: %s\",\n      fname, strerror(errno));\n    return continue_closedown();   /* yields DELIVER_NOT_ATTEMPTED */\n    }\n  }\n\n\n/* If asked to give up on a message, log who did it, and set the action for all\nthe addresses. */\n\nif (give_up)\n  {\n  struct passwd *pw = getpwuid(real_uid);\n  log_write(0, LOG_MAIN, \"cancelled by %s\",\n      pw ? US pw->pw_name : string_sprintf(\"uid %ld\", (long int)real_uid));\n  process_recipients = RECIP_FAIL;\n  }\n\n/* Otherwise, if there are too many Received: headers, fail all recipients. */\n\nelse if (received_count > received_headers_max)\n  process_recipients = RECIP_FAIL_LOOP;\n\n/* Otherwise, if a system-wide, address-independent message filter is\nspecified, run it now, except in the case when we are failing all recipients as\na result of timeout_frozen_after. If the system filter yields \"delivered\", then\nignore the true recipients of the message. Failure of the filter file is\nlogged, and the delivery attempt fails. */\n\nelse if (system_filter && process_recipients != RECIP_FAIL_TIMEOUT)\n  {\n  int rc;\n  int filtertype;\n  ugid_block ugid;\n  redirect_block redirect;\n\n  if (system_filter_uid_set)\n    {\n    ugid.uid = system_filter_uid;\n    ugid.gid = system_filter_gid;\n    ugid.uid_set = ugid.gid_set = TRUE;\n    }\n  else\n    {\n    ugid.uid_set = ugid.gid_set = FALSE;\n    }\n\n  return_path = sender_address;\n  enable_dollar_recipients = TRUE;   /* Permit $recipients in system filter */\n  system_filtering = TRUE;\n\n  /* Any error in the filter file causes a delivery to be abandoned. */\n\n  redirect.string = system_filter;\n  redirect.isfile = TRUE;\n  redirect.check_owner = redirect.check_group = FALSE;\n  redirect.owners = NULL;\n  redirect.owngroups = NULL;\n  redirect.pw = NULL;\n  redirect.modemask = 0;\n\n  DEBUG(D_deliver|D_filter) debug_printf(\"running system filter\\n\");\n\n  rc = rda_interpret(\n    &redirect,              /* Where the data is */\n    RDO_DEFER |             /* Turn on all the enabling options */\n      RDO_FAIL |            /* Leave off all the disabling options */\n      RDO_FILTER |\n      RDO_FREEZE |\n      RDO_REALLOG |\n      RDO_REWRITE,\n    NULL,                   /* No :include: restriction (not used in filter) */\n    NULL,                   /* No sieve vacation directory (not sieve!) */\n    NULL,                   /* No sieve enotify mailto owner (not sieve!) */\n    NULL,                   /* No sieve user address (not sieve!) */\n    NULL,                   /* No sieve subaddress (not sieve!) */\n    &ugid,                  /* uid/gid data */\n    &addr_new,              /* Where to hang generated addresses */\n    &filter_message,        /* Where to put error message */\n    NULL,                   /* Don't skip syntax errors */\n    &filtertype,            /* Will always be set to FILTER_EXIM for this call */\n    US\"system filter\");     /* For error messages */\n\n  DEBUG(D_deliver|D_filter) debug_printf(\"system filter returned %d\\n\", rc);\n\n  if (rc == FF_ERROR || rc == FF_NONEXIST)\n    {\n    (void)close(deliver_datafile);\n    deliver_datafile = -1;\n    log_write(0, LOG_MAIN|LOG_PANIC, \"Error in system filter: %s\",\n      string_printing(filter_message));\n    return continue_closedown();   /* yields DELIVER_NOT_ATTEMPTED */\n    }\n\n  /* Reset things. If the filter message is an empty string, which can happen\n  for a filter \"fail\" or \"freeze\" command with no text, reset it to NULL. */\n\n  system_filtering = FALSE;\n  enable_dollar_recipients = FALSE;\n  if (filter_message && filter_message[0] == 0) filter_message = NULL;\n\n  /* Save the values of the system filter variables so that user filters\n  can use them. */\n\n  memcpy(filter_sn, filter_n, sizeof(filter_sn));\n\n  /* The filter can request that delivery of the original addresses be\n  deferred. */\n\n  if (rc == FF_DEFER)\n    {\n    process_recipients = RECIP_DEFER;\n    deliver_msglog(\"Delivery deferred by system filter\\n\");\n    log_write(0, LOG_MAIN, \"Delivery deferred by system filter\");\n    }\n\n  /* The filter can request that a message be frozen, but this does not\n  take place if the message has been manually thawed. In that case, we must\n  unset \"delivered\", which is forced by the \"freeze\" command to make -bF\n  work properly. */\n\n  else if (rc == FF_FREEZE && !deliver_manual_thaw)\n    {\n    deliver_freeze = TRUE;\n    deliver_frozen_at = time(NULL);\n    process_recipients = RECIP_DEFER;\n    frozen_info = string_sprintf(\" by the system filter%s%s\",\n      filter_message ? US\": \" : US\"\",\n      filter_message ? filter_message : US\"\");\n    }\n\n  /* The filter can request that a message be failed. The error message may be\n  quite long - it is sent back to the sender in the bounce - but we don't want\n  to fill up the log with repetitions of it. If it starts with << then the text\n  between << and >> is written to the log, with the rest left for the bounce\n  message. */\n\n  else if (rc == FF_FAIL)\n    {\n    uschar *colon = US\"\";\n    uschar *logmsg = US\"\";\n    int loglen = 0;\n\n    process_recipients = RECIP_FAIL_FILTER;\n\n    if (filter_message)\n      {\n      uschar *logend;\n      colon = US\": \";\n      if (  filter_message[0] == '<'\n         && filter_message[1] == '<'\n\t && (logend = Ustrstr(filter_message, \">>\"))\n\t )\n        {\n        logmsg = filter_message + 2;\n        loglen = logend - logmsg;\n        filter_message = logend + 2;\n        if (filter_message[0] == 0) filter_message = NULL;\n        }\n      else\n        {\n        logmsg = filter_message;\n        loglen = Ustrlen(filter_message);\n        }\n      }\n\n    log_write(0, LOG_MAIN, \"cancelled by system filter%s%.*s\", colon, loglen,\n      logmsg);\n    }\n\n  /* Delivery can be restricted only to those recipients (if any) that the\n  filter specified. */\n\n  else if (rc == FF_DELIVERED)\n    {\n    process_recipients = RECIP_IGNORE;\n    if (addr_new)\n      log_write(0, LOG_MAIN, \"original recipients ignored (system filter)\");\n    else\n      log_write(0, LOG_MAIN, \"=> discarded (system filter)\");\n    }\n\n  /* If any new addresses were created by the filter, fake up a \"parent\"\n  for them. This is necessary for pipes, etc., which are expected to have\n  parents, and it also gives some sensible logging for others. Allow\n  pipes, files, and autoreplies, and run them as the filter uid if set,\n  otherwise as the current uid. */\n\n  if (addr_new)\n    {\n    int uid = (system_filter_uid_set)? system_filter_uid : geteuid();\n    int gid = (system_filter_gid_set)? system_filter_gid : getegid();\n\n    /* The text \"system-filter\" is tested in transport_set_up_command() and in\n    set_up_shell_command() in the pipe transport, to enable them to permit\n    $recipients, so don't change it here without also changing it there. */\n\n    address_item *p = addr_new;\n    address_item *parent = deliver_make_addr(US\"system-filter\", FALSE);\n\n    parent->domain = string_copylc(qualify_domain_recipient);\n    parent->local_part = US\"system-filter\";\n\n    /* As part of this loop, we arrange for addr_last to end up pointing\n    at the final address. This is used if we go on to add addresses for the\n    original recipients. */\n\n    while (p)\n      {\n      if (parent->child_count == USHRT_MAX)\n        log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"system filter generated more \"\n          \"than %d delivery addresses\", USHRT_MAX);\n      parent->child_count++;\n      p->parent = parent;\n\n      if (testflag(p, af_pfr))\n        {\n        uschar *tpname;\n        uschar *type;\n        p->uid = uid;\n        p->gid = gid;\n        setflag(p, af_uid_set);\n        setflag(p, af_gid_set);\n        setflag(p, af_allow_file);\n        setflag(p, af_allow_pipe);\n        setflag(p, af_allow_reply);\n\n        /* Find the name of the system filter's appropriate pfr transport */\n\n        if (p->address[0] == '|')\n          {\n          type = US\"pipe\";\n          tpname = system_filter_pipe_transport;\n          address_pipe = p->address;\n          }\n        else if (p->address[0] == '>')\n          {\n          type = US\"reply\";\n          tpname = system_filter_reply_transport;\n          }\n        else\n          {\n          if (p->address[Ustrlen(p->address)-1] == '/')\n            {\n            type = US\"directory\";\n            tpname = system_filter_directory_transport;\n            }\n          else\n            {\n            type = US\"file\";\n            tpname = system_filter_file_transport;\n            }\n          address_file = p->address;\n          }\n\n        /* Now find the actual transport, first expanding the name. We have\n        set address_file or address_pipe above. */\n\n        if (tpname)\n          {\n          uschar *tmp = expand_string(tpname);\n          address_file = address_pipe = NULL;\n          if (!tmp)\n            p->message = string_sprintf(\"failed to expand \\\"%s\\\" as a \"\n              \"system filter transport name\", tpname);\n          tpname = tmp;\n          }\n        else\n          p->message = string_sprintf(\"system_filter_%s_transport is unset\",\n            type);\n\n        if (tpname)\n          {\n          transport_instance *tp;\n          for (tp = transports; tp; tp = tp->next)\n            if (Ustrcmp(tp->name, tpname) == 0)\n              {\n              p->transport = tp;\n              break;\n              }\n          if (!tp)\n            p->message = string_sprintf(\"failed to find \\\"%s\\\" transport \"\n              \"for system filter delivery\", tpname);\n          }\n\n        /* If we couldn't set up a transport, defer the delivery, putting the\n        error on the panic log as well as the main log. */\n\n        if (!p->transport)\n          {\n          address_item *badp = p;\n          p = p->next;\n          if (!addr_last) addr_new = p; else addr_last->next = p;\n          badp->local_part = badp->address;   /* Needed for log line */\n          post_process_one(badp, DEFER, LOG_MAIN|LOG_PANIC, EXIM_DTYPE_ROUTER, 0);\n          continue;\n          }\n        }    /* End of pfr handling */\n\n      /* Either a non-pfr delivery, or we found a transport */\n\n      DEBUG(D_deliver|D_filter)\n        debug_printf(\"system filter added %s\\n\", p->address);\n\n      addr_last = p;\n      p = p->next;\n      }    /* Loop through all addr_new addresses */\n    }\n  }\n\n\n/* Scan the recipients list, and for every one that is not in the non-\nrecipients tree, add an addr item to the chain of new addresses. If the pno\nvalue is non-negative, we must set the onetime parent from it. This which\npoints to the relevant entry in the recipients list.\n\nThis processing can be altered by the setting of the process_recipients\nvariable, which is changed if recipients are to be ignored, failed, or\ndeferred. This can happen as a result of system filter activity, or if the -Mg\noption is used to fail all of them.\n\nDuplicate addresses are handled later by a different tree structure; we can't\njust extend the non-recipients tree, because that will be re-written to the\nspool if the message is deferred, and in any case there are casing\ncomplications for local addresses. */\n\nif (process_recipients != RECIP_IGNORE)\n  for (i = 0; i < recipients_count; i++)\n    if (!tree_search(tree_nonrecipients, recipients_list[i].address))\n      {\n      recipient_item *r = recipients_list + i;\n      address_item *new = deliver_make_addr(r->address, FALSE);\n      new->prop.errors_address = r->errors_to;\n#ifdef SUPPORT_I18N\n      if ((new->prop.utf8_msg = message_smtputf8))\n\t{\n\tnew->prop.utf8_downcvt =       message_utf8_downconvert == 1;\n\tnew->prop.utf8_downcvt_maybe = message_utf8_downconvert == -1;\n\tDEBUG(D_deliver) debug_printf(\"utf8, downconvert %s\\n\",\n\t  new->prop.utf8_downcvt ? \"yes\"\n\t  : new->prop.utf8_downcvt_maybe ? \"ifneeded\"\n\t  : \"no\");\n\t}\n#endif\n\n      if (r->pno >= 0)\n        new->onetime_parent = recipients_list[r->pno].address;\n\n      /* If DSN support is enabled, set the dsn flags and the original receipt\n         to be passed on to other DSN enabled MTAs */\n      new->dsn_flags = r->dsn_flags & rf_dsnflags;\n      new->dsn_orcpt = r->orcpt;\n      DEBUG(D_deliver) debug_printf(\"DSN: set orcpt: %s  flags: %d\\n\",\n\tnew->dsn_orcpt ? new->dsn_orcpt : US\"\", new->dsn_flags);\n\n      switch (process_recipients)\n        {\n        /* RECIP_DEFER is set when a system filter freezes a message. */\n\n        case RECIP_DEFER:\n        new->next = addr_defer;\n        addr_defer = new;\n        break;\n\n\n        /* RECIP_FAIL_FILTER is set when a system filter has obeyed a \"fail\"\n        command. */\n\n        case RECIP_FAIL_FILTER:\n        new->message =\n          filter_message ? filter_message : US\"delivery cancelled\";\n        setflag(new, af_pass_message);\n        goto RECIP_QUEUE_FAILED;   /* below */\n\n\n        /* RECIP_FAIL_TIMEOUT is set when a message is frozen, but is older\n        than the value in timeout_frozen_after. Treat non-bounce messages\n        similarly to -Mg; for bounce messages we just want to discard, so\n        don't put the address on the failed list. The timeout has already\n        been logged. */\n\n        case RECIP_FAIL_TIMEOUT:\n        new->message  = US\"delivery cancelled; message timed out\";\n        goto RECIP_QUEUE_FAILED;   /* below */\n\n\n        /* RECIP_FAIL is set when -Mg has been used. */\n\n        case RECIP_FAIL:\n        new->message  = US\"delivery cancelled by administrator\";\n        /* Fall through */\n\n        /* Common code for the failure cases above. If this is not a bounce\n        message, put the address on the failed list so that it is used to\n        create a bounce. Otherwise do nothing - this just discards the address.\n        The incident has already been logged. */\n\n        RECIP_QUEUE_FAILED:\n        if (sender_address[0] != 0)\n          {\n          new->next = addr_failed;\n          addr_failed = new;\n          }\n        break;\n\n\n        /* RECIP_FAIL_LOOP is set when there are too many Received: headers\n        in the message. Process each address as a routing failure; if this\n        is a bounce message, it will get frozen. */\n\n        case RECIP_FAIL_LOOP:\n        new->message = US\"Too many \\\"Received\\\" headers - suspected mail loop\";\n        post_process_one(new, FAIL, LOG_MAIN, EXIM_DTYPE_ROUTER, 0);\n        break;\n\n\n        /* Value should be RECIP_ACCEPT; take this as the safe default. */\n\n        default:\n        if (!addr_new) addr_new = new; else addr_last->next = new;\n        addr_last = new;\n        break;\n        }\n\n#ifndef DISABLE_EVENT\n      if (process_recipients != RECIP_ACCEPT)\n\t{\n\tuschar * save_local =  deliver_localpart;\n\tconst uschar * save_domain = deliver_domain;\n\tuschar * addr = new->address, * errmsg = NULL;\n\tint start, end, dom;\n\n\tif (!parse_extract_address(addr, &errmsg, &start, &end, &dom, TRUE))\n\t  log_write(0, LOG_MAIN|LOG_PANIC,\n                \"failed to parse address '%.100s': %s\\n\", addr, errmsg);\n\telse\n\t  {\n\t  deliver_localpart =\n\t    string_copyn(addr+start, dom ? (dom-1) - start : end - start);\n\t  deliver_domain = dom ? CUS string_copyn(addr+dom, end - dom) : CUS\"\";\n\n\t  event_raise(event_action, US\"msg:fail:internal\", new->message);\n\n\t  deliver_localpart = save_local;\n\t  deliver_domain = save_domain;\n\t  }\n\t}\n#endif\n      }\n\nDEBUG(D_deliver)\n  {\n  address_item *p;\n  debug_printf(\"Delivery address list:\\n\");\n  for (p = addr_new; p; p = p->next)\n    debug_printf(\"  %s %s\\n\", p->address,\n      p->onetime_parent ? p->onetime_parent : US\"\");\n  }\n\n/* Set up the buffers used for copying over the file when delivering. */\n\ndeliver_in_buffer = store_malloc(DELIVER_IN_BUFFER_SIZE);\ndeliver_out_buffer = store_malloc(DELIVER_OUT_BUFFER_SIZE);\n\n\n\n/* Until there are no more new addresses, handle each one as follows:\n\n . If this is a generated address (indicated by the presence of a parent\n   pointer) then check to see whether it is a pipe, file, or autoreply, and\n   if so, handle it directly here. The router that produced the address will\n   have set the allow flags into the address, and also set the uid/gid required.\n   Having the routers generate new addresses and then checking them here at\n   the outer level is tidier than making each router do the checking, and\n   means that routers don't need access to the failed address queue.\n\n . Break up the address into local part and domain, and make lowercased\n   versions of these strings. We also make unquoted versions of the local part.\n\n . Handle the percent hack for those domains for which it is valid.\n\n . For child addresses, determine if any of the parents have the same address.\n   If so, generate a different string for previous delivery checking. Without\n   this code, if the address spqr generates spqr via a forward or alias file,\n   delivery of the generated spqr stops further attempts at the top level spqr,\n   which is not what is wanted - it may have generated other addresses.\n\n . Check on the retry database to see if routing was previously deferred, but\n   only if in a queue run. Addresses that are to be routed are put on the\n   addr_route chain. Addresses that are to be deferred are put on the\n   addr_defer chain. We do all the checking first, so as not to keep the\n   retry database open any longer than necessary.\n\n . Now we run the addresses through the routers. A router may put the address\n   on either the addr_local or the addr_remote chain for local or remote\n   delivery, respectively, or put it on the addr_failed chain if it is\n   undeliveable, or it may generate child addresses and put them on the\n   addr_new chain, or it may defer an address. All the chain anchors are\n   passed as arguments so that the routers can be called for verification\n   purposes as well.\n\n . If new addresses have been generated by the routers, da capo.\n*/\n\nheader_rewritten = FALSE;          /* No headers rewritten yet */\nwhile (addr_new)           /* Loop until all addresses dealt with */\n  {\n  address_item *addr, *parent;\n\n  /* Failure to open the retry database is treated the same as if it does\n  not exist. In both cases, dbm_file is NULL. */\n\n  if (!(dbm_file = dbfn_open(US\"retry\", O_RDONLY, &dbblock, FALSE)))\n    DEBUG(D_deliver|D_retry|D_route|D_hints_lookup)\n      debug_printf(\"no retry data available\\n\");\n\n  /* Scan the current batch of new addresses, to handle pipes, files and\n  autoreplies, and determine which others are ready for routing. */\n\n  while (addr_new)\n    {\n    int rc;\n    uschar *p;\n    tree_node *tnode;\n    dbdata_retry *domain_retry_record;\n    dbdata_retry *address_retry_record;\n\n    addr = addr_new;\n    addr_new = addr->next;\n\n    DEBUG(D_deliver|D_retry|D_route)\n      {\n      debug_printf(\">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\\n\");\n      debug_printf(\"Considering: %s\\n\", addr->address);\n      }\n\n    /* Handle generated address that is a pipe or a file or an autoreply. */\n\n    if (testflag(addr, af_pfr))\n      {\n      /* If an autoreply in a filter could not generate a syntactically valid\n      address, give up forthwith. Set af_ignore_error so that we don't try to\n      generate a bounce. */\n\n      if (testflag(addr, af_bad_reply))\n        {\n        addr->basic_errno = ERRNO_BADADDRESS2;\n        addr->local_part = addr->address;\n        addr->message =\n          US\"filter autoreply generated syntactically invalid recipient\";\n        addr->prop.ignore_error = TRUE;\n        (void) post_process_one(addr, FAIL, LOG_MAIN, EXIM_DTYPE_ROUTER, 0);\n        continue;   /* with the next new address */\n        }\n\n      /* If two different users specify delivery to the same pipe or file or\n      autoreply, there should be two different deliveries, so build a unique\n      string that incorporates the original address, and use this for\n      duplicate testing and recording delivery, and also for retrying. */\n\n      addr->unique =\n        string_sprintf(\"%s:%s\", addr->address, addr->parent->unique +\n          (testflag(addr->parent, af_homonym)? 3:0));\n\n      addr->address_retry_key = addr->domain_retry_key =\n        string_sprintf(\"T:%s\", addr->unique);\n\n      /* If a filter file specifies two deliveries to the same pipe or file,\n      we want to de-duplicate, but this is probably not wanted for two mail\n      commands to the same address, where probably both should be delivered.\n      So, we have to invent a different unique string in that case. Just\n      keep piling '>' characters on the front. */\n\n      if (addr->address[0] == '>')\n        {\n        while (tree_search(tree_duplicates, addr->unique))\n          addr->unique = string_sprintf(\">%s\", addr->unique);\n        }\n\n      else if ((tnode = tree_search(tree_duplicates, addr->unique)))\n        {\n        DEBUG(D_deliver|D_route)\n          debug_printf(\"%s is a duplicate address: discarded\\n\", addr->address);\n        addr->dupof = tnode->data.ptr;\n        addr->next = addr_duplicate;\n        addr_duplicate = addr;\n        continue;\n        }\n\n      DEBUG(D_deliver|D_route) debug_printf(\"unique = %s\\n\", addr->unique);\n\n      /* Check for previous delivery */\n\n      if (tree_search(tree_nonrecipients, addr->unique))\n        {\n        DEBUG(D_deliver|D_route)\n          debug_printf(\"%s was previously delivered: discarded\\n\", addr->address);\n        child_done(addr, tod_stamp(tod_log));\n        continue;\n        }\n\n      /* Save for checking future duplicates */\n\n      tree_add_duplicate(addr->unique, addr);\n\n      /* Set local part and domain */\n\n      addr->local_part = addr->address;\n      addr->domain = addr->parent->domain;\n\n      /* Ensure that the delivery is permitted. */\n\n      if (testflag(addr, af_file))\n        {\n        if (!testflag(addr, af_allow_file))\n          {\n          addr->basic_errno = ERRNO_FORBIDFILE;\n          addr->message = US\"delivery to file forbidden\";\n          (void)post_process_one(addr, FAIL, LOG_MAIN, EXIM_DTYPE_ROUTER, 0);\n          continue;   /* with the next new address */\n          }\n        }\n      else if (addr->address[0] == '|')\n        {\n        if (!testflag(addr, af_allow_pipe))\n          {\n          addr->basic_errno = ERRNO_FORBIDPIPE;\n          addr->message = US\"delivery to pipe forbidden\";\n          (void)post_process_one(addr, FAIL, LOG_MAIN, EXIM_DTYPE_ROUTER, 0);\n          continue;   /* with the next new address */\n          }\n        }\n      else if (!testflag(addr, af_allow_reply))\n        {\n        addr->basic_errno = ERRNO_FORBIDREPLY;\n        addr->message = US\"autoreply forbidden\";\n        (void)post_process_one(addr, FAIL, LOG_MAIN, EXIM_DTYPE_ROUTER, 0);\n        continue;     /* with the next new address */\n        }\n\n      /* If the errno field is already set to BADTRANSPORT, it indicates\n      failure to expand a transport string, or find the associated transport,\n      or an unset transport when one is required. Leave this test till now so\n      that the forbid errors are given in preference. */\n\n      if (addr->basic_errno == ERRNO_BADTRANSPORT)\n        {\n        (void)post_process_one(addr, DEFER, LOG_MAIN, EXIM_DTYPE_ROUTER, 0);\n        continue;\n        }\n\n      /* Treat /dev/null as a special case and abandon the delivery. This\n      avoids having to specify a uid on the transport just for this case.\n      Arrange for the transport name to be logged as \"**bypassed**\". */\n\n      if (Ustrcmp(addr->address, \"/dev/null\") == 0)\n        {\n        uschar *save = addr->transport->name;\n        addr->transport->name = US\"**bypassed**\";\n        (void)post_process_one(addr, OK, LOG_MAIN, EXIM_DTYPE_TRANSPORT, '=');\n        addr->transport->name = save;\n        continue;   /* with the next new address */\n        }\n\n      /* Pipe, file, or autoreply delivery is to go ahead as a normal local\n      delivery. */\n\n      DEBUG(D_deliver|D_route)\n        debug_printf(\"queued for %s transport\\n\", addr->transport->name);\n      addr->next = addr_local;\n      addr_local = addr;\n      continue;       /* with the next new address */\n      }\n\n    /* Handle normal addresses. First, split up into local part and domain,\n    handling the %-hack if necessary. There is the possibility of a defer from\n    a lookup in percent_hack_domains. */\n\n    if ((rc = deliver_split_address(addr)) == DEFER)\n      {\n      addr->message = US\"cannot check percent_hack_domains\";\n      addr->basic_errno = ERRNO_LISTDEFER;\n      (void)post_process_one(addr, DEFER, LOG_MAIN, EXIM_DTYPE_NONE, 0);\n      continue;\n      }\n\n    /* Check to see if the domain is held. If so, proceed only if the\n    delivery was forced by hand. */\n\n    deliver_domain = addr->domain;  /* set $domain */\n    if (  !forced && hold_domains\n       && (rc = match_isinlist(addr->domain, (const uschar **)&hold_domains, 0,\n           &domainlist_anchor, addr->domain_cache, MCL_DOMAIN, TRUE,\n           NULL)) != FAIL\n       )\n      {\n      if (rc == DEFER)\n        {\n        addr->message = US\"hold_domains lookup deferred\";\n        addr->basic_errno = ERRNO_LISTDEFER;\n        }\n      else\n        {\n        addr->message = US\"domain is held\";\n        addr->basic_errno = ERRNO_HELD;\n        }\n      (void)post_process_one(addr, DEFER, LOG_MAIN, EXIM_DTYPE_NONE, 0);\n      continue;\n      }\n\n    /* Now we can check for duplicates and previously delivered addresses. In\n    order to do this, we have to generate a \"unique\" value for each address,\n    because there may be identical actual addresses in a line of descendents.\n    The \"unique\" field is initialized to the same value as the \"address\" field,\n    but gets changed here to cope with identically-named descendents. */\n\n    for (parent = addr->parent; parent; parent = parent->parent)\n      if (strcmpic(addr->address, parent->address) == 0) break;\n\n    /* If there's an ancestor with the same name, set the homonym flag. This\n    influences how deliveries are recorded. Then add a prefix on the front of\n    the unique address. We use \\n\\ where n starts at 0 and increases each time.\n    It is unlikely to pass 9, but if it does, it may look odd but will still\n    work. This means that siblings or cousins with the same names are treated\n    as duplicates, which is what we want. */\n\n    if (parent)\n      {\n      setflag(addr, af_homonym);\n      if (parent->unique[0] != '\\\\')\n        addr->unique = string_sprintf(\"\\\\0\\\\%s\", addr->address);\n      else\n        addr->unique = string_sprintf(\"\\\\%c\\\\%s\", parent->unique[1] + 1,\n          addr->address);\n      }\n\n    /* Ensure that the domain in the unique field is lower cased, because\n    domains are always handled caselessly. */\n\n    p = Ustrrchr(addr->unique, '@');\n    while (*p != 0) { *p = tolower(*p); p++; }\n\n    DEBUG(D_deliver|D_route) debug_printf(\"unique = %s\\n\", addr->unique);\n\n    if (tree_search(tree_nonrecipients, addr->unique))\n      {\n      DEBUG(D_deliver|D_route)\n        debug_printf(\"%s was previously delivered: discarded\\n\", addr->unique);\n      child_done(addr, tod_stamp(tod_log));\n      continue;\n      }\n\n    /* Get the routing retry status, saving the two retry keys (with and\n    without the local part) for subsequent use. If there is no retry record for\n    the standard address routing retry key, we look for the same key with the\n    sender attached, because this form is used by the smtp transport after a\n    4xx response to RCPT when address_retry_include_sender is true. */\n\n    addr->domain_retry_key = string_sprintf(\"R:%s\", addr->domain);\n    addr->address_retry_key = string_sprintf(\"R:%s@%s\", addr->local_part,\n      addr->domain);\n\n    if (dbm_file)\n      {\n      domain_retry_record = dbfn_read(dbm_file, addr->domain_retry_key);\n      if (  domain_retry_record\n         && now - domain_retry_record->time_stamp > retry_data_expire\n\t )\n        domain_retry_record = NULL;    /* Ignore if too old */\n\n      address_retry_record = dbfn_read(dbm_file, addr->address_retry_key);\n      if (  address_retry_record\n         && now - address_retry_record->time_stamp > retry_data_expire\n\t )\n        address_retry_record = NULL;   /* Ignore if too old */\n\n      if (!address_retry_record)\n        {\n        uschar *altkey = string_sprintf(\"%s:<%s>\", addr->address_retry_key,\n          sender_address);\n        address_retry_record = dbfn_read(dbm_file, altkey);\n        if (  address_retry_record\n\t   && now - address_retry_record->time_stamp > retry_data_expire)\n          address_retry_record = NULL;   /* Ignore if too old */\n        }\n      }\n    else\n      domain_retry_record = address_retry_record = NULL;\n\n    DEBUG(D_deliver|D_retry)\n      {\n      if (!domain_retry_record)\n        debug_printf(\"no domain retry record\\n\");\n      if (!address_retry_record)\n        debug_printf(\"no address retry record\\n\");\n      }\n\n    /* If we are sending a message down an existing SMTP connection, we must\n    assume that the message which created the connection managed to route\n    an address to that connection. We do not want to run the risk of taking\n    a long time over routing here, because if we do, the server at the other\n    end of the connection may time it out. This is especially true for messages\n    with lots of addresses. For this kind of delivery, queue_running is not\n    set, so we would normally route all addresses. We take a pragmatic approach\n    and defer routing any addresses that have any kind of domain retry record.\n    That is, we don't even look at their retry times. It doesn't matter if this\n    doesn't work occasionally. This is all just an optimization, after all.\n\n    The reason for not doing the same for address retries is that they normally\n    arise from 4xx responses, not DNS timeouts. */\n\n    if (continue_hostname && domain_retry_record)\n      {\n      addr->message = US\"reusing SMTP connection skips previous routing defer\";\n      addr->basic_errno = ERRNO_RRETRY;\n      (void)post_process_one(addr, DEFER, LOG_MAIN, EXIM_DTYPE_ROUTER, 0);\n      }\n\n    /* If we are in a queue run, defer routing unless there is no retry data or\n    we've passed the next retry time, or this message is forced. In other\n    words, ignore retry data when not in a queue run.\n\n    However, if the domain retry time has expired, always allow the routing\n    attempt. If it fails again, the address will be failed. This ensures that\n    each address is routed at least once, even after long-term routing\n    failures.\n\n    If there is an address retry, check that too; just wait for the next\n    retry time. This helps with the case when the temporary error on the\n    address was really message-specific rather than address specific, since\n    it allows other messages through.\n\n    We also wait for the next retry time if this is a message sent down an\n    existing SMTP connection (even though that will be forced). Otherwise there\n    will be far too many attempts for an address that gets a 4xx error. In\n    fact, after such an error, we should not get here because, the host should\n    not be remembered as one this message needs. However, there was a bug that\n    used to cause this to  happen, so it is best to be on the safe side.\n\n    Even if we haven't reached the retry time in the hints, there is one more\n    check to do, which is for the ultimate address timeout. We only do this\n    check if there is an address retry record and there is not a domain retry\n    record; this implies that previous attempts to handle the address had the\n    retry_use_local_parts option turned on. We use this as an approximation\n    for the destination being like a local delivery, for example delivery over\n    LMTP to an IMAP message store. In this situation users are liable to bump\n    into their quota and thereby have intermittently successful deliveries,\n    which keep the retry record fresh, which can lead to us perpetually\n    deferring messages. */\n\n    else if (  (  queue_running && !deliver_force\n\t       || continue_hostname\n\t       )\n            && (  (  domain_retry_record\n\t\t  && now < domain_retry_record->next_try\n\t\t  && !domain_retry_record->expired\n\t\t  )\n\t       || (  address_retry_record\n\t\t  && now < address_retry_record->next_try\n\t       )  )\n            && (  domain_retry_record\n\t       || !address_retry_record\n\t       || !retry_ultimate_address_timeout(addr->address_retry_key,\n\t\t\t\t addr->domain, address_retry_record, now)\n\t    )  )\n      {\n      addr->message = US\"retry time not reached\";\n      addr->basic_errno = ERRNO_RRETRY;\n      (void)post_process_one(addr, DEFER, LOG_MAIN, EXIM_DTYPE_ROUTER, 0);\n      }\n\n    /* The domain is OK for routing. Remember if retry data exists so it\n    can be cleaned up after a successful delivery. */\n\n    else\n      {\n      if (domain_retry_record || address_retry_record)\n        setflag(addr, af_dr_retry_exists);\n      addr->next = addr_route;\n      addr_route = addr;\n      DEBUG(D_deliver|D_route)\n        debug_printf(\"%s: queued for routing\\n\", addr->address);\n      }\n    }\n\n  /* The database is closed while routing is actually happening. Requests to\n  update it are put on a chain and all processed together at the end. */\n\n  if (dbm_file) dbfn_close(dbm_file);\n\n  /* If queue_domains is set, we don't even want to try routing addresses in\n  those domains. During queue runs, queue_domains is forced to be unset.\n  Optimize by skipping this pass through the addresses if nothing is set. */\n\n  if (!deliver_force && queue_domains)\n    {\n    address_item *okaddr = NULL;\n    while (addr_route)\n      {\n      address_item *addr = addr_route;\n      addr_route = addr->next;\n\n      deliver_domain = addr->domain;  /* set $domain */\n      if ((rc = match_isinlist(addr->domain, (const uschar **)&queue_domains, 0,\n            &domainlist_anchor, addr->domain_cache, MCL_DOMAIN, TRUE, NULL))\n              != OK)\n        if (rc == DEFER)\n          {\n          addr->basic_errno = ERRNO_LISTDEFER;\n          addr->message = US\"queue_domains lookup deferred\";\n          (void)post_process_one(addr, DEFER, LOG_MAIN, EXIM_DTYPE_ROUTER, 0);\n          }\n        else\n          {\n          addr->next = okaddr;\n          okaddr = addr;\n          }\n      else\n        {\n        addr->basic_errno = ERRNO_QUEUE_DOMAIN;\n        addr->message = US\"domain is in queue_domains\";\n        (void)post_process_one(addr, DEFER, LOG_MAIN, EXIM_DTYPE_ROUTER, 0);\n        }\n      }\n\n    addr_route = okaddr;\n    }\n\n  /* Now route those addresses that are not deferred. */\n\n  while (addr_route)\n    {\n    int rc;\n    address_item *addr = addr_route;\n    const uschar *old_domain = addr->domain;\n    uschar *old_unique = addr->unique;\n    addr_route = addr->next;\n    addr->next = NULL;\n\n    /* Just in case some router parameter refers to it. */\n\n    if (!(return_path = addr->prop.errors_address))\n      return_path = sender_address;\n\n    /* If a router defers an address, add a retry item. Whether or not to\n    use the local part in the key is a property of the router. */\n\n    if ((rc = route_address(addr, &addr_local, &addr_remote, &addr_new,\n         &addr_succeed, v_none)) == DEFER)\n      retry_add_item(addr,\n        addr->router->retry_use_local_part\n        ? string_sprintf(\"R:%s@%s\", addr->local_part, addr->domain)\n\t: string_sprintf(\"R:%s\", addr->domain),\n\t0);\n\n    /* Otherwise, if there is an existing retry record in the database, add\n    retry items to delete both forms. We must also allow for the possibility\n    of a routing retry that includes the sender address. Since the domain might\n    have been rewritten (expanded to fully qualified) as a result of routing,\n    ensure that the rewritten form is also deleted. */\n\n    else if (testflag(addr, af_dr_retry_exists))\n      {\n      uschar *altkey = string_sprintf(\"%s:<%s>\", addr->address_retry_key,\n        sender_address);\n      retry_add_item(addr, altkey, rf_delete);\n      retry_add_item(addr, addr->address_retry_key, rf_delete);\n      retry_add_item(addr, addr->domain_retry_key, rf_delete);\n      if (Ustrcmp(addr->domain, old_domain) != 0)\n        retry_add_item(addr, string_sprintf(\"R:%s\", old_domain), rf_delete);\n      }\n\n    /* DISCARD is given for :blackhole: and \"seen finish\". The event has been\n    logged, but we need to ensure the address (and maybe parents) is marked\n    done. */\n\n    if (rc == DISCARD)\n      {\n      address_done(addr, tod_stamp(tod_log));\n      continue;  /* route next address */\n      }\n\n    /* The address is finished with (failed or deferred). */\n\n    if (rc != OK)\n      {\n      (void)post_process_one(addr, rc, LOG_MAIN, EXIM_DTYPE_ROUTER, 0);\n      continue;  /* route next address */\n      }\n\n    /* The address has been routed. If the router changed the domain, it will\n    also have changed the unique address. We have to test whether this address\n    has already been delivered, because it's the unique address that finally\n    gets recorded. */\n\n    if (  addr->unique != old_unique\n       && tree_search(tree_nonrecipients, addr->unique) != 0\n       )\n      {\n      DEBUG(D_deliver|D_route) debug_printf(\"%s was previously delivered: \"\n        \"discarded\\n\", addr->address);\n      if (addr_remote == addr) addr_remote = addr->next;\n      else if (addr_local == addr) addr_local = addr->next;\n      }\n\n    /* If the router has same_domain_copy_routing set, we are permitted to copy\n    the routing for any other addresses with the same domain. This is an\n    optimisation to save repeated DNS lookups for \"standard\" remote domain\n    routing. The option is settable only on routers that generate host lists.\n    We play it very safe, and do the optimization only if the address is routed\n    to a remote transport, there are no header changes, and the domain was not\n    modified by the router. */\n\n    if (  addr_remote == addr\n       && addr->router->same_domain_copy_routing\n       && !addr->prop.extra_headers\n       && !addr->prop.remove_headers\n       && old_domain == addr->domain\n       )\n      {\n      address_item **chain = &addr_route;\n      while (*chain)\n        {\n        address_item *addr2 = *chain;\n        if (Ustrcmp(addr2->domain, addr->domain) != 0)\n          {\n          chain = &(addr2->next);\n          continue;\n          }\n\n        /* Found a suitable address; take it off the routing list and add it to\n        the remote delivery list. */\n\n        *chain = addr2->next;\n        addr2->next = addr_remote;\n        addr_remote = addr2;\n\n        /* Copy the routing data */\n\n        addr2->domain = addr->domain;\n        addr2->router = addr->router;\n        addr2->transport = addr->transport;\n        addr2->host_list = addr->host_list;\n        addr2->fallback_hosts = addr->fallback_hosts;\n        addr2->prop.errors_address = addr->prop.errors_address;\n        copyflag(addr2, addr, af_hide_child);\n        copyflag(addr2, addr, af_local_host_removed);\n\n        DEBUG(D_deliver|D_route)\n          debug_printf(\">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\\n\"\n                       \"routing %s\\n\"\n                       \"Routing for %s copied from %s\\n\",\n            addr2->address, addr2->address, addr->address);\n        }\n      }\n    }  /* Continue with routing the next address. */\n  }    /* Loop to process any child addresses that the routers created, and\n          any rerouted addresses that got put back on the new chain. */\n\n\n/* Debugging: show the results of the routing */\n\nDEBUG(D_deliver|D_retry|D_route)\n  {\n  address_item *p;\n  debug_printf(\">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\\n\");\n  debug_printf(\"After routing:\\n  Local deliveries:\\n\");\n  for (p = addr_local; p; p = p->next)\n    debug_printf(\"    %s\\n\", p->address);\n\n  debug_printf(\"  Remote deliveries:\\n\");\n  for (p = addr_remote; p; p = p->next)\n    debug_printf(\"    %s\\n\", p->address);\n\n  debug_printf(\"  Failed addresses:\\n\");\n  for (p = addr_failed; p; p = p->next)\n    debug_printf(\"    %s\\n\", p->address);\n\n  debug_printf(\"  Deferred addresses:\\n\");\n  for (p = addr_defer; p; p = p->next)\n    debug_printf(\"    %s\\n\", p->address);\n  }\n\n/* Free any resources that were cached during routing. */\n\nsearch_tidyup();\nroute_tidyup();\n\n/* These two variables are set only during routing, after check_local_user.\nEnsure they are not set in transports. */\n\nlocal_user_gid = (gid_t)(-1);\nlocal_user_uid = (uid_t)(-1);\n\n/* Check for any duplicate addresses. This check is delayed until after\nrouting, because the flexibility of the routing configuration means that\nidentical addresses with different parentage may end up being redirected to\ndifferent addresses. Checking for duplicates too early (as we previously used\nto) makes this kind of thing not work. */\n\ndo_duplicate_check(&addr_local);\ndo_duplicate_check(&addr_remote);\n\n/* When acting as an MUA wrapper, we proceed only if all addresses route to a\nremote transport. The check that they all end up in one transaction happens in\nthe do_remote_deliveries() function. */\n\nif (  mua_wrapper\n   && (addr_local || addr_failed || addr_defer)\n   )\n  {\n  address_item *addr;\n  uschar *which, *colon, *msg;\n\n  if (addr_local)\n    {\n    addr = addr_local;\n    which = US\"local\";\n    }\n  else if (addr_defer)\n    {\n    addr = addr_defer;\n    which = US\"deferred\";\n    }\n  else\n    {\n    addr = addr_failed;\n    which = US\"failed\";\n    }\n\n  while (addr->parent) addr = addr->parent;\n\n  if (addr->message)\n    {\n    colon = US\": \";\n    msg = addr->message;\n    }\n  else colon = msg = US\"\";\n\n  /* We don't need to log here for a forced failure as it will already\n  have been logged. Defer will also have been logged, but as a defer, so we do\n  need to do the failure logging. */\n\n  if (addr != addr_failed)\n    log_write(0, LOG_MAIN, \"** %s routing yielded a %s delivery\",\n      addr->address, which);\n\n  /* Always write an error to the caller */\n\n  fprintf(stderr, \"routing %s yielded a %s delivery%s%s\\n\", addr->address,\n    which, colon, msg);\n\n  final_yield = DELIVER_MUA_FAILED;\n  addr_failed = addr_defer = NULL;   /* So that we remove the message */\n  goto DELIVERY_TIDYUP;\n  }\n\n\n/* If this is a run to continue deliveries to an external channel that is\nalready set up, defer any local deliveries. */\n\nif (continue_transport)\n  {\n  if (addr_defer)\n    {\n    address_item *addr = addr_defer;\n    while (addr->next) addr = addr->next;\n    addr->next = addr_local;\n    }\n  else\n    addr_defer = addr_local;\n  addr_local = NULL;\n  }\n\n\n/* Because address rewriting can happen in the routers, we should not really do\nANY deliveries until all addresses have been routed, so that all recipients of\nthe message get the same headers. However, this is in practice not always\npossible, since sometimes remote addresses give DNS timeouts for days on end.\nThe pragmatic approach is to deliver what we can now, saving any rewritten\nheaders so that at least the next lot of recipients benefit from the rewriting\nthat has already been done.\n\nIf any headers have been rewritten during routing, update the spool file to\nremember them for all subsequent deliveries. This can be delayed till later if\nthere is only address to be delivered - if it succeeds the spool write need not\nhappen. */\n\nif (  header_rewritten\n   && (  addr_local && (addr_local->next || addr_remote)\n      || addr_remote && addr_remote->next\n   )  )\n  {\n  /* Panic-dies on error */\n  (void)spool_write_header(message_id, SW_DELIVERING, NULL);\n  header_rewritten = FALSE;\n  }\n\n\n/* If there are any deliveries to be and we do not already have the journal\nfile, create it. This is used to record successful deliveries as soon as\npossible after each delivery is known to be complete. A file opened with\nO_APPEND is used so that several processes can run simultaneously.\n\nThe journal is just insurance against crashes. When the spool file is\nultimately updated at the end of processing, the journal is deleted. If a\njournal is found to exist at the start of delivery, the addresses listed\ntherein are added to the non-recipients. */\n\nif (addr_local || addr_remote)\n  {\n  if (journal_fd < 0)\n    {\n    uschar * fname = spool_fname(US\"input\", message_subdir, id, US\"-J\");\n\n    if ((journal_fd = Uopen(fname,\n#ifdef O_CLOEXEC\n\t\t\tO_CLOEXEC |\n#endif\n\t\t\tO_WRONLY|O_APPEND|O_CREAT|O_EXCL, SPOOL_MODE)) < 0)\n      {\n      log_write(0, LOG_MAIN|LOG_PANIC, \"Couldn't open journal file %s: %s\",\n\tfname, strerror(errno));\n      return DELIVER_NOT_ATTEMPTED;\n      }\n\n    /* Set the close-on-exec flag, make the file owned by Exim, and ensure\n    that the mode is correct - the group setting doesn't always seem to get\n    set automatically. */\n\n    if(  fchown(journal_fd, exim_uid, exim_gid)\n      || fchmod(journal_fd, SPOOL_MODE)\n#ifndef O_CLOEXEC\n      || fcntl(journal_fd, F_SETFD, fcntl(journal_fd, F_GETFD) | FD_CLOEXEC)\n#endif\n      )\n      {\n      int ret = Uunlink(fname);\n      log_write(0, LOG_MAIN|LOG_PANIC, \"Couldn't set perms on journal file %s: %s\",\n\tfname, strerror(errno));\n      if(ret  &&  errno != ENOENT)\n\tlog_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to unlink %s: %s\",\n\t  fname, strerror(errno));\n      return DELIVER_NOT_ATTEMPTED;\n      }\n    }\n  }\nelse if (journal_fd >= 0)\n  {\n  close(journal_fd);\n  journal_fd = -1;\n  }\n\n\n\n/* Now we can get down to the business of actually doing deliveries. Local\ndeliveries are done first, then remote ones. If ever the problems of how to\nhandle fallback transports are figured out, this section can be put into a loop\nfor handling fallbacks, though the uid switching will have to be revised. */\n\n/* Precompile a regex that is used to recognize a parameter in response\nto an LHLO command, if is isn't already compiled. This may be used on both\nlocal and remote LMTP deliveries. */\n\nif (!regex_IGNOREQUOTA)\n  regex_IGNOREQUOTA =\n    regex_must_compile(US\"\\\\n250[\\\\s\\\\-]IGNOREQUOTA(\\\\s|\\\\n|$)\", FALSE, TRUE);\n\n/* Handle local deliveries */\n\nif (addr_local)\n  {\n  DEBUG(D_deliver|D_transport)\n    debug_printf(\">>>>>>>>>>>>>>>> Local deliveries >>>>>>>>>>>>>>>>\\n\");\n  do_local_deliveries();\n  disable_logging = FALSE;\n  }\n\n/* If queue_run_local is set, we do not want to attempt any remote deliveries,\nso just queue them all. */\n\nif (queue_run_local)\n  while (addr_remote)\n    {\n    address_item *addr = addr_remote;\n    addr_remote = addr->next;\n    addr->next = NULL;\n    addr->basic_errno = ERRNO_LOCAL_ONLY;\n    addr->message = US\"remote deliveries suppressed\";\n    (void)post_process_one(addr, DEFER, LOG_MAIN, EXIM_DTYPE_TRANSPORT, 0);\n    }\n\n/* Handle remote deliveries */\n\nif (addr_remote)\n  {\n  DEBUG(D_deliver|D_transport)\n    debug_printf(\">>>>>>>>>>>>>>>> Remote deliveries >>>>>>>>>>>>>>>>\\n\");\n\n  /* Precompile some regex that are used to recognize parameters in response\n  to an EHLO command, if they aren't already compiled. */\n\n  deliver_init();\n\n  /* Now sort the addresses if required, and do the deliveries. The yield of\n  do_remote_deliveries is FALSE when mua_wrapper is set and all addresses\n  cannot be delivered in one transaction. */\n\n  if (remote_sort_domains) sort_remote_deliveries();\n  if (!do_remote_deliveries(FALSE))\n    {\n    log_write(0, LOG_MAIN, \"** mua_wrapper is set but recipients cannot all \"\n      \"be delivered in one transaction\");\n    fprintf(stderr, \"delivery to smarthost failed (configuration problem)\\n\");\n\n    final_yield = DELIVER_MUA_FAILED;\n    addr_failed = addr_defer = NULL;   /* So that we remove the message */\n    goto DELIVERY_TIDYUP;\n    }\n\n  /* See if any of the addresses that failed got put on the queue for delivery\n  to their fallback hosts. We do it this way because often the same fallback\n  host is used for many domains, so all can be sent in a single transaction\n  (if appropriately configured). */\n\n  if (addr_fallback && !mua_wrapper)\n    {\n    DEBUG(D_deliver) debug_printf(\"Delivering to fallback hosts\\n\");\n    addr_remote = addr_fallback;\n    addr_fallback = NULL;\n    if (remote_sort_domains) sort_remote_deliveries();\n    do_remote_deliveries(TRUE);\n    }\n  disable_logging = FALSE;\n  }\n\n\n/* All deliveries are now complete. Ignore SIGTERM during this tidying up\nphase, to minimize cases of half-done things. */\n\nDEBUG(D_deliver)\n  debug_printf(\">>>>>>>>>>>>>>>> deliveries are done >>>>>>>>>>>>>>>>\\n\");\ncancel_cutthrough_connection(TRUE, US\"deliveries are done\");\n\n/* Root privilege is no longer needed */\n\nexim_setugid(exim_uid, exim_gid, FALSE, US\"post-delivery tidying\");\n\nset_process_info(\"tidying up after delivering %s\", message_id);\nsignal(SIGTERM, SIG_IGN);\n\n/* When we are acting as an MUA wrapper, the smtp transport will either have\nsucceeded for all addresses, or failed them all in normal cases. However, there\nare some setup situations (e.g. when a named port does not exist) that cause an\nimmediate exit with deferral of all addresses. Convert those into failures. We\ndo not ever want to retry, nor do we want to send a bounce message. */\n\nif (mua_wrapper)\n  {\n  if (addr_defer)\n    {\n    address_item *addr, *nextaddr;\n    for (addr = addr_defer; addr; addr = nextaddr)\n      {\n      log_write(0, LOG_MAIN, \"** %s mua_wrapper forced failure for deferred \"\n        \"delivery\", addr->address);\n      nextaddr = addr->next;\n      addr->next = addr_failed;\n      addr_failed = addr;\n      }\n    addr_defer = NULL;\n    }\n\n  /* Now all should either have succeeded or failed. */\n\n  if (!addr_failed)\n    final_yield = DELIVER_MUA_SUCCEEDED;\n  else\n    {\n    host_item * host;\n    uschar *s = addr_failed->user_message;\n\n    if (!s) s = addr_failed->message;\n\n    fprintf(stderr, \"Delivery failed: \");\n    if (addr_failed->basic_errno > 0)\n      {\n      fprintf(stderr, \"%s\", strerror(addr_failed->basic_errno));\n      if (s) fprintf(stderr, \": \");\n      }\n    if ((host = addr_failed->host_used))\n      fprintf(stderr, \"H=%s [%s]: \", host->name, host->address);\n    if (s)\n      fprintf(stderr, \"%s\", CS s);\n    else if (addr_failed->basic_errno <= 0)\n      fprintf(stderr, \"unknown error\");\n    fprintf(stderr, \"\\n\");\n\n    final_yield = DELIVER_MUA_FAILED;\n    addr_failed = NULL;\n    }\n  }\n\n/* In a normal configuration, we now update the retry database. This is done in\none fell swoop at the end in order not to keep opening and closing (and\nlocking) the database. The code for handling retries is hived off into a\nseparate module for convenience. We pass it the addresses of the various\nchains, because deferred addresses can get moved onto the failed chain if the\nretry cutoff time has expired for all alternative destinations. Bypass the\nupdating of the database if the -N flag is set, which is a debugging thing that\nprevents actual delivery. */\n\nelse if (!dont_deliver)\n  retry_update(&addr_defer, &addr_failed, &addr_succeed);\n\n/* Send DSN for successful messages if requested */\naddr_senddsn = NULL;\n\nfor (addr_dsntmp = addr_succeed; addr_dsntmp; addr_dsntmp = addr_dsntmp->next)\n  {\n  /* af_ignore_error not honored here. it's not an error */\n  DEBUG(D_deliver) debug_printf(\"DSN: processing router : %s\\n\"\n      \"DSN: processing successful delivery address: %s\\n\"\n      \"DSN: Sender_address: %s\\n\"\n      \"DSN: orcpt: %s  flags: %d\\n\"\n      \"DSN: envid: %s  ret: %d\\n\"\n      \"DSN: Final recipient: %s\\n\"\n      \"DSN: Remote SMTP server supports DSN: %d\\n\",\n      addr_dsntmp->router ? addr_dsntmp->router->name : US\"(unknown)\",\n      addr_dsntmp->address,\n      sender_address,\n      addr_dsntmp->dsn_orcpt ? addr_dsntmp->dsn_orcpt : US\"NULL\",\n      addr_dsntmp->dsn_flags,\n      dsn_envid ? dsn_envid : US\"NULL\", dsn_ret,\n      addr_dsntmp->address,\n      addr_dsntmp->dsn_aware\n      );\n\n  /* send report if next hop not DSN aware or a router flagged \"last DSN hop\"\n     and a report was requested */\n  if (  (  addr_dsntmp->dsn_aware != dsn_support_yes\n\t|| addr_dsntmp->dsn_flags & rf_dsnlasthop\n        )\n     && addr_dsntmp->dsn_flags & rf_dsnflags\n     && addr_dsntmp->dsn_flags & rf_notify_success\n     )\n    {\n    /* copy and relink address_item and send report with all of them at once later */\n    address_item * addr_next = addr_senddsn;\n    addr_senddsn = store_get(sizeof(address_item));\n    *addr_senddsn = *addr_dsntmp;\n    addr_senddsn->next = addr_next;\n    }\n  else\n    DEBUG(D_deliver) debug_printf(\"DSN: not sending DSN success message\\n\");\n  }\n\nif (addr_senddsn)\n  {\n  pid_t pid;\n  int fd;\n\n  /* create exim process to send message */\n  pid = child_open_exim(&fd);\n\n  DEBUG(D_deliver) debug_printf(\"DSN: child_open_exim returns: %d\\n\", pid);\n\n  if (pid < 0)  /* Creation of child failed */\n    {\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"Process %d (parent %d) failed to \"\n      \"create child process to send failure message: %s\", getpid(),\n      getppid(), strerror(errno));\n\n    DEBUG(D_deliver) debug_printf(\"DSN: child_open_exim failed\\n\");\n    }\n  else  /* Creation of child succeeded */\n    {\n    FILE *f = fdopen(fd, \"wb\");\n    /* header only as required by RFC. only failure DSN needs to honor RET=FULL */\n    uschar * bound;\n    transport_ctx tctx = {{0}};\n\n    DEBUG(D_deliver)\n      debug_printf(\"sending error message to: %s\\n\", sender_address);\n\n    /* build unique id for MIME boundary */\n    bound = string_sprintf(TIME_T_FMT \"-eximdsn-%d\", time(NULL), rand());\n    DEBUG(D_deliver) debug_printf(\"DSN: MIME boundary: %s\\n\", bound);\n\n    if (errors_reply_to)\n      fprintf(f, \"Reply-To: %s\\n\", errors_reply_to);\n\n    fprintf(f, \"Auto-Submitted: auto-generated\\n\"\n\t\"From: Mail Delivery System <Mailer-Daemon@%s>\\n\"\n\t\"To: %s\\n\"\n\t\"Subject: Delivery Status Notification\\n\"\n\t\"Content-Type: multipart/report; report-type=delivery-status; boundary=%s\\n\"\n\t\"MIME-Version: 1.0\\n\\n\"\n\n\t\"--%s\\n\"\n\t\"Content-type: text/plain; charset=us-ascii\\n\\n\"\n\n\t\"This message was created automatically by mail delivery software.\\n\"\n\t\" ----- The following addresses had successful delivery notifications -----\\n\",\n      qualify_domain_sender, sender_address, bound, bound);\n\n    for (addr_dsntmp = addr_senddsn; addr_dsntmp;\n\t addr_dsntmp = addr_dsntmp->next)\n      fprintf(f, \"<%s> (relayed %s)\\n\\n\",\n\taddr_dsntmp->address,\n\t(addr_dsntmp->dsn_flags & rf_dsnlasthop) == 1\n\t  ? \"via non DSN router\"\n\t  : addr_dsntmp->dsn_aware == dsn_support_no\n\t  ? \"to non-DSN-aware mailer\"\n\t  : \"via non \\\"Remote SMTP\\\" router\"\n\t);\n\n    fprintf(f, \"--%s\\n\"\n\t\"Content-type: message/delivery-status\\n\\n\"\n\t\"Reporting-MTA: dns; %s\\n\",\n      bound, smtp_active_hostname);\n\n    if (dsn_envid)\n      {\t\t\t/* must be decoded from xtext: see RFC 3461:6.3a */\n      uschar *xdec_envid;\n      if (auth_xtextdecode(dsn_envid, &xdec_envid) > 0)\n        fprintf(f, \"Original-Envelope-ID: %s\\n\", dsn_envid);\n      else\n        fprintf(f, \"X-Original-Envelope-ID: error decoding xtext formatted ENVID\\n\");\n      }\n    fputc('\\n', f);\n\n    for (addr_dsntmp = addr_senddsn;\n\t addr_dsntmp;\n\t addr_dsntmp = addr_dsntmp->next)\n      {\n      if (addr_dsntmp->dsn_orcpt)\n        fprintf(f,\"Original-Recipient: %s\\n\", addr_dsntmp->dsn_orcpt);\n\n      fprintf(f, \"Action: delivered\\n\"\n\t  \"Final-Recipient: rfc822;%s\\n\"\n\t  \"Status: 2.0.0\\n\",\n\taddr_dsntmp->address);\n\n      if (addr_dsntmp->host_used && addr_dsntmp->host_used->name)\n        fprintf(f, \"Remote-MTA: dns; %s\\nDiagnostic-Code: smtp; 250 Ok\\n\\n\",\n\t  addr_dsntmp->host_used->name);\n      else\n\tfprintf(f, \"Diagnostic-Code: X-Exim; relayed via non %s router\\n\\n\",\n\t  (addr_dsntmp->dsn_flags & rf_dsnlasthop) == 1 ? \"DSN\" : \"SMTP\");\n      }\n\n    fprintf(f, \"--%s\\nContent-type: text/rfc822-headers\\n\\n\", bound);\n\n    fflush(f);\n    transport_filter_argv = NULL;   /* Just in case */\n    return_path = sender_address;   /* In case not previously set */\n\n    /* Write the original email out */\n\n    tctx.u.fd = fileno(f);\n    tctx.options = topt_add_return_path | topt_no_body;\n    transport_write_message(&tctx, 0);\n    fflush(f);\n\n    fprintf(f,\"\\n--%s--\\n\", bound);\n\n    fflush(f);\n    fclose(f);\n    rc = child_close(pid, 0);     /* Waits for child to close, no timeout */\n    }\n  }\n\n/* If any addresses failed, we must send a message to somebody, unless\naf_ignore_error is set, in which case no action is taken. It is possible for\nseveral messages to get sent if there are addresses with different\nrequirements. */\n\nwhile (addr_failed)\n  {\n  pid_t pid;\n  int fd;\n  uschar *logtod = tod_stamp(tod_log);\n  address_item *addr;\n  address_item *handled_addr = NULL;\n  address_item **paddr;\n  address_item *msgchain = NULL;\n  address_item **pmsgchain = &msgchain;\n\n  /* There are weird cases when logging is disabled in the transport. However,\n  there may not be a transport (address failed by a router). */\n\n  disable_logging = FALSE;\n  if (addr_failed->transport)\n    disable_logging = addr_failed->transport->disable_logging;\n\n  DEBUG(D_deliver)\n    debug_printf(\"processing failed address %s\\n\", addr_failed->address);\n\n  /* There are only two ways an address in a bounce message can get here:\n\n  (1) When delivery was initially deferred, but has now timed out (in the call\n      to retry_update() above). We can detect this by testing for\n      af_retry_timedout. If the address does not have its own errors address,\n      we arrange to ignore the error.\n\n  (2) If delivery failures for bounce messages are being ignored. We can detect\n      this by testing for af_ignore_error. This will also be set if a bounce\n      message has been autothawed and the ignore_bounce_errors_after time has\n      passed. It might also be set if a router was explicitly configured to\n      ignore errors (errors_to = \"\").\n\n  If neither of these cases obtains, something has gone wrong. Log the\n  incident, but then ignore the error. */\n\n  if (sender_address[0] == 0 && !addr_failed->prop.errors_address)\n    {\n    if (  !testflag(addr_failed, af_retry_timedout)\n       && !addr_failed->prop.ignore_error)\n      log_write(0, LOG_MAIN|LOG_PANIC, \"internal error: bounce message \"\n        \"failure is neither frozen nor ignored (it's been ignored)\");\n\n    addr_failed->prop.ignore_error = TRUE;\n    }\n\n  /* If the first address on the list has af_ignore_error set, just remove\n  it from the list, throw away any saved message file, log it, and\n  mark the recipient done. */\n\n  if (  addr_failed->prop.ignore_error\n     || (  addr_failed->dsn_flags & rf_dsnflags\n        && (addr_failed->dsn_flags & rf_notify_failure) != rf_notify_failure\n     )  )\n    {\n    addr = addr_failed;\n    addr_failed = addr->next;\n    if (addr->return_filename) Uunlink(addr->return_filename);\n\n    log_write(0, LOG_MAIN, \"%s%s%s%s: error ignored\",\n      addr->address,\n      !addr->parent ? US\"\" : US\" <\",\n      !addr->parent ? US\"\" : addr->parent->address,\n      !addr->parent ? US\"\" : US\">\");\n\n    address_done(addr, logtod);\n    child_done(addr, logtod);\n    /* Panic-dies on error */\n    (void)spool_write_header(message_id, SW_DELIVERING, NULL);\n    }\n\n  /* Otherwise, handle the sending of a message. Find the error address for\n  the first address, then send a message that includes all failed addresses\n  that have the same error address. Note the bounce_recipient is a global so\n  that it can be accessed by $bounce_recipient while creating a customized\n  error message. */\n\n  else\n    {\n    if (!(bounce_recipient = addr_failed->prop.errors_address))\n      bounce_recipient = sender_address;\n\n    /* Make a subprocess to send a message */\n\n    if ((pid = child_open_exim(&fd)) < 0)\n      log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"Process %d (parent %d) failed to \"\n        \"create child process to send failure message: %s\", getpid(),\n        getppid(), strerror(errno));\n\n    /* Creation of child succeeded */\n\n    else\n      {\n      int ch, rc;\n      int filecount = 0;\n      int rcount = 0;\n      uschar *bcc, *emf_text;\n      FILE *f = fdopen(fd, \"wb\");\n      FILE *emf = NULL;\n      BOOL to_sender = strcmpic(sender_address, bounce_recipient) == 0;\n      int max = (bounce_return_size_limit/DELIVER_IN_BUFFER_SIZE + 1) *\n        DELIVER_IN_BUFFER_SIZE;\n      uschar * bound;\n      uschar *dsnlimitmsg;\n      uschar *dsnnotifyhdr;\n      int topt;\n\n      DEBUG(D_deliver)\n        debug_printf(\"sending error message to: %s\\n\", bounce_recipient);\n\n      /* Scan the addresses for all that have the same errors address, removing\n      them from the addr_failed chain, and putting them on msgchain. */\n\n      paddr = &addr_failed;\n      for (addr = addr_failed; addr; addr = *paddr)\n        if (Ustrcmp(bounce_recipient, addr->prop.errors_address\n\t      ? addr->prop.errors_address : sender_address) == 0)\n          {                          /* The same - dechain */\n          *paddr = addr->next;\n          *pmsgchain = addr;\n          addr->next = NULL;\n          pmsgchain = &(addr->next);\n          }\n        else\n          paddr = &addr->next;        /* Not the same; skip */\n\n      /* Include X-Failed-Recipients: for automatic interpretation, but do\n      not let any one header line get too long. We do this by starting a\n      new header every 50 recipients. Omit any addresses for which the\n      \"hide_child\" flag is set. */\n\n      for (addr = msgchain; addr; addr = addr->next)\n        {\n        if (testflag(addr, af_hide_child)) continue;\n        if (rcount >= 50)\n          {\n          fprintf(f, \"\\n\");\n          rcount = 0;\n          }\n        fprintf(f, \"%s%s\",\n          rcount++ == 0\n\t  ? \"X-Failed-Recipients: \"\n\t  : \",\\n  \",\n          testflag(addr, af_pfr) && addr->parent\n\t  ? string_printing(addr->parent->address)\n\t  : string_printing(addr->address));\n        }\n      if (rcount > 0) fprintf(f, \"\\n\");\n\n      /* Output the standard headers */\n\n      if (errors_reply_to)\n        fprintf(f, \"Reply-To: %s\\n\", errors_reply_to);\n      fprintf(f, \"Auto-Submitted: auto-replied\\n\");\n      moan_write_from(f);\n      fprintf(f, \"To: %s\\n\", bounce_recipient);\n\n      /* generate boundary string and output MIME-Headers */\n      bound = string_sprintf(TIME_T_FMT \"-eximdsn-%d\", time(NULL), rand());\n\n      fprintf(f, \"Content-Type: multipart/report;\"\n\t    \" report-type=delivery-status; boundary=%s\\n\"\n\t  \"MIME-Version: 1.0\\n\",\n\tbound);\n\n      /* Open a template file if one is provided. Log failure to open, but\n      carry on - default texts will be used. */\n\n      if (bounce_message_file)\n        if (!(emf = Ufopen(bounce_message_file, \"rb\")))\n          log_write(0, LOG_MAIN|LOG_PANIC, \"Failed to open %s for error \"\n            \"message texts: %s\", bounce_message_file, strerror(errno));\n\n      /* Quietly copy to configured additional addresses if required. */\n\n      if ((bcc = moan_check_errorcopy(bounce_recipient)))\n\tfprintf(f, \"Bcc: %s\\n\", bcc);\n\n      /* The texts for the message can be read from a template file; if there\n      isn't one, or if it is too short, built-in texts are used. The first\n      emf text is a Subject: and any other headers. */\n\n      if ((emf_text = next_emf(emf, US\"header\")))\n\tfprintf(f, \"%s\\n\", emf_text);\n      else\n        fprintf(f, \"Subject: Mail delivery failed%s\\n\\n\",\n          to_sender? \": returning message to sender\" : \"\");\n\n      /* output human readable part as text/plain section */\n      fprintf(f, \"--%s\\n\"\n\t  \"Content-type: text/plain; charset=us-ascii\\n\\n\",\n\tbound);\n\n      if ((emf_text = next_emf(emf, US\"intro\")))\n\tfprintf(f, \"%s\", CS emf_text);\n      else\n        {\n        fprintf(f,\n/* This message has been reworded several times. It seems to be confusing to\nsomebody, however it is worded. I have retreated to the original, simple\nwording. */\n\"This message was created automatically by mail delivery software.\\n\");\n\n        if (bounce_message_text)\n\t  fprintf(f, \"%s\", CS bounce_message_text);\n        if (to_sender)\n          fprintf(f,\n\"\\nA message that you sent could not be delivered to one or more of its\\n\"\n\"recipients. This is a permanent error. The following address(es) failed:\\n\");\n        else\n          fprintf(f,\n\"\\nA message sent by\\n\\n  <%s>\\n\\n\"\n\"could not be delivered to one or more of its recipients. The following\\n\"\n\"address(es) failed:\\n\", sender_address);\n        }\n      fputc('\\n', f);\n\n      /* Process the addresses, leaving them on the msgchain if they have a\n      file name for a return message. (There has already been a check in\n      post_process_one() for the existence of data in the message file.) A TRUE\n      return from print_address_information() means that the address is not\n      hidden. */\n\n      paddr = &msgchain;\n      for (addr = msgchain; addr; addr = *paddr)\n        {\n        if (print_address_information(addr, f, US\"  \", US\"\\n    \", US\"\"))\n          print_address_error(addr, f, US\"\");\n\n        /* End the final line for the address */\n\n        fputc('\\n', f);\n\n        /* Leave on msgchain if there's a return file. */\n\n        if (addr->return_file >= 0)\n          {\n          paddr = &(addr->next);\n          filecount++;\n          }\n\n        /* Else save so that we can tick off the recipient when the\n        message is sent. */\n\n        else\n          {\n          *paddr = addr->next;\n          addr->next = handled_addr;\n          handled_addr = addr;\n          }\n        }\n\n      fputc('\\n', f);\n\n      /* Get the next text, whether we need it or not, so as to be\n      positioned for the one after. */\n\n      emf_text = next_emf(emf, US\"generated text\");\n\n      /* If there were any file messages passed by the local transports,\n      include them in the message. Then put the address on the handled chain.\n      In the case of a batch of addresses that were all sent to the same\n      transport, the return_file field in all of them will contain the same\n      fd, and the return_filename field in the *last* one will be set (to the\n      name of the file). */\n\n      if (msgchain)\n        {\n        address_item *nextaddr;\n\n        if (emf_text)\n\t  fprintf(f, \"%s\", CS emf_text);\n\telse\n          fprintf(f,\n            \"The following text was generated during the delivery \"\n            \"attempt%s:\\n\", (filecount > 1)? \"s\" : \"\");\n\n        for (addr = msgchain; addr; addr = nextaddr)\n          {\n          FILE *fm;\n          address_item *topaddr = addr;\n\n          /* List all the addresses that relate to this file */\n\n\t  fputc('\\n', f);\n          while(addr)                   /* Insurance */\n            {\n            print_address_information(addr, f, US\"------ \",  US\"\\n       \",\n              US\" ------\\n\");\n            if (addr->return_filename) break;\n            addr = addr->next;\n            }\n\t  fputc('\\n', f);\n\n          /* Now copy the file */\n\n          if (!(fm = Ufopen(addr->return_filename, \"rb\")))\n            fprintf(f, \"    +++ Exim error... failed to open text file: %s\\n\",\n              strerror(errno));\n          else\n            {\n            while ((ch = fgetc(fm)) != EOF) fputc(ch, f);\n            (void)fclose(fm);\n            }\n          Uunlink(addr->return_filename);\n\n          /* Can now add to handled chain, first fishing off the next\n          address on the msgchain. */\n\n          nextaddr = addr->next;\n          addr->next = handled_addr;\n          handled_addr = topaddr;\n          }\n\tfputc('\\n', f);\n        }\n\n      /* output machine readable part */\n#ifdef SUPPORT_I18N\n      if (message_smtputf8)\n\tfprintf(f, \"--%s\\n\"\n\t    \"Content-type: message/global-delivery-status\\n\\n\"\n\t    \"Reporting-MTA: dns; %s\\n\",\n\t  bound, smtp_active_hostname);\n      else\n#endif\n\tfprintf(f, \"--%s\\n\"\n\t    \"Content-type: message/delivery-status\\n\\n\"\n\t    \"Reporting-MTA: dns; %s\\n\",\n\t  bound, smtp_active_hostname);\n\n      if (dsn_envid)\n\t{\n        /* must be decoded from xtext: see RFC 3461:6.3a */\n        uschar *xdec_envid;\n        if (auth_xtextdecode(dsn_envid, &xdec_envid) > 0)\n          fprintf(f, \"Original-Envelope-ID: %s\\n\", dsn_envid);\n        else\n          fprintf(f, \"X-Original-Envelope-ID: error decoding xtext formatted ENVID\\n\");\n        }\n      fputc('\\n', f);\n\n      for (addr = handled_addr; addr; addr = addr->next)\n        {\n\thost_item * hu;\n        fprintf(f, \"Action: failed\\n\"\n\t    \"Final-Recipient: rfc822;%s\\n\"\n\t    \"Status: 5.0.0\\n\",\n\t    addr->address);\n        if ((hu = addr->host_used) && hu->name)\n\t  {\n\t  const uschar * s;\n\t  fprintf(f, \"Remote-MTA: dns; %s\\n\", hu->name);\n#ifdef EXPERIMENTAL_DSN_INFO\n\t  if (hu->address)\n\t    {\n\t    uschar * p = hu->port == 25\n\t      ? US\"\" : string_sprintf(\":%d\", hu->port);\n\t    fprintf(f, \"Remote-MTA: X-ip; [%s]%s\\n\", hu->address, p);\n\t    }\n\t  if ((s = addr->smtp_greeting) && *s)\n\t    fprintf(f, \"X-Remote-MTA-smtp-greeting: X-str; %s\\n\", s);\n\t  if ((s = addr->helo_response) && *s)\n\t    fprintf(f, \"X-Remote-MTA-helo-response: X-str; %s\\n\", s);\n\t  if ((s = addr->message) && *s)\n\t    fprintf(f, \"X-Exim-Diagnostic: X-str; %s\\n\", s);\n#endif\n\t  print_dsn_diagnostic_code(addr, f);\n\t  }\n\tfputc('\\n', f);\n        }\n\n      /* Now copy the message, trying to give an intelligible comment if\n      it is too long for it all to be copied. The limit isn't strictly\n      applied because of the buffering. There is, however, an option\n      to suppress copying altogether. */\n\n      emf_text = next_emf(emf, US\"copy\");\n\n      /* add message body\n         we ignore the intro text from template and add\n         the text for bounce_return_size_limit at the end.\n\n         bounce_return_message is ignored\n         in case RET= is defined we honor these values\n         otherwise bounce_return_body is honored.\n\n         bounce_return_size_limit is always honored.\n      */\n\n      fprintf(f, \"--%s\\n\", bound);\n\n      dsnlimitmsg = US\"X-Exim-DSN-Information: Due to administrative limits only headers are returned\";\n      dsnnotifyhdr = NULL;\n      topt = topt_add_return_path;\n\n      /* RET=HDRS? top priority */\n      if (dsn_ret == dsn_ret_hdrs)\n        topt |= topt_no_body;\n      else\n\t{\n\tstruct stat statbuf;\n\n        /* no full body return at all? */\n        if (!bounce_return_body)\n          {\n          topt |= topt_no_body;\n          /* add header if we overrule RET=FULL */\n          if (dsn_ret == dsn_ret_full)\n            dsnnotifyhdr = dsnlimitmsg;\n          }\n\t/* line length limited... return headers only if oversize */\n        /* size limited ... return headers only if limit reached */\n\telse if (  max_received_linelength > bounce_return_linesize_limit\n\t\t|| (  bounce_return_size_limit > 0\n\t\t   && fstat(deliver_datafile, &statbuf) == 0\n\t\t   && statbuf.st_size > max\n\t\t)  )\n\t  {\n\t  topt |= topt_no_body;\n\t  dsnnotifyhdr = dsnlimitmsg;\n          }\n\t}\n\n#ifdef SUPPORT_I18N\n      if (message_smtputf8)\n\tfputs(topt & topt_no_body ? \"Content-type: message/global-headers\\n\\n\"\n\t\t\t\t  : \"Content-type: message/global\\n\\n\",\n\t      f);\n      else\n#endif\n\tfputs(topt & topt_no_body ? \"Content-type: text/rfc822-headers\\n\\n\"\n\t\t\t\t  : \"Content-type: message/rfc822\\n\\n\",\n\t      f);\n\n      fflush(f);\n      transport_filter_argv = NULL;   /* Just in case */\n      return_path = sender_address;   /* In case not previously set */\n\t{\t\t\t      /* Dummy transport for headers add */\n\ttransport_ctx tctx = {{0}};\n\ttransport_instance tb = {0};\n\n\ttctx.u.fd = fileno(f);\n\ttctx.tblock = &tb;\n\ttctx.options = topt;\n\ttb.add_headers = dsnnotifyhdr;\n\n\ttransport_write_message(&tctx, 0);\n\t}\n      fflush(f);\n\n      /* we never add the final text. close the file */\n      if (emf)\n        (void)fclose(emf);\n\n      fprintf(f, \"\\n--%s--\\n\", bound);\n\n      /* Close the file, which should send an EOF to the child process\n      that is receiving the message. Wait for it to finish. */\n\n      (void)fclose(f);\n      rc = child_close(pid, 0);     /* Waits for child to close, no timeout */\n\n      /* In the test harness, let the child do it's thing first. */\n\n      if (running_in_test_harness) millisleep(500);\n\n      /* If the process failed, there was some disaster in setting up the\n      error message. Unless the message is very old, ensure that addr_defer\n      is non-null, which will have the effect of leaving the message on the\n      spool. The failed addresses will get tried again next time. However, we\n      don't really want this to happen too often, so freeze the message unless\n      there are some genuine deferred addresses to try. To do this we have\n      to call spool_write_header() here, because with no genuine deferred\n      addresses the normal code below doesn't get run. */\n\n      if (rc != 0)\n        {\n        uschar *s = US\"\";\n        if (now - received_time.tv_sec < retry_maximum_timeout && !addr_defer)\n          {\n          addr_defer = (address_item *)(+1);\n          deliver_freeze = TRUE;\n          deliver_frozen_at = time(NULL);\n          /* Panic-dies on error */\n          (void)spool_write_header(message_id, SW_DELIVERING, NULL);\n          s = US\" (frozen)\";\n          }\n        deliver_msglog(\"Process failed (%d) when writing error message \"\n          \"to %s%s\", rc, bounce_recipient, s);\n        log_write(0, LOG_MAIN, \"Process failed (%d) when writing error message \"\n          \"to %s%s\", rc, bounce_recipient, s);\n        }\n\n      /* The message succeeded. Ensure that the recipients that failed are\n      now marked finished with on the spool and their parents updated. */\n\n      else\n        {\n        for (addr = handled_addr; addr; addr = addr->next)\n          {\n          address_done(addr, logtod);\n          child_done(addr, logtod);\n          }\n        /* Panic-dies on error */\n        (void)spool_write_header(message_id, SW_DELIVERING, NULL);\n        }\n      }\n    }\n  }\n\ndisable_logging = FALSE;  /* In case left set */\n\n/* Come here from the mua_wrapper case if routing goes wrong */\n\nDELIVERY_TIDYUP:\n\n/* If there are now no deferred addresses, we are done. Preserve the\nmessage log if so configured, and we are using them. Otherwise, sling it.\nThen delete the message itself. */\n\nif (!addr_defer)\n  {\n  uschar * fname;\n\n  if (message_logs)\n    {\n    fname = spool_fname(US\"msglog\", message_subdir, id, US\"\");\n    if (preserve_message_logs)\n      {\n      int rc;\n      uschar * moname = spool_fname(US\"msglog.OLD\", US\"\", id, US\"\");\n\n      if ((rc = Urename(fname, moname)) < 0)\n        {\n        (void)directory_make(spool_directory,\n\t\t\t      spool_sname(US\"msglog.OLD\", US\"\"),\n\t\t\t      MSGLOG_DIRECTORY_MODE, TRUE);\n        rc = Urename(fname, moname);\n        }\n      if (rc < 0)\n        log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to move %s to the \"\n          \"msglog.OLD directory\", fname);\n      }\n    else\n      if (Uunlink(fname) < 0)\n        log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to unlink %s: %s\",\n\t\t  fname, strerror(errno));\n    }\n\n  /* Remove the two message files. */\n\n  fname = spool_fname(US\"input\", message_subdir, id, US\"-D\");\n  if (Uunlink(fname) < 0)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to unlink %s: %s\",\n      fname, strerror(errno));\n  fname = spool_fname(US\"input\", message_subdir, id, US\"-H\");\n  if (Uunlink(fname) < 0)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to unlink %s: %s\",\n      fname, strerror(errno));\n\n  /* Log the end of this message, with queue time if requested. */\n\n  if (LOGGING(queue_time_overall))\n    log_write(0, LOG_MAIN, \"Completed QT=%s\", string_timesince(&received_time));\n  else\n    log_write(0, LOG_MAIN, \"Completed\");\n\n  /* Unset deliver_freeze so that we won't try to move the spool files further down */\n  deliver_freeze = FALSE;\n\n#ifndef DISABLE_EVENT\n  (void) event_raise(event_action, US\"msg:complete\", NULL);\n#endif\n  }\n\n/* If there are deferred addresses, we are keeping this message because it is\nnot yet completed. Lose any temporary files that were catching output from\npipes for any of the deferred addresses, handle one-time aliases, and see if\nthe message has been on the queue for so long that it is time to send a warning\nmessage to the sender, unless it is a mailer-daemon. If all deferred addresses\nhave the same domain, we can set deliver_domain for the expansion of\ndelay_warning_ condition - if any of them are pipes, files, or autoreplies, use\nthe parent's domain.\n\nIf all the deferred addresses have an error number that indicates \"retry time\nnot reached\", skip sending the warning message, because it won't contain the\nreason for the delay. It will get sent at the next real delivery attempt.\nHowever, if at least one address has tried, we'd better include all of them in\nthe message.\n\nIf we can't make a process to send the message, don't worry.\n\nFor mailing list expansions we want to send the warning message to the\nmailing list manager. We can't do a perfect job here, as some addresses may\nhave different errors addresses, but if we take the errors address from\neach deferred address it will probably be right in most cases.\n\nIf addr_defer == +1, it means there was a problem sending an error message\nfor failed addresses, and there were no \"real\" deferred addresses. The value\nwas set just to keep the message on the spool, so there is nothing to do here.\n*/\n\nelse if (addr_defer != (address_item *)(+1))\n  {\n  address_item *addr;\n  uschar *recipients = US\"\";\n  BOOL delivery_attempted = FALSE;\n\n  deliver_domain = testflag(addr_defer, af_pfr)\n    ? addr_defer->parent->domain : addr_defer->domain;\n\n  for (addr = addr_defer; addr; addr = addr->next)\n    {\n    address_item *otaddr;\n\n    if (addr->basic_errno > ERRNO_RETRY_BASE) delivery_attempted = TRUE;\n\n    if (deliver_domain)\n      {\n      const uschar *d = testflag(addr, af_pfr)\n\t? addr->parent->domain : addr->domain;\n\n      /* The domain may be unset for an address that has never been routed\n      because the system filter froze the message. */\n\n      if (!d || Ustrcmp(d, deliver_domain) != 0)\n        deliver_domain = NULL;\n      }\n\n    if (addr->return_filename) Uunlink(addr->return_filename);\n\n    /* Handle the case of one-time aliases. If any address in the ancestry\n    of this one is flagged, ensure it is in the recipients list, suitably\n    flagged, and that its parent is marked delivered. */\n\n    for (otaddr = addr; otaddr; otaddr = otaddr->parent)\n      if (otaddr->onetime_parent) break;\n\n    if (otaddr)\n      {\n      int i;\n      int t = recipients_count;\n\n      for (i = 0; i < recipients_count; i++)\n        {\n        uschar *r = recipients_list[i].address;\n        if (Ustrcmp(otaddr->onetime_parent, r) == 0) t = i;\n        if (Ustrcmp(otaddr->address, r) == 0) break;\n        }\n\n      /* Didn't find the address already in the list, and did find the\n      ultimate parent's address in the list, and they really are different\n      (i.e. not from an identity-redirect). After adding the recipient,\n      update the errors address in the recipients list. */\n\n      if (  i >= recipients_count && t < recipients_count\n         && Ustrcmp(otaddr->address, otaddr->parent->address) != 0)\n        {\n        DEBUG(D_deliver) debug_printf(\"one_time: adding %s in place of %s\\n\",\n          otaddr->address, otaddr->parent->address);\n        receive_add_recipient(otaddr->address, t);\n        recipients_list[recipients_count-1].errors_to = otaddr->prop.errors_address;\n        tree_add_nonrecipient(otaddr->parent->address);\n        update_spool = TRUE;\n        }\n      }\n\n    /* Except for error messages, ensure that either the errors address for\n    this deferred address or, if there is none, the sender address, is on the\n    list of recipients for a warning message. */\n\n    if (sender_address[0])\n      {\n      uschar * s = addr->prop.errors_address;\n      if (!s) s = sender_address;\n      if (Ustrstr(recipients, s) == NULL)\n\trecipients = string_sprintf(\"%s%s%s\", recipients,\n\t  recipients[0] ? \",\" : \"\", s);\n      }\n    }\n\n  /* Send a warning message if the conditions are right. If the condition check\n  fails because of a lookup defer, there is nothing we can do. The warning\n  is not sent. Another attempt will be made at the next delivery attempt (if\n  it also defers). */\n\n  if (  !queue_2stage\n     && delivery_attempted\n     && (  ((addr_defer->dsn_flags & rf_dsnflags) == 0)\n        || (addr_defer->dsn_flags & rf_notify_delay) == rf_notify_delay\n\t)\n     && delay_warning[1] > 0\n     && sender_address[0] != 0\n     && (  !delay_warning_condition\n        || expand_check_condition(delay_warning_condition,\n            US\"delay_warning\", US\"option\")\n\t)\n     )\n    {\n    int count;\n    int show_time;\n    int queue_time = time(NULL) - received_time.tv_sec;\n\n    /* When running in the test harness, there's an option that allows us to\n    fudge this time so as to get repeatability of the tests. Take the first\n    time off the list. In queue runs, the list pointer gets updated in the\n    calling process. */\n\n    if (running_in_test_harness && fudged_queue_times[0] != 0)\n      {\n      int qt = readconf_readtime(fudged_queue_times, '/', FALSE);\n      if (qt >= 0)\n        {\n        DEBUG(D_deliver) debug_printf(\"fudged queue_times = %s\\n\",\n          fudged_queue_times);\n        queue_time = qt;\n        }\n      }\n\n    /* See how many warnings we should have sent by now */\n\n    for (count = 0; count < delay_warning[1]; count++)\n      if (queue_time < delay_warning[count+2]) break;\n\n    show_time = delay_warning[count+1];\n\n    if (count >= delay_warning[1])\n      {\n      int extra;\n      int last_gap = show_time;\n      if (count > 1) last_gap -= delay_warning[count];\n      extra = (queue_time - delay_warning[count+1])/last_gap;\n      show_time += last_gap * extra;\n      count += extra;\n      }\n\n    DEBUG(D_deliver)\n      {\n      debug_printf(\"time on queue = %s\\n\", readconf_printtime(queue_time));\n      debug_printf(\"warning counts: required %d done %d\\n\", count,\n        warning_count);\n      }\n\n    /* We have computed the number of warnings there should have been by now.\n    If there haven't been enough, send one, and up the count to what it should\n    have been. */\n\n    if (warning_count < count)\n      {\n      header_line *h;\n      int fd;\n      pid_t pid = child_open_exim(&fd);\n\n      if (pid > 0)\n        {\n        uschar *wmf_text;\n        FILE *wmf = NULL;\n        FILE *f = fdopen(fd, \"wb\");\n\tuschar * bound;\n\ttransport_ctx tctx = {{0}};\n\n        if (warn_message_file)\n          if (!(wmf = Ufopen(warn_message_file, \"rb\")))\n            log_write(0, LOG_MAIN|LOG_PANIC, \"Failed to open %s for warning \"\n              \"message texts: %s\", warn_message_file, strerror(errno));\n\n        warnmsg_recipients = recipients;\n        warnmsg_delay = queue_time < 120*60\n\t  ? string_sprintf(\"%d minutes\", show_time/60)\n\t  : string_sprintf(\"%d hours\", show_time/3600);\n\n        if (errors_reply_to)\n          fprintf(f, \"Reply-To: %s\\n\", errors_reply_to);\n        fprintf(f, \"Auto-Submitted: auto-replied\\n\");\n        moan_write_from(f);\n        fprintf(f, \"To: %s\\n\", recipients);\n\n        /* generated boundary string and output MIME-Headers */\n        bound = string_sprintf(TIME_T_FMT \"-eximdsn-%d\", time(NULL), rand());\n\n        fprintf(f, \"Content-Type: multipart/report;\"\n\t    \" report-type=delivery-status; boundary=%s\\n\"\n\t    \"MIME-Version: 1.0\\n\",\n\t  bound);\n\n        if ((wmf_text = next_emf(wmf, US\"header\")))\n          fprintf(f, \"%s\\n\", wmf_text);\n        else\n          fprintf(f, \"Subject: Warning: message %s delayed %s\\n\\n\",\n            message_id, warnmsg_delay);\n\n        /* output human readable part as text/plain section */\n        fprintf(f, \"--%s\\n\"\n\t    \"Content-type: text/plain; charset=us-ascii\\n\\n\",\n\t  bound);\n\n        if ((wmf_text = next_emf(wmf, US\"intro\")))\n\t  fprintf(f, \"%s\", CS wmf_text);\n\telse\n          {\n          fprintf(f,\n\"This message was created automatically by mail delivery software.\\n\");\n\n          if (Ustrcmp(recipients, sender_address) == 0)\n            fprintf(f,\n\"A message that you sent has not yet been delivered to one or more of its\\n\"\n\"recipients after more than \");\n\n          else\n\t    fprintf(f,\n\"A message sent by\\n\\n  <%s>\\n\\n\"\n\"has not yet been delivered to one or more of its recipients after more than \\n\",\n\t      sender_address);\n\n          fprintf(f, \"%s on the queue on %s.\\n\\n\"\n\t      \"The message identifier is:     %s\\n\",\n\t    warnmsg_delay, primary_hostname, message_id);\n\n          for (h = header_list; h; h = h->next)\n            if (strncmpic(h->text, US\"Subject:\", 8) == 0)\n              fprintf(f, \"The subject of the message is: %s\", h->text + 9);\n            else if (strncmpic(h->text, US\"Date:\", 5) == 0)\n              fprintf(f, \"The date of the message is:    %s\", h->text + 6);\n          fputc('\\n', f);\n\n          fprintf(f, \"The address%s to which the message has not yet been \"\n            \"delivered %s:\\n\",\n            !addr_defer->next ? \"\" : \"es\",\n            !addr_defer->next ? \"is\": \"are\");\n          }\n\n        /* List the addresses, with error information if allowed */\n\n        /* store addr_defer for machine readable part */\n        address_item *addr_dsndefer = addr_defer;\n        fputc('\\n', f);\n        while (addr_defer)\n          {\n          address_item *addr = addr_defer;\n          addr_defer = addr->next;\n          if (print_address_information(addr, f, US\"  \", US\"\\n    \", US\"\"))\n            print_address_error(addr, f, US\"Delay reason: \");\n          fputc('\\n', f);\n          }\n        fputc('\\n', f);\n\n        /* Final text */\n\n        if (wmf)\n          {\n          if ((wmf_text = next_emf(wmf, US\"final\")))\n\t    fprintf(f, \"%s\", CS wmf_text);\n          (void)fclose(wmf);\n          }\n        else\n          {\n          fprintf(f,\n\"No action is required on your part. Delivery attempts will continue for\\n\"\n\"some time, and this warning may be repeated at intervals if the message\\n\"\n\"remains undelivered. Eventually the mail delivery software will give up,\\n\"\n\"and when that happens, the message will be returned to you.\\n\");\n          }\n\n        /* output machine readable part */\n        fprintf(f, \"\\n--%s\\n\"\n\t    \"Content-type: message/delivery-status\\n\\n\"\n\t    \"Reporting-MTA: dns; %s\\n\",\n\t  bound,\n\t  smtp_active_hostname);\n\n\n        if (dsn_envid)\n\t  {\n          /* must be decoded from xtext: see RFC 3461:6.3a */\n          uschar *xdec_envid;\n          if (auth_xtextdecode(dsn_envid, &xdec_envid) > 0)\n            fprintf(f,\"Original-Envelope-ID: %s\\n\", dsn_envid);\n          else\n            fprintf(f,\"X-Original-Envelope-ID: error decoding xtext formatted ENVID\\n\");\n          }\n        fputc('\\n', f);\n\n        for ( ; addr_dsndefer; addr_dsndefer = addr_dsndefer->next)\n          {\n          if (addr_dsndefer->dsn_orcpt)\n            fprintf(f, \"Original-Recipient: %s\\n\", addr_dsndefer->dsn_orcpt);\n\n          fprintf(f, \"Action: delayed\\n\"\n\t      \"Final-Recipient: rfc822;%s\\n\"\n\t      \"Status: 4.0.0\\n\",\n\t    addr_dsndefer->address);\n          if (addr_dsndefer->host_used && addr_dsndefer->host_used->name)\n            {\n            fprintf(f, \"Remote-MTA: dns; %s\\n\",\n\t\t    addr_dsndefer->host_used->name);\n            print_dsn_diagnostic_code(addr_dsndefer, f);\n            }\n\t  fputc('\\n', f);\n          }\n\n        fprintf(f, \"--%s\\n\"\n\t    \"Content-type: text/rfc822-headers\\n\\n\",\n\t  bound);\n\n        fflush(f);\n        /* header only as required by RFC. only failure DSN needs to honor RET=FULL */\n\ttctx.u.fd = fileno(f);\n        tctx.options = topt_add_return_path | topt_no_body;\n        transport_filter_argv = NULL;   /* Just in case */\n        return_path = sender_address;   /* In case not previously set */\n\n        /* Write the original email out */\n        transport_write_message(&tctx, 0);\n        fflush(f);\n\n        fprintf(f,\"\\n--%s--\\n\", bound);\n\n        fflush(f);\n\n        /* Close and wait for child process to complete, without a timeout.\n        If there's an error, don't update the count. */\n\n        (void)fclose(f);\n        if (child_close(pid, 0) == 0)\n          {\n          warning_count = count;\n          update_spool = TRUE;    /* Ensure spool rewritten */\n          }\n        }\n      }\n    }\n\n  /* Clear deliver_domain */\n\n  deliver_domain = NULL;\n\n  /* If this was a first delivery attempt, unset the first time flag, and\n  ensure that the spool gets updated. */\n\n  if (deliver_firsttime)\n    {\n    deliver_firsttime = FALSE;\n    update_spool = TRUE;\n    }\n\n  /* If delivery was frozen and freeze_tell is set, generate an appropriate\n  message, unless the message is a local error message (to avoid loops). Then\n  log the freezing. If the text in \"frozen_info\" came from a system filter,\n  it has been escaped into printing characters so as not to mess up log lines.\n  For the \"tell\" message, we turn \\n back into newline. Also, insert a newline\n  near the start instead of the \": \" string. */\n\n  if (deliver_freeze)\n    {\n    if (freeze_tell && freeze_tell[0] != 0 && !local_error_message)\n      {\n      uschar *s = string_copy(frozen_info);\n      uschar *ss = Ustrstr(s, \" by the system filter: \");\n\n      if (ss != NULL)\n        {\n        ss[21] = '.';\n        ss[22] = '\\n';\n        }\n\n      ss = s;\n      while (*ss != 0)\n        {\n        if (*ss == '\\\\' && ss[1] == 'n')\n          {\n          *ss++ = ' ';\n          *ss++ = '\\n';\n          }\n        else ss++;\n        }\n      moan_tell_someone(freeze_tell, addr_defer, US\"Message frozen\",\n        \"Message %s has been frozen%s.\\nThe sender is <%s>.\\n\", message_id,\n        s, sender_address);\n      }\n\n    /* Log freezing just before we update the -H file, to minimize the chance\n    of a race problem. */\n\n    deliver_msglog(\"*** Frozen%s\\n\", frozen_info);\n    log_write(0, LOG_MAIN, \"Frozen%s\", frozen_info);\n    }\n\n  /* If there have been any updates to the non-recipients list, or other things\n  that get written to the spool, we must now update the spool header file so\n  that it has the right information for the next delivery attempt. If there\n  was more than one address being delivered, the header_change update is done\n  earlier, in case one succeeds and then something crashes. */\n\n  DEBUG(D_deliver)\n    debug_printf(\"delivery deferred: update_spool=%d header_rewritten=%d\\n\",\n      update_spool, header_rewritten);\n\n  if (update_spool || header_rewritten)\n    /* Panic-dies on error */\n    (void)spool_write_header(message_id, SW_DELIVERING, NULL);\n  }\n\n/* Finished with the message log. If the message is complete, it will have\nbeen unlinked or renamed above. */\n\nif (message_logs) (void)fclose(message_log);\n\n/* Now we can close and remove the journal file. Its only purpose is to record\nsuccessfully completed deliveries asap so that this information doesn't get\nlost if Exim (or the machine) crashes. Forgetting about a failed delivery is\nnot serious, as trying it again is not harmful. The journal might not be open\nif all addresses were deferred at routing or directing. Nevertheless, we must\nremove it if it exists (may have been lying around from a crash during the\nprevious delivery attempt). We don't remove the journal if a delivery\nsubprocess failed to pass back delivery information; this is controlled by\nthe remove_journal flag. When the journal is left, we also don't move the\nmessage off the main spool if frozen and the option is set. It should get moved\nat the next attempt, after the journal has been inspected. */\n\nif (journal_fd >= 0) (void)close(journal_fd);\n\nif (remove_journal)\n  {\n  uschar * fname = spool_fname(US\"input\", message_subdir, id, US\"-J\");\n\n  if (Uunlink(fname) < 0 && errno != ENOENT)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to unlink %s: %s\", fname,\n      strerror(errno));\n\n  /* Move the message off the spool if requested */\n\n#ifdef SUPPORT_MOVE_FROZEN_MESSAGES\n  if (deliver_freeze && move_frozen_messages)\n    (void)spool_move_message(id, message_subdir, US\"\", US\"F\");\n#endif\n  }\n\n/* Closing the data file frees the lock; if the file has been unlinked it\nwill go away. Otherwise the message becomes available for another process\nto try delivery. */\n\n(void)close(deliver_datafile);\ndeliver_datafile = -1;\nDEBUG(D_deliver) debug_printf(\"end delivery of %s\\n\", id);\n\n/* It is unlikely that there will be any cached resources, since they are\nreleased after routing, and in the delivery subprocesses. However, it's\npossible for an expansion for something afterwards (for example,\nexpand_check_condition) to do a lookup. We must therefore be sure everything is\nreleased. */\n\nsearch_tidyup();\nacl_where = ACL_WHERE_UNKNOWN;\nreturn final_yield;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146459,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "void nsexec(void)\n{\n\tint pipenum;\n\tjmp_buf env;\n\tint sync_child_pipe[2], sync_grandchild_pipe[2];\n\tstruct nlconfig_t config = { 0 };\n\n\t/*\n\t * If we don't have an init pipe, just return to the go routine.\n\t * We'll only get an init pipe for start or exec.\n\t */\n\tpipenum = initpipe();\n\tif (pipenum == -1)\n\t\treturn;\n\n\t/* Parse all of the netlink configuration. */\n\tnl_parse(pipenum, &config);\n\n\t/* Set oom_score_adj. This has to be done before !dumpable because\n\t * /proc/self/oom_score_adj is not writeable unless you're an privileged\n\t * user (if !dumpable is set). All children inherit their parent's\n\t * oom_score_adj value on fork(2) so this will always be propagated\n\t * properly.\n\t */\n\tupdate_oom_score_adj(config.oom_score_adj, config.oom_score_adj_len);\n\n\t/*\n\t * Make the process non-dumpable, to avoid various race conditions that\n\t * could cause processes in namespaces we're joining to access host\n\t * resources (or potentially execute code).\n\t *\n\t * However, if the number of namespaces we are joining is 0, we are not\n\t * going to be switching to a different security context. Thus setting\n\t * ourselves to be non-dumpable only breaks things (like rootless\n\t * containers), which is the recommendation from the kernel folks.\n\t */\n\tif (config.namespaces) {\n\t\tif (prctl(PR_SET_DUMPABLE, 0, 0, 0, 0) < 0)\n\t\t\tbail(\"failed to set process as non-dumpable\");\n\t}\n\n\t/* Pipe so we can tell the child when we've finished setting up. */\n\tif (socketpair(AF_LOCAL, SOCK_STREAM, 0, sync_child_pipe) < 0)\n\t\tbail(\"failed to setup sync pipe between parent and child\");\n\n\t/*\n\t * We need a new socketpair to sync with grandchild so we don't have\n\t * race condition with child.\n\t */\n\tif (socketpair(AF_LOCAL, SOCK_STREAM, 0, sync_grandchild_pipe) < 0)\n\t\tbail(\"failed to setup sync pipe between parent and grandchild\");\n\n\t/* TODO: Currently we aren't dealing with child deaths properly. */\n\n\t/*\n\t * Okay, so this is quite annoying.\n\t *\n\t * In order for this unsharing code to be more extensible we need to split\n\t * up unshare(CLONE_NEWUSER) and clone() in various ways. The ideal case\n\t * would be if we did clone(CLONE_NEWUSER) and the other namespaces\n\t * separately, but because of SELinux issues we cannot really do that. But\n\t * we cannot just dump the namespace flags into clone(...) because several\n\t * usecases (such as rootless containers) require more granularity around\n\t * the namespace setup. In addition, some older kernels had issues where\n\t * CLONE_NEWUSER wasn't handled before other namespaces (but we cannot\n\t * handle this while also dealing with SELinux so we choose SELinux support\n\t * over broken kernel support).\n\t *\n\t * However, if we unshare(2) the user namespace *before* we clone(2), then\n\t * all hell breaks loose.\n\t *\n\t * The parent no longer has permissions to do many things (unshare(2) drops\n\t * all capabilities in your old namespace), and the container cannot be set\n\t * up to have more than one {uid,gid} mapping. This is obviously less than\n\t * ideal. In order to fix this, we have to first clone(2) and then unshare.\n\t *\n\t * Unfortunately, it's not as simple as that. We have to fork to enter the\n\t * PID namespace (the PID namespace only applies to children). Since we'll\n\t * have to double-fork, this clone_parent() call won't be able to get the\n\t * PID of the _actual_ init process (without doing more synchronisation than\n\t * I can deal with at the moment). So we'll just get the parent to send it\n\t * for us, the only job of this process is to update\n\t * /proc/pid/{setgroups,uid_map,gid_map}.\n\t *\n\t * And as a result of the above, we also need to setns(2) in the first child\n\t * because if we join a PID namespace in the topmost parent then our child\n\t * will be in that namespace (and it will not be able to give us a PID value\n\t * that makes sense without resorting to sending things with cmsg).\n\t *\n\t * This also deals with an older issue caused by dumping cloneflags into\n\t * clone(2): On old kernels, CLONE_PARENT didn't work with CLONE_NEWPID, so\n\t * we have to unshare(2) before clone(2) in order to do this. This was fixed\n\t * in upstream commit 1f7f4dde5c945f41a7abc2285be43d918029ecc5, and was\n\t * introduced by 40a0d32d1eaffe6aac7324ca92604b6b3977eb0e. As far as we're\n\t * aware, the last mainline kernel which had this bug was Linux 3.12.\n\t * However, we cannot comment on which kernels the broken patch was\n\t * backported to.\n\t *\n\t * -- Aleksa \"what has my life come to?\" Sarai\n\t */\n\n\tswitch (setjmp(env)) {\n\t\t/*\n\t\t * Stage 0: We're in the parent. Our job is just to create a new child\n\t\t *          (stage 1: JUMP_CHILD) process and write its uid_map and\n\t\t *          gid_map. That process will go on to create a new process, then\n\t\t *          it will send us its PID which we will send to the bootstrap\n\t\t *          process.\n\t\t */\n\tcase JUMP_PARENT:{\n\t\t\tint len;\n\t\t\tpid_t child, first_child = -1;\n\t\t\tbool ready = false;\n\n\t\t\t/* For debugging. */\n\t\t\tprctl(PR_SET_NAME, (unsigned long)\"runc:[0:PARENT]\", 0, 0, 0);\n\n\t\t\t/* Start the process of getting a container. */\n\t\t\tchild = clone_parent(&env, JUMP_CHILD);\n\t\t\tif (child < 0)\n\t\t\t\tbail(\"unable to fork: child_func\");\n\n\t\t\t/*\n\t\t\t * State machine for synchronisation with the children.\n\t\t\t *\n\t\t\t * Father only return when both child and grandchild are\n\t\t\t * ready, so we can receive all possible error codes\n\t\t\t * generated by children.\n\t\t\t */\n\t\t\twhile (!ready) {\n\t\t\t\tenum sync_t s;\n\t\t\t\tint ret;\n\n\t\t\t\tsyncfd = sync_child_pipe[1];\n\t\t\t\tclose(sync_child_pipe[0]);\n\n\t\t\t\tif (read(syncfd, &s, sizeof(s)) != sizeof(s))\n\t\t\t\t\tbail(\"failed to sync with child: next state\");\n\n\t\t\t\tswitch (s) {\n\t\t\t\tcase SYNC_ERR:\n\t\t\t\t\t/* We have to mirror the error code of the child. */\n\t\t\t\t\tif (read(syncfd, &ret, sizeof(ret)) != sizeof(ret))\n\t\t\t\t\t\tbail(\"failed to sync with child: read(error code)\");\n\n\t\t\t\t\texit(ret);\n\t\t\t\tcase SYNC_USERMAP_PLS:\n\t\t\t\t\t/*\n\t\t\t\t\t * Enable setgroups(2) if we've been asked to. But we also\n\t\t\t\t\t * have to explicitly disable setgroups(2) if we're\n\t\t\t\t\t * creating a rootless container for single-entry mapping.\n\t\t\t\t\t * i.e. config.is_setgroup == false.\n\t\t\t\t\t * (this is required since Linux 3.19).\n\t\t\t\t\t *\n\t\t\t\t\t * For rootless multi-entry mapping, config.is_setgroup shall be true and\n\t\t\t\t\t * newuidmap/newgidmap shall be used.\n\t\t\t\t\t */\n\n\t\t\t\t\tif (config.is_rootless_euid && !config.is_setgroup)\n\t\t\t\t\t\tupdate_setgroups(child, SETGROUPS_DENY);\n\n\t\t\t\t\t/* Set up mappings. */\n\t\t\t\t\tupdate_uidmap(config.uidmappath, child, config.uidmap, config.uidmap_len);\n\t\t\t\t\tupdate_gidmap(config.gidmappath, child, config.gidmap, config.gidmap_len);\n\n\t\t\t\t\ts = SYNC_USERMAP_ACK;\n\t\t\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s)) {\n\t\t\t\t\t\tkill(child, SIGKILL);\n\t\t\t\t\t\tbail(\"failed to sync with child: write(SYNC_USERMAP_ACK)\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase SYNC_RECVPID_PLS:{\n\t\t\t\t\t\tfirst_child = child;\n\n\t\t\t\t\t\t/* Get the init_func pid. */\n\t\t\t\t\t\tif (read(syncfd, &child, sizeof(child)) != sizeof(child)) {\n\t\t\t\t\t\t\tkill(first_child, SIGKILL);\n\t\t\t\t\t\t\tbail(\"failed to sync with child: read(childpid)\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* Send ACK. */\n\t\t\t\t\t\ts = SYNC_RECVPID_ACK;\n\t\t\t\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s)) {\n\t\t\t\t\t\t\tkill(first_child, SIGKILL);\n\t\t\t\t\t\t\tkill(child, SIGKILL);\n\t\t\t\t\t\t\tbail(\"failed to sync with child: write(SYNC_RECVPID_ACK)\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* Send the init_func pid back to our parent.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * Send the init_func pid and the pid of the first child back to our parent.\n\t\t\t\t\t\t * We need to send both back because we can't reap the first child we created (CLONE_PARENT).\n\t\t\t\t\t\t * It becomes the responsibility of our parent to reap the first child.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tlen = dprintf(pipenum, \"{\\\"pid\\\": %d, \\\"pid_first\\\": %d}\\n\", child, first_child);\n\t\t\t\t\t\tif (len < 0) {\n\t\t\t\t\t\t\tkill(child, SIGKILL);\n\t\t\t\t\t\t\tbail(\"unable to generate JSON for child pid\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase SYNC_CHILD_READY:\n\t\t\t\t\tready = true;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbail(\"unexpected sync value: %u\", s);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Now sync with grandchild. */\n\n\t\t\tready = false;\n\t\t\twhile (!ready) {\n\t\t\t\tenum sync_t s;\n\t\t\t\tint ret;\n\n\t\t\t\tsyncfd = sync_grandchild_pipe[1];\n\t\t\t\tclose(sync_grandchild_pipe[0]);\n\n\t\t\t\ts = SYNC_GRANDCHILD;\n\t\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s)) {\n\t\t\t\t\tkill(child, SIGKILL);\n\t\t\t\t\tbail(\"failed to sync with child: write(SYNC_GRANDCHILD)\");\n\t\t\t\t}\n\n\t\t\t\tif (read(syncfd, &s, sizeof(s)) != sizeof(s))\n\t\t\t\t\tbail(\"failed to sync with child: next state\");\n\n\t\t\t\tswitch (s) {\n\t\t\t\tcase SYNC_ERR:\n\t\t\t\t\t/* We have to mirror the error code of the child. */\n\t\t\t\t\tif (read(syncfd, &ret, sizeof(ret)) != sizeof(ret))\n\t\t\t\t\t\tbail(\"failed to sync with child: read(error code)\");\n\n\t\t\t\t\texit(ret);\n\t\t\t\tcase SYNC_CHILD_READY:\n\t\t\t\t\tready = true;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbail(\"unexpected sync value: %u\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\texit(0);\n\t\t}\n\n\t\t/*\n\t\t * Stage 1: We're in the first child process. Our job is to join any\n\t\t *          provided namespaces in the netlink payload and unshare all\n\t\t *          of the requested namespaces. If we've been asked to\n\t\t *          CLONE_NEWUSER, we will ask our parent (stage 0) to set up\n\t\t *          our user mappings for us. Then, we create a new child\n\t\t *          (stage 2: JUMP_INIT) for PID namespace. We then send the\n\t\t *          child's PID to our parent (stage 0).\n\t\t */\n\tcase JUMP_CHILD:{\n\t\t\tpid_t child;\n\t\t\tenum sync_t s;\n\n\t\t\t/* We're in a child and thus need to tell the parent if we die. */\n\t\t\tsyncfd = sync_child_pipe[0];\n\t\t\tclose(sync_child_pipe[1]);\n\n\t\t\t/* For debugging. */\n\t\t\tprctl(PR_SET_NAME, (unsigned long)\"runc:[1:CHILD]\", 0, 0, 0);\n\n\t\t\t/*\n\t\t\t * We need to setns first. We cannot do this earlier (in stage 0)\n\t\t\t * because of the fact that we forked to get here (the PID of\n\t\t\t * [stage 2: JUMP_INIT]) would be meaningless). We could send it\n\t\t\t * using cmsg(3) but that's just annoying.\n\t\t\t */\n\t\t\tif (config.namespaces)\n\t\t\t\tjoin_namespaces(config.namespaces);\n\n\t\t\t/*\n\t\t\t * Deal with user namespaces first. They are quite special, as they\n\t\t\t * affect our ability to unshare other namespaces and are used as\n\t\t\t * context for privilege checks.\n\t\t\t *\n\t\t\t * We don't unshare all namespaces in one go. The reason for this\n\t\t\t * is that, while the kernel documentation may claim otherwise,\n\t\t\t * there are certain cases where unsharing all namespaces at once\n\t\t\t * will result in namespace objects being owned incorrectly.\n\t\t\t * Ideally we should just fix these kernel bugs, but it's better to\n\t\t\t * be safe than sorry, and fix them separately.\n\t\t\t *\n\t\t\t * A specific case of this is that the SELinux label of the\n\t\t\t * internal kern-mount that mqueue uses will be incorrect if the\n\t\t\t * UTS namespace is cloned before the USER namespace is mapped.\n\t\t\t * I've also heard of similar problems with the network namespace\n\t\t\t * in some scenarios. This also mirrors how LXC deals with this\n\t\t\t * problem.\n\t\t\t */\n\t\t\tif (config.cloneflags & CLONE_NEWUSER) {\n\t\t\t\tif (unshare(CLONE_NEWUSER) < 0)\n\t\t\t\t\tbail(\"failed to unshare user namespace\");\n\t\t\t\tconfig.cloneflags &= ~CLONE_NEWUSER;\n\n\t\t\t\t/*\n\t\t\t\t * We don't have the privileges to do any mapping here (see the\n\t\t\t\t * clone_parent rant). So signal our parent to hook us up.\n\t\t\t\t */\n\n\t\t\t\t/* Switching is only necessary if we joined namespaces. */\n\t\t\t\tif (config.namespaces) {\n\t\t\t\t\tif (prctl(PR_SET_DUMPABLE, 1, 0, 0, 0) < 0)\n\t\t\t\t\t\tbail(\"failed to set process as dumpable\");\n\t\t\t\t}\n\t\t\t\ts = SYNC_USERMAP_PLS;\n\t\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s))\n\t\t\t\t\tbail(\"failed to sync with parent: write(SYNC_USERMAP_PLS)\");\n\n\t\t\t\t/* ... wait for mapping ... */\n\n\t\t\t\tif (read(syncfd, &s, sizeof(s)) != sizeof(s))\n\t\t\t\t\tbail(\"failed to sync with parent: read(SYNC_USERMAP_ACK)\");\n\t\t\t\tif (s != SYNC_USERMAP_ACK)\n\t\t\t\t\tbail(\"failed to sync with parent: SYNC_USERMAP_ACK: got %u\", s);\n\t\t\t\t/* Switching is only necessary if we joined namespaces. */\n\t\t\t\tif (config.namespaces) {\n\t\t\t\t\tif (prctl(PR_SET_DUMPABLE, 0, 0, 0, 0) < 0)\n\t\t\t\t\t\tbail(\"failed to set process as dumpable\");\n\t\t\t\t}\n\n\t\t\t\t/* Become root in the namespace proper. */\n\t\t\t\tif (setresuid(0, 0, 0) < 0)\n\t\t\t\t\tbail(\"failed to become root in user namespace\");\n\t\t\t}\n\t\t\t/*\n\t\t\t * Unshare all of the namespaces. Now, it should be noted that this\n\t\t\t * ordering might break in the future (especially with rootless\n\t\t\t * containers). But for now, it's not possible to split this into\n\t\t\t * CLONE_NEWUSER + [the rest] because of some RHEL SELinux issues.\n\t\t\t *\n\t\t\t * Note that we don't merge this with clone() because there were\n\t\t\t * some old kernel versions where clone(CLONE_PARENT | CLONE_NEWPID)\n\t\t\t * was broken, so we'll just do it the long way anyway.\n\t\t\t */\n\t\t\tif (unshare(config.cloneflags & ~CLONE_NEWCGROUP) < 0)\n\t\t\t\tbail(\"failed to unshare namespaces\");\n\n\t\t\t/*\n\t\t\t * TODO: What about non-namespace clone flags that we're dropping here?\n\t\t\t *\n\t\t\t * We fork again because of PID namespace, setns(2) or unshare(2) don't\n\t\t\t * change the PID namespace of the calling process, because doing so\n\t\t\t * would change the caller's idea of its own PID (as reported by getpid()),\n\t\t\t * which would break many applications and libraries, so we must fork\n\t\t\t * to actually enter the new PID namespace.\n\t\t\t */\n\t\t\tchild = clone_parent(&env, JUMP_INIT);\n\t\t\tif (child < 0)\n\t\t\t\tbail(\"unable to fork: init_func\");\n\n\t\t\t/* Send the child to our parent, which knows what it's doing. */\n\t\t\ts = SYNC_RECVPID_PLS;\n\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s)) {\n\t\t\t\tkill(child, SIGKILL);\n\t\t\t\tbail(\"failed to sync with parent: write(SYNC_RECVPID_PLS)\");\n\t\t\t}\n\t\t\tif (write(syncfd, &child, sizeof(child)) != sizeof(child)) {\n\t\t\t\tkill(child, SIGKILL);\n\t\t\t\tbail(\"failed to sync with parent: write(childpid)\");\n\t\t\t}\n\n\t\t\t/* ... wait for parent to get the pid ... */\n\n\t\t\tif (read(syncfd, &s, sizeof(s)) != sizeof(s)) {\n\t\t\t\tkill(child, SIGKILL);\n\t\t\t\tbail(\"failed to sync with parent: read(SYNC_RECVPID_ACK)\");\n\t\t\t}\n\t\t\tif (s != SYNC_RECVPID_ACK) {\n\t\t\t\tkill(child, SIGKILL);\n\t\t\t\tbail(\"failed to sync with parent: SYNC_RECVPID_ACK: got %u\", s);\n\t\t\t}\n\n\t\t\ts = SYNC_CHILD_READY;\n\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s)) {\n\t\t\t\tkill(child, SIGKILL);\n\t\t\t\tbail(\"failed to sync with parent: write(SYNC_CHILD_READY)\");\n\t\t\t}\n\n\t\t\t/* Our work is done. [Stage 2: JUMP_INIT] is doing the rest of the work. */\n\t\t\texit(0);\n\t\t}\n\n\t\t/*\n\t\t * Stage 2: We're the final child process, and the only process that will\n\t\t *          actually return to the Go runtime. Our job is to just do the\n\t\t *          final cleanup steps and then return to the Go runtime to allow\n\t\t *          init_linux.go to run.\n\t\t */\n\tcase JUMP_INIT:{\n\t\t\t/*\n\t\t\t * We're inside the child now, having jumped from the\n\t\t\t * start_child() code after forking in the parent.\n\t\t\t */\n\t\t\tenum sync_t s;\n\n\t\t\t/* We're in a child and thus need to tell the parent if we die. */\n\t\t\tsyncfd = sync_grandchild_pipe[0];\n\t\t\tclose(sync_grandchild_pipe[1]);\n\t\t\tclose(sync_child_pipe[0]);\n\t\t\tclose(sync_child_pipe[1]);\n\n\t\t\t/* For debugging. */\n\t\t\tprctl(PR_SET_NAME, (unsigned long)\"runc:[2:INIT]\", 0, 0, 0);\n\n\t\t\tif (read(syncfd, &s, sizeof(s)) != sizeof(s))\n\t\t\t\tbail(\"failed to sync with parent: read(SYNC_GRANDCHILD)\");\n\t\t\tif (s != SYNC_GRANDCHILD)\n\t\t\t\tbail(\"failed to sync with parent: SYNC_GRANDCHILD: got %u\", s);\n\n\t\t\tif (setsid() < 0)\n\t\t\t\tbail(\"setsid failed\");\n\n\t\t\tif (setuid(0) < 0)\n\t\t\t\tbail(\"setuid failed\");\n\n\t\t\tif (setgid(0) < 0)\n\t\t\t\tbail(\"setgid failed\");\n\n\t\t\tif (!config.is_rootless_euid && config.is_setgroup) {\n\t\t\t\tif (setgroups(0, NULL) < 0)\n\t\t\t\t\tbail(\"setgroups failed\");\n\t\t\t}\n\n\t\t\t/* ... wait until our topmost parent has finished cgroup setup in p.manager.Apply() ... */\n\t\t\tif (config.cloneflags & CLONE_NEWCGROUP) {\n\t\t\t\tuint8_t value;\n\t\t\t\tif (read(pipenum, &value, sizeof(value)) != sizeof(value))\n\t\t\t\t\tbail(\"read synchronisation value failed\");\n\t\t\t\tif (value == CREATECGROUPNS) {\n\t\t\t\t\tif (unshare(CLONE_NEWCGROUP) < 0)\n\t\t\t\t\t\tbail(\"failed to unshare cgroup namespace\");\n\t\t\t\t} else\n\t\t\t\t\tbail(\"received unknown synchronisation value\");\n\t\t\t}\n\n\t\t\ts = SYNC_CHILD_READY;\n\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s))\n\t\t\t\tbail(\"failed to sync with patent: write(SYNC_CHILD_READY)\");\n\n\t\t\t/* Close sync pipes. */\n\t\t\tclose(sync_grandchild_pipe[0]);\n\n\t\t\t/* Free netlink data. */\n\t\t\tnl_free(&config);\n\n\t\t\t/* Finish executing, let the Go runtime take over. */\n\t\t\treturn;\n\t\t}\n\tdefault:\n\t\tbail(\"unexpected jump value\");\n\t}\n\n\t/* Should never be reached. */\n\tbail(\"should never be reached\");\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146664,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "void nsexec(void)\n{\n\tint pipenum;\n\tjmp_buf env;\n\tint sync_child_pipe[2], sync_grandchild_pipe[2];\n\tstruct nlconfig_t config = { 0 };\n\n\t/*\n\t * If we don't have an init pipe, just return to the go routine.\n\t * We'll only get an init pipe for start or exec.\n\t */\n\tpipenum = initpipe();\n\tif (pipenum == -1)\n\t\treturn;\n\n\t/*\n\t * We need to re-exec if we are not in a cloned binary. This is necessary\n\t * to ensure that containers won't be able to access the host binary\n\t * through /proc/self/exe. See CVE-2019-5736.\n\t */\n\tif (ensure_cloned_binary() < 0)\n\t\tbail(\"could not ensure we are a cloned binary\");\n\n\t/* Parse all of the netlink configuration. */\n\tnl_parse(pipenum, &config);\n\n\t/* Set oom_score_adj. This has to be done before !dumpable because\n\t * /proc/self/oom_score_adj is not writeable unless you're an privileged\n\t * user (if !dumpable is set). All children inherit their parent's\n\t * oom_score_adj value on fork(2) so this will always be propagated\n\t * properly.\n\t */\n\tupdate_oom_score_adj(config.oom_score_adj, config.oom_score_adj_len);\n\n\t/*\n\t * Make the process non-dumpable, to avoid various race conditions that\n\t * could cause processes in namespaces we're joining to access host\n\t * resources (or potentially execute code).\n\t *\n\t * However, if the number of namespaces we are joining is 0, we are not\n\t * going to be switching to a different security context. Thus setting\n\t * ourselves to be non-dumpable only breaks things (like rootless\n\t * containers), which is the recommendation from the kernel folks.\n\t */\n\tif (config.namespaces) {\n\t\tif (prctl(PR_SET_DUMPABLE, 0, 0, 0, 0) < 0)\n\t\t\tbail(\"failed to set process as non-dumpable\");\n\t}\n\n\t/* Pipe so we can tell the child when we've finished setting up. */\n\tif (socketpair(AF_LOCAL, SOCK_STREAM, 0, sync_child_pipe) < 0)\n\t\tbail(\"failed to setup sync pipe between parent and child\");\n\n\t/*\n\t * We need a new socketpair to sync with grandchild so we don't have\n\t * race condition with child.\n\t */\n\tif (socketpair(AF_LOCAL, SOCK_STREAM, 0, sync_grandchild_pipe) < 0)\n\t\tbail(\"failed to setup sync pipe between parent and grandchild\");\n\n\t/* TODO: Currently we aren't dealing with child deaths properly. */\n\n\t/*\n\t * Okay, so this is quite annoying.\n\t *\n\t * In order for this unsharing code to be more extensible we need to split\n\t * up unshare(CLONE_NEWUSER) and clone() in various ways. The ideal case\n\t * would be if we did clone(CLONE_NEWUSER) and the other namespaces\n\t * separately, but because of SELinux issues we cannot really do that. But\n\t * we cannot just dump the namespace flags into clone(...) because several\n\t * usecases (such as rootless containers) require more granularity around\n\t * the namespace setup. In addition, some older kernels had issues where\n\t * CLONE_NEWUSER wasn't handled before other namespaces (but we cannot\n\t * handle this while also dealing with SELinux so we choose SELinux support\n\t * over broken kernel support).\n\t *\n\t * However, if we unshare(2) the user namespace *before* we clone(2), then\n\t * all hell breaks loose.\n\t *\n\t * The parent no longer has permissions to do many things (unshare(2) drops\n\t * all capabilities in your old namespace), and the container cannot be set\n\t * up to have more than one {uid,gid} mapping. This is obviously less than\n\t * ideal. In order to fix this, we have to first clone(2) and then unshare.\n\t *\n\t * Unfortunately, it's not as simple as that. We have to fork to enter the\n\t * PID namespace (the PID namespace only applies to children). Since we'll\n\t * have to double-fork, this clone_parent() call won't be able to get the\n\t * PID of the _actual_ init process (without doing more synchronisation than\n\t * I can deal with at the moment). So we'll just get the parent to send it\n\t * for us, the only job of this process is to update\n\t * /proc/pid/{setgroups,uid_map,gid_map}.\n\t *\n\t * And as a result of the above, we also need to setns(2) in the first child\n\t * because if we join a PID namespace in the topmost parent then our child\n\t * will be in that namespace (and it will not be able to give us a PID value\n\t * that makes sense without resorting to sending things with cmsg).\n\t *\n\t * This also deals with an older issue caused by dumping cloneflags into\n\t * clone(2): On old kernels, CLONE_PARENT didn't work with CLONE_NEWPID, so\n\t * we have to unshare(2) before clone(2) in order to do this. This was fixed\n\t * in upstream commit 1f7f4dde5c945f41a7abc2285be43d918029ecc5, and was\n\t * introduced by 40a0d32d1eaffe6aac7324ca92604b6b3977eb0e. As far as we're\n\t * aware, the last mainline kernel which had this bug was Linux 3.12.\n\t * However, we cannot comment on which kernels the broken patch was\n\t * backported to.\n\t *\n\t * -- Aleksa \"what has my life come to?\" Sarai\n\t */\n\n\tswitch (setjmp(env)) {\n\t\t/*\n\t\t * Stage 0: We're in the parent. Our job is just to create a new child\n\t\t *          (stage 1: JUMP_CHILD) process and write its uid_map and\n\t\t *          gid_map. That process will go on to create a new process, then\n\t\t *          it will send us its PID which we will send to the bootstrap\n\t\t *          process.\n\t\t */\n\tcase JUMP_PARENT:{\n\t\t\tint len;\n\t\t\tpid_t child, first_child = -1;\n\t\t\tbool ready = false;\n\n\t\t\t/* For debugging. */\n\t\t\tprctl(PR_SET_NAME, (unsigned long)\"runc:[0:PARENT]\", 0, 0, 0);\n\n\t\t\t/* Start the process of getting a container. */\n\t\t\tchild = clone_parent(&env, JUMP_CHILD);\n\t\t\tif (child < 0)\n\t\t\t\tbail(\"unable to fork: child_func\");\n\n\t\t\t/*\n\t\t\t * State machine for synchronisation with the children.\n\t\t\t *\n\t\t\t * Father only return when both child and grandchild are\n\t\t\t * ready, so we can receive all possible error codes\n\t\t\t * generated by children.\n\t\t\t */\n\t\t\twhile (!ready) {\n\t\t\t\tenum sync_t s;\n\t\t\t\tint ret;\n\n\t\t\t\tsyncfd = sync_child_pipe[1];\n\t\t\t\tclose(sync_child_pipe[0]);\n\n\t\t\t\tif (read(syncfd, &s, sizeof(s)) != sizeof(s))\n\t\t\t\t\tbail(\"failed to sync with child: next state\");\n\n\t\t\t\tswitch (s) {\n\t\t\t\tcase SYNC_ERR:\n\t\t\t\t\t/* We have to mirror the error code of the child. */\n\t\t\t\t\tif (read(syncfd, &ret, sizeof(ret)) != sizeof(ret))\n\t\t\t\t\t\tbail(\"failed to sync with child: read(error code)\");\n\n\t\t\t\t\texit(ret);\n\t\t\t\tcase SYNC_USERMAP_PLS:\n\t\t\t\t\t/*\n\t\t\t\t\t * Enable setgroups(2) if we've been asked to. But we also\n\t\t\t\t\t * have to explicitly disable setgroups(2) if we're\n\t\t\t\t\t * creating a rootless container for single-entry mapping.\n\t\t\t\t\t * i.e. config.is_setgroup == false.\n\t\t\t\t\t * (this is required since Linux 3.19).\n\t\t\t\t\t *\n\t\t\t\t\t * For rootless multi-entry mapping, config.is_setgroup shall be true and\n\t\t\t\t\t * newuidmap/newgidmap shall be used.\n\t\t\t\t\t */\n\n\t\t\t\t\tif (config.is_rootless_euid && !config.is_setgroup)\n\t\t\t\t\t\tupdate_setgroups(child, SETGROUPS_DENY);\n\n\t\t\t\t\t/* Set up mappings. */\n\t\t\t\t\tupdate_uidmap(config.uidmappath, child, config.uidmap, config.uidmap_len);\n\t\t\t\t\tupdate_gidmap(config.gidmappath, child, config.gidmap, config.gidmap_len);\n\n\t\t\t\t\ts = SYNC_USERMAP_ACK;\n\t\t\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s)) {\n\t\t\t\t\t\tkill(child, SIGKILL);\n\t\t\t\t\t\tbail(\"failed to sync with child: write(SYNC_USERMAP_ACK)\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase SYNC_RECVPID_PLS:{\n\t\t\t\t\t\tfirst_child = child;\n\n\t\t\t\t\t\t/* Get the init_func pid. */\n\t\t\t\t\t\tif (read(syncfd, &child, sizeof(child)) != sizeof(child)) {\n\t\t\t\t\t\t\tkill(first_child, SIGKILL);\n\t\t\t\t\t\t\tbail(\"failed to sync with child: read(childpid)\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* Send ACK. */\n\t\t\t\t\t\ts = SYNC_RECVPID_ACK;\n\t\t\t\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s)) {\n\t\t\t\t\t\t\tkill(first_child, SIGKILL);\n\t\t\t\t\t\t\tkill(child, SIGKILL);\n\t\t\t\t\t\t\tbail(\"failed to sync with child: write(SYNC_RECVPID_ACK)\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* Send the init_func pid back to our parent.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * Send the init_func pid and the pid of the first child back to our parent.\n\t\t\t\t\t\t * We need to send both back because we can't reap the first child we created (CLONE_PARENT).\n\t\t\t\t\t\t * It becomes the responsibility of our parent to reap the first child.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tlen = dprintf(pipenum, \"{\\\"pid\\\": %d, \\\"pid_first\\\": %d}\\n\", child, first_child);\n\t\t\t\t\t\tif (len < 0) {\n\t\t\t\t\t\t\tkill(child, SIGKILL);\n\t\t\t\t\t\t\tbail(\"unable to generate JSON for child pid\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase SYNC_CHILD_READY:\n\t\t\t\t\tready = true;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbail(\"unexpected sync value: %u\", s);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Now sync with grandchild. */\n\n\t\t\tready = false;\n\t\t\twhile (!ready) {\n\t\t\t\tenum sync_t s;\n\t\t\t\tint ret;\n\n\t\t\t\tsyncfd = sync_grandchild_pipe[1];\n\t\t\t\tclose(sync_grandchild_pipe[0]);\n\n\t\t\t\ts = SYNC_GRANDCHILD;\n\t\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s)) {\n\t\t\t\t\tkill(child, SIGKILL);\n\t\t\t\t\tbail(\"failed to sync with child: write(SYNC_GRANDCHILD)\");\n\t\t\t\t}\n\n\t\t\t\tif (read(syncfd, &s, sizeof(s)) != sizeof(s))\n\t\t\t\t\tbail(\"failed to sync with child: next state\");\n\n\t\t\t\tswitch (s) {\n\t\t\t\tcase SYNC_ERR:\n\t\t\t\t\t/* We have to mirror the error code of the child. */\n\t\t\t\t\tif (read(syncfd, &ret, sizeof(ret)) != sizeof(ret))\n\t\t\t\t\t\tbail(\"failed to sync with child: read(error code)\");\n\n\t\t\t\t\texit(ret);\n\t\t\t\tcase SYNC_CHILD_READY:\n\t\t\t\t\tready = true;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbail(\"unexpected sync value: %u\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\texit(0);\n\t\t}\n\n\t\t/*\n\t\t * Stage 1: We're in the first child process. Our job is to join any\n\t\t *          provided namespaces in the netlink payload and unshare all\n\t\t *          of the requested namespaces. If we've been asked to\n\t\t *          CLONE_NEWUSER, we will ask our parent (stage 0) to set up\n\t\t *          our user mappings for us. Then, we create a new child\n\t\t *          (stage 2: JUMP_INIT) for PID namespace. We then send the\n\t\t *          child's PID to our parent (stage 0).\n\t\t */\n\tcase JUMP_CHILD:{\n\t\t\tpid_t child;\n\t\t\tenum sync_t s;\n\n\t\t\t/* We're in a child and thus need to tell the parent if we die. */\n\t\t\tsyncfd = sync_child_pipe[0];\n\t\t\tclose(sync_child_pipe[1]);\n\n\t\t\t/* For debugging. */\n\t\t\tprctl(PR_SET_NAME, (unsigned long)\"runc:[1:CHILD]\", 0, 0, 0);\n\n\t\t\t/*\n\t\t\t * We need to setns first. We cannot do this earlier (in stage 0)\n\t\t\t * because of the fact that we forked to get here (the PID of\n\t\t\t * [stage 2: JUMP_INIT]) would be meaningless). We could send it\n\t\t\t * using cmsg(3) but that's just annoying.\n\t\t\t */\n\t\t\tif (config.namespaces)\n\t\t\t\tjoin_namespaces(config.namespaces);\n\n\t\t\t/*\n\t\t\t * Deal with user namespaces first. They are quite special, as they\n\t\t\t * affect our ability to unshare other namespaces and are used as\n\t\t\t * context for privilege checks.\n\t\t\t *\n\t\t\t * We don't unshare all namespaces in one go. The reason for this\n\t\t\t * is that, while the kernel documentation may claim otherwise,\n\t\t\t * there are certain cases where unsharing all namespaces at once\n\t\t\t * will result in namespace objects being owned incorrectly.\n\t\t\t * Ideally we should just fix these kernel bugs, but it's better to\n\t\t\t * be safe than sorry, and fix them separately.\n\t\t\t *\n\t\t\t * A specific case of this is that the SELinux label of the\n\t\t\t * internal kern-mount that mqueue uses will be incorrect if the\n\t\t\t * UTS namespace is cloned before the USER namespace is mapped.\n\t\t\t * I've also heard of similar problems with the network namespace\n\t\t\t * in some scenarios. This also mirrors how LXC deals with this\n\t\t\t * problem.\n\t\t\t */\n\t\t\tif (config.cloneflags & CLONE_NEWUSER) {\n\t\t\t\tif (unshare(CLONE_NEWUSER) < 0)\n\t\t\t\t\tbail(\"failed to unshare user namespace\");\n\t\t\t\tconfig.cloneflags &= ~CLONE_NEWUSER;\n\n\t\t\t\t/*\n\t\t\t\t * We don't have the privileges to do any mapping here (see the\n\t\t\t\t * clone_parent rant). So signal our parent to hook us up.\n\t\t\t\t */\n\n\t\t\t\t/* Switching is only necessary if we joined namespaces. */\n\t\t\t\tif (config.namespaces) {\n\t\t\t\t\tif (prctl(PR_SET_DUMPABLE, 1, 0, 0, 0) < 0)\n\t\t\t\t\t\tbail(\"failed to set process as dumpable\");\n\t\t\t\t}\n\t\t\t\ts = SYNC_USERMAP_PLS;\n\t\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s))\n\t\t\t\t\tbail(\"failed to sync with parent: write(SYNC_USERMAP_PLS)\");\n\n\t\t\t\t/* ... wait for mapping ... */\n\n\t\t\t\tif (read(syncfd, &s, sizeof(s)) != sizeof(s))\n\t\t\t\t\tbail(\"failed to sync with parent: read(SYNC_USERMAP_ACK)\");\n\t\t\t\tif (s != SYNC_USERMAP_ACK)\n\t\t\t\t\tbail(\"failed to sync with parent: SYNC_USERMAP_ACK: got %u\", s);\n\t\t\t\t/* Switching is only necessary if we joined namespaces. */\n\t\t\t\tif (config.namespaces) {\n\t\t\t\t\tif (prctl(PR_SET_DUMPABLE, 0, 0, 0, 0) < 0)\n\t\t\t\t\t\tbail(\"failed to set process as dumpable\");\n\t\t\t\t}\n\n\t\t\t\t/* Become root in the namespace proper. */\n\t\t\t\tif (setresuid(0, 0, 0) < 0)\n\t\t\t\t\tbail(\"failed to become root in user namespace\");\n\t\t\t}\n\t\t\t/*\n\t\t\t * Unshare all of the namespaces. Now, it should be noted that this\n\t\t\t * ordering might break in the future (especially with rootless\n\t\t\t * containers). But for now, it's not possible to split this into\n\t\t\t * CLONE_NEWUSER + [the rest] because of some RHEL SELinux issues.\n\t\t\t *\n\t\t\t * Note that we don't merge this with clone() because there were\n\t\t\t * some old kernel versions where clone(CLONE_PARENT | CLONE_NEWPID)\n\t\t\t * was broken, so we'll just do it the long way anyway.\n\t\t\t */\n\t\t\tif (unshare(config.cloneflags & ~CLONE_NEWCGROUP) < 0)\n\t\t\t\tbail(\"failed to unshare namespaces\");\n\n\t\t\t/*\n\t\t\t * TODO: What about non-namespace clone flags that we're dropping here?\n\t\t\t *\n\t\t\t * We fork again because of PID namespace, setns(2) or unshare(2) don't\n\t\t\t * change the PID namespace of the calling process, because doing so\n\t\t\t * would change the caller's idea of its own PID (as reported by getpid()),\n\t\t\t * which would break many applications and libraries, so we must fork\n\t\t\t * to actually enter the new PID namespace.\n\t\t\t */\n\t\t\tchild = clone_parent(&env, JUMP_INIT);\n\t\t\tif (child < 0)\n\t\t\t\tbail(\"unable to fork: init_func\");\n\n\t\t\t/* Send the child to our parent, which knows what it's doing. */\n\t\t\ts = SYNC_RECVPID_PLS;\n\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s)) {\n\t\t\t\tkill(child, SIGKILL);\n\t\t\t\tbail(\"failed to sync with parent: write(SYNC_RECVPID_PLS)\");\n\t\t\t}\n\t\t\tif (write(syncfd, &child, sizeof(child)) != sizeof(child)) {\n\t\t\t\tkill(child, SIGKILL);\n\t\t\t\tbail(\"failed to sync with parent: write(childpid)\");\n\t\t\t}\n\n\t\t\t/* ... wait for parent to get the pid ... */\n\n\t\t\tif (read(syncfd, &s, sizeof(s)) != sizeof(s)) {\n\t\t\t\tkill(child, SIGKILL);\n\t\t\t\tbail(\"failed to sync with parent: read(SYNC_RECVPID_ACK)\");\n\t\t\t}\n\t\t\tif (s != SYNC_RECVPID_ACK) {\n\t\t\t\tkill(child, SIGKILL);\n\t\t\t\tbail(\"failed to sync with parent: SYNC_RECVPID_ACK: got %u\", s);\n\t\t\t}\n\n\t\t\ts = SYNC_CHILD_READY;\n\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s)) {\n\t\t\t\tkill(child, SIGKILL);\n\t\t\t\tbail(\"failed to sync with parent: write(SYNC_CHILD_READY)\");\n\t\t\t}\n\n\t\t\t/* Our work is done. [Stage 2: JUMP_INIT] is doing the rest of the work. */\n\t\t\texit(0);\n\t\t}\n\n\t\t/*\n\t\t * Stage 2: We're the final child process, and the only process that will\n\t\t *          actually return to the Go runtime. Our job is to just do the\n\t\t *          final cleanup steps and then return to the Go runtime to allow\n\t\t *          init_linux.go to run.\n\t\t */\n\tcase JUMP_INIT:{\n\t\t\t/*\n\t\t\t * We're inside the child now, having jumped from the\n\t\t\t * start_child() code after forking in the parent.\n\t\t\t */\n\t\t\tenum sync_t s;\n\n\t\t\t/* We're in a child and thus need to tell the parent if we die. */\n\t\t\tsyncfd = sync_grandchild_pipe[0];\n\t\t\tclose(sync_grandchild_pipe[1]);\n\t\t\tclose(sync_child_pipe[0]);\n\t\t\tclose(sync_child_pipe[1]);\n\n\t\t\t/* For debugging. */\n\t\t\tprctl(PR_SET_NAME, (unsigned long)\"runc:[2:INIT]\", 0, 0, 0);\n\n\t\t\tif (read(syncfd, &s, sizeof(s)) != sizeof(s))\n\t\t\t\tbail(\"failed to sync with parent: read(SYNC_GRANDCHILD)\");\n\t\t\tif (s != SYNC_GRANDCHILD)\n\t\t\t\tbail(\"failed to sync with parent: SYNC_GRANDCHILD: got %u\", s);\n\n\t\t\tif (setsid() < 0)\n\t\t\t\tbail(\"setsid failed\");\n\n\t\t\tif (setuid(0) < 0)\n\t\t\t\tbail(\"setuid failed\");\n\n\t\t\tif (setgid(0) < 0)\n\t\t\t\tbail(\"setgid failed\");\n\n\t\t\tif (!config.is_rootless_euid && config.is_setgroup) {\n\t\t\t\tif (setgroups(0, NULL) < 0)\n\t\t\t\t\tbail(\"setgroups failed\");\n\t\t\t}\n\n\t\t\t/* ... wait until our topmost parent has finished cgroup setup in p.manager.Apply() ... */\n\t\t\tif (config.cloneflags & CLONE_NEWCGROUP) {\n\t\t\t\tuint8_t value;\n\t\t\t\tif (read(pipenum, &value, sizeof(value)) != sizeof(value))\n\t\t\t\t\tbail(\"read synchronisation value failed\");\n\t\t\t\tif (value == CREATECGROUPNS) {\n\t\t\t\t\tif (unshare(CLONE_NEWCGROUP) < 0)\n\t\t\t\t\t\tbail(\"failed to unshare cgroup namespace\");\n\t\t\t\t} else\n\t\t\t\t\tbail(\"received unknown synchronisation value\");\n\t\t\t}\n\n\t\t\ts = SYNC_CHILD_READY;\n\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s))\n\t\t\t\tbail(\"failed to sync with patent: write(SYNC_CHILD_READY)\");\n\n\t\t\t/* Close sync pipes. */\n\t\t\tclose(sync_grandchild_pipe[0]);\n\n\t\t\t/* Free netlink data. */\n\t\t\tnl_free(&config);\n\n\t\t\t/* Finish executing, let the Go runtime take over. */\n\t\t\treturn;\n\t\t}\n\tdefault:\n\t\tbail(\"unexpected jump value\");\n\t}\n\n\t/* Should never be reached. */\n\tbail(\"should never be reached\");\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146665,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "dvi_document_file_exporter_end (EvFileExporter *exporter)\n{\n\tgchar *command_line;\n\tgint exit_stat;\n\tGError *err = NULL;\n\tgboolean success;\n\t\n\tDviDocument *dvi_document = DVI_DOCUMENT(exporter);\n\t\n\tcommand_line = g_strdup_printf (\"dvipdfm %s -o %s \\\"%s\\\"\", /* dvipdfm -s 1,2,.., -o exporter_filename dvi_filename */\n\t\t\t\t\tdvi_document->exporter_opts->str,\n\t\t\t\t\tdvi_document->exporter_filename,\n\t\t\t\t\tdvi_document->context->filename);\n\t\n\tsuccess = g_spawn_command_line_sync (command_line,\n\t\t\t\t\t     NULL,\n\t\t\t\t\t     NULL,\n\t\t\t\t\t     &exit_stat,\n\t\t\t\t\t     &err);\n\n\tg_free (command_line);\n\n\tif (success == FALSE) {\n\t\tg_warning (\"Error: %s\", err->message);\n\t} else if (!WIFEXITED(exit_stat) || WEXITSTATUS(exit_stat) != EXIT_SUCCESS){\n\t\tg_warning (\"Error: dvipdfm does not end normally or exit with a failure status.\");\n\t}\n\n\tif (err)\n\t\tg_error_free (err);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146676,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "dvi_document_file_exporter_end (EvFileExporter *exporter)\n{\n\tgchar *command_line;\n\tgint exit_stat;\n\tGError *err = NULL;\n\tgboolean success;\n\t\n\tDviDocument *dvi_document = DVI_DOCUMENT(exporter);\n\tgchar* quoted_filename = g_shell_quote (dvi_document->context->filename);\n\t\n\tcommand_line = g_strdup_printf (\"dvipdfm %s -o %s %s\", /* dvipdfm -s 1,2,.., -o exporter_filename dvi_filename */\n\t\t\t\t\tdvi_document->exporter_opts->str,\n\t\t\t\t\tdvi_document->exporter_filename,\n\t\t\t\t\tquoted_filename);\n\tg_free (quoted_filename);\n\n\tsuccess = g_spawn_command_line_sync (command_line,\n\t\t\t\t\t     NULL,\n\t\t\t\t\t     NULL,\n\t\t\t\t\t     &exit_stat,\n\t\t\t\t\t     &err);\n\n\tg_free (command_line);\n\n\tif (success == FALSE) {\n\t\tg_warning (\"Error: %s\", err->message);\n\t} else if (!WIFEXITED(exit_stat) || WEXITSTATUS(exit_stat) != EXIT_SUCCESS){\n\t\tg_warning (\"Error: dvipdfm does not end normally or exit with a failure status.\");\n\t}\n\n\tif (err)\n\t\tg_error_free (err);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146677,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "deliver_message(uschar *id, BOOL forced, BOOL give_up)\n{\nint i, rc;\nint final_yield = DELIVER_ATTEMPTED_NORMAL;\ntime_t now = time(NULL);\naddress_item *addr_last = NULL;\nuschar *filter_message = NULL;\nint process_recipients = RECIP_ACCEPT;\nopen_db dbblock;\nopen_db *dbm_file;\nextern int acl_where;\n\nuschar *info = queue_run_pid == (pid_t)0\n  ? string_sprintf(\"delivering %s\", id)\n  : string_sprintf(\"delivering %s (queue run pid %d)\", id, queue_run_pid);\n\n/* If the D_process_info bit is on, set_process_info() will output debugging\ninformation. If not, we want to show this initial information if D_deliver or\nD_queue_run is set or in verbose mode. */\n\nset_process_info(\"%s\", info);\n\nif (  !(debug_selector & D_process_info)\n   && (debug_selector & (D_deliver|D_queue_run|D_v))\n   )\n  debug_printf(\"%s\\n\", info);\n\n/* Ensure that we catch any subprocesses that are created. Although Exim\nsets SIG_DFL as its initial default, some routes through the code end up\nhere with it set to SIG_IGN - cases where a non-synchronous delivery process\nhas been forked, but no re-exec has been done. We use sigaction rather than\nplain signal() on those OS where SA_NOCLDWAIT exists, because we want to be\nsure it is turned off. (There was a problem on AIX with this.) */\n\n#ifdef SA_NOCLDWAIT\n  {\n  struct sigaction act;\n  act.sa_handler = SIG_DFL;\n  sigemptyset(&(act.sa_mask));\n  act.sa_flags = 0;\n  sigaction(SIGCHLD, &act, NULL);\n  }\n#else\nsignal(SIGCHLD, SIG_DFL);\n#endif\n\n/* Make the forcing flag available for routers and transports, set up the\nglobal message id field, and initialize the count for returned files and the\nmessage size. This use of strcpy() is OK because the length id is checked when\nit is obtained from a command line (the -M or -q options), and otherwise it is\nknown to be a valid message id. */\n\nUstrcpy(message_id, id);\nf.deliver_force = forced;\nreturn_count = 0;\nmessage_size = 0;\n\n/* Initialize some flags */\n\nupdate_spool = FALSE;\nremove_journal = TRUE;\n\n/* Set a known context for any ACLs we call via expansions */\nacl_where = ACL_WHERE_DELIVERY;\n\n/* Reset the random number generator, so that if several delivery processes are\nstarted from a queue runner that has already used random numbers (for sorting),\nthey don't all get the same sequence. */\n\nrandom_seed = 0;\n\n/* Open and lock the message's data file. Exim locks on this one because the\nheader file may get replaced as it is re-written during the delivery process.\nAny failures cause messages to be written to the log, except for missing files\nwhile queue running - another process probably completed delivery. As part of\nopening the data file, message_subdir gets set. */\n\nif ((deliver_datafile = spool_open_datafile(id)) < 0)\n  return continue_closedown();  /* yields DELIVER_NOT_ATTEMPTED */\n\n/* The value of message_size at this point has been set to the data length,\nplus one for the blank line that notionally precedes the data. */\n\n/* Now read the contents of the header file, which will set up the headers in\nstore, and also the list of recipients and the tree of non-recipients and\nassorted flags. It updates message_size. If there is a reading or format error,\ngive up; if the message has been around for sufficiently long, remove it. */\n\n  {\n  uschar * spoolname = string_sprintf(\"%s-H\", id);\n  if ((rc = spool_read_header(spoolname, TRUE, TRUE)) != spool_read_OK)\n    {\n    if (errno == ERRNO_SPOOLFORMAT)\n      {\n      struct stat statbuf;\n      if (Ustat(spool_fname(US\"input\", message_subdir, spoolname, US\"\"),\n\t\t&statbuf) == 0)\n\tlog_write(0, LOG_MAIN, \"Format error in spool file %s: \"\n\t  \"size=\" OFF_T_FMT, spoolname, statbuf.st_size);\n      else\n\tlog_write(0, LOG_MAIN, \"Format error in spool file %s\", spoolname);\n      }\n    else\n      log_write(0, LOG_MAIN, \"Error reading spool file %s: %s\", spoolname,\n\tstrerror(errno));\n\n    /* If we managed to read the envelope data, received_time contains the\n    time the message was received. Otherwise, we can calculate it from the\n    message id. */\n\n    if (rc != spool_read_hdrerror)\n      {\n      received_time.tv_sec = received_time.tv_usec = 0;\n      /*XXX subsec precision?*/\n      for (i = 0; i < 6; i++)\n\treceived_time.tv_sec = received_time.tv_sec * BASE_62 + tab62[id[i] - '0'];\n      }\n\n    /* If we've had this malformed message too long, sling it. */\n\n    if (now - received_time.tv_sec > keep_malformed)\n      {\n      Uunlink(spool_fname(US\"msglog\", message_subdir, id, US\"\"));\n      Uunlink(spool_fname(US\"input\", message_subdir, id, US\"-D\"));\n      Uunlink(spool_fname(US\"input\", message_subdir, id, US\"-H\"));\n      Uunlink(spool_fname(US\"input\", message_subdir, id, US\"-J\"));\n      log_write(0, LOG_MAIN, \"Message removed because older than %s\",\n\treadconf_printtime(keep_malformed));\n      }\n\n    (void)close(deliver_datafile);\n    deliver_datafile = -1;\n    return continue_closedown();   /* yields DELIVER_NOT_ATTEMPTED */\n    }\n  }\n\n/* The spool header file has been read. Look to see if there is an existing\njournal file for this message. If there is, it means that a previous delivery\nattempt crashed (program or host) before it could update the spool header file.\nRead the list of delivered addresses from the journal and add them to the\nnonrecipients tree. Then update the spool file. We can leave the journal in\nexistence, as it will get further successful deliveries added to it in this\nrun, and it will be deleted if this function gets to its end successfully.\nOtherwise it might be needed again. */\n\n  {\n  uschar * fname = spool_fname(US\"input\", message_subdir, id, US\"-J\");\n  FILE * jread;\n\n  if (  (journal_fd = Uopen(fname, O_RDWR|O_APPEND\n#ifdef O_CLOEXEC\n\t\t\t\t    | O_CLOEXEC\n#endif\n#ifdef O_NOFOLLOW\n\t\t\t\t    | O_NOFOLLOW\n#endif\n\t, SPOOL_MODE)) >= 0\n     && lseek(journal_fd, 0, SEEK_SET) == 0\n     && (jread = fdopen(journal_fd, \"rb\"))\n     )\n    {\n    while (Ufgets(big_buffer, big_buffer_size, jread))\n      {\n      int n = Ustrlen(big_buffer);\n      big_buffer[n-1] = 0;\n      tree_add_nonrecipient(big_buffer);\n      DEBUG(D_deliver) debug_printf(\"Previously delivered address %s taken from \"\n\t\"journal file\\n\", big_buffer);\n      }\n    rewind(jread);\n    if ((journal_fd = dup(fileno(jread))) < 0)\n      journal_fd = fileno(jread);\n    else\n      (void) fclose(jread);\t/* Try to not leak the FILE resource */\n\n    /* Panic-dies on error */\n    (void)spool_write_header(message_id, SW_DELIVERING, NULL);\n    }\n  else if (errno != ENOENT)\n    {\n    log_write(0, LOG_MAIN|LOG_PANIC, \"attempt to open journal for reading gave: \"\n      \"%s\", strerror(errno));\n    return continue_closedown();   /* yields DELIVER_NOT_ATTEMPTED */\n    }\n\n  /* A null recipients list indicates some kind of disaster. */\n\n  if (!recipients_list)\n    {\n    (void)close(deliver_datafile);\n    deliver_datafile = -1;\n    log_write(0, LOG_MAIN, \"Spool error: no recipients for %s\", fname);\n    return continue_closedown();   /* yields DELIVER_NOT_ATTEMPTED */\n    }\n  }\n\n\n/* Handle a message that is frozen. There are a number of different things that\ncan happen, but in the default situation, unless forced, no delivery is\nattempted. */\n\nif (f.deliver_freeze)\n  {\n#ifdef SUPPORT_MOVE_FROZEN_MESSAGES\n  /* Moving to another directory removes the message from Exim's view. Other\n  tools must be used to deal with it. Logging of this action happens in\n  spool_move_message() and its subfunctions. */\n\n  if (  move_frozen_messages\n     && spool_move_message(id, message_subdir, US\"\", US\"F\")\n     )\n    return continue_closedown();   /* yields DELIVER_NOT_ATTEMPTED */\n#endif\n\n  /* For all frozen messages (bounces or not), timeout_frozen_after sets the\n  maximum time to keep messages that are frozen. Thaw if we reach it, with a\n  flag causing all recipients to be failed. The time is the age of the\n  message, not the time since freezing. */\n\n  if (timeout_frozen_after > 0 && message_age >= timeout_frozen_after)\n    {\n    log_write(0, LOG_MAIN, \"cancelled by timeout_frozen_after\");\n    process_recipients = RECIP_FAIL_TIMEOUT;\n    }\n\n  /* For bounce messages (and others with no sender), thaw if the error message\n  ignore timer is exceeded. The message will be discarded if this delivery\n  fails. */\n\n  else if (!*sender_address && message_age >= ignore_bounce_errors_after)\n    log_write(0, LOG_MAIN, \"Unfrozen by errmsg timer\");\n\n  /* If this is a bounce message, or there's no auto thaw, or we haven't\n  reached the auto thaw time yet, and this delivery is not forced by an admin\n  user, do not attempt delivery of this message. Note that forced is set for\n  continuing messages down the same channel, in order to skip load checking and\n  ignore hold domains, but we don't want unfreezing in that case. */\n\n  else\n    {\n    if (  (  sender_address[0] == 0\n\t  || auto_thaw <= 0\n\t  || now <= deliver_frozen_at + auto_thaw\n          )\n       && (  !forced || !f.deliver_force_thaw\n\t  || !f.admin_user || continue_hostname\n       )  )\n      {\n      (void)close(deliver_datafile);\n      deliver_datafile = -1;\n      log_write(L_skip_delivery, LOG_MAIN, \"Message is frozen\");\n      return continue_closedown();   /* yields DELIVER_NOT_ATTEMPTED */\n      }\n\n    /* If delivery was forced (by an admin user), assume a manual thaw.\n    Otherwise it's an auto thaw. */\n\n    if (forced)\n      {\n      f.deliver_manual_thaw = TRUE;\n      log_write(0, LOG_MAIN, \"Unfrozen by forced delivery\");\n      }\n    else log_write(0, LOG_MAIN, \"Unfrozen by auto-thaw\");\n    }\n\n  /* We get here if any of the rules for unfreezing have triggered. */\n\n  f.deliver_freeze = FALSE;\n  update_spool = TRUE;\n  }\n\n\n/* Open the message log file if we are using them. This records details of\ndeliveries, deferments, and failures for the benefit of the mail administrator.\nThe log is not used by exim itself to track the progress of a message; that is\ndone by rewriting the header spool file. */\n\nif (message_logs)\n  {\n  uschar * fname = spool_fname(US\"msglog\", message_subdir, id, US\"\");\n  uschar * error;\n  int fd;\n\n  if ((fd = open_msglog_file(fname, SPOOL_MODE, &error)) < 0)\n    {\n    log_write(0, LOG_MAIN|LOG_PANIC, \"Couldn't %s message log %s: %s\", error,\n      fname, strerror(errno));\n    return continue_closedown();   /* yields DELIVER_NOT_ATTEMPTED */\n    }\n\n  /* Make a C stream out of it. */\n\n  if (!(message_log = fdopen(fd, \"a\")))\n    {\n    log_write(0, LOG_MAIN|LOG_PANIC, \"Couldn't fdopen message log %s: %s\",\n      fname, strerror(errno));\n    return continue_closedown();   /* yields DELIVER_NOT_ATTEMPTED */\n    }\n  }\n\n\n/* If asked to give up on a message, log who did it, and set the action for all\nthe addresses. */\n\nif (give_up)\n  {\n  struct passwd *pw = getpwuid(real_uid);\n  log_write(0, LOG_MAIN, \"cancelled by %s\",\n      pw ? US pw->pw_name : string_sprintf(\"uid %ld\", (long int)real_uid));\n  process_recipients = RECIP_FAIL;\n  }\n\n/* Otherwise, if there are too many Received: headers, fail all recipients. */\n\nelse if (received_count > received_headers_max)\n  process_recipients = RECIP_FAIL_LOOP;\n\n/* Otherwise, if a system-wide, address-independent message filter is\nspecified, run it now, except in the case when we are failing all recipients as\na result of timeout_frozen_after. If the system filter yields \"delivered\", then\nignore the true recipients of the message. Failure of the filter file is\nlogged, and the delivery attempt fails. */\n\nelse if (system_filter && process_recipients != RECIP_FAIL_TIMEOUT)\n  {\n  int rc;\n  int filtertype;\n  ugid_block ugid;\n  redirect_block redirect;\n\n  if (system_filter_uid_set)\n    {\n    ugid.uid = system_filter_uid;\n    ugid.gid = system_filter_gid;\n    ugid.uid_set = ugid.gid_set = TRUE;\n    }\n  else\n    {\n    ugid.uid_set = ugid.gid_set = FALSE;\n    }\n\n  return_path = sender_address;\n  f.enable_dollar_recipients = TRUE;   /* Permit $recipients in system filter */\n  f.system_filtering = TRUE;\n\n  /* Any error in the filter file causes a delivery to be abandoned. */\n\n  redirect.string = system_filter;\n  redirect.isfile = TRUE;\n  redirect.check_owner = redirect.check_group = FALSE;\n  redirect.owners = NULL;\n  redirect.owngroups = NULL;\n  redirect.pw = NULL;\n  redirect.modemask = 0;\n\n  DEBUG(D_deliver|D_filter) debug_printf(\"running system filter\\n\");\n\n  rc = rda_interpret(\n    &redirect,              /* Where the data is */\n    RDO_DEFER |             /* Turn on all the enabling options */\n      RDO_FAIL |            /* Leave off all the disabling options */\n      RDO_FILTER |\n      RDO_FREEZE |\n      RDO_REALLOG |\n      RDO_REWRITE,\n    NULL,                   /* No :include: restriction (not used in filter) */\n    NULL,                   /* No sieve vacation directory (not sieve!) */\n    NULL,                   /* No sieve enotify mailto owner (not sieve!) */\n    NULL,                   /* No sieve user address (not sieve!) */\n    NULL,                   /* No sieve subaddress (not sieve!) */\n    &ugid,                  /* uid/gid data */\n    &addr_new,              /* Where to hang generated addresses */\n    &filter_message,        /* Where to put error message */\n    NULL,                   /* Don't skip syntax errors */\n    &filtertype,            /* Will always be set to FILTER_EXIM for this call */\n    US\"system filter\");     /* For error messages */\n\n  DEBUG(D_deliver|D_filter) debug_printf(\"system filter returned %d\\n\", rc);\n\n  if (rc == FF_ERROR || rc == FF_NONEXIST)\n    {\n    (void)close(deliver_datafile);\n    deliver_datafile = -1;\n    log_write(0, LOG_MAIN|LOG_PANIC, \"Error in system filter: %s\",\n      string_printing(filter_message));\n    return continue_closedown();   /* yields DELIVER_NOT_ATTEMPTED */\n    }\n\n  /* Reset things. If the filter message is an empty string, which can happen\n  for a filter \"fail\" or \"freeze\" command with no text, reset it to NULL. */\n\n  f.system_filtering = FALSE;\n  f.enable_dollar_recipients = FALSE;\n  if (filter_message && filter_message[0] == 0) filter_message = NULL;\n\n  /* Save the values of the system filter variables so that user filters\n  can use them. */\n\n  memcpy(filter_sn, filter_n, sizeof(filter_sn));\n\n  /* The filter can request that delivery of the original addresses be\n  deferred. */\n\n  if (rc == FF_DEFER)\n    {\n    process_recipients = RECIP_DEFER;\n    deliver_msglog(\"Delivery deferred by system filter\\n\");\n    log_write(0, LOG_MAIN, \"Delivery deferred by system filter\");\n    }\n\n  /* The filter can request that a message be frozen, but this does not\n  take place if the message has been manually thawed. In that case, we must\n  unset \"delivered\", which is forced by the \"freeze\" command to make -bF\n  work properly. */\n\n  else if (rc == FF_FREEZE && !f.deliver_manual_thaw)\n    {\n    f.deliver_freeze = TRUE;\n    deliver_frozen_at = time(NULL);\n    process_recipients = RECIP_DEFER;\n    frozen_info = string_sprintf(\" by the system filter%s%s\",\n      filter_message ? US\": \" : US\"\",\n      filter_message ? filter_message : US\"\");\n    }\n\n  /* The filter can request that a message be failed. The error message may be\n  quite long - it is sent back to the sender in the bounce - but we don't want\n  to fill up the log with repetitions of it. If it starts with << then the text\n  between << and >> is written to the log, with the rest left for the bounce\n  message. */\n\n  else if (rc == FF_FAIL)\n    {\n    uschar *colon = US\"\";\n    uschar *logmsg = US\"\";\n    int loglen = 0;\n\n    process_recipients = RECIP_FAIL_FILTER;\n\n    if (filter_message)\n      {\n      uschar *logend;\n      colon = US\": \";\n      if (  filter_message[0] == '<'\n         && filter_message[1] == '<'\n\t && (logend = Ustrstr(filter_message, \">>\"))\n\t )\n        {\n        logmsg = filter_message + 2;\n        loglen = logend - logmsg;\n        filter_message = logend + 2;\n        if (filter_message[0] == 0) filter_message = NULL;\n        }\n      else\n        {\n        logmsg = filter_message;\n        loglen = Ustrlen(filter_message);\n        }\n      }\n\n    log_write(0, LOG_MAIN, \"cancelled by system filter%s%.*s\", colon, loglen,\n      logmsg);\n    }\n\n  /* Delivery can be restricted only to those recipients (if any) that the\n  filter specified. */\n\n  else if (rc == FF_DELIVERED)\n    {\n    process_recipients = RECIP_IGNORE;\n    if (addr_new)\n      log_write(0, LOG_MAIN, \"original recipients ignored (system filter)\");\n    else\n      log_write(0, LOG_MAIN, \"=> discarded (system filter)\");\n    }\n\n  /* If any new addresses were created by the filter, fake up a \"parent\"\n  for them. This is necessary for pipes, etc., which are expected to have\n  parents, and it also gives some sensible logging for others. Allow\n  pipes, files, and autoreplies, and run them as the filter uid if set,\n  otherwise as the current uid. */\n\n  if (addr_new)\n    {\n    int uid = (system_filter_uid_set)? system_filter_uid : geteuid();\n    int gid = (system_filter_gid_set)? system_filter_gid : getegid();\n\n    /* The text \"system-filter\" is tested in transport_set_up_command() and in\n    set_up_shell_command() in the pipe transport, to enable them to permit\n    $recipients, so don't change it here without also changing it there. */\n\n    address_item *p = addr_new;\n    address_item *parent = deliver_make_addr(US\"system-filter\", FALSE);\n\n    parent->domain = string_copylc(qualify_domain_recipient);\n    parent->local_part = US\"system-filter\";\n\n    /* As part of this loop, we arrange for addr_last to end up pointing\n    at the final address. This is used if we go on to add addresses for the\n    original recipients. */\n\n    while (p)\n      {\n      if (parent->child_count == USHRT_MAX)\n        log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"system filter generated more \"\n          \"than %d delivery addresses\", USHRT_MAX);\n      parent->child_count++;\n      p->parent = parent;\n\n      if (testflag(p, af_pfr))\n        {\n        uschar *tpname;\n        uschar *type;\n        p->uid = uid;\n        p->gid = gid;\n        setflag(p, af_uid_set);\n        setflag(p, af_gid_set);\n        setflag(p, af_allow_file);\n        setflag(p, af_allow_pipe);\n        setflag(p, af_allow_reply);\n\n        /* Find the name of the system filter's appropriate pfr transport */\n\n        if (p->address[0] == '|')\n          {\n          type = US\"pipe\";\n          tpname = system_filter_pipe_transport;\n          address_pipe = p->address;\n          }\n        else if (p->address[0] == '>')\n          {\n          type = US\"reply\";\n          tpname = system_filter_reply_transport;\n          }\n        else\n          {\n          if (p->address[Ustrlen(p->address)-1] == '/')\n            {\n            type = US\"directory\";\n            tpname = system_filter_directory_transport;\n            }\n          else\n            {\n            type = US\"file\";\n            tpname = system_filter_file_transport;\n            }\n          address_file = p->address;\n          }\n\n        /* Now find the actual transport, first expanding the name. We have\n        set address_file or address_pipe above. */\n\n        if (tpname)\n          {\n          uschar *tmp = expand_string(tpname);\n          address_file = address_pipe = NULL;\n          if (!tmp)\n            p->message = string_sprintf(\"failed to expand \\\"%s\\\" as a \"\n              \"system filter transport name\", tpname);\n          tpname = tmp;\n          }\n        else\n          p->message = string_sprintf(\"system_filter_%s_transport is unset\",\n            type);\n\n        if (tpname)\n          {\n          transport_instance *tp;\n          for (tp = transports; tp; tp = tp->next)\n            if (Ustrcmp(tp->name, tpname) == 0)\n              {\n              p->transport = tp;\n              break;\n              }\n          if (!tp)\n            p->message = string_sprintf(\"failed to find \\\"%s\\\" transport \"\n              \"for system filter delivery\", tpname);\n          }\n\n        /* If we couldn't set up a transport, defer the delivery, putting the\n        error on the panic log as well as the main log. */\n\n        if (!p->transport)\n          {\n          address_item *badp = p;\n          p = p->next;\n          if (!addr_last) addr_new = p; else addr_last->next = p;\n          badp->local_part = badp->address;   /* Needed for log line */\n          post_process_one(badp, DEFER, LOG_MAIN|LOG_PANIC, EXIM_DTYPE_ROUTER, 0);\n          continue;\n          }\n        }    /* End of pfr handling */\n\n      /* Either a non-pfr delivery, or we found a transport */\n\n      DEBUG(D_deliver|D_filter)\n        debug_printf(\"system filter added %s\\n\", p->address);\n\n      addr_last = p;\n      p = p->next;\n      }    /* Loop through all addr_new addresses */\n    }\n  }\n\n\n/* Scan the recipients list, and for every one that is not in the non-\nrecipients tree, add an addr item to the chain of new addresses. If the pno\nvalue is non-negative, we must set the onetime parent from it. This which\npoints to the relevant entry in the recipients list.\n\nThis processing can be altered by the setting of the process_recipients\nvariable, which is changed if recipients are to be ignored, failed, or\ndeferred. This can happen as a result of system filter activity, or if the -Mg\noption is used to fail all of them.\n\nDuplicate addresses are handled later by a different tree structure; we can't\njust extend the non-recipients tree, because that will be re-written to the\nspool if the message is deferred, and in any case there are casing\ncomplications for local addresses. */\n\nif (process_recipients != RECIP_IGNORE)\n  for (i = 0; i < recipients_count; i++)\n    if (!tree_search(tree_nonrecipients, recipients_list[i].address))\n      {\n      recipient_item *r = recipients_list + i;\n      address_item *new = deliver_make_addr(r->address, FALSE);\n      new->prop.errors_address = r->errors_to;\n#ifdef SUPPORT_I18N\n      if ((new->prop.utf8_msg = message_smtputf8))\n\t{\n\tnew->prop.utf8_downcvt =       message_utf8_downconvert == 1;\n\tnew->prop.utf8_downcvt_maybe = message_utf8_downconvert == -1;\n\tDEBUG(D_deliver) debug_printf(\"utf8, downconvert %s\\n\",\n\t  new->prop.utf8_downcvt ? \"yes\"\n\t  : new->prop.utf8_downcvt_maybe ? \"ifneeded\"\n\t  : \"no\");\n\t}\n#endif\n\n      if (r->pno >= 0)\n        new->onetime_parent = recipients_list[r->pno].address;\n\n      /* If DSN support is enabled, set the dsn flags and the original receipt\n         to be passed on to other DSN enabled MTAs */\n      new->dsn_flags = r->dsn_flags & rf_dsnflags;\n      new->dsn_orcpt = r->orcpt;\n      DEBUG(D_deliver) debug_printf(\"DSN: set orcpt: %s  flags: %d\\n\",\n\tnew->dsn_orcpt ? new->dsn_orcpt : US\"\", new->dsn_flags);\n\n      switch (process_recipients)\n        {\n        /* RECIP_DEFER is set when a system filter freezes a message. */\n\n        case RECIP_DEFER:\n\t  new->next = addr_defer;\n\t  addr_defer = new;\n\t  break;\n\n\n        /* RECIP_FAIL_FILTER is set when a system filter has obeyed a \"fail\"\n        command. */\n\n        case RECIP_FAIL_FILTER:\n\t  new->message =\n\t    filter_message ? filter_message : US\"delivery cancelled\";\n\t  setflag(new, af_pass_message);\n\t  goto RECIP_QUEUE_FAILED;   /* below */\n\n\n        /* RECIP_FAIL_TIMEOUT is set when a message is frozen, but is older\n        than the value in timeout_frozen_after. Treat non-bounce messages\n        similarly to -Mg; for bounce messages we just want to discard, so\n        don't put the address on the failed list. The timeout has already\n        been logged. */\n\n        case RECIP_FAIL_TIMEOUT:\n\t  new->message  = US\"delivery cancelled; message timed out\";\n\t  goto RECIP_QUEUE_FAILED;   /* below */\n\n\n        /* RECIP_FAIL is set when -Mg has been used. */\n\n        case RECIP_FAIL:\n\t  new->message  = US\"delivery cancelled by administrator\";\n\t  /* Fall through */\n\n        /* Common code for the failure cases above. If this is not a bounce\n        message, put the address on the failed list so that it is used to\n        create a bounce. Otherwise do nothing - this just discards the address.\n        The incident has already been logged. */\n\n        RECIP_QUEUE_FAILED:\n\t  if (sender_address[0])\n\t    {\n\t    new->next = addr_failed;\n\t    addr_failed = new;\n\t    }\n        break;\n\n\n        /* RECIP_FAIL_LOOP is set when there are too many Received: headers\n        in the message. Process each address as a routing failure; if this\n        is a bounce message, it will get frozen. */\n\n        case RECIP_FAIL_LOOP:\n\t  new->message = US\"Too many \\\"Received\\\" headers - suspected mail loop\";\n\t  post_process_one(new, FAIL, LOG_MAIN, EXIM_DTYPE_ROUTER, 0);\n\t  break;\n\n\n        /* Value should be RECIP_ACCEPT; take this as the safe default. */\n\n        default:\n\t  if (!addr_new) addr_new = new; else addr_last->next = new;\n\t  addr_last = new;\n\t  break;\n        }\n\n#ifndef DISABLE_EVENT\n      if (process_recipients != RECIP_ACCEPT)\n\t{\n\tuschar * save_local =  deliver_localpart;\n\tconst uschar * save_domain = deliver_domain;\n\n\tdeliver_localpart = expand_string(\n\t\t      string_sprintf(\"${local_part:%s}\", new->address));\n\tdeliver_domain =    expand_string(\n\t\t      string_sprintf(\"${domain:%s}\", new->address));\n\n\t(void) event_raise(event_action,\n\t\t      US\"msg:fail:internal\", new->message);\n\n\tdeliver_localpart = save_local;\n\tdeliver_domain =    save_domain;\n\t}\n#endif\n      }\n\nDEBUG(D_deliver)\n  {\n  address_item *p;\n  debug_printf(\"Delivery address list:\\n\");\n  for (p = addr_new; p; p = p->next)\n    debug_printf(\"  %s %s\\n\", p->address,\n      p->onetime_parent ? p->onetime_parent : US\"\");\n  }\n\n/* Set up the buffers used for copying over the file when delivering. */\n\ndeliver_in_buffer = store_malloc(DELIVER_IN_BUFFER_SIZE);\ndeliver_out_buffer = store_malloc(DELIVER_OUT_BUFFER_SIZE);\n\n\n\n/* Until there are no more new addresses, handle each one as follows:\n\n . If this is a generated address (indicated by the presence of a parent\n   pointer) then check to see whether it is a pipe, file, or autoreply, and\n   if so, handle it directly here. The router that produced the address will\n   have set the allow flags into the address, and also set the uid/gid required.\n   Having the routers generate new addresses and then checking them here at\n   the outer level is tidier than making each router do the checking, and\n   means that routers don't need access to the failed address queue.\n\n . Break up the address into local part and domain, and make lowercased\n   versions of these strings. We also make unquoted versions of the local part.\n\n . Handle the percent hack for those domains for which it is valid.\n\n . For child addresses, determine if any of the parents have the same address.\n   If so, generate a different string for previous delivery checking. Without\n   this code, if the address spqr generates spqr via a forward or alias file,\n   delivery of the generated spqr stops further attempts at the top level spqr,\n   which is not what is wanted - it may have generated other addresses.\n\n . Check on the retry database to see if routing was previously deferred, but\n   only if in a queue run. Addresses that are to be routed are put on the\n   addr_route chain. Addresses that are to be deferred are put on the\n   addr_defer chain. We do all the checking first, so as not to keep the\n   retry database open any longer than necessary.\n\n . Now we run the addresses through the routers. A router may put the address\n   on either the addr_local or the addr_remote chain for local or remote\n   delivery, respectively, or put it on the addr_failed chain if it is\n   undeliveable, or it may generate child addresses and put them on the\n   addr_new chain, or it may defer an address. All the chain anchors are\n   passed as arguments so that the routers can be called for verification\n   purposes as well.\n\n . If new addresses have been generated by the routers, da capo.\n*/\n\nf.header_rewritten = FALSE;          /* No headers rewritten yet */\nwhile (addr_new)           /* Loop until all addresses dealt with */\n  {\n  address_item *addr, *parent;\n\n  /* Failure to open the retry database is treated the same as if it does\n  not exist. In both cases, dbm_file is NULL. */\n\n  if (!(dbm_file = dbfn_open(US\"retry\", O_RDONLY, &dbblock, FALSE)))\n    DEBUG(D_deliver|D_retry|D_route|D_hints_lookup)\n      debug_printf(\"no retry data available\\n\");\n\n  /* Scan the current batch of new addresses, to handle pipes, files and\n  autoreplies, and determine which others are ready for routing. */\n\n  while (addr_new)\n    {\n    int rc;\n    uschar *p;\n    tree_node *tnode;\n    dbdata_retry *domain_retry_record;\n    dbdata_retry *address_retry_record;\n\n    addr = addr_new;\n    addr_new = addr->next;\n\n    DEBUG(D_deliver|D_retry|D_route)\n      {\n      debug_printf(\">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\\n\");\n      debug_printf(\"Considering: %s\\n\", addr->address);\n      }\n\n    /* Handle generated address that is a pipe or a file or an autoreply. */\n\n    if (testflag(addr, af_pfr))\n      {\n      /* If an autoreply in a filter could not generate a syntactically valid\n      address, give up forthwith. Set af_ignore_error so that we don't try to\n      generate a bounce. */\n\n      if (testflag(addr, af_bad_reply))\n        {\n        addr->basic_errno = ERRNO_BADADDRESS2;\n        addr->local_part = addr->address;\n        addr->message =\n          US\"filter autoreply generated syntactically invalid recipient\";\n        addr->prop.ignore_error = TRUE;\n        (void) post_process_one(addr, FAIL, LOG_MAIN, EXIM_DTYPE_ROUTER, 0);\n        continue;   /* with the next new address */\n        }\n\n      /* If two different users specify delivery to the same pipe or file or\n      autoreply, there should be two different deliveries, so build a unique\n      string that incorporates the original address, and use this for\n      duplicate testing and recording delivery, and also for retrying. */\n\n      addr->unique =\n        string_sprintf(\"%s:%s\", addr->address, addr->parent->unique +\n          (testflag(addr->parent, af_homonym)? 3:0));\n\n      addr->address_retry_key = addr->domain_retry_key =\n        string_sprintf(\"T:%s\", addr->unique);\n\n      /* If a filter file specifies two deliveries to the same pipe or file,\n      we want to de-duplicate, but this is probably not wanted for two mail\n      commands to the same address, where probably both should be delivered.\n      So, we have to invent a different unique string in that case. Just\n      keep piling '>' characters on the front. */\n\n      if (addr->address[0] == '>')\n        {\n        while (tree_search(tree_duplicates, addr->unique))\n          addr->unique = string_sprintf(\">%s\", addr->unique);\n        }\n\n      else if ((tnode = tree_search(tree_duplicates, addr->unique)))\n        {\n        DEBUG(D_deliver|D_route)\n          debug_printf(\"%s is a duplicate address: discarded\\n\", addr->address);\n        addr->dupof = tnode->data.ptr;\n        addr->next = addr_duplicate;\n        addr_duplicate = addr;\n        continue;\n        }\n\n      DEBUG(D_deliver|D_route) debug_printf(\"unique = %s\\n\", addr->unique);\n\n      /* Check for previous delivery */\n\n      if (tree_search(tree_nonrecipients, addr->unique))\n        {\n        DEBUG(D_deliver|D_route)\n          debug_printf(\"%s was previously delivered: discarded\\n\", addr->address);\n        child_done(addr, tod_stamp(tod_log));\n        continue;\n        }\n\n      /* Save for checking future duplicates */\n\n      tree_add_duplicate(addr->unique, addr);\n\n      /* Set local part and domain */\n\n      addr->local_part = addr->address;\n      addr->domain = addr->parent->domain;\n\n      /* Ensure that the delivery is permitted. */\n\n      if (testflag(addr, af_file))\n        {\n        if (!testflag(addr, af_allow_file))\n          {\n          addr->basic_errno = ERRNO_FORBIDFILE;\n          addr->message = US\"delivery to file forbidden\";\n          (void)post_process_one(addr, FAIL, LOG_MAIN, EXIM_DTYPE_ROUTER, 0);\n          continue;   /* with the next new address */\n          }\n        }\n      else if (addr->address[0] == '|')\n        {\n        if (!testflag(addr, af_allow_pipe))\n          {\n          addr->basic_errno = ERRNO_FORBIDPIPE;\n          addr->message = US\"delivery to pipe forbidden\";\n          (void)post_process_one(addr, FAIL, LOG_MAIN, EXIM_DTYPE_ROUTER, 0);\n          continue;   /* with the next new address */\n          }\n        }\n      else if (!testflag(addr, af_allow_reply))\n        {\n        addr->basic_errno = ERRNO_FORBIDREPLY;\n        addr->message = US\"autoreply forbidden\";\n        (void)post_process_one(addr, FAIL, LOG_MAIN, EXIM_DTYPE_ROUTER, 0);\n        continue;     /* with the next new address */\n        }\n\n      /* If the errno field is already set to BADTRANSPORT, it indicates\n      failure to expand a transport string, or find the associated transport,\n      or an unset transport when one is required. Leave this test till now so\n      that the forbid errors are given in preference. */\n\n      if (addr->basic_errno == ERRNO_BADTRANSPORT)\n        {\n        (void)post_process_one(addr, DEFER, LOG_MAIN, EXIM_DTYPE_ROUTER, 0);\n        continue;\n        }\n\n      /* Treat /dev/null as a special case and abandon the delivery. This\n      avoids having to specify a uid on the transport just for this case.\n      Arrange for the transport name to be logged as \"**bypassed**\". */\n\n      if (Ustrcmp(addr->address, \"/dev/null\") == 0)\n        {\n        uschar *save = addr->transport->name;\n        addr->transport->name = US\"**bypassed**\";\n        (void)post_process_one(addr, OK, LOG_MAIN, EXIM_DTYPE_TRANSPORT, '=');\n        addr->transport->name = save;\n        continue;   /* with the next new address */\n        }\n\n      /* Pipe, file, or autoreply delivery is to go ahead as a normal local\n      delivery. */\n\n      DEBUG(D_deliver|D_route)\n        debug_printf(\"queued for %s transport\\n\", addr->transport->name);\n      addr->next = addr_local;\n      addr_local = addr;\n      continue;       /* with the next new address */\n      }\n\n    /* Handle normal addresses. First, split up into local part and domain,\n    handling the %-hack if necessary. There is the possibility of a defer from\n    a lookup in percent_hack_domains. */\n\n    if ((rc = deliver_split_address(addr)) == DEFER)\n      {\n      addr->message = US\"cannot check percent_hack_domains\";\n      addr->basic_errno = ERRNO_LISTDEFER;\n      (void)post_process_one(addr, DEFER, LOG_MAIN, EXIM_DTYPE_NONE, 0);\n      continue;\n      }\n\n    /* Check to see if the domain is held. If so, proceed only if the\n    delivery was forced by hand. */\n\n    deliver_domain = addr->domain;  /* set $domain */\n    if (  !forced && hold_domains\n       && (rc = match_isinlist(addr->domain, (const uschar **)&hold_domains, 0,\n           &domainlist_anchor, addr->domain_cache, MCL_DOMAIN, TRUE,\n           NULL)) != FAIL\n       )\n      {\n      if (rc == DEFER)\n        {\n        addr->message = US\"hold_domains lookup deferred\";\n        addr->basic_errno = ERRNO_LISTDEFER;\n        }\n      else\n        {\n        addr->message = US\"domain is held\";\n        addr->basic_errno = ERRNO_HELD;\n        }\n      (void)post_process_one(addr, DEFER, LOG_MAIN, EXIM_DTYPE_NONE, 0);\n      continue;\n      }\n\n    /* Now we can check for duplicates and previously delivered addresses. In\n    order to do this, we have to generate a \"unique\" value for each address,\n    because there may be identical actual addresses in a line of descendents.\n    The \"unique\" field is initialized to the same value as the \"address\" field,\n    but gets changed here to cope with identically-named descendents. */\n\n    for (parent = addr->parent; parent; parent = parent->parent)\n      if (strcmpic(addr->address, parent->address) == 0) break;\n\n    /* If there's an ancestor with the same name, set the homonym flag. This\n    influences how deliveries are recorded. Then add a prefix on the front of\n    the unique address. We use \\n\\ where n starts at 0 and increases each time.\n    It is unlikely to pass 9, but if it does, it may look odd but will still\n    work. This means that siblings or cousins with the same names are treated\n    as duplicates, which is what we want. */\n\n    if (parent)\n      {\n      setflag(addr, af_homonym);\n      if (parent->unique[0] != '\\\\')\n        addr->unique = string_sprintf(\"\\\\0\\\\%s\", addr->address);\n      else\n        addr->unique = string_sprintf(\"\\\\%c\\\\%s\", parent->unique[1] + 1,\n          addr->address);\n      }\n\n    /* Ensure that the domain in the unique field is lower cased, because\n    domains are always handled caselessly. */\n\n    p = Ustrrchr(addr->unique, '@');\n    while (*p != 0) { *p = tolower(*p); p++; }\n\n    DEBUG(D_deliver|D_route) debug_printf(\"unique = %s\\n\", addr->unique);\n\n    if (tree_search(tree_nonrecipients, addr->unique))\n      {\n      DEBUG(D_deliver|D_route)\n        debug_printf(\"%s was previously delivered: discarded\\n\", addr->unique);\n      child_done(addr, tod_stamp(tod_log));\n      continue;\n      }\n\n    /* Get the routing retry status, saving the two retry keys (with and\n    without the local part) for subsequent use. If there is no retry record for\n    the standard address routing retry key, we look for the same key with the\n    sender attached, because this form is used by the smtp transport after a\n    4xx response to RCPT when address_retry_include_sender is true. */\n\n    addr->domain_retry_key = string_sprintf(\"R:%s\", addr->domain);\n    addr->address_retry_key = string_sprintf(\"R:%s@%s\", addr->local_part,\n      addr->domain);\n\n    if (dbm_file)\n      {\n      domain_retry_record = dbfn_read(dbm_file, addr->domain_retry_key);\n      if (  domain_retry_record\n         && now - domain_retry_record->time_stamp > retry_data_expire\n\t )\n        domain_retry_record = NULL;    /* Ignore if too old */\n\n      address_retry_record = dbfn_read(dbm_file, addr->address_retry_key);\n      if (  address_retry_record\n         && now - address_retry_record->time_stamp > retry_data_expire\n\t )\n        address_retry_record = NULL;   /* Ignore if too old */\n\n      if (!address_retry_record)\n        {\n        uschar *altkey = string_sprintf(\"%s:<%s>\", addr->address_retry_key,\n          sender_address);\n        address_retry_record = dbfn_read(dbm_file, altkey);\n        if (  address_retry_record\n\t   && now - address_retry_record->time_stamp > retry_data_expire)\n          address_retry_record = NULL;   /* Ignore if too old */\n        }\n      }\n    else\n      domain_retry_record = address_retry_record = NULL;\n\n    DEBUG(D_deliver|D_retry)\n      {\n      if (!domain_retry_record)\n        debug_printf(\"no domain retry record\\n\");\n      if (!address_retry_record)\n        debug_printf(\"no address retry record\\n\");\n      }\n\n    /* If we are sending a message down an existing SMTP connection, we must\n    assume that the message which created the connection managed to route\n    an address to that connection. We do not want to run the risk of taking\n    a long time over routing here, because if we do, the server at the other\n    end of the connection may time it out. This is especially true for messages\n    with lots of addresses. For this kind of delivery, queue_running is not\n    set, so we would normally route all addresses. We take a pragmatic approach\n    and defer routing any addresses that have any kind of domain retry record.\n    That is, we don't even look at their retry times. It doesn't matter if this\n    doesn't work occasionally. This is all just an optimization, after all.\n\n    The reason for not doing the same for address retries is that they normally\n    arise from 4xx responses, not DNS timeouts. */\n\n    if (continue_hostname && domain_retry_record)\n      {\n      addr->message = US\"reusing SMTP connection skips previous routing defer\";\n      addr->basic_errno = ERRNO_RRETRY;\n      (void)post_process_one(addr, DEFER, LOG_MAIN, EXIM_DTYPE_ROUTER, 0);\n      }\n\n    /* If we are in a queue run, defer routing unless there is no retry data or\n    we've passed the next retry time, or this message is forced. In other\n    words, ignore retry data when not in a queue run.\n\n    However, if the domain retry time has expired, always allow the routing\n    attempt. If it fails again, the address will be failed. This ensures that\n    each address is routed at least once, even after long-term routing\n    failures.\n\n    If there is an address retry, check that too; just wait for the next\n    retry time. This helps with the case when the temporary error on the\n    address was really message-specific rather than address specific, since\n    it allows other messages through.\n\n    We also wait for the next retry time if this is a message sent down an\n    existing SMTP connection (even though that will be forced). Otherwise there\n    will be far too many attempts for an address that gets a 4xx error. In\n    fact, after such an error, we should not get here because, the host should\n    not be remembered as one this message needs. However, there was a bug that\n    used to cause this to  happen, so it is best to be on the safe side.\n\n    Even if we haven't reached the retry time in the hints, there is one more\n    check to do, which is for the ultimate address timeout. We only do this\n    check if there is an address retry record and there is not a domain retry\n    record; this implies that previous attempts to handle the address had the\n    retry_use_local_parts option turned on. We use this as an approximation\n    for the destination being like a local delivery, for example delivery over\n    LMTP to an IMAP message store. In this situation users are liable to bump\n    into their quota and thereby have intermittently successful deliveries,\n    which keep the retry record fresh, which can lead to us perpetually\n    deferring messages. */\n\n    else if (  (  f.queue_running && !f.deliver_force\n\t       || continue_hostname\n\t       )\n            && (  (  domain_retry_record\n\t\t  && now < domain_retry_record->next_try\n\t\t  && !domain_retry_record->expired\n\t\t  )\n\t       || (  address_retry_record\n\t\t  && now < address_retry_record->next_try\n\t       )  )\n            && (  domain_retry_record\n\t       || !address_retry_record\n\t       || !retry_ultimate_address_timeout(addr->address_retry_key,\n\t\t\t\t addr->domain, address_retry_record, now)\n\t    )  )\n      {\n      addr->message = US\"retry time not reached\";\n      addr->basic_errno = ERRNO_RRETRY;\n      (void)post_process_one(addr, DEFER, LOG_MAIN, EXIM_DTYPE_ROUTER, 0);\n      }\n\n    /* The domain is OK for routing. Remember if retry data exists so it\n    can be cleaned up after a successful delivery. */\n\n    else\n      {\n      if (domain_retry_record || address_retry_record)\n        setflag(addr, af_dr_retry_exists);\n      addr->next = addr_route;\n      addr_route = addr;\n      DEBUG(D_deliver|D_route)\n        debug_printf(\"%s: queued for routing\\n\", addr->address);\n      }\n    }\n\n  /* The database is closed while routing is actually happening. Requests to\n  update it are put on a chain and all processed together at the end. */\n\n  if (dbm_file) dbfn_close(dbm_file);\n\n  /* If queue_domains is set, we don't even want to try routing addresses in\n  those domains. During queue runs, queue_domains is forced to be unset.\n  Optimize by skipping this pass through the addresses if nothing is set. */\n\n  if (!f.deliver_force && queue_domains)\n    {\n    address_item *okaddr = NULL;\n    while (addr_route)\n      {\n      address_item *addr = addr_route;\n      addr_route = addr->next;\n\n      deliver_domain = addr->domain;  /* set $domain */\n      if ((rc = match_isinlist(addr->domain, (const uschar **)&queue_domains, 0,\n            &domainlist_anchor, addr->domain_cache, MCL_DOMAIN, TRUE, NULL))\n              != OK)\n        if (rc == DEFER)\n          {\n          addr->basic_errno = ERRNO_LISTDEFER;\n          addr->message = US\"queue_domains lookup deferred\";\n          (void)post_process_one(addr, DEFER, LOG_MAIN, EXIM_DTYPE_ROUTER, 0);\n          }\n        else\n          {\n          addr->next = okaddr;\n          okaddr = addr;\n          }\n      else\n        {\n        addr->basic_errno = ERRNO_QUEUE_DOMAIN;\n        addr->message = US\"domain is in queue_domains\";\n        (void)post_process_one(addr, DEFER, LOG_MAIN, EXIM_DTYPE_ROUTER, 0);\n        }\n      }\n\n    addr_route = okaddr;\n    }\n\n  /* Now route those addresses that are not deferred. */\n\n  while (addr_route)\n    {\n    int rc;\n    address_item *addr = addr_route;\n    const uschar *old_domain = addr->domain;\n    uschar *old_unique = addr->unique;\n    addr_route = addr->next;\n    addr->next = NULL;\n\n    /* Just in case some router parameter refers to it. */\n\n    if (!(return_path = addr->prop.errors_address))\n      return_path = sender_address;\n\n    /* If a router defers an address, add a retry item. Whether or not to\n    use the local part in the key is a property of the router. */\n\n    if ((rc = route_address(addr, &addr_local, &addr_remote, &addr_new,\n         &addr_succeed, v_none)) == DEFER)\n      retry_add_item(addr,\n        addr->router->retry_use_local_part\n        ? string_sprintf(\"R:%s@%s\", addr->local_part, addr->domain)\n\t: string_sprintf(\"R:%s\", addr->domain),\n\t0);\n\n    /* Otherwise, if there is an existing retry record in the database, add\n    retry items to delete both forms. We must also allow for the possibility\n    of a routing retry that includes the sender address. Since the domain might\n    have been rewritten (expanded to fully qualified) as a result of routing,\n    ensure that the rewritten form is also deleted. */\n\n    else if (testflag(addr, af_dr_retry_exists))\n      {\n      uschar *altkey = string_sprintf(\"%s:<%s>\", addr->address_retry_key,\n        sender_address);\n      retry_add_item(addr, altkey, rf_delete);\n      retry_add_item(addr, addr->address_retry_key, rf_delete);\n      retry_add_item(addr, addr->domain_retry_key, rf_delete);\n      if (Ustrcmp(addr->domain, old_domain) != 0)\n        retry_add_item(addr, string_sprintf(\"R:%s\", old_domain), rf_delete);\n      }\n\n    /* DISCARD is given for :blackhole: and \"seen finish\". The event has been\n    logged, but we need to ensure the address (and maybe parents) is marked\n    done. */\n\n    if (rc == DISCARD)\n      {\n      address_done(addr, tod_stamp(tod_log));\n      continue;  /* route next address */\n      }\n\n    /* The address is finished with (failed or deferred). */\n\n    if (rc != OK)\n      {\n      (void)post_process_one(addr, rc, LOG_MAIN, EXIM_DTYPE_ROUTER, 0);\n      continue;  /* route next address */\n      }\n\n    /* The address has been routed. If the router changed the domain, it will\n    also have changed the unique address. We have to test whether this address\n    has already been delivered, because it's the unique address that finally\n    gets recorded. */\n\n    if (  addr->unique != old_unique\n       && tree_search(tree_nonrecipients, addr->unique) != 0\n       )\n      {\n      DEBUG(D_deliver|D_route) debug_printf(\"%s was previously delivered: \"\n        \"discarded\\n\", addr->address);\n      if (addr_remote == addr) addr_remote = addr->next;\n      else if (addr_local == addr) addr_local = addr->next;\n      }\n\n    /* If the router has same_domain_copy_routing set, we are permitted to copy\n    the routing for any other addresses with the same domain. This is an\n    optimisation to save repeated DNS lookups for \"standard\" remote domain\n    routing. The option is settable only on routers that generate host lists.\n    We play it very safe, and do the optimization only if the address is routed\n    to a remote transport, there are no header changes, and the domain was not\n    modified by the router. */\n\n    if (  addr_remote == addr\n       && addr->router->same_domain_copy_routing\n       && !addr->prop.extra_headers\n       && !addr->prop.remove_headers\n       && old_domain == addr->domain\n       )\n      {\n      address_item **chain = &addr_route;\n      while (*chain)\n        {\n        address_item *addr2 = *chain;\n        if (Ustrcmp(addr2->domain, addr->domain) != 0)\n          {\n          chain = &(addr2->next);\n          continue;\n          }\n\n        /* Found a suitable address; take it off the routing list and add it to\n        the remote delivery list. */\n\n        *chain = addr2->next;\n        addr2->next = addr_remote;\n        addr_remote = addr2;\n\n        /* Copy the routing data */\n\n        addr2->domain = addr->domain;\n        addr2->router = addr->router;\n        addr2->transport = addr->transport;\n        addr2->host_list = addr->host_list;\n        addr2->fallback_hosts = addr->fallback_hosts;\n        addr2->prop.errors_address = addr->prop.errors_address;\n        copyflag(addr2, addr, af_hide_child);\n        copyflag(addr2, addr, af_local_host_removed);\n\n        DEBUG(D_deliver|D_route)\n          debug_printf(\">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\\n\"\n                       \"routing %s\\n\"\n                       \"Routing for %s copied from %s\\n\",\n            addr2->address, addr2->address, addr->address);\n        }\n      }\n    }  /* Continue with routing the next address. */\n  }    /* Loop to process any child addresses that the routers created, and\n          any rerouted addresses that got put back on the new chain. */\n\n\n/* Debugging: show the results of the routing */\n\nDEBUG(D_deliver|D_retry|D_route)\n  {\n  address_item *p;\n  debug_printf(\">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\\n\");\n  debug_printf(\"After routing:\\n  Local deliveries:\\n\");\n  for (p = addr_local; p; p = p->next)\n    debug_printf(\"    %s\\n\", p->address);\n\n  debug_printf(\"  Remote deliveries:\\n\");\n  for (p = addr_remote; p; p = p->next)\n    debug_printf(\"    %s\\n\", p->address);\n\n  debug_printf(\"  Failed addresses:\\n\");\n  for (p = addr_failed; p; p = p->next)\n    debug_printf(\"    %s\\n\", p->address);\n\n  debug_printf(\"  Deferred addresses:\\n\");\n  for (p = addr_defer; p; p = p->next)\n    debug_printf(\"    %s\\n\", p->address);\n  }\n\n/* Free any resources that were cached during routing. */\n\nsearch_tidyup();\nroute_tidyup();\n\n/* These two variables are set only during routing, after check_local_user.\nEnsure they are not set in transports. */\n\nlocal_user_gid = (gid_t)(-1);\nlocal_user_uid = (uid_t)(-1);\n\n/* Check for any duplicate addresses. This check is delayed until after\nrouting, because the flexibility of the routing configuration means that\nidentical addresses with different parentage may end up being redirected to\ndifferent addresses. Checking for duplicates too early (as we previously used\nto) makes this kind of thing not work. */\n\ndo_duplicate_check(&addr_local);\ndo_duplicate_check(&addr_remote);\n\n/* When acting as an MUA wrapper, we proceed only if all addresses route to a\nremote transport. The check that they all end up in one transaction happens in\nthe do_remote_deliveries() function. */\n\nif (  mua_wrapper\n   && (addr_local || addr_failed || addr_defer)\n   )\n  {\n  address_item *addr;\n  uschar *which, *colon, *msg;\n\n  if (addr_local)\n    {\n    addr = addr_local;\n    which = US\"local\";\n    }\n  else if (addr_defer)\n    {\n    addr = addr_defer;\n    which = US\"deferred\";\n    }\n  else\n    {\n    addr = addr_failed;\n    which = US\"failed\";\n    }\n\n  while (addr->parent) addr = addr->parent;\n\n  if (addr->message)\n    {\n    colon = US\": \";\n    msg = addr->message;\n    }\n  else colon = msg = US\"\";\n\n  /* We don't need to log here for a forced failure as it will already\n  have been logged. Defer will also have been logged, but as a defer, so we do\n  need to do the failure logging. */\n\n  if (addr != addr_failed)\n    log_write(0, LOG_MAIN, \"** %s routing yielded a %s delivery\",\n      addr->address, which);\n\n  /* Always write an error to the caller */\n\n  fprintf(stderr, \"routing %s yielded a %s delivery%s%s\\n\", addr->address,\n    which, colon, msg);\n\n  final_yield = DELIVER_MUA_FAILED;\n  addr_failed = addr_defer = NULL;   /* So that we remove the message */\n  goto DELIVERY_TIDYUP;\n  }\n\n\n/* If this is a run to continue deliveries to an external channel that is\nalready set up, defer any local deliveries. */\n\nif (continue_transport)\n  {\n  if (addr_defer)\n    {\n    address_item *addr = addr_defer;\n    while (addr->next) addr = addr->next;\n    addr->next = addr_local;\n    }\n  else\n    addr_defer = addr_local;\n  addr_local = NULL;\n  }\n\n\n/* Because address rewriting can happen in the routers, we should not really do\nANY deliveries until all addresses have been routed, so that all recipients of\nthe message get the same headers. However, this is in practice not always\npossible, since sometimes remote addresses give DNS timeouts for days on end.\nThe pragmatic approach is to deliver what we can now, saving any rewritten\nheaders so that at least the next lot of recipients benefit from the rewriting\nthat has already been done.\n\nIf any headers have been rewritten during routing, update the spool file to\nremember them for all subsequent deliveries. This can be delayed till later if\nthere is only address to be delivered - if it succeeds the spool write need not\nhappen. */\n\nif (  f.header_rewritten\n   && (  addr_local && (addr_local->next || addr_remote)\n      || addr_remote && addr_remote->next\n   )  )\n  {\n  /* Panic-dies on error */\n  (void)spool_write_header(message_id, SW_DELIVERING, NULL);\n  f.header_rewritten = FALSE;\n  }\n\n\n/* If there are any deliveries to be and we do not already have the journal\nfile, create it. This is used to record successful deliveries as soon as\npossible after each delivery is known to be complete. A file opened with\nO_APPEND is used so that several processes can run simultaneously.\n\nThe journal is just insurance against crashes. When the spool file is\nultimately updated at the end of processing, the journal is deleted. If a\njournal is found to exist at the start of delivery, the addresses listed\ntherein are added to the non-recipients. */\n\nif (addr_local || addr_remote)\n  {\n  if (journal_fd < 0)\n    {\n    uschar * fname = spool_fname(US\"input\", message_subdir, id, US\"-J\");\n\n    if ((journal_fd = Uopen(fname,\n#ifdef O_CLOEXEC\n\t\t\tO_CLOEXEC |\n#endif\n\t\t\tO_WRONLY|O_APPEND|O_CREAT|O_EXCL, SPOOL_MODE)) < 0)\n      {\n      log_write(0, LOG_MAIN|LOG_PANIC, \"Couldn't open journal file %s: %s\",\n\tfname, strerror(errno));\n      return DELIVER_NOT_ATTEMPTED;\n      }\n\n    /* Set the close-on-exec flag, make the file owned by Exim, and ensure\n    that the mode is correct - the group setting doesn't always seem to get\n    set automatically. */\n\n    if(  fchown(journal_fd, exim_uid, exim_gid)\n      || fchmod(journal_fd, SPOOL_MODE)\n#ifndef O_CLOEXEC\n      || fcntl(journal_fd, F_SETFD, fcntl(journal_fd, F_GETFD) | FD_CLOEXEC)\n#endif\n      )\n      {\n      int ret = Uunlink(fname);\n      log_write(0, LOG_MAIN|LOG_PANIC, \"Couldn't set perms on journal file %s: %s\",\n\tfname, strerror(errno));\n      if(ret  &&  errno != ENOENT)\n\tlog_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to unlink %s: %s\",\n\t  fname, strerror(errno));\n      return DELIVER_NOT_ATTEMPTED;\n      }\n    }\n  }\nelse if (journal_fd >= 0)\n  {\n  close(journal_fd);\n  journal_fd = -1;\n  }\n\n\n\n/* Now we can get down to the business of actually doing deliveries. Local\ndeliveries are done first, then remote ones. If ever the problems of how to\nhandle fallback transports are figured out, this section can be put into a loop\nfor handling fallbacks, though the uid switching will have to be revised. */\n\n/* Precompile a regex that is used to recognize a parameter in response\nto an LHLO command, if is isn't already compiled. This may be used on both\nlocal and remote LMTP deliveries. */\n\nif (!regex_IGNOREQUOTA)\n  regex_IGNOREQUOTA =\n    regex_must_compile(US\"\\\\n250[\\\\s\\\\-]IGNOREQUOTA(\\\\s|\\\\n|$)\", FALSE, TRUE);\n\n/* Handle local deliveries */\n\nif (addr_local)\n  {\n  DEBUG(D_deliver|D_transport)\n    debug_printf(\">>>>>>>>>>>>>>>> Local deliveries >>>>>>>>>>>>>>>>\\n\");\n  do_local_deliveries();\n  f.disable_logging = FALSE;\n  }\n\n/* If queue_run_local is set, we do not want to attempt any remote deliveries,\nso just queue them all. */\n\nif (f.queue_run_local)\n  while (addr_remote)\n    {\n    address_item *addr = addr_remote;\n    addr_remote = addr->next;\n    addr->next = NULL;\n    addr->basic_errno = ERRNO_LOCAL_ONLY;\n    addr->message = US\"remote deliveries suppressed\";\n    (void)post_process_one(addr, DEFER, LOG_MAIN, EXIM_DTYPE_TRANSPORT, 0);\n    }\n\n/* Handle remote deliveries */\n\nif (addr_remote)\n  {\n  DEBUG(D_deliver|D_transport)\n    debug_printf(\">>>>>>>>>>>>>>>> Remote deliveries >>>>>>>>>>>>>>>>\\n\");\n\n  /* Precompile some regex that are used to recognize parameters in response\n  to an EHLO command, if they aren't already compiled. */\n\n  deliver_init();\n\n  /* Now sort the addresses if required, and do the deliveries. The yield of\n  do_remote_deliveries is FALSE when mua_wrapper is set and all addresses\n  cannot be delivered in one transaction. */\n\n  if (remote_sort_domains) sort_remote_deliveries();\n  if (!do_remote_deliveries(FALSE))\n    {\n    log_write(0, LOG_MAIN, \"** mua_wrapper is set but recipients cannot all \"\n      \"be delivered in one transaction\");\n    fprintf(stderr, \"delivery to smarthost failed (configuration problem)\\n\");\n\n    final_yield = DELIVER_MUA_FAILED;\n    addr_failed = addr_defer = NULL;   /* So that we remove the message */\n    goto DELIVERY_TIDYUP;\n    }\n\n  /* See if any of the addresses that failed got put on the queue for delivery\n  to their fallback hosts. We do it this way because often the same fallback\n  host is used for many domains, so all can be sent in a single transaction\n  (if appropriately configured). */\n\n  if (addr_fallback && !mua_wrapper)\n    {\n    DEBUG(D_deliver) debug_printf(\"Delivering to fallback hosts\\n\");\n    addr_remote = addr_fallback;\n    addr_fallback = NULL;\n    if (remote_sort_domains) sort_remote_deliveries();\n    do_remote_deliveries(TRUE);\n    }\n  f.disable_logging = FALSE;\n  }\n\n\n/* All deliveries are now complete. Ignore SIGTERM during this tidying up\nphase, to minimize cases of half-done things. */\n\nDEBUG(D_deliver)\n  debug_printf(\">>>>>>>>>>>>>>>> deliveries are done >>>>>>>>>>>>>>>>\\n\");\ncancel_cutthrough_connection(TRUE, US\"deliveries are done\");\n\n/* Root privilege is no longer needed */\n\nexim_setugid(exim_uid, exim_gid, FALSE, US\"post-delivery tidying\");\n\nset_process_info(\"tidying up after delivering %s\", message_id);\nsignal(SIGTERM, SIG_IGN);\n\n/* When we are acting as an MUA wrapper, the smtp transport will either have\nsucceeded for all addresses, or failed them all in normal cases. However, there\nare some setup situations (e.g. when a named port does not exist) that cause an\nimmediate exit with deferral of all addresses. Convert those into failures. We\ndo not ever want to retry, nor do we want to send a bounce message. */\n\nif (mua_wrapper)\n  {\n  if (addr_defer)\n    {\n    address_item *addr, *nextaddr;\n    for (addr = addr_defer; addr; addr = nextaddr)\n      {\n      log_write(0, LOG_MAIN, \"** %s mua_wrapper forced failure for deferred \"\n        \"delivery\", addr->address);\n      nextaddr = addr->next;\n      addr->next = addr_failed;\n      addr_failed = addr;\n      }\n    addr_defer = NULL;\n    }\n\n  /* Now all should either have succeeded or failed. */\n\n  if (!addr_failed)\n    final_yield = DELIVER_MUA_SUCCEEDED;\n  else\n    {\n    host_item * host;\n    uschar *s = addr_failed->user_message;\n\n    if (!s) s = addr_failed->message;\n\n    fprintf(stderr, \"Delivery failed: \");\n    if (addr_failed->basic_errno > 0)\n      {\n      fprintf(stderr, \"%s\", strerror(addr_failed->basic_errno));\n      if (s) fprintf(stderr, \": \");\n      }\n    if ((host = addr_failed->host_used))\n      fprintf(stderr, \"H=%s [%s]: \", host->name, host->address);\n    if (s)\n      fprintf(stderr, \"%s\", CS s);\n    else if (addr_failed->basic_errno <= 0)\n      fprintf(stderr, \"unknown error\");\n    fprintf(stderr, \"\\n\");\n\n    final_yield = DELIVER_MUA_FAILED;\n    addr_failed = NULL;\n    }\n  }\n\n/* In a normal configuration, we now update the retry database. This is done in\none fell swoop at the end in order not to keep opening and closing (and\nlocking) the database. The code for handling retries is hived off into a\nseparate module for convenience. We pass it the addresses of the various\nchains, because deferred addresses can get moved onto the failed chain if the\nretry cutoff time has expired for all alternative destinations. Bypass the\nupdating of the database if the -N flag is set, which is a debugging thing that\nprevents actual delivery. */\n\nelse if (!f.dont_deliver)\n  retry_update(&addr_defer, &addr_failed, &addr_succeed);\n\n/* Send DSN for successful messages if requested */\naddr_senddsn = NULL;\n\nfor (addr_dsntmp = addr_succeed; addr_dsntmp; addr_dsntmp = addr_dsntmp->next)\n  {\n  /* af_ignore_error not honored here. it's not an error */\n  DEBUG(D_deliver) debug_printf(\"DSN: processing router : %s\\n\"\n      \"DSN: processing successful delivery address: %s\\n\"\n      \"DSN: Sender_address: %s\\n\"\n      \"DSN: orcpt: %s  flags: %d\\n\"\n      \"DSN: envid: %s  ret: %d\\n\"\n      \"DSN: Final recipient: %s\\n\"\n      \"DSN: Remote SMTP server supports DSN: %d\\n\",\n      addr_dsntmp->router ? addr_dsntmp->router->name : US\"(unknown)\",\n      addr_dsntmp->address,\n      sender_address,\n      addr_dsntmp->dsn_orcpt ? addr_dsntmp->dsn_orcpt : US\"NULL\",\n      addr_dsntmp->dsn_flags,\n      dsn_envid ? dsn_envid : US\"NULL\", dsn_ret,\n      addr_dsntmp->address,\n      addr_dsntmp->dsn_aware\n      );\n\n  /* send report if next hop not DSN aware or a router flagged \"last DSN hop\"\n     and a report was requested */\n  if (  (  addr_dsntmp->dsn_aware != dsn_support_yes\n\t|| addr_dsntmp->dsn_flags & rf_dsnlasthop\n        )\n     && addr_dsntmp->dsn_flags & rf_dsnflags\n     && addr_dsntmp->dsn_flags & rf_notify_success\n     )\n    {\n    /* copy and relink address_item and send report with all of them at once later */\n    address_item * addr_next = addr_senddsn;\n    addr_senddsn = store_get(sizeof(address_item));\n    *addr_senddsn = *addr_dsntmp;\n    addr_senddsn->next = addr_next;\n    }\n  else\n    DEBUG(D_deliver) debug_printf(\"DSN: not sending DSN success message\\n\");\n  }\n\nif (addr_senddsn)\n  {\n  pid_t pid;\n  int fd;\n\n  /* create exim process to send message */\n  pid = child_open_exim(&fd);\n\n  DEBUG(D_deliver) debug_printf(\"DSN: child_open_exim returns: %d\\n\", pid);\n\n  if (pid < 0)  /* Creation of child failed */\n    {\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"Process %d (parent %d) failed to \"\n      \"create child process to send failure message: %s\", getpid(),\n      getppid(), strerror(errno));\n\n    DEBUG(D_deliver) debug_printf(\"DSN: child_open_exim failed\\n\");\n    }\n  else  /* Creation of child succeeded */\n    {\n    FILE *f = fdopen(fd, \"wb\");\n    /* header only as required by RFC. only failure DSN needs to honor RET=FULL */\n    uschar * bound;\n    transport_ctx tctx = {{0}};\n\n    DEBUG(D_deliver)\n      debug_printf(\"sending error message to: %s\\n\", sender_address);\n\n    /* build unique id for MIME boundary */\n    bound = string_sprintf(TIME_T_FMT \"-eximdsn-%d\", time(NULL), rand());\n    DEBUG(D_deliver) debug_printf(\"DSN: MIME boundary: %s\\n\", bound);\n\n    if (errors_reply_to)\n      fprintf(f, \"Reply-To: %s\\n\", errors_reply_to);\n\n    fprintf(f, \"Auto-Submitted: auto-generated\\n\"\n\t\"From: Mail Delivery System <Mailer-Daemon@%s>\\n\"\n\t\"To: %s\\n\"\n\t\"Subject: Delivery Status Notification\\n\"\n\t\"Content-Type: multipart/report; report-type=delivery-status; boundary=%s\\n\"\n\t\"MIME-Version: 1.0\\n\\n\"\n\n\t\"--%s\\n\"\n\t\"Content-type: text/plain; charset=us-ascii\\n\\n\"\n\n\t\"This message was created automatically by mail delivery software.\\n\"\n\t\" ----- The following addresses had successful delivery notifications -----\\n\",\n      qualify_domain_sender, sender_address, bound, bound);\n\n    for (addr_dsntmp = addr_senddsn; addr_dsntmp;\n\t addr_dsntmp = addr_dsntmp->next)\n      fprintf(f, \"<%s> (relayed %s)\\n\\n\",\n\taddr_dsntmp->address,\n\t(addr_dsntmp->dsn_flags & rf_dsnlasthop) == 1\n\t  ? \"via non DSN router\"\n\t  : addr_dsntmp->dsn_aware == dsn_support_no\n\t  ? \"to non-DSN-aware mailer\"\n\t  : \"via non \\\"Remote SMTP\\\" router\"\n\t);\n\n    fprintf(f, \"--%s\\n\"\n\t\"Content-type: message/delivery-status\\n\\n\"\n\t\"Reporting-MTA: dns; %s\\n\",\n      bound, smtp_active_hostname);\n\n    if (dsn_envid)\n      {\t\t\t/* must be decoded from xtext: see RFC 3461:6.3a */\n      uschar *xdec_envid;\n      if (auth_xtextdecode(dsn_envid, &xdec_envid) > 0)\n        fprintf(f, \"Original-Envelope-ID: %s\\n\", dsn_envid);\n      else\n        fprintf(f, \"X-Original-Envelope-ID: error decoding xtext formatted ENVID\\n\");\n      }\n    fputc('\\n', f);\n\n    for (addr_dsntmp = addr_senddsn;\n\t addr_dsntmp;\n\t addr_dsntmp = addr_dsntmp->next)\n      {\n      if (addr_dsntmp->dsn_orcpt)\n        fprintf(f,\"Original-Recipient: %s\\n\", addr_dsntmp->dsn_orcpt);\n\n      fprintf(f, \"Action: delivered\\n\"\n\t  \"Final-Recipient: rfc822;%s\\n\"\n\t  \"Status: 2.0.0\\n\",\n\taddr_dsntmp->address);\n\n      if (addr_dsntmp->host_used && addr_dsntmp->host_used->name)\n        fprintf(f, \"Remote-MTA: dns; %s\\nDiagnostic-Code: smtp; 250 Ok\\n\\n\",\n\t  addr_dsntmp->host_used->name);\n      else\n\tfprintf(f, \"Diagnostic-Code: X-Exim; relayed via non %s router\\n\\n\",\n\t  (addr_dsntmp->dsn_flags & rf_dsnlasthop) == 1 ? \"DSN\" : \"SMTP\");\n      }\n\n    fprintf(f, \"--%s\\nContent-type: text/rfc822-headers\\n\\n\", bound);\n\n    fflush(f);\n    transport_filter_argv = NULL;   /* Just in case */\n    return_path = sender_address;   /* In case not previously set */\n\n    /* Write the original email out */\n\n    tctx.u.fd = fileno(f);\n    tctx.options = topt_add_return_path | topt_no_body;\n    transport_write_message(&tctx, 0);\n    fflush(f);\n\n    fprintf(f,\"\\n--%s--\\n\", bound);\n\n    fflush(f);\n    fclose(f);\n    rc = child_close(pid, 0);     /* Waits for child to close, no timeout */\n    }\n  }\n\n/* If any addresses failed, we must send a message to somebody, unless\naf_ignore_error is set, in which case no action is taken. It is possible for\nseveral messages to get sent if there are addresses with different\nrequirements. */\n\nwhile (addr_failed)\n  {\n  pid_t pid;\n  int fd;\n  uschar *logtod = tod_stamp(tod_log);\n  address_item *addr;\n  address_item *handled_addr = NULL;\n  address_item **paddr;\n  address_item *msgchain = NULL;\n  address_item **pmsgchain = &msgchain;\n\n  /* There are weird cases when logging is disabled in the transport. However,\n  there may not be a transport (address failed by a router). */\n\n  f.disable_logging = FALSE;\n  if (addr_failed->transport)\n    f.disable_logging = addr_failed->transport->disable_logging;\n\n  DEBUG(D_deliver)\n    debug_printf(\"processing failed address %s\\n\", addr_failed->address);\n\n  /* There are only two ways an address in a bounce message can get here:\n\n  (1) When delivery was initially deferred, but has now timed out (in the call\n      to retry_update() above). We can detect this by testing for\n      af_retry_timedout. If the address does not have its own errors address,\n      we arrange to ignore the error.\n\n  (2) If delivery failures for bounce messages are being ignored. We can detect\n      this by testing for af_ignore_error. This will also be set if a bounce\n      message has been autothawed and the ignore_bounce_errors_after time has\n      passed. It might also be set if a router was explicitly configured to\n      ignore errors (errors_to = \"\").\n\n  If neither of these cases obtains, something has gone wrong. Log the\n  incident, but then ignore the error. */\n\n  if (sender_address[0] == 0 && !addr_failed->prop.errors_address)\n    {\n    if (  !testflag(addr_failed, af_retry_timedout)\n       && !addr_failed->prop.ignore_error)\n      log_write(0, LOG_MAIN|LOG_PANIC, \"internal error: bounce message \"\n        \"failure is neither frozen nor ignored (it's been ignored)\");\n\n    addr_failed->prop.ignore_error = TRUE;\n    }\n\n  /* If the first address on the list has af_ignore_error set, just remove\n  it from the list, throw away any saved message file, log it, and\n  mark the recipient done. */\n\n  if (  addr_failed->prop.ignore_error\n     || (  addr_failed->dsn_flags & rf_dsnflags\n        && (addr_failed->dsn_flags & rf_notify_failure) != rf_notify_failure\n     )  )\n    {\n    addr = addr_failed;\n    addr_failed = addr->next;\n    if (addr->return_filename) Uunlink(addr->return_filename);\n\n    log_write(0, LOG_MAIN, \"%s%s%s%s: error ignored\",\n      addr->address,\n      !addr->parent ? US\"\" : US\" <\",\n      !addr->parent ? US\"\" : addr->parent->address,\n      !addr->parent ? US\"\" : US\">\");\n\n    address_done(addr, logtod);\n    child_done(addr, logtod);\n    /* Panic-dies on error */\n    (void)spool_write_header(message_id, SW_DELIVERING, NULL);\n    }\n\n  /* Otherwise, handle the sending of a message. Find the error address for\n  the first address, then send a message that includes all failed addresses\n  that have the same error address. Note the bounce_recipient is a global so\n  that it can be accessed by $bounce_recipient while creating a customized\n  error message. */\n\n  else\n    {\n    if (!(bounce_recipient = addr_failed->prop.errors_address))\n      bounce_recipient = sender_address;\n\n    /* Make a subprocess to send a message */\n\n    if ((pid = child_open_exim(&fd)) < 0)\n      log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"Process %d (parent %d) failed to \"\n        \"create child process to send failure message: %s\", getpid(),\n        getppid(), strerror(errno));\n\n    /* Creation of child succeeded */\n\n    else\n      {\n      int ch, rc;\n      int filecount = 0;\n      int rcount = 0;\n      uschar *bcc, *emf_text;\n      FILE * fp = fdopen(fd, \"wb\");\n      FILE * emf = NULL;\n      BOOL to_sender = strcmpic(sender_address, bounce_recipient) == 0;\n      int max = (bounce_return_size_limit/DELIVER_IN_BUFFER_SIZE + 1) *\n        DELIVER_IN_BUFFER_SIZE;\n      uschar * bound;\n      uschar *dsnlimitmsg;\n      uschar *dsnnotifyhdr;\n      int topt;\n\n      DEBUG(D_deliver)\n        debug_printf(\"sending error message to: %s\\n\", bounce_recipient);\n\n      /* Scan the addresses for all that have the same errors address, removing\n      them from the addr_failed chain, and putting them on msgchain. */\n\n      paddr = &addr_failed;\n      for (addr = addr_failed; addr; addr = *paddr)\n        if (Ustrcmp(bounce_recipient, addr->prop.errors_address\n\t      ? addr->prop.errors_address : sender_address) == 0)\n          {                          /* The same - dechain */\n          *paddr = addr->next;\n          *pmsgchain = addr;\n          addr->next = NULL;\n          pmsgchain = &(addr->next);\n          }\n        else\n          paddr = &addr->next;        /* Not the same; skip */\n\n      /* Include X-Failed-Recipients: for automatic interpretation, but do\n      not let any one header line get too long. We do this by starting a\n      new header every 50 recipients. Omit any addresses for which the\n      \"hide_child\" flag is set. */\n\n      for (addr = msgchain; addr; addr = addr->next)\n        {\n        if (testflag(addr, af_hide_child)) continue;\n        if (rcount >= 50)\n          {\n          fprintf(fp, \"\\n\");\n          rcount = 0;\n          }\n        fprintf(fp, \"%s%s\",\n          rcount++ == 0\n\t  ? \"X-Failed-Recipients: \"\n\t  : \",\\n  \",\n          testflag(addr, af_pfr) && addr->parent\n\t  ? string_printing(addr->parent->address)\n\t  : string_printing(addr->address));\n        }\n      if (rcount > 0) fprintf(fp, \"\\n\");\n\n      /* Output the standard headers */\n\n      if (errors_reply_to)\n        fprintf(fp, \"Reply-To: %s\\n\", errors_reply_to);\n      fprintf(fp, \"Auto-Submitted: auto-replied\\n\");\n      moan_write_from(fp);\n      fprintf(fp, \"To: %s\\n\", bounce_recipient);\n\n      /* generate boundary string and output MIME-Headers */\n      bound = string_sprintf(TIME_T_FMT \"-eximdsn-%d\", time(NULL), rand());\n\n      fprintf(fp, \"Content-Type: multipart/report;\"\n\t    \" report-type=delivery-status; boundary=%s\\n\"\n\t  \"MIME-Version: 1.0\\n\",\n\tbound);\n\n      /* Open a template file if one is provided. Log failure to open, but\n      carry on - default texts will be used. */\n\n      if (bounce_message_file)\n        if (!(emf = Ufopen(bounce_message_file, \"rb\")))\n          log_write(0, LOG_MAIN|LOG_PANIC, \"Failed to open %s for error \"\n            \"message texts: %s\", bounce_message_file, strerror(errno));\n\n      /* Quietly copy to configured additional addresses if required. */\n\n      if ((bcc = moan_check_errorcopy(bounce_recipient)))\n\tfprintf(fp, \"Bcc: %s\\n\", bcc);\n\n      /* The texts for the message can be read from a template file; if there\n      isn't one, or if it is too short, built-in texts are used. The first\n      emf text is a Subject: and any other headers. */\n\n      if ((emf_text = next_emf(emf, US\"header\")))\n\tfprintf(fp, \"%s\\n\", emf_text);\n      else\n        fprintf(fp, \"Subject: Mail delivery failed%s\\n\\n\",\n          to_sender? \": returning message to sender\" : \"\");\n\n      /* output human readable part as text/plain section */\n      fprintf(fp, \"--%s\\n\"\n\t  \"Content-type: text/plain; charset=us-ascii\\n\\n\",\n\tbound);\n\n      if ((emf_text = next_emf(emf, US\"intro\")))\n\tfprintf(fp, \"%s\", CS emf_text);\n      else\n        {\n        fprintf(fp,\n/* This message has been reworded several times. It seems to be confusing to\nsomebody, however it is worded. I have retreated to the original, simple\nwording. */\n\"This message was created automatically by mail delivery software.\\n\");\n\n        if (bounce_message_text)\n\t  fprintf(fp, \"%s\", CS bounce_message_text);\n        if (to_sender)\n          fprintf(fp,\n\"\\nA message that you sent could not be delivered to one or more of its\\n\"\n\"recipients. This is a permanent error. The following address(es) failed:\\n\");\n        else\n          fprintf(fp,\n\"\\nA message sent by\\n\\n  <%s>\\n\\n\"\n\"could not be delivered to one or more of its recipients. The following\\n\"\n\"address(es) failed:\\n\", sender_address);\n        }\n      fputc('\\n', fp);\n\n      /* Process the addresses, leaving them on the msgchain if they have a\n      file name for a return message. (There has already been a check in\n      post_process_one() for the existence of data in the message file.) A TRUE\n      return from print_address_information() means that the address is not\n      hidden. */\n\n      paddr = &msgchain;\n      for (addr = msgchain; addr; addr = *paddr)\n        {\n        if (print_address_information(addr, fp, US\"  \", US\"\\n    \", US\"\"))\n          print_address_error(addr, fp, US\"\");\n\n        /* End the final line for the address */\n\n        fputc('\\n', fp);\n\n        /* Leave on msgchain if there's a return file. */\n\n        if (addr->return_file >= 0)\n          {\n          paddr = &(addr->next);\n          filecount++;\n          }\n\n        /* Else save so that we can tick off the recipient when the\n        message is sent. */\n\n        else\n          {\n          *paddr = addr->next;\n          addr->next = handled_addr;\n          handled_addr = addr;\n          }\n        }\n\n      fputc('\\n', fp);\n\n      /* Get the next text, whether we need it or not, so as to be\n      positioned for the one after. */\n\n      emf_text = next_emf(emf, US\"generated text\");\n\n      /* If there were any file messages passed by the local transports,\n      include them in the message. Then put the address on the handled chain.\n      In the case of a batch of addresses that were all sent to the same\n      transport, the return_file field in all of them will contain the same\n      fd, and the return_filename field in the *last* one will be set (to the\n      name of the file). */\n\n      if (msgchain)\n        {\n        address_item *nextaddr;\n\n        if (emf_text)\n\t  fprintf(fp, \"%s\", CS emf_text);\n\telse\n          fprintf(fp,\n            \"The following text was generated during the delivery \"\n            \"attempt%s:\\n\", (filecount > 1)? \"s\" : \"\");\n\n        for (addr = msgchain; addr; addr = nextaddr)\n          {\n          FILE *fm;\n          address_item *topaddr = addr;\n\n          /* List all the addresses that relate to this file */\n\n\t  fputc('\\n', fp);\n          while(addr)                   /* Insurance */\n            {\n            print_address_information(addr, fp, US\"------ \",  US\"\\n       \",\n              US\" ------\\n\");\n            if (addr->return_filename) break;\n            addr = addr->next;\n            }\n\t  fputc('\\n', fp);\n\n          /* Now copy the file */\n\n          if (!(fm = Ufopen(addr->return_filename, \"rb\")))\n            fprintf(fp, \"    +++ Exim error... failed to open text file: %s\\n\",\n              strerror(errno));\n          else\n            {\n            while ((ch = fgetc(fm)) != EOF) fputc(ch, fp);\n            (void)fclose(fm);\n            }\n          Uunlink(addr->return_filename);\n\n          /* Can now add to handled chain, first fishing off the next\n          address on the msgchain. */\n\n          nextaddr = addr->next;\n          addr->next = handled_addr;\n          handled_addr = topaddr;\n          }\n\tfputc('\\n', fp);\n        }\n\n      /* output machine readable part */\n#ifdef SUPPORT_I18N\n      if (message_smtputf8)\n\tfprintf(fp, \"--%s\\n\"\n\t    \"Content-type: message/global-delivery-status\\n\\n\"\n\t    \"Reporting-MTA: dns; %s\\n\",\n\t  bound, smtp_active_hostname);\n      else\n#endif\n\tfprintf(fp, \"--%s\\n\"\n\t    \"Content-type: message/delivery-status\\n\\n\"\n\t    \"Reporting-MTA: dns; %s\\n\",\n\t  bound, smtp_active_hostname);\n\n      if (dsn_envid)\n\t{\n        /* must be decoded from xtext: see RFC 3461:6.3a */\n        uschar *xdec_envid;\n        if (auth_xtextdecode(dsn_envid, &xdec_envid) > 0)\n          fprintf(fp, \"Original-Envelope-ID: %s\\n\", dsn_envid);\n        else\n          fprintf(fp, \"X-Original-Envelope-ID: error decoding xtext formatted ENVID\\n\");\n        }\n      fputc('\\n', fp);\n\n      for (addr = handled_addr; addr; addr = addr->next)\n        {\n\thost_item * hu;\n        fprintf(fp, \"Action: failed\\n\"\n\t    \"Final-Recipient: rfc822;%s\\n\"\n\t    \"Status: 5.0.0\\n\",\n\t    addr->address);\n        if ((hu = addr->host_used) && hu->name)\n\t  {\n\t  fprintf(fp, \"Remote-MTA: dns; %s\\n\", hu->name);\n#ifdef EXPERIMENTAL_DSN_INFO\n\t  {\n\t  const uschar * s;\n\t  if (hu->address)\n\t    {\n\t    uschar * p = hu->port == 25\n\t      ? US\"\" : string_sprintf(\":%d\", hu->port);\n\t    fprintf(fp, \"Remote-MTA: X-ip; [%s]%s\\n\", hu->address, p);\n\t    }\n\t  if ((s = addr->smtp_greeting) && *s)\n\t    fprintf(fp, \"X-Remote-MTA-smtp-greeting: X-str; %s\\n\", s);\n\t  if ((s = addr->helo_response) && *s)\n\t    fprintf(fp, \"X-Remote-MTA-helo-response: X-str; %s\\n\", s);\n\t  if ((s = addr->message) && *s)\n\t    fprintf(fp, \"X-Exim-Diagnostic: X-str; %s\\n\", s);\n\t  }\n#endif\n\t  print_dsn_diagnostic_code(addr, fp);\n\t  }\n\tfputc('\\n', fp);\n        }\n\n      /* Now copy the message, trying to give an intelligible comment if\n      it is too long for it all to be copied. The limit isn't strictly\n      applied because of the buffering. There is, however, an option\n      to suppress copying altogether. */\n\n      emf_text = next_emf(emf, US\"copy\");\n\n      /* add message body\n         we ignore the intro text from template and add\n         the text for bounce_return_size_limit at the end.\n\n         bounce_return_message is ignored\n         in case RET= is defined we honor these values\n         otherwise bounce_return_body is honored.\n\n         bounce_return_size_limit is always honored.\n      */\n\n      fprintf(fp, \"--%s\\n\", bound);\n\n      dsnlimitmsg = US\"X-Exim-DSN-Information: Due to administrative limits only headers are returned\";\n      dsnnotifyhdr = NULL;\n      topt = topt_add_return_path;\n\n      /* RET=HDRS? top priority */\n      if (dsn_ret == dsn_ret_hdrs)\n        topt |= topt_no_body;\n      else\n\t{\n\tstruct stat statbuf;\n\n        /* no full body return at all? */\n        if (!bounce_return_body)\n          {\n          topt |= topt_no_body;\n          /* add header if we overrule RET=FULL */\n          if (dsn_ret == dsn_ret_full)\n            dsnnotifyhdr = dsnlimitmsg;\n          }\n\t/* line length limited... return headers only if oversize */\n        /* size limited ... return headers only if limit reached */\n\telse if (  max_received_linelength > bounce_return_linesize_limit\n\t\t|| (  bounce_return_size_limit > 0\n\t\t   && fstat(deliver_datafile, &statbuf) == 0\n\t\t   && statbuf.st_size > max\n\t\t)  )\n\t  {\n\t  topt |= topt_no_body;\n\t  dsnnotifyhdr = dsnlimitmsg;\n          }\n\t}\n\n#ifdef SUPPORT_I18N\n      if (message_smtputf8)\n\tfputs(topt & topt_no_body ? \"Content-type: message/global-headers\\n\\n\"\n\t\t\t\t  : \"Content-type: message/global\\n\\n\",\n\t      fp);\n      else\n#endif\n\tfputs(topt & topt_no_body ? \"Content-type: text/rfc822-headers\\n\\n\"\n\t\t\t\t  : \"Content-type: message/rfc822\\n\\n\",\n\t      fp);\n\n      fflush(fp);\n      transport_filter_argv = NULL;   /* Just in case */\n      return_path = sender_address;   /* In case not previously set */\n\t{\t\t\t      /* Dummy transport for headers add */\n\ttransport_ctx tctx = {{0}};\n\ttransport_instance tb = {0};\n\n\ttctx.u.fd = fileno(fp);\n\ttctx.tblock = &tb;\n\ttctx.options = topt;\n\ttb.add_headers = dsnnotifyhdr;\n\n\ttransport_write_message(&tctx, 0);\n\t}\n      fflush(fp);\n\n      /* we never add the final text. close the file */\n      if (emf)\n        (void)fclose(emf);\n\n      fprintf(fp, \"\\n--%s--\\n\", bound);\n\n      /* Close the file, which should send an EOF to the child process\n      that is receiving the message. Wait for it to finish. */\n\n      (void)fclose(fp);\n      rc = child_close(pid, 0);     /* Waits for child to close, no timeout */\n\n      /* In the test harness, let the child do it's thing first. */\n\n      if (f.running_in_test_harness) millisleep(500);\n\n      /* If the process failed, there was some disaster in setting up the\n      error message. Unless the message is very old, ensure that addr_defer\n      is non-null, which will have the effect of leaving the message on the\n      spool. The failed addresses will get tried again next time. However, we\n      don't really want this to happen too often, so freeze the message unless\n      there are some genuine deferred addresses to try. To do this we have\n      to call spool_write_header() here, because with no genuine deferred\n      addresses the normal code below doesn't get run. */\n\n      if (rc != 0)\n        {\n        uschar *s = US\"\";\n        if (now - received_time.tv_sec < retry_maximum_timeout && !addr_defer)\n          {\n          addr_defer = (address_item *)(+1);\n          f.deliver_freeze = TRUE;\n          deliver_frozen_at = time(NULL);\n          /* Panic-dies on error */\n          (void)spool_write_header(message_id, SW_DELIVERING, NULL);\n          s = US\" (frozen)\";\n          }\n        deliver_msglog(\"Process failed (%d) when writing error message \"\n          \"to %s%s\", rc, bounce_recipient, s);\n        log_write(0, LOG_MAIN, \"Process failed (%d) when writing error message \"\n          \"to %s%s\", rc, bounce_recipient, s);\n        }\n\n      /* The message succeeded. Ensure that the recipients that failed are\n      now marked finished with on the spool and their parents updated. */\n\n      else\n        {\n        for (addr = handled_addr; addr; addr = addr->next)\n          {\n          address_done(addr, logtod);\n          child_done(addr, logtod);\n          }\n        /* Panic-dies on error */\n        (void)spool_write_header(message_id, SW_DELIVERING, NULL);\n        }\n      }\n    }\n  }\n\nf.disable_logging = FALSE;  /* In case left set */\n\n/* Come here from the mua_wrapper case if routing goes wrong */\n\nDELIVERY_TIDYUP:\n\n/* If there are now no deferred addresses, we are done. Preserve the\nmessage log if so configured, and we are using them. Otherwise, sling it.\nThen delete the message itself. */\n\nif (!addr_defer)\n  {\n  uschar * fname;\n\n  if (message_logs)\n    {\n    fname = spool_fname(US\"msglog\", message_subdir, id, US\"\");\n    if (preserve_message_logs)\n      {\n      int rc;\n      uschar * moname = spool_fname(US\"msglog.OLD\", US\"\", id, US\"\");\n\n      if ((rc = Urename(fname, moname)) < 0)\n        {\n        (void)directory_make(spool_directory,\n\t\t\t      spool_sname(US\"msglog.OLD\", US\"\"),\n\t\t\t      MSGLOG_DIRECTORY_MODE, TRUE);\n        rc = Urename(fname, moname);\n        }\n      if (rc < 0)\n        log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to move %s to the \"\n          \"msglog.OLD directory\", fname);\n      }\n    else\n      if (Uunlink(fname) < 0)\n        log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to unlink %s: %s\",\n\t\t  fname, strerror(errno));\n    }\n\n  /* Remove the two message files. */\n\n  fname = spool_fname(US\"input\", message_subdir, id, US\"-D\");\n  if (Uunlink(fname) < 0)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to unlink %s: %s\",\n      fname, strerror(errno));\n  fname = spool_fname(US\"input\", message_subdir, id, US\"-H\");\n  if (Uunlink(fname) < 0)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to unlink %s: %s\",\n      fname, strerror(errno));\n\n  /* Log the end of this message, with queue time if requested. */\n\n  if (LOGGING(queue_time_overall))\n    log_write(0, LOG_MAIN, \"Completed QT=%s\", string_timesince(&received_time));\n  else\n    log_write(0, LOG_MAIN, \"Completed\");\n\n  /* Unset deliver_freeze so that we won't try to move the spool files further down */\n  f.deliver_freeze = FALSE;\n\n#ifndef DISABLE_EVENT\n  (void) event_raise(event_action, US\"msg:complete\", NULL);\n#endif\n  }\n\n/* If there are deferred addresses, we are keeping this message because it is\nnot yet completed. Lose any temporary files that were catching output from\npipes for any of the deferred addresses, handle one-time aliases, and see if\nthe message has been on the queue for so long that it is time to send a warning\nmessage to the sender, unless it is a mailer-daemon. If all deferred addresses\nhave the same domain, we can set deliver_domain for the expansion of\ndelay_warning_ condition - if any of them are pipes, files, or autoreplies, use\nthe parent's domain.\n\nIf all the deferred addresses have an error number that indicates \"retry time\nnot reached\", skip sending the warning message, because it won't contain the\nreason for the delay. It will get sent at the next real delivery attempt.\nHowever, if at least one address has tried, we'd better include all of them in\nthe message.\n\nIf we can't make a process to send the message, don't worry.\n\nFor mailing list expansions we want to send the warning message to the\nmailing list manager. We can't do a perfect job here, as some addresses may\nhave different errors addresses, but if we take the errors address from\neach deferred address it will probably be right in most cases.\n\nIf addr_defer == +1, it means there was a problem sending an error message\nfor failed addresses, and there were no \"real\" deferred addresses. The value\nwas set just to keep the message on the spool, so there is nothing to do here.\n*/\n\nelse if (addr_defer != (address_item *)(+1))\n  {\n  address_item *addr;\n  uschar *recipients = US\"\";\n  BOOL delivery_attempted = FALSE;\n\n  deliver_domain = testflag(addr_defer, af_pfr)\n    ? addr_defer->parent->domain : addr_defer->domain;\n\n  for (addr = addr_defer; addr; addr = addr->next)\n    {\n    address_item *otaddr;\n\n    if (addr->basic_errno > ERRNO_RETRY_BASE) delivery_attempted = TRUE;\n\n    if (deliver_domain)\n      {\n      const uschar *d = testflag(addr, af_pfr)\n\t? addr->parent->domain : addr->domain;\n\n      /* The domain may be unset for an address that has never been routed\n      because the system filter froze the message. */\n\n      if (!d || Ustrcmp(d, deliver_domain) != 0)\n        deliver_domain = NULL;\n      }\n\n    if (addr->return_filename) Uunlink(addr->return_filename);\n\n    /* Handle the case of one-time aliases. If any address in the ancestry\n    of this one is flagged, ensure it is in the recipients list, suitably\n    flagged, and that its parent is marked delivered. */\n\n    for (otaddr = addr; otaddr; otaddr = otaddr->parent)\n      if (otaddr->onetime_parent) break;\n\n    if (otaddr)\n      {\n      int i;\n      int t = recipients_count;\n\n      for (i = 0; i < recipients_count; i++)\n        {\n        uschar *r = recipients_list[i].address;\n        if (Ustrcmp(otaddr->onetime_parent, r) == 0) t = i;\n        if (Ustrcmp(otaddr->address, r) == 0) break;\n        }\n\n      /* Didn't find the address already in the list, and did find the\n      ultimate parent's address in the list, and they really are different\n      (i.e. not from an identity-redirect). After adding the recipient,\n      update the errors address in the recipients list. */\n\n      if (  i >= recipients_count && t < recipients_count\n         && Ustrcmp(otaddr->address, otaddr->parent->address) != 0)\n        {\n        DEBUG(D_deliver) debug_printf(\"one_time: adding %s in place of %s\\n\",\n          otaddr->address, otaddr->parent->address);\n        receive_add_recipient(otaddr->address, t);\n        recipients_list[recipients_count-1].errors_to = otaddr->prop.errors_address;\n        tree_add_nonrecipient(otaddr->parent->address);\n        update_spool = TRUE;\n        }\n      }\n\n    /* Except for error messages, ensure that either the errors address for\n    this deferred address or, if there is none, the sender address, is on the\n    list of recipients for a warning message. */\n\n    if (sender_address[0])\n      {\n      uschar * s = addr->prop.errors_address;\n      if (!s) s = sender_address;\n      if (Ustrstr(recipients, s) == NULL)\n\trecipients = string_sprintf(\"%s%s%s\", recipients,\n\t  recipients[0] ? \",\" : \"\", s);\n      }\n    }\n\n  /* Send a warning message if the conditions are right. If the condition check\n  fails because of a lookup defer, there is nothing we can do. The warning\n  is not sent. Another attempt will be made at the next delivery attempt (if\n  it also defers). */\n\n  if (  !f.queue_2stage\n     && delivery_attempted\n     && (  ((addr_defer->dsn_flags & rf_dsnflags) == 0)\n        || (addr_defer->dsn_flags & rf_notify_delay) == rf_notify_delay\n\t)\n     && delay_warning[1] > 0\n     && sender_address[0] != 0\n     && (  !delay_warning_condition\n        || expand_check_condition(delay_warning_condition,\n            US\"delay_warning\", US\"option\")\n\t)\n     )\n    {\n    int count;\n    int show_time;\n    int queue_time = time(NULL) - received_time.tv_sec;\n\n    /* When running in the test harness, there's an option that allows us to\n    fudge this time so as to get repeatability of the tests. Take the first\n    time off the list. In queue runs, the list pointer gets updated in the\n    calling process. */\n\n    if (f.running_in_test_harness && fudged_queue_times[0] != 0)\n      {\n      int qt = readconf_readtime(fudged_queue_times, '/', FALSE);\n      if (qt >= 0)\n        {\n        DEBUG(D_deliver) debug_printf(\"fudged queue_times = %s\\n\",\n          fudged_queue_times);\n        queue_time = qt;\n        }\n      }\n\n    /* See how many warnings we should have sent by now */\n\n    for (count = 0; count < delay_warning[1]; count++)\n      if (queue_time < delay_warning[count+2]) break;\n\n    show_time = delay_warning[count+1];\n\n    if (count >= delay_warning[1])\n      {\n      int extra;\n      int last_gap = show_time;\n      if (count > 1) last_gap -= delay_warning[count];\n      extra = (queue_time - delay_warning[count+1])/last_gap;\n      show_time += last_gap * extra;\n      count += extra;\n      }\n\n    DEBUG(D_deliver)\n      {\n      debug_printf(\"time on queue = %s\\n\", readconf_printtime(queue_time));\n      debug_printf(\"warning counts: required %d done %d\\n\", count,\n        warning_count);\n      }\n\n    /* We have computed the number of warnings there should have been by now.\n    If there haven't been enough, send one, and up the count to what it should\n    have been. */\n\n    if (warning_count < count)\n      {\n      header_line *h;\n      int fd;\n      pid_t pid = child_open_exim(&fd);\n\n      if (pid > 0)\n        {\n        uschar *wmf_text;\n        FILE *wmf = NULL;\n        FILE *f = fdopen(fd, \"wb\");\n\tuschar * bound;\n\ttransport_ctx tctx = {{0}};\n\n        if (warn_message_file)\n          if (!(wmf = Ufopen(warn_message_file, \"rb\")))\n            log_write(0, LOG_MAIN|LOG_PANIC, \"Failed to open %s for warning \"\n              \"message texts: %s\", warn_message_file, strerror(errno));\n\n        warnmsg_recipients = recipients;\n        warnmsg_delay = queue_time < 120*60\n\t  ? string_sprintf(\"%d minutes\", show_time/60)\n\t  : string_sprintf(\"%d hours\", show_time/3600);\n\n        if (errors_reply_to)\n          fprintf(f, \"Reply-To: %s\\n\", errors_reply_to);\n        fprintf(f, \"Auto-Submitted: auto-replied\\n\");\n        moan_write_from(f);\n        fprintf(f, \"To: %s\\n\", recipients);\n\n        /* generated boundary string and output MIME-Headers */\n        bound = string_sprintf(TIME_T_FMT \"-eximdsn-%d\", time(NULL), rand());\n\n        fprintf(f, \"Content-Type: multipart/report;\"\n\t    \" report-type=delivery-status; boundary=%s\\n\"\n\t    \"MIME-Version: 1.0\\n\",\n\t  bound);\n\n        if ((wmf_text = next_emf(wmf, US\"header\")))\n          fprintf(f, \"%s\\n\", wmf_text);\n        else\n          fprintf(f, \"Subject: Warning: message %s delayed %s\\n\\n\",\n            message_id, warnmsg_delay);\n\n        /* output human readable part as text/plain section */\n        fprintf(f, \"--%s\\n\"\n\t    \"Content-type: text/plain; charset=us-ascii\\n\\n\",\n\t  bound);\n\n        if ((wmf_text = next_emf(wmf, US\"intro\")))\n\t  fprintf(f, \"%s\", CS wmf_text);\n\telse\n          {\n          fprintf(f,\n\"This message was created automatically by mail delivery software.\\n\");\n\n          if (Ustrcmp(recipients, sender_address) == 0)\n            fprintf(f,\n\"A message that you sent has not yet been delivered to one or more of its\\n\"\n\"recipients after more than \");\n\n          else\n\t    fprintf(f,\n\"A message sent by\\n\\n  <%s>\\n\\n\"\n\"has not yet been delivered to one or more of its recipients after more than \\n\",\n\t      sender_address);\n\n          fprintf(f, \"%s on the queue on %s.\\n\\n\"\n\t      \"The message identifier is:     %s\\n\",\n\t    warnmsg_delay, primary_hostname, message_id);\n\n          for (h = header_list; h; h = h->next)\n            if (strncmpic(h->text, US\"Subject:\", 8) == 0)\n              fprintf(f, \"The subject of the message is: %s\", h->text + 9);\n            else if (strncmpic(h->text, US\"Date:\", 5) == 0)\n              fprintf(f, \"The date of the message is:    %s\", h->text + 6);\n          fputc('\\n', f);\n\n          fprintf(f, \"The address%s to which the message has not yet been \"\n            \"delivered %s:\\n\",\n            !addr_defer->next ? \"\" : \"es\",\n            !addr_defer->next ? \"is\": \"are\");\n          }\n\n        /* List the addresses, with error information if allowed */\n\n        /* store addr_defer for machine readable part */\n        address_item *addr_dsndefer = addr_defer;\n        fputc('\\n', f);\n        while (addr_defer)\n          {\n          address_item *addr = addr_defer;\n          addr_defer = addr->next;\n          if (print_address_information(addr, f, US\"  \", US\"\\n    \", US\"\"))\n            print_address_error(addr, f, US\"Delay reason: \");\n          fputc('\\n', f);\n          }\n        fputc('\\n', f);\n\n        /* Final text */\n\n        if (wmf)\n          {\n          if ((wmf_text = next_emf(wmf, US\"final\")))\n\t    fprintf(f, \"%s\", CS wmf_text);\n          (void)fclose(wmf);\n          }\n        else\n          {\n          fprintf(f,\n\"No action is required on your part. Delivery attempts will continue for\\n\"\n\"some time, and this warning may be repeated at intervals if the message\\n\"\n\"remains undelivered. Eventually the mail delivery software will give up,\\n\"\n\"and when that happens, the message will be returned to you.\\n\");\n          }\n\n        /* output machine readable part */\n        fprintf(f, \"\\n--%s\\n\"\n\t    \"Content-type: message/delivery-status\\n\\n\"\n\t    \"Reporting-MTA: dns; %s\\n\",\n\t  bound,\n\t  smtp_active_hostname);\n\n\n        if (dsn_envid)\n\t  {\n          /* must be decoded from xtext: see RFC 3461:6.3a */\n          uschar *xdec_envid;\n          if (auth_xtextdecode(dsn_envid, &xdec_envid) > 0)\n            fprintf(f,\"Original-Envelope-ID: %s\\n\", dsn_envid);\n          else\n            fprintf(f,\"X-Original-Envelope-ID: error decoding xtext formatted ENVID\\n\");\n          }\n        fputc('\\n', f);\n\n        for ( ; addr_dsndefer; addr_dsndefer = addr_dsndefer->next)\n          {\n          if (addr_dsndefer->dsn_orcpt)\n            fprintf(f, \"Original-Recipient: %s\\n\", addr_dsndefer->dsn_orcpt);\n\n          fprintf(f, \"Action: delayed\\n\"\n\t      \"Final-Recipient: rfc822;%s\\n\"\n\t      \"Status: 4.0.0\\n\",\n\t    addr_dsndefer->address);\n          if (addr_dsndefer->host_used && addr_dsndefer->host_used->name)\n            {\n            fprintf(f, \"Remote-MTA: dns; %s\\n\",\n\t\t    addr_dsndefer->host_used->name);\n            print_dsn_diagnostic_code(addr_dsndefer, f);\n            }\n\t  fputc('\\n', f);\n          }\n\n        fprintf(f, \"--%s\\n\"\n\t    \"Content-type: text/rfc822-headers\\n\\n\",\n\t  bound);\n\n        fflush(f);\n        /* header only as required by RFC. only failure DSN needs to honor RET=FULL */\n\ttctx.u.fd = fileno(f);\n        tctx.options = topt_add_return_path | topt_no_body;\n        transport_filter_argv = NULL;   /* Just in case */\n        return_path = sender_address;   /* In case not previously set */\n\n        /* Write the original email out */\n        transport_write_message(&tctx, 0);\n        fflush(f);\n\n        fprintf(f,\"\\n--%s--\\n\", bound);\n\n        fflush(f);\n\n        /* Close and wait for child process to complete, without a timeout.\n        If there's an error, don't update the count. */\n\n        (void)fclose(f);\n        if (child_close(pid, 0) == 0)\n          {\n          warning_count = count;\n          update_spool = TRUE;    /* Ensure spool rewritten */\n          }\n        }\n      }\n    }\n\n  /* Clear deliver_domain */\n\n  deliver_domain = NULL;\n\n  /* If this was a first delivery attempt, unset the first time flag, and\n  ensure that the spool gets updated. */\n\n  if (f.deliver_firsttime)\n    {\n    f.deliver_firsttime = FALSE;\n    update_spool = TRUE;\n    }\n\n  /* If delivery was frozen and freeze_tell is set, generate an appropriate\n  message, unless the message is a local error message (to avoid loops). Then\n  log the freezing. If the text in \"frozen_info\" came from a system filter,\n  it has been escaped into printing characters so as not to mess up log lines.\n  For the \"tell\" message, we turn \\n back into newline. Also, insert a newline\n  near the start instead of the \": \" string. */\n\n  if (f.deliver_freeze)\n    {\n    if (freeze_tell && freeze_tell[0] != 0 && !f.local_error_message)\n      {\n      uschar *s = string_copy(frozen_info);\n      uschar *ss = Ustrstr(s, \" by the system filter: \");\n\n      if (ss != NULL)\n        {\n        ss[21] = '.';\n        ss[22] = '\\n';\n        }\n\n      ss = s;\n      while (*ss != 0)\n        {\n        if (*ss == '\\\\' && ss[1] == 'n')\n          {\n          *ss++ = ' ';\n          *ss++ = '\\n';\n          }\n        else ss++;\n        }\n      moan_tell_someone(freeze_tell, addr_defer, US\"Message frozen\",\n        \"Message %s has been frozen%s.\\nThe sender is <%s>.\\n\", message_id,\n        s, sender_address);\n      }\n\n    /* Log freezing just before we update the -H file, to minimize the chance\n    of a race problem. */\n\n    deliver_msglog(\"*** Frozen%s\\n\", frozen_info);\n    log_write(0, LOG_MAIN, \"Frozen%s\", frozen_info);\n    }\n\n  /* If there have been any updates to the non-recipients list, or other things\n  that get written to the spool, we must now update the spool header file so\n  that it has the right information for the next delivery attempt. If there\n  was more than one address being delivered, the header_change update is done\n  earlier, in case one succeeds and then something crashes. */\n\n  DEBUG(D_deliver)\n    debug_printf(\"delivery deferred: update_spool=%d header_rewritten=%d\\n\",\n      update_spool, f.header_rewritten);\n\n  if (update_spool || f.header_rewritten)\n    /* Panic-dies on error */\n    (void)spool_write_header(message_id, SW_DELIVERING, NULL);\n  }\n\n/* Finished with the message log. If the message is complete, it will have\nbeen unlinked or renamed above. */\n\nif (message_logs) (void)fclose(message_log);\n\n/* Now we can close and remove the journal file. Its only purpose is to record\nsuccessfully completed deliveries asap so that this information doesn't get\nlost if Exim (or the machine) crashes. Forgetting about a failed delivery is\nnot serious, as trying it again is not harmful. The journal might not be open\nif all addresses were deferred at routing or directing. Nevertheless, we must\nremove it if it exists (may have been lying around from a crash during the\nprevious delivery attempt). We don't remove the journal if a delivery\nsubprocess failed to pass back delivery information; this is controlled by\nthe remove_journal flag. When the journal is left, we also don't move the\nmessage off the main spool if frozen and the option is set. It should get moved\nat the next attempt, after the journal has been inspected. */\n\nif (journal_fd >= 0) (void)close(journal_fd);\n\nif (remove_journal)\n  {\n  uschar * fname = spool_fname(US\"input\", message_subdir, id, US\"-J\");\n\n  if (Uunlink(fname) < 0 && errno != ENOENT)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to unlink %s: %s\", fname,\n      strerror(errno));\n\n  /* Move the message off the spool if requested */\n\n#ifdef SUPPORT_MOVE_FROZEN_MESSAGES\n  if (f.deliver_freeze && move_frozen_messages)\n    (void)spool_move_message(id, message_subdir, US\"\", US\"F\");\n#endif\n  }\n\n/* Closing the data file frees the lock; if the file has been unlinked it\nwill go away. Otherwise the message becomes available for another process\nto try delivery. */\n\n(void)close(deliver_datafile);\ndeliver_datafile = -1;\nDEBUG(D_deliver) debug_printf(\"end delivery of %s\\n\", id);\n\n/* It is unlikely that there will be any cached resources, since they are\nreleased after routing, and in the delivery subprocesses. However, it's\npossible for an expansion for something afterwards (for example,\nexpand_check_condition) to do a lookup. We must therefore be sure everything is\nreleased. */\n\nsearch_tidyup();\nacl_where = ACL_WHERE_UNKNOWN;\nreturn final_yield;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147360,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "deliver_message(uschar *id, BOOL forced, BOOL give_up)\n{\nint i, rc;\nint final_yield = DELIVER_ATTEMPTED_NORMAL;\ntime_t now = time(NULL);\naddress_item *addr_last = NULL;\nuschar *filter_message = NULL;\nint process_recipients = RECIP_ACCEPT;\nopen_db dbblock;\nopen_db *dbm_file;\nextern int acl_where;\n\nuschar *info = queue_run_pid == (pid_t)0\n  ? string_sprintf(\"delivering %s\", id)\n  : string_sprintf(\"delivering %s (queue run pid %d)\", id, queue_run_pid);\n\n/* If the D_process_info bit is on, set_process_info() will output debugging\ninformation. If not, we want to show this initial information if D_deliver or\nD_queue_run is set or in verbose mode. */\n\nset_process_info(\"%s\", info);\n\nif (  !(debug_selector & D_process_info)\n   && (debug_selector & (D_deliver|D_queue_run|D_v))\n   )\n  debug_printf(\"%s\\n\", info);\n\n/* Ensure that we catch any subprocesses that are created. Although Exim\nsets SIG_DFL as its initial default, some routes through the code end up\nhere with it set to SIG_IGN - cases where a non-synchronous delivery process\nhas been forked, but no re-exec has been done. We use sigaction rather than\nplain signal() on those OS where SA_NOCLDWAIT exists, because we want to be\nsure it is turned off. (There was a problem on AIX with this.) */\n\n#ifdef SA_NOCLDWAIT\n  {\n  struct sigaction act;\n  act.sa_handler = SIG_DFL;\n  sigemptyset(&(act.sa_mask));\n  act.sa_flags = 0;\n  sigaction(SIGCHLD, &act, NULL);\n  }\n#else\nsignal(SIGCHLD, SIG_DFL);\n#endif\n\n/* Make the forcing flag available for routers and transports, set up the\nglobal message id field, and initialize the count for returned files and the\nmessage size. This use of strcpy() is OK because the length id is checked when\nit is obtained from a command line (the -M or -q options), and otherwise it is\nknown to be a valid message id. */\n\nUstrcpy(message_id, id);\nf.deliver_force = forced;\nreturn_count = 0;\nmessage_size = 0;\n\n/* Initialize some flags */\n\nupdate_spool = FALSE;\nremove_journal = TRUE;\n\n/* Set a known context for any ACLs we call via expansions */\nacl_where = ACL_WHERE_DELIVERY;\n\n/* Reset the random number generator, so that if several delivery processes are\nstarted from a queue runner that has already used random numbers (for sorting),\nthey don't all get the same sequence. */\n\nrandom_seed = 0;\n\n/* Open and lock the message's data file. Exim locks on this one because the\nheader file may get replaced as it is re-written during the delivery process.\nAny failures cause messages to be written to the log, except for missing files\nwhile queue running - another process probably completed delivery. As part of\nopening the data file, message_subdir gets set. */\n\nif ((deliver_datafile = spool_open_datafile(id)) < 0)\n  return continue_closedown();  /* yields DELIVER_NOT_ATTEMPTED */\n\n/* The value of message_size at this point has been set to the data length,\nplus one for the blank line that notionally precedes the data. */\n\n/* Now read the contents of the header file, which will set up the headers in\nstore, and also the list of recipients and the tree of non-recipients and\nassorted flags. It updates message_size. If there is a reading or format error,\ngive up; if the message has been around for sufficiently long, remove it. */\n\n  {\n  uschar * spoolname = string_sprintf(\"%s-H\", id);\n  if ((rc = spool_read_header(spoolname, TRUE, TRUE)) != spool_read_OK)\n    {\n    if (errno == ERRNO_SPOOLFORMAT)\n      {\n      struct stat statbuf;\n      if (Ustat(spool_fname(US\"input\", message_subdir, spoolname, US\"\"),\n\t\t&statbuf) == 0)\n\tlog_write(0, LOG_MAIN, \"Format error in spool file %s: \"\n\t  \"size=\" OFF_T_FMT, spoolname, statbuf.st_size);\n      else\n\tlog_write(0, LOG_MAIN, \"Format error in spool file %s\", spoolname);\n      }\n    else\n      log_write(0, LOG_MAIN, \"Error reading spool file %s: %s\", spoolname,\n\tstrerror(errno));\n\n    /* If we managed to read the envelope data, received_time contains the\n    time the message was received. Otherwise, we can calculate it from the\n    message id. */\n\n    if (rc != spool_read_hdrerror)\n      {\n      received_time.tv_sec = received_time.tv_usec = 0;\n      /*XXX subsec precision?*/\n      for (i = 0; i < 6; i++)\n\treceived_time.tv_sec = received_time.tv_sec * BASE_62 + tab62[id[i] - '0'];\n      }\n\n    /* If we've had this malformed message too long, sling it. */\n\n    if (now - received_time.tv_sec > keep_malformed)\n      {\n      Uunlink(spool_fname(US\"msglog\", message_subdir, id, US\"\"));\n      Uunlink(spool_fname(US\"input\", message_subdir, id, US\"-D\"));\n      Uunlink(spool_fname(US\"input\", message_subdir, id, US\"-H\"));\n      Uunlink(spool_fname(US\"input\", message_subdir, id, US\"-J\"));\n      log_write(0, LOG_MAIN, \"Message removed because older than %s\",\n\treadconf_printtime(keep_malformed));\n      }\n\n    (void)close(deliver_datafile);\n    deliver_datafile = -1;\n    return continue_closedown();   /* yields DELIVER_NOT_ATTEMPTED */\n    }\n  }\n\n/* The spool header file has been read. Look to see if there is an existing\njournal file for this message. If there is, it means that a previous delivery\nattempt crashed (program or host) before it could update the spool header file.\nRead the list of delivered addresses from the journal and add them to the\nnonrecipients tree. Then update the spool file. We can leave the journal in\nexistence, as it will get further successful deliveries added to it in this\nrun, and it will be deleted if this function gets to its end successfully.\nOtherwise it might be needed again. */\n\n  {\n  uschar * fname = spool_fname(US\"input\", message_subdir, id, US\"-J\");\n  FILE * jread;\n\n  if (  (journal_fd = Uopen(fname, O_RDWR|O_APPEND\n#ifdef O_CLOEXEC\n\t\t\t\t    | O_CLOEXEC\n#endif\n#ifdef O_NOFOLLOW\n\t\t\t\t    | O_NOFOLLOW\n#endif\n\t, SPOOL_MODE)) >= 0\n     && lseek(journal_fd, 0, SEEK_SET) == 0\n     && (jread = fdopen(journal_fd, \"rb\"))\n     )\n    {\n    while (Ufgets(big_buffer, big_buffer_size, jread))\n      {\n      int n = Ustrlen(big_buffer);\n      big_buffer[n-1] = 0;\n      tree_add_nonrecipient(big_buffer);\n      DEBUG(D_deliver) debug_printf(\"Previously delivered address %s taken from \"\n\t\"journal file\\n\", big_buffer);\n      }\n    rewind(jread);\n    if ((journal_fd = dup(fileno(jread))) < 0)\n      journal_fd = fileno(jread);\n    else\n      (void) fclose(jread);\t/* Try to not leak the FILE resource */\n\n    /* Panic-dies on error */\n    (void)spool_write_header(message_id, SW_DELIVERING, NULL);\n    }\n  else if (errno != ENOENT)\n    {\n    log_write(0, LOG_MAIN|LOG_PANIC, \"attempt to open journal for reading gave: \"\n      \"%s\", strerror(errno));\n    return continue_closedown();   /* yields DELIVER_NOT_ATTEMPTED */\n    }\n\n  /* A null recipients list indicates some kind of disaster. */\n\n  if (!recipients_list)\n    {\n    (void)close(deliver_datafile);\n    deliver_datafile = -1;\n    log_write(0, LOG_MAIN, \"Spool error: no recipients for %s\", fname);\n    return continue_closedown();   /* yields DELIVER_NOT_ATTEMPTED */\n    }\n  }\n\n\n/* Handle a message that is frozen. There are a number of different things that\ncan happen, but in the default situation, unless forced, no delivery is\nattempted. */\n\nif (f.deliver_freeze)\n  {\n#ifdef SUPPORT_MOVE_FROZEN_MESSAGES\n  /* Moving to another directory removes the message from Exim's view. Other\n  tools must be used to deal with it. Logging of this action happens in\n  spool_move_message() and its subfunctions. */\n\n  if (  move_frozen_messages\n     && spool_move_message(id, message_subdir, US\"\", US\"F\")\n     )\n    return continue_closedown();   /* yields DELIVER_NOT_ATTEMPTED */\n#endif\n\n  /* For all frozen messages (bounces or not), timeout_frozen_after sets the\n  maximum time to keep messages that are frozen. Thaw if we reach it, with a\n  flag causing all recipients to be failed. The time is the age of the\n  message, not the time since freezing. */\n\n  if (timeout_frozen_after > 0 && message_age >= timeout_frozen_after)\n    {\n    log_write(0, LOG_MAIN, \"cancelled by timeout_frozen_after\");\n    process_recipients = RECIP_FAIL_TIMEOUT;\n    }\n\n  /* For bounce messages (and others with no sender), thaw if the error message\n  ignore timer is exceeded. The message will be discarded if this delivery\n  fails. */\n\n  else if (!*sender_address && message_age >= ignore_bounce_errors_after)\n    log_write(0, LOG_MAIN, \"Unfrozen by errmsg timer\");\n\n  /* If this is a bounce message, or there's no auto thaw, or we haven't\n  reached the auto thaw time yet, and this delivery is not forced by an admin\n  user, do not attempt delivery of this message. Note that forced is set for\n  continuing messages down the same channel, in order to skip load checking and\n  ignore hold domains, but we don't want unfreezing in that case. */\n\n  else\n    {\n    if (  (  sender_address[0] == 0\n\t  || auto_thaw <= 0\n\t  || now <= deliver_frozen_at + auto_thaw\n          )\n       && (  !forced || !f.deliver_force_thaw\n\t  || !f.admin_user || continue_hostname\n       )  )\n      {\n      (void)close(deliver_datafile);\n      deliver_datafile = -1;\n      log_write(L_skip_delivery, LOG_MAIN, \"Message is frozen\");\n      return continue_closedown();   /* yields DELIVER_NOT_ATTEMPTED */\n      }\n\n    /* If delivery was forced (by an admin user), assume a manual thaw.\n    Otherwise it's an auto thaw. */\n\n    if (forced)\n      {\n      f.deliver_manual_thaw = TRUE;\n      log_write(0, LOG_MAIN, \"Unfrozen by forced delivery\");\n      }\n    else log_write(0, LOG_MAIN, \"Unfrozen by auto-thaw\");\n    }\n\n  /* We get here if any of the rules for unfreezing have triggered. */\n\n  f.deliver_freeze = FALSE;\n  update_spool = TRUE;\n  }\n\n\n/* Open the message log file if we are using them. This records details of\ndeliveries, deferments, and failures for the benefit of the mail administrator.\nThe log is not used by exim itself to track the progress of a message; that is\ndone by rewriting the header spool file. */\n\nif (message_logs)\n  {\n  uschar * fname = spool_fname(US\"msglog\", message_subdir, id, US\"\");\n  uschar * error;\n  int fd;\n\n  if ((fd = open_msglog_file(fname, SPOOL_MODE, &error)) < 0)\n    {\n    log_write(0, LOG_MAIN|LOG_PANIC, \"Couldn't %s message log %s: %s\", error,\n      fname, strerror(errno));\n    return continue_closedown();   /* yields DELIVER_NOT_ATTEMPTED */\n    }\n\n  /* Make a C stream out of it. */\n\n  if (!(message_log = fdopen(fd, \"a\")))\n    {\n    log_write(0, LOG_MAIN|LOG_PANIC, \"Couldn't fdopen message log %s: %s\",\n      fname, strerror(errno));\n    return continue_closedown();   /* yields DELIVER_NOT_ATTEMPTED */\n    }\n  }\n\n\n/* If asked to give up on a message, log who did it, and set the action for all\nthe addresses. */\n\nif (give_up)\n  {\n  struct passwd *pw = getpwuid(real_uid);\n  log_write(0, LOG_MAIN, \"cancelled by %s\",\n      pw ? US pw->pw_name : string_sprintf(\"uid %ld\", (long int)real_uid));\n  process_recipients = RECIP_FAIL;\n  }\n\n/* Otherwise, if there are too many Received: headers, fail all recipients. */\n\nelse if (received_count > received_headers_max)\n  process_recipients = RECIP_FAIL_LOOP;\n\n/* Otherwise, if a system-wide, address-independent message filter is\nspecified, run it now, except in the case when we are failing all recipients as\na result of timeout_frozen_after. If the system filter yields \"delivered\", then\nignore the true recipients of the message. Failure of the filter file is\nlogged, and the delivery attempt fails. */\n\nelse if (system_filter && process_recipients != RECIP_FAIL_TIMEOUT)\n  {\n  int rc;\n  int filtertype;\n  ugid_block ugid;\n  redirect_block redirect;\n\n  if (system_filter_uid_set)\n    {\n    ugid.uid = system_filter_uid;\n    ugid.gid = system_filter_gid;\n    ugid.uid_set = ugid.gid_set = TRUE;\n    }\n  else\n    {\n    ugid.uid_set = ugid.gid_set = FALSE;\n    }\n\n  return_path = sender_address;\n  f.enable_dollar_recipients = TRUE;   /* Permit $recipients in system filter */\n  f.system_filtering = TRUE;\n\n  /* Any error in the filter file causes a delivery to be abandoned. */\n\n  redirect.string = system_filter;\n  redirect.isfile = TRUE;\n  redirect.check_owner = redirect.check_group = FALSE;\n  redirect.owners = NULL;\n  redirect.owngroups = NULL;\n  redirect.pw = NULL;\n  redirect.modemask = 0;\n\n  DEBUG(D_deliver|D_filter) debug_printf(\"running system filter\\n\");\n\n  rc = rda_interpret(\n    &redirect,              /* Where the data is */\n    RDO_DEFER |             /* Turn on all the enabling options */\n      RDO_FAIL |            /* Leave off all the disabling options */\n      RDO_FILTER |\n      RDO_FREEZE |\n      RDO_REALLOG |\n      RDO_REWRITE,\n    NULL,                   /* No :include: restriction (not used in filter) */\n    NULL,                   /* No sieve vacation directory (not sieve!) */\n    NULL,                   /* No sieve enotify mailto owner (not sieve!) */\n    NULL,                   /* No sieve user address (not sieve!) */\n    NULL,                   /* No sieve subaddress (not sieve!) */\n    &ugid,                  /* uid/gid data */\n    &addr_new,              /* Where to hang generated addresses */\n    &filter_message,        /* Where to put error message */\n    NULL,                   /* Don't skip syntax errors */\n    &filtertype,            /* Will always be set to FILTER_EXIM for this call */\n    US\"system filter\");     /* For error messages */\n\n  DEBUG(D_deliver|D_filter) debug_printf(\"system filter returned %d\\n\", rc);\n\n  if (rc == FF_ERROR || rc == FF_NONEXIST)\n    {\n    (void)close(deliver_datafile);\n    deliver_datafile = -1;\n    log_write(0, LOG_MAIN|LOG_PANIC, \"Error in system filter: %s\",\n      string_printing(filter_message));\n    return continue_closedown();   /* yields DELIVER_NOT_ATTEMPTED */\n    }\n\n  /* Reset things. If the filter message is an empty string, which can happen\n  for a filter \"fail\" or \"freeze\" command with no text, reset it to NULL. */\n\n  f.system_filtering = FALSE;\n  f.enable_dollar_recipients = FALSE;\n  if (filter_message && filter_message[0] == 0) filter_message = NULL;\n\n  /* Save the values of the system filter variables so that user filters\n  can use them. */\n\n  memcpy(filter_sn, filter_n, sizeof(filter_sn));\n\n  /* The filter can request that delivery of the original addresses be\n  deferred. */\n\n  if (rc == FF_DEFER)\n    {\n    process_recipients = RECIP_DEFER;\n    deliver_msglog(\"Delivery deferred by system filter\\n\");\n    log_write(0, LOG_MAIN, \"Delivery deferred by system filter\");\n    }\n\n  /* The filter can request that a message be frozen, but this does not\n  take place if the message has been manually thawed. In that case, we must\n  unset \"delivered\", which is forced by the \"freeze\" command to make -bF\n  work properly. */\n\n  else if (rc == FF_FREEZE && !f.deliver_manual_thaw)\n    {\n    f.deliver_freeze = TRUE;\n    deliver_frozen_at = time(NULL);\n    process_recipients = RECIP_DEFER;\n    frozen_info = string_sprintf(\" by the system filter%s%s\",\n      filter_message ? US\": \" : US\"\",\n      filter_message ? filter_message : US\"\");\n    }\n\n  /* The filter can request that a message be failed. The error message may be\n  quite long - it is sent back to the sender in the bounce - but we don't want\n  to fill up the log with repetitions of it. If it starts with << then the text\n  between << and >> is written to the log, with the rest left for the bounce\n  message. */\n\n  else if (rc == FF_FAIL)\n    {\n    uschar *colon = US\"\";\n    uschar *logmsg = US\"\";\n    int loglen = 0;\n\n    process_recipients = RECIP_FAIL_FILTER;\n\n    if (filter_message)\n      {\n      uschar *logend;\n      colon = US\": \";\n      if (  filter_message[0] == '<'\n         && filter_message[1] == '<'\n\t && (logend = Ustrstr(filter_message, \">>\"))\n\t )\n        {\n        logmsg = filter_message + 2;\n        loglen = logend - logmsg;\n        filter_message = logend + 2;\n        if (filter_message[0] == 0) filter_message = NULL;\n        }\n      else\n        {\n        logmsg = filter_message;\n        loglen = Ustrlen(filter_message);\n        }\n      }\n\n    log_write(0, LOG_MAIN, \"cancelled by system filter%s%.*s\", colon, loglen,\n      logmsg);\n    }\n\n  /* Delivery can be restricted only to those recipients (if any) that the\n  filter specified. */\n\n  else if (rc == FF_DELIVERED)\n    {\n    process_recipients = RECIP_IGNORE;\n    if (addr_new)\n      log_write(0, LOG_MAIN, \"original recipients ignored (system filter)\");\n    else\n      log_write(0, LOG_MAIN, \"=> discarded (system filter)\");\n    }\n\n  /* If any new addresses were created by the filter, fake up a \"parent\"\n  for them. This is necessary for pipes, etc., which are expected to have\n  parents, and it also gives some sensible logging for others. Allow\n  pipes, files, and autoreplies, and run them as the filter uid if set,\n  otherwise as the current uid. */\n\n  if (addr_new)\n    {\n    int uid = (system_filter_uid_set)? system_filter_uid : geteuid();\n    int gid = (system_filter_gid_set)? system_filter_gid : getegid();\n\n    /* The text \"system-filter\" is tested in transport_set_up_command() and in\n    set_up_shell_command() in the pipe transport, to enable them to permit\n    $recipients, so don't change it here without also changing it there. */\n\n    address_item *p = addr_new;\n    address_item *parent = deliver_make_addr(US\"system-filter\", FALSE);\n\n    parent->domain = string_copylc(qualify_domain_recipient);\n    parent->local_part = US\"system-filter\";\n\n    /* As part of this loop, we arrange for addr_last to end up pointing\n    at the final address. This is used if we go on to add addresses for the\n    original recipients. */\n\n    while (p)\n      {\n      if (parent->child_count == USHRT_MAX)\n        log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"system filter generated more \"\n          \"than %d delivery addresses\", USHRT_MAX);\n      parent->child_count++;\n      p->parent = parent;\n\n      if (testflag(p, af_pfr))\n        {\n        uschar *tpname;\n        uschar *type;\n        p->uid = uid;\n        p->gid = gid;\n        setflag(p, af_uid_set);\n        setflag(p, af_gid_set);\n        setflag(p, af_allow_file);\n        setflag(p, af_allow_pipe);\n        setflag(p, af_allow_reply);\n\n        /* Find the name of the system filter's appropriate pfr transport */\n\n        if (p->address[0] == '|')\n          {\n          type = US\"pipe\";\n          tpname = system_filter_pipe_transport;\n          address_pipe = p->address;\n          }\n        else if (p->address[0] == '>')\n          {\n          type = US\"reply\";\n          tpname = system_filter_reply_transport;\n          }\n        else\n          {\n          if (p->address[Ustrlen(p->address)-1] == '/')\n            {\n            type = US\"directory\";\n            tpname = system_filter_directory_transport;\n            }\n          else\n            {\n            type = US\"file\";\n            tpname = system_filter_file_transport;\n            }\n          address_file = p->address;\n          }\n\n        /* Now find the actual transport, first expanding the name. We have\n        set address_file or address_pipe above. */\n\n        if (tpname)\n          {\n          uschar *tmp = expand_string(tpname);\n          address_file = address_pipe = NULL;\n          if (!tmp)\n            p->message = string_sprintf(\"failed to expand \\\"%s\\\" as a \"\n              \"system filter transport name\", tpname);\n          tpname = tmp;\n          }\n        else\n          p->message = string_sprintf(\"system_filter_%s_transport is unset\",\n            type);\n\n        if (tpname)\n          {\n          transport_instance *tp;\n          for (tp = transports; tp; tp = tp->next)\n            if (Ustrcmp(tp->name, tpname) == 0)\n              {\n              p->transport = tp;\n              break;\n              }\n          if (!tp)\n            p->message = string_sprintf(\"failed to find \\\"%s\\\" transport \"\n              \"for system filter delivery\", tpname);\n          }\n\n        /* If we couldn't set up a transport, defer the delivery, putting the\n        error on the panic log as well as the main log. */\n\n        if (!p->transport)\n          {\n          address_item *badp = p;\n          p = p->next;\n          if (!addr_last) addr_new = p; else addr_last->next = p;\n          badp->local_part = badp->address;   /* Needed for log line */\n          post_process_one(badp, DEFER, LOG_MAIN|LOG_PANIC, EXIM_DTYPE_ROUTER, 0);\n          continue;\n          }\n        }    /* End of pfr handling */\n\n      /* Either a non-pfr delivery, or we found a transport */\n\n      DEBUG(D_deliver|D_filter)\n        debug_printf(\"system filter added %s\\n\", p->address);\n\n      addr_last = p;\n      p = p->next;\n      }    /* Loop through all addr_new addresses */\n    }\n  }\n\n\n/* Scan the recipients list, and for every one that is not in the non-\nrecipients tree, add an addr item to the chain of new addresses. If the pno\nvalue is non-negative, we must set the onetime parent from it. This which\npoints to the relevant entry in the recipients list.\n\nThis processing can be altered by the setting of the process_recipients\nvariable, which is changed if recipients are to be ignored, failed, or\ndeferred. This can happen as a result of system filter activity, or if the -Mg\noption is used to fail all of them.\n\nDuplicate addresses are handled later by a different tree structure; we can't\njust extend the non-recipients tree, because that will be re-written to the\nspool if the message is deferred, and in any case there are casing\ncomplications for local addresses. */\n\nif (process_recipients != RECIP_IGNORE)\n  for (i = 0; i < recipients_count; i++)\n    if (!tree_search(tree_nonrecipients, recipients_list[i].address))\n      {\n      recipient_item *r = recipients_list + i;\n      address_item *new = deliver_make_addr(r->address, FALSE);\n      new->prop.errors_address = r->errors_to;\n#ifdef SUPPORT_I18N\n      if ((new->prop.utf8_msg = message_smtputf8))\n\t{\n\tnew->prop.utf8_downcvt =       message_utf8_downconvert == 1;\n\tnew->prop.utf8_downcvt_maybe = message_utf8_downconvert == -1;\n\tDEBUG(D_deliver) debug_printf(\"utf8, downconvert %s\\n\",\n\t  new->prop.utf8_downcvt ? \"yes\"\n\t  : new->prop.utf8_downcvt_maybe ? \"ifneeded\"\n\t  : \"no\");\n\t}\n#endif\n\n      if (r->pno >= 0)\n        new->onetime_parent = recipients_list[r->pno].address;\n\n      /* If DSN support is enabled, set the dsn flags and the original receipt\n         to be passed on to other DSN enabled MTAs */\n      new->dsn_flags = r->dsn_flags & rf_dsnflags;\n      new->dsn_orcpt = r->orcpt;\n      DEBUG(D_deliver) debug_printf(\"DSN: set orcpt: %s  flags: %d\\n\",\n\tnew->dsn_orcpt ? new->dsn_orcpt : US\"\", new->dsn_flags);\n\n      switch (process_recipients)\n        {\n        /* RECIP_DEFER is set when a system filter freezes a message. */\n\n        case RECIP_DEFER:\n\t  new->next = addr_defer;\n\t  addr_defer = new;\n\t  break;\n\n\n        /* RECIP_FAIL_FILTER is set when a system filter has obeyed a \"fail\"\n        command. */\n\n        case RECIP_FAIL_FILTER:\n\t  new->message =\n\t    filter_message ? filter_message : US\"delivery cancelled\";\n\t  setflag(new, af_pass_message);\n\t  goto RECIP_QUEUE_FAILED;   /* below */\n\n\n        /* RECIP_FAIL_TIMEOUT is set when a message is frozen, but is older\n        than the value in timeout_frozen_after. Treat non-bounce messages\n        similarly to -Mg; for bounce messages we just want to discard, so\n        don't put the address on the failed list. The timeout has already\n        been logged. */\n\n        case RECIP_FAIL_TIMEOUT:\n\t  new->message  = US\"delivery cancelled; message timed out\";\n\t  goto RECIP_QUEUE_FAILED;   /* below */\n\n\n        /* RECIP_FAIL is set when -Mg has been used. */\n\n        case RECIP_FAIL:\n\t  new->message  = US\"delivery cancelled by administrator\";\n\t  /* Fall through */\n\n        /* Common code for the failure cases above. If this is not a bounce\n        message, put the address on the failed list so that it is used to\n        create a bounce. Otherwise do nothing - this just discards the address.\n        The incident has already been logged. */\n\n        RECIP_QUEUE_FAILED:\n\t  if (sender_address[0])\n\t    {\n\t    new->next = addr_failed;\n\t    addr_failed = new;\n\t    }\n        break;\n\n\n        /* RECIP_FAIL_LOOP is set when there are too many Received: headers\n        in the message. Process each address as a routing failure; if this\n        is a bounce message, it will get frozen. */\n\n        case RECIP_FAIL_LOOP:\n\t  new->message = US\"Too many \\\"Received\\\" headers - suspected mail loop\";\n\t  post_process_one(new, FAIL, LOG_MAIN, EXIM_DTYPE_ROUTER, 0);\n\t  break;\n\n\n        /* Value should be RECIP_ACCEPT; take this as the safe default. */\n\n        default:\n\t  if (!addr_new) addr_new = new; else addr_last->next = new;\n\t  addr_last = new;\n\t  break;\n        }\n\n#ifndef DISABLE_EVENT\n      if (process_recipients != RECIP_ACCEPT)\n\t{\n\tuschar * save_local =  deliver_localpart;\n\tconst uschar * save_domain = deliver_domain;\n\tuschar * addr = new->address, * errmsg = NULL;\n\tint start, end, dom;\n\n\tif (!parse_extract_address(addr, &errmsg, &start, &end, &dom, TRUE))\n\t  log_write(0, LOG_MAIN|LOG_PANIC,\n                \"failed to parse address '%.100s': %s\\n\", addr, errmsg);\n\telse\n\t  {\n\t  deliver_localpart =\n\t    string_copyn(addr+start, dom ? (dom-1) - start : end - start);\n\t  deliver_domain = dom ? CUS string_copyn(addr+dom, end - dom) : CUS\"\";\n\n\t  event_raise(event_action, US\"msg:fail:internal\", new->message);\n\n\t  deliver_localpart = save_local;\n\t  deliver_domain = save_domain;\n\t  }\n\t}\n#endif\n      }\n\nDEBUG(D_deliver)\n  {\n  address_item *p;\n  debug_printf(\"Delivery address list:\\n\");\n  for (p = addr_new; p; p = p->next)\n    debug_printf(\"  %s %s\\n\", p->address,\n      p->onetime_parent ? p->onetime_parent : US\"\");\n  }\n\n/* Set up the buffers used for copying over the file when delivering. */\n\ndeliver_in_buffer = store_malloc(DELIVER_IN_BUFFER_SIZE);\ndeliver_out_buffer = store_malloc(DELIVER_OUT_BUFFER_SIZE);\n\n\n\n/* Until there are no more new addresses, handle each one as follows:\n\n . If this is a generated address (indicated by the presence of a parent\n   pointer) then check to see whether it is a pipe, file, or autoreply, and\n   if so, handle it directly here. The router that produced the address will\n   have set the allow flags into the address, and also set the uid/gid required.\n   Having the routers generate new addresses and then checking them here at\n   the outer level is tidier than making each router do the checking, and\n   means that routers don't need access to the failed address queue.\n\n . Break up the address into local part and domain, and make lowercased\n   versions of these strings. We also make unquoted versions of the local part.\n\n . Handle the percent hack for those domains for which it is valid.\n\n . For child addresses, determine if any of the parents have the same address.\n   If so, generate a different string for previous delivery checking. Without\n   this code, if the address spqr generates spqr via a forward or alias file,\n   delivery of the generated spqr stops further attempts at the top level spqr,\n   which is not what is wanted - it may have generated other addresses.\n\n . Check on the retry database to see if routing was previously deferred, but\n   only if in a queue run. Addresses that are to be routed are put on the\n   addr_route chain. Addresses that are to be deferred are put on the\n   addr_defer chain. We do all the checking first, so as not to keep the\n   retry database open any longer than necessary.\n\n . Now we run the addresses through the routers. A router may put the address\n   on either the addr_local or the addr_remote chain for local or remote\n   delivery, respectively, or put it on the addr_failed chain if it is\n   undeliveable, or it may generate child addresses and put them on the\n   addr_new chain, or it may defer an address. All the chain anchors are\n   passed as arguments so that the routers can be called for verification\n   purposes as well.\n\n . If new addresses have been generated by the routers, da capo.\n*/\n\nf.header_rewritten = FALSE;          /* No headers rewritten yet */\nwhile (addr_new)           /* Loop until all addresses dealt with */\n  {\n  address_item *addr, *parent;\n\n  /* Failure to open the retry database is treated the same as if it does\n  not exist. In both cases, dbm_file is NULL. */\n\n  if (!(dbm_file = dbfn_open(US\"retry\", O_RDONLY, &dbblock, FALSE)))\n    DEBUG(D_deliver|D_retry|D_route|D_hints_lookup)\n      debug_printf(\"no retry data available\\n\");\n\n  /* Scan the current batch of new addresses, to handle pipes, files and\n  autoreplies, and determine which others are ready for routing. */\n\n  while (addr_new)\n    {\n    int rc;\n    uschar *p;\n    tree_node *tnode;\n    dbdata_retry *domain_retry_record;\n    dbdata_retry *address_retry_record;\n\n    addr = addr_new;\n    addr_new = addr->next;\n\n    DEBUG(D_deliver|D_retry|D_route)\n      {\n      debug_printf(\">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\\n\");\n      debug_printf(\"Considering: %s\\n\", addr->address);\n      }\n\n    /* Handle generated address that is a pipe or a file or an autoreply. */\n\n    if (testflag(addr, af_pfr))\n      {\n      /* If an autoreply in a filter could not generate a syntactically valid\n      address, give up forthwith. Set af_ignore_error so that we don't try to\n      generate a bounce. */\n\n      if (testflag(addr, af_bad_reply))\n        {\n        addr->basic_errno = ERRNO_BADADDRESS2;\n        addr->local_part = addr->address;\n        addr->message =\n          US\"filter autoreply generated syntactically invalid recipient\";\n        addr->prop.ignore_error = TRUE;\n        (void) post_process_one(addr, FAIL, LOG_MAIN, EXIM_DTYPE_ROUTER, 0);\n        continue;   /* with the next new address */\n        }\n\n      /* If two different users specify delivery to the same pipe or file or\n      autoreply, there should be two different deliveries, so build a unique\n      string that incorporates the original address, and use this for\n      duplicate testing and recording delivery, and also for retrying. */\n\n      addr->unique =\n        string_sprintf(\"%s:%s\", addr->address, addr->parent->unique +\n          (testflag(addr->parent, af_homonym)? 3:0));\n\n      addr->address_retry_key = addr->domain_retry_key =\n        string_sprintf(\"T:%s\", addr->unique);\n\n      /* If a filter file specifies two deliveries to the same pipe or file,\n      we want to de-duplicate, but this is probably not wanted for two mail\n      commands to the same address, where probably both should be delivered.\n      So, we have to invent a different unique string in that case. Just\n      keep piling '>' characters on the front. */\n\n      if (addr->address[0] == '>')\n        {\n        while (tree_search(tree_duplicates, addr->unique))\n          addr->unique = string_sprintf(\">%s\", addr->unique);\n        }\n\n      else if ((tnode = tree_search(tree_duplicates, addr->unique)))\n        {\n        DEBUG(D_deliver|D_route)\n          debug_printf(\"%s is a duplicate address: discarded\\n\", addr->address);\n        addr->dupof = tnode->data.ptr;\n        addr->next = addr_duplicate;\n        addr_duplicate = addr;\n        continue;\n        }\n\n      DEBUG(D_deliver|D_route) debug_printf(\"unique = %s\\n\", addr->unique);\n\n      /* Check for previous delivery */\n\n      if (tree_search(tree_nonrecipients, addr->unique))\n        {\n        DEBUG(D_deliver|D_route)\n          debug_printf(\"%s was previously delivered: discarded\\n\", addr->address);\n        child_done(addr, tod_stamp(tod_log));\n        continue;\n        }\n\n      /* Save for checking future duplicates */\n\n      tree_add_duplicate(addr->unique, addr);\n\n      /* Set local part and domain */\n\n      addr->local_part = addr->address;\n      addr->domain = addr->parent->domain;\n\n      /* Ensure that the delivery is permitted. */\n\n      if (testflag(addr, af_file))\n        {\n        if (!testflag(addr, af_allow_file))\n          {\n          addr->basic_errno = ERRNO_FORBIDFILE;\n          addr->message = US\"delivery to file forbidden\";\n          (void)post_process_one(addr, FAIL, LOG_MAIN, EXIM_DTYPE_ROUTER, 0);\n          continue;   /* with the next new address */\n          }\n        }\n      else if (addr->address[0] == '|')\n        {\n        if (!testflag(addr, af_allow_pipe))\n          {\n          addr->basic_errno = ERRNO_FORBIDPIPE;\n          addr->message = US\"delivery to pipe forbidden\";\n          (void)post_process_one(addr, FAIL, LOG_MAIN, EXIM_DTYPE_ROUTER, 0);\n          continue;   /* with the next new address */\n          }\n        }\n      else if (!testflag(addr, af_allow_reply))\n        {\n        addr->basic_errno = ERRNO_FORBIDREPLY;\n        addr->message = US\"autoreply forbidden\";\n        (void)post_process_one(addr, FAIL, LOG_MAIN, EXIM_DTYPE_ROUTER, 0);\n        continue;     /* with the next new address */\n        }\n\n      /* If the errno field is already set to BADTRANSPORT, it indicates\n      failure to expand a transport string, or find the associated transport,\n      or an unset transport when one is required. Leave this test till now so\n      that the forbid errors are given in preference. */\n\n      if (addr->basic_errno == ERRNO_BADTRANSPORT)\n        {\n        (void)post_process_one(addr, DEFER, LOG_MAIN, EXIM_DTYPE_ROUTER, 0);\n        continue;\n        }\n\n      /* Treat /dev/null as a special case and abandon the delivery. This\n      avoids having to specify a uid on the transport just for this case.\n      Arrange for the transport name to be logged as \"**bypassed**\". */\n\n      if (Ustrcmp(addr->address, \"/dev/null\") == 0)\n        {\n        uschar *save = addr->transport->name;\n        addr->transport->name = US\"**bypassed**\";\n        (void)post_process_one(addr, OK, LOG_MAIN, EXIM_DTYPE_TRANSPORT, '=');\n        addr->transport->name = save;\n        continue;   /* with the next new address */\n        }\n\n      /* Pipe, file, or autoreply delivery is to go ahead as a normal local\n      delivery. */\n\n      DEBUG(D_deliver|D_route)\n        debug_printf(\"queued for %s transport\\n\", addr->transport->name);\n      addr->next = addr_local;\n      addr_local = addr;\n      continue;       /* with the next new address */\n      }\n\n    /* Handle normal addresses. First, split up into local part and domain,\n    handling the %-hack if necessary. There is the possibility of a defer from\n    a lookup in percent_hack_domains. */\n\n    if ((rc = deliver_split_address(addr)) == DEFER)\n      {\n      addr->message = US\"cannot check percent_hack_domains\";\n      addr->basic_errno = ERRNO_LISTDEFER;\n      (void)post_process_one(addr, DEFER, LOG_MAIN, EXIM_DTYPE_NONE, 0);\n      continue;\n      }\n\n    /* Check to see if the domain is held. If so, proceed only if the\n    delivery was forced by hand. */\n\n    deliver_domain = addr->domain;  /* set $domain */\n    if (  !forced && hold_domains\n       && (rc = match_isinlist(addr->domain, (const uschar **)&hold_domains, 0,\n           &domainlist_anchor, addr->domain_cache, MCL_DOMAIN, TRUE,\n           NULL)) != FAIL\n       )\n      {\n      if (rc == DEFER)\n        {\n        addr->message = US\"hold_domains lookup deferred\";\n        addr->basic_errno = ERRNO_LISTDEFER;\n        }\n      else\n        {\n        addr->message = US\"domain is held\";\n        addr->basic_errno = ERRNO_HELD;\n        }\n      (void)post_process_one(addr, DEFER, LOG_MAIN, EXIM_DTYPE_NONE, 0);\n      continue;\n      }\n\n    /* Now we can check for duplicates and previously delivered addresses. In\n    order to do this, we have to generate a \"unique\" value for each address,\n    because there may be identical actual addresses in a line of descendents.\n    The \"unique\" field is initialized to the same value as the \"address\" field,\n    but gets changed here to cope with identically-named descendents. */\n\n    for (parent = addr->parent; parent; parent = parent->parent)\n      if (strcmpic(addr->address, parent->address) == 0) break;\n\n    /* If there's an ancestor with the same name, set the homonym flag. This\n    influences how deliveries are recorded. Then add a prefix on the front of\n    the unique address. We use \\n\\ where n starts at 0 and increases each time.\n    It is unlikely to pass 9, but if it does, it may look odd but will still\n    work. This means that siblings or cousins with the same names are treated\n    as duplicates, which is what we want. */\n\n    if (parent)\n      {\n      setflag(addr, af_homonym);\n      if (parent->unique[0] != '\\\\')\n        addr->unique = string_sprintf(\"\\\\0\\\\%s\", addr->address);\n      else\n        addr->unique = string_sprintf(\"\\\\%c\\\\%s\", parent->unique[1] + 1,\n          addr->address);\n      }\n\n    /* Ensure that the domain in the unique field is lower cased, because\n    domains are always handled caselessly. */\n\n    p = Ustrrchr(addr->unique, '@');\n    while (*p != 0) { *p = tolower(*p); p++; }\n\n    DEBUG(D_deliver|D_route) debug_printf(\"unique = %s\\n\", addr->unique);\n\n    if (tree_search(tree_nonrecipients, addr->unique))\n      {\n      DEBUG(D_deliver|D_route)\n        debug_printf(\"%s was previously delivered: discarded\\n\", addr->unique);\n      child_done(addr, tod_stamp(tod_log));\n      continue;\n      }\n\n    /* Get the routing retry status, saving the two retry keys (with and\n    without the local part) for subsequent use. If there is no retry record for\n    the standard address routing retry key, we look for the same key with the\n    sender attached, because this form is used by the smtp transport after a\n    4xx response to RCPT when address_retry_include_sender is true. */\n\n    addr->domain_retry_key = string_sprintf(\"R:%s\", addr->domain);\n    addr->address_retry_key = string_sprintf(\"R:%s@%s\", addr->local_part,\n      addr->domain);\n\n    if (dbm_file)\n      {\n      domain_retry_record = dbfn_read(dbm_file, addr->domain_retry_key);\n      if (  domain_retry_record\n         && now - domain_retry_record->time_stamp > retry_data_expire\n\t )\n        domain_retry_record = NULL;    /* Ignore if too old */\n\n      address_retry_record = dbfn_read(dbm_file, addr->address_retry_key);\n      if (  address_retry_record\n         && now - address_retry_record->time_stamp > retry_data_expire\n\t )\n        address_retry_record = NULL;   /* Ignore if too old */\n\n      if (!address_retry_record)\n        {\n        uschar *altkey = string_sprintf(\"%s:<%s>\", addr->address_retry_key,\n          sender_address);\n        address_retry_record = dbfn_read(dbm_file, altkey);\n        if (  address_retry_record\n\t   && now - address_retry_record->time_stamp > retry_data_expire)\n          address_retry_record = NULL;   /* Ignore if too old */\n        }\n      }\n    else\n      domain_retry_record = address_retry_record = NULL;\n\n    DEBUG(D_deliver|D_retry)\n      {\n      if (!domain_retry_record)\n        debug_printf(\"no domain retry record\\n\");\n      if (!address_retry_record)\n        debug_printf(\"no address retry record\\n\");\n      }\n\n    /* If we are sending a message down an existing SMTP connection, we must\n    assume that the message which created the connection managed to route\n    an address to that connection. We do not want to run the risk of taking\n    a long time over routing here, because if we do, the server at the other\n    end of the connection may time it out. This is especially true for messages\n    with lots of addresses. For this kind of delivery, queue_running is not\n    set, so we would normally route all addresses. We take a pragmatic approach\n    and defer routing any addresses that have any kind of domain retry record.\n    That is, we don't even look at their retry times. It doesn't matter if this\n    doesn't work occasionally. This is all just an optimization, after all.\n\n    The reason for not doing the same for address retries is that they normally\n    arise from 4xx responses, not DNS timeouts. */\n\n    if (continue_hostname && domain_retry_record)\n      {\n      addr->message = US\"reusing SMTP connection skips previous routing defer\";\n      addr->basic_errno = ERRNO_RRETRY;\n      (void)post_process_one(addr, DEFER, LOG_MAIN, EXIM_DTYPE_ROUTER, 0);\n      }\n\n    /* If we are in a queue run, defer routing unless there is no retry data or\n    we've passed the next retry time, or this message is forced. In other\n    words, ignore retry data when not in a queue run.\n\n    However, if the domain retry time has expired, always allow the routing\n    attempt. If it fails again, the address will be failed. This ensures that\n    each address is routed at least once, even after long-term routing\n    failures.\n\n    If there is an address retry, check that too; just wait for the next\n    retry time. This helps with the case when the temporary error on the\n    address was really message-specific rather than address specific, since\n    it allows other messages through.\n\n    We also wait for the next retry time if this is a message sent down an\n    existing SMTP connection (even though that will be forced). Otherwise there\n    will be far too many attempts for an address that gets a 4xx error. In\n    fact, after such an error, we should not get here because, the host should\n    not be remembered as one this message needs. However, there was a bug that\n    used to cause this to  happen, so it is best to be on the safe side.\n\n    Even if we haven't reached the retry time in the hints, there is one more\n    check to do, which is for the ultimate address timeout. We only do this\n    check if there is an address retry record and there is not a domain retry\n    record; this implies that previous attempts to handle the address had the\n    retry_use_local_parts option turned on. We use this as an approximation\n    for the destination being like a local delivery, for example delivery over\n    LMTP to an IMAP message store. In this situation users are liable to bump\n    into their quota and thereby have intermittently successful deliveries,\n    which keep the retry record fresh, which can lead to us perpetually\n    deferring messages. */\n\n    else if (  (  f.queue_running && !f.deliver_force\n\t       || continue_hostname\n\t       )\n            && (  (  domain_retry_record\n\t\t  && now < domain_retry_record->next_try\n\t\t  && !domain_retry_record->expired\n\t\t  )\n\t       || (  address_retry_record\n\t\t  && now < address_retry_record->next_try\n\t       )  )\n            && (  domain_retry_record\n\t       || !address_retry_record\n\t       || !retry_ultimate_address_timeout(addr->address_retry_key,\n\t\t\t\t addr->domain, address_retry_record, now)\n\t    )  )\n      {\n      addr->message = US\"retry time not reached\";\n      addr->basic_errno = ERRNO_RRETRY;\n      (void)post_process_one(addr, DEFER, LOG_MAIN, EXIM_DTYPE_ROUTER, 0);\n      }\n\n    /* The domain is OK for routing. Remember if retry data exists so it\n    can be cleaned up after a successful delivery. */\n\n    else\n      {\n      if (domain_retry_record || address_retry_record)\n        setflag(addr, af_dr_retry_exists);\n      addr->next = addr_route;\n      addr_route = addr;\n      DEBUG(D_deliver|D_route)\n        debug_printf(\"%s: queued for routing\\n\", addr->address);\n      }\n    }\n\n  /* The database is closed while routing is actually happening. Requests to\n  update it are put on a chain and all processed together at the end. */\n\n  if (dbm_file) dbfn_close(dbm_file);\n\n  /* If queue_domains is set, we don't even want to try routing addresses in\n  those domains. During queue runs, queue_domains is forced to be unset.\n  Optimize by skipping this pass through the addresses if nothing is set. */\n\n  if (!f.deliver_force && queue_domains)\n    {\n    address_item *okaddr = NULL;\n    while (addr_route)\n      {\n      address_item *addr = addr_route;\n      addr_route = addr->next;\n\n      deliver_domain = addr->domain;  /* set $domain */\n      if ((rc = match_isinlist(addr->domain, (const uschar **)&queue_domains, 0,\n            &domainlist_anchor, addr->domain_cache, MCL_DOMAIN, TRUE, NULL))\n              != OK)\n        if (rc == DEFER)\n          {\n          addr->basic_errno = ERRNO_LISTDEFER;\n          addr->message = US\"queue_domains lookup deferred\";\n          (void)post_process_one(addr, DEFER, LOG_MAIN, EXIM_DTYPE_ROUTER, 0);\n          }\n        else\n          {\n          addr->next = okaddr;\n          okaddr = addr;\n          }\n      else\n        {\n        addr->basic_errno = ERRNO_QUEUE_DOMAIN;\n        addr->message = US\"domain is in queue_domains\";\n        (void)post_process_one(addr, DEFER, LOG_MAIN, EXIM_DTYPE_ROUTER, 0);\n        }\n      }\n\n    addr_route = okaddr;\n    }\n\n  /* Now route those addresses that are not deferred. */\n\n  while (addr_route)\n    {\n    int rc;\n    address_item *addr = addr_route;\n    const uschar *old_domain = addr->domain;\n    uschar *old_unique = addr->unique;\n    addr_route = addr->next;\n    addr->next = NULL;\n\n    /* Just in case some router parameter refers to it. */\n\n    if (!(return_path = addr->prop.errors_address))\n      return_path = sender_address;\n\n    /* If a router defers an address, add a retry item. Whether or not to\n    use the local part in the key is a property of the router. */\n\n    if ((rc = route_address(addr, &addr_local, &addr_remote, &addr_new,\n         &addr_succeed, v_none)) == DEFER)\n      retry_add_item(addr,\n        addr->router->retry_use_local_part\n        ? string_sprintf(\"R:%s@%s\", addr->local_part, addr->domain)\n\t: string_sprintf(\"R:%s\", addr->domain),\n\t0);\n\n    /* Otherwise, if there is an existing retry record in the database, add\n    retry items to delete both forms. We must also allow for the possibility\n    of a routing retry that includes the sender address. Since the domain might\n    have been rewritten (expanded to fully qualified) as a result of routing,\n    ensure that the rewritten form is also deleted. */\n\n    else if (testflag(addr, af_dr_retry_exists))\n      {\n      uschar *altkey = string_sprintf(\"%s:<%s>\", addr->address_retry_key,\n        sender_address);\n      retry_add_item(addr, altkey, rf_delete);\n      retry_add_item(addr, addr->address_retry_key, rf_delete);\n      retry_add_item(addr, addr->domain_retry_key, rf_delete);\n      if (Ustrcmp(addr->domain, old_domain) != 0)\n        retry_add_item(addr, string_sprintf(\"R:%s\", old_domain), rf_delete);\n      }\n\n    /* DISCARD is given for :blackhole: and \"seen finish\". The event has been\n    logged, but we need to ensure the address (and maybe parents) is marked\n    done. */\n\n    if (rc == DISCARD)\n      {\n      address_done(addr, tod_stamp(tod_log));\n      continue;  /* route next address */\n      }\n\n    /* The address is finished with (failed or deferred). */\n\n    if (rc != OK)\n      {\n      (void)post_process_one(addr, rc, LOG_MAIN, EXIM_DTYPE_ROUTER, 0);\n      continue;  /* route next address */\n      }\n\n    /* The address has been routed. If the router changed the domain, it will\n    also have changed the unique address. We have to test whether this address\n    has already been delivered, because it's the unique address that finally\n    gets recorded. */\n\n    if (  addr->unique != old_unique\n       && tree_search(tree_nonrecipients, addr->unique) != 0\n       )\n      {\n      DEBUG(D_deliver|D_route) debug_printf(\"%s was previously delivered: \"\n        \"discarded\\n\", addr->address);\n      if (addr_remote == addr) addr_remote = addr->next;\n      else if (addr_local == addr) addr_local = addr->next;\n      }\n\n    /* If the router has same_domain_copy_routing set, we are permitted to copy\n    the routing for any other addresses with the same domain. This is an\n    optimisation to save repeated DNS lookups for \"standard\" remote domain\n    routing. The option is settable only on routers that generate host lists.\n    We play it very safe, and do the optimization only if the address is routed\n    to a remote transport, there are no header changes, and the domain was not\n    modified by the router. */\n\n    if (  addr_remote == addr\n       && addr->router->same_domain_copy_routing\n       && !addr->prop.extra_headers\n       && !addr->prop.remove_headers\n       && old_domain == addr->domain\n       )\n      {\n      address_item **chain = &addr_route;\n      while (*chain)\n        {\n        address_item *addr2 = *chain;\n        if (Ustrcmp(addr2->domain, addr->domain) != 0)\n          {\n          chain = &(addr2->next);\n          continue;\n          }\n\n        /* Found a suitable address; take it off the routing list and add it to\n        the remote delivery list. */\n\n        *chain = addr2->next;\n        addr2->next = addr_remote;\n        addr_remote = addr2;\n\n        /* Copy the routing data */\n\n        addr2->domain = addr->domain;\n        addr2->router = addr->router;\n        addr2->transport = addr->transport;\n        addr2->host_list = addr->host_list;\n        addr2->fallback_hosts = addr->fallback_hosts;\n        addr2->prop.errors_address = addr->prop.errors_address;\n        copyflag(addr2, addr, af_hide_child);\n        copyflag(addr2, addr, af_local_host_removed);\n\n        DEBUG(D_deliver|D_route)\n          debug_printf(\">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\\n\"\n                       \"routing %s\\n\"\n                       \"Routing for %s copied from %s\\n\",\n            addr2->address, addr2->address, addr->address);\n        }\n      }\n    }  /* Continue with routing the next address. */\n  }    /* Loop to process any child addresses that the routers created, and\n          any rerouted addresses that got put back on the new chain. */\n\n\n/* Debugging: show the results of the routing */\n\nDEBUG(D_deliver|D_retry|D_route)\n  {\n  address_item *p;\n  debug_printf(\">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\\n\");\n  debug_printf(\"After routing:\\n  Local deliveries:\\n\");\n  for (p = addr_local; p; p = p->next)\n    debug_printf(\"    %s\\n\", p->address);\n\n  debug_printf(\"  Remote deliveries:\\n\");\n  for (p = addr_remote; p; p = p->next)\n    debug_printf(\"    %s\\n\", p->address);\n\n  debug_printf(\"  Failed addresses:\\n\");\n  for (p = addr_failed; p; p = p->next)\n    debug_printf(\"    %s\\n\", p->address);\n\n  debug_printf(\"  Deferred addresses:\\n\");\n  for (p = addr_defer; p; p = p->next)\n    debug_printf(\"    %s\\n\", p->address);\n  }\n\n/* Free any resources that were cached during routing. */\n\nsearch_tidyup();\nroute_tidyup();\n\n/* These two variables are set only during routing, after check_local_user.\nEnsure they are not set in transports. */\n\nlocal_user_gid = (gid_t)(-1);\nlocal_user_uid = (uid_t)(-1);\n\n/* Check for any duplicate addresses. This check is delayed until after\nrouting, because the flexibility of the routing configuration means that\nidentical addresses with different parentage may end up being redirected to\ndifferent addresses. Checking for duplicates too early (as we previously used\nto) makes this kind of thing not work. */\n\ndo_duplicate_check(&addr_local);\ndo_duplicate_check(&addr_remote);\n\n/* When acting as an MUA wrapper, we proceed only if all addresses route to a\nremote transport. The check that they all end up in one transaction happens in\nthe do_remote_deliveries() function. */\n\nif (  mua_wrapper\n   && (addr_local || addr_failed || addr_defer)\n   )\n  {\n  address_item *addr;\n  uschar *which, *colon, *msg;\n\n  if (addr_local)\n    {\n    addr = addr_local;\n    which = US\"local\";\n    }\n  else if (addr_defer)\n    {\n    addr = addr_defer;\n    which = US\"deferred\";\n    }\n  else\n    {\n    addr = addr_failed;\n    which = US\"failed\";\n    }\n\n  while (addr->parent) addr = addr->parent;\n\n  if (addr->message)\n    {\n    colon = US\": \";\n    msg = addr->message;\n    }\n  else colon = msg = US\"\";\n\n  /* We don't need to log here for a forced failure as it will already\n  have been logged. Defer will also have been logged, but as a defer, so we do\n  need to do the failure logging. */\n\n  if (addr != addr_failed)\n    log_write(0, LOG_MAIN, \"** %s routing yielded a %s delivery\",\n      addr->address, which);\n\n  /* Always write an error to the caller */\n\n  fprintf(stderr, \"routing %s yielded a %s delivery%s%s\\n\", addr->address,\n    which, colon, msg);\n\n  final_yield = DELIVER_MUA_FAILED;\n  addr_failed = addr_defer = NULL;   /* So that we remove the message */\n  goto DELIVERY_TIDYUP;\n  }\n\n\n/* If this is a run to continue deliveries to an external channel that is\nalready set up, defer any local deliveries. */\n\nif (continue_transport)\n  {\n  if (addr_defer)\n    {\n    address_item *addr = addr_defer;\n    while (addr->next) addr = addr->next;\n    addr->next = addr_local;\n    }\n  else\n    addr_defer = addr_local;\n  addr_local = NULL;\n  }\n\n\n/* Because address rewriting can happen in the routers, we should not really do\nANY deliveries until all addresses have been routed, so that all recipients of\nthe message get the same headers. However, this is in practice not always\npossible, since sometimes remote addresses give DNS timeouts for days on end.\nThe pragmatic approach is to deliver what we can now, saving any rewritten\nheaders so that at least the next lot of recipients benefit from the rewriting\nthat has already been done.\n\nIf any headers have been rewritten during routing, update the spool file to\nremember them for all subsequent deliveries. This can be delayed till later if\nthere is only address to be delivered - if it succeeds the spool write need not\nhappen. */\n\nif (  f.header_rewritten\n   && (  addr_local && (addr_local->next || addr_remote)\n      || addr_remote && addr_remote->next\n   )  )\n  {\n  /* Panic-dies on error */\n  (void)spool_write_header(message_id, SW_DELIVERING, NULL);\n  f.header_rewritten = FALSE;\n  }\n\n\n/* If there are any deliveries to be and we do not already have the journal\nfile, create it. This is used to record successful deliveries as soon as\npossible after each delivery is known to be complete. A file opened with\nO_APPEND is used so that several processes can run simultaneously.\n\nThe journal is just insurance against crashes. When the spool file is\nultimately updated at the end of processing, the journal is deleted. If a\njournal is found to exist at the start of delivery, the addresses listed\ntherein are added to the non-recipients. */\n\nif (addr_local || addr_remote)\n  {\n  if (journal_fd < 0)\n    {\n    uschar * fname = spool_fname(US\"input\", message_subdir, id, US\"-J\");\n\n    if ((journal_fd = Uopen(fname,\n#ifdef O_CLOEXEC\n\t\t\tO_CLOEXEC |\n#endif\n\t\t\tO_WRONLY|O_APPEND|O_CREAT|O_EXCL, SPOOL_MODE)) < 0)\n      {\n      log_write(0, LOG_MAIN|LOG_PANIC, \"Couldn't open journal file %s: %s\",\n\tfname, strerror(errno));\n      return DELIVER_NOT_ATTEMPTED;\n      }\n\n    /* Set the close-on-exec flag, make the file owned by Exim, and ensure\n    that the mode is correct - the group setting doesn't always seem to get\n    set automatically. */\n\n    if(  fchown(journal_fd, exim_uid, exim_gid)\n      || fchmod(journal_fd, SPOOL_MODE)\n#ifndef O_CLOEXEC\n      || fcntl(journal_fd, F_SETFD, fcntl(journal_fd, F_GETFD) | FD_CLOEXEC)\n#endif\n      )\n      {\n      int ret = Uunlink(fname);\n      log_write(0, LOG_MAIN|LOG_PANIC, \"Couldn't set perms on journal file %s: %s\",\n\tfname, strerror(errno));\n      if(ret  &&  errno != ENOENT)\n\tlog_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to unlink %s: %s\",\n\t  fname, strerror(errno));\n      return DELIVER_NOT_ATTEMPTED;\n      }\n    }\n  }\nelse if (journal_fd >= 0)\n  {\n  close(journal_fd);\n  journal_fd = -1;\n  }\n\n\n\n/* Now we can get down to the business of actually doing deliveries. Local\ndeliveries are done first, then remote ones. If ever the problems of how to\nhandle fallback transports are figured out, this section can be put into a loop\nfor handling fallbacks, though the uid switching will have to be revised. */\n\n/* Precompile a regex that is used to recognize a parameter in response\nto an LHLO command, if is isn't already compiled. This may be used on both\nlocal and remote LMTP deliveries. */\n\nif (!regex_IGNOREQUOTA)\n  regex_IGNOREQUOTA =\n    regex_must_compile(US\"\\\\n250[\\\\s\\\\-]IGNOREQUOTA(\\\\s|\\\\n|$)\", FALSE, TRUE);\n\n/* Handle local deliveries */\n\nif (addr_local)\n  {\n  DEBUG(D_deliver|D_transport)\n    debug_printf(\">>>>>>>>>>>>>>>> Local deliveries >>>>>>>>>>>>>>>>\\n\");\n  do_local_deliveries();\n  f.disable_logging = FALSE;\n  }\n\n/* If queue_run_local is set, we do not want to attempt any remote deliveries,\nso just queue them all. */\n\nif (f.queue_run_local)\n  while (addr_remote)\n    {\n    address_item *addr = addr_remote;\n    addr_remote = addr->next;\n    addr->next = NULL;\n    addr->basic_errno = ERRNO_LOCAL_ONLY;\n    addr->message = US\"remote deliveries suppressed\";\n    (void)post_process_one(addr, DEFER, LOG_MAIN, EXIM_DTYPE_TRANSPORT, 0);\n    }\n\n/* Handle remote deliveries */\n\nif (addr_remote)\n  {\n  DEBUG(D_deliver|D_transport)\n    debug_printf(\">>>>>>>>>>>>>>>> Remote deliveries >>>>>>>>>>>>>>>>\\n\");\n\n  /* Precompile some regex that are used to recognize parameters in response\n  to an EHLO command, if they aren't already compiled. */\n\n  deliver_init();\n\n  /* Now sort the addresses if required, and do the deliveries. The yield of\n  do_remote_deliveries is FALSE when mua_wrapper is set and all addresses\n  cannot be delivered in one transaction. */\n\n  if (remote_sort_domains) sort_remote_deliveries();\n  if (!do_remote_deliveries(FALSE))\n    {\n    log_write(0, LOG_MAIN, \"** mua_wrapper is set but recipients cannot all \"\n      \"be delivered in one transaction\");\n    fprintf(stderr, \"delivery to smarthost failed (configuration problem)\\n\");\n\n    final_yield = DELIVER_MUA_FAILED;\n    addr_failed = addr_defer = NULL;   /* So that we remove the message */\n    goto DELIVERY_TIDYUP;\n    }\n\n  /* See if any of the addresses that failed got put on the queue for delivery\n  to their fallback hosts. We do it this way because often the same fallback\n  host is used for many domains, so all can be sent in a single transaction\n  (if appropriately configured). */\n\n  if (addr_fallback && !mua_wrapper)\n    {\n    DEBUG(D_deliver) debug_printf(\"Delivering to fallback hosts\\n\");\n    addr_remote = addr_fallback;\n    addr_fallback = NULL;\n    if (remote_sort_domains) sort_remote_deliveries();\n    do_remote_deliveries(TRUE);\n    }\n  f.disable_logging = FALSE;\n  }\n\n\n/* All deliveries are now complete. Ignore SIGTERM during this tidying up\nphase, to minimize cases of half-done things. */\n\nDEBUG(D_deliver)\n  debug_printf(\">>>>>>>>>>>>>>>> deliveries are done >>>>>>>>>>>>>>>>\\n\");\ncancel_cutthrough_connection(TRUE, US\"deliveries are done\");\n\n/* Root privilege is no longer needed */\n\nexim_setugid(exim_uid, exim_gid, FALSE, US\"post-delivery tidying\");\n\nset_process_info(\"tidying up after delivering %s\", message_id);\nsignal(SIGTERM, SIG_IGN);\n\n/* When we are acting as an MUA wrapper, the smtp transport will either have\nsucceeded for all addresses, or failed them all in normal cases. However, there\nare some setup situations (e.g. when a named port does not exist) that cause an\nimmediate exit with deferral of all addresses. Convert those into failures. We\ndo not ever want to retry, nor do we want to send a bounce message. */\n\nif (mua_wrapper)\n  {\n  if (addr_defer)\n    {\n    address_item *addr, *nextaddr;\n    for (addr = addr_defer; addr; addr = nextaddr)\n      {\n      log_write(0, LOG_MAIN, \"** %s mua_wrapper forced failure for deferred \"\n        \"delivery\", addr->address);\n      nextaddr = addr->next;\n      addr->next = addr_failed;\n      addr_failed = addr;\n      }\n    addr_defer = NULL;\n    }\n\n  /* Now all should either have succeeded or failed. */\n\n  if (!addr_failed)\n    final_yield = DELIVER_MUA_SUCCEEDED;\n  else\n    {\n    host_item * host;\n    uschar *s = addr_failed->user_message;\n\n    if (!s) s = addr_failed->message;\n\n    fprintf(stderr, \"Delivery failed: \");\n    if (addr_failed->basic_errno > 0)\n      {\n      fprintf(stderr, \"%s\", strerror(addr_failed->basic_errno));\n      if (s) fprintf(stderr, \": \");\n      }\n    if ((host = addr_failed->host_used))\n      fprintf(stderr, \"H=%s [%s]: \", host->name, host->address);\n    if (s)\n      fprintf(stderr, \"%s\", CS s);\n    else if (addr_failed->basic_errno <= 0)\n      fprintf(stderr, \"unknown error\");\n    fprintf(stderr, \"\\n\");\n\n    final_yield = DELIVER_MUA_FAILED;\n    addr_failed = NULL;\n    }\n  }\n\n/* In a normal configuration, we now update the retry database. This is done in\none fell swoop at the end in order not to keep opening and closing (and\nlocking) the database. The code for handling retries is hived off into a\nseparate module for convenience. We pass it the addresses of the various\nchains, because deferred addresses can get moved onto the failed chain if the\nretry cutoff time has expired for all alternative destinations. Bypass the\nupdating of the database if the -N flag is set, which is a debugging thing that\nprevents actual delivery. */\n\nelse if (!f.dont_deliver)\n  retry_update(&addr_defer, &addr_failed, &addr_succeed);\n\n/* Send DSN for successful messages if requested */\naddr_senddsn = NULL;\n\nfor (addr_dsntmp = addr_succeed; addr_dsntmp; addr_dsntmp = addr_dsntmp->next)\n  {\n  /* af_ignore_error not honored here. it's not an error */\n  DEBUG(D_deliver) debug_printf(\"DSN: processing router : %s\\n\"\n      \"DSN: processing successful delivery address: %s\\n\"\n      \"DSN: Sender_address: %s\\n\"\n      \"DSN: orcpt: %s  flags: %d\\n\"\n      \"DSN: envid: %s  ret: %d\\n\"\n      \"DSN: Final recipient: %s\\n\"\n      \"DSN: Remote SMTP server supports DSN: %d\\n\",\n      addr_dsntmp->router ? addr_dsntmp->router->name : US\"(unknown)\",\n      addr_dsntmp->address,\n      sender_address,\n      addr_dsntmp->dsn_orcpt ? addr_dsntmp->dsn_orcpt : US\"NULL\",\n      addr_dsntmp->dsn_flags,\n      dsn_envid ? dsn_envid : US\"NULL\", dsn_ret,\n      addr_dsntmp->address,\n      addr_dsntmp->dsn_aware\n      );\n\n  /* send report if next hop not DSN aware or a router flagged \"last DSN hop\"\n     and a report was requested */\n  if (  (  addr_dsntmp->dsn_aware != dsn_support_yes\n\t|| addr_dsntmp->dsn_flags & rf_dsnlasthop\n        )\n     && addr_dsntmp->dsn_flags & rf_dsnflags\n     && addr_dsntmp->dsn_flags & rf_notify_success\n     )\n    {\n    /* copy and relink address_item and send report with all of them at once later */\n    address_item * addr_next = addr_senddsn;\n    addr_senddsn = store_get(sizeof(address_item));\n    *addr_senddsn = *addr_dsntmp;\n    addr_senddsn->next = addr_next;\n    }\n  else\n    DEBUG(D_deliver) debug_printf(\"DSN: not sending DSN success message\\n\");\n  }\n\nif (addr_senddsn)\n  {\n  pid_t pid;\n  int fd;\n\n  /* create exim process to send message */\n  pid = child_open_exim(&fd);\n\n  DEBUG(D_deliver) debug_printf(\"DSN: child_open_exim returns: %d\\n\", pid);\n\n  if (pid < 0)  /* Creation of child failed */\n    {\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"Process %d (parent %d) failed to \"\n      \"create child process to send failure message: %s\", getpid(),\n      getppid(), strerror(errno));\n\n    DEBUG(D_deliver) debug_printf(\"DSN: child_open_exim failed\\n\");\n    }\n  else  /* Creation of child succeeded */\n    {\n    FILE *f = fdopen(fd, \"wb\");\n    /* header only as required by RFC. only failure DSN needs to honor RET=FULL */\n    uschar * bound;\n    transport_ctx tctx = {{0}};\n\n    DEBUG(D_deliver)\n      debug_printf(\"sending error message to: %s\\n\", sender_address);\n\n    /* build unique id for MIME boundary */\n    bound = string_sprintf(TIME_T_FMT \"-eximdsn-%d\", time(NULL), rand());\n    DEBUG(D_deliver) debug_printf(\"DSN: MIME boundary: %s\\n\", bound);\n\n    if (errors_reply_to)\n      fprintf(f, \"Reply-To: %s\\n\", errors_reply_to);\n\n    fprintf(f, \"Auto-Submitted: auto-generated\\n\"\n\t\"From: Mail Delivery System <Mailer-Daemon@%s>\\n\"\n\t\"To: %s\\n\"\n\t\"Subject: Delivery Status Notification\\n\"\n\t\"Content-Type: multipart/report; report-type=delivery-status; boundary=%s\\n\"\n\t\"MIME-Version: 1.0\\n\\n\"\n\n\t\"--%s\\n\"\n\t\"Content-type: text/plain; charset=us-ascii\\n\\n\"\n\n\t\"This message was created automatically by mail delivery software.\\n\"\n\t\" ----- The following addresses had successful delivery notifications -----\\n\",\n      qualify_domain_sender, sender_address, bound, bound);\n\n    for (addr_dsntmp = addr_senddsn; addr_dsntmp;\n\t addr_dsntmp = addr_dsntmp->next)\n      fprintf(f, \"<%s> (relayed %s)\\n\\n\",\n\taddr_dsntmp->address,\n\t(addr_dsntmp->dsn_flags & rf_dsnlasthop) == 1\n\t  ? \"via non DSN router\"\n\t  : addr_dsntmp->dsn_aware == dsn_support_no\n\t  ? \"to non-DSN-aware mailer\"\n\t  : \"via non \\\"Remote SMTP\\\" router\"\n\t);\n\n    fprintf(f, \"--%s\\n\"\n\t\"Content-type: message/delivery-status\\n\\n\"\n\t\"Reporting-MTA: dns; %s\\n\",\n      bound, smtp_active_hostname);\n\n    if (dsn_envid)\n      {\t\t\t/* must be decoded from xtext: see RFC 3461:6.3a */\n      uschar *xdec_envid;\n      if (auth_xtextdecode(dsn_envid, &xdec_envid) > 0)\n        fprintf(f, \"Original-Envelope-ID: %s\\n\", dsn_envid);\n      else\n        fprintf(f, \"X-Original-Envelope-ID: error decoding xtext formatted ENVID\\n\");\n      }\n    fputc('\\n', f);\n\n    for (addr_dsntmp = addr_senddsn;\n\t addr_dsntmp;\n\t addr_dsntmp = addr_dsntmp->next)\n      {\n      if (addr_dsntmp->dsn_orcpt)\n        fprintf(f,\"Original-Recipient: %s\\n\", addr_dsntmp->dsn_orcpt);\n\n      fprintf(f, \"Action: delivered\\n\"\n\t  \"Final-Recipient: rfc822;%s\\n\"\n\t  \"Status: 2.0.0\\n\",\n\taddr_dsntmp->address);\n\n      if (addr_dsntmp->host_used && addr_dsntmp->host_used->name)\n        fprintf(f, \"Remote-MTA: dns; %s\\nDiagnostic-Code: smtp; 250 Ok\\n\\n\",\n\t  addr_dsntmp->host_used->name);\n      else\n\tfprintf(f, \"Diagnostic-Code: X-Exim; relayed via non %s router\\n\\n\",\n\t  (addr_dsntmp->dsn_flags & rf_dsnlasthop) == 1 ? \"DSN\" : \"SMTP\");\n      }\n\n    fprintf(f, \"--%s\\nContent-type: text/rfc822-headers\\n\\n\", bound);\n\n    fflush(f);\n    transport_filter_argv = NULL;   /* Just in case */\n    return_path = sender_address;   /* In case not previously set */\n\n    /* Write the original email out */\n\n    tctx.u.fd = fileno(f);\n    tctx.options = topt_add_return_path | topt_no_body;\n    transport_write_message(&tctx, 0);\n    fflush(f);\n\n    fprintf(f,\"\\n--%s--\\n\", bound);\n\n    fflush(f);\n    fclose(f);\n    rc = child_close(pid, 0);     /* Waits for child to close, no timeout */\n    }\n  }\n\n/* If any addresses failed, we must send a message to somebody, unless\naf_ignore_error is set, in which case no action is taken. It is possible for\nseveral messages to get sent if there are addresses with different\nrequirements. */\n\nwhile (addr_failed)\n  {\n  pid_t pid;\n  int fd;\n  uschar *logtod = tod_stamp(tod_log);\n  address_item *addr;\n  address_item *handled_addr = NULL;\n  address_item **paddr;\n  address_item *msgchain = NULL;\n  address_item **pmsgchain = &msgchain;\n\n  /* There are weird cases when logging is disabled in the transport. However,\n  there may not be a transport (address failed by a router). */\n\n  f.disable_logging = FALSE;\n  if (addr_failed->transport)\n    f.disable_logging = addr_failed->transport->disable_logging;\n\n  DEBUG(D_deliver)\n    debug_printf(\"processing failed address %s\\n\", addr_failed->address);\n\n  /* There are only two ways an address in a bounce message can get here:\n\n  (1) When delivery was initially deferred, but has now timed out (in the call\n      to retry_update() above). We can detect this by testing for\n      af_retry_timedout. If the address does not have its own errors address,\n      we arrange to ignore the error.\n\n  (2) If delivery failures for bounce messages are being ignored. We can detect\n      this by testing for af_ignore_error. This will also be set if a bounce\n      message has been autothawed and the ignore_bounce_errors_after time has\n      passed. It might also be set if a router was explicitly configured to\n      ignore errors (errors_to = \"\").\n\n  If neither of these cases obtains, something has gone wrong. Log the\n  incident, but then ignore the error. */\n\n  if (sender_address[0] == 0 && !addr_failed->prop.errors_address)\n    {\n    if (  !testflag(addr_failed, af_retry_timedout)\n       && !addr_failed->prop.ignore_error)\n      log_write(0, LOG_MAIN|LOG_PANIC, \"internal error: bounce message \"\n        \"failure is neither frozen nor ignored (it's been ignored)\");\n\n    addr_failed->prop.ignore_error = TRUE;\n    }\n\n  /* If the first address on the list has af_ignore_error set, just remove\n  it from the list, throw away any saved message file, log it, and\n  mark the recipient done. */\n\n  if (  addr_failed->prop.ignore_error\n     || (  addr_failed->dsn_flags & rf_dsnflags\n        && (addr_failed->dsn_flags & rf_notify_failure) != rf_notify_failure\n     )  )\n    {\n    addr = addr_failed;\n    addr_failed = addr->next;\n    if (addr->return_filename) Uunlink(addr->return_filename);\n\n    log_write(0, LOG_MAIN, \"%s%s%s%s: error ignored\",\n      addr->address,\n      !addr->parent ? US\"\" : US\" <\",\n      !addr->parent ? US\"\" : addr->parent->address,\n      !addr->parent ? US\"\" : US\">\");\n\n    address_done(addr, logtod);\n    child_done(addr, logtod);\n    /* Panic-dies on error */\n    (void)spool_write_header(message_id, SW_DELIVERING, NULL);\n    }\n\n  /* Otherwise, handle the sending of a message. Find the error address for\n  the first address, then send a message that includes all failed addresses\n  that have the same error address. Note the bounce_recipient is a global so\n  that it can be accessed by $bounce_recipient while creating a customized\n  error message. */\n\n  else\n    {\n    if (!(bounce_recipient = addr_failed->prop.errors_address))\n      bounce_recipient = sender_address;\n\n    /* Make a subprocess to send a message */\n\n    if ((pid = child_open_exim(&fd)) < 0)\n      log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"Process %d (parent %d) failed to \"\n        \"create child process to send failure message: %s\", getpid(),\n        getppid(), strerror(errno));\n\n    /* Creation of child succeeded */\n\n    else\n      {\n      int ch, rc;\n      int filecount = 0;\n      int rcount = 0;\n      uschar *bcc, *emf_text;\n      FILE * fp = fdopen(fd, \"wb\");\n      FILE * emf = NULL;\n      BOOL to_sender = strcmpic(sender_address, bounce_recipient) == 0;\n      int max = (bounce_return_size_limit/DELIVER_IN_BUFFER_SIZE + 1) *\n        DELIVER_IN_BUFFER_SIZE;\n      uschar * bound;\n      uschar *dsnlimitmsg;\n      uschar *dsnnotifyhdr;\n      int topt;\n\n      DEBUG(D_deliver)\n        debug_printf(\"sending error message to: %s\\n\", bounce_recipient);\n\n      /* Scan the addresses for all that have the same errors address, removing\n      them from the addr_failed chain, and putting them on msgchain. */\n\n      paddr = &addr_failed;\n      for (addr = addr_failed; addr; addr = *paddr)\n        if (Ustrcmp(bounce_recipient, addr->prop.errors_address\n\t      ? addr->prop.errors_address : sender_address) == 0)\n          {                          /* The same - dechain */\n          *paddr = addr->next;\n          *pmsgchain = addr;\n          addr->next = NULL;\n          pmsgchain = &(addr->next);\n          }\n        else\n          paddr = &addr->next;        /* Not the same; skip */\n\n      /* Include X-Failed-Recipients: for automatic interpretation, but do\n      not let any one header line get too long. We do this by starting a\n      new header every 50 recipients. Omit any addresses for which the\n      \"hide_child\" flag is set. */\n\n      for (addr = msgchain; addr; addr = addr->next)\n        {\n        if (testflag(addr, af_hide_child)) continue;\n        if (rcount >= 50)\n          {\n          fprintf(fp, \"\\n\");\n          rcount = 0;\n          }\n        fprintf(fp, \"%s%s\",\n          rcount++ == 0\n\t  ? \"X-Failed-Recipients: \"\n\t  : \",\\n  \",\n          testflag(addr, af_pfr) && addr->parent\n\t  ? string_printing(addr->parent->address)\n\t  : string_printing(addr->address));\n        }\n      if (rcount > 0) fprintf(fp, \"\\n\");\n\n      /* Output the standard headers */\n\n      if (errors_reply_to)\n        fprintf(fp, \"Reply-To: %s\\n\", errors_reply_to);\n      fprintf(fp, \"Auto-Submitted: auto-replied\\n\");\n      moan_write_from(fp);\n      fprintf(fp, \"To: %s\\n\", bounce_recipient);\n\n      /* generate boundary string and output MIME-Headers */\n      bound = string_sprintf(TIME_T_FMT \"-eximdsn-%d\", time(NULL), rand());\n\n      fprintf(fp, \"Content-Type: multipart/report;\"\n\t    \" report-type=delivery-status; boundary=%s\\n\"\n\t  \"MIME-Version: 1.0\\n\",\n\tbound);\n\n      /* Open a template file if one is provided. Log failure to open, but\n      carry on - default texts will be used. */\n\n      if (bounce_message_file)\n        if (!(emf = Ufopen(bounce_message_file, \"rb\")))\n          log_write(0, LOG_MAIN|LOG_PANIC, \"Failed to open %s for error \"\n            \"message texts: %s\", bounce_message_file, strerror(errno));\n\n      /* Quietly copy to configured additional addresses if required. */\n\n      if ((bcc = moan_check_errorcopy(bounce_recipient)))\n\tfprintf(fp, \"Bcc: %s\\n\", bcc);\n\n      /* The texts for the message can be read from a template file; if there\n      isn't one, or if it is too short, built-in texts are used. The first\n      emf text is a Subject: and any other headers. */\n\n      if ((emf_text = next_emf(emf, US\"header\")))\n\tfprintf(fp, \"%s\\n\", emf_text);\n      else\n        fprintf(fp, \"Subject: Mail delivery failed%s\\n\\n\",\n          to_sender? \": returning message to sender\" : \"\");\n\n      /* output human readable part as text/plain section */\n      fprintf(fp, \"--%s\\n\"\n\t  \"Content-type: text/plain; charset=us-ascii\\n\\n\",\n\tbound);\n\n      if ((emf_text = next_emf(emf, US\"intro\")))\n\tfprintf(fp, \"%s\", CS emf_text);\n      else\n        {\n        fprintf(fp,\n/* This message has been reworded several times. It seems to be confusing to\nsomebody, however it is worded. I have retreated to the original, simple\nwording. */\n\"This message was created automatically by mail delivery software.\\n\");\n\n        if (bounce_message_text)\n\t  fprintf(fp, \"%s\", CS bounce_message_text);\n        if (to_sender)\n          fprintf(fp,\n\"\\nA message that you sent could not be delivered to one or more of its\\n\"\n\"recipients. This is a permanent error. The following address(es) failed:\\n\");\n        else\n          fprintf(fp,\n\"\\nA message sent by\\n\\n  <%s>\\n\\n\"\n\"could not be delivered to one or more of its recipients. The following\\n\"\n\"address(es) failed:\\n\", sender_address);\n        }\n      fputc('\\n', fp);\n\n      /* Process the addresses, leaving them on the msgchain if they have a\n      file name for a return message. (There has already been a check in\n      post_process_one() for the existence of data in the message file.) A TRUE\n      return from print_address_information() means that the address is not\n      hidden. */\n\n      paddr = &msgchain;\n      for (addr = msgchain; addr; addr = *paddr)\n        {\n        if (print_address_information(addr, fp, US\"  \", US\"\\n    \", US\"\"))\n          print_address_error(addr, fp, US\"\");\n\n        /* End the final line for the address */\n\n        fputc('\\n', fp);\n\n        /* Leave on msgchain if there's a return file. */\n\n        if (addr->return_file >= 0)\n          {\n          paddr = &(addr->next);\n          filecount++;\n          }\n\n        /* Else save so that we can tick off the recipient when the\n        message is sent. */\n\n        else\n          {\n          *paddr = addr->next;\n          addr->next = handled_addr;\n          handled_addr = addr;\n          }\n        }\n\n      fputc('\\n', fp);\n\n      /* Get the next text, whether we need it or not, so as to be\n      positioned for the one after. */\n\n      emf_text = next_emf(emf, US\"generated text\");\n\n      /* If there were any file messages passed by the local transports,\n      include them in the message. Then put the address on the handled chain.\n      In the case of a batch of addresses that were all sent to the same\n      transport, the return_file field in all of them will contain the same\n      fd, and the return_filename field in the *last* one will be set (to the\n      name of the file). */\n\n      if (msgchain)\n        {\n        address_item *nextaddr;\n\n        if (emf_text)\n\t  fprintf(fp, \"%s\", CS emf_text);\n\telse\n          fprintf(fp,\n            \"The following text was generated during the delivery \"\n            \"attempt%s:\\n\", (filecount > 1)? \"s\" : \"\");\n\n        for (addr = msgchain; addr; addr = nextaddr)\n          {\n          FILE *fm;\n          address_item *topaddr = addr;\n\n          /* List all the addresses that relate to this file */\n\n\t  fputc('\\n', fp);\n          while(addr)                   /* Insurance */\n            {\n            print_address_information(addr, fp, US\"------ \",  US\"\\n       \",\n              US\" ------\\n\");\n            if (addr->return_filename) break;\n            addr = addr->next;\n            }\n\t  fputc('\\n', fp);\n\n          /* Now copy the file */\n\n          if (!(fm = Ufopen(addr->return_filename, \"rb\")))\n            fprintf(fp, \"    +++ Exim error... failed to open text file: %s\\n\",\n              strerror(errno));\n          else\n            {\n            while ((ch = fgetc(fm)) != EOF) fputc(ch, fp);\n            (void)fclose(fm);\n            }\n          Uunlink(addr->return_filename);\n\n          /* Can now add to handled chain, first fishing off the next\n          address on the msgchain. */\n\n          nextaddr = addr->next;\n          addr->next = handled_addr;\n          handled_addr = topaddr;\n          }\n\tfputc('\\n', fp);\n        }\n\n      /* output machine readable part */\n#ifdef SUPPORT_I18N\n      if (message_smtputf8)\n\tfprintf(fp, \"--%s\\n\"\n\t    \"Content-type: message/global-delivery-status\\n\\n\"\n\t    \"Reporting-MTA: dns; %s\\n\",\n\t  bound, smtp_active_hostname);\n      else\n#endif\n\tfprintf(fp, \"--%s\\n\"\n\t    \"Content-type: message/delivery-status\\n\\n\"\n\t    \"Reporting-MTA: dns; %s\\n\",\n\t  bound, smtp_active_hostname);\n\n      if (dsn_envid)\n\t{\n        /* must be decoded from xtext: see RFC 3461:6.3a */\n        uschar *xdec_envid;\n        if (auth_xtextdecode(dsn_envid, &xdec_envid) > 0)\n          fprintf(fp, \"Original-Envelope-ID: %s\\n\", dsn_envid);\n        else\n          fprintf(fp, \"X-Original-Envelope-ID: error decoding xtext formatted ENVID\\n\");\n        }\n      fputc('\\n', fp);\n\n      for (addr = handled_addr; addr; addr = addr->next)\n        {\n\thost_item * hu;\n        fprintf(fp, \"Action: failed\\n\"\n\t    \"Final-Recipient: rfc822;%s\\n\"\n\t    \"Status: 5.0.0\\n\",\n\t    addr->address);\n        if ((hu = addr->host_used) && hu->name)\n\t  {\n\t  fprintf(fp, \"Remote-MTA: dns; %s\\n\", hu->name);\n#ifdef EXPERIMENTAL_DSN_INFO\n\t  {\n\t  const uschar * s;\n\t  if (hu->address)\n\t    {\n\t    uschar * p = hu->port == 25\n\t      ? US\"\" : string_sprintf(\":%d\", hu->port);\n\t    fprintf(fp, \"Remote-MTA: X-ip; [%s]%s\\n\", hu->address, p);\n\t    }\n\t  if ((s = addr->smtp_greeting) && *s)\n\t    fprintf(fp, \"X-Remote-MTA-smtp-greeting: X-str; %s\\n\", s);\n\t  if ((s = addr->helo_response) && *s)\n\t    fprintf(fp, \"X-Remote-MTA-helo-response: X-str; %s\\n\", s);\n\t  if ((s = addr->message) && *s)\n\t    fprintf(fp, \"X-Exim-Diagnostic: X-str; %s\\n\", s);\n\t  }\n#endif\n\t  print_dsn_diagnostic_code(addr, fp);\n\t  }\n\tfputc('\\n', fp);\n        }\n\n      /* Now copy the message, trying to give an intelligible comment if\n      it is too long for it all to be copied. The limit isn't strictly\n      applied because of the buffering. There is, however, an option\n      to suppress copying altogether. */\n\n      emf_text = next_emf(emf, US\"copy\");\n\n      /* add message body\n         we ignore the intro text from template and add\n         the text for bounce_return_size_limit at the end.\n\n         bounce_return_message is ignored\n         in case RET= is defined we honor these values\n         otherwise bounce_return_body is honored.\n\n         bounce_return_size_limit is always honored.\n      */\n\n      fprintf(fp, \"--%s\\n\", bound);\n\n      dsnlimitmsg = US\"X-Exim-DSN-Information: Due to administrative limits only headers are returned\";\n      dsnnotifyhdr = NULL;\n      topt = topt_add_return_path;\n\n      /* RET=HDRS? top priority */\n      if (dsn_ret == dsn_ret_hdrs)\n        topt |= topt_no_body;\n      else\n\t{\n\tstruct stat statbuf;\n\n        /* no full body return at all? */\n        if (!bounce_return_body)\n          {\n          topt |= topt_no_body;\n          /* add header if we overrule RET=FULL */\n          if (dsn_ret == dsn_ret_full)\n            dsnnotifyhdr = dsnlimitmsg;\n          }\n\t/* line length limited... return headers only if oversize */\n        /* size limited ... return headers only if limit reached */\n\telse if (  max_received_linelength > bounce_return_linesize_limit\n\t\t|| (  bounce_return_size_limit > 0\n\t\t   && fstat(deliver_datafile, &statbuf) == 0\n\t\t   && statbuf.st_size > max\n\t\t)  )\n\t  {\n\t  topt |= topt_no_body;\n\t  dsnnotifyhdr = dsnlimitmsg;\n          }\n\t}\n\n#ifdef SUPPORT_I18N\n      if (message_smtputf8)\n\tfputs(topt & topt_no_body ? \"Content-type: message/global-headers\\n\\n\"\n\t\t\t\t  : \"Content-type: message/global\\n\\n\",\n\t      fp);\n      else\n#endif\n\tfputs(topt & topt_no_body ? \"Content-type: text/rfc822-headers\\n\\n\"\n\t\t\t\t  : \"Content-type: message/rfc822\\n\\n\",\n\t      fp);\n\n      fflush(fp);\n      transport_filter_argv = NULL;   /* Just in case */\n      return_path = sender_address;   /* In case not previously set */\n\t{\t\t\t      /* Dummy transport for headers add */\n\ttransport_ctx tctx = {{0}};\n\ttransport_instance tb = {0};\n\n\ttctx.u.fd = fileno(fp);\n\ttctx.tblock = &tb;\n\ttctx.options = topt;\n\ttb.add_headers = dsnnotifyhdr;\n\n\ttransport_write_message(&tctx, 0);\n\t}\n      fflush(fp);\n\n      /* we never add the final text. close the file */\n      if (emf)\n        (void)fclose(emf);\n\n      fprintf(fp, \"\\n--%s--\\n\", bound);\n\n      /* Close the file, which should send an EOF to the child process\n      that is receiving the message. Wait for it to finish. */\n\n      (void)fclose(fp);\n      rc = child_close(pid, 0);     /* Waits for child to close, no timeout */\n\n      /* In the test harness, let the child do it's thing first. */\n\n      if (f.running_in_test_harness) millisleep(500);\n\n      /* If the process failed, there was some disaster in setting up the\n      error message. Unless the message is very old, ensure that addr_defer\n      is non-null, which will have the effect of leaving the message on the\n      spool. The failed addresses will get tried again next time. However, we\n      don't really want this to happen too often, so freeze the message unless\n      there are some genuine deferred addresses to try. To do this we have\n      to call spool_write_header() here, because with no genuine deferred\n      addresses the normal code below doesn't get run. */\n\n      if (rc != 0)\n        {\n        uschar *s = US\"\";\n        if (now - received_time.tv_sec < retry_maximum_timeout && !addr_defer)\n          {\n          addr_defer = (address_item *)(+1);\n          f.deliver_freeze = TRUE;\n          deliver_frozen_at = time(NULL);\n          /* Panic-dies on error */\n          (void)spool_write_header(message_id, SW_DELIVERING, NULL);\n          s = US\" (frozen)\";\n          }\n        deliver_msglog(\"Process failed (%d) when writing error message \"\n          \"to %s%s\", rc, bounce_recipient, s);\n        log_write(0, LOG_MAIN, \"Process failed (%d) when writing error message \"\n          \"to %s%s\", rc, bounce_recipient, s);\n        }\n\n      /* The message succeeded. Ensure that the recipients that failed are\n      now marked finished with on the spool and their parents updated. */\n\n      else\n        {\n        for (addr = handled_addr; addr; addr = addr->next)\n          {\n          address_done(addr, logtod);\n          child_done(addr, logtod);\n          }\n        /* Panic-dies on error */\n        (void)spool_write_header(message_id, SW_DELIVERING, NULL);\n        }\n      }\n    }\n  }\n\nf.disable_logging = FALSE;  /* In case left set */\n\n/* Come here from the mua_wrapper case if routing goes wrong */\n\nDELIVERY_TIDYUP:\n\n/* If there are now no deferred addresses, we are done. Preserve the\nmessage log if so configured, and we are using them. Otherwise, sling it.\nThen delete the message itself. */\n\nif (!addr_defer)\n  {\n  uschar * fname;\n\n  if (message_logs)\n    {\n    fname = spool_fname(US\"msglog\", message_subdir, id, US\"\");\n    if (preserve_message_logs)\n      {\n      int rc;\n      uschar * moname = spool_fname(US\"msglog.OLD\", US\"\", id, US\"\");\n\n      if ((rc = Urename(fname, moname)) < 0)\n        {\n        (void)directory_make(spool_directory,\n\t\t\t      spool_sname(US\"msglog.OLD\", US\"\"),\n\t\t\t      MSGLOG_DIRECTORY_MODE, TRUE);\n        rc = Urename(fname, moname);\n        }\n      if (rc < 0)\n        log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to move %s to the \"\n          \"msglog.OLD directory\", fname);\n      }\n    else\n      if (Uunlink(fname) < 0)\n        log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to unlink %s: %s\",\n\t\t  fname, strerror(errno));\n    }\n\n  /* Remove the two message files. */\n\n  fname = spool_fname(US\"input\", message_subdir, id, US\"-D\");\n  if (Uunlink(fname) < 0)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to unlink %s: %s\",\n      fname, strerror(errno));\n  fname = spool_fname(US\"input\", message_subdir, id, US\"-H\");\n  if (Uunlink(fname) < 0)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to unlink %s: %s\",\n      fname, strerror(errno));\n\n  /* Log the end of this message, with queue time if requested. */\n\n  if (LOGGING(queue_time_overall))\n    log_write(0, LOG_MAIN, \"Completed QT=%s\", string_timesince(&received_time));\n  else\n    log_write(0, LOG_MAIN, \"Completed\");\n\n  /* Unset deliver_freeze so that we won't try to move the spool files further down */\n  f.deliver_freeze = FALSE;\n\n#ifndef DISABLE_EVENT\n  (void) event_raise(event_action, US\"msg:complete\", NULL);\n#endif\n  }\n\n/* If there are deferred addresses, we are keeping this message because it is\nnot yet completed. Lose any temporary files that were catching output from\npipes for any of the deferred addresses, handle one-time aliases, and see if\nthe message has been on the queue for so long that it is time to send a warning\nmessage to the sender, unless it is a mailer-daemon. If all deferred addresses\nhave the same domain, we can set deliver_domain for the expansion of\ndelay_warning_ condition - if any of them are pipes, files, or autoreplies, use\nthe parent's domain.\n\nIf all the deferred addresses have an error number that indicates \"retry time\nnot reached\", skip sending the warning message, because it won't contain the\nreason for the delay. It will get sent at the next real delivery attempt.\nHowever, if at least one address has tried, we'd better include all of them in\nthe message.\n\nIf we can't make a process to send the message, don't worry.\n\nFor mailing list expansions we want to send the warning message to the\nmailing list manager. We can't do a perfect job here, as some addresses may\nhave different errors addresses, but if we take the errors address from\neach deferred address it will probably be right in most cases.\n\nIf addr_defer == +1, it means there was a problem sending an error message\nfor failed addresses, and there were no \"real\" deferred addresses. The value\nwas set just to keep the message on the spool, so there is nothing to do here.\n*/\n\nelse if (addr_defer != (address_item *)(+1))\n  {\n  address_item *addr;\n  uschar *recipients = US\"\";\n  BOOL delivery_attempted = FALSE;\n\n  deliver_domain = testflag(addr_defer, af_pfr)\n    ? addr_defer->parent->domain : addr_defer->domain;\n\n  for (addr = addr_defer; addr; addr = addr->next)\n    {\n    address_item *otaddr;\n\n    if (addr->basic_errno > ERRNO_RETRY_BASE) delivery_attempted = TRUE;\n\n    if (deliver_domain)\n      {\n      const uschar *d = testflag(addr, af_pfr)\n\t? addr->parent->domain : addr->domain;\n\n      /* The domain may be unset for an address that has never been routed\n      because the system filter froze the message. */\n\n      if (!d || Ustrcmp(d, deliver_domain) != 0)\n        deliver_domain = NULL;\n      }\n\n    if (addr->return_filename) Uunlink(addr->return_filename);\n\n    /* Handle the case of one-time aliases. If any address in the ancestry\n    of this one is flagged, ensure it is in the recipients list, suitably\n    flagged, and that its parent is marked delivered. */\n\n    for (otaddr = addr; otaddr; otaddr = otaddr->parent)\n      if (otaddr->onetime_parent) break;\n\n    if (otaddr)\n      {\n      int i;\n      int t = recipients_count;\n\n      for (i = 0; i < recipients_count; i++)\n        {\n        uschar *r = recipients_list[i].address;\n        if (Ustrcmp(otaddr->onetime_parent, r) == 0) t = i;\n        if (Ustrcmp(otaddr->address, r) == 0) break;\n        }\n\n      /* Didn't find the address already in the list, and did find the\n      ultimate parent's address in the list, and they really are different\n      (i.e. not from an identity-redirect). After adding the recipient,\n      update the errors address in the recipients list. */\n\n      if (  i >= recipients_count && t < recipients_count\n         && Ustrcmp(otaddr->address, otaddr->parent->address) != 0)\n        {\n        DEBUG(D_deliver) debug_printf(\"one_time: adding %s in place of %s\\n\",\n          otaddr->address, otaddr->parent->address);\n        receive_add_recipient(otaddr->address, t);\n        recipients_list[recipients_count-1].errors_to = otaddr->prop.errors_address;\n        tree_add_nonrecipient(otaddr->parent->address);\n        update_spool = TRUE;\n        }\n      }\n\n    /* Except for error messages, ensure that either the errors address for\n    this deferred address or, if there is none, the sender address, is on the\n    list of recipients for a warning message. */\n\n    if (sender_address[0])\n      {\n      uschar * s = addr->prop.errors_address;\n      if (!s) s = sender_address;\n      if (Ustrstr(recipients, s) == NULL)\n\trecipients = string_sprintf(\"%s%s%s\", recipients,\n\t  recipients[0] ? \",\" : \"\", s);\n      }\n    }\n\n  /* Send a warning message if the conditions are right. If the condition check\n  fails because of a lookup defer, there is nothing we can do. The warning\n  is not sent. Another attempt will be made at the next delivery attempt (if\n  it also defers). */\n\n  if (  !f.queue_2stage\n     && delivery_attempted\n     && (  ((addr_defer->dsn_flags & rf_dsnflags) == 0)\n        || (addr_defer->dsn_flags & rf_notify_delay) == rf_notify_delay\n\t)\n     && delay_warning[1] > 0\n     && sender_address[0] != 0\n     && (  !delay_warning_condition\n        || expand_check_condition(delay_warning_condition,\n            US\"delay_warning\", US\"option\")\n\t)\n     )\n    {\n    int count;\n    int show_time;\n    int queue_time = time(NULL) - received_time.tv_sec;\n\n    /* When running in the test harness, there's an option that allows us to\n    fudge this time so as to get repeatability of the tests. Take the first\n    time off the list. In queue runs, the list pointer gets updated in the\n    calling process. */\n\n    if (f.running_in_test_harness && fudged_queue_times[0] != 0)\n      {\n      int qt = readconf_readtime(fudged_queue_times, '/', FALSE);\n      if (qt >= 0)\n        {\n        DEBUG(D_deliver) debug_printf(\"fudged queue_times = %s\\n\",\n          fudged_queue_times);\n        queue_time = qt;\n        }\n      }\n\n    /* See how many warnings we should have sent by now */\n\n    for (count = 0; count < delay_warning[1]; count++)\n      if (queue_time < delay_warning[count+2]) break;\n\n    show_time = delay_warning[count+1];\n\n    if (count >= delay_warning[1])\n      {\n      int extra;\n      int last_gap = show_time;\n      if (count > 1) last_gap -= delay_warning[count];\n      extra = (queue_time - delay_warning[count+1])/last_gap;\n      show_time += last_gap * extra;\n      count += extra;\n      }\n\n    DEBUG(D_deliver)\n      {\n      debug_printf(\"time on queue = %s\\n\", readconf_printtime(queue_time));\n      debug_printf(\"warning counts: required %d done %d\\n\", count,\n        warning_count);\n      }\n\n    /* We have computed the number of warnings there should have been by now.\n    If there haven't been enough, send one, and up the count to what it should\n    have been. */\n\n    if (warning_count < count)\n      {\n      header_line *h;\n      int fd;\n      pid_t pid = child_open_exim(&fd);\n\n      if (pid > 0)\n        {\n        uschar *wmf_text;\n        FILE *wmf = NULL;\n        FILE *f = fdopen(fd, \"wb\");\n\tuschar * bound;\n\ttransport_ctx tctx = {{0}};\n\n        if (warn_message_file)\n          if (!(wmf = Ufopen(warn_message_file, \"rb\")))\n            log_write(0, LOG_MAIN|LOG_PANIC, \"Failed to open %s for warning \"\n              \"message texts: %s\", warn_message_file, strerror(errno));\n\n        warnmsg_recipients = recipients;\n        warnmsg_delay = queue_time < 120*60\n\t  ? string_sprintf(\"%d minutes\", show_time/60)\n\t  : string_sprintf(\"%d hours\", show_time/3600);\n\n        if (errors_reply_to)\n          fprintf(f, \"Reply-To: %s\\n\", errors_reply_to);\n        fprintf(f, \"Auto-Submitted: auto-replied\\n\");\n        moan_write_from(f);\n        fprintf(f, \"To: %s\\n\", recipients);\n\n        /* generated boundary string and output MIME-Headers */\n        bound = string_sprintf(TIME_T_FMT \"-eximdsn-%d\", time(NULL), rand());\n\n        fprintf(f, \"Content-Type: multipart/report;\"\n\t    \" report-type=delivery-status; boundary=%s\\n\"\n\t    \"MIME-Version: 1.0\\n\",\n\t  bound);\n\n        if ((wmf_text = next_emf(wmf, US\"header\")))\n          fprintf(f, \"%s\\n\", wmf_text);\n        else\n          fprintf(f, \"Subject: Warning: message %s delayed %s\\n\\n\",\n            message_id, warnmsg_delay);\n\n        /* output human readable part as text/plain section */\n        fprintf(f, \"--%s\\n\"\n\t    \"Content-type: text/plain; charset=us-ascii\\n\\n\",\n\t  bound);\n\n        if ((wmf_text = next_emf(wmf, US\"intro\")))\n\t  fprintf(f, \"%s\", CS wmf_text);\n\telse\n          {\n          fprintf(f,\n\"This message was created automatically by mail delivery software.\\n\");\n\n          if (Ustrcmp(recipients, sender_address) == 0)\n            fprintf(f,\n\"A message that you sent has not yet been delivered to one or more of its\\n\"\n\"recipients after more than \");\n\n          else\n\t    fprintf(f,\n\"A message sent by\\n\\n  <%s>\\n\\n\"\n\"has not yet been delivered to one or more of its recipients after more than \\n\",\n\t      sender_address);\n\n          fprintf(f, \"%s on the queue on %s.\\n\\n\"\n\t      \"The message identifier is:     %s\\n\",\n\t    warnmsg_delay, primary_hostname, message_id);\n\n          for (h = header_list; h; h = h->next)\n            if (strncmpic(h->text, US\"Subject:\", 8) == 0)\n              fprintf(f, \"The subject of the message is: %s\", h->text + 9);\n            else if (strncmpic(h->text, US\"Date:\", 5) == 0)\n              fprintf(f, \"The date of the message is:    %s\", h->text + 6);\n          fputc('\\n', f);\n\n          fprintf(f, \"The address%s to which the message has not yet been \"\n            \"delivered %s:\\n\",\n            !addr_defer->next ? \"\" : \"es\",\n            !addr_defer->next ? \"is\": \"are\");\n          }\n\n        /* List the addresses, with error information if allowed */\n\n        /* store addr_defer for machine readable part */\n        address_item *addr_dsndefer = addr_defer;\n        fputc('\\n', f);\n        while (addr_defer)\n          {\n          address_item *addr = addr_defer;\n          addr_defer = addr->next;\n          if (print_address_information(addr, f, US\"  \", US\"\\n    \", US\"\"))\n            print_address_error(addr, f, US\"Delay reason: \");\n          fputc('\\n', f);\n          }\n        fputc('\\n', f);\n\n        /* Final text */\n\n        if (wmf)\n          {\n          if ((wmf_text = next_emf(wmf, US\"final\")))\n\t    fprintf(f, \"%s\", CS wmf_text);\n          (void)fclose(wmf);\n          }\n        else\n          {\n          fprintf(f,\n\"No action is required on your part. Delivery attempts will continue for\\n\"\n\"some time, and this warning may be repeated at intervals if the message\\n\"\n\"remains undelivered. Eventually the mail delivery software will give up,\\n\"\n\"and when that happens, the message will be returned to you.\\n\");\n          }\n\n        /* output machine readable part */\n        fprintf(f, \"\\n--%s\\n\"\n\t    \"Content-type: message/delivery-status\\n\\n\"\n\t    \"Reporting-MTA: dns; %s\\n\",\n\t  bound,\n\t  smtp_active_hostname);\n\n\n        if (dsn_envid)\n\t  {\n          /* must be decoded from xtext: see RFC 3461:6.3a */\n          uschar *xdec_envid;\n          if (auth_xtextdecode(dsn_envid, &xdec_envid) > 0)\n            fprintf(f,\"Original-Envelope-ID: %s\\n\", dsn_envid);\n          else\n            fprintf(f,\"X-Original-Envelope-ID: error decoding xtext formatted ENVID\\n\");\n          }\n        fputc('\\n', f);\n\n        for ( ; addr_dsndefer; addr_dsndefer = addr_dsndefer->next)\n          {\n          if (addr_dsndefer->dsn_orcpt)\n            fprintf(f, \"Original-Recipient: %s\\n\", addr_dsndefer->dsn_orcpt);\n\n          fprintf(f, \"Action: delayed\\n\"\n\t      \"Final-Recipient: rfc822;%s\\n\"\n\t      \"Status: 4.0.0\\n\",\n\t    addr_dsndefer->address);\n          if (addr_dsndefer->host_used && addr_dsndefer->host_used->name)\n            {\n            fprintf(f, \"Remote-MTA: dns; %s\\n\",\n\t\t    addr_dsndefer->host_used->name);\n            print_dsn_diagnostic_code(addr_dsndefer, f);\n            }\n\t  fputc('\\n', f);\n          }\n\n        fprintf(f, \"--%s\\n\"\n\t    \"Content-type: text/rfc822-headers\\n\\n\",\n\t  bound);\n\n        fflush(f);\n        /* header only as required by RFC. only failure DSN needs to honor RET=FULL */\n\ttctx.u.fd = fileno(f);\n        tctx.options = topt_add_return_path | topt_no_body;\n        transport_filter_argv = NULL;   /* Just in case */\n        return_path = sender_address;   /* In case not previously set */\n\n        /* Write the original email out */\n        transport_write_message(&tctx, 0);\n        fflush(f);\n\n        fprintf(f,\"\\n--%s--\\n\", bound);\n\n        fflush(f);\n\n        /* Close and wait for child process to complete, without a timeout.\n        If there's an error, don't update the count. */\n\n        (void)fclose(f);\n        if (child_close(pid, 0) == 0)\n          {\n          warning_count = count;\n          update_spool = TRUE;    /* Ensure spool rewritten */\n          }\n        }\n      }\n    }\n\n  /* Clear deliver_domain */\n\n  deliver_domain = NULL;\n\n  /* If this was a first delivery attempt, unset the first time flag, and\n  ensure that the spool gets updated. */\n\n  if (f.deliver_firsttime)\n    {\n    f.deliver_firsttime = FALSE;\n    update_spool = TRUE;\n    }\n\n  /* If delivery was frozen and freeze_tell is set, generate an appropriate\n  message, unless the message is a local error message (to avoid loops). Then\n  log the freezing. If the text in \"frozen_info\" came from a system filter,\n  it has been escaped into printing characters so as not to mess up log lines.\n  For the \"tell\" message, we turn \\n back into newline. Also, insert a newline\n  near the start instead of the \": \" string. */\n\n  if (f.deliver_freeze)\n    {\n    if (freeze_tell && freeze_tell[0] != 0 && !f.local_error_message)\n      {\n      uschar *s = string_copy(frozen_info);\n      uschar *ss = Ustrstr(s, \" by the system filter: \");\n\n      if (ss != NULL)\n        {\n        ss[21] = '.';\n        ss[22] = '\\n';\n        }\n\n      ss = s;\n      while (*ss != 0)\n        {\n        if (*ss == '\\\\' && ss[1] == 'n')\n          {\n          *ss++ = ' ';\n          *ss++ = '\\n';\n          }\n        else ss++;\n        }\n      moan_tell_someone(freeze_tell, addr_defer, US\"Message frozen\",\n        \"Message %s has been frozen%s.\\nThe sender is <%s>.\\n\", message_id,\n        s, sender_address);\n      }\n\n    /* Log freezing just before we update the -H file, to minimize the chance\n    of a race problem. */\n\n    deliver_msglog(\"*** Frozen%s\\n\", frozen_info);\n    log_write(0, LOG_MAIN, \"Frozen%s\", frozen_info);\n    }\n\n  /* If there have been any updates to the non-recipients list, or other things\n  that get written to the spool, we must now update the spool header file so\n  that it has the right information for the next delivery attempt. If there\n  was more than one address being delivered, the header_change update is done\n  earlier, in case one succeeds and then something crashes. */\n\n  DEBUG(D_deliver)\n    debug_printf(\"delivery deferred: update_spool=%d header_rewritten=%d\\n\",\n      update_spool, f.header_rewritten);\n\n  if (update_spool || f.header_rewritten)\n    /* Panic-dies on error */\n    (void)spool_write_header(message_id, SW_DELIVERING, NULL);\n  }\n\n/* Finished with the message log. If the message is complete, it will have\nbeen unlinked or renamed above. */\n\nif (message_logs) (void)fclose(message_log);\n\n/* Now we can close and remove the journal file. Its only purpose is to record\nsuccessfully completed deliveries asap so that this information doesn't get\nlost if Exim (or the machine) crashes. Forgetting about a failed delivery is\nnot serious, as trying it again is not harmful. The journal might not be open\nif all addresses were deferred at routing or directing. Nevertheless, we must\nremove it if it exists (may have been lying around from a crash during the\nprevious delivery attempt). We don't remove the journal if a delivery\nsubprocess failed to pass back delivery information; this is controlled by\nthe remove_journal flag. When the journal is left, we also don't move the\nmessage off the main spool if frozen and the option is set. It should get moved\nat the next attempt, after the journal has been inspected. */\n\nif (journal_fd >= 0) (void)close(journal_fd);\n\nif (remove_journal)\n  {\n  uschar * fname = spool_fname(US\"input\", message_subdir, id, US\"-J\");\n\n  if (Uunlink(fname) < 0 && errno != ENOENT)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to unlink %s: %s\", fname,\n      strerror(errno));\n\n  /* Move the message off the spool if requested */\n\n#ifdef SUPPORT_MOVE_FROZEN_MESSAGES\n  if (f.deliver_freeze && move_frozen_messages)\n    (void)spool_move_message(id, message_subdir, US\"\", US\"F\");\n#endif\n  }\n\n/* Closing the data file frees the lock; if the file has been unlinked it\nwill go away. Otherwise the message becomes available for another process\nto try delivery. */\n\n(void)close(deliver_datafile);\ndeliver_datafile = -1;\nDEBUG(D_deliver) debug_printf(\"end delivery of %s\\n\", id);\n\n/* It is unlikely that there will be any cached resources, since they are\nreleased after routing, and in the delivery subprocesses. However, it's\npossible for an expansion for something afterwards (for example,\nexpand_check_condition) to do a lookup. We must therefore be sure everything is\nreleased. */\n\nsearch_tidyup();\nacl_where = ACL_WHERE_UNKNOWN;\nreturn final_yield;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147361,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "ssh_scp ssh_scp_new(ssh_session session, int mode, const char *location)\n{\n    ssh_scp scp = NULL;\n\n    if (session == NULL) {\n        goto error;\n    }\n\n    scp = (ssh_scp)calloc(1, sizeof(struct ssh_scp_struct));\n    if (scp == NULL) {\n        ssh_set_error(session, SSH_FATAL,\n                      \"Error allocating memory for ssh_scp\");\n        goto error;\n    }\n\n    if ((mode & ~SSH_SCP_RECURSIVE) != SSH_SCP_WRITE &&\n        (mode & ~SSH_SCP_RECURSIVE) != SSH_SCP_READ)\n    {\n        ssh_set_error(session, SSH_FATAL,\n                      \"Invalid mode %d for ssh_scp_new()\", mode);\n        goto error;\n    }\n\n    scp->location = strdup(location);\n    if (scp->location == NULL) {\n        ssh_set_error(session, SSH_FATAL,\n                      \"Error allocating memory for ssh_scp\");\n        goto error;\n    }\n\n    scp->session = session;\n    scp->mode = mode & ~SSH_SCP_RECURSIVE;\n    scp->recursive = (mode & SSH_SCP_RECURSIVE) != 0;\n    scp->channel = NULL;\n    scp->state = SSH_SCP_NEW;\n\n    return scp;\n\nerror:\n    ssh_scp_free(scp);\n    return NULL;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147758,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "ssh_scp ssh_scp_new(ssh_session session, int mode, const char *location)\n{\n    ssh_scp scp = NULL;\n\n    if (session == NULL) {\n        goto error;\n    }\n\n    scp = (ssh_scp)calloc(1, sizeof(struct ssh_scp_struct));\n    if (scp == NULL) {\n        ssh_set_error(session, SSH_FATAL,\n                      \"Error allocating memory for ssh_scp\");\n        goto error;\n    }\n\n    if ((mode & ~SSH_SCP_RECURSIVE) != SSH_SCP_WRITE &&\n        (mode & ~SSH_SCP_RECURSIVE) != SSH_SCP_READ)\n    {\n        ssh_set_error(session, SSH_FATAL,\n                      \"Invalid mode %d for ssh_scp_new()\", mode);\n        goto error;\n    }\n\n    if (strlen(location) > 32 * 1024) {\n        ssh_set_error(session, SSH_FATAL,\n                      \"Location path is too long\");\n        goto error;\n    }\n\n    scp->location = strdup(location);\n    if (scp->location == NULL) {\n        ssh_set_error(session, SSH_FATAL,\n                      \"Error allocating memory for ssh_scp\");\n        goto error;\n    }\n\n    scp->session = session;\n    scp->mode = mode & ~SSH_SCP_RECURSIVE;\n    scp->recursive = (mode & SSH_SCP_RECURSIVE) != 0;\n    scp->channel = NULL;\n    scp->state = SSH_SCP_NEW;\n\n    return scp;\n\nerror:\n    ssh_scp_free(scp);\n    return NULL;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147759,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "int ssh_scp_init(ssh_scp scp)\n{\n    int rc;\n    char execbuffer[1024] = {0};\n\n    if (scp == NULL) {\n        return SSH_ERROR;\n    }\n\n    if (scp->state != SSH_SCP_NEW) {\n        ssh_set_error(scp->session, SSH_FATAL,\n                      \"ssh_scp_init called under invalid state\");\n        return SSH_ERROR;\n    }\n\n    SSH_LOG(SSH_LOG_PROTOCOL,\n            \"Initializing scp session %s %son location '%s'\",\n            scp->mode == SSH_SCP_WRITE?\"write\":\"read\",\n            scp->recursive?\"recursive \":\"\",\n            scp->location);\n\n    scp->channel = ssh_channel_new(scp->session);\n    if (scp->channel == NULL) {\n        scp->state = SSH_SCP_ERROR;\n        return SSH_ERROR;\n    }\n\n    rc = ssh_channel_open_session(scp->channel);\n    if (rc == SSH_ERROR) {\n        scp->state = SSH_SCP_ERROR;\n        return SSH_ERROR;\n    }\n\n    if (scp->mode == SSH_SCP_WRITE) {\n        snprintf(execbuffer, sizeof(execbuffer), \"scp -t %s %s\",\n                scp->recursive ? \"-r\":\"\", scp->location);\n    } else {\n        snprintf(execbuffer, sizeof(execbuffer), \"scp -f %s %s\",\n                scp->recursive ? \"-r\":\"\", scp->location);\n    }\n\n    if (ssh_channel_request_exec(scp->channel, execbuffer) == SSH_ERROR) {\n        scp->state = SSH_SCP_ERROR;\n        return SSH_ERROR;\n    }\n\n    if (scp->mode == SSH_SCP_WRITE) {\n        rc = ssh_scp_response(scp, NULL);\n        if (rc != 0) {\n            return SSH_ERROR;\n        }\n    } else {\n        ssh_channel_write(scp->channel, \"\", 1);\n    }\n\n    if (scp->mode == SSH_SCP_WRITE) {\n        scp->state = SSH_SCP_WRITE_INITED;\n    } else {\n        scp->state = SSH_SCP_READ_INITED;\n    }\n\n    return SSH_OK;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147760,
    "human": "Correct. With CWE-78",
    "reason": "Vulnerable to CWE-78 due to unsafe embedding of user-controlled scp->location into the shell command.",
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "int ssh_scp_init(ssh_scp scp)\n{\n    int rc;\n    char execbuffer[1024] = {0};\n    char *quoted_location = NULL;\n    size_t quoted_location_len = 0;\n    size_t scp_location_len;\n\n    if (scp == NULL) {\n        return SSH_ERROR;\n    }\n\n    if (scp->state != SSH_SCP_NEW) {\n        ssh_set_error(scp->session, SSH_FATAL,\n                      \"ssh_scp_init called under invalid state\");\n        return SSH_ERROR;\n    }\n\n    if (scp->location == NULL) {\n        ssh_set_error(scp->session, SSH_FATAL,\n                      \"Invalid scp context: location is NULL\");\n        return SSH_ERROR;\n    }\n\n    SSH_LOG(SSH_LOG_PROTOCOL, \"Initializing scp session %s %son location '%s'\",\n            scp->mode == SSH_SCP_WRITE?\"write\":\"read\",\n            scp->recursive ? \"recursive \" : \"\",\n            scp->location);\n\n    scp->channel = ssh_channel_new(scp->session);\n    if (scp->channel == NULL) {\n        ssh_set_error(scp->session, SSH_FATAL,\n                      \"Channel creation failed for scp\");\n        scp->state = SSH_SCP_ERROR;\n        return SSH_ERROR;\n    }\n\n    rc = ssh_channel_open_session(scp->channel);\n    if (rc == SSH_ERROR) {\n        ssh_set_error(scp->session, SSH_FATAL,\n                      \"Failed to open channel for scp\");\n        scp->state = SSH_SCP_ERROR;\n        return SSH_ERROR;\n    }\n\n    /* In the worst case, each character would be replaced by 3 plus the string\n     * terminator '\\0' */\n    scp_location_len = strlen(scp->location);\n    quoted_location_len = ((size_t)3 * scp_location_len) + 1;\n    /* Paranoia check */\n    if (quoted_location_len < scp_location_len) {\n        ssh_set_error(scp->session, SSH_FATAL,\n                      \"Buffer overflow detected\");\n        scp->state = SSH_SCP_ERROR;\n        return SSH_ERROR;\n    }\n\n    quoted_location = (char *)calloc(1, quoted_location_len);\n    if (quoted_location == NULL) {\n        ssh_set_error(scp->session, SSH_FATAL,\n                      \"Failed to allocate memory for quoted location\");\n        scp->state = SSH_SCP_ERROR;\n        return SSH_ERROR;\n    }\n\n    rc = ssh_quote_file_name(scp->location, quoted_location,\n                             quoted_location_len);\n    if (rc <= 0) {\n        ssh_set_error(scp->session, SSH_FATAL,\n                      \"Failed to single quote command location\");\n        SAFE_FREE(quoted_location);\n        scp->state = SSH_SCP_ERROR;\n        return SSH_ERROR;\n    }\n\n    if (scp->mode == SSH_SCP_WRITE) {\n        snprintf(execbuffer, sizeof(execbuffer), \"scp -t %s %s\",\n                scp->recursive ? \"-r\" : \"\", quoted_location);\n    } else {\n        snprintf(execbuffer, sizeof(execbuffer), \"scp -f %s %s\",\n                scp->recursive ? \"-r\" : \"\", quoted_location);\n    }\n\n    SAFE_FREE(quoted_location);\n\n    SSH_LOG(SSH_LOG_DEBUG, \"Executing command: %s\", execbuffer);\n\n    rc = ssh_channel_request_exec(scp->channel, execbuffer);\n    if (rc == SSH_ERROR){\n        ssh_set_error(scp->session, SSH_FATAL,\n                      \"Failed executing command: %s\", execbuffer);\n        scp->state = SSH_SCP_ERROR;\n        return SSH_ERROR;\n    }\n\n    if (scp->mode == SSH_SCP_WRITE) {\n        rc = ssh_scp_response(scp, NULL);\n        if (rc != 0) {\n            return SSH_ERROR;\n        }\n    } else {\n        ssh_channel_write(scp->channel, \"\", 1);\n    }\n\n    if (scp->mode == SSH_SCP_WRITE) {\n        scp->state = SSH_SCP_WRITE_INITED;\n    } else {\n        scp->state = SSH_SCP_READ_INITED;\n    }\n\n    return SSH_OK;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147761,
    "human": "Correct. Without CWE-78",
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "static int download(struct SPDBDownloader *pd) {\n\tSPDBDownloaderOpt *opt = pd->opt;\n\tchar *curl_cmd = NULL;\n\tchar *extractor_cmd = NULL;\n\tchar *abspath_to_archive = NULL;\n\tchar *abspath_to_file = NULL;\n\tchar *archive_name = NULL;\n\tsize_t archive_name_len = 0;\n\tchar *symbol_store_path = NULL;\n\tchar *dbg_file = NULL;\n\tchar *guid = NULL;\n\tchar *archive_name_escaped  = NULL;\n\tchar *user_agent = NULL;\n\tchar *symbol_server = NULL;\n\n\tint res = 0;\n\tint cmd_ret;\n\tif (!opt->dbg_file || !*opt->dbg_file) {\n\t\t// no pdb debug file\n\t\treturn 0;\n\t}\n\tif (!checkCurl ()) {\n\t\treturn 0;\n\t}\n\t// dbg_file len is > 0\n\tarchive_name_len = strlen (opt->dbg_file);\n\tarchive_name = malloc (archive_name_len + 1);\n\tif (!archive_name) {\n\t\treturn 0;\n\t}\n\tmemcpy (archive_name, opt->dbg_file, archive_name_len + 1);\n\tarchive_name[archive_name_len - 1] = '_';\n\tsymbol_store_path = r_str_escape (opt->symbol_store_path);\n\tdbg_file = r_str_escape (opt->dbg_file);\n\tguid = r_str_escape (opt->guid);\n\tarchive_name_escaped = r_str_escape (archive_name);\n\tuser_agent = r_str_escape (opt->user_agent);\n\tsymbol_server = r_str_escape (opt->symbol_server);\n\n\tabspath_to_archive = r_str_newf (\"%s%s%s%s%s%s%s\",\n\t\t\t    symbol_store_path, R_SYS_DIR,\n\t\t\t    dbg_file, R_SYS_DIR,\n\t\t\t    guid, R_SYS_DIR,\n\t\t\t    archive_name_escaped);\n\n\tabspath_to_file = strdup (abspath_to_archive);\n\tabspath_to_file[strlen (abspath_to_file) - 1] = 'b';\n\tif (r_file_exists (abspath_to_file)) {\n\t\teprintf (\"File already downloaded.\\n\");\n\t\tR_FREE (user_agent);\n\t\tR_FREE (abspath_to_archive);\n\t\tR_FREE (archive_name_escaped);\n\t\tR_FREE (symbol_store_path);\n\t\tR_FREE (dbg_file);\n\t\tR_FREE (guid);\n\t\tR_FREE (archive_name);\n\t\tR_FREE (abspath_to_file);\n\t\tR_FREE (symbol_server);\n\t\treturn 1;\n\t}\n\n\tif (checkExtract () || opt->extract == 0) {\n\t\tres = 1;\n\n\t\tcurl_cmd = r_str_newf (\"curl -sfLA \\\"%s\\\" \\\"%s/%s/%s/%s\\\" --create-dirs -o \\\"%s\\\"\",\n\t\t                       user_agent,\n\t\t                       symbol_server,\n\t\t\t\t\t\t\t   dbg_file,\n\t\t\t\t\t\t\t   guid,\n\t\t                       archive_name_escaped,\n\t\t                       abspath_to_archive);\n#if __WINDOWS__\n\t\tconst char *cabextractor = \"expand\";\n\t\tconst char *format = \"%s %s %s\";\n\n\t\t// extractor_cmd -> %1 %2 %3\n\t\t// %1 - 'expand'\n\t\t// %2 - absolute path to archive\n\t\t// %3 - absolute path to file that will be dearchive\n\t\textractor_cmd = r_str_newf (format, cabextractor,\n\t\t\tabspath_to_archive, abspath_to_file);\n#else\n\t\tconst char *cabextractor = \"cabextract\";\n\t\tconst char *format = \"%s -d \\\"%s\\\" \\\"%s\\\"\";\n\t\tchar *abspath_to_dir = r_file_dirname (abspath_to_archive);\n\t\t// cabextract -d %1 %2\n\t\t// %1 - path to directory where to extract all files from cab archive\n\t\t// %2 - absolute path to cab archive\n\t\textractor_cmd = r_str_newf (format, cabextractor, abspath_to_dir, abspath_to_archive);\n\t\tR_FREE (abspath_to_dir);\n#endif\n\t\teprintf (\"Attempting to download compressed pdb in %s\\n\", abspath_to_archive);\n\t\tif ((cmd_ret = r_sys_cmd (curl_cmd) != 0)) {\n\t\t\teprintf(\"curl exited with error %d\\n\", cmd_ret);\n\t\t\tres = 0;\n\t\t}\n\t\teprintf (\"Attempting to decompress pdb\\n\");\n\t\tif (opt->extract > 0) {\n\t\t\tif (res && ((cmd_ret = r_sys_cmd (extractor_cmd)) != 0)) {\n\t\t\t\teprintf (\"cab extractor exited with error %d\\n\", cmd_ret);\n\t\t\t\tres = 0;\n\t\t\t}\n\t\t\tr_file_rm (abspath_to_archive);\n\t\t}\n\t\tR_FREE (curl_cmd);\n\t}\n\tif (res == 0) {\n\t\teprintf (\"Falling back to uncompressed pdb\\n\");\n\t\tres = 1;\n\n\t\tarchive_name_escaped[strlen (archive_name_escaped) - 1] = 'b';\n\n\t\tcurl_cmd = r_str_newf (\"curl -sfLA \\\"%s\\\" \\\"%s/%s/%s/%s\\\" --create-dirs -o \\\"%s\\\"\",\n\t\t                       opt->user_agent,\n\t\t                       opt->symbol_server,\n\t\t                       opt->dbg_file,\n\t\t                       opt->guid,\n\t\t                       archive_name_escaped,\n\t\t                       abspath_to_file);\n\t\teprintf (\"Attempting to download uncompressed pdb in %s\\n\", abspath_to_file);\n\t\tif ((cmd_ret = r_sys_cmd (curl_cmd) != 0)) {\n\t\t\teprintf(\"curl exited with error %d\\n\", cmd_ret);\n\t\t\tres = 0;\n\t\t}\n\t\tR_FREE (curl_cmd);\n\t}\n\tR_FREE (abspath_to_archive);\n\tR_FREE (abspath_to_file);\n\tR_FREE (archive_name);\n\tR_FREE (extractor_cmd);\n\tR_FREE (symbol_store_path);\n\tR_FREE (dbg_file);\n\tR_FREE (guid);\n\tR_FREE (archive_name_escaped);\n\tR_FREE (user_agent);\n\tR_FREE (symbol_server);\n\treturn res;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148106,
    "human": "Correct. With CWE-78",
    "reason": "It constructs shell commands with unescaped inputs (e.g., guid, dbg_file).",
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "static int download(struct SPDBDownloader *pd) {\n\tSPDBDownloaderOpt *opt = pd->opt;\n\tint res = 0;\n\tint cmd_ret;\n\n\tif (!opt->dbg_file || !*opt->dbg_file) {\n\t\t// no pdb debug file\n\t\treturn 0;\n\t}\n\n\tchar *abspath_to_file = r_str_newf (\"%s%s%s%s%s%s%s\",\n\t\topt->symbol_store_path, R_SYS_DIR,\n\t\topt->dbg_file, R_SYS_DIR,\n\t\topt->guid, R_SYS_DIR,\n\t\topt->dbg_file);\n\n\tif (r_file_exists (abspath_to_file)) {\n\t\teprintf (\"File already downloaded.\\n\");\n\t\tfree (abspath_to_file);\n\t\treturn 1;\n\t}\n\n\tif (checkExtract () || opt->extract == 0) {\n\t\tchar *extractor_cmd = NULL;\n\t\tchar *archive_name = strdup (opt->dbg_file);\n\t\tarchive_name[strlen (archive_name) - 1] = '_';\n\t\tchar *abspath_to_archive = r_str_newf (\"%s%s%s%s%s%s%s\",\n\t\t\topt->symbol_store_path, R_SYS_DIR,\n\t\t\topt->dbg_file, R_SYS_DIR,\n\t\t\topt->guid, R_SYS_DIR,\n\t\t\tarchive_name);\n\n\t\teprintf (\"Attempting to download compressed pdb in %s\\n\", abspath_to_archive);\n\t\tchar *abs_arch_esc = r_str_escape_sh (abspath_to_archive);\n#if __WINDOWS__\n\t\tchar *abs_file_esc = r_str_escape_sh (abspath_to_file);\n\t\t// expand %1 %2\n\t\t// %1 - absolute path to archive\n\t\t// %2 - absolute path to file that will be dearchive\n\t\textractor_cmd = r_str_newf (\"expand \\\"%s\\\" \\\"%s\\\"\", abs_arch_esc, abs_file_esc);\n\t\tfree (abs_file_esc);\n#else\n\t\tchar *abspath_to_dir = r_file_dirname (abspath_to_archive);\n\t\tchar *abs_dir_esc = r_str_escape_sh (abspath_to_dir);\n\t\t// cabextract -d %1 %2\n\t\t// %1 - path to directory where to extract all files from cab archive\n\t\t// %2 - absolute path to cab archive\n\t\textractor_cmd = r_str_newf (\"cabextract -d \\\"%s\\\" \\\"%s\\\"\", abs_arch_esc, abs_dir_esc);\n\t\tfree (abs_dir_esc);\n\t\tfree (abspath_to_dir);\n#endif\n\t\tfree (abs_arch_esc);\n\t\tres = download_and_write (opt, archive_name);\n\n\t\tif (opt->extract > 0 && res) {\n\t\t\teprintf (\"Attempting to decompress pdb\\n\");\n\t\t\tif (res && ((cmd_ret = r_sys_cmd (extractor_cmd)) != 0)) {\n\t\t\t\teprintf (\"cab extractor exited with error %d\\n\", cmd_ret);\n\t\t\t\tres = 0;\n\t\t\t}\n\t\t\tr_file_rm (abspath_to_archive);\n\t\t}\n\t\tfree (archive_name);\n\t\tfree (abspath_to_archive);\n\t}\n\tif (res == 0) {\n\t\teprintf (\"Falling back to uncompressed pdb\\n\");\n\t\teprintf (\"Attempting to download uncompressed pdb in %s\\n\", abspath_to_file);\n\t\tres = download_and_write (opt, opt->dbg_file);\n\t}\n\tfree (abspath_to_file);\n\treturn res;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148107,
    "human": "Correct. Without CWE-78",
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "do_ed_script (char const *inname, char const *outname,\n\t      bool *outname_needs_removal, FILE *ofp)\n{\n    static char const editor_program[] = EDITOR_PROGRAM;\n\n    file_offset beginning_of_this_line;\n    size_t chars_read;\n    FILE *tmpfp = 0;\n    char const *tmpname;\n    int tmpfd;\n    pid_t pid;\n\n    if (! dry_run && ! skip_rest_of_patch)\n      {\n\t/* Write ed script to a temporary file.  This causes ed to abort on\n\t   invalid commands such as when line numbers or ranges exceed the\n\t   number of available lines.  When ed reads from a pipe, it rejects\n\t   invalid commands and treats the next line as a new command, which\n\t   can lead to arbitrary command execution.  */\n\n\ttmpfd = make_tempfile (&tmpname, 'e', NULL, O_RDWR | O_BINARY, 0);\n\tif (tmpfd == -1)\n\t  pfatal (\"Can't create temporary file %s\", quotearg (tmpname));\n\ttmpfp = fdopen (tmpfd, \"w+b\");\n\tif (! tmpfp)\n\t  pfatal (\"Can't open stream for file %s\", quotearg (tmpname));\n      }\n\n    for (;;) {\n\tchar ed_command_letter;\n\tbeginning_of_this_line = file_tell (pfp);\n\tchars_read = get_line ();\n\tif (! chars_read) {\n\t    next_intuit_at(beginning_of_this_line,p_input_line);\n\t    break;\n\t}\n\ted_command_letter = get_ed_command_letter (buf);\n\tif (ed_command_letter) {\n\t    if (tmpfp)\n\t\tif (! fwrite (buf, sizeof *buf, chars_read, tmpfp))\n\t\t    write_fatal ();\n\t    if (ed_command_letter != 'd' && ed_command_letter != 's') {\n\t        p_pass_comments_through = true;\n\t\twhile ((chars_read = get_line ()) != 0) {\n\t\t    if (tmpfp)\n\t\t\tif (! fwrite (buf, sizeof *buf, chars_read, tmpfp))\n\t\t\t    write_fatal ();\n\t\t    if (chars_read == 2  &&  strEQ (buf, \".\\n\"))\n\t\t\tbreak;\n\t\t}\n\t\tp_pass_comments_through = false;\n\t    }\n\t}\n\telse {\n\t    next_intuit_at(beginning_of_this_line,p_input_line);\n\t    break;\n\t}\n    }\n    if (!tmpfp)\n      return;\n    if (fwrite (\"w\\nq\\n\", sizeof (char), (size_t) 4, tmpfp) == 0\n\t|| fflush (tmpfp) != 0)\n      write_fatal ();\n\n    if (lseek (tmpfd, 0, SEEK_SET) == -1)\n      pfatal (\"Can't rewind to the beginning of file %s\", quotearg (tmpname));\n\n    if (! dry_run && ! skip_rest_of_patch) {\n\tint exclusive = *outname_needs_removal ? 0 : O_EXCL;\n\t*outname_needs_removal = true;\n\tif (inerrno != ENOENT)\n\t  {\n\t    *outname_needs_removal = true;\n\t    copy_file (inname, outname, 0, exclusive, instat.st_mode, true);\n\t  }\n\tsprintf (buf, \"%s %s%s\", editor_program,\n\t\t verbosity == VERBOSE ? \"\" : \"- \",\n\t\t outname);\n\tfflush (stdout);\n\n\tpid = fork();\n\tif (pid == -1)\n\t  pfatal (\"Can't fork\");\n\telse if (pid == 0)\n\t  {\n\t    dup2 (tmpfd, 0);\n\t    execl (\"/bin/sh\", \"sh\", \"-c\", buf, (char *) 0);\n\t    _exit (2);\n\t  }\n\telse\n\t  {\n\t    int wstatus;\n\t    if (waitpid (pid, &wstatus, 0) == -1\n\t        || ! WIFEXITED (wstatus)\n\t\t|| WEXITSTATUS (wstatus) != 0)\n\t      fatal (\"%s FAILED\", editor_program);\n\t  }\n    }\n\n    fclose (tmpfp);\n    safe_unlink (tmpname);\n\n    if (ofp)\n      {\n\tFILE *ifp = fopen (outname, binary_transput ? \"rb\" : \"r\");\n\tint c;\n\tif (!ifp)\n\t  pfatal (\"can't open '%s'\", outname);\n\twhile ((c = getc (ifp)) != EOF)\n\t  if (putc (c, ofp) == EOF)\n\t    write_fatal ();\n\tif (ferror (ifp) || fclose (ifp) != 0)\n\t  read_fatal ();\n      }\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148740,
    "human": "Correct. With CWE-78",
    "reason": "Vulnerable to CWE-78 due to unsafe shell command construction with untrusted outname.",
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "do_ed_script (char const *inname, char const *outname,\n\t      bool *outname_needs_removal, FILE *ofp)\n{\n    static char const editor_program[] = EDITOR_PROGRAM;\n\n    file_offset beginning_of_this_line;\n    size_t chars_read;\n    FILE *tmpfp = 0;\n    char const *tmpname;\n    int tmpfd;\n    pid_t pid;\n\n    if (! dry_run && ! skip_rest_of_patch)\n      {\n\t/* Write ed script to a temporary file.  This causes ed to abort on\n\t   invalid commands such as when line numbers or ranges exceed the\n\t   number of available lines.  When ed reads from a pipe, it rejects\n\t   invalid commands and treats the next line as a new command, which\n\t   can lead to arbitrary command execution.  */\n\n\ttmpfd = make_tempfile (&tmpname, 'e', NULL, O_RDWR | O_BINARY, 0);\n\tif (tmpfd == -1)\n\t  pfatal (\"Can't create temporary file %s\", quotearg (tmpname));\n\ttmpfp = fdopen (tmpfd, \"w+b\");\n\tif (! tmpfp)\n\t  pfatal (\"Can't open stream for file %s\", quotearg (tmpname));\n      }\n\n    for (;;) {\n\tchar ed_command_letter;\n\tbeginning_of_this_line = file_tell (pfp);\n\tchars_read = get_line ();\n\tif (! chars_read) {\n\t    next_intuit_at(beginning_of_this_line,p_input_line);\n\t    break;\n\t}\n\ted_command_letter = get_ed_command_letter (buf);\n\tif (ed_command_letter) {\n\t    if (tmpfp)\n\t\tif (! fwrite (buf, sizeof *buf, chars_read, tmpfp))\n\t\t    write_fatal ();\n\t    if (ed_command_letter != 'd' && ed_command_letter != 's') {\n\t        p_pass_comments_through = true;\n\t\twhile ((chars_read = get_line ()) != 0) {\n\t\t    if (tmpfp)\n\t\t\tif (! fwrite (buf, sizeof *buf, chars_read, tmpfp))\n\t\t\t    write_fatal ();\n\t\t    if (chars_read == 2  &&  strEQ (buf, \".\\n\"))\n\t\t\tbreak;\n\t\t}\n\t\tp_pass_comments_through = false;\n\t    }\n\t}\n\telse {\n\t    next_intuit_at(beginning_of_this_line,p_input_line);\n\t    break;\n\t}\n    }\n    if (!tmpfp)\n      return;\n    if (fwrite (\"w\\nq\\n\", sizeof (char), (size_t) 4, tmpfp) == 0\n\t|| fflush (tmpfp) != 0)\n      write_fatal ();\n\n    if (lseek (tmpfd, 0, SEEK_SET) == -1)\n      pfatal (\"Can't rewind to the beginning of file %s\", quotearg (tmpname));\n\n    if (! dry_run && ! skip_rest_of_patch) {\n\tint exclusive = *outname_needs_removal ? 0 : O_EXCL;\n\t*outname_needs_removal = true;\n\tif (inerrno != ENOENT)\n\t  {\n\t    *outname_needs_removal = true;\n\t    copy_file (inname, outname, 0, exclusive, instat.st_mode, true);\n\t  }\n\tfflush (stdout);\n\n\tpid = fork();\n\tif (pid == -1)\n\t  pfatal (\"Can't fork\");\n\telse if (pid == 0)\n\t  {\n\t    dup2 (tmpfd, 0);\n\t    assert (outname[0] != '!' && outname[0] != '-');\n\t    execlp (editor_program, editor_program, \"-\", outname, (char  *) NULL);\n\t    _exit (2);\n\t  }\n\telse\n\t  {\n\t    int wstatus;\n\t    if (waitpid (pid, &wstatus, 0) == -1\n\t        || ! WIFEXITED (wstatus)\n\t\t|| WEXITSTATUS (wstatus) != 0)\n\t      fatal (\"%s FAILED\", editor_program);\n\t  }\n    }\n\n    fclose (tmpfp);\n    safe_unlink (tmpname);\n\n    if (ofp)\n      {\n\tFILE *ifp = fopen (outname, binary_transput ? \"rb\" : \"r\");\n\tint c;\n\tif (!ifp)\n\t  pfatal (\"can't open '%s'\", outname);\n\twhile ((c = getc (ifp)) != EOF)\n\t  if (putc (c, ofp) == EOF)\n\t    write_fatal ();\n\tif (ferror (ifp) || fclose (ifp) != 0)\n\t  read_fatal ();\n      }\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148741,
    "human": "Correct. Without CWE-78",
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "static int bin_symbols(RCore *r, int mode, ut64 laddr, int va, ut64 at, const char *name, bool exponly, const char *args) {\n\tRBinInfo *info = r_bin_get_info (r->bin);\n\tRList *entries = r_bin_get_entries (r->bin);\n\tRBinSymbol *symbol;\n\tRBinAddr *entry;\n\tRListIter *iter;\n\tbool firstexp = true;\n\tbool printHere = false;\n\tint i = 0, lastfs = 's';\n\tbool bin_demangle = r_config_get_i (r->config, \"bin.demangle\");\n\tif (!info) {\n\t\treturn 0;\n\t}\n\n\tif (args && *args == '.') {\n\t\tprintHere = true;\n\t}\n\n\tbool is_arm = info && info->arch && !strncmp (info->arch, \"arm\", 3);\n\tconst char *lang = bin_demangle ? r_config_get (r->config, \"bin.lang\") : NULL;\n\n\tRList *symbols = r_bin_get_symbols (r->bin);\n\tr_spaces_push (&r->anal->meta_spaces, \"bin\");\n\n\tif (IS_MODE_JSON (mode) && !printHere) {\n\t\tr_cons_printf (\"[\");\n\t} else if (IS_MODE_SET (mode)) {\n\t\tr_flag_space_set (r->flags, R_FLAGS_FS_SYMBOLS);\n\t} else if (!at && exponly) {\n\t\tif (IS_MODE_RAD (mode)) {\n\t\t\tr_cons_printf (\"fs exports\\n\");\n\t\t} else if (IS_MODE_NORMAL (mode)) {\n\t\t\tr_cons_printf (printHere ? \"\" : \"[Exports]\\n\");\n\t\t}\n\t} else if (!at && !exponly) {\n\t\tif (IS_MODE_RAD (mode)) {\n\t\t\tr_cons_printf (\"fs symbols\\n\");\n\t\t} else if (IS_MODE_NORMAL (mode)) {\n\t\t\tr_cons_printf (printHere ? \"\" : \"[Symbols]\\n\");\n\t\t}\n\t}\n\tif (IS_MODE_NORMAL (mode)) {\n\t\tr_cons_printf (\"Num Paddr      Vaddr      Bind     Type Size Name\\n\");\n\t}\n\n\n\tsize_t count = 0;\n\tr_list_foreach (symbols, iter, symbol) {\n\t\tif (!symbol->name) {\n\t\t\tcontinue;\n\t\t}\n\t\tchar *r_symbol_name = r_str_escape_utf8 (symbol->name, false, true);\n\t\tut64 addr = compute_addr (r->bin, symbol->paddr, symbol->vaddr, va);\n\t\tint len = symbol->size ? symbol->size : 32;\n\t\tSymName sn = {0};\n\n\t\tif (exponly && !isAnExport (symbol)) {\n\t\t\tfree (r_symbol_name);\n\t\t\tcontinue;\n\t\t}\n\t\tif (name && strcmp (r_symbol_name, name)) {\n\t\t\tfree (r_symbol_name);\n\t\t\tcontinue;\n\t\t}\n\t\tif (at && (!symbol->size || !is_in_range (at, addr, symbol->size))) {\n\t\t\tfree (r_symbol_name);\n\t\t\tcontinue;\n\t\t}\n\t\tif ((printHere && !is_in_range (r->offset, symbol->paddr, len))\n\t\t\t\t&& (printHere && !is_in_range (r->offset, addr, len))) {\n\t\t\tfree (r_symbol_name);\n\t\t\tcontinue;\n\t\t}\n\t\tcount ++;\n\t\tsnInit (r, &sn, symbol, lang);\n\n\t\tif (IS_MODE_SET (mode) && (is_section_symbol (symbol) || is_file_symbol (symbol))) {\n\t\t\t/*\n\t\t\t * Skip section symbols because they will have their own flag.\n\t\t\t * Skip also file symbols because not useful for now.\n\t\t\t */\n\t\t} else if (IS_MODE_SET (mode) && is_special_symbol (symbol)) {\n\t\t\tif (is_arm) {\n\t\t\t\thandle_arm_special_symbol (r, symbol, va);\n\t\t\t}\n\t\t} else if (IS_MODE_SET (mode)) {\n\t\t\t// TODO: provide separate API in RBinPlugin to let plugins handle anal hints/metadata\n\t\t\tif (is_arm) {\n\t\t\t\thandle_arm_symbol (r, symbol, info, va);\n\t\t\t}\n\t\t\tselect_flag_space (r, symbol);\n\t\t\t/* If that's a Classed symbol (method or so) */\n\t\t\tif (sn.classname) {\n\t\t\t\tRFlagItem *fi = r_flag_get (r->flags, sn.methflag);\n\t\t\t\tif (r->bin->prefix) {\n\t\t\t\t\tchar *prname = r_str_newf (\"%s.%s\", r->bin->prefix, sn.methflag);\n\t\t\t\t\tr_name_filter (sn.methflag, -1);\n\t\t\t\t\tfree (sn.methflag);\n\t\t\t\t\tsn.methflag = prname;\n\t\t\t\t}\n\t\t\t\tif (fi) {\n\t\t\t\t\tr_flag_item_set_realname (fi, sn.methname);\n\t\t\t\t\tif ((fi->offset - r->flags->base) == addr) {\n\t\t\t\t//\t\tchar *comment = fi->comment ? strdup (fi->comment) : NULL;\n\t\t\t\t\t\tr_flag_unset (r->flags, fi);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfi = r_flag_set (r->flags, sn.methflag, addr, symbol->size);\n\t\t\t\t\tchar *comment = fi->comment ? strdup (fi->comment) : NULL;\n\t\t\t\t\tif (comment) {\n\t\t\t\t\t\tr_flag_item_set_comment (fi, comment);\n\t\t\t\t\t\tR_FREE (comment);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst char *n = sn.demname ? sn.demname : sn.name;\n\t\t\t\tconst char *fn = sn.demflag ? sn.demflag : sn.nameflag;\n\t\t\t\tchar *fnp = (r->bin->prefix) ?\n\t\t\t\t\tr_str_newf (\"%s.%s\", r->bin->prefix, fn):\n\t\t\t\t\tstrdup (fn);\n\t\t\t\tRFlagItem *fi = r_flag_set (r->flags, fnp, addr, symbol->size);\n\t\t\t\tif (fi) {\n\t\t\t\t\tr_flag_item_set_realname (fi, n);\n\t\t\t\t\tfi->demangled = (bool)(size_t)sn.demname;\n\t\t\t\t} else {\n\t\t\t\t\tif (fn) {\n\t\t\t\t\t\teprintf (\"[Warning] Can't find flag (%s)\\n\", fn);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree (fnp);\n\t\t\t}\n\t\t\tif (sn.demname) {\n\t\t\t\tr_meta_add (r->anal, R_META_TYPE_COMMENT,\n\t\t\t\t\taddr, symbol->size, sn.demname);\n\t\t\t}\n\t\t\tr_flag_space_pop (r->flags);\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tchar *str = r_str_escape_utf8_for_json (r_symbol_name, -1);\n\t\t\t// str = r_str_replace (str, \"\\\"\", \"\\\\\\\"\", 1);\n\t\t\tr_cons_printf (\"%s{\\\"name\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"demname\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"flagname\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"ordinal\\\":%d,\"\n\t\t\t\t\"\\\"bind\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"size\\\":%d,\"\n\t\t\t\t\"\\\"type\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"vaddr\\\":%\"PFMT64d\",\"\n\t\t\t\t\"\\\"paddr\\\":%\"PFMT64d\"}\",\n\t\t\t\t((exponly && firstexp) || printHere) ? \"\" : (iter->p ? \",\" : \"\"),\n\t\t\t\tstr,\n\t\t\t\tsn.demname? sn.demname: \"\",\n\t\t\t\tsn.nameflag,\n\t\t\t\tsymbol->ordinal,\n\t\t\t\tsymbol->bind,\n\t\t\t\t(int)symbol->size,\n\t\t\t\tsymbol->type,\n\t\t\t\t(ut64)addr, (ut64)symbol->paddr);\n\t\t\tfree (str);\n\t\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\t\tconst char *name = sn.demname? sn.demname: r_symbol_name;\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\" %d %s\\n\",\n\t\t\t\taddr, (int)symbol->size, name);\n\t\t} else if (IS_MODE_SIMPLEST (mode)) {\n\t\t\tconst char *name = sn.demname? sn.demname: r_symbol_name;\n\t\t\tr_cons_printf (\"%s\\n\", name);\n\t\t} else if (IS_MODE_RAD (mode)) {\n\t\t\t/* Skip special symbols because we do not flag them and\n\t\t\t * they shouldn't be printed in the rad format either */\n\t\t\tif (is_special_symbol (symbol)) {\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tRBinFile *binfile;\n\t\t\tRBinPlugin *plugin;\n\t\t\tconst char *name = sn.demname? sn.demname: r_symbol_name;\n\t\t\tif (!name) {\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tif (!strncmp (name, \"imp.\", 4)) {\n\t\t\t\tif (lastfs != 'i') {\n\t\t\t\t\tr_cons_printf (\"fs imports\\n\");\n\t\t\t\t}\n\t\t\t\tlastfs = 'i';\n\t\t\t} else {\n\t\t\t\tif (lastfs != 's') {\n\t\t\t\t\tconst char *fs = exponly? \"exports\": \"symbols\";\n\t\t\t\t\tr_cons_printf (\"fs %s\\n\", fs);\n\t\t\t\t}\n\t\t\t\tlastfs = 's';\n\t\t\t}\n\t\t\tif (r->bin->prefix || *name) { // we don't want unnamed symbol flags\n\t\t\t\tchar *flagname = construct_symbol_flagname (\"sym\", name, MAXFLAG_LEN_DEFAULT);\n\t\t\t\tif (!flagname) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\t\t\t\tr_cons_printf (\"\\\"f %s%s%s %u 0x%08\" PFMT64x \"\\\"\\n\",\n\t\t\t\t\tr->bin->prefix ? r->bin->prefix : \"\", r->bin->prefix ? \".\" : \"\",\n\t\t\t\t\tflagname, symbol->size, addr);\n\t\t\t\tfree (flagname);\n\t\t\t}\n\t\t\tbinfile = r_bin_cur (r->bin);\n\t\t\tplugin = r_bin_file_cur_plugin (binfile);\n\t\t\tif (plugin && plugin->name) {\n\t\t\t\tif (r_str_startswith (plugin->name, \"pe\")) {\n\t\t\t\t\tchar *module = strdup (r_symbol_name);\n\t\t\t\t\tchar *p = strstr (module, \".dll_\");\n\t\t\t\t\tif (p && strstr (module, \"imp.\")) {\n\t\t\t\t\t\tchar *symname = __filterShell (p + 5);\n\t\t\t\t\t\tchar *m = __filterShell (module);\n\t\t\t\t\t\t*p = 0;\n\t\t\t\t\t\tif (r->bin->prefix) {\n\t\t\t\t\t\t\tr_cons_printf (\"k bin/pe/%s/%d=%s.%s\\n\",\n\t\t\t\t\t\t\t\tmodule, symbol->ordinal, r->bin->prefix, symname);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tr_cons_printf (\"k bin/pe/%s/%d=%s\\n\",\n\t\t\t\t\t\t\t\tmodule, symbol->ordinal, symname);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree (symname);\n\t\t\t\t\t\tfree (m);\n\t\t\t\t\t}\n\t\t\t\t\tfree (module);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tconst char *bind = symbol->bind? symbol->bind: \"NONE\";\n\t\t\tconst char *type = symbol->type? symbol->type: \"NONE\";\n\t\t\tconst char *name = r_str_get (sn.demname? sn.demname: r_symbol_name);\n\t\t\t// const char *fwd = r_str_get (symbol->forwarder);\n\t\t\tr_cons_printf (\"%03u\", symbol->ordinal);\n\t\t\tif (symbol->paddr == UT64_MAX) {\n\t\t\t\tr_cons_printf (\" ----------\");\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\" 0x%08\"PFMT64x, symbol->paddr);\n\t\t\t}\n\t\t\tr_cons_printf (\" 0x%08\"PFMT64x\" %6s %6s %4d%s%s\\n\",\n\t\t\t               addr, bind, type, symbol->size, *name? \" \": \"\", name);\n\t\t}\nnext:\n\t\tsnFini (&sn);\n\t\ti++;\n\t\tfree (r_symbol_name);\n\t\tif (exponly && firstexp) {\n\t\t\tfirstexp = false;\n\t\t}\n\t\tif (printHere) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (count == 0 && IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"{}\");\n\t}\n\n\n\t//handle thumb and arm for entry point since they are not present in symbols\n\tif (is_arm) {\n\t\tr_list_foreach (entries, iter, entry) {\n\t\t\tif (IS_MODE_SET (mode)) {\n\t\t\t\thandle_arm_entry (r, entry, info, va);\n\t\t\t}\n\t\t}\n\t}\n\tif (IS_MODE_JSON (mode) && !printHere) {\n\t\tr_cons_printf (\"]\");\n\t}\n\n\tr_spaces_pop (&r->anal->meta_spaces);\n\treturn true;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149938,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "static int bin_symbols(RCore *r, int mode, ut64 laddr, int va, ut64 at, const char *name, bool exponly, const char *args) {\n\tRBinInfo *info = r_bin_get_info (r->bin);\n\tRList *entries = r_bin_get_entries (r->bin);\n\tRBinSymbol *symbol;\n\tRBinAddr *entry;\n\tRListIter *iter;\n\tbool firstexp = true;\n\tbool printHere = false;\n\tint i = 0, lastfs = 's';\n\tbool bin_demangle = r_config_get_i (r->config, \"bin.demangle\");\n\tif (!info) {\n\t\treturn 0;\n\t}\n\n\tif (args && *args == '.') {\n\t\tprintHere = true;\n\t}\n\n\tbool is_arm = info && info->arch && !strncmp (info->arch, \"arm\", 3);\n\tconst char *lang = bin_demangle ? r_config_get (r->config, \"bin.lang\") : NULL;\n\n\tRList *symbols = r_bin_get_symbols (r->bin);\n\tr_spaces_push (&r->anal->meta_spaces, \"bin\");\n\n\tif (IS_MODE_JSON (mode) && !printHere) {\n\t\tr_cons_printf (\"[\");\n\t} else if (IS_MODE_SET (mode)) {\n\t\tr_flag_space_set (r->flags, R_FLAGS_FS_SYMBOLS);\n\t} else if (!at && exponly) {\n\t\tif (IS_MODE_RAD (mode)) {\n\t\t\tr_cons_printf (\"fs exports\\n\");\n\t\t} else if (IS_MODE_NORMAL (mode)) {\n\t\t\tr_cons_printf (printHere ? \"\" : \"[Exports]\\n\");\n\t\t}\n\t} else if (!at && !exponly) {\n\t\tif (IS_MODE_RAD (mode)) {\n\t\t\tr_cons_printf (\"fs symbols\\n\");\n\t\t} else if (IS_MODE_NORMAL (mode)) {\n\t\t\tr_cons_printf (printHere ? \"\" : \"[Symbols]\\n\");\n\t\t}\n\t}\n\tif (IS_MODE_NORMAL (mode)) {\n\t\tr_cons_printf (\"Num Paddr      Vaddr      Bind     Type Size Name\\n\");\n\t}\n\n\n\tsize_t count = 0;\n\tr_list_foreach (symbols, iter, symbol) {\n\t\tif (!symbol->name) {\n\t\t\tcontinue;\n\t\t}\n\t\tchar *r_symbol_name = r_str_escape_utf8 (symbol->name, false, true);\n\t\tut64 addr = compute_addr (r->bin, symbol->paddr, symbol->vaddr, va);\n\t\tint len = symbol->size ? symbol->size : 32;\n\t\tSymName sn = {0};\n\n\t\tif (exponly && !isAnExport (symbol)) {\n\t\t\tfree (r_symbol_name);\n\t\t\tcontinue;\n\t\t}\n\t\tif (name && strcmp (r_symbol_name, name)) {\n\t\t\tfree (r_symbol_name);\n\t\t\tcontinue;\n\t\t}\n\t\tif (at && (!symbol->size || !is_in_range (at, addr, symbol->size))) {\n\t\t\tfree (r_symbol_name);\n\t\t\tcontinue;\n\t\t}\n\t\tif ((printHere && !is_in_range (r->offset, symbol->paddr, len))\n\t\t\t\t&& (printHere && !is_in_range (r->offset, addr, len))) {\n\t\t\tfree (r_symbol_name);\n\t\t\tcontinue;\n\t\t}\n\t\tcount ++;\n\t\tsnInit (r, &sn, symbol, lang);\n\n\t\tif (IS_MODE_SET (mode) && (is_section_symbol (symbol) || is_file_symbol (symbol))) {\n\t\t\t/*\n\t\t\t * Skip section symbols because they will have their own flag.\n\t\t\t * Skip also file symbols because not useful for now.\n\t\t\t */\n\t\t} else if (IS_MODE_SET (mode) && is_special_symbol (symbol)) {\n\t\t\tif (is_arm) {\n\t\t\t\thandle_arm_special_symbol (r, symbol, va);\n\t\t\t}\n\t\t} else if (IS_MODE_SET (mode)) {\n\t\t\t// TODO: provide separate API in RBinPlugin to let plugins handle anal hints/metadata\n\t\t\tif (is_arm) {\n\t\t\t\thandle_arm_symbol (r, symbol, info, va);\n\t\t\t}\n\t\t\tselect_flag_space (r, symbol);\n\t\t\t/* If that's a Classed symbol (method or so) */\n\t\t\tif (sn.classname) {\n\t\t\t\tRFlagItem *fi = r_flag_get (r->flags, sn.methflag);\n\t\t\t\tif (r->bin->prefix) {\n\t\t\t\t\tchar *prname = r_str_newf (\"%s.%s\", r->bin->prefix, sn.methflag);\n\t\t\t\t\tr_name_filter (sn.methflag, -1);\n\t\t\t\t\tfree (sn.methflag);\n\t\t\t\t\tsn.methflag = prname;\n\t\t\t\t}\n\t\t\t\tif (fi) {\n\t\t\t\t\tr_flag_item_set_realname (fi, sn.methname);\n\t\t\t\t\tif ((fi->offset - r->flags->base) == addr) {\n\t\t\t\t//\t\tchar *comment = fi->comment ? strdup (fi->comment) : NULL;\n\t\t\t\t\t\tr_flag_unset (r->flags, fi);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfi = r_flag_set (r->flags, sn.methflag, addr, symbol->size);\n\t\t\t\t\tchar *comment = fi->comment ? strdup (fi->comment) : NULL;\n\t\t\t\t\tif (comment) {\n\t\t\t\t\t\tr_flag_item_set_comment (fi, comment);\n\t\t\t\t\t\tR_FREE (comment);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst char *n = sn.demname ? sn.demname : sn.name;\n\t\t\t\tconst char *fn = sn.demflag ? sn.demflag : sn.nameflag;\n\t\t\t\tchar *fnp = (r->bin->prefix) ?\n\t\t\t\t\tr_str_newf (\"%s.%s\", r->bin->prefix, fn):\n\t\t\t\t\tstrdup (fn);\n\t\t\t\tRFlagItem *fi = r_flag_set (r->flags, fnp, addr, symbol->size);\n\t\t\t\tif (fi) {\n\t\t\t\t\tr_flag_item_set_realname (fi, n);\n\t\t\t\t\tfi->demangled = (bool)(size_t)sn.demname;\n\t\t\t\t} else {\n\t\t\t\t\tif (fn) {\n\t\t\t\t\t\teprintf (\"[Warning] Can't find flag (%s)\\n\", fn);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree (fnp);\n\t\t\t}\n\t\t\tif (sn.demname) {\n\t\t\t\tr_meta_add (r->anal, R_META_TYPE_COMMENT,\n\t\t\t\t\taddr, symbol->size, sn.demname);\n\t\t\t}\n\t\t\tr_flag_space_pop (r->flags);\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tchar *str = r_str_escape_utf8_for_json (r_symbol_name, -1);\n\t\t\t// str = r_str_replace (str, \"\\\"\", \"\\\\\\\"\", 1);\n\t\t\tr_cons_printf (\"%s{\\\"name\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"demname\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"flagname\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"ordinal\\\":%d,\"\n\t\t\t\t\"\\\"bind\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"size\\\":%d,\"\n\t\t\t\t\"\\\"type\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"vaddr\\\":%\"PFMT64d\",\"\n\t\t\t\t\"\\\"paddr\\\":%\"PFMT64d\"}\",\n\t\t\t\t((exponly && firstexp) || printHere) ? \"\" : (iter->p ? \",\" : \"\"),\n\t\t\t\tstr,\n\t\t\t\tsn.demname? sn.demname: \"\",\n\t\t\t\tsn.nameflag,\n\t\t\t\tsymbol->ordinal,\n\t\t\t\tsymbol->bind,\n\t\t\t\t(int)symbol->size,\n\t\t\t\tsymbol->type,\n\t\t\t\t(ut64)addr, (ut64)symbol->paddr);\n\t\t\tfree (str);\n\t\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\t\tconst char *name = sn.demname? sn.demname: r_symbol_name;\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\" %d %s\\n\",\n\t\t\t\taddr, (int)symbol->size, name);\n\t\t} else if (IS_MODE_SIMPLEST (mode)) {\n\t\t\tconst char *name = sn.demname? sn.demname: r_symbol_name;\n\t\t\tr_cons_printf (\"%s\\n\", name);\n\t\t} else if (IS_MODE_RAD (mode)) {\n\t\t\t/* Skip special symbols because we do not flag them and\n\t\t\t * they shouldn't be printed in the rad format either */\n\t\t\tif (is_special_symbol (symbol)) {\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tRBinFile *binfile;\n\t\t\tRBinPlugin *plugin;\n\t\t\tconst char *name = sn.demname? sn.demname: r_symbol_name;\n\t\t\tif (!name) {\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tif (!strncmp (name, \"imp.\", 4)) {\n\t\t\t\tif (lastfs != 'i') {\n\t\t\t\t\tr_cons_printf (\"fs imports\\n\");\n\t\t\t\t}\n\t\t\t\tlastfs = 'i';\n\t\t\t} else {\n\t\t\t\tif (lastfs != 's') {\n\t\t\t\t\tconst char *fs = exponly? \"exports\": \"symbols\";\n\t\t\t\t\tr_cons_printf (\"fs %s\\n\", fs);\n\t\t\t\t}\n\t\t\t\tlastfs = 's';\n\t\t\t}\n\t\t\tif (r->bin->prefix || *name) { // we don't want unnamed symbol flags\n\t\t\t\tchar *flagname = construct_symbol_flagname (\"sym\", name, MAXFLAG_LEN_DEFAULT);\n\t\t\t\tif (!flagname) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\t\t\t\tr_cons_printf (\"\\\"f %s%s%s %u 0x%08\" PFMT64x \"\\\"\\n\",\n\t\t\t\t\tr->bin->prefix ? r->bin->prefix : \"\", r->bin->prefix ? \".\" : \"\",\n\t\t\t\t\tflagname, symbol->size, addr);\n\t\t\t\tfree (flagname);\n\t\t\t}\n\t\t\tbinfile = r_bin_cur (r->bin);\n\t\t\tplugin = r_bin_file_cur_plugin (binfile);\n\t\t\tif (plugin && plugin->name) {\n\t\t\t\tif (r_str_startswith (plugin->name, \"pe\")) {\n\t\t\t\t\tchar *module = strdup (r_symbol_name);\n\t\t\t\t\tchar *p = strstr (module, \".dll_\");\n\t\t\t\t\tif (p && strstr (module, \"imp.\")) {\n\t\t\t\t\t\tchar *symname = __filterShell (p + 5);\n\t\t\t\t\t\tchar *m = __filterShell (module);\n\t\t\t\t\t\t*p = 0;\n\t\t\t\t\t\tif (r->bin->prefix) {\n\t\t\t\t\t\t\tr_cons_printf (\"\\\"k bin/pe/%s/%d=%s.%s\\\"\\n\",\n\t\t\t\t\t\t\t\tmodule, symbol->ordinal, r->bin->prefix, symname);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tr_cons_printf (\"\\\"k bin/pe/%s/%d=%s\\\"\\n\",\n\t\t\t\t\t\t\t\tmodule, symbol->ordinal, symname);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree (symname);\n\t\t\t\t\t\tfree (m);\n\t\t\t\t\t}\n\t\t\t\t\tfree (module);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tconst char *bind = symbol->bind? symbol->bind: \"NONE\";\n\t\t\tconst char *type = symbol->type? symbol->type: \"NONE\";\n\t\t\tconst char *name = r_str_get (sn.demname? sn.demname: r_symbol_name);\n\t\t\t// const char *fwd = r_str_get (symbol->forwarder);\n\t\t\tr_cons_printf (\"%03u\", symbol->ordinal);\n\t\t\tif (symbol->paddr == UT64_MAX) {\n\t\t\t\tr_cons_printf (\" ----------\");\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\" 0x%08\"PFMT64x, symbol->paddr);\n\t\t\t}\n\t\t\tr_cons_printf (\" 0x%08\"PFMT64x\" %6s %6s %4d%s%s\\n\",\n\t\t\t               addr, bind, type, symbol->size, *name? \" \": \"\", name);\n\t\t}\nnext:\n\t\tsnFini (&sn);\n\t\ti++;\n\t\tfree (r_symbol_name);\n\t\tif (exponly && firstexp) {\n\t\t\tfirstexp = false;\n\t\t}\n\t\tif (printHere) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (count == 0 && IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"{}\");\n\t}\n\n\n\t//handle thumb and arm for entry point since they are not present in symbols\n\tif (is_arm) {\n\t\tr_list_foreach (entries, iter, entry) {\n\t\t\tif (IS_MODE_SET (mode)) {\n\t\t\t\thandle_arm_entry (r, entry, info, va);\n\t\t\t}\n\t\t}\n\t}\n\tif (IS_MODE_JSON (mode) && !printHere) {\n\t\tr_cons_printf (\"]\");\n\t}\n\n\tr_spaces_pop (&r->anal->meta_spaces);\n\treturn true;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149939,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "openscript(\n    char_u\t*name,\n    int\t\tdirectly)\t/* when TRUE execute directly */\n{\n    if (curscript + 1 == NSCRIPT)\n    {\n\temsg(_(e_nesting));\n\treturn;\n    }\n#ifdef FEAT_EVAL\n    if (ignore_script)\n\t/* Not reading from script, also don't open one.  Warning message? */\n\treturn;\n#endif\n\n    if (scriptin[curscript] != NULL)\t/* already reading script */\n\t++curscript;\n\t\t\t\t/* use NameBuff for expanded name */\n    expand_env(name, NameBuff, MAXPATHL);\n    if ((scriptin[curscript] = mch_fopen((char *)NameBuff, READBIN)) == NULL)\n    {\n\tsemsg(_(e_notopen), name);\n\tif (curscript)\n\t    --curscript;\n\treturn;\n    }\n    if (save_typebuf() == FAIL)\n\treturn;\n\n    /*\n     * Execute the commands from the file right now when using \":source!\"\n     * after \":global\" or \":argdo\" or in a loop.  Also when another command\n     * follows.  This means the display won't be updated.  Don't do this\n     * always, \"make test\" would fail.\n     */\n    if (directly)\n    {\n\toparg_T\toa;\n\tint\toldcurscript;\n\tint\tsave_State = State;\n\tint\tsave_restart_edit = restart_edit;\n\tint\tsave_insertmode = p_im;\n\tint\tsave_finish_op = finish_op;\n\tint\tsave_msg_scroll = msg_scroll;\n\n\tState = NORMAL;\n\tmsg_scroll = FALSE;\t/* no msg scrolling in Normal mode */\n\trestart_edit = 0;\t/* don't go to Insert mode */\n\tp_im = FALSE;\t\t/* don't use 'insertmode' */\n\tclear_oparg(&oa);\n\tfinish_op = FALSE;\n\n\toldcurscript = curscript;\n\tdo\n\t{\n\t    update_topline_cursor();\t// update cursor position and topline\n\t    normal_cmd(&oa, FALSE);\t// execute one command\n\t    vpeekc();\t\t\t// check for end of file\n\t}\n\twhile (scriptin[oldcurscript] != NULL);\n\n\tState = save_State;\n\tmsg_scroll = save_msg_scroll;\n\trestart_edit = save_restart_edit;\n\tp_im = save_insertmode;\n\tfinish_op = save_finish_op;\n    }\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149942,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "openscript(\n    char_u\t*name,\n    int\t\tdirectly)\t/* when TRUE execute directly */\n{\n    if (curscript + 1 == NSCRIPT)\n    {\n\temsg(_(e_nesting));\n\treturn;\n    }\n\n    // Disallow sourcing a file in the sandbox, the commands would be executed\n    // later, possibly outside of the sandbox.\n    if (check_secure())\n\treturn;\n\n#ifdef FEAT_EVAL\n    if (ignore_script)\n\t/* Not reading from script, also don't open one.  Warning message? */\n\treturn;\n#endif\n\n    if (scriptin[curscript] != NULL)\t/* already reading script */\n\t++curscript;\n\t\t\t\t/* use NameBuff for expanded name */\n    expand_env(name, NameBuff, MAXPATHL);\n    if ((scriptin[curscript] = mch_fopen((char *)NameBuff, READBIN)) == NULL)\n    {\n\tsemsg(_(e_notopen), name);\n\tif (curscript)\n\t    --curscript;\n\treturn;\n    }\n    if (save_typebuf() == FAIL)\n\treturn;\n\n    /*\n     * Execute the commands from the file right now when using \":source!\"\n     * after \":global\" or \":argdo\" or in a loop.  Also when another command\n     * follows.  This means the display won't be updated.  Don't do this\n     * always, \"make test\" would fail.\n     */\n    if (directly)\n    {\n\toparg_T\toa;\n\tint\toldcurscript;\n\tint\tsave_State = State;\n\tint\tsave_restart_edit = restart_edit;\n\tint\tsave_insertmode = p_im;\n\tint\tsave_finish_op = finish_op;\n\tint\tsave_msg_scroll = msg_scroll;\n\n\tState = NORMAL;\n\tmsg_scroll = FALSE;\t/* no msg scrolling in Normal mode */\n\trestart_edit = 0;\t/* don't go to Insert mode */\n\tp_im = FALSE;\t\t/* don't use 'insertmode' */\n\tclear_oparg(&oa);\n\tfinish_op = FALSE;\n\n\toldcurscript = curscript;\n\tdo\n\t{\n\t    update_topline_cursor();\t// update cursor position and topline\n\t    normal_cmd(&oa, FALSE);\t// execute one command\n\t    vpeekc();\t\t\t// check for end of file\n\t}\n\twhile (scriptin[oldcurscript] != NULL);\n\n\tState = save_State;\n\tmsg_scroll = save_msg_scroll;\n\trestart_edit = save_restart_edit;\n\tp_im = save_insertmode;\n\tfinish_op = save_finish_op;\n    }\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149943,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  }
]