[
  {
    "CWE_ID": [
      "CWE-79"
    ],
    "code": "static int php_handler(request_rec *r)\n{\n\tphp_struct * volatile ctx;\n\tvoid *conf;\n\tapr_bucket_brigade * volatile brigade;\n\tapr_bucket *bucket;\n\tapr_status_t rv;\n\trequest_rec * volatile parent_req = NULL;\n\tTSRMLS_FETCH();\n\n#define PHPAP_INI_OFF php_apache_ini_dtor(r, parent_req TSRMLS_CC);\n\n\tconf = ap_get_module_config(r->per_dir_config, &php5_module);\n\n\t/* apply_config() needs r in some cases, so allocate server_context early */\n\tctx = SG(server_context);\n\tif (ctx == NULL || (ctx && ctx->request_processed && !strcmp(r->protocol, \"INCLUDED\"))) {\nnormal:\n\t\tctx = SG(server_context) = apr_pcalloc(r->pool, sizeof(*ctx));\n\t\t/* register a cleanup so we clear out the SG(server_context)\n\t\t * after each request. Note: We pass in the pointer to the\n\t\t * server_context in case this is handled by a different thread.\n\t\t */\n\t\tapr_pool_cleanup_register(r->pool, (void *)&SG(server_context), php_server_context_cleanup, apr_pool_cleanup_null);\n\t\tctx->r = r;\n\t\tctx = NULL; /* May look weird to null it here, but it is to catch the right case in the first_try later on */\n\t} else {\n\t\tparent_req = ctx->r;\n\t\tctx->r = r;\n\t}\n\tapply_config(conf);\n\n\tif (strcmp(r->handler, PHP_MAGIC_TYPE) && strcmp(r->handler, PHP_SOURCE_MAGIC_TYPE) && strcmp(r->handler, PHP_SCRIPT)) {\n\t\t/* Check for xbithack in this case. */\n\t\tif (!AP2(xbithack) || strcmp(r->handler, \"text/html\") || !(r->finfo.protection & APR_UEXECUTE)) {\n\t\t\tPHPAP_INI_OFF;\n\t\t\treturn DECLINED;\n\t\t}\n\t}\n\n\t/* Give a 404 if PATH_INFO is used but is explicitly disabled in\n\t * the configuration; default behaviour is to accept. */\n\tif (r->used_path_info == AP_REQ_REJECT_PATH_INFO\n\t\t&& r->path_info && r->path_info[0]) {\n\t\tPHPAP_INI_OFF;\n\t\treturn HTTP_NOT_FOUND;\n\t}\n\n\t/* handle situations where user turns the engine off */\n\tif (!AP2(engine)) {\n\t\tPHPAP_INI_OFF;\n\t\treturn DECLINED;\n\t}\n\n\tif (r->finfo.filetype == 0) {\n\t\tphp_apache_sapi_log_message_ex(\"script '%s' not found or unable to stat\", r TSRMLS_CC);\n\t\tPHPAP_INI_OFF;\n\t\treturn HTTP_NOT_FOUND;\n\t}\n\tif (r->finfo.filetype == APR_DIR) {\n\t\tphp_apache_sapi_log_message_ex(\"attempt to invoke directory '%s' as script\", r TSRMLS_CC);\n\t\tPHPAP_INI_OFF;\n\t\treturn HTTP_FORBIDDEN;\n\t}\n\n\t/* Setup the CGI variables if this is the main request */\n\tif (r->main == NULL ||\n\t\t/* .. or if the sub-request environment differs from the main-request. */\n\t\tr->subprocess_env != r->main->subprocess_env\n\t) {\n\t\t/* setup standard CGI variables */\n\t\tap_add_common_vars(r);\n\t\tap_add_cgi_vars(r);\n\t}\n\nzend_first_try {\n\n\tif (ctx == NULL) {\n\t\tbrigade = apr_brigade_create(r->pool, r->connection->bucket_alloc);\n\t\tctx = SG(server_context);\n\t\tctx->brigade = brigade;\n\n\t\tif (php_apache_request_ctor(r, ctx TSRMLS_CC)!=SUCCESS) {\n\t\t\tzend_bailout();\n\t\t}\n\t} else {\n\t\tif (!parent_req) {\n\t\t\tparent_req = ctx->r;\n\t\t}\n\t\tif (parent_req && parent_req->handler &&\n\t\t\t\tstrcmp(parent_req->handler, PHP_MAGIC_TYPE) &&\n\t\t\t\tstrcmp(parent_req->handler, PHP_SOURCE_MAGIC_TYPE) &&\n\t\t\t\tstrcmp(parent_req->handler, PHP_SCRIPT)) {\n\t\t\tif (php_apache_request_ctor(r, ctx TSRMLS_CC)!=SUCCESS) {\n\t\t\t\tzend_bailout();\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * check if coming due to ErrorDocument\n\t\t * We make a special exception of 413 (Invalid POST request) as the invalidity of the request occurs\n\t\t * during processing of the request by PHP during POST processing. Therefor we need to re-use the exiting\n\t\t * PHP instance to handle the request rather then creating a new one.\n\t\t*/\n\t\tif (parent_req && parent_req->status != HTTP_OK && parent_req->status != 413 && strcmp(r->protocol, \"INCLUDED\")) {\n\t\t\tparent_req = NULL;\n\t\t\tgoto normal;\n\t\t}\n\t\tctx->r = r;\n\t\tbrigade = ctx->brigade;\n\t}\n\n\tif (AP2(last_modified)) {\n\t\tap_update_mtime(r, r->finfo.mtime);\n\t\tap_set_last_modified(r);\n\t}\n\n\t/* Determine if we need to parse the file or show the source */\n\tif (strncmp(r->handler, PHP_SOURCE_MAGIC_TYPE, sizeof(PHP_SOURCE_MAGIC_TYPE) - 1) == 0) {\n\t\tzend_syntax_highlighter_ini syntax_highlighter_ini;\n\t\tphp_get_highlight_struct(&syntax_highlighter_ini);\n\t\thighlight_file((char *)r->filename, &syntax_highlighter_ini TSRMLS_CC);\n\t} else {\n\t\tzend_file_handle zfd;\n\n\t\tzfd.type = ZEND_HANDLE_FILENAME;\n\t\tzfd.filename = (char *) r->filename;\n\t\tzfd.free_filename = 0;\n\t\tzfd.opened_path = NULL;\n\n\t\tif (!parent_req) {\n\t\t\tphp_execute_script(&zfd TSRMLS_CC);\n\t\t} else {\n\t\t\tzend_execute_scripts(ZEND_INCLUDE TSRMLS_CC, NULL, 1, &zfd);\n\t\t}\n\n\t\tapr_table_set(r->notes, \"mod_php_memory_usage\",\n\t\t\tapr_psprintf(ctx->r->pool, \"%\" APR_SIZE_T_FMT, zend_memory_peak_usage(1 TSRMLS_CC)));\n\t}\n\n} zend_end_try();\n\n \tif (!parent_req) {\n \t\tphp_apache_request_dtor(r TSRMLS_CC);\n \t\tctx->request_processed = 1;\n \t\tbucket = apr_bucket_eos_create(r->connection->bucket_alloc);\n \t\tAPR_BRIGADE_INSERT_TAIL(brigade, bucket);\n \n\t\trv = ap_pass_brigade(r->output_filters, brigade);\n\t\tif (rv != APR_SUCCESS || r->connection->aborted) {\nzend_first_try {\n\t\t\tphp_handle_aborted_connection();\n} zend_end_try();\n\t\t}\n\t\tapr_brigade_cleanup(brigade);\n\t\tapr_pool_cleanup_run(r->pool, (void *)&SG(server_context), php_server_context_cleanup);\n\t} else {\n\t\tctx->r = parent_req;\n\t}\n\n\treturn OK;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142901,
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-79"
    ],
    "code": "static int php_handler(request_rec *r)\n{\n\tphp_struct * volatile ctx;\n\tvoid *conf;\n\tapr_bucket_brigade * volatile brigade;\n\tapr_bucket *bucket;\n\tapr_status_t rv;\n\trequest_rec * volatile parent_req = NULL;\n\tTSRMLS_FETCH();\n\n#define PHPAP_INI_OFF php_apache_ini_dtor(r, parent_req TSRMLS_CC);\n\n\tconf = ap_get_module_config(r->per_dir_config, &php5_module);\n\n\t/* apply_config() needs r in some cases, so allocate server_context early */\n\tctx = SG(server_context);\n\tif (ctx == NULL || (ctx && ctx->request_processed && !strcmp(r->protocol, \"INCLUDED\"))) {\nnormal:\n\t\tctx = SG(server_context) = apr_pcalloc(r->pool, sizeof(*ctx));\n\t\t/* register a cleanup so we clear out the SG(server_context)\n\t\t * after each request. Note: We pass in the pointer to the\n\t\t * server_context in case this is handled by a different thread.\n\t\t */\n\t\tapr_pool_cleanup_register(r->pool, (void *)&SG(server_context), php_server_context_cleanup, apr_pool_cleanup_null);\n\t\tctx->r = r;\n\t\tctx = NULL; /* May look weird to null it here, but it is to catch the right case in the first_try later on */\n\t} else {\n\t\tparent_req = ctx->r;\n\t\tctx->r = r;\n\t}\n\tapply_config(conf);\n\n\tif (strcmp(r->handler, PHP_MAGIC_TYPE) && strcmp(r->handler, PHP_SOURCE_MAGIC_TYPE) && strcmp(r->handler, PHP_SCRIPT)) {\n\t\t/* Check for xbithack in this case. */\n\t\tif (!AP2(xbithack) || strcmp(r->handler, \"text/html\") || !(r->finfo.protection & APR_UEXECUTE)) {\n\t\t\tPHPAP_INI_OFF;\n\t\t\treturn DECLINED;\n\t\t}\n\t}\n\n\t/* Give a 404 if PATH_INFO is used but is explicitly disabled in\n\t * the configuration; default behaviour is to accept. */\n\tif (r->used_path_info == AP_REQ_REJECT_PATH_INFO\n\t\t&& r->path_info && r->path_info[0]) {\n\t\tPHPAP_INI_OFF;\n\t\treturn HTTP_NOT_FOUND;\n\t}\n\n\t/* handle situations where user turns the engine off */\n\tif (!AP2(engine)) {\n\t\tPHPAP_INI_OFF;\n\t\treturn DECLINED;\n\t}\n\n\tif (r->finfo.filetype == 0) {\n\t\tphp_apache_sapi_log_message_ex(\"script '%s' not found or unable to stat\", r TSRMLS_CC);\n\t\tPHPAP_INI_OFF;\n\t\treturn HTTP_NOT_FOUND;\n\t}\n\tif (r->finfo.filetype == APR_DIR) {\n\t\tphp_apache_sapi_log_message_ex(\"attempt to invoke directory '%s' as script\", r TSRMLS_CC);\n\t\tPHPAP_INI_OFF;\n\t\treturn HTTP_FORBIDDEN;\n\t}\n\n\t/* Setup the CGI variables if this is the main request */\n\tif (r->main == NULL ||\n\t\t/* .. or if the sub-request environment differs from the main-request. */\n\t\tr->subprocess_env != r->main->subprocess_env\n\t) {\n\t\t/* setup standard CGI variables */\n\t\tap_add_common_vars(r);\n\t\tap_add_cgi_vars(r);\n\t}\n\nzend_first_try {\n\n\tif (ctx == NULL) {\n\t\tbrigade = apr_brigade_create(r->pool, r->connection->bucket_alloc);\n\t\tctx = SG(server_context);\n\t\tctx->brigade = brigade;\n\n\t\tif (php_apache_request_ctor(r, ctx TSRMLS_CC)!=SUCCESS) {\n\t\t\tzend_bailout();\n\t\t}\n\t} else {\n\t\tif (!parent_req) {\n\t\t\tparent_req = ctx->r;\n\t\t}\n\t\tif (parent_req && parent_req->handler &&\n\t\t\t\tstrcmp(parent_req->handler, PHP_MAGIC_TYPE) &&\n\t\t\t\tstrcmp(parent_req->handler, PHP_SOURCE_MAGIC_TYPE) &&\n\t\t\t\tstrcmp(parent_req->handler, PHP_SCRIPT)) {\n\t\t\tif (php_apache_request_ctor(r, ctx TSRMLS_CC)!=SUCCESS) {\n\t\t\t\tzend_bailout();\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * check if coming due to ErrorDocument\n\t\t * We make a special exception of 413 (Invalid POST request) as the invalidity of the request occurs\n\t\t * during processing of the request by PHP during POST processing. Therefor we need to re-use the exiting\n\t\t * PHP instance to handle the request rather then creating a new one.\n\t\t*/\n\t\tif (parent_req && parent_req->status != HTTP_OK && parent_req->status != 413 && strcmp(r->protocol, \"INCLUDED\")) {\n\t\t\tparent_req = NULL;\n\t\t\tgoto normal;\n\t\t}\n\t\tctx->r = r;\n\t\tbrigade = ctx->brigade;\n\t}\n\n\tif (AP2(last_modified)) {\n\t\tap_update_mtime(r, r->finfo.mtime);\n\t\tap_set_last_modified(r);\n\t}\n\n\t/* Determine if we need to parse the file or show the source */\n\tif (strncmp(r->handler, PHP_SOURCE_MAGIC_TYPE, sizeof(PHP_SOURCE_MAGIC_TYPE) - 1) == 0) {\n\t\tzend_syntax_highlighter_ini syntax_highlighter_ini;\n\t\tphp_get_highlight_struct(&syntax_highlighter_ini);\n\t\thighlight_file((char *)r->filename, &syntax_highlighter_ini TSRMLS_CC);\n\t} else {\n\t\tzend_file_handle zfd;\n\n\t\tzfd.type = ZEND_HANDLE_FILENAME;\n\t\tzfd.filename = (char *) r->filename;\n\t\tzfd.free_filename = 0;\n\t\tzfd.opened_path = NULL;\n\n\t\tif (!parent_req) {\n\t\t\tphp_execute_script(&zfd TSRMLS_CC);\n\t\t} else {\n\t\t\tzend_execute_scripts(ZEND_INCLUDE TSRMLS_CC, NULL, 1, &zfd);\n\t\t}\n\n\t\tapr_table_set(r->notes, \"mod_php_memory_usage\",\n\t\t\tapr_psprintf(ctx->r->pool, \"%\" APR_SIZE_T_FMT, zend_memory_peak_usage(1 TSRMLS_CC)));\n\t}\n\n} zend_end_try();\n\n \tif (!parent_req) {\n \t\tphp_apache_request_dtor(r TSRMLS_CC);\n \t\tctx->request_processed = 1;\n\t\tapr_brigade_cleanup(brigade);\n \t\tbucket = apr_bucket_eos_create(r->connection->bucket_alloc);\n \t\tAPR_BRIGADE_INSERT_TAIL(brigade, bucket);\n \n\t\trv = ap_pass_brigade(r->output_filters, brigade);\n\t\tif (rv != APR_SUCCESS || r->connection->aborted) {\nzend_first_try {\n\t\t\tphp_handle_aborted_connection();\n} zend_end_try();\n\t\t}\n\t\tapr_brigade_cleanup(brigade);\n\t\tapr_pool_cleanup_run(r->pool, (void *)&SG(server_context), php_server_context_cleanup);\n\t} else {\n\t\tctx->r = parent_req;\n\t}\n\n\treturn OK;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142902,
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-79"
    ],
    "code": "SSLErrorInfo SSLErrorInfo::CreateError(ErrorType error_type,\n                                       net::X509Certificate* cert,\n                                       const GURL& request_url) {\n  string16 title, details, short_description;\n  std::vector<string16> extra_info;\n  switch (error_type) {\n    case CERT_COMMON_NAME_INVALID: {\n      title =\n          l10n_util::GetStringUTF16(IDS_CERT_ERROR_COMMON_NAME_INVALID_TITLE);\n      std::vector<std::string> dns_names;\n      cert->GetDNSNames(&dns_names);\n      DCHECK(!dns_names.empty());\n      size_t i = 0;\n      for (; i < dns_names.size(); ++i) {\n        if (dns_names[i] == cert->subject().common_name)\n          break;\n      }\n      if (i == dns_names.size())\n        i = 0;\n       details =\n           l10n_util::GetStringFUTF16(IDS_CERT_ERROR_COMMON_NAME_INVALID_DETAILS,\n                                      UTF8ToUTF16(request_url.host()),\n                                     UTF8ToUTF16(dns_names[i]),\n                                      UTF8ToUTF16(request_url.host()));\n       short_description = l10n_util::GetStringUTF16(\n           IDS_CERT_ERROR_COMMON_NAME_INVALID_DESCRIPTION);\n      extra_info.push_back(\n          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));\n       extra_info.push_back(\n           l10n_util::GetStringFUTF16(\n               IDS_CERT_ERROR_COMMON_NAME_INVALID_EXTRA_INFO_2,\n              UTF8ToUTF16(cert->subject().common_name),\n               UTF8ToUTF16(request_url.host())));\n       break;\n     }\n    case CERT_DATE_INVALID:\n      extra_info.push_back(\n          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));\n      if (cert->HasExpired()) {\n        title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXPIRED_TITLE);\n        details = l10n_util::GetStringFUTF16(\n            IDS_CERT_ERROR_EXPIRED_DETAILS,\n            UTF8ToUTF16(request_url.host()),\n            UTF8ToUTF16(request_url.host()),\n            base::TimeFormatFriendlyDateAndTime(base::Time::Now()));\n        short_description =\n            l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXPIRED_DESCRIPTION);\n        extra_info.push_back(l10n_util::GetStringUTF16(\n            IDS_CERT_ERROR_EXPIRED_DETAILS_EXTRA_INFO_2));\n      } else {\n        title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_NOT_YET_VALID_TITLE);\n        details = l10n_util::GetStringFUTF16(\n            IDS_CERT_ERROR_NOT_YET_VALID_DETAILS,\n            UTF8ToUTF16(request_url.host()),\n            UTF8ToUTF16(request_url.host()),\n            base::TimeFormatFriendlyDateAndTime(base::Time::Now()));\n        short_description =\n            l10n_util::GetStringUTF16(IDS_CERT_ERROR_NOT_YET_VALID_DESCRIPTION);\n        extra_info.push_back(\n            l10n_util::GetStringUTF16(\n                IDS_CERT_ERROR_NOT_YET_VALID_DETAILS_EXTRA_INFO_2));\n      }\n      break;\n    case CERT_AUTHORITY_INVALID:\n      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_AUTHORITY_INVALID_TITLE);\n      details = l10n_util::GetStringFUTF16(\n          IDS_CERT_ERROR_AUTHORITY_INVALID_DETAILS,\n          UTF8ToUTF16(request_url.host()));\n      short_description = l10n_util::GetStringUTF16(\n          IDS_CERT_ERROR_AUTHORITY_INVALID_DESCRIPTION);\n      extra_info.push_back(\n          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));\n      extra_info.push_back(l10n_util::GetStringFUTF16(\n          IDS_CERT_ERROR_AUTHORITY_INVALID_EXTRA_INFO_2,\n          UTF8ToUTF16(request_url.host()),\n          UTF8ToUTF16(request_url.host())));\n      extra_info.push_back(l10n_util::GetStringUTF16(\n          IDS_CERT_ERROR_AUTHORITY_INVALID_EXTRA_INFO_3));\n      break;\n    case CERT_CONTAINS_ERRORS:\n      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_CONTAINS_ERRORS_TITLE);\n      details = l10n_util::GetStringFUTF16(\n          IDS_CERT_ERROR_CONTAINS_ERRORS_DETAILS,\n          UTF8ToUTF16(request_url.host()));\n      short_description =\n          l10n_util::GetStringUTF16(IDS_CERT_ERROR_CONTAINS_ERRORS_DESCRIPTION);\n      extra_info.push_back(\n          l10n_util::GetStringFUTF16(IDS_CERT_ERROR_EXTRA_INFO_1,\n                                     UTF8ToUTF16(request_url.host())));\n      extra_info.push_back(l10n_util::GetStringUTF16(\n          IDS_CERT_ERROR_CONTAINS_ERRORS_EXTRA_INFO_2));\n      break;\n    case CERT_NO_REVOCATION_MECHANISM:\n      title = l10n_util::GetStringUTF16(\n          IDS_CERT_ERROR_NO_REVOCATION_MECHANISM_TITLE);\n      details = l10n_util::GetStringUTF16(\n          IDS_CERT_ERROR_NO_REVOCATION_MECHANISM_DETAILS);\n      short_description = l10n_util::GetStringUTF16(\n          IDS_CERT_ERROR_NO_REVOCATION_MECHANISM_DESCRIPTION);\n      break;\n    case CERT_UNABLE_TO_CHECK_REVOCATION:\n      title = l10n_util::GetStringUTF16(\n          IDS_CERT_ERROR_UNABLE_TO_CHECK_REVOCATION_TITLE);\n      details = l10n_util::GetStringUTF16(\n          IDS_CERT_ERROR_UNABLE_TO_CHECK_REVOCATION_DETAILS);\n      short_description = l10n_util::GetStringUTF16(\n          IDS_CERT_ERROR_UNABLE_TO_CHECK_REVOCATION_DESCRIPTION);\n      break;\n    case CERT_REVOKED:\n      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_REVOKED_CERT_TITLE);\n      details = l10n_util::GetStringFUTF16(IDS_CERT_ERROR_REVOKED_CERT_DETAILS,\n                                           UTF8ToUTF16(request_url.host()));\n      short_description =\n          l10n_util::GetStringUTF16(IDS_CERT_ERROR_REVOKED_CERT_DESCRIPTION);\n      extra_info.push_back(\n          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));\n      extra_info.push_back(\n          l10n_util::GetStringUTF16(IDS_CERT_ERROR_REVOKED_CERT_EXTRA_INFO_2));\n      break;\n    case CERT_INVALID:\n      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_INVALID_CERT_TITLE);\n      details = l10n_util::GetStringFUTF16(\n          IDS_CERT_ERROR_INVALID_CERT_DETAILS,\n          UTF8ToUTF16(request_url.host()));\n      short_description =\n          l10n_util::GetStringUTF16(IDS_CERT_ERROR_INVALID_CERT_DESCRIPTION);\n      extra_info.push_back(\n          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));\n      extra_info.push_back(l10n_util::GetStringUTF16(\n          IDS_CERT_ERROR_INVALID_CERT_EXTRA_INFO_2));\n      break;\n    case CERT_WEAK_SIGNATURE_ALGORITHM:\n      title = l10n_util::GetStringUTF16(\n          IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_TITLE);\n      details = l10n_util::GetStringFUTF16(\n          IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_DETAILS,\n          UTF8ToUTF16(request_url.host()));\n      short_description = l10n_util::GetStringUTF16(\n          IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_DESCRIPTION);\n      extra_info.push_back(\n          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));\n      extra_info.push_back(\n          l10n_util::GetStringUTF16(\n              IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_EXTRA_INFO_2));\n      break;\n    case CERT_WEAK_KEY:\n      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_WEAK_KEY_TITLE);\n      details = l10n_util::GetStringFUTF16(\n          IDS_CERT_ERROR_WEAK_KEY_DETAILS, UTF8ToUTF16(request_url.host()));\n      short_description = l10n_util::GetStringUTF16(\n          IDS_CERT_ERROR_WEAK_KEY_DESCRIPTION);\n      extra_info.push_back(\n          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));\n      extra_info.push_back(\n          l10n_util::GetStringUTF16(\n              IDS_CERT_ERROR_WEAK_KEY_EXTRA_INFO_2));\n      break;\n    case UNKNOWN:\n      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_UNKNOWN_ERROR_TITLE);\n      details = l10n_util::GetStringUTF16(IDS_CERT_ERROR_UNKNOWN_ERROR_DETAILS);\n      short_description =\n          l10n_util::GetStringUTF16(IDS_CERT_ERROR_UNKNOWN_ERROR_DESCRIPTION);\n      break;\n    default:\n      NOTREACHED();\n  }\n  return SSLErrorInfo(title, details, short_description, extra_info);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143543,
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-79"
    ],
    "code": "SSLErrorInfo SSLErrorInfo::CreateError(ErrorType error_type,\n                                       net::X509Certificate* cert,\n                                       const GURL& request_url) {\n  string16 title, details, short_description;\n  std::vector<string16> extra_info;\n  switch (error_type) {\n    case CERT_COMMON_NAME_INVALID: {\n      title =\n          l10n_util::GetStringUTF16(IDS_CERT_ERROR_COMMON_NAME_INVALID_TITLE);\n      std::vector<std::string> dns_names;\n      cert->GetDNSNames(&dns_names);\n      DCHECK(!dns_names.empty());\n      size_t i = 0;\n      for (; i < dns_names.size(); ++i) {\n        if (dns_names[i] == cert->subject().common_name)\n          break;\n      }\n      if (i == dns_names.size())\n        i = 0;\n       details =\n           l10n_util::GetStringFUTF16(IDS_CERT_ERROR_COMMON_NAME_INVALID_DETAILS,\n                                      UTF8ToUTF16(request_url.host()),\n                                     net::EscapeForHTML(\n                                         UTF8ToUTF16(dns_names[i])),\n                                      UTF8ToUTF16(request_url.host()));\n       short_description = l10n_util::GetStringUTF16(\n           IDS_CERT_ERROR_COMMON_NAME_INVALID_DESCRIPTION);\n      extra_info.push_back(\n          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));\n       extra_info.push_back(\n           l10n_util::GetStringFUTF16(\n               IDS_CERT_ERROR_COMMON_NAME_INVALID_EXTRA_INFO_2,\n              net::EscapeForHTML(UTF8ToUTF16(cert->subject().common_name)),\n               UTF8ToUTF16(request_url.host())));\n       break;\n     }\n    case CERT_DATE_INVALID:\n      extra_info.push_back(\n          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));\n      if (cert->HasExpired()) {\n        title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXPIRED_TITLE);\n        details = l10n_util::GetStringFUTF16(\n            IDS_CERT_ERROR_EXPIRED_DETAILS,\n            UTF8ToUTF16(request_url.host()),\n            UTF8ToUTF16(request_url.host()),\n            base::TimeFormatFriendlyDateAndTime(base::Time::Now()));\n        short_description =\n            l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXPIRED_DESCRIPTION);\n        extra_info.push_back(l10n_util::GetStringUTF16(\n            IDS_CERT_ERROR_EXPIRED_DETAILS_EXTRA_INFO_2));\n      } else {\n        title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_NOT_YET_VALID_TITLE);\n        details = l10n_util::GetStringFUTF16(\n            IDS_CERT_ERROR_NOT_YET_VALID_DETAILS,\n            UTF8ToUTF16(request_url.host()),\n            UTF8ToUTF16(request_url.host()),\n            base::TimeFormatFriendlyDateAndTime(base::Time::Now()));\n        short_description =\n            l10n_util::GetStringUTF16(IDS_CERT_ERROR_NOT_YET_VALID_DESCRIPTION);\n        extra_info.push_back(\n            l10n_util::GetStringUTF16(\n                IDS_CERT_ERROR_NOT_YET_VALID_DETAILS_EXTRA_INFO_2));\n      }\n      break;\n    case CERT_AUTHORITY_INVALID:\n      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_AUTHORITY_INVALID_TITLE);\n      details = l10n_util::GetStringFUTF16(\n          IDS_CERT_ERROR_AUTHORITY_INVALID_DETAILS,\n          UTF8ToUTF16(request_url.host()));\n      short_description = l10n_util::GetStringUTF16(\n          IDS_CERT_ERROR_AUTHORITY_INVALID_DESCRIPTION);\n      extra_info.push_back(\n          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));\n      extra_info.push_back(l10n_util::GetStringFUTF16(\n          IDS_CERT_ERROR_AUTHORITY_INVALID_EXTRA_INFO_2,\n          UTF8ToUTF16(request_url.host()),\n          UTF8ToUTF16(request_url.host())));\n      extra_info.push_back(l10n_util::GetStringUTF16(\n          IDS_CERT_ERROR_AUTHORITY_INVALID_EXTRA_INFO_3));\n      break;\n    case CERT_CONTAINS_ERRORS:\n      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_CONTAINS_ERRORS_TITLE);\n      details = l10n_util::GetStringFUTF16(\n          IDS_CERT_ERROR_CONTAINS_ERRORS_DETAILS,\n          UTF8ToUTF16(request_url.host()));\n      short_description =\n          l10n_util::GetStringUTF16(IDS_CERT_ERROR_CONTAINS_ERRORS_DESCRIPTION);\n      extra_info.push_back(\n          l10n_util::GetStringFUTF16(IDS_CERT_ERROR_EXTRA_INFO_1,\n                                     UTF8ToUTF16(request_url.host())));\n      extra_info.push_back(l10n_util::GetStringUTF16(\n          IDS_CERT_ERROR_CONTAINS_ERRORS_EXTRA_INFO_2));\n      break;\n    case CERT_NO_REVOCATION_MECHANISM:\n      title = l10n_util::GetStringUTF16(\n          IDS_CERT_ERROR_NO_REVOCATION_MECHANISM_TITLE);\n      details = l10n_util::GetStringUTF16(\n          IDS_CERT_ERROR_NO_REVOCATION_MECHANISM_DETAILS);\n      short_description = l10n_util::GetStringUTF16(\n          IDS_CERT_ERROR_NO_REVOCATION_MECHANISM_DESCRIPTION);\n      break;\n    case CERT_UNABLE_TO_CHECK_REVOCATION:\n      title = l10n_util::GetStringUTF16(\n          IDS_CERT_ERROR_UNABLE_TO_CHECK_REVOCATION_TITLE);\n      details = l10n_util::GetStringUTF16(\n          IDS_CERT_ERROR_UNABLE_TO_CHECK_REVOCATION_DETAILS);\n      short_description = l10n_util::GetStringUTF16(\n          IDS_CERT_ERROR_UNABLE_TO_CHECK_REVOCATION_DESCRIPTION);\n      break;\n    case CERT_REVOKED:\n      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_REVOKED_CERT_TITLE);\n      details = l10n_util::GetStringFUTF16(IDS_CERT_ERROR_REVOKED_CERT_DETAILS,\n                                           UTF8ToUTF16(request_url.host()));\n      short_description =\n          l10n_util::GetStringUTF16(IDS_CERT_ERROR_REVOKED_CERT_DESCRIPTION);\n      extra_info.push_back(\n          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));\n      extra_info.push_back(\n          l10n_util::GetStringUTF16(IDS_CERT_ERROR_REVOKED_CERT_EXTRA_INFO_2));\n      break;\n    case CERT_INVALID:\n      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_INVALID_CERT_TITLE);\n      details = l10n_util::GetStringFUTF16(\n          IDS_CERT_ERROR_INVALID_CERT_DETAILS,\n          UTF8ToUTF16(request_url.host()));\n      short_description =\n          l10n_util::GetStringUTF16(IDS_CERT_ERROR_INVALID_CERT_DESCRIPTION);\n      extra_info.push_back(\n          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));\n      extra_info.push_back(l10n_util::GetStringUTF16(\n          IDS_CERT_ERROR_INVALID_CERT_EXTRA_INFO_2));\n      break;\n    case CERT_WEAK_SIGNATURE_ALGORITHM:\n      title = l10n_util::GetStringUTF16(\n          IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_TITLE);\n      details = l10n_util::GetStringFUTF16(\n          IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_DETAILS,\n          UTF8ToUTF16(request_url.host()));\n      short_description = l10n_util::GetStringUTF16(\n          IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_DESCRIPTION);\n      extra_info.push_back(\n          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));\n      extra_info.push_back(\n          l10n_util::GetStringUTF16(\n              IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_EXTRA_INFO_2));\n      break;\n    case CERT_WEAK_KEY:\n      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_WEAK_KEY_TITLE);\n      details = l10n_util::GetStringFUTF16(\n          IDS_CERT_ERROR_WEAK_KEY_DETAILS, UTF8ToUTF16(request_url.host()));\n      short_description = l10n_util::GetStringUTF16(\n          IDS_CERT_ERROR_WEAK_KEY_DESCRIPTION);\n      extra_info.push_back(\n          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));\n      extra_info.push_back(\n          l10n_util::GetStringUTF16(\n              IDS_CERT_ERROR_WEAK_KEY_EXTRA_INFO_2));\n      break;\n    case UNKNOWN:\n      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_UNKNOWN_ERROR_TITLE);\n      details = l10n_util::GetStringUTF16(IDS_CERT_ERROR_UNKNOWN_ERROR_DETAILS);\n      short_description =\n          l10n_util::GetStringUTF16(IDS_CERT_ERROR_UNKNOWN_ERROR_DESCRIPTION);\n      break;\n    default:\n      NOTREACHED();\n  }\n  return SSLErrorInfo(title, details, short_description, extra_info);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143544,
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-79"
    ],
    "code": " base::string16 FormatBookmarkURLForDisplay(const GURL& url) {\n  return url_formatter::FormatUrl(\n      url, url_formatter::kFormatUrlOmitAll &\n               ~url_formatter::kFormatUrlOmitUsernamePassword,\n      net::UnescapeRule::SPACES, nullptr, nullptr, nullptr);\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143631,
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-79"
    ],
    "code": " base::string16 FormatBookmarkURLForDisplay(const GURL& url) {\n  // and trailing slash, and unescape most characters. However, it's\n  url_formatter::FormatUrlTypes format_types =\n      url_formatter::kFormatUrlOmitAll &\n      ~url_formatter::kFormatUrlOmitUsernamePassword;\n\n  // If username is present, we must not omit the scheme because FixupURL() will\n  // subsequently interpret the username as a scheme. crbug.com/639126\n  if (url.has_username())\n    format_types &= ~url_formatter::kFormatUrlOmitHTTP;\n\n  return url_formatter::FormatUrl(url, format_types, net::UnescapeRule::SPACES,\n                                  nullptr, nullptr, nullptr);\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143632,
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-79"
    ],
    "code": "SessionStartupPref StartupBrowserCreator::GetSessionStartupPref(\n    const base::CommandLine& command_line,\n    Profile* profile) {\n  DCHECK(profile);\n  PrefService* prefs = profile->GetPrefs();\n  SessionStartupPref pref = SessionStartupPref::GetStartupPref(prefs);\n\n#if defined(OS_CHROMEOS)\n  const bool is_first_run =\n      user_manager::UserManager::Get()->IsCurrentUserNew();\n  const bool did_restart = false;\n  StartupBrowserCreator::WasRestarted();\n#else\n  const bool is_first_run = first_run::IsChromeFirstRun();\n  const bool did_restart = StartupBrowserCreator::WasRestarted();\n#endif\n\n  if (is_first_run && SessionStartupPref::TypeIsDefault(prefs))\n    pref.type = SessionStartupPref::DEFAULT;\n\n  if ((command_line.HasSwitch(switches::kRestoreLastSession) || did_restart) &&\n      !profile->IsNewProfile()) {\n    pref.type = SessionStartupPref::LAST;\n  }\n\n  if (!profile->IsGuestSession()) {\n    ProfileAttributesEntry* entry = nullptr;\n    bool has_entry =\n        g_browser_process->profile_manager()\n            ->GetProfileAttributesStorage()\n            .GetProfileAttributesWithPath(profile->GetPath(), &entry);\n\n    if (has_entry && entry->IsSigninRequired())\n       pref.type = SessionStartupPref::LAST;\n   }\n \n  if (pref.type == SessionStartupPref::LAST &&\n      IncognitoModePrefs::ShouldLaunchIncognito(command_line, prefs)) {\n    pref.type = SessionStartupPref::DEFAULT;\n  }\n\n  return pref;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143657,
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-79"
    ],
    "code": "SessionStartupPref StartupBrowserCreator::GetSessionStartupPref(\n    const base::CommandLine& command_line,\n    Profile* profile) {\n  DCHECK(profile);\n  PrefService* prefs = profile->GetPrefs();\n  SessionStartupPref pref = SessionStartupPref::GetStartupPref(prefs);\n\n#if defined(OS_CHROMEOS)\n  const bool is_first_run =\n      user_manager::UserManager::Get()->IsCurrentUserNew();\n  const bool did_restart = false;\n  StartupBrowserCreator::WasRestarted();\n#else\n  const bool is_first_run = first_run::IsChromeFirstRun();\n  const bool did_restart = StartupBrowserCreator::WasRestarted();\n#endif\n\n  if (is_first_run && SessionStartupPref::TypeIsDefault(prefs))\n    pref.type = SessionStartupPref::DEFAULT;\n\n  if ((command_line.HasSwitch(switches::kRestoreLastSession) || did_restart) &&\n      !profile->IsNewProfile()) {\n    pref.type = SessionStartupPref::LAST;\n  }\n\n  if (!profile->IsGuestSession()) {\n    ProfileAttributesEntry* entry = nullptr;\n    bool has_entry =\n        g_browser_process->profile_manager()\n            ->GetProfileAttributesStorage()\n            .GetProfileAttributesWithPath(profile->GetPath(), &entry);\n\n    if (has_entry && entry->IsSigninRequired())\n       pref.type = SessionStartupPref::LAST;\n   }\n \n  if (pref.type == SessionStartupPref::LAST && profile->IsOffTheRecord()) {\n    pref.type = SessionStartupPref::DEFAULT;\n  }\n\n  return pref;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143658,
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-79"
    ],
    "code": "static v8::Local<v8::Value> compileAndRunPrivateScript(ScriptState* scriptState,\n                                                       String scriptClassName,\n                                                       const char* source,\n                                                       size_t size) {\n  v8::Isolate* isolate = scriptState->isolate();\n  v8::TryCatch block(isolate);\n  String sourceString(source, size);\n  String fileName = scriptClassName + \".js\";\n \n   v8::Local<v8::Context> context = scriptState->context();\n   v8::Local<v8::Object> global = context->Global();\n  v8::Local<v8::Value> privateScriptController =\n      global->Get(context, v8String(isolate, \"privateScriptController\"))\n          .ToLocalChecked();\n  RELEASE_ASSERT(privateScriptController->IsUndefined() ||\n                 privateScriptController->IsObject());\n  if (privateScriptController->IsObject()) {\n     v8::Local<v8::Object> privateScriptControllerObject =\n         privateScriptController.As<v8::Object>();\n     v8::Local<v8::Value> importFunctionValue =\n        privateScriptControllerObject->Get(context, v8String(isolate, \"import\"))\n            .ToLocalChecked();\n    if (importFunctionValue->IsUndefined()) {\n      v8::Local<v8::Function> function;\n      if (!v8::FunctionTemplate::New(isolate, importFunction)\n               ->GetFunction(context)\n               .ToLocal(&function) ||\n          !v8CallBoolean(privateScriptControllerObject->Set(\n              context, v8String(isolate, \"import\"), function))) {\n        dumpV8Message(context, block.Message());\n        LOG(FATAL)\n            << \"Private script error: Setting import function failed. (Class \"\n               \"name = \"\n            << scriptClassName.utf8().data() << \")\";\n      }\n    }\n  }\n\n  v8::Local<v8::Script> script;\n  if (!v8Call(V8ScriptRunner::compileScript(\n                  v8String(isolate, sourceString), fileName, String(),\n                  TextPosition::minimumPosition(), isolate, nullptr, nullptr,\n                  nullptr, NotSharableCrossOrigin),\n              script, block)) {\n    dumpV8Message(context, block.Message());\n    LOG(FATAL) << \"Private script error: Compile failed. (Class name = \"\n               << scriptClassName.utf8().data() << \")\";\n  }\n\n  v8::Local<v8::Value> result;\n  if (!v8Call(V8ScriptRunner::runCompiledInternalScript(isolate, script),\n              result, block)) {\n    dumpV8Message(context, block.Message());\n    LOG(FATAL) << \"Private script error: installClass() failed. (Class name = \"\n               << scriptClassName.utf8().data() << \")\";\n  }\n  return result;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143663,
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-79"
    ],
    "code": "static v8::Local<v8::Value> compileAndRunPrivateScript(ScriptState* scriptState,\n                                                       String scriptClassName,\n                                                       const char* source,\n                                                       size_t size) {\n  v8::Isolate* isolate = scriptState->isolate();\n  v8::TryCatch block(isolate);\n  String sourceString(source, size);\n  String fileName = scriptClassName + \".js\";\n \n   v8::Local<v8::Context> context = scriptState->context();\n   v8::Local<v8::Object> global = context->Global();\n  v8::Local<v8::String> key = v8String(isolate, \"privateScriptController\");\n\n  if (global->HasOwnProperty(context, key).ToChecked()) {\n    v8::Local<v8::Value> privateScriptController =\n        global->Get(context, key).ToLocalChecked();\n    CHECK(privateScriptController->IsObject());\n     v8::Local<v8::Object> privateScriptControllerObject =\n         privateScriptController.As<v8::Object>();\n     v8::Local<v8::Value> importFunctionValue =\n        privateScriptControllerObject->Get(context, v8String(isolate, \"import\"))\n            .ToLocalChecked();\n    if (importFunctionValue->IsUndefined()) {\n      v8::Local<v8::Function> function;\n      if (!v8::FunctionTemplate::New(isolate, importFunction)\n               ->GetFunction(context)\n               .ToLocal(&function) ||\n          !v8CallBoolean(privateScriptControllerObject->Set(\n              context, v8String(isolate, \"import\"), function))) {\n        dumpV8Message(context, block.Message());\n        LOG(FATAL)\n            << \"Private script error: Setting import function failed. (Class \"\n               \"name = \"\n            << scriptClassName.utf8().data() << \")\";\n      }\n    }\n  }\n\n  v8::Local<v8::Script> script;\n  if (!v8Call(V8ScriptRunner::compileScript(\n                  v8String(isolate, sourceString), fileName, String(),\n                  TextPosition::minimumPosition(), isolate, nullptr, nullptr,\n                  nullptr, NotSharableCrossOrigin),\n              script, block)) {\n    dumpV8Message(context, block.Message());\n    LOG(FATAL) << \"Private script error: Compile failed. (Class name = \"\n               << scriptClassName.utf8().data() << \")\";\n  }\n\n  v8::Local<v8::Value> result;\n  if (!v8Call(V8ScriptRunner::runCompiledInternalScript(isolate, script),\n              result, block)) {\n    dumpV8Message(context, block.Message());\n    LOG(FATAL) << \"Private script error: installClass() failed. (Class name = \"\n               << scriptClassName.utf8().data() << \")\";\n  }\n  return result;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143664,
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-79"
    ],
    "code": "void XSSAuditor::Init(Document* document,\n                      XSSAuditorDelegate* auditor_delegate) {\n  DCHECK(IsMainThread());\n  if (state_ != kUninitialized)\n    return;\n  state_ = kFilteringTokens;\n\n  if (Settings* settings = document->GetSettings())\n    is_enabled_ = settings->GetXSSAuditorEnabled();\n\n  if (!is_enabled_)\n    return;\n\n  document_url_ = document->Url().Copy();\n\n  if (!document->GetFrame()) {\n    is_enabled_ = false;\n    return;\n  }\n\n  if (document_url_.IsEmpty()) {\n    is_enabled_ = false;\n    return;\n  }\n\n  if (document_url_.ProtocolIsData()) {\n    is_enabled_ = false;\n    return;\n  }\n\n  if (document->Encoding().IsValid())\n    encoding_ = document->Encoding();\n\n  if (DocumentLoader* document_loader =\n          document->GetFrame()->Loader().GetDocumentLoader()) {\n    const AtomicString& header_value =\n        document_loader->GetResponse().HttpHeaderField(\n            HTTPNames::X_XSS_Protection);\n    String error_details;\n    unsigned error_position = 0;\n    String report_url;\n    KURL xss_protection_report_url;\n\n    ReflectedXSSDisposition xss_protection_header = ParseXSSProtectionHeader(\n        header_value, error_details, error_position, report_url);\n\n    if (xss_protection_header == kAllowReflectedXSS)\n      UseCounter::Count(*document, WebFeature::kXSSAuditorDisabled);\n    else if (xss_protection_header == kFilterReflectedXSS)\n      UseCounter::Count(*document, WebFeature::kXSSAuditorEnabledFilter);\n    else if (xss_protection_header == kBlockReflectedXSS)\n      UseCounter::Count(*document, WebFeature::kXSSAuditorEnabledBlock);\n    else if (xss_protection_header == kReflectedXSSInvalid)\n      UseCounter::Count(*document, WebFeature::kXSSAuditorInvalid);\n\n    did_send_valid_xss_protection_header_ =\n        xss_protection_header != kReflectedXSSUnset &&\n        xss_protection_header != kReflectedXSSInvalid;\n    if ((xss_protection_header == kFilterReflectedXSS ||\n          xss_protection_header == kBlockReflectedXSS) &&\n         !report_url.IsEmpty()) {\n       xss_protection_report_url = document->CompleteURL(report_url);\n       if (MixedContentChecker::IsMixedContent(document->GetSecurityOrigin(),\n                                               xss_protection_report_url)) {\n         error_details = \"insecure reporting URL for secure page\";\n        xss_protection_header = kReflectedXSSInvalid;\n        xss_protection_report_url = KURL();\n      }\n    }\n    if (xss_protection_header == kReflectedXSSInvalid) {\n      document->AddConsoleMessage(ConsoleMessage::Create(\n          kSecurityMessageSource, kErrorMessageLevel,\n          \"Error parsing header X-XSS-Protection: \" + header_value + \": \" +\n              error_details + \" at character position \" +\n              String::Format(\"%u\", error_position) +\n              \". The default protections will be applied.\"));\n    }\n\n    xss_protection_ = xss_protection_header;\n    if (xss_protection_ == kReflectedXSSInvalid ||\n        xss_protection_ == kReflectedXSSUnset) {\n      xss_protection_ = kBlockReflectedXSS;\n    }\n\n    if (auditor_delegate)\n      auditor_delegate->SetReportURL(xss_protection_report_url.Copy());\n\n    EncodedFormData* http_body = document_loader->GetRequest().HttpBody();\n    if (http_body && !http_body->IsEmpty())\n      http_body_as_string_ = http_body->FlattenToString();\n  }\n\n  SetEncoding(encoding_);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143713,
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-79"
    ],
    "code": "void XSSAuditor::Init(Document* document,\n                      XSSAuditorDelegate* auditor_delegate) {\n  DCHECK(IsMainThread());\n  if (state_ != kUninitialized)\n    return;\n  state_ = kFilteringTokens;\n\n  if (Settings* settings = document->GetSettings())\n    is_enabled_ = settings->GetXSSAuditorEnabled();\n\n  if (!is_enabled_)\n    return;\n\n  document_url_ = document->Url().Copy();\n\n  if (!document->GetFrame()) {\n    is_enabled_ = false;\n    return;\n  }\n\n  if (document_url_.IsEmpty()) {\n    is_enabled_ = false;\n    return;\n  }\n\n  if (document_url_.ProtocolIsData()) {\n    is_enabled_ = false;\n    return;\n  }\n\n  if (document->Encoding().IsValid())\n    encoding_ = document->Encoding();\n\n  if (DocumentLoader* document_loader =\n          document->GetFrame()->Loader().GetDocumentLoader()) {\n    const AtomicString& header_value =\n        document_loader->GetResponse().HttpHeaderField(\n            HTTPNames::X_XSS_Protection);\n    String error_details;\n    unsigned error_position = 0;\n    String report_url;\n    KURL xss_protection_report_url;\n\n    ReflectedXSSDisposition xss_protection_header = ParseXSSProtectionHeader(\n        header_value, error_details, error_position, report_url);\n\n    if (xss_protection_header == kAllowReflectedXSS)\n      UseCounter::Count(*document, WebFeature::kXSSAuditorDisabled);\n    else if (xss_protection_header == kFilterReflectedXSS)\n      UseCounter::Count(*document, WebFeature::kXSSAuditorEnabledFilter);\n    else if (xss_protection_header == kBlockReflectedXSS)\n      UseCounter::Count(*document, WebFeature::kXSSAuditorEnabledBlock);\n    else if (xss_protection_header == kReflectedXSSInvalid)\n      UseCounter::Count(*document, WebFeature::kXSSAuditorInvalid);\n\n    did_send_valid_xss_protection_header_ =\n        xss_protection_header != kReflectedXSSUnset &&\n        xss_protection_header != kReflectedXSSInvalid;\n    if ((xss_protection_header == kFilterReflectedXSS ||\n          xss_protection_header == kBlockReflectedXSS) &&\n         !report_url.IsEmpty()) {\n       xss_protection_report_url = document->CompleteURL(report_url);\n      if (!SecurityOrigin::Create(xss_protection_report_url)\n               ->IsSameSchemeHostPort(document->GetSecurityOrigin())) {\n        error_details =\n            \"reporting URL is not same scheme, host, and port as page\";\n        xss_protection_header = kReflectedXSSInvalid;\n        xss_protection_report_url = KURL();\n      }\n       if (MixedContentChecker::IsMixedContent(document->GetSecurityOrigin(),\n                                               xss_protection_report_url)) {\n         error_details = \"insecure reporting URL for secure page\";\n        xss_protection_header = kReflectedXSSInvalid;\n        xss_protection_report_url = KURL();\n      }\n    }\n    if (xss_protection_header == kReflectedXSSInvalid) {\n      document->AddConsoleMessage(ConsoleMessage::Create(\n          kSecurityMessageSource, kErrorMessageLevel,\n          \"Error parsing header X-XSS-Protection: \" + header_value + \": \" +\n              error_details + \" at character position \" +\n              String::Format(\"%u\", error_position) +\n              \". The default protections will be applied.\"));\n    }\n\n    xss_protection_ = xss_protection_header;\n    if (xss_protection_ == kReflectedXSSInvalid ||\n        xss_protection_ == kReflectedXSSUnset) {\n      xss_protection_ = kBlockReflectedXSS;\n    }\n\n    if (auditor_delegate)\n      auditor_delegate->SetReportURL(xss_protection_report_url.Copy());\n\n    EncodedFormData* http_body = document_loader->GetRequest().HttpBody();\n    if (http_body && !http_body->IsEmpty())\n      http_body_as_string_ = http_body->FlattenToString();\n  }\n\n  SetEncoding(encoding_);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143714,
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-79"
    ],
    "code": "bool VaapiJpegDecoder::Initialize(const base::RepeatingClosure& error_uma_cb) {\n  vaapi_wrapper_ = VaapiWrapper::Create(VaapiWrapper::kDecode,\n                                        VAProfileJPEGBaseline, error_uma_cb);\n  if (!vaapi_wrapper_) {\n    VLOGF(1) << \"Failed initializing VAAPI\";\n    return false;\n  }\n  return true;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143735,
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-79"
    ],
    "code": "bool VaapiJpegDecoder::Initialize(const base::RepeatingClosure& error_uma_cb) {\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143736,
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-79"
    ],
    "code": "void DoCanonicalizeRef(const CHAR* spec,\n                       const Component& ref,\n                       CanonOutput* output,\n                       Component* out_ref) {\n  if (ref.len < 0) {\n    *out_ref = Component();\n    return;\n  }\n\n  output->push_back('#');\n  out_ref->begin = output->length();\n\n  int end = ref.end();\n  for (int i = ref.begin; i < end; i++) {\n    if (spec[i] == 0) {\n      continue;\n    } else if (static_cast<UCHAR>(spec[i]) < 0x20) {\n      AppendEscapedChar(static_cast<unsigned char>(spec[i]), output);\n    } else if (static_cast<UCHAR>(spec[i]) < 0x80) {\n       output->push_back(static_cast<char>(spec[i]));\n     } else {\n      unsigned code_point;\n      ReadUTFChar(spec, &i, end, &code_point);\n      AppendUTF8Value(code_point, output);\n     }\n   }\n \n  out_ref->len = output->length() - out_ref->begin;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143737,
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-79"
    ],
    "code": "void DoCanonicalizeRef(const CHAR* spec,\n                       const Component& ref,\n                       CanonOutput* output,\n                       Component* out_ref) {\n  if (ref.len < 0) {\n    *out_ref = Component();\n    return;\n  }\n\n  output->push_back('#');\n  out_ref->begin = output->length();\n\n  int end = ref.end();\n  for (int i = ref.begin; i < end; i++) {\n    if (spec[i] == 0) {\n      continue;\n    } else if (static_cast<UCHAR>(spec[i]) < 0x20) {\n      AppendEscapedChar(static_cast<unsigned char>(spec[i]), output);\n    } else if (static_cast<UCHAR>(spec[i]) < 0x80) {\n       output->push_back(static_cast<char>(spec[i]));\n     } else {\n      AppendUTF8EscapedChar(spec, &i, end, output);\n     }\n   }\n \n  out_ref->len = output->length() - out_ref->begin;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143738,
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-79"
    ],
    "code": "int OmniboxViewViews::OnDrop(const ui::OSExchangeData& data) {\n  if (HasTextBeingDragged())\n    return ui::DragDropTypes::DRAG_NONE;\n\n  if (data.HasURL(ui::OSExchangeData::CONVERT_FILENAMES)) {\n    GURL url;\n    base::string16 title;\n    if (data.GetURLAndTitle(\n            ui::OSExchangeData::CONVERT_FILENAMES, &url, &title)) {\n      base::string16 text(\n          StripJavascriptSchemas(base::UTF8ToUTF16(url.spec())));\n      if (model()->CanPasteAndGo(text)) {\n        model()->PasteAndGo(text);\n        return ui::DragDropTypes::DRAG_COPY;\n      }\n    }\n   } else if (data.HasString()) {\n     base::string16 text;\n     if (data.GetString(&text)) {\n      base::string16 collapsed_text(base::CollapseWhitespace(text, true));\n       if (model()->CanPasteAndGo(collapsed_text))\n         model()->PasteAndGo(collapsed_text);\n       return ui::DragDropTypes::DRAG_COPY;\n    }\n  }\n\n  return ui::DragDropTypes::DRAG_NONE;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143745,
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-79"
    ],
    "code": "int OmniboxViewViews::OnDrop(const ui::OSExchangeData& data) {\n  if (HasTextBeingDragged())\n    return ui::DragDropTypes::DRAG_NONE;\n\n  if (data.HasURL(ui::OSExchangeData::CONVERT_FILENAMES)) {\n    GURL url;\n    base::string16 title;\n    if (data.GetURLAndTitle(\n            ui::OSExchangeData::CONVERT_FILENAMES, &url, &title)) {\n      base::string16 text(\n          StripJavascriptSchemas(base::UTF8ToUTF16(url.spec())));\n      if (model()->CanPasteAndGo(text)) {\n        model()->PasteAndGo(text);\n        return ui::DragDropTypes::DRAG_COPY;\n      }\n    }\n   } else if (data.HasString()) {\n     base::string16 text;\n     if (data.GetString(&text)) {\n      base::string16 collapsed_text(\n          StripJavascriptSchemas(base::CollapseWhitespace(text, true)));\n       if (model()->CanPasteAndGo(collapsed_text))\n         model()->PasteAndGo(collapsed_text);\n       return ui::DragDropTypes::DRAG_COPY;\n    }\n  }\n\n  return ui::DragDropTypes::DRAG_NONE;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143746,
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-79"
    ],
    "code": "void PaintLayerScrollableArea::UpdateCompositingLayersAfterScroll() {\n  PaintLayerCompositor* compositor = GetLayoutBox()->View()->Compositor();\n  if (!compositor->InCompositingMode())\n    return;\n\n  if (UsesCompositedScrolling()) {\n     DCHECK(Layer()->HasCompositedLayerMapping());\n     ScrollingCoordinator* scrolling_coordinator = GetScrollingCoordinator();\n     bool handled_scroll =\n        Layer()->IsRootLayer() && scrolling_coordinator &&\n         scrolling_coordinator->UpdateCompositedScrollOffset(this);\n \n     if (!handled_scroll) {\n      if (!RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled()) {\n        Layer()->GetCompositedLayerMapping()->SetNeedsGraphicsLayerUpdate(\n            kGraphicsLayerUpdateSubtree);\n      }\n      compositor->SetNeedsCompositingUpdate(\n          kCompositingUpdateAfterGeometryChange);\n    }\n\n    if (Layer()->IsRootLayer()) {\n      LocalFrame* frame = GetLayoutBox()->GetFrame();\n      if (frame && frame->View() &&\n          frame->View()->HasViewportConstrainedObjects()) {\n        Layer()->SetNeedsCompositingInputsUpdate();\n      }\n    }\n  } else {\n    Layer()->SetNeedsCompositingInputsUpdate();\n  }\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144231,
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-79"
    ],
    "code": "void PaintLayerScrollableArea::UpdateCompositingLayersAfterScroll() {\n  PaintLayerCompositor* compositor = GetLayoutBox()->View()->Compositor();\n  if (!compositor->InCompositingMode())\n    return;\n\n  if (UsesCompositedScrolling()) {\n     DCHECK(Layer()->HasCompositedLayerMapping());\n     ScrollingCoordinator* scrolling_coordinator = GetScrollingCoordinator();\n     bool handled_scroll =\n        (Layer()->IsRootLayer() ||\n         RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled()) &&\n        scrolling_coordinator &&\n         scrolling_coordinator->UpdateCompositedScrollOffset(this);\n \n     if (!handled_scroll) {\n      if (!RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled()) {\n        Layer()->GetCompositedLayerMapping()->SetNeedsGraphicsLayerUpdate(\n            kGraphicsLayerUpdateSubtree);\n      }\n      compositor->SetNeedsCompositingUpdate(\n          kCompositingUpdateAfterGeometryChange);\n    }\n\n    if (Layer()->IsRootLayer()) {\n      LocalFrame* frame = GetLayoutBox()->GetFrame();\n      if (frame && frame->View() &&\n          frame->View()->HasViewportConstrainedObjects()) {\n        Layer()->SetNeedsCompositingInputsUpdate();\n      }\n    }\n  } else {\n    Layer()->SetNeedsCompositingInputsUpdate();\n  }\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144232,
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-79"
    ],
    "code": " std::string GetUploadData(const std::string& brand) {\n   DCHECK(!brand.empty());\n  std::string data(kPostXml);\n  const std::string placeholder(\"__BRANDCODE_PLACEHOLDER__\");\n  size_t placeholder_pos = data.find(placeholder);\n  DCHECK(placeholder_pos != std::string::npos);\n  data.replace(placeholder_pos, placeholder.size(), brand);\n  return data;\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144233,
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-79"
    ],
    "code": " std::string GetUploadData(const std::string& brand) {\n  std::string app_id(kDefaultAppID);\n#if defined(OS_WIN)\n  app_id = install_static::UTF16ToUTF8(install_static::GetAppGuid());\n#endif  // defined(OS_WIN)\n   DCHECK(!brand.empty());\n  return base::StringPrintf(kPostXml, app_id.c_str(), brand.c_str());\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144234,
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-79"
    ],
    "code": "bool WddxPacket::recursiveAddVar(const String& varName,\n                                 const Variant& varVariant,\n                                 bool hasVarTag) {\n\n  bool isArray = varVariant.isArray();\n  bool isObject = varVariant.isObject();\n\n  if (isArray || isObject) {\n    if (hasVarTag) {\n      m_packetString += \"<var name='\";\n      m_packetString += varName.data();\n      m_packetString += \"'>\";\n    }\n\n    Array varAsArray;\n    Object varAsObject = varVariant.toObject();\n    if (isArray) varAsArray = varVariant.toArray();\n    if (isObject) varAsArray = varAsObject.toArray();\n\n    int length = varAsArray.length();\n    if (length > 0) {\n      ArrayIter it = ArrayIter(varAsArray);\n      if (it.first().isString()) isObject = true;\n      if (isObject) {\n        m_packetString += \"<struct>\";\n        if (!isArray) {\n          m_packetString += \"<var name='php_class_name'><string>\";\n          m_packetString += varAsObject->o_getClassName().c_str();\n          m_packetString += \"</string></var>\";\n        }\n      } else {\n        m_packetString += \"<array length='\";\n        m_packetString += std::to_string(length);\n        m_packetString += \"'>\";\n      }\n      for (ArrayIter it(varAsArray); it; ++it) {\n        Variant key = it.first();\n        Variant value = it.second();\n        recursiveAddVar(key.toString(), value, isObject);\n      }\n      if (isObject) {\n        m_packetString += \"</struct>\";\n      }\n      else {\n        m_packetString += \"</array>\";\n      }\n    }\n    else {\n      //empty object\n      if (isObject) {\n        m_packetString += \"<struct>\";\n        if (!isArray) {\n          m_packetString += \"<var name='php_class_name'><string>\";\n          m_packetString += varAsObject->o_getClassName().c_str();\n          m_packetString += \"</string></var>\";\n        }\n        m_packetString += \"</struct>\";\n      }\n    }\n    if (hasVarTag) {\n      m_packetString += \"</var>\";\n    }\n    return true;\n  }\n\n  std::string varType = getDataTypeString(varVariant.getType()).data();\n  if (!getWddxEncoded(varType, \"\", varName, false).empty()) {\n    std::string varValue = varVariant.toString().data();\n    if (varType.compare(\"boolean\") == 0) {\n      varValue = varVariant.toBoolean() ? \"true\" : \"false\";\n    }\n    m_packetString += getWddxEncoded(varType, varValue, varName, hasVarTag);\n    return true;\n  }\n\n  return false;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144761,
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-79"
    ],
    "code": "bool WddxPacket::recursiveAddVar(const String& varName,\n                                 const Variant& varVariant,\n                                 bool hasVarTag) {\n\n  bool isArray = varVariant.isArray();\n  bool isObject = varVariant.isObject();\n\n  if (isArray || isObject) {\n    if (hasVarTag) {\n      m_packetString += \"<var name='\";\n      m_packetString += varName.data();\n      m_packetString += \"'>\";\n    }\n\n    Array varAsArray;\n    Object varAsObject = varVariant.toObject();\n    if (isArray) varAsArray = varVariant.toArray();\n    if (isObject) varAsArray = varAsObject.toArray();\n\n    int length = varAsArray.length();\n    if (length > 0) {\n      ArrayIter it = ArrayIter(varAsArray);\n      if (it.first().isString()) isObject = true;\n      if (isObject) {\n        m_packetString += \"<struct>\";\n        if (!isArray) {\n          m_packetString += \"<var name='php_class_name'><string>\";\n          m_packetString += varAsObject->o_getClassName().c_str();\n          m_packetString += \"</string></var>\";\n        }\n      } else {\n        m_packetString += \"<array length='\";\n        m_packetString += std::to_string(length);\n        m_packetString += \"'>\";\n      }\n      for (ArrayIter it(varAsArray); it; ++it) {\n        Variant key = it.first();\n        Variant value = it.second();\n        recursiveAddVar(key.toString(), value, isObject);\n      }\n      if (isObject) {\n        m_packetString += \"</struct>\";\n      }\n      else {\n        m_packetString += \"</array>\";\n      }\n    }\n    else {\n      //empty object\n      if (isObject) {\n        m_packetString += \"<struct>\";\n        if (!isArray) {\n          m_packetString += \"<var name='php_class_name'><string>\";\n          m_packetString += varAsObject->o_getClassName().c_str();\n          m_packetString += \"</string></var>\";\n        }\n        m_packetString += \"</struct>\";\n      }\n    }\n    if (hasVarTag) {\n      m_packetString += \"</var>\";\n    }\n    return true;\n  }\n\n  std::string varType = getDataTypeString(varVariant.getType()).data();\n  if (!getWddxEncoded(varType, \"\", varName, false).empty()) {\n    std::string varValue;\n    if (varType.compare(\"boolean\") == 0) {\n      varValue = varVariant.toBoolean() ? \"true\" : \"false\";\n    } else {\n      varValue = StringUtil::HtmlEncode(varVariant.toString(),\n                                        StringUtil::QuoteStyle::Double,\n                                        \"UTF-8\", false, false).toCppString();\n    }\n    m_packetString += getWddxEncoded(varType, varValue, varName, hasVarTag);\n    return true;\n  }\n\n  return false;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144762,
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-79"
    ],
    "code": "static inline zend_string* phar_get_stub(const char *index_php, const char *web, const int name_len, const int web_len)\n{\n\tstatic const char newstub0[] = \"<?php\\n\\n$web = '\";\n\tstatic const char newstub1_0[] = \"';\\n\\nif (in_array('phar', stream_get_wrappers()) && class_exists('Phar', 0)) {\\nPhar::interceptFileFuncs();\\nset_include_path('phar://' . __FILE__ . PATH_SEPARATOR . get_include_path());\\nPhar::webPhar(null, $web);\\ninclude 'phar://' . __FILE__ . '/' . Extract_Phar::START;\\nreturn;\\n}\\n\\nif (@(isset($_SERVER['REQUEST_URI']) && isset($_SERVER['REQUEST_METHOD']) && ($_SERVER['REQUEST_METHOD'] == 'GET' || $_SERVER['REQUEST_METHOD'] == 'POST'))) {\\nExtract_Phar::go(true);\\n$mimes = array(\\n'phps' => 2,\\n'c' => 'text/plain',\\n'cc' => 'text/plain',\\n'cpp' => 'text/plain',\\n'c++' => 'text/plain',\\n'dtd' => 'text/plain',\\n'h' => 'text/plain',\\n'log' => 'text/plain',\\n'rng' => 'text/plain',\\n'txt' => 'text/plain',\\n'xsd' => 'text/plain',\\n'php' => 1,\\n'inc' => 1,\\n'avi' => 'video/avi',\\n'bmp' => 'image/bmp',\\n'css' => 'text/css',\\n'gif' => 'image/gif',\\n'htm' => 'text/html',\\n'html' => 'text/html',\\n'htmls' => 'text/html',\\n'ico' => 'image/x-ico',\\n'jpe' => 'image/jpeg',\\n'jpg' => 'image/jpeg',\\n'jpeg' => 'image/jpeg',\\n'js' => 'application/x-javascript',\\n'midi' => 'audio/midi',\\n'mid' => 'audio/midi',\\n'mod' => 'audio/mod',\\n'mov' => 'movie/quicktime',\\n'mp3' => 'audio/mp3',\\n'mpg' => 'video/mpeg',\\n'mpeg' => 'video/mpeg',\\n'pdf' => 'application/pdf',\\n'png' => 'image/png',\\n'swf' => 'application/shockwave-flash',\\n'tif' => 'image/tiff',\\n'tiff' => 'image/tiff',\\n'wav' => 'audio/wav',\\n'xbm' => 'image/xbm',\\n'xml' => 'text/xml',\\n);\\n\\nheader(\\\"Cache-Control: no-cache, must-revalidate\\\");\\nheader(\\\"Pragma: no-cache\\\");\\n\\n$basename = basename(__FILE__);\\nif (!strpos($_SERVER['REQUEST_URI'], $basename)) {\\nchdir(Extract_Phar::$temp);\\ninclude $web;\\nreturn;\\n}\\n$pt = substr($_SERVER['REQUEST_URI'], strpos($_SERVER['REQUEST_URI'], $basename) + strlen($basename));\\nif (!$pt || $pt == '/') {\\n$pt = $web;\\nheader('HTTP/1.1 301 Moved Permanently');\\nheader('Location: ' . $_SERVER['REQUEST_URI'] . '/' . $pt);\\nexit;\\n}\\n$a = realpath(Extract_Phar::$temp . DIRECTORY_SEPARATOR . $pt);\\nif (!$a || strlen(dirname($a)) < strlen(\";\n\tstatic const char newstub1_1[] = \"Extract_Phar::$temp)) {\\nheader('HTTP/1.0 404 Not Found');\\necho \\\"<html>\\\\n <head>\\\\n  <title>File Not Found<title>\\\\n </head>\\\\n <body>\\\\n  <h1>404 - File \\\", $pt, \\\" Not Found</h1>\\\\n </body>\\\\n</html>\\\";\\nexit;\\n}\\n$b = pathinfo($a);\\nif (!isset($b['extension'])) {\\nheader('Content-Type: text/plain');\\nheader('Content-Length: ' . filesize($a));\\nreadfile($a);\\nexit;\\n}\\nif (isset($mimes[$b['extension']])) {\\nif ($mimes[$b['extension']] === 1) {\\ninclude $a;\\nexit;\\n}\\nif ($mimes[$b['extension']] === 2) {\\nhighlight_file($a);\\nexit;\\n}\\nheader('Content-Type: ' .$mimes[$b['extension']]);\\nheader('Content-Length: ' . filesize($a));\\nreadfile($a);\\nexit;\\n}\\n}\\n\\nclass Extract_Phar\\n{\\nstatic $temp;\\nstatic $origdir;\\nconst GZ = 0x1000;\\nconst BZ2 = 0x2000;\\nconst MASK = 0x3000;\\nconst START = '\";\n\tstatic const char newstub2[] = \"';\\nconst LEN = \";\n\tstatic const char newstub3_0[] = \";\\n\\nstatic function go($return = false)\\n{\\n$fp = fopen(__FILE__, 'rb');\\nfseek($fp, self::LEN);\\n$L = unpack('V', $a = fread($fp, 4));\\n$m = '';\\n\\ndo {\\n$read = 8192;\\nif ($L[1] - strlen($m) < 8192) {\\n$read = $L[1] - strlen($m);\\n}\\n$last = fread($fp, $read);\\n$m .= $last;\\n} while (strlen($last) && strlen($m) < $L[1]);\\n\\nif (strlen($m) < $L[1]) {\\ndie('ERROR: manifest length read was \\\"' .\\nstrlen($m) .'\\\" should be \\\"' .\\n$L[1] . '\\\"');\\n}\\n\\n$info = self::_unpack($m);\\n$f = $info['c'];\\n\\nif ($f & self::GZ) {\\nif (!function_exists('gzinflate')) {\\ndie('Error: zlib extension is not enabled -' .\\n' gzinflate() function needed for zlib-compressed .phars');\\n}\\n}\\n\\nif ($f & self::BZ2) {\\nif (!function_exists('bzdecompress')) {\\ndie('Error: bzip2 extension is not enabled -' .\\n' bzdecompress() function needed for bz2-compressed .phars');\\n}\\n}\\n\\n$temp = self::tmpdir();\\n\\nif (!$temp || !is_writable($temp)) {\\n$sessionpath = session_save_path();\\nif (strpos ($sessionpath, \\\";\\\") !== false)\\n$sessionpath = substr ($sessionpath, strpos ($sessionpath, \\\";\\\")+1);\\nif (!file_exists($sessionpath) || !is_dir($sessionpath)) {\\ndie('Could not locate temporary directory to extract phar');\\n}\\n$temp = $sessionpath;\\n}\\n\\n$temp .= '/pharextract/'.basename(__FILE__, '.phar');\\nself::$temp = $temp;\\nself::$origdir = getcwd();\\n@mkdir($temp, 0777, true);\\n$temp = realpath($temp);\\n\\nif (!file_exists($temp . DIRECTORY_SEPARATOR . md5_file(__FILE__))) {\\nself::_removeTmpFiles($temp, getcwd());\\n@mkdir($temp, 0777, true);\\n@file_put_contents($temp . '/' . md5_file(__FILE__), '');\\n\\nforeach ($info['m'] as $path => $file) {\\n$a = !file_exists(dirname($temp . '/' . $path));\\n@mkdir(dirname($temp . '/' . $path), 0777, true);\\nclearstatcache();\\n\\nif ($path[strlen($path) - 1] == '/') {\\n@mkdir($temp . '/' . $path, 0777);\\n} else {\\nfile_put_contents($temp . '/' . $path, self::extractFile($path, $file, $fp));\\n@chmod($temp . '/' . $path, 0666);\\n}\\n}\\n}\\n\\nchdir($temp);\\n\\nif (!$return) {\\ninclude self::START;\\n}\\n}\\n\\nstatic fun\";\n\tstatic const char newstub3_1[] = \"ction tmpdir()\\n{\\nif (strpos(PHP_OS, 'WIN') !== false) {\\nif ($var = getenv('TMP') ? getenv('TMP') : getenv('TEMP')) {\\nreturn $var;\\n}\\nif (is_dir('/temp') || mkdir('/temp')) {\\nreturn realpath('/temp');\\n}\\nreturn false;\\n}\\nif ($var = getenv('TMPDIR')) {\\nreturn $var;\\n}\\nreturn realpath('/tmp');\\n}\\n\\nstatic function _unpack($m)\\n{\\n$info = unpack('V', substr($m, 0, 4));\\n $l = unpack('V', substr($m, 10, 4));\\n$m = substr($m, 14 + $l[1]);\\n$s = unpack('V', substr($m, 0, 4));\\n$o = 0;\\n$start = 4 + $s[1];\\n$ret['c'] = 0;\\n\\nfor ($i = 0; $i < $info[1]; $i++) {\\n $len = unpack('V', substr($m, $start, 4));\\n$start += 4;\\n $savepath = substr($m, $start, $len[1]);\\n$start += $len[1];\\n   $ret['m'][$savepath] = array_values(unpack('Va/Vb/Vc/Vd/Ve/Vf', substr($m, $start, 24)));\\n$ret['m'][$savepath][3] = sprintf('%u', $ret['m'][$savepath][3]\\n& 0xffffffff);\\n$ret['m'][$savepath][7] = $o;\\n$o += $ret['m'][$savepath][2];\\n$start += 24 + $ret['m'][$savepath][5];\\n$ret['c'] |= $ret['m'][$savepath][4] & self::MASK;\\n}\\nreturn $ret;\\n}\\n\\nstatic function extractFile($path, $entry, $fp)\\n{\\n$data = '';\\n$c = $entry[2];\\n\\nwhile ($c) {\\nif ($c < 8192) {\\n$data .= @fread($fp, $c);\\n$c = 0;\\n} else {\\n$c -= 8192;\\n$data .= @fread($fp, 8192);\\n}\\n}\\n\\nif ($entry[4] & self::GZ) {\\n$data = gzinflate($data);\\n} elseif ($entry[4] & self::BZ2) {\\n$data = bzdecompress($data);\\n}\\n\\nif (strlen($data) != $entry[0]) {\\ndie(\\\"Invalid internal .phar file (size error \\\" . strlen($data) . \\\" != \\\" .\\n$stat[7] . \\\")\\\");\\n}\\n\\nif ($entry[3] != sprintf(\\\"%u\\\", crc32($data) & 0xffffffff)) {\\ndie(\\\"Invalid internal .phar file (checksum error)\\\");\\n}\\n\\nreturn $data;\\n}\\n\\nstatic function _removeTmpFiles($temp, $origdir)\\n{\\nchdir($temp);\\n\\nforeach (glob('*') as $f) {\\nif (file_exists($f)) {\\nis_dir($f) ? @rmdir($f) : @unlink($f);\\nif (file_exists($f) && is_dir($f)) {\\nself::_removeTmpFiles($f, getcwd());\\n}\\n}\\n}\\n\\n@rmdir($temp);\\nclearstatcache();\\nchdir($origdir);\\n}\\n}\\n\\nExtract_Phar::go();\\n__HALT_COMPILER(); ?>\";\n\n\tstatic const int newstub_len = 6633;\n\n\treturn strpprintf(name_len + web_len + newstub_len, \"%s%s%s%s%s%s%d%s%s\", newstub0, web, newstub1_0, newstub1_1, index_php, newstub2, name_len + web_len + newstub_len, newstub3_0, newstub3_1);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145838,
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-79"
    ],
    "code": "static inline zend_string* phar_get_stub(const char *index_php, const char *web, const int name_len, const int web_len)\n{\n\tstatic const char newstub0[] = \"<?php\\n\\n$web = '\";\n\tstatic const char newstub1_0[] = \"';\\n\\nif (in_array('phar', stream_get_wrappers()) && class_exists('Phar', 0)) {\\nPhar::interceptFileFuncs();\\nset_include_path('phar://' . __FILE__ . PATH_SEPARATOR . get_include_path());\\nPhar::webPhar(null, $web);\\ninclude 'phar://' . __FILE__ . '/' . Extract_Phar::START;\\nreturn;\\n}\\n\\nif (@(isset($_SERVER['REQUEST_URI']) && isset($_SERVER['REQUEST_METHOD']) && ($_SERVER['REQUEST_METHOD'] == 'GET' || $_SERVER['REQUEST_METHOD'] == 'POST'))) {\\nExtract_Phar::go(true);\\n$mimes = array(\\n'phps' => 2,\\n'c' => 'text/plain',\\n'cc' => 'text/plain',\\n'cpp' => 'text/plain',\\n'c++' => 'text/plain',\\n'dtd' => 'text/plain',\\n'h' => 'text/plain',\\n'log' => 'text/plain',\\n'rng' => 'text/plain',\\n'txt' => 'text/plain',\\n'xsd' => 'text/plain',\\n'php' => 1,\\n'inc' => 1,\\n'avi' => 'video/avi',\\n'bmp' => 'image/bmp',\\n'css' => 'text/css',\\n'gif' => 'image/gif',\\n'htm' => 'text/html',\\n'html' => 'text/html',\\n'htmls' => 'text/html',\\n'ico' => 'image/x-ico',\\n'jpe' => 'image/jpeg',\\n'jpg' => 'image/jpeg',\\n'jpeg' => 'image/jpeg',\\n'js' => 'application/x-javascript',\\n'midi' => 'audio/midi',\\n'mid' => 'audio/midi',\\n'mod' => 'audio/mod',\\n'mov' => 'movie/quicktime',\\n'mp3' => 'audio/mp3',\\n'mpg' => 'video/mpeg',\\n'mpeg' => 'video/mpeg',\\n'pdf' => 'application/pdf',\\n'png' => 'image/png',\\n'swf' => 'application/shockwave-flash',\\n'tif' => 'image/tiff',\\n'tiff' => 'image/tiff',\\n'wav' => 'audio/wav',\\n'xbm' => 'image/xbm',\\n'xml' => 'text/xml',\\n);\\n\\nheader(\\\"Cache-Control: no-cache, must-revalidate\\\");\\nheader(\\\"Pragma: no-cache\\\");\\n\\n$basename = basename(__FILE__);\\nif (!strpos($_SERVER['REQUEST_URI'], $basename)) {\\nchdir(Extract_Phar::$temp);\\ninclude $web;\\nreturn;\\n}\\n$pt = substr($_SERVER['REQUEST_URI'], strpos($_SERVER['REQUEST_URI'], $basename) + strlen($basename));\\nif (!$pt || $pt == '/') {\\n$pt = $web;\\nheader('HTTP/1.1 301 Moved Permanently');\\nheader('Location: ' . $_SERVER['REQUEST_URI'] . '/' . $pt);\\nexit;\\n}\\n$a = realpath(Extract_Phar::$temp . DIRECTORY_SEPARATOR . $pt);\\nif (!$a || strlen(dirname($a)) < strlen(\";\n\tstatic const char newstub1_1[] = \"Extract_Phar::$temp)) {\\nheader('HTTP/1.0 404 Not Found');\\necho \\\"<html>\\\\n <head>\\\\n  <title>File Not Found<title>\\\\n </head>\\\\n <body>\\\\n  <h1>404 - File Not Found</h1>\\\\n </body>\\\\n</html>\\\";\\nexit;\\n}\\n$b = pathinfo($a);\\nif (!isset($b['extension'])) {\\nheader('Content-Type: text/plain');\\nheader('Content-Length: ' . filesize($a));\\nreadfile($a);\\nexit;\\n}\\nif (isset($mimes[$b['extension']])) {\\nif ($mimes[$b['extension']] === 1) {\\ninclude $a;\\nexit;\\n}\\nif ($mimes[$b['extension']] === 2) {\\nhighlight_file($a);\\nexit;\\n}\\nheader('Content-Type: ' .$mimes[$b['extension']]);\\nheader('Content-Length: ' . filesize($a));\\nreadfile($a);\\nexit;\\n}\\n}\\n\\nclass Extract_Phar\\n{\\nstatic $temp;\\nstatic $origdir;\\nconst GZ = 0x1000;\\nconst BZ2 = 0x2000;\\nconst MASK = 0x3000;\\nconst START = '\";\n\tstatic const char newstub2[] = \"';\\nconst LEN = \";\n\tstatic const char newstub3_0[] = \";\\n\\nstatic function go($return = false)\\n{\\n$fp = fopen(__FILE__, 'rb');\\nfseek($fp, self::LEN);\\n$L = unpack('V', $a = fread($fp, 4));\\n$m = '';\\n\\ndo {\\n$read = 8192;\\nif ($L[1] - strlen($m) < 8192) {\\n$read = $L[1] - strlen($m);\\n}\\n$last = fread($fp, $read);\\n$m .= $last;\\n} while (strlen($last) && strlen($m) < $L[1]);\\n\\nif (strlen($m) < $L[1]) {\\ndie('ERROR: manifest length read was \\\"' .\\nstrlen($m) .'\\\" should be \\\"' .\\n$L[1] . '\\\"');\\n}\\n\\n$info = self::_unpack($m);\\n$f = $info['c'];\\n\\nif ($f & self::GZ) {\\nif (!function_exists('gzinflate')) {\\ndie('Error: zlib extension is not enabled -' .\\n' gzinflate() function needed for zlib-compressed .phars');\\n}\\n}\\n\\nif ($f & self::BZ2) {\\nif (!function_exists('bzdecompress')) {\\ndie('Error: bzip2 extension is not enabled -' .\\n' bzdecompress() function needed for bz2-compressed .phars');\\n}\\n}\\n\\n$temp = self::tmpdir();\\n\\nif (!$temp || !is_writable($temp)) {\\n$sessionpath = session_save_path();\\nif (strpos ($sessionpath, \\\";\\\") !== false)\\n$sessionpath = substr ($sessionpath, strpos ($sessionpath, \\\";\\\")+1);\\nif (!file_exists($sessionpath) || !is_dir($sessionpath)) {\\ndie('Could not locate temporary directory to extract phar');\\n}\\n$temp = $sessionpath;\\n}\\n\\n$temp .= '/pharextract/'.basename(__FILE__, '.phar');\\nself::$temp = $temp;\\nself::$origdir = getcwd();\\n@mkdir($temp, 0777, true);\\n$temp = realpath($temp);\\n\\nif (!file_exists($temp . DIRECTORY_SEPARATOR . md5_file(__FILE__))) {\\nself::_removeTmpFiles($temp, getcwd());\\n@mkdir($temp, 0777, true);\\n@file_put_contents($temp . '/' . md5_file(__FILE__), '');\\n\\nforeach ($info['m'] as $path => $file) {\\n$a = !file_exists(dirname($temp . '/' . $path));\\n@mkdir(dirname($temp . '/' . $path), 0777, true);\\nclearstatcache();\\n\\nif ($path[strlen($path) - 1] == '/') {\\n@mkdir($temp . '/' . $path, 0777);\\n} else {\\nfile_put_contents($temp . '/' . $path, self::extractFile($path, $file, $fp));\\n@chmod($temp . '/' . $path, 0666);\\n}\\n}\\n}\\n\\nchdir($temp);\\n\\nif (!$return) {\\ninclude self::START;\\n}\\n}\\n\\nstatic fun\";\n\tstatic const char newstub3_1[] = \"ction tmpdir()\\n{\\nif (strpos(PHP_OS, 'WIN') !== false) {\\nif ($var = getenv('TMP') ? getenv('TMP') : getenv('TEMP')) {\\nreturn $var;\\n}\\nif (is_dir('/temp') || mkdir('/temp')) {\\nreturn realpath('/temp');\\n}\\nreturn false;\\n}\\nif ($var = getenv('TMPDIR')) {\\nreturn $var;\\n}\\nreturn realpath('/tmp');\\n}\\n\\nstatic function _unpack($m)\\n{\\n$info = unpack('V', substr($m, 0, 4));\\n $l = unpack('V', substr($m, 10, 4));\\n$m = substr($m, 14 + $l[1]);\\n$s = unpack('V', substr($m, 0, 4));\\n$o = 0;\\n$start = 4 + $s[1];\\n$ret['c'] = 0;\\n\\nfor ($i = 0; $i < $info[1]; $i++) {\\n $len = unpack('V', substr($m, $start, 4));\\n$start += 4;\\n $savepath = substr($m, $start, $len[1]);\\n$start += $len[1];\\n   $ret['m'][$savepath] = array_values(unpack('Va/Vb/Vc/Vd/Ve/Vf', substr($m, $start, 24)));\\n$ret['m'][$savepath][3] = sprintf('%u', $ret['m'][$savepath][3]\\n& 0xffffffff);\\n$ret['m'][$savepath][7] = $o;\\n$o += $ret['m'][$savepath][2];\\n$start += 24 + $ret['m'][$savepath][5];\\n$ret['c'] |= $ret['m'][$savepath][4] & self::MASK;\\n}\\nreturn $ret;\\n}\\n\\nstatic function extractFile($path, $entry, $fp)\\n{\\n$data = '';\\n$c = $entry[2];\\n\\nwhile ($c) {\\nif ($c < 8192) {\\n$data .= @fread($fp, $c);\\n$c = 0;\\n} else {\\n$c -= 8192;\\n$data .= @fread($fp, 8192);\\n}\\n}\\n\\nif ($entry[4] & self::GZ) {\\n$data = gzinflate($data);\\n} elseif ($entry[4] & self::BZ2) {\\n$data = bzdecompress($data);\\n}\\n\\nif (strlen($data) != $entry[0]) {\\ndie(\\\"Invalid internal .phar file (size error \\\" . strlen($data) . \\\" != \\\" .\\n$stat[7] . \\\")\\\");\\n}\\n\\nif ($entry[3] != sprintf(\\\"%u\\\", crc32($data) & 0xffffffff)) {\\ndie(\\\"Invalid internal .phar file (checksum error)\\\");\\n}\\n\\nreturn $data;\\n}\\n\\nstatic function _removeTmpFiles($temp, $origdir)\\n{\\nchdir($temp);\\n\\nforeach (glob('*') as $f) {\\nif (file_exists($f)) {\\nis_dir($f) ? @rmdir($f) : @unlink($f);\\nif (file_exists($f) && is_dir($f)) {\\nself::_removeTmpFiles($f, getcwd());\\n}\\n}\\n}\\n\\n@rmdir($temp);\\nclearstatcache();\\nchdir($origdir);\\n}\\n}\\n\\nExtract_Phar::go();\\n__HALT_COMPILER(); ?>\";\n\n\tstatic const int newstub_len = 6623;\n\n\treturn strpprintf(name_len + web_len + newstub_len, \"%s%s%s%s%s%s%d%s%s\", newstub0, web, newstub1_0, newstub1_1, index_php, newstub2, name_len + web_len + newstub_len, newstub3_0, newstub3_1);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145839,
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-79"
    ],
    "code": "htmlAttrDumpOutput(xmlOutputBufferPtr buf, xmlDocPtr doc, xmlAttrPtr cur,\n\t           const char *encoding ATTRIBUTE_UNUSED) {\n    xmlChar *value;\n\n    /*\n     * The html output method should not escape a & character\n     * occurring in an attribute value immediately followed by\n     * a { character (see Section B.7.1 of the HTML 4.0 Recommendation).\n     * This is implemented in xmlEncodeEntitiesReentrant\n     */\n\n    if (cur == NULL) {\n\treturn;\n    }\n    xmlOutputBufferWriteString(buf, \" \");\n    if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {\n        xmlOutputBufferWriteString(buf, (const char *)cur->ns->prefix);\n\txmlOutputBufferWriteString(buf, \":\");\n    }\n    xmlOutputBufferWriteString(buf, (const char *)cur->name);\n    if ((cur->children != NULL) && (!htmlIsBooleanAttr(cur->name))) {\n\tvalue = xmlNodeListGetString(doc, cur->children, 0);\n\tif (value) {\n\t    xmlOutputBufferWriteString(buf, \"=\");\n\t    if ((cur->ns == NULL) && (cur->parent != NULL) &&\n\t\t(cur->parent->ns == NULL) &&\n\t\t((!xmlStrcasecmp(cur->name, BAD_CAST \"href\")) ||\n\t         (!xmlStrcasecmp(cur->name, BAD_CAST \"action\")) ||\n\t\t (!xmlStrcasecmp(cur->name, BAD_CAST \"src\")) ||\n\t\t ((!xmlStrcasecmp(cur->name, BAD_CAST \"name\")) &&\n\t\t  (!xmlStrcasecmp(cur->parent->name, BAD_CAST \"a\"))))) {\n\t\txmlChar *tmp = value;\n\t\t/* xmlURIEscapeStr() escapes '\"' so it can be safely used. */\n\t\txmlBufCCat(buf->buffer, \"\\\"\");\n\n\t\twhile (IS_BLANK_CH(*tmp)) tmp++;\n\n\t\t/* URI Escape everything, except server side includes. */\n\t\tfor ( ; ; ) {\n\t\t    xmlChar *escaped;\n\t\t    xmlChar endChar;\n\t\t    xmlChar *end = NULL;\n\t\t    xmlChar *start = (xmlChar *)xmlStrstr(tmp, BAD_CAST \"<!--\");\n\t\t    if (start != NULL) {\n\t\t\tend = (xmlChar *)xmlStrstr(tmp, BAD_CAST \"-->\");\n\t\t\tif (end != NULL) {\n\t\t\t    *start = '\\0';\n\t\t\t}\n\t\t    }\n\n\t\t    /* Escape the whole string, or until start (set to '\\0'). */\n\t\t    escaped = xmlURIEscapeStr(tmp, BAD_CAST\"@/:=?;#%&,+\");\n\t\t    if (escaped != NULL) {\n\t\t        xmlBufCat(buf->buffer, escaped);\n\t\t        xmlFree(escaped);\n\t\t    } else {\n\t\t        xmlBufCat(buf->buffer, tmp);\n\t\t    }\n\n\t\t    if (end == NULL) { /* Everything has been written. */\n\t\t\tbreak;\n\t\t    }\n\n\t\t    /* Do not escape anything within server side includes. */\n\t\t    *start = '<'; /* Restore the first character of \"<!--\". */\n\t\t    end += 3; /* strlen(\"-->\") */\n\t\t    endChar = *end;\n\t\t    *end = '\\0';\n\t\t    xmlBufCat(buf->buffer, start);\n\t\t    *end = endChar;\n\t\t    tmp = end;\n\t\t}\n\n\t\txmlBufCCat(buf->buffer, \"\\\"\");\n\t    } else {\n\t\txmlBufWriteQuotedString(buf->buffer, value);\n\t    }\n\t    xmlFree(value);\n\t} else  {\n\t    xmlOutputBufferWriteString(buf, \"=\\\"\\\"\");\n\t}\n    }\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147174,
    "human": "Correct. With CWE-79",
    "reason": "< and > are not escaped in URI attributes.",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-79"
    ],
    "code": "htmlAttrDumpOutput(xmlOutputBufferPtr buf, xmlDocPtr doc, xmlAttrPtr cur,\n\t           const char *encoding ATTRIBUTE_UNUSED) {\n    xmlChar *value;\n\n    /*\n     * The html output method should not escape a & character\n     * occurring in an attribute value immediately followed by\n     * a { character (see Section B.7.1 of the HTML 4.0 Recommendation).\n     * This is implemented in xmlEncodeEntitiesReentrant\n     */\n\n    if (cur == NULL) {\n\treturn;\n    }\n    xmlOutputBufferWriteString(buf, \" \");\n    if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {\n        xmlOutputBufferWriteString(buf, (const char *)cur->ns->prefix);\n\txmlOutputBufferWriteString(buf, \":\");\n    }\n    xmlOutputBufferWriteString(buf, (const char *)cur->name);\n    if ((cur->children != NULL) && (!htmlIsBooleanAttr(cur->name))) {\n\tvalue = xmlNodeListGetString(doc, cur->children, 0);\n\tif (value) {\n\t    xmlOutputBufferWriteString(buf, \"=\");\n\t    if ((cur->ns == NULL) && (cur->parent != NULL) &&\n\t\t(cur->parent->ns == NULL) &&\n\t\t((!xmlStrcasecmp(cur->name, BAD_CAST \"href\")) ||\n\t         (!xmlStrcasecmp(cur->name, BAD_CAST \"action\")) ||\n\t\t (!xmlStrcasecmp(cur->name, BAD_CAST \"src\")) ||\n\t\t ((!xmlStrcasecmp(cur->name, BAD_CAST \"name\")) &&\n\t\t  (!xmlStrcasecmp(cur->parent->name, BAD_CAST \"a\"))))) {\n\t\txmlChar *escaped;\n\t\txmlChar *tmp = value;\n\n\t\twhile (IS_BLANK_CH(*tmp)) tmp++;\n\n\t\t/*\n\t\t * the < and > have already been escaped at the entity level\n\t\t * And doing so here breaks server side includes\n\t\t */\n\t\tescaped = xmlURIEscapeStr(tmp, BAD_CAST\"@/:=?;#%&,+<>\");\n\t\tif (escaped != NULL) {\n\t\t    xmlBufWriteQuotedString(buf->buffer, escaped);\n\t\t    xmlFree(escaped);\n\t\t} else {\n\t\t    xmlBufWriteQuotedString(buf->buffer, value);\n\t\t}\n\t    } else {\n\t\txmlBufWriteQuotedString(buf->buffer, value);\n\t    }\n\t    xmlFree(value);\n\t} else  {\n\t    xmlOutputBufferWriteString(buf, \"=\\\"\\\"\");\n\t}\n    }\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147175,
    "human": "Correct. Without CWE-79",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-79"
    ],
    "code": "theme_adium_append_message (EmpathyChatView *view,\n\t\t\t    EmpathyMessage  *msg)\n{\n\tEmpathyThemeAdium     *theme = EMPATHY_THEME_ADIUM (view);\n\tEmpathyThemeAdiumPriv *priv = GET_PRIV (theme);\n\tEmpathyContact        *sender;\n\tTpMessage             *tp_msg;\n\tTpAccount             *account;\n\tgchar                 *body_escaped, *name_escaped;\n\tconst gchar           *name;\n\tconst gchar           *contact_id;\n\tEmpathyAvatar         *avatar;\n\tconst gchar           *avatar_filename = NULL;\n\tgint64                 timestamp;\n\tconst gchar           *html = NULL;\n\tconst gchar           *func;\n\tconst gchar           *service_name;\n\tGString               *message_classes = NULL;\n\tgboolean               is_backlog;\n\tgboolean               consecutive;\n\tgboolean               action;\n\n\tif (priv->pages_loading != 0) {\n\t\tqueue_item (&priv->message_queue, QUEUED_MESSAGE, msg, NULL);\n\t\treturn;\n\t}\n\n\t/* Get information */\n\tsender = empathy_message_get_sender (msg);\n\taccount = empathy_contact_get_account (sender);\n\tservice_name = empathy_protocol_name_to_display_name\n\t\t(tp_account_get_protocol (account));\n\tif (service_name == NULL)\n\t\tservice_name = tp_account_get_protocol (account);\n\ttimestamp = empathy_message_get_timestamp (msg);\n\tbody_escaped = theme_adium_parse_body (theme,\n\t\tempathy_message_get_body (msg),\n\t\tempathy_message_get_token (msg));\n\tname = empathy_contact_get_logged_alias (sender);\n\tcontact_id = empathy_contact_get_id (sender);\n\taction = (empathy_message_get_tptype (msg) == TP_CHANNEL_TEXT_MESSAGE_TYPE_ACTION);\n\n\t/* If this is a /me probably */\n\tif (action) {\n\t\tgchar *str;\n\n\t\tif (priv->data->version >= 4 || !priv->data->custom_template) {\n\t\t\tstr = g_strdup_printf (\"<span class='actionMessageUserName'>%s</span>\"\n\t\t\t\t\t       \"<span class='actionMessageBody'>%s</span>\",\n\t\t\t\t\t       name, body_escaped);\n\t\t} else {\n\t\t\tstr = g_strdup_printf (\"*%s*\", body_escaped);\n\t\t}\n\t\tg_free (body_escaped);\n\t\tbody_escaped = str;\n\t}\n\n\t/* Get the avatar filename, or a fallback */\n\tavatar = empathy_contact_get_avatar (sender);\n\tif (avatar) {\n\t\tavatar_filename = avatar->filename;\n\t}\n\tif (!avatar_filename) {\n\t\tif (empathy_contact_is_user (sender)) {\n\t\t\tavatar_filename = priv->data->default_outgoing_avatar_filename;\n\t\t} else {\n\t\t\tavatar_filename = priv->data->default_incoming_avatar_filename;\n\t\t}\n\t\tif (!avatar_filename) {\n\t\t\tif (!priv->data->default_avatar_filename) {\n\t\t\t\tpriv->data->default_avatar_filename =\n\t\t\t\t\tempathy_filename_from_icon_name (EMPATHY_IMAGE_AVATAR_DEFAULT,\n\t\t\t\t\t\t\t\t\t GTK_ICON_SIZE_DIALOG);\n\t\t\t}\n\t\t\tavatar_filename = priv->data->default_avatar_filename;\n\t\t}\n\t}\n\n\t/* We want to join this message with the last one if\n\t * - senders are the same contact,\n\t * - last message was recieved recently,\n\t * - last message and this message both are/aren't backlog, and\n\t * - DisableCombineConsecutive is not set in theme's settings */\n\tis_backlog = empathy_message_is_backlog (msg);\n\tconsecutive = empathy_contact_equal (priv->last_contact, sender) &&\n\t\t(timestamp - priv->last_timestamp < MESSAGE_JOIN_PERIOD) &&\n\t\t(is_backlog == priv->last_is_backlog) &&\n\t\t!tp_asv_get_boolean (priv->data->info,\n\t\t\t\t     \"DisableCombineConsecutive\", NULL);\n\n\t/* Define message classes */\n\tmessage_classes = g_string_new (\"message\");\n\tif (!priv->has_focus && !is_backlog) {\n\t\tif (!priv->has_unread_message) {\n\t\t\tg_string_append (message_classes, \" firstFocus\");\n\t\t\tpriv->has_unread_message = TRUE;\n\t\t}\n\t\tg_string_append (message_classes, \" focus\");\n\t}\n\tif (is_backlog) {\n\t\tg_string_append (message_classes, \" history\");\n\t}\n\tif (consecutive) {\n\t\tg_string_append (message_classes, \" consecutive\");\n\t}\n\tif (empathy_contact_is_user (sender)) {\n\t\tg_string_append (message_classes, \" outgoing\");\n\t} else {\n\t\tg_string_append (message_classes, \" incoming\");\n\t}\n\tif (empathy_message_should_highlight (msg)) {\n\t\tg_string_append (message_classes, \" mention\");\n\t}\n\tif (empathy_message_get_tptype (msg) == TP_CHANNEL_TEXT_MESSAGE_TYPE_AUTO_REPLY) {\n\t\tg_string_append (message_classes, \" autoreply\");\n\t}\n\tif (action) {\n\t\tg_string_append (message_classes, \" action\");\n\t}\n\t/* FIXME: other classes:\n\t * status - the message is a status change\n\t * event - the message is a notification of something happening\n\t *         (for example, encryption being turned on)\n\t * %status% - See %status% in theme_adium_append_html ()\n\t */\n\n\t/* This is slightly a hack, but it's the only way to add\n\t * arbitrary data to messages in the HTML. We add another\n\t * class called \"x-empathy-message-id-*\" to the message. This\n\t * way, we can remove the unread marker for this specific\n\t * message later. */\n\ttp_msg = empathy_message_get_tp_message (msg);\n\tif (tp_msg != NULL) {\n\t\tguint32 id;\n\t\tgboolean valid;\n\n\t\tid = tp_message_get_pending_message_id (tp_msg, &valid);\n\t\tif (valid) {\n\t\t\tg_string_append_printf (message_classes,\n\t\t\t    \" x-empathy-message-id-%u\", id);\n\t\t}\n\t}\n\n\t/* Define javascript function to use */\n\tif (consecutive) {\n\t\tfunc = priv->allow_scrolling ? \"appendNextMessage\" : \"appendNextMessageNoScroll\";\n\t} else {\n\t\tfunc = priv->allow_scrolling ? \"appendMessage\" : \"appendMessageNoScroll\";\n\t}\n\n\tif (empathy_contact_is_user (sender)) {\n\t\t/* out */\n\t\tif (is_backlog) {\n\t\t\t/* context */\n\t\t\thtml = consecutive ? priv->data->out_nextcontext_html : priv->data->out_context_html;\n\t\t} else {\n\t\t\t/* content */\n\t\t\thtml = consecutive ? priv->data->out_nextcontent_html : priv->data->out_content_html;\n\t\t}\n\n\t\t/* remove all the unread marks when we are sending a message */\n\t\ttheme_adium_remove_all_focus_marks (theme);\n\t} else {\n\t\t/* in */\n\t\tif (is_backlog) {\n\t\t\t/* context */\n\t\t\thtml = consecutive ? priv->data->in_nextcontext_html : priv->data->in_context_html;\n\t\t} else {\n\t\t\t/* content */\n\t\t\thtml = consecutive ? priv->data->in_nextcontent_html : priv->data->in_content_html;\n\t\t}\n\t}\n\n\tname_escaped = g_markup_escape_text (name, -1);\n\n\ttheme_adium_append_html (theme, func, html, body_escaped,\n\t\t\t\t avatar_filename, name_escaped, contact_id,\n\t\t\t\t service_name, message_classes->str,\n\t\t\t\t timestamp, is_backlog, empathy_contact_is_user (sender));\n\n\t/* Keep the sender of the last displayed message */\n\tif (priv->last_contact) {\n\t\tg_object_unref (priv->last_contact);\n\t}\n\tpriv->last_contact = g_object_ref (sender);\n\tpriv->last_timestamp = timestamp;\n\tpriv->last_is_backlog = is_backlog;\n\n\tg_free (body_escaped);\n\tg_free (name_escaped);\n\tg_string_free (message_classes, TRUE);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147630,
    "human": "Correct. With CWE-79",
    "reason": "Untrusted name is embedded raw into HTML, allowing script injection.",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-79"
    ],
    "code": "theme_adium_append_message (EmpathyChatView *view,\n\t\t\t    EmpathyMessage  *msg)\n{\n\tEmpathyThemeAdium     *theme = EMPATHY_THEME_ADIUM (view);\n\tEmpathyThemeAdiumPriv *priv = GET_PRIV (theme);\n\tEmpathyContact        *sender;\n\tTpMessage             *tp_msg;\n\tTpAccount             *account;\n\tgchar                 *body_escaped, *name_escaped;\n\tconst gchar           *name;\n\tconst gchar           *contact_id;\n\tEmpathyAvatar         *avatar;\n\tconst gchar           *avatar_filename = NULL;\n\tgint64                 timestamp;\n\tconst gchar           *html = NULL;\n\tconst gchar           *func;\n\tconst gchar           *service_name;\n\tGString               *message_classes = NULL;\n\tgboolean               is_backlog;\n\tgboolean               consecutive;\n\tgboolean               action;\n\n\tif (priv->pages_loading != 0) {\n\t\tqueue_item (&priv->message_queue, QUEUED_MESSAGE, msg, NULL);\n\t\treturn;\n\t}\n\n\t/* Get information */\n\tsender = empathy_message_get_sender (msg);\n\taccount = empathy_contact_get_account (sender);\n\tservice_name = empathy_protocol_name_to_display_name\n\t\t(tp_account_get_protocol (account));\n\tif (service_name == NULL)\n\t\tservice_name = tp_account_get_protocol (account);\n\ttimestamp = empathy_message_get_timestamp (msg);\n\tbody_escaped = theme_adium_parse_body (theme,\n\t\tempathy_message_get_body (msg),\n\t\tempathy_message_get_token (msg));\n\tname = empathy_contact_get_logged_alias (sender);\n\tcontact_id = empathy_contact_get_id (sender);\n\taction = (empathy_message_get_tptype (msg) == TP_CHANNEL_TEXT_MESSAGE_TYPE_ACTION);\n\n\tname_escaped = g_markup_escape_text (name, -1);\n\n\t/* If this is a /me probably */\n\tif (action) {\n\t\tgchar *str;\n\n\t\tif (priv->data->version >= 4 || !priv->data->custom_template) {\n\t\t\tstr = g_strdup_printf (\"<span class='actionMessageUserName'>%s</span>\"\n\t\t\t\t\t       \"<span class='actionMessageBody'>%s</span>\",\n\t\t\t\t\t       name_escaped, body_escaped);\n\t\t} else {\n\t\t\tstr = g_strdup_printf (\"*%s*\", body_escaped);\n\t\t}\n\t\tg_free (body_escaped);\n\t\tbody_escaped = str;\n\t}\n\n\t/* Get the avatar filename, or a fallback */\n\tavatar = empathy_contact_get_avatar (sender);\n\tif (avatar) {\n\t\tavatar_filename = avatar->filename;\n\t}\n\tif (!avatar_filename) {\n\t\tif (empathy_contact_is_user (sender)) {\n\t\t\tavatar_filename = priv->data->default_outgoing_avatar_filename;\n\t\t} else {\n\t\t\tavatar_filename = priv->data->default_incoming_avatar_filename;\n\t\t}\n\t\tif (!avatar_filename) {\n\t\t\tif (!priv->data->default_avatar_filename) {\n\t\t\t\tpriv->data->default_avatar_filename =\n\t\t\t\t\tempathy_filename_from_icon_name (EMPATHY_IMAGE_AVATAR_DEFAULT,\n\t\t\t\t\t\t\t\t\t GTK_ICON_SIZE_DIALOG);\n\t\t\t}\n\t\t\tavatar_filename = priv->data->default_avatar_filename;\n\t\t}\n\t}\n\n\t/* We want to join this message with the last one if\n\t * - senders are the same contact,\n\t * - last message was recieved recently,\n\t * - last message and this message both are/aren't backlog, and\n\t * - DisableCombineConsecutive is not set in theme's settings */\n\tis_backlog = empathy_message_is_backlog (msg);\n\tconsecutive = empathy_contact_equal (priv->last_contact, sender) &&\n\t\t(timestamp - priv->last_timestamp < MESSAGE_JOIN_PERIOD) &&\n\t\t(is_backlog == priv->last_is_backlog) &&\n\t\t!tp_asv_get_boolean (priv->data->info,\n\t\t\t\t     \"DisableCombineConsecutive\", NULL);\n\n\t/* Define message classes */\n\tmessage_classes = g_string_new (\"message\");\n\tif (!priv->has_focus && !is_backlog) {\n\t\tif (!priv->has_unread_message) {\n\t\t\tg_string_append (message_classes, \" firstFocus\");\n\t\t\tpriv->has_unread_message = TRUE;\n\t\t}\n\t\tg_string_append (message_classes, \" focus\");\n\t}\n\tif (is_backlog) {\n\t\tg_string_append (message_classes, \" history\");\n\t}\n\tif (consecutive) {\n\t\tg_string_append (message_classes, \" consecutive\");\n\t}\n\tif (empathy_contact_is_user (sender)) {\n\t\tg_string_append (message_classes, \" outgoing\");\n\t} else {\n\t\tg_string_append (message_classes, \" incoming\");\n\t}\n\tif (empathy_message_should_highlight (msg)) {\n\t\tg_string_append (message_classes, \" mention\");\n\t}\n\tif (empathy_message_get_tptype (msg) == TP_CHANNEL_TEXT_MESSAGE_TYPE_AUTO_REPLY) {\n\t\tg_string_append (message_classes, \" autoreply\");\n\t}\n\tif (action) {\n\t\tg_string_append (message_classes, \" action\");\n\t}\n\t/* FIXME: other classes:\n\t * status - the message is a status change\n\t * event - the message is a notification of something happening\n\t *         (for example, encryption being turned on)\n\t * %status% - See %status% in theme_adium_append_html ()\n\t */\n\n\t/* This is slightly a hack, but it's the only way to add\n\t * arbitrary data to messages in the HTML. We add another\n\t * class called \"x-empathy-message-id-*\" to the message. This\n\t * way, we can remove the unread marker for this specific\n\t * message later. */\n\ttp_msg = empathy_message_get_tp_message (msg);\n\tif (tp_msg != NULL) {\n\t\tguint32 id;\n\t\tgboolean valid;\n\n\t\tid = tp_message_get_pending_message_id (tp_msg, &valid);\n\t\tif (valid) {\n\t\t\tg_string_append_printf (message_classes,\n\t\t\t    \" x-empathy-message-id-%u\", id);\n\t\t}\n\t}\n\n\t/* Define javascript function to use */\n\tif (consecutive) {\n\t\tfunc = priv->allow_scrolling ? \"appendNextMessage\" : \"appendNextMessageNoScroll\";\n\t} else {\n\t\tfunc = priv->allow_scrolling ? \"appendMessage\" : \"appendMessageNoScroll\";\n\t}\n\n\tif (empathy_contact_is_user (sender)) {\n\t\t/* out */\n\t\tif (is_backlog) {\n\t\t\t/* context */\n\t\t\thtml = consecutive ? priv->data->out_nextcontext_html : priv->data->out_context_html;\n\t\t} else {\n\t\t\t/* content */\n\t\t\thtml = consecutive ? priv->data->out_nextcontent_html : priv->data->out_content_html;\n\t\t}\n\n\t\t/* remove all the unread marks when we are sending a message */\n\t\ttheme_adium_remove_all_focus_marks (theme);\n\t} else {\n\t\t/* in */\n\t\tif (is_backlog) {\n\t\t\t/* context */\n\t\t\thtml = consecutive ? priv->data->in_nextcontext_html : priv->data->in_context_html;\n\t\t} else {\n\t\t\t/* content */\n\t\t\thtml = consecutive ? priv->data->in_nextcontent_html : priv->data->in_content_html;\n\t\t}\n\t}\n\n\ttheme_adium_append_html (theme, func, html, body_escaped,\n\t\t\t\t avatar_filename, name_escaped, contact_id,\n\t\t\t\t service_name, message_classes->str,\n\t\t\t\t timestamp, is_backlog, empathy_contact_is_user (sender));\n\n\t/* Keep the sender of the last displayed message */\n\tif (priv->last_contact) {\n\t\tg_object_unref (priv->last_contact);\n\t}\n\tpriv->last_contact = g_object_ref (sender);\n\tpriv->last_timestamp = timestamp;\n\tpriv->last_is_backlog = is_backlog;\n\n\tg_free (body_escaped);\n\tg_free (name_escaped);\n\tg_string_free (message_classes, TRUE);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147631,
    "human": "Correct. Without CWE-79",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-79"
    ],
    "code": "void send_file_direct(char *file_name) {\n   int fh, i, length, delta;\n   char str[MAX_PATH_LENGTH], dir[MAX_PATH_LENGTH], charset[80];\n\n   getcwd(dir, sizeof(dir));\n   fh = open(file_name, O_RDONLY | O_BINARY);\n   if (fh > 0) {\n      lseek(fh, 0, SEEK_END);\n      length = TELL(fh);\n      lseek(fh, 0, SEEK_SET);\n\n      rsprintf(\"HTTP/1.1 200 Document follows\\r\\n\");\n      rsprintf(\"Server: ELOG HTTP %s-%s\\r\\n\", VERSION, git_revision());\n      rsprintf(\"Accept-Ranges: bytes\\r\\n\");\n\n      /* set expiration time to one day if no thumbnail */\n      if (isparam(\"thumb\")) {\n         rsprintf(\"Pragma: no-cache\\r\\n\");\n         rsprintf(\"Cache-control: private, max-age=0, no-cache, no-store\\r\\n\");\n      } else {\n         rsprintf(\"Cache-control: public, max-age=86400\\r\\n\");\n      }\n\n      if (keep_alive) {\n         rsprintf(\"Connection: Keep-Alive\\r\\n\");\n         rsprintf(\"Keep-Alive: timeout=60, max=10\\r\\n\");\n      }\n\n      /* return proper header for file type */\n      for (i = 0; i < (int) strlen(file_name); i++)\n         str[i] = toupper(file_name[i]);\n      str[i] = 0;\n\n      for (i = 0; filetype[i].ext[0]; i++)\n         if (chkext(str, filetype[i].ext))\n            break;\n\n      if (!getcfg(\"global\", \"charset\", charset, sizeof(charset)))\n         strcpy(charset, DEFAULT_HTTP_CHARSET);\n\n      if (filetype[i].ext[0]) {\n         if (strncmp(filetype[i].type, \"text\", 4) == 0)\n            rsprintf(\"Content-Type: %s;charset=%s\\r\\n\", filetype[i].type, charset);\n         else\n            rsprintf(\"Content-Type: %s\\r\\n\", filetype[i].type);\n      } else if (is_ascii(file_name))\n         rsprintf(\"Content-Type: text/plain;charset=%s\\r\\n\", charset);\n      else\n         rsprintf(\"Content-Type: application/octet-stream;charset=%s\\r\\n\", charset);\n\n      rsprintf(\"Content-Length: %d\\r\\n\\r\\n\", length);\n\n      /* increase return buffer size if file too big */\n      if (length > return_buffer_size - (int) strlen(return_buffer)) {\n         delta = length - (return_buffer_size - strlen(return_buffer)) + 1000;\n\n         return_buffer = xrealloc(return_buffer, return_buffer_size + delta);\n         memset(return_buffer + return_buffer_size, 0, delta);\n         return_buffer_size += delta;\n      }\n\n      return_length = strlen(return_buffer) + length;\n      read(fh, return_buffer + strlen(return_buffer), length);\n\n      close(fh);\n   } else {\n      char encodedname[256];\n      show_html_header(NULL, FALSE, \"404 Not Found\", TRUE, FALSE, NULL, FALSE, 0);\n\n      rsprintf(\"<body><h1>Not Found</h1>\\r\\n\");\n      rsprintf(\"The requested file <b>\");\n      strencode2(encodedname, file_name, sizeof(encodedname));\n      if (strchr(file_name, DIR_SEPARATOR))\n         rsprintf(\"%s\", encodedname);\n      else\n         rsprintf(\"%s%c%s\", dir, DIR_SEPARATOR, encodedname);\n      rsprintf(\"</b> was not found on this server<p>\\r\\n\");\n      rsprintf(\"<hr><address>ELOG version %s</address></body></html>\\r\\n\\r\\n\", VERSION);\n      return_length = strlen_retbuf;\n      keep_alive = FALSE;\n   }\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147862,
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-79"
    ],
    "code": "void send_file_direct(char *file_name) {\n   int fh, i, length, delta;\n   char str[MAX_PATH_LENGTH], dir[MAX_PATH_LENGTH], charset[80];\n\n   getcwd(dir, sizeof(dir));\n   fh = open(file_name, O_RDONLY | O_BINARY);\n   if (fh > 0) {\n      lseek(fh, 0, SEEK_END);\n      length = TELL(fh);\n      lseek(fh, 0, SEEK_SET);\n\n      rsprintf(\"HTTP/1.1 200 Document follows\\r\\n\");\n      rsprintf(\"Server: ELOG HTTP %s-%s\\r\\n\", VERSION, git_revision());\n      rsprintf(\"Accept-Ranges: bytes\\r\\n\");\n\n      /* set expiration time to one day if no thumbnail */\n      if (isparam(\"thumb\")) {\n         rsprintf(\"Pragma: no-cache\\r\\n\");\n         rsprintf(\"Cache-control: private, max-age=0, no-cache, no-store\\r\\n\");\n      } else {\n         rsprintf(\"Cache-control: public, max-age=86400\\r\\n\");\n      }\n\n      if (keep_alive) {\n         rsprintf(\"Connection: Keep-Alive\\r\\n\");\n         rsprintf(\"Keep-Alive: timeout=60, max=10\\r\\n\");\n      }\n\n      /* return proper header for file type */\n      for (i = 0; i < (int) strlen(file_name); i++)\n         str[i] = toupper(file_name[i]);\n      str[i] = 0;\n\n      for (i = 0; filetype[i].ext[0]; i++)\n         if (chkext(str, filetype[i].ext))\n            break;\n\n      if (!getcfg(\"global\", \"charset\", charset, sizeof(charset)))\n         strcpy(charset, DEFAULT_HTTP_CHARSET);\n\n      if (filetype[i].ext[0]) {\n         if (strncmp(filetype[i].type, \"text\", 4) == 0)\n            rsprintf(\"Content-Type: %s;charset=%s\\r\\n\", filetype[i].type, charset);\n         else if (strcmp(filetype[i].ext, \".SVG\") == 0) {\n            rsprintf(\"Content-Type: %s\\r\\n\", filetype[i].type);\n            if (strrchr(file_name, '/'))\n               strlcpy(str, strrchr(file_name, '/')+1, sizeof(str));\n            else\n               strlcpy(str, file_name, sizeof(str));\n            if (str[6] == '_' && str[13] == '_')\n               rsprintf(\"Content-Disposition: attachment; filename=\\\"%s\\\"\\r\\n\", str+14);\n            else\n               rsprintf(\"Content-Disposition: attachment; filename=\\\"%s\\\"\\r\\n\", str);\n         } else\n            rsprintf(\"Content-Type: %s\\r\\n\", filetype[i].type);\n      } else if (is_ascii(file_name))\n         rsprintf(\"Content-Type: text/plain;charset=%s\\r\\n\", charset);\n      else\n         rsprintf(\"Content-Type: application/octet-stream;charset=%s\\r\\n\", charset);\n\n      rsprintf(\"Content-Length: %d\\r\\n\\r\\n\", length);\n\n      /* increase return buffer size if file too big */\n      if (length > return_buffer_size - (int) strlen(return_buffer)) {\n         delta = length - (return_buffer_size - strlen(return_buffer)) + 1000;\n\n         return_buffer = xrealloc(return_buffer, return_buffer_size + delta);\n         memset(return_buffer + return_buffer_size, 0, delta);\n         return_buffer_size += delta;\n      }\n\n      return_length = strlen(return_buffer) + length;\n      read(fh, return_buffer + strlen(return_buffer), length);\n\n      close(fh);\n   } else {\n      char encodedname[256];\n      show_html_header(NULL, FALSE, \"404 Not Found\", TRUE, FALSE, NULL, FALSE, 0);\n\n      rsprintf(\"<body><h1>Not Found</h1>\\r\\n\");\n      rsprintf(\"The requested file <b>\");\n      strencode2(encodedname, file_name, sizeof(encodedname));\n      if (strchr(file_name, DIR_SEPARATOR))\n         rsprintf(\"%s\", encodedname);\n      else\n         rsprintf(\"%s%c%s\", dir, DIR_SEPARATOR, encodedname);\n      rsprintf(\"</b> was not found on this server<p>\\r\\n\");\n      rsprintf(\"<hr><address>ELOG version %s</address></body></html>\\r\\n\\r\\n\", VERSION);\n      return_length = strlen_retbuf;\n      keep_alive = FALSE;\n   }\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147863,
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-79"
    ],
    "code": "rndr_quote(struct buf *ob, const struct buf *text, void *opaque)\n{\n\tif (!text || !text->size)\n\t\treturn 0;\n\n\tBUFPUTSL(ob, \"<q>\");\n\tbufput(ob, text->data, text->size);\n\tBUFPUTSL(ob, \"</q>\");\n\n\treturn 1;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148520,
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-79"
    ],
    "code": "rndr_underline(struct buf *ob, const struct buf *text, void *opaque)\n{\n\tif (!text || !text->size)\n\t\treturn 0;\n\n\tBUFPUTSL(ob, \"<u>\");\n\tbufput(ob, text->data, text->size);\n\tBUFPUTSL(ob, \"</u>\");\n\n\treturn 1;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148521,
    "human": "Incorrect. With CWE-79",
    "reason": "Malicious text is embedded unsafely.",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-79"
    ],
    "code": "int RGWGetObj_ObjStore_S3::send_response_data(bufferlist& bl, off_t bl_ofs,\n\t\t\t\t\t      off_t bl_len)\n{\n  const char *content_type = NULL;\n  string content_type_str;\n  map<string, string> response_attrs;\n  map<string, string>::iterator riter;\n  bufferlist metadata_bl;\n\n  if (sent_header)\n    goto send_data;\n\n  if (custom_http_ret) {\n    set_req_state_err(s, 0);\n    dump_errno(s, custom_http_ret);\n  } else {\n    set_req_state_err(s, (partial_content && !op_ret) ? STATUS_PARTIAL_CONTENT\n                  : op_ret);\n    dump_errno(s);\n  }\n\n  if (op_ret)\n    goto done;\n\n  if (range_str)\n    dump_range(s, start, end, s->obj_size);\n\n  if (s->system_request &&\n      s->info.args.exists(RGW_SYS_PARAM_PREFIX \"prepend-metadata\")) {\n\n    dump_header(s, \"Rgwx-Object-Size\", (long long)total_len);\n\n    if (rgwx_stat) {\n      /*\n       * in this case, we're not returning the object's content, only the prepended\n       * extra metadata\n       */\n      total_len = 0;\n    }\n\n    /* JSON encode object metadata */\n    JSONFormatter jf;\n    jf.open_object_section(\"obj_metadata\");\n    encode_json(\"attrs\", attrs, &jf);\n    utime_t ut(lastmod);\n    encode_json(\"mtime\", ut, &jf);\n    jf.close_section();\n    stringstream ss;\n    jf.flush(ss);\n    metadata_bl.append(ss.str());\n    dump_header(s, \"Rgwx-Embedded-Metadata-Len\", metadata_bl.length());\n    total_len += metadata_bl.length();\n  }\n\n  if (s->system_request && !real_clock::is_zero(lastmod)) {\n    /* we end up dumping mtime in two different methods, a bit redundant */\n    dump_epoch_header(s, \"Rgwx-Mtime\", lastmod);\n    uint64_t pg_ver = 0;\n    int r = decode_attr_bl_single_value(attrs, RGW_ATTR_PG_VER, &pg_ver, (uint64_t)0);\n    if (r < 0) {\n      ldout(s->cct, 0) << \"ERROR: failed to decode pg ver attr, ignoring\" << dendl;\n    }\n    dump_header(s, \"Rgwx-Obj-PG-Ver\", pg_ver);\n\n    uint32_t source_zone_short_id = 0;\n    r = decode_attr_bl_single_value(attrs, RGW_ATTR_SOURCE_ZONE, &source_zone_short_id, (uint32_t)0);\n    if (r < 0) {\n      ldout(s->cct, 0) << \"ERROR: failed to decode pg ver attr, ignoring\" << dendl;\n    }\n    if (source_zone_short_id != 0) {\n      dump_header(s, \"Rgwx-Source-Zone-Short-Id\", source_zone_short_id);\n    }\n  }\n\n  for (auto &it : crypt_http_responses)\n    dump_header(s, it.first, it.second);\n\n  dump_content_length(s, total_len);\n  dump_last_modified(s, lastmod);\n  dump_header_if_nonempty(s, \"x-amz-version-id\", version_id);\n  if (attrs.find(RGW_ATTR_APPEND_PART_NUM) != attrs.end()) {\n    dump_header(s, \"x-rgw-object-type\", \"Appendable\");\n    dump_header(s, \"x-rgw-next-append-position\", s->obj_size);\n  } else {\n    dump_header(s, \"x-rgw-object-type\", \"Normal\");\n  }\n\n  if (! op_ret) {\n    if (! lo_etag.empty()) {\n      /* Handle etag of Swift API's large objects (DLO/SLO). It's entirerly\n       * legit to perform GET on them through S3 API. In such situation,\n       * a client should receive the composited content with corresponding\n       * etag value. */\n      dump_etag(s, lo_etag);\n    } else {\n      auto iter = attrs.find(RGW_ATTR_ETAG);\n      if (iter != attrs.end()) {\n        dump_etag(s, iter->second.to_str());\n      }\n    }\n\n    for (struct response_attr_param *p = resp_attr_params; p->param; p++) {\n      bool exists;\n      string val = s->info.args.get(p->param, &exists);\n      if (exists) {\n\t/* reject unauthenticated response header manipulation, see\n\t * https://docs.aws.amazon.com/AmazonS3/latest/API/API_GetObject.html */\n\tif (s->auth.identity->is_anonymous()) {\n\t  return -ERR_INVALID_REQUEST;\n\t}\n\tif (strcmp(p->param, \"response-content-type\") != 0) {\n\t  response_attrs[p->http_attr] = val;\n\t} else {\n\t  content_type_str = val;\n\t  content_type = content_type_str.c_str();\n\t}\n      }\n    }\n\n    for (auto iter = attrs.begin(); iter != attrs.end(); ++iter) {\n      const char *name = iter->first.c_str();\n      map<string, string>::iterator aiter = rgw_to_http_attrs.find(name);\n      if (aiter != rgw_to_http_attrs.end()) {\n        if (response_attrs.count(aiter->second) == 0) {\n          /* Was not already overridden by a response param. */\n\n          size_t len = iter->second.length();\n          string s(iter->second.c_str(), len);\n          while (len && !s[len - 1]) {\n            --len;\n            s.resize(len);\n          }\n          response_attrs[aiter->second] = s;\n        }\n      } else if (iter->first.compare(RGW_ATTR_CONTENT_TYPE) == 0) {\n        /* Special handling for content_type. */\n        if (!content_type) {\n          content_type_str = rgw_bl_str(iter->second);\n          content_type = content_type_str.c_str();\n        }\n      } else if (strcmp(name, RGW_ATTR_SLO_UINDICATOR) == 0) {\n        // this attr has an extra length prefix from encode() in prior versions\n        dump_header(s, \"X-Object-Meta-Static-Large-Object\", \"True\");\n      } else if (strncmp(name, RGW_ATTR_META_PREFIX,\n\t\t\t sizeof(RGW_ATTR_META_PREFIX)-1) == 0) {\n        /* User custom metadata. */\n        name += sizeof(RGW_ATTR_PREFIX) - 1;\n        dump_header(s, name, iter->second);\n      } else if (iter->first.compare(RGW_ATTR_TAGS) == 0) {\n        RGWObjTags obj_tags;\n        try{\n          auto it = iter->second.cbegin();\n          obj_tags.decode(it);\n        } catch (buffer::error &err) {\n          ldout(s->cct,0) << \"Error caught buffer::error couldn't decode TagSet \" << dendl;\n        }\n        dump_header(s, RGW_AMZ_TAG_COUNT, obj_tags.count());\n      } else if (iter->first.compare(RGW_ATTR_OBJECT_RETENTION) == 0 && get_retention){\n        RGWObjectRetention retention;\n        try {\n          decode(retention, iter->second);\n          dump_header(s, \"x-amz-object-lock-mode\", retention.get_mode());\n          dump_time_header(s, \"x-amz-object-lock-retain-until-date\", retention.get_retain_until_date());\n        } catch (buffer::error& err) {\n          ldpp_dout(this, 0) << \"ERROR: failed to decode RGWObjectRetention\" << dendl;\n        }\n      } else if (iter->first.compare(RGW_ATTR_OBJECT_LEGAL_HOLD) == 0 && get_legal_hold) {\n        RGWObjectLegalHold legal_hold;\n        try {\n          decode(legal_hold, iter->second);\n          dump_header(s, \"x-amz-object-lock-legal-hold\",legal_hold.get_status());\n        } catch (buffer::error& err) {\n          ldpp_dout(this, 0) << \"ERROR: failed to decode RGWObjectLegalHold\" << dendl;\n        }\n      }\n    }\n  }\n\ndone:\n  for (riter = response_attrs.begin(); riter != response_attrs.end();\n       ++riter) {\n    dump_header(s, riter->first, riter->second);\n  }\n\n  if (op_ret == -ERR_NOT_MODIFIED) {\n      end_header(s, this);\n  } else {\n      if (!content_type)\n          content_type = \"binary/octet-stream\";\n\n      end_header(s, this, content_type);\n  }\n\n  if (metadata_bl.length()) {\n    dump_body(s, metadata_bl);\n  }\n  sent_header = true;\n\nsend_data:\n  if (get_data && !op_ret) {\n    int r = dump_body(s, bl.c_str() + bl_ofs, bl_len);\n    if (r < 0)\n      return r;\n  }\n\n  return 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148632,
    "human": "Correct. With CWE-79",
    "reason": "It allows unvalidated user input in headers.",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-79"
    ],
    "code": "int RGWGetObj_ObjStore_S3::send_response_data(bufferlist& bl, off_t bl_ofs,\n\t\t\t\t\t      off_t bl_len)\n{\n  const char *content_type = NULL;\n  string content_type_str;\n  map<string, string> response_attrs;\n  map<string, string>::iterator riter;\n  bufferlist metadata_bl;\n\n  if (sent_header)\n    goto send_data;\n\n  if (custom_http_ret) {\n    set_req_state_err(s, 0);\n    dump_errno(s, custom_http_ret);\n  } else {\n    set_req_state_err(s, (partial_content && !op_ret) ? STATUS_PARTIAL_CONTENT\n                  : op_ret);\n    dump_errno(s);\n  }\n\n  if (op_ret)\n    goto done;\n\n  if (range_str)\n    dump_range(s, start, end, s->obj_size);\n\n  if (s->system_request &&\n      s->info.args.exists(RGW_SYS_PARAM_PREFIX \"prepend-metadata\")) {\n\n    dump_header(s, \"Rgwx-Object-Size\", (long long)total_len);\n\n    if (rgwx_stat) {\n      /*\n       * in this case, we're not returning the object's content, only the prepended\n       * extra metadata\n       */\n      total_len = 0;\n    }\n\n    /* JSON encode object metadata */\n    JSONFormatter jf;\n    jf.open_object_section(\"obj_metadata\");\n    encode_json(\"attrs\", attrs, &jf);\n    utime_t ut(lastmod);\n    encode_json(\"mtime\", ut, &jf);\n    jf.close_section();\n    stringstream ss;\n    jf.flush(ss);\n    metadata_bl.append(ss.str());\n    dump_header(s, \"Rgwx-Embedded-Metadata-Len\", metadata_bl.length());\n    total_len += metadata_bl.length();\n  }\n\n  if (s->system_request && !real_clock::is_zero(lastmod)) {\n    /* we end up dumping mtime in two different methods, a bit redundant */\n    dump_epoch_header(s, \"Rgwx-Mtime\", lastmod);\n    uint64_t pg_ver = 0;\n    int r = decode_attr_bl_single_value(attrs, RGW_ATTR_PG_VER, &pg_ver, (uint64_t)0);\n    if (r < 0) {\n      ldout(s->cct, 0) << \"ERROR: failed to decode pg ver attr, ignoring\" << dendl;\n    }\n    dump_header(s, \"Rgwx-Obj-PG-Ver\", pg_ver);\n\n    uint32_t source_zone_short_id = 0;\n    r = decode_attr_bl_single_value(attrs, RGW_ATTR_SOURCE_ZONE, &source_zone_short_id, (uint32_t)0);\n    if (r < 0) {\n      ldout(s->cct, 0) << \"ERROR: failed to decode pg ver attr, ignoring\" << dendl;\n    }\n    if (source_zone_short_id != 0) {\n      dump_header(s, \"Rgwx-Source-Zone-Short-Id\", source_zone_short_id);\n    }\n  }\n\n  for (auto &it : crypt_http_responses)\n    dump_header(s, it.first, it.second);\n\n  dump_content_length(s, total_len);\n  dump_last_modified(s, lastmod);\n  dump_header_if_nonempty(s, \"x-amz-version-id\", version_id);\n  if (attrs.find(RGW_ATTR_APPEND_PART_NUM) != attrs.end()) {\n    dump_header(s, \"x-rgw-object-type\", \"Appendable\");\n    dump_header(s, \"x-rgw-next-append-position\", s->obj_size);\n  } else {\n    dump_header(s, \"x-rgw-object-type\", \"Normal\");\n  }\n\n  if (! op_ret) {\n    if (! lo_etag.empty()) {\n      /* Handle etag of Swift API's large objects (DLO/SLO). It's entirerly\n       * legit to perform GET on them through S3 API. In such situation,\n       * a client should receive the composited content with corresponding\n       * etag value. */\n      dump_etag(s, lo_etag);\n    } else {\n      auto iter = attrs.find(RGW_ATTR_ETAG);\n      if (iter != attrs.end()) {\n        dump_etag(s, iter->second.to_str());\n      }\n    }\n\n    for (struct response_attr_param *p = resp_attr_params; p->param; p++) {\n      bool exists;\n      string val = s->info.args.get(p->param, &exists);\n      if (exists) {\n\t/* reject unauthenticated response header manipulation, see\n\t * https://docs.aws.amazon.com/AmazonS3/latest/API/API_GetObject.html */\n\tif (s->auth.identity->is_anonymous()) {\n\t  return -ERR_INVALID_REQUEST;\n\t}\n        /* HTTP specification says no control characters should be present in\n         * header values: https://tools.ietf.org/html/rfc7230#section-3.2\n         *      field-vchar    = VCHAR / obs-text\n         *\n         * Failure to validate this permits a CRLF injection in HTTP headers,\n         * whereas S3 GetObject only permits specific headers.\n         */\n        if(str_has_cntrl(val)) {\n          /* TODO: return a more distinct error in future;\n           * stating what the problem is */\n          return -ERR_INVALID_REQUEST;\n        }\n\n\tif (strcmp(p->param, \"response-content-type\") != 0) {\n\t  response_attrs[p->http_attr] = val;\n\t} else {\n\t  content_type_str = val;\n\t  content_type = content_type_str.c_str();\n\t}\n      }\n    }\n\n    for (auto iter = attrs.begin(); iter != attrs.end(); ++iter) {\n      const char *name = iter->first.c_str();\n      map<string, string>::iterator aiter = rgw_to_http_attrs.find(name);\n      if (aiter != rgw_to_http_attrs.end()) {\n        if (response_attrs.count(aiter->second) == 0) {\n          /* Was not already overridden by a response param. */\n\n          size_t len = iter->second.length();\n          string s(iter->second.c_str(), len);\n          while (len && !s[len - 1]) {\n            --len;\n            s.resize(len);\n          }\n          response_attrs[aiter->second] = s;\n        }\n      } else if (iter->first.compare(RGW_ATTR_CONTENT_TYPE) == 0) {\n        /* Special handling for content_type. */\n        if (!content_type) {\n          content_type_str = rgw_bl_str(iter->second);\n          content_type = content_type_str.c_str();\n        }\n      } else if (strcmp(name, RGW_ATTR_SLO_UINDICATOR) == 0) {\n        // this attr has an extra length prefix from encode() in prior versions\n        dump_header(s, \"X-Object-Meta-Static-Large-Object\", \"True\");\n      } else if (strncmp(name, RGW_ATTR_META_PREFIX,\n\t\t\t sizeof(RGW_ATTR_META_PREFIX)-1) == 0) {\n        /* User custom metadata. */\n        name += sizeof(RGW_ATTR_PREFIX) - 1;\n        dump_header(s, name, iter->second);\n      } else if (iter->first.compare(RGW_ATTR_TAGS) == 0) {\n        RGWObjTags obj_tags;\n        try{\n          auto it = iter->second.cbegin();\n          obj_tags.decode(it);\n        } catch (buffer::error &err) {\n          ldout(s->cct,0) << \"Error caught buffer::error couldn't decode TagSet \" << dendl;\n        }\n        dump_header(s, RGW_AMZ_TAG_COUNT, obj_tags.count());\n      } else if (iter->first.compare(RGW_ATTR_OBJECT_RETENTION) == 0 && get_retention){\n        RGWObjectRetention retention;\n        try {\n          decode(retention, iter->second);\n          dump_header(s, \"x-amz-object-lock-mode\", retention.get_mode());\n          dump_time_header(s, \"x-amz-object-lock-retain-until-date\", retention.get_retain_until_date());\n        } catch (buffer::error& err) {\n          ldpp_dout(this, 0) << \"ERROR: failed to decode RGWObjectRetention\" << dendl;\n        }\n      } else if (iter->first.compare(RGW_ATTR_OBJECT_LEGAL_HOLD) == 0 && get_legal_hold) {\n        RGWObjectLegalHold legal_hold;\n        try {\n          decode(legal_hold, iter->second);\n          dump_header(s, \"x-amz-object-lock-legal-hold\",legal_hold.get_status());\n        } catch (buffer::error& err) {\n          ldpp_dout(this, 0) << \"ERROR: failed to decode RGWObjectLegalHold\" << dendl;\n        }\n      }\n    }\n  }\n\ndone:\n  for (riter = response_attrs.begin(); riter != response_attrs.end();\n       ++riter) {\n    dump_header(s, riter->first, riter->second);\n  }\n\n  if (op_ret == -ERR_NOT_MODIFIED) {\n      end_header(s, this);\n  } else {\n      if (!content_type)\n          content_type = \"binary/octet-stream\";\n\n      end_header(s, this, content_type);\n  }\n\n  if (metadata_bl.length()) {\n    dump_body(s, metadata_bl);\n  }\n  sent_header = true;\n\nsend_data:\n  if (get_data && !op_ret) {\n    int r = dump_body(s, bl.c_str() + bl_ofs, bl_len);\n    if (r < 0)\n      return r;\n  }\n\n  return 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148633,
    "human": "Correct. Without CWE-79",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-79"
    ],
    "code": "static int oidc_handle_session_management_iframe_rp(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session, const char *client_id,\n\t\tconst char *check_session_iframe) {\n\n\toidc_debug(r, \"enter\");\n\n\tconst char *java_script =\n\t\t\t\"    <script type=\\\"text/javascript\\\">\\n\"\n\t\t\t\"      var targetOrigin  = '%s';\\n\"\n\t\t\t\"      var message = '%s' + ' ' + '%s';\\n\"\n\t\t\t\"\t   var timerID;\\n\"\n\t\t\t\"\\n\"\n\t\t\t\"      function checkSession() {\\n\"\n\t\t\t\"        console.debug('checkSession: posting ' + message + ' to ' + targetOrigin);\\n\"\n\t\t\t\"        var win = window.parent.document.getElementById('%s').contentWindow;\\n\"\n\t\t\t\"        win.postMessage( message, targetOrigin);\\n\"\n\t\t\t\"      }\\n\"\n\t\t\t\"\\n\"\n\t\t\t\"      function setTimer() {\\n\"\n\t\t\t\"        checkSession();\\n\"\n\t\t\t\"        timerID = setInterval('checkSession()', %s);\\n\"\n\t\t\t\"      }\\n\"\n\t\t\t\"\\n\"\n\t\t\t\"      function receiveMessage(e) {\\n\"\n\t\t\t\"        console.debug('receiveMessage: ' + e.data + ' from ' + e.origin);\\n\"\n\t\t\t\"        if (e.origin !== targetOrigin ) {\\n\"\n\t\t\t\"          console.debug('receiveMessage: cross-site scripting attack?');\\n\"\n\t\t\t\"          return;\\n\"\n\t\t\t\"        }\\n\"\n\t\t\t\"        if (e.data != 'unchanged') {\\n\"\n\t\t\t\"          clearInterval(timerID);\\n\"\n\t\t\t\"          if (e.data == 'changed') {\\n\"\n\t\t\t\"\t\t     window.location.href = '%s?session=check';\\n\"\n\t\t\t\"          } else {\\n\"\n\t\t\t\"\t\t     window.location.href = '%s?session=logout';\\n\"\n\t\t\t\"          }\\n\"\n\t\t\t\"        }\\n\"\n\t\t\t\"      }\\n\"\n\t\t\t\"\\n\"\n\t\t\t\"      window.addEventListener('message', receiveMessage, false);\\n\"\n\t\t\t\"\\n\"\n\t\t\t\"    </script>\\n\";\n\n\t/* determine the origin for the check_session_iframe endpoint */\n\tchar *origin = apr_pstrdup(r->pool, check_session_iframe);\n\tapr_uri_t uri;\n\tapr_uri_parse(r->pool, check_session_iframe, &uri);\n\tchar *p = strstr(origin, uri.path);\n\t*p = '\\0';\n\n\t/* the element identifier for the OP iframe */\n\tconst char *op_iframe_id = \"openidc-op\";\n\n\t/* restore the OP session_state from the session */\n\tconst char *session_state = oidc_session_get_session_state(r, session);\n\tif (session_state == NULL) {\n\t\toidc_warn(r,\n\t\t\t\t\"no session_state found in the session; the OP does probably not support session management!?\");\n\t\treturn DONE;\n\t}\n\n\tchar *s_poll_interval = NULL;\n\toidc_util_get_request_parameter(r, \"poll\", &s_poll_interval);\n\tif (s_poll_interval == NULL)\n\t\ts_poll_interval = \"3000\";\n\n\tconst char *redirect_uri = oidc_get_redirect_uri(r, c);\n\tjava_script = apr_psprintf(r->pool, java_script, origin, client_id,\n\t\t\tsession_state, op_iframe_id, s_poll_interval, redirect_uri,\n\t\t\tredirect_uri);\n\n\treturn oidc_util_html_send(r, NULL, java_script, \"setTimer\", NULL, DONE);\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149954,
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-79"
    ],
    "code": "static int oidc_handle_session_management_iframe_rp(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session, const char *client_id,\n\t\tconst char *check_session_iframe) {\n\n\toidc_debug(r, \"enter\");\n\n\tconst char *java_script =\n\t\t\t\"    <script type=\\\"text/javascript\\\">\\n\"\n\t\t\t\"      var targetOrigin  = '%s';\\n\"\n\t\t\t\"      var message = '%s' + ' ' + '%s';\\n\"\n\t\t\t\"\t   var timerID;\\n\"\n\t\t\t\"\\n\"\n\t\t\t\"      function checkSession() {\\n\"\n\t\t\t\"        console.debug('checkSession: posting ' + message + ' to ' + targetOrigin);\\n\"\n\t\t\t\"        var win = window.parent.document.getElementById('%s').contentWindow;\\n\"\n\t\t\t\"        win.postMessage( message, targetOrigin);\\n\"\n\t\t\t\"      }\\n\"\n\t\t\t\"\\n\"\n\t\t\t\"      function setTimer() {\\n\"\n\t\t\t\"        checkSession();\\n\"\n\t\t\t\"        timerID = setInterval('checkSession()', %d);\\n\"\n\t\t\t\"      }\\n\"\n\t\t\t\"\\n\"\n\t\t\t\"      function receiveMessage(e) {\\n\"\n\t\t\t\"        console.debug('receiveMessage: ' + e.data + ' from ' + e.origin);\\n\"\n\t\t\t\"        if (e.origin !== targetOrigin ) {\\n\"\n\t\t\t\"          console.debug('receiveMessage: cross-site scripting attack?');\\n\"\n\t\t\t\"          return;\\n\"\n\t\t\t\"        }\\n\"\n\t\t\t\"        if (e.data != 'unchanged') {\\n\"\n\t\t\t\"          clearInterval(timerID);\\n\"\n\t\t\t\"          if (e.data == 'changed') {\\n\"\n\t\t\t\"\t\t     window.location.href = '%s?session=check';\\n\"\n\t\t\t\"          } else {\\n\"\n\t\t\t\"\t\t     window.location.href = '%s?session=logout';\\n\"\n\t\t\t\"          }\\n\"\n\t\t\t\"        }\\n\"\n\t\t\t\"      }\\n\"\n\t\t\t\"\\n\"\n\t\t\t\"      window.addEventListener('message', receiveMessage, false);\\n\"\n\t\t\t\"\\n\"\n\t\t\t\"    </script>\\n\";\n\n\t/* determine the origin for the check_session_iframe endpoint */\n\tchar *origin = apr_pstrdup(r->pool, check_session_iframe);\n\tapr_uri_t uri;\n\tapr_uri_parse(r->pool, check_session_iframe, &uri);\n\tchar *p = strstr(origin, uri.path);\n\t*p = '\\0';\n\n\t/* the element identifier for the OP iframe */\n\tconst char *op_iframe_id = \"openidc-op\";\n\n\t/* restore the OP session_state from the session */\n\tconst char *session_state = oidc_session_get_session_state(r, session);\n\tif (session_state == NULL) {\n\t\toidc_warn(r,\n\t\t\t\t\"no session_state found in the session; the OP does probably not support session management!?\");\n\t\treturn DONE;\n\t}\n\n\tchar *s_poll_interval = NULL;\n\toidc_util_get_request_parameter(r, \"poll\", &s_poll_interval);\n\tint poll_interval = s_poll_interval ? strtol(s_poll_interval, NULL, 10) : 0;\n\tif ((poll_interval <= 0) || (poll_interval > 3600 * 24))\n\t\tpoll_interval = 3000;\n\n\tconst char *redirect_uri = oidc_get_redirect_uri(r, c);\n\tjava_script = apr_psprintf(r->pool, java_script, origin, client_id,\n\t\t\tsession_state, op_iframe_id, poll_interval, redirect_uri,\n\t\t\tredirect_uri);\n\n\treturn oidc_util_html_send(r, NULL, java_script, \"setTimer\", NULL, DONE);\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149955,
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  }
]