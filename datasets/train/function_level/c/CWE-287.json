[
  {
    "CWE_ID": [
      "CWE-287"
    ],
    "code": "static SECStatus SelectClientCert(void *arg, PRFileDesc *sock,\n                                  struct CERTDistNamesStr *caNames,\n                                  struct CERTCertificateStr **pRetCert,\n                                  struct SECKEYPrivateKeyStr **pRetKey)\n{\n   struct ssl_connect_data *connssl = (struct ssl_connect_data *)arg;\n   struct Curl_easy *data = connssl->data;\n   const char *nickname = connssl->client_nickname;\n \n   if(connssl->obj_clicert) {\n     /* use the cert/key provided by PEM reader */\n    static const char pem_slotname[] = \"PEM Token #1\";\n     SECItem cert_der = { 0, NULL, 0 };\n     void *proto_win = SSL_RevealPinArg(sock);\n     struct CERTCertificateStr *cert;\n    struct SECKEYPrivateKeyStr *key;\n\n    PK11SlotInfo *slot = PK11_FindSlotByName(pem_slotname);\n    if(NULL == slot) {\n      failf(data, \"NSS: PK11 slot not found: %s\", pem_slotname);\n      return SECFailure;\n    }\n\n    if(PK11_ReadRawAttribute(PK11_TypeGeneric, connssl->obj_clicert, CKA_VALUE,\n                             &cert_der) != SECSuccess) {\n      failf(data, \"NSS: CKA_VALUE not found in PK11 generic object\");\n      PK11_FreeSlot(slot);\n      return SECFailure;\n    }\n\n    cert = PK11_FindCertFromDERCertItem(slot, &cert_der, proto_win);\n    SECITEM_FreeItem(&cert_der, PR_FALSE);\n    if(NULL == cert) {\n      failf(data, \"NSS: client certificate from file not found\");\n      PK11_FreeSlot(slot);\n      return SECFailure;\n    }\n\n    key = PK11_FindPrivateKeyFromCert(slot, cert, NULL);\n    PK11_FreeSlot(slot);\n    if(NULL == key) {\n      failf(data, \"NSS: private key from file not found\");\n      CERT_DestroyCertificate(cert);\n      return SECFailure;\n    }\n\n    infof(data, \"NSS: client certificate from file\\n\");\n    display_cert_info(data, cert);\n\n    *pRetCert = cert;\n    *pRetKey = key;\n    return SECSuccess;\n  }\n\n  /* use the default NSS hook */\n  if(SECSuccess != NSS_GetClientAuthData((void *)nickname, sock, caNames,\n                                          pRetCert, pRetKey)\n      || NULL == *pRetCert) {\n\n    if(NULL == nickname)\n      failf(data, \"NSS: client certificate not found (nickname not \"\n            \"specified)\");\n    else\n      failf(data, \"NSS: client certificate not found: %s\", nickname);\n\n    return SECFailure;\n  }\n\n  /* get certificate nickname if any */\n  nickname = (*pRetCert)->nickname;\n   if(NULL == nickname)\n     nickname = \"[unknown]\";\n \n   if(NULL == *pRetKey) {\n     failf(data, \"NSS: private key not found for certificate: %s\", nickname);\n     return SECFailure;\n  }\n\n  infof(data, \"NSS: using client certificate: %s\\n\", nickname);\n  display_cert_info(data, *pRetCert);\n  return SECSuccess;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142075,
    "RELATED_CWE": [
      "CWE-862",
      "CWE-285",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-287"
    ],
    "code": "static SECStatus SelectClientCert(void *arg, PRFileDesc *sock,\n                                  struct CERTDistNamesStr *caNames,\n                                  struct CERTCertificateStr **pRetCert,\n                                  struct SECKEYPrivateKeyStr **pRetKey)\n{\n   struct ssl_connect_data *connssl = (struct ssl_connect_data *)arg;\n   struct Curl_easy *data = connssl->data;\n   const char *nickname = connssl->client_nickname;\n  static const char pem_slotname[] = \"PEM Token #1\";\n \n   if(connssl->obj_clicert) {\n     /* use the cert/key provided by PEM reader */\n     SECItem cert_der = { 0, NULL, 0 };\n     void *proto_win = SSL_RevealPinArg(sock);\n     struct CERTCertificateStr *cert;\n    struct SECKEYPrivateKeyStr *key;\n\n    PK11SlotInfo *slot = PK11_FindSlotByName(pem_slotname);\n    if(NULL == slot) {\n      failf(data, \"NSS: PK11 slot not found: %s\", pem_slotname);\n      return SECFailure;\n    }\n\n    if(PK11_ReadRawAttribute(PK11_TypeGeneric, connssl->obj_clicert, CKA_VALUE,\n                             &cert_der) != SECSuccess) {\n      failf(data, \"NSS: CKA_VALUE not found in PK11 generic object\");\n      PK11_FreeSlot(slot);\n      return SECFailure;\n    }\n\n    cert = PK11_FindCertFromDERCertItem(slot, &cert_der, proto_win);\n    SECITEM_FreeItem(&cert_der, PR_FALSE);\n    if(NULL == cert) {\n      failf(data, \"NSS: client certificate from file not found\");\n      PK11_FreeSlot(slot);\n      return SECFailure;\n    }\n\n    key = PK11_FindPrivateKeyFromCert(slot, cert, NULL);\n    PK11_FreeSlot(slot);\n    if(NULL == key) {\n      failf(data, \"NSS: private key from file not found\");\n      CERT_DestroyCertificate(cert);\n      return SECFailure;\n    }\n\n    infof(data, \"NSS: client certificate from file\\n\");\n    display_cert_info(data, cert);\n\n    *pRetCert = cert;\n    *pRetKey = key;\n    return SECSuccess;\n  }\n\n  /* use the default NSS hook */\n  if(SECSuccess != NSS_GetClientAuthData((void *)nickname, sock, caNames,\n                                          pRetCert, pRetKey)\n      || NULL == *pRetCert) {\n\n    if(NULL == nickname)\n      failf(data, \"NSS: client certificate not found (nickname not \"\n            \"specified)\");\n    else\n      failf(data, \"NSS: client certificate not found: %s\", nickname);\n\n    return SECFailure;\n  }\n\n  /* get certificate nickname if any */\n  nickname = (*pRetCert)->nickname;\n   if(NULL == nickname)\n     nickname = \"[unknown]\";\n \n  if(!strncmp(nickname, pem_slotname, sizeof(pem_slotname) - 1U)) {\n    failf(data, \"NSS: refusing previously loaded certificate from file: %s\",\n          nickname);\n    return SECFailure;\n  }\n\n   if(NULL == *pRetKey) {\n     failf(data, \"NSS: private key not found for certificate: %s\", nickname);\n     return SECFailure;\n  }\n\n  infof(data, \"NSS: using client certificate: %s\\n\", nickname);\n  display_cert_info(data, *pRetCert);\n  return SECSuccess;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142076,
    "RELATED_CWE": [
      "CWE-862",
      "CWE-285",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-287"
    ],
    "code": "int m_authenticate(struct Client* cptr, struct Client* sptr, int parc, char* parv[])\n{\n  struct Client* acptr;\n  int first = 0;\n  char realhost[HOSTLEN + 3];\n  char *hoststr = (cli_sockhost(cptr) ? cli_sockhost(cptr) : cli_sock_ip(cptr));\n\n  if (!CapActive(cptr, CAP_SASL))\n    return 0;\n\n  if (parc < 2) /* have enough parameters? */\n    return need_more_params(cptr, \"AUTHENTICATE\");\n\n  if (strlen(parv[1]) > 400)\n    return send_reply(cptr, ERR_SASLTOOLONG);\n\n  if (IsSASLComplete(cptr))\n    return send_reply(cptr, ERR_SASLALREADY);\n\n  /* Look up the target server */\n  if (!(acptr = cli_saslagent(cptr))) {\n    if (strcmp(feature_str(FEAT_SASL_SERVER), \"*\"))\n      acptr = find_match_server((char *)feature_str(FEAT_SASL_SERVER));\n    else\n      acptr = NULL;\n  }\n\n  if (!acptr && strcmp(feature_str(FEAT_SASL_SERVER), \"*\"))\n    return send_reply(cptr, ERR_SASLFAIL, \": service unavailable\");\n\n  /* If it's to us, do nothing; otherwise, forward the query */\n  if (acptr && IsMe(acptr))\n    return 0;\n\n  /* Generate an SASL session cookie if not already generated */\n  if (!cli_saslcookie(cptr)) {\n    do {\n      cli_saslcookie(cptr) = ircrandom() & 0x7fffffff;\n    } while (!cli_saslcookie(cptr));\n    first = 1;\n  }\n\n  if (strchr(hoststr, ':') != NULL)\n    ircd_snprintf(0, realhost, sizeof(realhost), \"[%s]\", hoststr);\n  else\n    ircd_strncpy(realhost, hoststr, sizeof(realhost));\n \n   if (acptr) {\n     if (first) {\n       if (!EmptyString(cli_sslclifp(cptr)))\n         sendcmdto_one(&me, CMD_SASL, acptr, \"%C %C!%u.%u S %s :%s\", acptr, &me,\n                       cli_fd(cptr), cli_saslcookie(cptr),\n                      parv[1], cli_sslclifp(cptr));\n      else\n        sendcmdto_one(&me, CMD_SASL, acptr, \"%C %C!%u.%u S :%s\", acptr, &me,\n                      cli_fd(cptr), cli_saslcookie(cptr), parv[1]);\n      if (feature_bool(FEAT_SASL_SENDHOST))\n        sendcmdto_one(&me, CMD_SASL, acptr, \"%C %C!%u.%u H :%s@%s:%s\", acptr, &me,\n                      cli_fd(cptr), cli_saslcookie(cptr), cli_username(cptr),\n                      realhost, cli_sock_ip(cptr));\n    } else {\n      sendcmdto_one(&me, CMD_SASL, acptr, \"%C %C!%u.%u C :%s\", acptr, &me,\n                    cli_fd(cptr), cli_saslcookie(cptr), parv[1]);\n     }\n   } else {\n     if (first) {\n       if (!EmptyString(cli_sslclifp(cptr)))\n         sendcmdto_serv_butone(&me, CMD_SASL, cptr, \"* %C!%u.%u S %s :%s\", &me,\n                               cli_fd(cptr), cli_saslcookie(cptr),\n                              parv[1], cli_sslclifp(cptr));\n      else\n        sendcmdto_serv_butone(&me, CMD_SASL, cptr, \"* %C!%u.%u S :%s\", &me,\n                              cli_fd(cptr), cli_saslcookie(cptr), parv[1]);\n      if (feature_bool(FEAT_SASL_SENDHOST))\n        sendcmdto_serv_butone(&me, CMD_SASL, cptr, \"* %C!%u.%u H :%s@%s:%s\", &me,\n                              cli_fd(cptr), cli_saslcookie(cptr), cli_username(cptr),\n                              realhost, cli_sock_ip(cptr));\n    } else {\n      sendcmdto_serv_butone(&me, CMD_SASL, cptr, \"* %C!%u.%u C :%s\", &me,\n                            cli_fd(cptr), cli_saslcookie(cptr), parv[1]);\n    }\n  }\n\n  if (!t_active(&cli_sasltimeout(cptr)))\n    timer_add(timer_init(&cli_sasltimeout(cptr)), sasl_timeout_callback, (void*) cptr,\n              TT_RELATIVE, feature_int(FEAT_SASL_TIMEOUT));\n\n  return 0;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142801,
    "RELATED_CWE": [
      "CWE-862",
      "CWE-285",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-287"
    ],
    "code": "int m_authenticate(struct Client* cptr, struct Client* sptr, int parc, char* parv[])\n{\n  struct Client* acptr;\n  int first = 0;\n  char realhost[HOSTLEN + 3];\n  char *hoststr = (cli_sockhost(cptr) ? cli_sockhost(cptr) : cli_sock_ip(cptr));\n\n  if (!CapActive(cptr, CAP_SASL))\n    return 0;\n\n  if (parc < 2) /* have enough parameters? */\n    return need_more_params(cptr, \"AUTHENTICATE\");\n\n  if (strlen(parv[1]) > 400)\n    return send_reply(cptr, ERR_SASLTOOLONG);\n\n  if (IsSASLComplete(cptr))\n    return send_reply(cptr, ERR_SASLALREADY);\n\n  /* Look up the target server */\n  if (!(acptr = cli_saslagent(cptr))) {\n    if (strcmp(feature_str(FEAT_SASL_SERVER), \"*\"))\n      acptr = find_match_server((char *)feature_str(FEAT_SASL_SERVER));\n    else\n      acptr = NULL;\n  }\n\n  if (!acptr && strcmp(feature_str(FEAT_SASL_SERVER), \"*\"))\n    return send_reply(cptr, ERR_SASLFAIL, \": service unavailable\");\n\n  /* If it's to us, do nothing; otherwise, forward the query */\n  if (acptr && IsMe(acptr))\n    return 0;\n\n  /* Generate an SASL session cookie if not already generated */\n  if (!cli_saslcookie(cptr)) {\n    do {\n      cli_saslcookie(cptr) = ircrandom() & 0x7fffffff;\n    } while (!cli_saslcookie(cptr));\n    first = 1;\n  }\n\n  if (strchr(hoststr, ':') != NULL)\n    ircd_snprintf(0, realhost, sizeof(realhost), \"[%s]\", hoststr);\n  else\n    ircd_strncpy(realhost, hoststr, sizeof(realhost));\n \n   if (acptr) {\n     if (first) {\n      if (*parv[1] == ':' || strchr(parv[1], ' '))\n\t\treturn exit_client(cptr, sptr, sptr, \"Malformed AUTHENTICATE\");\n       if (!EmptyString(cli_sslclifp(cptr)))\n         sendcmdto_one(&me, CMD_SASL, acptr, \"%C %C!%u.%u S %s :%s\", acptr, &me,\n                       cli_fd(cptr), cli_saslcookie(cptr),\n                      parv[1], cli_sslclifp(cptr));\n      else\n        sendcmdto_one(&me, CMD_SASL, acptr, \"%C %C!%u.%u S :%s\", acptr, &me,\n                      cli_fd(cptr), cli_saslcookie(cptr), parv[1]);\n      if (feature_bool(FEAT_SASL_SENDHOST))\n        sendcmdto_one(&me, CMD_SASL, acptr, \"%C %C!%u.%u H :%s@%s:%s\", acptr, &me,\n                      cli_fd(cptr), cli_saslcookie(cptr), cli_username(cptr),\n                      realhost, cli_sock_ip(cptr));\n    } else {\n      sendcmdto_one(&me, CMD_SASL, acptr, \"%C %C!%u.%u C :%s\", acptr, &me,\n                    cli_fd(cptr), cli_saslcookie(cptr), parv[1]);\n     }\n   } else {\n     if (first) {\n      if (*parv[1] == ':' || strchr(parv[1], ' '))\n        return exit_client(cptr, sptr, sptr, \"Malformed AUTHENTICATE\");\n       if (!EmptyString(cli_sslclifp(cptr)))\n         sendcmdto_serv_butone(&me, CMD_SASL, cptr, \"* %C!%u.%u S %s :%s\", &me,\n                               cli_fd(cptr), cli_saslcookie(cptr),\n                              parv[1], cli_sslclifp(cptr));\n      else\n        sendcmdto_serv_butone(&me, CMD_SASL, cptr, \"* %C!%u.%u S :%s\", &me,\n                              cli_fd(cptr), cli_saslcookie(cptr), parv[1]);\n      if (feature_bool(FEAT_SASL_SENDHOST))\n        sendcmdto_serv_butone(&me, CMD_SASL, cptr, \"* %C!%u.%u H :%s@%s:%s\", &me,\n                              cli_fd(cptr), cli_saslcookie(cptr), cli_username(cptr),\n                              realhost, cli_sock_ip(cptr));\n    } else {\n      sendcmdto_serv_butone(&me, CMD_SASL, cptr, \"* %C!%u.%u C :%s\", &me,\n                            cli_fd(cptr), cli_saslcookie(cptr), parv[1]);\n    }\n  }\n\n  if (!t_active(&cli_sasltimeout(cptr)))\n    timer_add(timer_init(&cli_sasltimeout(cptr)), sasl_timeout_callback, (void*) cptr,\n              TT_RELATIVE, feature_int(FEAT_SASL_TIMEOUT));\n\n  return 0;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142802,
    "RELATED_CWE": [
      "CWE-862",
      "CWE-285",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-287"
    ],
    "code": "CMD_FUNC(m_authenticate)\n{\n\taClient *agent_p = NULL;\n\n\t/* Failing to use CAP REQ for sasl is a protocol violation. */\n\tif (!SASL_SERVER || !MyConnect(sptr) || BadPtr(parv[1]) || !CHECKPROTO(sptr, PROTO_SASL))\n\t\treturn 0;\n\n\tif (sptr->local->sasl_complete)\n\t{\n\t\tsendto_one(sptr, err_str(ERR_SASLALREADY), me.name, BadPtr(sptr->name) ? \"*\" : sptr->name);\n \t\treturn 0;\n \t}\n \n \tif (strlen(parv[1]) > 400)\n \t{\n \t\tsendto_one(sptr, err_str(ERR_SASLTOOLONG), me.name, BadPtr(sptr->name) ? \"*\" : sptr->name);\n\t\treturn 0;\n\t}\n\n\tif (*sptr->local->sasl_agent)\n\t\tagent_p = find_client(sptr->local->sasl_agent, NULL);\n\n\tif (agent_p == NULL)\n\t{\n\t\tchar *addr = BadPtr(sptr->ip) ? \"0\" : sptr->ip;\n\t\tchar *certfp = moddata_client_get(sptr, \"certfp\");\n\n\t\tsendto_server(NULL, 0, 0, \":%s SASL %s %s H %s %s\",\n\t\t    me.name, SASL_SERVER, encode_puid(sptr), addr, addr);\n\n\t\tif (certfp)\n\t\t\tsendto_server(NULL, 0, 0, \":%s SASL %s %s S %s %s\",\n\t\t\t    me.name, SASL_SERVER, encode_puid(sptr), parv[1], certfp);\n\t\telse\n\t\t\tsendto_server(NULL, 0, 0, \":%s SASL %s %s S %s\",\n\t\t\t    me.name, SASL_SERVER, encode_puid(sptr), parv[1]);\n\t}\n\telse\n\t\tsendto_server(NULL, 0, 0, \":%s SASL %s %s C %s\",\n\t\t    me.name, AGENT_SID(agent_p), encode_puid(sptr), parv[1]);\n\n\tsptr->local->sasl_out++;\n\n\treturn 0;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142803,
    "RELATED_CWE": [
      "CWE-862",
      "CWE-285",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-287"
    ],
    "code": "CMD_FUNC(m_authenticate)\n{\n\taClient *agent_p = NULL;\n\n\t/* Failing to use CAP REQ for sasl is a protocol violation. */\n\tif (!SASL_SERVER || !MyConnect(sptr) || BadPtr(parv[1]) || !CHECKPROTO(sptr, PROTO_SASL))\n\t\treturn 0;\n\n\tif (sptr->local->sasl_complete)\n\t{\n\t\tsendto_one(sptr, err_str(ERR_SASLALREADY), me.name, BadPtr(sptr->name) ? \"*\" : sptr->name);\n \t\treturn 0;\n \t}\n \n\tif ((parv[1][0] == ':') || strchr(parv[1], ' '))\n\t{\n\t\tsendto_one(sptr, err_str(ERR_CANNOTDOCOMMAND), me.name, \"*\", \"AUTHENTICATE\", \"Invalid parameter\");\n\t\treturn 0;\n\t}\n\n \tif (strlen(parv[1]) > 400)\n \t{\n \t\tsendto_one(sptr, err_str(ERR_SASLTOOLONG), me.name, BadPtr(sptr->name) ? \"*\" : sptr->name);\n\t\treturn 0;\n\t}\n\n\tif (*sptr->local->sasl_agent)\n\t\tagent_p = find_client(sptr->local->sasl_agent, NULL);\n\n\tif (agent_p == NULL)\n\t{\n\t\tchar *addr = BadPtr(sptr->ip) ? \"0\" : sptr->ip;\n\t\tchar *certfp = moddata_client_get(sptr, \"certfp\");\n\n\t\tsendto_server(NULL, 0, 0, \":%s SASL %s %s H %s %s\",\n\t\t    me.name, SASL_SERVER, encode_puid(sptr), addr, addr);\n\n\t\tif (certfp)\n\t\t\tsendto_server(NULL, 0, 0, \":%s SASL %s %s S %s %s\",\n\t\t\t    me.name, SASL_SERVER, encode_puid(sptr), parv[1], certfp);\n\t\telse\n\t\t\tsendto_server(NULL, 0, 0, \":%s SASL %s %s S %s\",\n\t\t\t    me.name, SASL_SERVER, encode_puid(sptr), parv[1]);\n\t}\n\telse\n\t\tsendto_server(NULL, 0, 0, \":%s SASL %s %s C %s\",\n\t\t    me.name, AGENT_SID(agent_p), encode_puid(sptr), parv[1]);\n\n\tsptr->local->sasl_out++;\n\n\treturn 0;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142804,
    "RELATED_CWE": [
      "CWE-862",
      "CWE-285",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-287"
    ],
    "code": "static void start_auth_request(PgSocket *client, const char *username)\n{\n \tint res;\n \tPktBuf *buf;\n \n\tclient->auth_user = client->db->auth_user;\n \t/* have to fetch user info from db */\n \tclient->pool = get_pool(client->db, client->db->auth_user);\n \tif (!find_server(client)) {\n\t\tclient->wait_for_user_conn = true;\n\t\treturn;\n\t}\n\tslog_noise(client, \"Doing auth_conn query\");\n\tclient->wait_for_user_conn = false;\n\tclient->wait_for_user = true;\n\tif (!sbuf_pause(&client->sbuf)) {\n\t\trelease_server(client->link);\n\t\tdisconnect_client(client, true, \"pause failed\");\n\t\treturn;\n\t}\n\tclient->link->ready = 0;\n\n\tres = 0;\n\tbuf = pktbuf_dynamic(512);\n\tif (buf) {\n\t\tpktbuf_write_ExtQuery(buf, cf_auth_query, 1, username);\n\t\tres = pktbuf_send_immediate(buf, client->link);\n\t\tpktbuf_free(buf);\n\t\t/*\n\t\t * Should do instead:\n\t\t *   res = pktbuf_send_queued(buf, client->link);\n\t\t * but that needs better integration with SBuf.\n\t\t */\n\t}\n\tif (!res)\n\t\tdisconnect_server(client->link, false, \"unable to send login query\");\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142827,
    "RELATED_CWE": [
      "CWE-862",
      "CWE-285",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-287"
    ],
    "code": "static void start_auth_request(PgSocket *client, const char *username)\n{\n \tint res;\n \tPktBuf *buf;\n \n \t/* have to fetch user info from db */\n \tclient->pool = get_pool(client->db, client->db->auth_user);\n \tif (!find_server(client)) {\n\t\tclient->wait_for_user_conn = true;\n\t\treturn;\n\t}\n\tslog_noise(client, \"Doing auth_conn query\");\n\tclient->wait_for_user_conn = false;\n\tclient->wait_for_user = true;\n\tif (!sbuf_pause(&client->sbuf)) {\n\t\trelease_server(client->link);\n\t\tdisconnect_client(client, true, \"pause failed\");\n\t\treturn;\n\t}\n\tclient->link->ready = 0;\n\n\tres = 0;\n\tbuf = pktbuf_dynamic(512);\n\tif (buf) {\n\t\tpktbuf_write_ExtQuery(buf, cf_auth_query, 1, username);\n\t\tres = pktbuf_send_immediate(buf, client->link);\n\t\tpktbuf_free(buf);\n\t\t/*\n\t\t * Should do instead:\n\t\t *   res = pktbuf_send_queued(buf, client->link);\n\t\t * but that needs better integration with SBuf.\n\t\t */\n\t}\n\tif (!res)\n\t\tdisconnect_server(client->link, false, \"unable to send login query\");\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142828,
    "RELATED_CWE": [
      "CWE-862",
      "CWE-285",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-287"
    ],
    "code": "void OneClickSigninHelper::ShowInfoBarIfPossible(net::URLRequest* request,\n                                                 ProfileIOData* io_data,\n                                                 int child_id,\n                                                 int route_id) {\n  std::string google_chrome_signin_value;\n  std::string google_accounts_signin_value;\n  request->GetResponseHeaderByName(\"Google-Chrome-SignIn\",\n                                   &google_chrome_signin_value);\n  request->GetResponseHeaderByName(\"Google-Accounts-SignIn\",\n                                   &google_accounts_signin_value);\n\n  if (!google_accounts_signin_value.empty() ||\n      !google_chrome_signin_value.empty()) {\n    VLOG(1) << \"OneClickSigninHelper::ShowInfoBarIfPossible:\"\n            << \" g-a-s='\" << google_accounts_signin_value << \"'\"\n             << \" g-c-s='\" << google_chrome_signin_value << \"'\";\n   }\n \n  if (!gaia::IsGaiaSignonRealm(request->original_url().GetOrigin()))\n     return;\n \n  std::vector<std::pair<std::string, std::string> > pairs;\n  base::SplitStringIntoKeyValuePairs(google_accounts_signin_value, '=', ',',\n                                     &pairs);\n  std::string session_index;\n  std::string email;\n  for (size_t i = 0; i < pairs.size(); ++i) {\n    const std::pair<std::string, std::string>& pair = pairs[i];\n    const std::string& key = pair.first;\n    const std::string& value = pair.second;\n    if (key == \"email\") {\n      TrimString(value, \"\\\"\", &email);\n    } else if (key == \"sessionindex\") {\n      session_index = value;\n    }\n  }\n\n  if (!email.empty())\n    io_data->set_reverse_autologin_pending_email(email);\n\n  if (!email.empty() || !session_index.empty()) {\n    VLOG(1) << \"OneClickSigninHelper::ShowInfoBarIfPossible:\"\n            << \" email=\" << email\n            << \" sessionindex=\" << session_index;\n  }\n\n  AutoAccept auto_accept = AUTO_ACCEPT_NONE;\n  signin::Source source = signin::SOURCE_UNKNOWN;\n  GURL continue_url;\n  std::vector<std::string> tokens;\n  base::SplitString(google_chrome_signin_value, ',', &tokens);\n  for (size_t i = 0; i < tokens.size(); ++i) {\n    const std::string& token = tokens[i];\n    if (token == \"accepted\") {\n      auto_accept = AUTO_ACCEPT_ACCEPTED;\n    } else if (token == \"configure\") {\n      auto_accept = AUTO_ACCEPT_CONFIGURE;\n    } else if (token == \"rejected-for-profile\") {\n      auto_accept = AUTO_ACCEPT_REJECTED_FOR_PROFILE;\n    }\n  }\n\n  source = GetSigninSource(request->url(), &continue_url);\n  if (source != signin::SOURCE_UNKNOWN)\n    auto_accept = AUTO_ACCEPT_EXPLICIT;\n\n  if (auto_accept != AUTO_ACCEPT_NONE) {\n    VLOG(1) << \"OneClickSigninHelper::ShowInfoBarIfPossible:\"\n            << \" auto_accept=\" << auto_accept;\n  }\n\n  if (session_index.empty() && email.empty() &&\n      auto_accept == AUTO_ACCEPT_NONE && !continue_url.is_valid()) {\n    return;\n  }\n\n  content::BrowserThread::PostTask(\n      content::BrowserThread::UI, FROM_HERE,\n      base::Bind(&OneClickSigninHelper::ShowInfoBarUIThread, session_index,\n                 email, auto_accept, source, continue_url, child_id, route_id));\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143555,
    "RELATED_CWE": [
      "CWE-862",
      "CWE-285",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-287"
    ],
    "code": "void OneClickSigninHelper::ShowInfoBarIfPossible(net::URLRequest* request,\n                                                 ProfileIOData* io_data,\n                                                 int child_id,\n                                                 int route_id) {\n  std::string google_chrome_signin_value;\n  std::string google_accounts_signin_value;\n  request->GetResponseHeaderByName(\"Google-Chrome-SignIn\",\n                                   &google_chrome_signin_value);\n  request->GetResponseHeaderByName(\"Google-Accounts-SignIn\",\n                                   &google_accounts_signin_value);\n\n  if (!google_accounts_signin_value.empty() ||\n      !google_chrome_signin_value.empty()) {\n    VLOG(1) << \"OneClickSigninHelper::ShowInfoBarIfPossible:\"\n            << \" g-a-s='\" << google_accounts_signin_value << \"'\"\n             << \" g-c-s='\" << google_chrome_signin_value << \"'\";\n   }\n \n  if (!gaia::IsGaiaSignonRealm(request->url().GetOrigin()))\n     return;\n \n  std::vector<std::pair<std::string, std::string> > pairs;\n  base::SplitStringIntoKeyValuePairs(google_accounts_signin_value, '=', ',',\n                                     &pairs);\n  std::string session_index;\n  std::string email;\n  for (size_t i = 0; i < pairs.size(); ++i) {\n    const std::pair<std::string, std::string>& pair = pairs[i];\n    const std::string& key = pair.first;\n    const std::string& value = pair.second;\n    if (key == \"email\") {\n      TrimString(value, \"\\\"\", &email);\n    } else if (key == \"sessionindex\") {\n      session_index = value;\n    }\n  }\n\n  if (!email.empty())\n    io_data->set_reverse_autologin_pending_email(email);\n\n  if (!email.empty() || !session_index.empty()) {\n    VLOG(1) << \"OneClickSigninHelper::ShowInfoBarIfPossible:\"\n            << \" email=\" << email\n            << \" sessionindex=\" << session_index;\n  }\n\n  AutoAccept auto_accept = AUTO_ACCEPT_NONE;\n  signin::Source source = signin::SOURCE_UNKNOWN;\n  GURL continue_url;\n  std::vector<std::string> tokens;\n  base::SplitString(google_chrome_signin_value, ',', &tokens);\n  for (size_t i = 0; i < tokens.size(); ++i) {\n    const std::string& token = tokens[i];\n    if (token == \"accepted\") {\n      auto_accept = AUTO_ACCEPT_ACCEPTED;\n    } else if (token == \"configure\") {\n      auto_accept = AUTO_ACCEPT_CONFIGURE;\n    } else if (token == \"rejected-for-profile\") {\n      auto_accept = AUTO_ACCEPT_REJECTED_FOR_PROFILE;\n    }\n  }\n\n  source = GetSigninSource(request->url(), &continue_url);\n  if (source != signin::SOURCE_UNKNOWN)\n    auto_accept = AUTO_ACCEPT_EXPLICIT;\n\n  if (auto_accept != AUTO_ACCEPT_NONE) {\n    VLOG(1) << \"OneClickSigninHelper::ShowInfoBarIfPossible:\"\n            << \" auto_accept=\" << auto_accept;\n  }\n\n  if (session_index.empty() && email.empty() &&\n      auto_accept == AUTO_ACCEPT_NONE && !continue_url.is_valid()) {\n    return;\n  }\n\n  content::BrowserThread::PostTask(\n      content::BrowserThread::UI, FROM_HERE,\n      base::Bind(&OneClickSigninHelper::ShowInfoBarUIThread, session_index,\n                 email, auto_accept, source, continue_url, child_id, route_id));\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143556,
    "RELATED_CWE": [
      "CWE-862",
      "CWE-285",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-287"
    ],
    "code": " void FormAssociatedElement::formRemovedFromTree(const Node* formRoot)\n {\n     ASSERT(m_form);\n    if (toHTMLElement(this)->highestAncestor() != formRoot)\n        setForm(0);\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143607,
    "RELATED_CWE": [
      "CWE-862",
      "CWE-285",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-287"
    ],
    "code": " void FormAssociatedElement::formRemovedFromTree(const Node* formRoot)\n {\n     ASSERT(m_form);\n    if (toHTMLElement(this)->highestAncestor() == formRoot)\n        return;\n    RefPtr<HTMLElement> protector(toHTMLElement(this));\n    setForm(0);\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143608,
    "RELATED_CWE": [
      "CWE-862",
      "CWE-285",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-287"
    ],
    "code": "cherokee_validator_ldap_check (cherokee_validator_ldap_t *ldap,\n                               cherokee_connection_t     *conn)\n{\n\tint                              re;\n\tret_t                            ret;\n\tsize_t                           size;\n\tchar                            *dn;\n\tLDAPMessage                     *message;\n\tLDAPMessage                     *first;\n\tchar                            *attrs[] = { LDAP_NO_ATTRS, NULL };\n\tcherokee_validator_ldap_props_t *props   = VAL_LDAP_PROP(ldap);\n\n \t/* Sanity checks\n \t */\n \tif ((conn->validator == NULL) ||\n\t    cherokee_buffer_is_empty (&conn->validator->user))\n \t\treturn ret_error;\n \n \tsize = cherokee_buffer_cnt_cspn (&conn->validator->user, 0, \"*()\");\n\tif (size != conn->validator->user.len)\n\t\treturn ret_error;\n\n\t/* Build filter\n\t */\n\tret = init_filter (ldap, props, conn);\n\tif (ret != ret_ok)\n\t\treturn ret;\n\n\t/* Search\n\t */\n\tre = ldap_search_s (ldap->conn, props->basedn.buf, LDAP_SCOPE_SUBTREE, ldap->filter.buf, attrs, 0, &message);\n\tif (re != LDAP_SUCCESS) {\n\t\tLOG_ERROR (CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH,\n\t\t           props->filter.buf ? props->filter.buf : \"\");\n\t\treturn ret_error;\n\t}\n\n\tTRACE (ENTRIES, \"subtree search (%s): done\\n\", ldap->filter.buf ? ldap->filter.buf : \"\");\n\n\t/* Check that there a single entry\n\t */\n\tre = ldap_count_entries (ldap->conn, message);\n\tif (re != 1) {\n\t\tldap_msgfree (message);\n\t\treturn ret_not_found;\n\t}\n\n\t/* Pick up the first one\n\t */\n\tfirst = ldap_first_entry (ldap->conn, message);\n\tif (first == NULL) {\n\t\tldap_msgfree (message);\n\t\treturn ret_not_found;\n\t}\n\n\t/* Get DN\n\t */\n\tdn = ldap_get_dn (ldap->conn, first);\n\tif (dn == NULL) {\n\t\tldap_msgfree (message);\n\t\treturn ret_error;\n\t}\n\n\tldap_msgfree (message);\n\n\t/* Check that it's right\n\t */\n\tret = validate_dn (props, dn, conn->validator->passwd.buf);\n\tif (ret != ret_ok)\n\t\treturn ret;\n\n\t/* Disconnect from the LDAP server\n\t */\n\tre = ldap_unbind_s (ldap->conn);\n\tif (re != LDAP_SUCCESS)\n\t\treturn ret_error;\n\n\t/* Validated!\n\t */\n\tTRACE (ENTRIES, \"Access to use %s has been granted\\n\", conn->validator->user.buf);\n\n\treturn ret_ok;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144415,
    "RELATED_CWE": [
      "CWE-862",
      "CWE-285",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-287"
    ],
    "code": "cherokee_validator_ldap_check (cherokee_validator_ldap_t *ldap,\n                               cherokee_connection_t     *conn)\n{\n\tint                              re;\n\tret_t                            ret;\n\tsize_t                           size;\n\tchar                            *dn;\n\tLDAPMessage                     *message;\n\tLDAPMessage                     *first;\n\tchar                            *attrs[] = { LDAP_NO_ATTRS, NULL };\n\tcherokee_validator_ldap_props_t *props   = VAL_LDAP_PROP(ldap);\n\n \t/* Sanity checks\n \t */\n \tif ((conn->validator == NULL) ||\n\t    cherokee_buffer_is_empty (&conn->validator->user) ||\n\t    cherokee_buffer_is_empty (&conn->validator->passwd))\n \t\treturn ret_error;\n \n \tsize = cherokee_buffer_cnt_cspn (&conn->validator->user, 0, \"*()\");\n\tif (size != conn->validator->user.len)\n\t\treturn ret_error;\n\n\t/* Build filter\n\t */\n\tret = init_filter (ldap, props, conn);\n\tif (ret != ret_ok)\n\t\treturn ret;\n\n\t/* Search\n\t */\n\tre = ldap_search_s (ldap->conn, props->basedn.buf, LDAP_SCOPE_SUBTREE, ldap->filter.buf, attrs, 0, &message);\n\tif (re != LDAP_SUCCESS) {\n\t\tLOG_ERROR (CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH,\n\t\t           props->filter.buf ? props->filter.buf : \"\");\n\t\treturn ret_error;\n\t}\n\n\tTRACE (ENTRIES, \"subtree search (%s): done\\n\", ldap->filter.buf ? ldap->filter.buf : \"\");\n\n\t/* Check that there a single entry\n\t */\n\tre = ldap_count_entries (ldap->conn, message);\n\tif (re != 1) {\n\t\tldap_msgfree (message);\n\t\treturn ret_not_found;\n\t}\n\n\t/* Pick up the first one\n\t */\n\tfirst = ldap_first_entry (ldap->conn, message);\n\tif (first == NULL) {\n\t\tldap_msgfree (message);\n\t\treturn ret_not_found;\n\t}\n\n\t/* Get DN\n\t */\n\tdn = ldap_get_dn (ldap->conn, first);\n\tif (dn == NULL) {\n\t\tldap_msgfree (message);\n\t\treturn ret_error;\n\t}\n\n\tldap_msgfree (message);\n\n\t/* Check that it's right\n\t */\n\tret = validate_dn (props, dn, conn->validator->passwd.buf);\n\tif (ret != ret_ok)\n\t\treturn ret;\n\n\t/* Disconnect from the LDAP server\n\t */\n\tre = ldap_unbind_s (ldap->conn);\n\tif (re != LDAP_SUCCESS)\n\t\treturn ret_error;\n\n\t/* Validated!\n\t */\n\tTRACE (ENTRIES, \"Access to use %s has been granted\\n\", conn->validator->user.buf);\n\n\treturn ret_ok;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144416,
    "RELATED_CWE": [
      "CWE-862",
      "CWE-285",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-287"
    ],
    "code": "int imap_open_connection (IMAP_DATA* idata)\n{\n  if (mutt_socket_open (idata->conn) < 0)\n    return -1;\n\n  idata->state = IMAP_CONNECTED;\n\n  if (imap_cmd_step (idata) != IMAP_CMD_OK)\n  {\n    imap_close_connection (idata);\n    return -1;\n  }\n\n  if (ascii_strncasecmp (\"* OK\", idata->buf, 4) == 0)\n  {\n    if (ascii_strncasecmp (\"* OK [CAPABILITY\", idata->buf, 16)\n        && imap_check_capabilities (idata))\n      goto bail;\n#if defined(USE_SSL)\n    /* Attempt STARTTLS if available and desired. */\n    if (!idata->conn->ssf && (option(OPTSSLFORCETLS) ||\n                              mutt_bit_isset (idata->capabilities, STARTTLS)))\n    {\n      int rc;\n\n      if (option(OPTSSLFORCETLS))\n        rc = MUTT_YES;\n      else if ((rc = query_quadoption (OPT_SSLSTARTTLS,\n                                       _(\"Secure connection with TLS?\"))) == -1)\n\tgoto err_close_conn;\n      if (rc == MUTT_YES)\n      {\n\tif ((rc = imap_exec (idata, \"STARTTLS\", IMAP_CMD_FAIL_OK)) == -1)\n\t  goto bail;\n\tif (rc != -2)\n\t{\n\t  if (mutt_ssl_starttls (idata->conn))\n\t  {\n\t    mutt_error (_(\"Could not negotiate TLS connection\"));\n\t    mutt_sleep (1);\n\t    goto err_close_conn;\n\t  }\n\t  else\n\t  {\n\t    /* RFC 2595 demands we recheck CAPABILITY after TLS completes. */\n\t    if (imap_exec (idata, \"CAPABILITY\", 0))\n\t      goto bail;\n\t  }\n\t}\n      }\n    }\n\n    if (option(OPTSSLFORCETLS) && ! idata->conn->ssf)\n    {\n      mutt_error _(\"Encrypted connection unavailable\");\n      mutt_sleep (1);\n      goto err_close_conn;\n    }\n#endif\n  }\n  else if (ascii_strncasecmp (\"* PREAUTH\", idata->buf, 9) == 0)\n  {\n#if defined(USE_SSL)\n    /* Unless using a secure $tunnel, an unencrypted PREAUTH response\n     * may be a MITM attack.  The only way to stop \"STARTTLS\" MITM\n     * attacks is via $ssl_force_tls: an attacker can easily spoof\n     * \"* OK\" and strip the STARTTLS capability.  So consult\n     * $ssl_force_tls, not $ssl_starttls, to decide whether to\n     * abort. Note that if using $tunnel and $tunnel_is_secure,\n     * conn->ssf will be set to 1. */\n    if (!idata->conn->ssf && option(OPTSSLFORCETLS))\n    {\n      mutt_error _(\"Encrypted connection unavailable\");\n      mutt_sleep (1);\n      goto err_close_conn;\n    }\n#endif\n\n    idata->state = IMAP_AUTHENTICATED;\n    if (imap_check_capabilities (idata) != 0)\n      goto bail;\n    FREE (&idata->capstr);\n  }\n  else\n  {\n    imap_error (\"imap_open_connection()\", idata->buf);\n    goto bail;\n  }\n\n  return 0;\n\n#if defined(USE_SSL)\nerr_close_conn:\n  imap_close_connection (idata);\n#endif\nbail:\n  FREE (&idata->capstr);\n  return -1;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145626,
    "RELATED_CWE": [
      "CWE-862",
      "CWE-285",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-287"
    ],
    "code": "int imap_open_connection (IMAP_DATA* idata)\n{\n  if (mutt_socket_open (idata->conn) < 0)\n    return -1;\n\n  idata->state = IMAP_CONNECTED;\n\n  if (imap_cmd_step (idata) != IMAP_CMD_OK)\n  {\n    imap_close_connection (idata);\n    return -1;\n  }\n\n  if (ascii_strncasecmp (\"* OK\", idata->buf, 4) == 0)\n  {\n    if (ascii_strncasecmp (\"* OK [CAPABILITY\", idata->buf, 16)\n        && imap_check_capabilities (idata))\n      goto bail;\n#if defined(USE_SSL)\n    /* Attempt STARTTLS if available and desired. */\n    if (!idata->conn->ssf && (option(OPTSSLFORCETLS) ||\n                              mutt_bit_isset (idata->capabilities, STARTTLS)))\n    {\n      int rc;\n\n      if (option(OPTSSLFORCETLS))\n        rc = MUTT_YES;\n      else if ((rc = query_quadoption (OPT_SSLSTARTTLS,\n                                       _(\"Secure connection with TLS?\"))) == -1)\n\tgoto err_close_conn;\n      if (rc == MUTT_YES)\n      {\n\tif ((rc = imap_exec (idata, \"STARTTLS\", IMAP_CMD_FAIL_OK)) == -1)\n\t  goto bail;\n\tif (rc != -2)\n\t{\n\t  if (mutt_ssl_starttls (idata->conn))\n\t  {\n\t    mutt_error (_(\"Could not negotiate TLS connection\"));\n\t    mutt_sleep (1);\n\t    goto err_close_conn;\n\t  }\n\t  else\n\t  {\n\t    /* RFC 2595 demands we recheck CAPABILITY after TLS completes. */\n\t    if (imap_exec (idata, \"CAPABILITY\", 0))\n\t      goto bail;\n\t  }\n\t}\n      }\n    }\n\n    if (option(OPTSSLFORCETLS) && ! idata->conn->ssf)\n    {\n      mutt_error _(\"Encrypted connection unavailable\");\n      mutt_sleep (1);\n      goto err_close_conn;\n    }\n#endif\n  }\n  else if (ascii_strncasecmp (\"* PREAUTH\", idata->buf, 9) == 0)\n  {\n#if defined(USE_SSL)\n    /* Unless using a secure $tunnel, an unencrypted PREAUTH response\n     * may be a MITM attack.  The only way to stop \"STARTTLS\" MITM\n     * attacks is via $ssl_force_tls: an attacker can easily spoof\n     * \"* OK\" and strip the STARTTLS capability.  So consult\n     * $ssl_force_tls, not $ssl_starttls, to decide whether to\n     * abort. Note that if using $tunnel and $tunnel_is_secure,\n     * conn->ssf will be set to 1. */\n    if (!idata->conn->ssf && option(OPTSSLFORCETLS))\n    {\n      mutt_error _(\"Encrypted connection unavailable\");\n      mutt_sleep (1);\n      goto err_close_conn;\n    }\n#endif\n\n    idata->state = IMAP_AUTHENTICATED;\n    if (imap_check_capabilities (idata) != 0)\n      goto bail;\n    FREE (&idata->capstr);\n  }\n  else\n  {\n    imap_error (\"imap_open_connection()\", idata->buf);\n    goto bail;\n  }\n\n  return 0;\n\n#if defined(USE_SSL)\nerr_close_conn:\n#endif\nbail:\n  imap_close_connection (idata);\n  FREE (&idata->capstr);\n  return -1;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145627,
    "RELATED_CWE": [
      "CWE-862",
      "CWE-285",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-287"
    ],
    "code": "pk_transaction_authorize_actions_finished_cb (GObject *source_object,\n\t\t\t\t\t      GAsyncResult *res,\n\t\t\t\t\t      struct AuthorizeActionsData *data)\n{\n\tconst gchar *action_id = NULL;\n\tPkTransactionPrivate *priv = data->transaction->priv;\n\tg_autoptr(GError) error = NULL;\n\tg_autoptr(PolkitAuthorizationResult) result = NULL;\n\tg_assert (data->actions && data->actions->len > 0);\n\n\t/* get the first action */\n\taction_id = g_ptr_array_index (data->actions, 0);\n\n\t/* finish the call */\n\tresult = polkit_authority_check_authorization_finish (priv->authority, res, &error);\n\n\t/* failed because the request was cancelled */\n\tif (g_cancellable_is_cancelled (priv->cancellable)) {\n\t\t/* emit an ::StatusChanged, ::ErrorCode() and then ::Finished() */\n\t\tpriv->waiting_for_auth = FALSE;\n\t\tpk_transaction_status_changed_emit (data->transaction, PK_STATUS_ENUM_FINISHED);\n\t\tpk_transaction_error_code_emit (data->transaction, PK_ERROR_ENUM_NOT_AUTHORIZED,\n\t\t\t\t\t\t\"The authentication was cancelled due to a timeout.\");\n\t\tpk_transaction_finished_emit (data->transaction, PK_EXIT_ENUM_FAILED, 0);\n\t\tgoto out;\n\t}\n\n\t/* failed, maybe polkit is messed up? */\n\tif (result == NULL) {\n\t\tg_autofree gchar *message = NULL;\n\t\tpriv->waiting_for_auth = FALSE;\n\t\tg_warning (\"failed to check for auth: %s\", error->message);\n\n\t\t/* emit an ::StatusChanged, ::ErrorCode() and then ::Finished() */\n\t\tpk_transaction_status_changed_emit (data->transaction, PK_STATUS_ENUM_FINISHED);\n\t\tmessage = g_strdup_printf (\"Failed to check for authentication: %s\", error->message);\n\t\tpk_transaction_error_code_emit (data->transaction,\n\t\t\t\t\t\tPK_ERROR_ENUM_NOT_AUTHORIZED,\n\t\t\t\t\t\tmessage);\n\t\tpk_transaction_finished_emit (data->transaction, PK_EXIT_ENUM_FAILED, 0);\n\t\tgoto out;\n\t}\n\n\t/* did not auth */\n\tif (!polkit_authorization_result_get_is_authorized (result)) {\n\t\tif (g_strcmp0 (action_id, \"org.freedesktop.packagekit.package-install\") == 0 &&\n\t\t\t       pk_bitfield_contain (priv->cached_transaction_flags,\n\t\t\t\t\t\t    PK_TRANSACTION_FLAG_ENUM_ALLOW_REINSTALL)) {\n\t\t\tg_debug (\"allowing just reinstallation\");\n\t\t\tpk_bitfield_add (priv->cached_transaction_flags,\n\t\t\t\t\t PK_TRANSACTION_FLAG_ENUM_JUST_REINSTALL);\n\t\t} else {\n\t\t\tpriv->waiting_for_auth = FALSE;\n\t\t\t/* emit an ::StatusChanged, ::ErrorCode() and then ::Finished() */\n\t\t\tpk_transaction_status_changed_emit (data->transaction, PK_STATUS_ENUM_FINISHED);\n\t\t\tpk_transaction_error_code_emit (data->transaction, PK_ERROR_ENUM_NOT_AUTHORIZED,\n\t\t\t\t\t\t\t\"Failed to obtain authentication.\");\n\t\t\tpk_transaction_finished_emit (data->transaction, PK_EXIT_ENUM_FAILED, 0);\n\n\t\t\tsyslog (LOG_AUTH | LOG_NOTICE,\n\t\t\t\t\"uid %i failed to obtain auth\",\n\t\t\t\tpriv->uid);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (data->actions->len <= 1) {\n\t\t/* authentication finished successfully */\n\t\tpriv->waiting_for_auth = FALSE;\n\t\tpk_transaction_set_state (data->transaction, PK_TRANSACTION_STATE_READY);\n\t\t/* log success too */\n\t\tsyslog (LOG_AUTH | LOG_INFO,\n\t\t\t\"uid %i obtained auth for %s\",\n\t\t\tpriv->uid, action_id);\n\t} else {\n\t\t/* process the rest of actions */\n\t\tg_ptr_array_remove_index (data->actions, 0);\n\t\tpk_transaction_authorize_actions (data->transaction, data->role, data->actions);\n\t}\n\nout:\n\tg_ptr_array_unref (data->actions);\n\tg_free (data);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145634,
    "RELATED_CWE": [
      "CWE-862",
      "CWE-285",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-287"
    ],
    "code": "pk_transaction_authorize_actions_finished_cb (GObject *source_object,\n\t\t\t\t\t      GAsyncResult *res,\n\t\t\t\t\t      struct AuthorizeActionsData *data)\n{\n\tconst gchar *action_id = NULL;\n\tPkTransactionPrivate *priv = data->transaction->priv;\n\tg_autoptr(GError) error = NULL;\n\tg_autoptr(PolkitAuthorizationResult) result = NULL;\n\tg_assert (data->actions && data->actions->len > 0);\n\n\t/* get the first action */\n\taction_id = g_ptr_array_index (data->actions, 0);\n\n\t/* finish the call */\n\tresult = polkit_authority_check_authorization_finish (priv->authority, res, &error);\n\n\t/* failed because the request was cancelled */\n\tif (g_cancellable_is_cancelled (priv->cancellable)) {\n\t\t/* emit an ::StatusChanged, ::ErrorCode() and then ::Finished() */\n\t\tpriv->waiting_for_auth = FALSE;\n\t\tpk_transaction_status_changed_emit (data->transaction, PK_STATUS_ENUM_FINISHED);\n\t\tpk_transaction_error_code_emit (data->transaction, PK_ERROR_ENUM_NOT_AUTHORIZED,\n\t\t\t\t\t\t\"The authentication was cancelled due to a timeout.\");\n\t\tpk_transaction_finished_emit (data->transaction, PK_EXIT_ENUM_FAILED, 0);\n\t\tgoto out;\n\t}\n\n\t/* failed, maybe polkit is messed up? */\n\tif (result == NULL) {\n\t\tg_autofree gchar *message = NULL;\n\t\tpriv->waiting_for_auth = FALSE;\n\t\tg_warning (\"failed to check for auth: %s\", error->message);\n\n\t\t/* emit an ::StatusChanged, ::ErrorCode() and then ::Finished() */\n\t\tpk_transaction_status_changed_emit (data->transaction, PK_STATUS_ENUM_FINISHED);\n\t\tmessage = g_strdup_printf (\"Failed to check for authentication: %s\", error->message);\n\t\tpk_transaction_error_code_emit (data->transaction,\n\t\t\t\t\t\tPK_ERROR_ENUM_NOT_AUTHORIZED,\n\t\t\t\t\t\tmessage);\n\t\tpk_transaction_finished_emit (data->transaction, PK_EXIT_ENUM_FAILED, 0);\n\t\tgoto out;\n\t}\n\n\t/* did not auth */\n\tif (!polkit_authorization_result_get_is_authorized (result)) {\n\t\tpriv->waiting_for_auth = FALSE;\n\t\t/* emit an ::StatusChanged, ::ErrorCode() and then ::Finished() */\n\t\tpk_transaction_status_changed_emit (data->transaction, PK_STATUS_ENUM_FINISHED);\n\t\tpk_transaction_error_code_emit (data->transaction, PK_ERROR_ENUM_NOT_AUTHORIZED,\n\t\t\t\t\t\t\"Failed to obtain authentication.\");\n\t\tpk_transaction_finished_emit (data->transaction, PK_EXIT_ENUM_FAILED, 0);\n\t\tsyslog (LOG_AUTH | LOG_NOTICE, \"uid %i failed to obtain auth\", priv->uid);\n\t\tgoto out;\n\t}\n\n\tif (data->actions->len <= 1) {\n\t\t/* authentication finished successfully */\n\t\tpriv->waiting_for_auth = FALSE;\n\t\tpk_transaction_set_state (data->transaction, PK_TRANSACTION_STATE_READY);\n\t\t/* log success too */\n\t\tsyslog (LOG_AUTH | LOG_INFO,\n\t\t\t\"uid %i obtained auth for %s\",\n\t\t\tpriv->uid, action_id);\n\t} else {\n\t\t/* process the rest of actions */\n\t\tg_ptr_array_remove_index (data->actions, 0);\n\t\tpk_transaction_authorize_actions (data->transaction, data->role, data->actions);\n\t}\n\nout:\n\tg_ptr_array_unref (data->actions);\n\tg_free (data);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145635,
    "RELATED_CWE": [
      "CWE-862",
      "CWE-285",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-287"
    ],
    "code": "receive(\n\tstruct recvbuf *rbufp\n\t)\n{\n\tregister struct peer *peer;\t/* peer structure pointer */\n\tregister struct pkt *pkt;\t/* receive packet pointer */\n\tu_char\thisversion;\t\t/* packet version */\n\tu_char\thisleap;\t\t/* packet leap indicator */\n\tu_char\thismode;\t\t/* packet mode */\n\tu_char\thisstratum;\t\t/* packet stratum */\n\tu_short\trestrict_mask;\t\t/* restrict bits */\n\tint\thas_mac;\t\t/* length of MAC field */\n\tint\tauthlen;\t\t/* offset of MAC field */\n\tint\tis_authentic = 0;\t/* cryptosum ok */\n\tint\tretcode = AM_NOMATCH;\t/* match code */\n\tkeyid_t\tskeyid = 0;\t\t/* key IDs */\n\tu_int32\topcode = 0;\t\t/* extension field opcode */\n\tsockaddr_u *dstadr_sin; \t/* active runway */\n\tstruct peer *peer2;\t\t/* aux peer structure pointer */\n\tendpt *\tmatch_ep;\t\t/* newpeer() local address */\n\tl_fp\tp_org;\t\t\t/* origin timestamp */\n\tl_fp\tp_rec;\t\t\t/* receive timestamp */\n\tl_fp\tp_xmt;\t\t\t/* transmit timestamp */\n#ifdef AUTOKEY\n\tchar\thostname[NTP_MAXSTRLEN + 1];\n\tchar\t*groupname = NULL;\n\tstruct autokey *ap;\t\t/* autokey structure pointer */\n\tint\trval;\t\t\t/* cookie snatcher */\n\tkeyid_t\tpkeyid = 0, tkeyid = 0;\t/* key IDs */\n#endif\t/* AUTOKEY */\n#ifdef HAVE_NTP_SIGND\n\tstatic unsigned char zero_key[16];\n#endif /* HAVE_NTP_SIGND */\n\n\t/*\n\t * Monitor the packet and get restrictions. Note that the packet\n\t * length for control and private mode packets must be checked\n\t * by the service routines. Some restrictions have to be handled\n\t * later in order to generate a kiss-o'-death packet.\n\t */\n\t/*\n\t * Bogus port check is before anything, since it probably\n\t * reveals a clogging attack.\n\t */\n\tsys_received++;\n\tif (0 == SRCPORT(&rbufp->recv_srcadr)) {\n\t\tsys_badlength++;\n\t\treturn;\t\t\t\t/* bogus port */\n\t}\n\trestrict_mask = restrictions(&rbufp->recv_srcadr);\n\tDPRINTF(2, (\"receive: at %ld %s<-%s flags %x restrict %03x\\n\",\n\t\t    current_time, stoa(&rbufp->dstadr->sin),\n\t\t    stoa(&rbufp->recv_srcadr),\n\t\t    rbufp->dstadr->flags, restrict_mask));\n\tpkt = &rbufp->recv_pkt;\n\thisversion = PKT_VERSION(pkt->li_vn_mode);\n\thisleap = PKT_LEAP(pkt->li_vn_mode);\n\thismode = (int)PKT_MODE(pkt->li_vn_mode);\n\thisstratum = PKT_TO_STRATUM(pkt->stratum);\n\tif (restrict_mask & RES_IGNORE) {\n\t\tsys_restricted++;\n\t\treturn;\t\t\t\t/* ignore everything */\n\t}\n\tif (hismode == MODE_PRIVATE) {\n\t\tif (!ntp_mode7 || (restrict_mask & RES_NOQUERY)) {\n\t\t\tsys_restricted++;\n\t\t\treturn;\t\t\t/* no query private */\n\t\t}\n\t\tprocess_private(rbufp, ((restrict_mask &\n\t\t    RES_NOMODIFY) == 0));\n\t\treturn;\n\t}\n\tif (hismode == MODE_CONTROL) {\n\t\tif (restrict_mask & RES_NOQUERY) {\n\t\t\tsys_restricted++;\n\t\t\treturn;\t\t\t/* no query control */\n\t\t}\n\t\tprocess_control(rbufp, restrict_mask);\n\t\treturn;\n\t}\n\tif (restrict_mask & RES_DONTSERVE) {\n\t\tsys_restricted++;\n\t\treturn;\t\t\t\t/* no time serve */\n\t}\n\n\t/*\n\t * This is for testing. If restricted drop ten percent of\n\t * surviving packets.\n\t */\n\tif (restrict_mask & RES_FLAKE) {\n\t\tif ((double)ntp_random() / 0x7fffffff < .1) {\n\t\t\tsys_restricted++;\n\t\t\treturn;\t\t\t/* no flakeway */\n\t\t}\n\t}\n\n\t/*\n\t * Version check must be after the query packets, since they\n\t * intentionally use an early version.\n\t */\n\tif (hisversion == NTP_VERSION) {\n\t\tsys_newversion++;\t\t/* new version */\n\t} else if (!(restrict_mask & RES_VERSION) && hisversion >=\n\t    NTP_OLDVERSION) {\n\t\tsys_oldversion++;\t\t/* previous version */\n\t} else {\n\t\tsys_badlength++;\n\t\treturn;\t\t\t\t/* old version */\n\t}\n\n\t/*\n\t * Figure out his mode and validate the packet. This has some\n\t * legacy raunch that probably should be removed. In very early\n\t * NTP versions mode 0 was equivalent to what later versions\n\t * would interpret as client mode.\n\t */\n\tif (hismode == MODE_UNSPEC) {\n\t\tif (hisversion == NTP_OLDVERSION) {\n\t\t\thismode = MODE_CLIENT;\n\t\t} else {\n\t\t\tsys_badlength++;\n\t\t\treturn;                 /* invalid mode */\n\t\t}\n\t}\n\n\t/*\n\t * Parse the extension field if present. We figure out whether\n\t * an extension field is present by measuring the MAC size. If\n\t * the number of words following the packet header is 0, no MAC\n\t * is present and the packet is not authenticated. If 1, the\n\t * packet is a crypto-NAK; if 3, the packet is authenticated\n\t * with DES; if 5, the packet is authenticated with MD5; if 6,\n\t * the packet is authenticated with SHA. If 2 or * 4, the packet\n\t * is a runt and discarded forthwith. If greater than 6, an\n\t * extension field is present, so we subtract the length of the\n\t * field and go around again.\n\t */\n\tauthlen = LEN_PKT_NOMAC;\n\thas_mac = rbufp->recv_length - authlen;\n\twhile (has_mac > 0) {\n\t\tu_int32\tlen;\n#ifdef AUTOKEY\n\t\tu_int32\thostlen;\n\t\tstruct exten *ep;\n#endif /*AUTOKEY */\n\n\t\tif (has_mac % 4 != 0 || has_mac < (int)MIN_MAC_LEN) {\n\t\t\tsys_badlength++;\n\t\t\treturn;\t\t\t/* bad length */\n\t\t}\n\t\tif (has_mac <= (int)MAX_MAC_LEN) {\n\t\t\tskeyid = ntohl(((u_int32 *)pkt)[authlen / 4]);\n\t\t\tbreak;\n\n\t\t} else {\n\t\t\topcode = ntohl(((u_int32 *)pkt)[authlen / 4]);\n\t\t\tlen = opcode & 0xffff;\n\t\t\tif (len % 4 != 0 || len < 4 || (int)len +\n\t\t\t    authlen > rbufp->recv_length) {\n\t\t\t\tsys_badlength++;\n\t\t\t\treturn;\t\t/* bad length */\n\t\t\t}\n#ifdef AUTOKEY\n\t\t\t/*\n\t\t\t * Extract calling group name for later.  If\n\t\t\t * sys_groupname is non-NULL, there must be\n\t\t\t * a group name provided to elicit a response.\n\t\t\t */\n\t\t\tif ((opcode & 0x3fff0000) == CRYPTO_ASSOC &&\n\t\t\t    sys_groupname != NULL) {\n\t\t\t\tep = (struct exten *)&((u_int32 *)pkt)[authlen / 4];\n\t\t\t\thostlen = ntohl(ep->vallen);\n\t\t\t\tif (hostlen >= sizeof(hostname) ||\n\t\t\t\t    hostlen > len -\n\t\t\t\t    offsetof(struct exten, pkt)) {\n\t\t\t\t\tsys_badlength++;\n\t\t\t\t\treturn;\t\t/* bad length */\n\t\t\t\t}\n\t\t\t\tmemcpy(hostname, &ep->pkt, hostlen);\n\t\t\t\thostname[hostlen] = '\\0';\n\t\t\t\tgroupname = strchr(hostname, '@');\n\t\t\t\tif (groupname == NULL) {\n\t\t\t\t\tsys_declined++;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tgroupname++;\n\t\t\t}\n#endif /* AUTOKEY */\n\t\t\tauthlen += len;\n\t\t\thas_mac -= len;\n\t\t}\n\t}\n\n\t/*\n\t * If has_mac is < 0 we had a malformed packet.\n\t */\n\tif (has_mac < 0) {\n\t\tsys_badlength++;\n\t\treturn;\t\t/* bad length */\n\t}\n\n\t/*\n\t * If authentication required, a MAC must be present.\n\t */\n\tif (restrict_mask & RES_DONTTRUST && has_mac == 0) {\n\t\tsys_restricted++;\n\t\treturn;\t\t\t\t/* access denied */\n\t}\n\n\t/*\n\t * Update the MRU list and finger the cloggers. It can be a\n\t * little expensive, so turn it off for production use.\n\t * RES_LIMITED and RES_KOD will be cleared in the returned\n\t * restrict_mask unless one or both actions are warranted.\n\t */\n\trestrict_mask = ntp_monitor(rbufp, restrict_mask);\n\tif (restrict_mask & RES_LIMITED) {\n\t\tsys_limitrejected++;\n\t\tif (!(restrict_mask & RES_KOD) || MODE_BROADCAST ==\n\t\t    hismode || MODE_SERVER == hismode) {\n\t\t\tif (MODE_SERVER == hismode)\n\t\t\t\tDPRINTF(1, (\"Possibly self-induced rate limiting of MODE_SERVER from %s\\n\",\n\t\t\t\t\tstoa(&rbufp->recv_srcadr)));\n\t\t\treturn;\t\t\t/* rate exceeded */\n\t\t}\n\t\tif (hismode == MODE_CLIENT)\n\t\t\tfast_xmit(rbufp, MODE_SERVER, skeyid,\n\t\t\t    restrict_mask);\n\t\telse\n\t\t\tfast_xmit(rbufp, MODE_ACTIVE, skeyid,\n\t\t\t    restrict_mask);\n\t\treturn;\t\t\t\t/* rate exceeded */\n\t}\n\trestrict_mask &= ~RES_KOD;\n\n\t/*\n\t * We have tossed out as many buggy packets as possible early in\n\t * the game to reduce the exposure to a clogging attack. Now we\n\t * have to burn some cycles to find the association and\n\t * authenticate the packet if required. Note that we burn only\n\t * digest cycles, again to reduce exposure. There may be no\n\t * matching association and that's okay.\n\t *\n\t * More on the autokey mambo. Normally the local interface is\n\t * found when the association was mobilized with respect to a\n\t * designated remote address. We assume packets arriving from\n\t * the remote address arrive via this interface and the local\n\t * address used to construct the autokey is the unicast address\n\t * of the interface. However, if the sender is a broadcaster,\n\t * the interface broadcast address is used instead.\n\t * Notwithstanding this technobabble, if the sender is a\n\t * multicaster, the broadcast address is null, so we use the\n\t * unicast address anyway. Don't ask.\n\t */\n\tpeer = findpeer(rbufp,  hismode, &retcode);\n\tdstadr_sin = &rbufp->dstadr->sin;\n\tNTOHL_FP(&pkt->org, &p_org);\n\tNTOHL_FP(&pkt->rec, &p_rec);\n\tNTOHL_FP(&pkt->xmt, &p_xmt);\n\n\t/*\n\t * Authentication is conditioned by three switches:\n\t *\n\t * NOPEER  (RES_NOPEER) do not mobilize an association unless\n\t *         authenticated\n\t * NOTRUST (RES_DONTTRUST) do not allow access unless\n\t *         authenticated (implies NOPEER)\n\t * enable  (sys_authenticate) master NOPEER switch, by default\n\t *         on\n\t *\n\t * The NOPEER and NOTRUST can be specified on a per-client basis\n\t * using the restrict command. The enable switch if on implies\n\t * NOPEER for all clients. There are four outcomes:\n\t *\n\t * NONE    The packet has no MAC.\n\t * OK      the packet has a MAC and authentication succeeds\n\t * ERROR   the packet has a MAC and authentication fails\n\t * CRYPTO  crypto-NAK. The MAC has four octets only.\n\t *\n\t * Note: The AUTH(x, y) macro is used to filter outcomes. If x\n\t * is zero, acceptable outcomes of y are NONE and OK. If x is\n\t * one, the only acceptable outcome of y is OK.\n\t */\n\n\tif (has_mac == 0) {\n\t\trestrict_mask &= ~RES_MSSNTP;\n\t\tis_authentic = AUTH_NONE; /* not required */\n#ifdef DEBUG\n\t\tif (debug)\n\t\t\tprintf(\n\t\t\t    \"receive: at %ld %s<-%s mode %d len %d\\n\",\n\t\t\t    current_time, stoa(dstadr_sin),\n\t\t\t    stoa(&rbufp->recv_srcadr), hismode,\n\t\t\t    authlen);\n#endif\n\t} else if (has_mac == 4) {\n\t\trestrict_mask &= ~RES_MSSNTP;\n\t\tis_authentic = AUTH_CRYPTO; /* crypto-NAK */\n#ifdef DEBUG\n\t\tif (debug)\n\t\t\tprintf(\n\t\t\t    \"receive: at %ld %s<-%s mode %d keyid %08x len %d auth %d\\n\",\n\t\t\t    current_time, stoa(dstadr_sin),\n\t\t\t    stoa(&rbufp->recv_srcadr), hismode, skeyid,\n\t\t\t    authlen + has_mac, is_authentic);\n#endif\n\n#ifdef HAVE_NTP_SIGND\n\t\t/*\n\t\t * If the signature is 20 bytes long, the last 16 of\n\t\t * which are zero, then this is a Microsoft client\n\t\t * wanting AD-style authentication of the server's\n\t\t * reply.\n\t\t *\n\t\t * This is described in Microsoft's WSPP docs, in MS-SNTP:\n\t\t * http://msdn.microsoft.com/en-us/library/cc212930.aspx\n\t\t */\n\t} else if (has_mac == MAX_MD5_LEN && (restrict_mask & RES_MSSNTP) &&\n\t   (retcode == AM_FXMIT || retcode == AM_NEWPASS) &&\n\t   (memcmp(zero_key, (char *)pkt + authlen + 4, MAX_MD5_LEN - 4) ==\n\t   0)) {\n\t\tis_authentic = AUTH_NONE;\n#endif /* HAVE_NTP_SIGND */\n\n\t} else {\n\t\trestrict_mask &= ~RES_MSSNTP;\n#ifdef AUTOKEY\n\t\t/*\n\t\t * For autokey modes, generate the session key\n\t\t * and install in the key cache. Use the socket\n\t\t * broadcast or unicast address as appropriate.\n\t\t */\n\t\tif (crypto_flags && skeyid > NTP_MAXKEY) {\n\n\t\t\t/*\n\t\t\t * More on the autokey dance (AKD). A cookie is\n\t\t\t * constructed from public and private values.\n\t\t\t * For broadcast packets, the cookie is public\n\t\t\t * (zero). For packets that match no\n\t\t\t * association, the cookie is hashed from the\n\t\t\t * addresses and private value. For server\n\t\t\t * packets, the cookie was previously obtained\n\t\t\t * from the server. For symmetric modes, the\n\t\t\t * cookie was previously constructed using an\n\t\t\t * agreement protocol; however, should PKI be\n\t\t\t * unavailable, we construct a fake agreement as\n\t\t\t * the EXOR of the peer and host cookies.\n\t\t\t *\n\t\t\t * hismode\tephemeral\tpersistent\n\t\t\t * =======================================\n\t\t\t * active\t0\t\tcookie#\n\t\t\t * passive\t0%\t\tcookie#\n\t\t\t * client\tsys cookie\t0%\n\t\t\t * server\t0%\t\tsys cookie\n\t\t\t * broadcast\t0\t\t0\n\t\t\t *\n\t\t\t * # if unsync, 0\n\t\t\t * % can't happen\n\t\t\t */\n\t\t\tif (has_mac < (int)MAX_MD5_LEN) {\n\t\t\t\tsys_badauth++;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (hismode == MODE_BROADCAST) {\n\n\t\t\t\t/*\n\t\t\t\t * For broadcaster, use the interface\n\t\t\t\t * broadcast address when available;\n\t\t\t\t * otherwise, use the unicast address\n\t\t\t\t * found when the association was\n\t\t\t\t * mobilized. However, if this is from\n\t\t\t\t * the wildcard interface, game over.\n\t\t\t\t */\n\t\t\t\tif (crypto_flags && rbufp->dstadr ==\n\t\t\t\t    ANY_INTERFACE_CHOOSE(&rbufp->recv_srcadr)) {\n\t\t\t\t\tsys_restricted++;\n\t\t\t\t\treturn;\t     /* no wildcard */\n\t\t\t\t}\n\t\t\t\tpkeyid = 0;\n\t\t\t\tif (!SOCK_UNSPEC(&rbufp->dstadr->bcast))\n\t\t\t\t\tdstadr_sin =\n\t\t\t\t\t    &rbufp->dstadr->bcast;\n\t\t\t} else if (peer == NULL) {\n\t\t\t\tpkeyid = session_key(\n\t\t\t\t    &rbufp->recv_srcadr, dstadr_sin, 0,\n\t\t\t\t    sys_private, 0);\n\t\t\t} else {\n\t\t\t\tpkeyid = peer->pcookie;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The session key includes both the public\n\t\t\t * values and cookie. In case of an extension\n\t\t\t * field, the cookie used for authentication\n\t\t\t * purposes is zero. Note the hash is saved for\n\t\t\t * use later in the autokey mambo.\n\t\t\t */\n\t\t\tif (authlen > (int)LEN_PKT_NOMAC && pkeyid != 0) {\n\t\t\t\tsession_key(&rbufp->recv_srcadr,\n\t\t\t\t    dstadr_sin, skeyid, 0, 2);\n\t\t\t\ttkeyid = session_key(\n\t\t\t\t    &rbufp->recv_srcadr, dstadr_sin,\n\t\t\t\t    skeyid, pkeyid, 0);\n\t\t\t} else {\n\t\t\t\ttkeyid = session_key(\n\t\t\t\t    &rbufp->recv_srcadr, dstadr_sin,\n\t\t\t\t    skeyid, pkeyid, 2);\n\t\t\t}\n\n\t\t}\n#endif\t/* AUTOKEY */\n\n\t\t/*\n\t\t * Compute the cryptosum. Note a clogging attack may\n\t\t * succeed in bloating the key cache. If an autokey,\n\t\t * purge it immediately, since we won't be needing it\n\t\t * again. If the packet is authentic, it can mobilize an\n\t\t * association. Note that there is no key zero.\n\t\t */\n\t\tif (!authdecrypt(skeyid, (u_int32 *)pkt, authlen,\n\t\t    has_mac))\n\t\t\tis_authentic = AUTH_ERROR;\n\t\telse\n\t\t\tis_authentic = AUTH_OK;\n#ifdef AUTOKEY\n\t\tif (crypto_flags && skeyid > NTP_MAXKEY)\n\t\t\tauthtrust(skeyid, 0);\n#endif\t/* AUTOKEY */\n#ifdef DEBUG\n\t\tif (debug)\n\t\t\tprintf(\n\t\t\t    \"receive: at %ld %s<-%s mode %d keyid %08x len %d auth %d\\n\",\n\t\t\t    current_time, stoa(dstadr_sin),\n\t\t\t    stoa(&rbufp->recv_srcadr), hismode, skeyid,\n\t\t\t    authlen + has_mac, is_authentic);\n#endif\n\t}\n\n\t/*\n\t * The association matching rules are implemented by a set of\n\t * routines and an association table. A packet matching an\n\t * association is processed by the peer process for that\n\t * association. If there are no errors, an ephemeral association\n\t * is mobilized: a broadcast packet mobilizes a broadcast client\n\t * aassociation; a manycast server packet mobilizes a manycast\n\t * client association; a symmetric active packet mobilizes a\n\t * symmetric passive association.\n\t */\n\tswitch (retcode) {\n\n\t/*\n\t * This is a client mode packet not matching any association. If\n\t * an ordinary client, simply toss a server mode packet back\n\t * over the fence. If a manycast client, we have to work a\n\t * little harder.\n\t */\n\tcase AM_FXMIT:\n\n\t\t/*\n\t\t * If authentication OK, send a server reply; otherwise,\n\t\t * send a crypto-NAK.\n\t\t */\n\t\tif (!(rbufp->dstadr->flags & INT_MCASTOPEN)) {\n\t\t\tif (AUTH(restrict_mask & RES_DONTTRUST,\n\t\t\t   is_authentic)) {\n\t\t\t\tfast_xmit(rbufp, MODE_SERVER, skeyid,\n\t\t\t\t    restrict_mask);\n\t\t\t} else if (is_authentic == AUTH_ERROR) {\n\t\t\t\tfast_xmit(rbufp, MODE_SERVER, 0,\n\t\t\t\t    restrict_mask);\n\t\t\t\tsys_badauth++;\n\t\t\t} else {\n\t\t\t\tsys_restricted++;\n\t\t\t}\n\t\t\treturn;\t\t\t/* hooray */\n\t\t}\n\n\t\t/*\n\t\t * This must be manycast. Do not respond if not\n\t\t * configured as a manycast server.\n\t\t */\n\t\tif (!sys_manycastserver) {\n\t\t\tsys_restricted++;\n\t\t\treturn;\t\t\t/* not enabled */\n\t\t}\n\n#ifdef AUTOKEY\n\t\t/*\n\t\t * Do not respond if not the same group.\n\t\t */\n\t\tif (group_test(groupname, NULL)) {\n\t\t\tsys_declined++;\n\t\t\treturn;\n\t\t}\n#endif /* AUTOKEY */\n\n\t\t/*\n\t\t * Do not respond if we are not synchronized or our\n\t\t * stratum is greater than the manycaster or the\n\t\t * manycaster has already synchronized to us.\n\t\t */\n\t\tif (sys_leap == LEAP_NOTINSYNC || sys_stratum >=\n\t\t    hisstratum || (!sys_cohort && sys_stratum ==\n\t\t    hisstratum + 1) || rbufp->dstadr->addr_refid ==\n\t\t    pkt->refid) {\n\t\t\tsys_declined++;\n\t\t\treturn;\t\t\t/* no help */\n\t\t}\n\n\t\t/*\n\t\t * Respond only if authentication succeeds. Don't do a\n\t\t * crypto-NAK, as that would not be useful.\n\t\t */\n\t\tif (AUTH(restrict_mask & RES_DONTTRUST, is_authentic))\n\t\t\tfast_xmit(rbufp, MODE_SERVER, skeyid,\n\t\t\t    restrict_mask);\n\t\treturn;\t\t\t\t/* hooray */\n\n\t/*\n\t * This is a server mode packet returned in response to a client\n\t * mode packet sent to a multicast group address (for\n\t * manycastclient) or to a unicast address (for pool). The\n\t * origin timestamp is a good nonce to reliably associate the\n\t * reply with what was sent. If there is no match, that's\n\t * curious and could be an intruder attempting to clog, so we\n\t * just ignore it.\n\t *\n\t * If the packet is authentic and the manycastclient or pool\n\t * association is found, we mobilize a client association and\n\t * copy pertinent variables from the manycastclient or pool\n\t * association to the new client association. If not, just\n\t * ignore the packet.\n\t *\n\t * There is an implosion hazard at the manycast client, since\n\t * the manycast servers send the server packet immediately. If\n\t * the guy is already here, don't fire up a duplicate.\n\t */\n\tcase AM_MANYCAST:\n\n#ifdef AUTOKEY\n\t\t/*\n\t\t * Do not respond if not the same group.\n\t\t */\n\t\tif (group_test(groupname, NULL)) {\n\t\t\tsys_declined++;\n\t\t\treturn;\n\t\t}\n#endif /* AUTOKEY */\n\t\tif ((peer2 = findmanycastpeer(rbufp)) == NULL) {\n\t\t\tsys_restricted++;\n\t\t\treturn;\t\t\t/* not enabled */\n\t\t}\n\t\tif (!AUTH((!(peer2->cast_flags & MDF_POOL) &&\n\t\t    sys_authenticate) | (restrict_mask & (RES_NOPEER |\n\t\t    RES_DONTTRUST)), is_authentic)) {\n\t\t\tsys_restricted++;\n\t\t\treturn;\t\t\t/* access denied */\n\t\t}\n\n\t\t/*\n\t\t * Do not respond if unsynchronized or stratum is below\n\t\t * the floor or at or above the ceiling.\n\t\t */\n\t\tif (hisleap == LEAP_NOTINSYNC || hisstratum <\n\t\t    sys_floor || hisstratum >= sys_ceiling) {\n\t\t\tsys_declined++;\n\t\t\treturn;\t\t\t/* no help */\n\t\t}\n\t\tpeer = newpeer(&rbufp->recv_srcadr, NULL, rbufp->dstadr,\n\t\t\t       MODE_CLIENT, hisversion, peer2->minpoll,\n\t\t\t       peer2->maxpoll, FLAG_PREEMPT |\n\t\t\t       (FLAG_IBURST & peer2->flags), MDF_UCAST |\n\t\t\t       MDF_UCLNT, 0, skeyid, sys_ident);\n\t\tif (NULL == peer) {\n\t\t\tsys_declined++;\n\t\t\treturn;\t\t\t/* ignore duplicate  */\n\t\t}\n\n\t\t/*\n\t\t * After each ephemeral pool association is spun,\n\t\t * accelerate the next poll for the pool solicitor so\n\t\t * the pool will fill promptly.\n\t\t */\n\t\tif (peer2->cast_flags & MDF_POOL)\n\t\t\tpeer2->nextdate = current_time + 1;\n\n\t\t/*\n\t\t * Further processing of the solicitation response would\n\t\t * simply detect its origin timestamp as bogus for the\n\t\t * brand-new association (it matches the prototype\n\t\t * association) and tinker with peer->nextdate delaying\n\t\t * first sync.\n\t\t */\n\t\treturn;\t\t/* solicitation response handled */\n\n\t/*\n\t * This is the first packet received from a broadcast server. If\n\t * the packet is authentic and we are enabled as broadcast\n\t * client, mobilize a broadcast client association. We don't\n\t * kiss any frogs here.\n\t */\n\tcase AM_NEWBCL:\n\n#ifdef AUTOKEY\n\t\t/*\n\t\t * Do not respond if not the same group.\n\t\t */\n\t\tif (group_test(groupname, sys_ident)) {\n\t\t\tsys_declined++;\n\t\t\treturn;\n\t\t}\n#endif /* AUTOKEY */\n\t\tif (sys_bclient == 0) {\n\t\t\tsys_restricted++;\n\t\t\treturn;\t\t\t/* not enabled */\n\t\t}\n\t\tif (!AUTH(sys_authenticate | (restrict_mask &\n\t\t    (RES_NOPEER | RES_DONTTRUST)), is_authentic)) {\n\t\t\tsys_restricted++;\n\t\t\treturn;\t\t\t/* access denied */\n\t\t}\n\n\t\t/*\n\t\t * Do not respond if unsynchronized or stratum is below\n\t\t * the floor or at or above the ceiling.\n\t\t */\n\t\tif (hisleap == LEAP_NOTINSYNC || hisstratum <\n\t\t    sys_floor || hisstratum >= sys_ceiling) {\n\t\t\tsys_declined++;\n\t\t\treturn;\t\t\t/* no help */\n\t\t}\n\n#ifdef AUTOKEY\n\t\t/*\n\t\t * Do not respond if Autokey and the opcode is not a\n\t\t * CRYPTO_ASSOC response with association ID.\n\t\t */\n\t\tif (crypto_flags && skeyid > NTP_MAXKEY && (opcode &\n\t\t    0xffff0000) != (CRYPTO_ASSOC | CRYPTO_RESP)) {\n\t\t\tsys_declined++;\n\t\t\treturn;\t\t\t/* protocol error */\n\t\t}\n#endif\t/* AUTOKEY */\n\n\t\t/*\n\t\t * Broadcasts received via a multicast address may\n\t\t * arrive after a unicast volley has begun\n\t\t * with the same remote address.  newpeer() will not\n\t\t * find duplicate associations on other local endpoints\n\t\t * if a non-NULL endpoint is supplied.  multicastclient\n\t\t * ephemeral associations are unique across all local\n\t\t * endpoints.\n\t\t */\n\t\tif (!(INT_MCASTOPEN & rbufp->dstadr->flags))\n\t\t\tmatch_ep = rbufp->dstadr;\n\t\telse\n\t\t\tmatch_ep = NULL;\n\n\t\t/*\n\t\t * Determine whether to execute the initial volley.\n\t\t */\n\t\tif (sys_bdelay != 0) {\n#ifdef AUTOKEY\n\t\t\t/*\n\t\t\t * If a two-way exchange is not possible,\n\t\t\t * neither is Autokey.\n\t\t\t */\n\t\t\tif (crypto_flags && skeyid > NTP_MAXKEY) {\n\t\t\t\tsys_restricted++;\n\t\t\t\treturn;\t\t/* no autokey */\n\t\t\t}\n#endif\t/* AUTOKEY */\n\n\t\t\t/*\n\t\t\t * Do not execute the volley. Start out in\n\t\t\t * broadcast client mode.\n\t\t\t */\n\t\t\tpeer = newpeer(&rbufp->recv_srcadr, NULL,\n\t\t\t    match_ep, MODE_BCLIENT, hisversion,\n\t\t\t    pkt->ppoll, pkt->ppoll, FLAG_PREEMPT,\n\t\t\t    MDF_BCLNT, 0, skeyid, sys_ident);\n\t\t\tif (NULL == peer) {\n\t\t\t\tsys_restricted++;\n\t\t\t\treturn;\t\t/* ignore duplicate */\n\n\t\t\t} else {\n\t\t\t\tpeer->delay = sys_bdelay;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Execute the initial volley in order to calibrate the\n\t\t * propagation delay and run the Autokey protocol.\n\t\t *\n\t\t * Note that the minpoll is taken from the broadcast\n\t\t * packet, normally 6 (64 s) and that the poll interval\n\t\t * is fixed at this value.\n\t\t */\n\t\tpeer = newpeer(&rbufp->recv_srcadr, NULL, match_ep,\n\t\t    MODE_CLIENT, hisversion, pkt->ppoll, pkt->ppoll,\n\t\t    FLAG_BC_VOL | FLAG_IBURST | FLAG_PREEMPT, MDF_BCLNT,\n\t\t    0, skeyid, sys_ident);\n\t\tif (NULL == peer) {\n\t\t\tsys_restricted++;\n\t\t\treturn;\t\t\t/* ignore duplicate */\n\t\t}\n#ifdef AUTOKEY\n\t\tif (skeyid > NTP_MAXKEY)\n\t\t\tcrypto_recv(peer, rbufp);\n#endif\t/* AUTOKEY */\n\n\t\treturn;\t\t\t\t/* hooray */\n\n\t/*\n\t * This is the first packet received from a symmetric active\n\t * peer. If the packet is authentic and the first he sent,\n\t * mobilize a passive association. If not, kiss the frog.\n\t */\n\tcase AM_NEWPASS:\n\n#ifdef AUTOKEY\n\t\t/*\n\t\t * Do not respond if not the same group.\n\t\t */\n\t\tif (group_test(groupname, sys_ident)) {\n\t\t\tsys_declined++;\n\t\t\treturn;\n\t\t}\n#endif /* AUTOKEY */\n\t\tif (!AUTH(sys_authenticate | (restrict_mask &\n\t\t    (RES_NOPEER | RES_DONTTRUST)), is_authentic)) {\n\n\t\t\t/*\n\t\t\t * If authenticated but cannot mobilize an\n\t\t\t * association, send a symmetric passive\n\t\t\t * response without mobilizing an association.\n\t\t\t * This is for drat broken Windows clients. See\n\t\t\t * Microsoft KB 875424 for preferred workaround.\n\t\t\t */\n\t\t\tif (AUTH(restrict_mask & RES_DONTTRUST,\n\t\t\t    is_authentic)) {\n\t\t\t\tfast_xmit(rbufp, MODE_PASSIVE, skeyid,\n\t\t\t\t    restrict_mask);\n\t\t\t\treturn;\t\t\t/* hooray */\n\t\t\t}\n\t\t\tif (is_authentic == AUTH_ERROR) {\n\t\t\t\tfast_xmit(rbufp, MODE_ACTIVE, 0,\n\t\t\t\t    restrict_mask);\n\t\t\t\tsys_restricted++;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Do not respond if synchronized and if stratum is\n\t\t * below the floor or at or above the ceiling. Note,\n\t\t * this allows an unsynchronized peer to synchronize to\n\t\t * us. It would be very strange if he did and then was\n\t\t * nipped, but that could only happen if we were\n\t\t * operating at the top end of the range.  It also means\n\t\t * we will spin an ephemeral association in response to\n\t\t * MODE_ACTIVE KoDs, which will time out eventually.\n\t\t */\n\t\tif (hisleap != LEAP_NOTINSYNC && (hisstratum <\n\t\t    sys_floor || hisstratum >= sys_ceiling)) {\n\t\t\tsys_declined++;\n\t\t\treturn;\t\t\t/* no help */\n\t\t}\n\n\t\t/*\n\t\t * The message is correctly authenticated and allowed.\n\t\t * Mobilize a symmetric passive association.\n\t\t */\n\t\tif ((peer = newpeer(&rbufp->recv_srcadr, NULL,\n\t\t    rbufp->dstadr, MODE_PASSIVE, hisversion, pkt->ppoll,\n\t\t    NTP_MAXDPOLL, 0, MDF_UCAST, 0, skeyid,\n\t\t    sys_ident)) == NULL) {\n\t\t\tsys_declined++;\n\t\t\treturn;\t\t\t/* ignore duplicate */\n\t\t}\n\t\tbreak;\n\n\n\t/*\n\t * Process regular packet. Nothing special.\n\t */\n\tcase AM_PROCPKT:\n\n#ifdef AUTOKEY\n\t\t/*\n\t\t * Do not respond if not the same group.\n\t\t */\n\t\tif (group_test(groupname, peer->ident)) {\n\t\t\tsys_declined++;\n\t\t\treturn;\n\t\t}\n#endif /* AUTOKEY */\n\t\tbreak;\n\n\t/*\n\t * A passive packet matches a passive association. This is\n\t * usually the result of reconfiguring a client on the fly. As\n\t * this association might be legitimate and this packet an\n\t * attempt to deny service, just ignore it.\n\t */\n\tcase AM_ERR:\n\t\tsys_declined++;\n\t\treturn;\n\n\t/*\n\t * For everything else there is the bit bucket.\n\t */\n\tdefault:\n\t\tsys_declined++;\n\t\treturn;\n\t}\n\n#ifdef AUTOKEY\n\t/*\n\t * If the association is configured for Autokey, the packet must\n\t * have a public key ID; if not, the packet must have a\n\t * symmetric key ID.\n\t */\n\tif (is_authentic != AUTH_CRYPTO && (((peer->flags &\n\t    FLAG_SKEY) && skeyid <= NTP_MAXKEY) || (!(peer->flags &\n\t    FLAG_SKEY) && skeyid > NTP_MAXKEY))) {\n\t\tsys_badauth++;\n\t\treturn;\n\t}\n#endif\t/* AUTOKEY */\n\tpeer->received++;\n\tpeer->flash &= ~PKT_TEST_MASK;\n\tif (peer->flags & FLAG_XBOGUS) {\n\t\tpeer->flags &= ~FLAG_XBOGUS;\n\t\tpeer->flash |= TEST3;\n\t}\n\n\t/*\n\t * Next comes a rigorous schedule of timestamp checking. If the\n\t * transmit timestamp is zero, the server has not initialized in\n\t * interleaved modes or is horribly broken.\n\t */\n\tif (L_ISZERO(&p_xmt)) {\n\t\tpeer->flash |= TEST3;\t\t\t/* unsynch */\n\n\t/*\n\t * If the transmit timestamp duplicates a previous one, the\n\t * packet is a replay. This prevents the bad guys from replaying\n\t * the most recent packet, authenticated or not.\n\t */\n\t} else if (L_ISEQU(&peer->xmt, &p_xmt)) {\n\t\tpeer->flash |= TEST1;\t\t\t/* duplicate */\n\t\tpeer->oldpkt++;\n\t\treturn;\n\n\t/*\n\t * If this is a broadcast mode packet, skip further checking. If\n\t * an initial volley, bail out now and let the client do its\n\t * stuff. If the origin timestamp is nonzero, this is an\n\t * interleaved broadcast. so restart the protocol.\n\t */\n\t} else if (hismode == MODE_BROADCAST) {\n\t\tif (!L_ISZERO(&p_org) && !(peer->flags & FLAG_XB)) {\n\t\t\tpeer->flags |= FLAG_XB;\n\t\t\tpeer->aorg = p_xmt;\n\t\t\tpeer->borg = rbufp->recv_time;\n\t\t\treport_event(PEVNT_XLEAVE, peer, NULL);\n\t\t\treturn;\n\t\t}\n\n\t/*\n\t * Check for bogus packet in basic mode. If found, switch to\n\t * interleaved mode and resynchronize, but only after confirming\n\t * the packet is not bogus in symmetric interleaved mode.\n\t */\n\t} else if (peer->flip == 0) {\n\t\tif (!L_ISEQU(&p_org, &peer->aorg)) {\n\t\t\tpeer->bogusorg++;\n\t\t\tpeer->flash |= TEST2;\t/* bogus */\n\t\t\tif (!L_ISZERO(&peer->dst) && L_ISEQU(&p_org,\n\t\t\t    &peer->dst)) {\n\t\t\t\tpeer->flip = 1;\n\t\t\t\treport_event(PEVNT_XLEAVE, peer, NULL);\n\t\t\t}\n\t\t} else {\n\t\t\tL_CLR(&peer->aorg);\n\t\t}\n\n\t/*\n\t * Check for valid nonzero timestamp fields.\n\t */\n\t} else if (L_ISZERO(&p_org) || L_ISZERO(&p_rec) ||\n\t    L_ISZERO(&peer->dst)) {\n\t\tpeer->flash |= TEST3;\t\t/* unsynch */\n\n\t/*\n\t * Check for bogus packet in interleaved symmetric mode. This\n\t * can happen if a packet is lost, duplicated or crossed. If\n\t * found, flip and resynchronize.\n\t */\n\t} else if (!L_ISZERO(&peer->dst) && !L_ISEQU(&p_org,\n\t    &peer->dst)) {\n\t\tpeer->bogusorg++;\n\t\tpeer->flags |= FLAG_XBOGUS;\n\t\tpeer->flash |= TEST2;\t\t/* bogus */\n\t}\n\n\t/*\n\t * If this is a crypto_NAK, the server cannot authenticate a\n\t * client packet. The server might have just changed keys. Clear\n\t * the association and restart the protocol.\n\t */\n\tif (is_authentic == AUTH_CRYPTO) {\n\t\treport_event(PEVNT_AUTH, peer, \"crypto_NAK\");\n\t\tpeer->flash |= TEST5;\t\t/* bad auth */\n\t\tpeer->badauth++;\n\t\tif (peer->flags & FLAG_PREEMPT) {\n\t\t\tunpeer(peer);\n\t\t\treturn;\n\t\t}\n#ifdef AUTOKEY\n\t\tif (peer->crypto)\n\t\t\tpeer_clear(peer, \"AUTH\");\n#endif\t/* AUTOKEY */\n\t\treturn;\n\n\t/*\n\t * If the digest fails or it's missing for authenticated\n\t * associations, the client cannot authenticate a server\n\t * reply to a client packet previously sent. The loopback check\n\t * is designed to avoid a bait-and-switch attack, which was\n\t * possible in past versions. If symmetric modes, return a\n\t * crypto-NAK. The peer should restart the protocol.\n\t */\n\t} else if (!AUTH(peer->keyid || has_mac ||\n\t\t\t (restrict_mask & RES_DONTTRUST), is_authentic)) {\n\t\treport_event(PEVNT_AUTH, peer, \"digest\");\n\t\tpeer->flash |= TEST5;\t\t/* bad auth */\n\t\tpeer->badauth++;\n\t\tif (has_mac &&\n\t\t    (hismode == MODE_ACTIVE || hismode == MODE_PASSIVE))\n\t\t\tfast_xmit(rbufp, MODE_ACTIVE, 0, restrict_mask);\n\t\tif (peer->flags & FLAG_PREEMPT) {\n\t\t\tunpeer(peer);\n\t\t\treturn;\n\t\t}\n#ifdef AUTOKEY\n\t\tif (peer->crypto)\n\t\t\tpeer_clear(peer, \"AUTH\");\n#endif\t/* AUTOKEY */\n\t\treturn;\n\t}\n\n\t/*\n\t * Update the state variables.\n\t */\n\tif (peer->flip == 0) {\n\t\tif (hismode != MODE_BROADCAST)\n\t\t\tpeer->rec = p_xmt;\n\t\tpeer->dst = rbufp->recv_time;\n\t}\n\tpeer->xmt = p_xmt;\n\n\t/*\n\t * Set the peer ppoll to the maximum of the packet ppoll and the\n\t * peer minpoll. If a kiss-o'-death, set the peer minpoll to\n\t * this maximum and advance the headway to give the sender some\n\t * headroom. Very intricate.\n\t */\n\tpeer->ppoll = max(peer->minpoll, pkt->ppoll);\n\tif (hismode == MODE_SERVER && hisleap == LEAP_NOTINSYNC &&\n\t    hisstratum == STRATUM_UNSPEC && memcmp(&pkt->refid,\n\t    \"RATE\", 4) == 0) {\n\t\tpeer->selbroken++;\n\t\treport_event(PEVNT_RATE, peer, NULL);\n\t\tif (pkt->ppoll > peer->minpoll)\n\t\t\tpeer->minpoll = peer->ppoll;\n\t\tpeer->burst = peer->retry = 0;\n\t\tpeer->throttle = (NTP_SHIFT + 1) * (1 << peer->minpoll);\n\t\tpoll_update(peer, pkt->ppoll);\n\t\treturn;\t\t\t\t/* kiss-o'-death */\n\t}\n\n\t/*\n\t * That was hard and I am sweaty, but the packet is squeaky\n\t * clean. Get on with real work.\n\t */\n\tpeer->timereceived = current_time;\n\tif (is_authentic == AUTH_OK)\n\t\tpeer->flags |= FLAG_AUTHENTIC;\n\telse\n\t\tpeer->flags &= ~FLAG_AUTHENTIC;\n\n#ifdef AUTOKEY\n\t/*\n\t * More autokey dance. The rules of the cha-cha are as follows:\n\t *\n\t * 1. If there is no key or the key is not auto, do nothing.\n\t *\n\t * 2. If this packet is in response to the one just previously\n\t *    sent or from a broadcast server, do the extension fields.\n\t *    Otherwise, assume bogosity and bail out.\n\t *\n\t * 3. If an extension field contains a verified signature, it is\n\t *    self-authenticated and we sit the dance.\n\t *\n\t * 4. If this is a server reply, check only to see that the\n\t *    transmitted key ID matches the received key ID.\n\t *\n\t * 5. Check to see that one or more hashes of the current key ID\n\t *    matches the previous key ID or ultimate original key ID\n\t *    obtained from the broadcaster or symmetric peer. If no\n\t *    match, sit the dance and call for new autokey values.\n\t *\n\t * In case of crypto error, fire the orchestra, stop dancing and\n\t * restart the protocol.\n\t */\n\tif (peer->flags & FLAG_SKEY) {\n\t\t/*\n\t\t * Decrement remaining autokey hashes. This isn't\n\t\t * perfect if a packet is lost, but results in no harm.\n\t\t */\n\t\tap = (struct autokey *)peer->recval.ptr;\n\t\tif (ap != NULL) {\n\t\t\tif (ap->seq > 0)\n\t\t\t\tap->seq--;\n\t\t}\n\t\tpeer->flash |= TEST8;\n\t\trval = crypto_recv(peer, rbufp);\n\t\tif (rval == XEVNT_OK) {\n\t\t\tpeer->unreach = 0;\n\t\t} else {\n\t\t\tif (rval == XEVNT_ERR) {\n\t\t\t\treport_event(PEVNT_RESTART, peer,\n\t\t\t\t    \"crypto error\");\n\t\t\t\tpeer_clear(peer, \"CRYP\");\n\t\t\t\tpeer->flash |= TEST9;\t/* bad crypt */\n\t\t\t\tif (peer->flags & FLAG_PREEMPT)\n\t\t\t\t\tunpeer(peer);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * If server mode, verify the receive key ID matches\n\t\t * the transmit key ID.\n\t\t */\n\t\tif (hismode == MODE_SERVER) {\n\t\t\tif (skeyid == peer->keyid)\n\t\t\t\tpeer->flash &= ~TEST8;\n\n\t\t/*\n\t\t * If an extension field is present, verify only that it\n\t\t * has been correctly signed. We don't need a sequence\n\t\t * check here, but the sequence continues.\n\t\t */\n\t\t} else if (!(peer->flash & TEST8)) {\n\t\t\tpeer->pkeyid = skeyid;\n\n\t\t/*\n\t\t * Now the fun part. Here, skeyid is the current ID in\n\t\t * the packet, pkeyid is the ID in the last packet and\n\t\t * tkeyid is the hash of skeyid. If the autokey values\n\t\t * have not been received, this is an automatic error.\n\t\t * If so, check that the tkeyid matches pkeyid. If not,\n\t\t * hash tkeyid and try again. If the number of hashes\n\t\t * exceeds the number remaining in the sequence, declare\n\t\t * a successful failure and refresh the autokey values.\n\t\t */\n\t\t} else if (ap != NULL) {\n\t\t\tint i;\n\n\t\t\tfor (i = 0; ; i++) {\n\t\t\t\tif (tkeyid == peer->pkeyid ||\n\t\t\t\t    tkeyid == ap->key) {\n\t\t\t\t\tpeer->flash &= ~TEST8;\n\t\t\t\t\tpeer->pkeyid = skeyid;\n\t\t\t\t\tap->seq -= i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (i > ap->seq) {\n\t\t\t\t\tpeer->crypto &=\n\t\t\t\t\t    ~CRYPTO_FLAG_AUTO;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttkeyid = session_key(\n\t\t\t\t    &rbufp->recv_srcadr, dstadr_sin,\n\t\t\t\t    tkeyid, pkeyid, 0);\n\t\t\t}\n\t\t\tif (peer->flash & TEST8)\n\t\t\t\treport_event(PEVNT_AUTH, peer, \"keylist\");\n\t\t}\n\t\tif (!(peer->crypto & CRYPTO_FLAG_PROV)) /* test 9 */\n\t\t\tpeer->flash |= TEST8;\t/* bad autokey */\n\n\t\t/*\n\t\t * The maximum lifetime of the protocol is about one\n\t\t * week before restarting the Autokey protocol to\n\t\t * refresh certificates and leapseconds values.\n\t\t */\n\t\tif (current_time > peer->refresh) {\n\t\t\treport_event(PEVNT_RESTART, peer,\n\t\t\t    \"crypto refresh\");\n\t\t\tpeer_clear(peer, \"TIME\");\n\t\t\treturn;\n\t\t}\n\t}\n#endif\t/* AUTOKEY */\n\n\t/*\n\t * The dance is complete and the flash bits have been lit. Toss\n\t * the packet over the fence for processing, which may light up\n\t * more flashers.\n\t */\n\tprocess_packet(peer, pkt, rbufp->recv_length);\n\n\t/*\n\t * In interleaved mode update the state variables. Also adjust the\n\t * transmit phase to avoid crossover.\n\t */\n\tif (peer->flip != 0) {\n\t\tpeer->rec = p_rec;\n\t\tpeer->dst = rbufp->recv_time;\n\t\tif (peer->nextdate - current_time < (1U << min(peer->ppoll,\n\t\t    peer->hpoll)) / 2)\n\t\t\tpeer->nextdate++;\n\t\telse\n\t\t\tpeer->nextdate--;\n\t}\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145716,
    "RELATED_CWE": [
      "CWE-862",
      "CWE-285",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-287"
    ],
    "code": "receive(\n\tstruct recvbuf *rbufp\n\t)\n{\n\tregister struct peer *peer;\t/* peer structure pointer */\n\tregister struct pkt *pkt;\t/* receive packet pointer */\n\tu_char\thisversion;\t\t/* packet version */\n\tu_char\thisleap;\t\t/* packet leap indicator */\n\tu_char\thismode;\t\t/* packet mode */\n\tu_char\thisstratum;\t\t/* packet stratum */\n\tu_short\trestrict_mask;\t\t/* restrict bits */\n\tint\thas_mac;\t\t/* length of MAC field */\n\tint\tauthlen;\t\t/* offset of MAC field */\n\tint\tis_authentic = 0;\t/* cryptosum ok */\n\tint\tretcode = AM_NOMATCH;\t/* match code */\n\tkeyid_t\tskeyid = 0;\t\t/* key IDs */\n\tu_int32\topcode = 0;\t\t/* extension field opcode */\n\tsockaddr_u *dstadr_sin; \t/* active runway */\n\tstruct peer *peer2;\t\t/* aux peer structure pointer */\n\tendpt *\tmatch_ep;\t\t/* newpeer() local address */\n\tl_fp\tp_org;\t\t\t/* origin timestamp */\n\tl_fp\tp_rec;\t\t\t/* receive timestamp */\n\tl_fp\tp_xmt;\t\t\t/* transmit timestamp */\n#ifdef AUTOKEY\n\tchar\thostname[NTP_MAXSTRLEN + 1];\n\tchar\t*groupname = NULL;\n\tstruct autokey *ap;\t\t/* autokey structure pointer */\n\tint\trval;\t\t\t/* cookie snatcher */\n\tkeyid_t\tpkeyid = 0, tkeyid = 0;\t/* key IDs */\n#endif\t/* AUTOKEY */\n#ifdef HAVE_NTP_SIGND\n\tstatic unsigned char zero_key[16];\n#endif /* HAVE_NTP_SIGND */\n\n\t/*\n\t * Monitor the packet and get restrictions. Note that the packet\n\t * length for control and private mode packets must be checked\n\t * by the service routines. Some restrictions have to be handled\n\t * later in order to generate a kiss-o'-death packet.\n\t */\n\t/*\n\t * Bogus port check is before anything, since it probably\n\t * reveals a clogging attack.\n\t */\n\tsys_received++;\n\tif (0 == SRCPORT(&rbufp->recv_srcadr)) {\n\t\tsys_badlength++;\n\t\treturn;\t\t\t\t/* bogus port */\n\t}\n\trestrict_mask = restrictions(&rbufp->recv_srcadr);\n\tDPRINTF(2, (\"receive: at %ld %s<-%s flags %x restrict %03x\\n\",\n\t\t    current_time, stoa(&rbufp->dstadr->sin),\n\t\t    stoa(&rbufp->recv_srcadr),\n\t\t    rbufp->dstadr->flags, restrict_mask));\n\tpkt = &rbufp->recv_pkt;\n\thisversion = PKT_VERSION(pkt->li_vn_mode);\n\thisleap = PKT_LEAP(pkt->li_vn_mode);\n\thismode = (int)PKT_MODE(pkt->li_vn_mode);\n\thisstratum = PKT_TO_STRATUM(pkt->stratum);\n\tif (restrict_mask & RES_IGNORE) {\n\t\tsys_restricted++;\n\t\treturn;\t\t\t\t/* ignore everything */\n\t}\n\tif (hismode == MODE_PRIVATE) {\n\t\tif (!ntp_mode7 || (restrict_mask & RES_NOQUERY)) {\n\t\t\tsys_restricted++;\n\t\t\treturn;\t\t\t/* no query private */\n\t\t}\n\t\tprocess_private(rbufp, ((restrict_mask &\n\t\t    RES_NOMODIFY) == 0));\n\t\treturn;\n\t}\n\tif (hismode == MODE_CONTROL) {\n\t\tif (restrict_mask & RES_NOQUERY) {\n\t\t\tsys_restricted++;\n\t\t\treturn;\t\t\t/* no query control */\n\t\t}\n\t\tprocess_control(rbufp, restrict_mask);\n\t\treturn;\n\t}\n\tif (restrict_mask & RES_DONTSERVE) {\n\t\tsys_restricted++;\n\t\treturn;\t\t\t\t/* no time serve */\n\t}\n\n\t/*\n\t * This is for testing. If restricted drop ten percent of\n\t * surviving packets.\n\t */\n\tif (restrict_mask & RES_FLAKE) {\n\t\tif ((double)ntp_random() / 0x7fffffff < .1) {\n\t\t\tsys_restricted++;\n\t\t\treturn;\t\t\t/* no flakeway */\n\t\t}\n\t}\n\n\t/*\n\t * Version check must be after the query packets, since they\n\t * intentionally use an early version.\n\t */\n\tif (hisversion == NTP_VERSION) {\n\t\tsys_newversion++;\t\t/* new version */\n\t} else if (!(restrict_mask & RES_VERSION) && hisversion >=\n\t    NTP_OLDVERSION) {\n\t\tsys_oldversion++;\t\t/* previous version */\n\t} else {\n\t\tsys_badlength++;\n\t\treturn;\t\t\t\t/* old version */\n\t}\n\n\t/*\n\t * Figure out his mode and validate the packet. This has some\n\t * legacy raunch that probably should be removed. In very early\n\t * NTP versions mode 0 was equivalent to what later versions\n\t * would interpret as client mode.\n\t */\n\tif (hismode == MODE_UNSPEC) {\n\t\tif (hisversion == NTP_OLDVERSION) {\n\t\t\thismode = MODE_CLIENT;\n\t\t} else {\n\t\t\tsys_badlength++;\n\t\t\treturn;                 /* invalid mode */\n\t\t}\n\t}\n\n\t/*\n\t * Parse the extension field if present. We figure out whether\n\t * an extension field is present by measuring the MAC size. If\n\t * the number of words following the packet header is 0, no MAC\n\t * is present and the packet is not authenticated. If 1, the\n\t * packet is a crypto-NAK; if 3, the packet is authenticated\n\t * with DES; if 5, the packet is authenticated with MD5; if 6,\n\t * the packet is authenticated with SHA. If 2 or * 4, the packet\n\t * is a runt and discarded forthwith. If greater than 6, an\n\t * extension field is present, so we subtract the length of the\n\t * field and go around again.\n\t */\n\tauthlen = LEN_PKT_NOMAC;\n\thas_mac = rbufp->recv_length - authlen;\n\twhile (has_mac > 0) {\n\t\tu_int32\tlen;\n#ifdef AUTOKEY\n\t\tu_int32\thostlen;\n\t\tstruct exten *ep;\n#endif /*AUTOKEY */\n\n\t\tif (has_mac % 4 != 0 || has_mac < (int)MIN_MAC_LEN) {\n\t\t\tsys_badlength++;\n\t\t\treturn;\t\t\t/* bad length */\n\t\t}\n\t\tif (has_mac <= (int)MAX_MAC_LEN) {\n\t\t\tskeyid = ntohl(((u_int32 *)pkt)[authlen / 4]);\n\t\t\tbreak;\n\n\t\t} else {\n\t\t\topcode = ntohl(((u_int32 *)pkt)[authlen / 4]);\n\t\t\tlen = opcode & 0xffff;\n\t\t\tif (len % 4 != 0 || len < 4 || (int)len +\n\t\t\t    authlen > rbufp->recv_length) {\n\t\t\t\tsys_badlength++;\n\t\t\t\treturn;\t\t/* bad length */\n\t\t\t}\n#ifdef AUTOKEY\n\t\t\t/*\n\t\t\t * Extract calling group name for later.  If\n\t\t\t * sys_groupname is non-NULL, there must be\n\t\t\t * a group name provided to elicit a response.\n\t\t\t */\n\t\t\tif ((opcode & 0x3fff0000) == CRYPTO_ASSOC &&\n\t\t\t    sys_groupname != NULL) {\n\t\t\t\tep = (struct exten *)&((u_int32 *)pkt)[authlen / 4];\n\t\t\t\thostlen = ntohl(ep->vallen);\n\t\t\t\tif (hostlen >= sizeof(hostname) ||\n\t\t\t\t    hostlen > len -\n\t\t\t\t    offsetof(struct exten, pkt)) {\n\t\t\t\t\tsys_badlength++;\n\t\t\t\t\treturn;\t\t/* bad length */\n\t\t\t\t}\n\t\t\t\tmemcpy(hostname, &ep->pkt, hostlen);\n\t\t\t\thostname[hostlen] = '\\0';\n\t\t\t\tgroupname = strchr(hostname, '@');\n\t\t\t\tif (groupname == NULL) {\n\t\t\t\t\tsys_declined++;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tgroupname++;\n\t\t\t}\n#endif /* AUTOKEY */\n\t\t\tauthlen += len;\n\t\t\thas_mac -= len;\n\t\t}\n\t}\n\n\t/*\n\t * If has_mac is < 0 we had a malformed packet.\n\t */\n\tif (has_mac < 0) {\n\t\tsys_badlength++;\n\t\treturn;\t\t/* bad length */\n\t}\n\n\t/*\n\t * If authentication required, a MAC must be present.\n\t */\n\tif (restrict_mask & RES_DONTTRUST && has_mac == 0) {\n\t\tsys_restricted++;\n\t\treturn;\t\t\t\t/* access denied */\n\t}\n\n\t/*\n\t * Update the MRU list and finger the cloggers. It can be a\n\t * little expensive, so turn it off for production use.\n\t * RES_LIMITED and RES_KOD will be cleared in the returned\n\t * restrict_mask unless one or both actions are warranted.\n\t */\n\trestrict_mask = ntp_monitor(rbufp, restrict_mask);\n\tif (restrict_mask & RES_LIMITED) {\n\t\tsys_limitrejected++;\n\t\tif (!(restrict_mask & RES_KOD) || MODE_BROADCAST ==\n\t\t    hismode || MODE_SERVER == hismode) {\n\t\t\tif (MODE_SERVER == hismode)\n\t\t\t\tDPRINTF(1, (\"Possibly self-induced rate limiting of MODE_SERVER from %s\\n\",\n\t\t\t\t\tstoa(&rbufp->recv_srcadr)));\n\t\t\treturn;\t\t\t/* rate exceeded */\n\t\t}\n\t\tif (hismode == MODE_CLIENT)\n\t\t\tfast_xmit(rbufp, MODE_SERVER, skeyid,\n\t\t\t    restrict_mask);\n\t\telse\n\t\t\tfast_xmit(rbufp, MODE_ACTIVE, skeyid,\n\t\t\t    restrict_mask);\n\t\treturn;\t\t\t\t/* rate exceeded */\n\t}\n\trestrict_mask &= ~RES_KOD;\n\n\t/*\n\t * We have tossed out as many buggy packets as possible early in\n\t * the game to reduce the exposure to a clogging attack. Now we\n\t * have to burn some cycles to find the association and\n\t * authenticate the packet if required. Note that we burn only\n\t * digest cycles, again to reduce exposure. There may be no\n\t * matching association and that's okay.\n\t *\n\t * More on the autokey mambo. Normally the local interface is\n\t * found when the association was mobilized with respect to a\n\t * designated remote address. We assume packets arriving from\n\t * the remote address arrive via this interface and the local\n\t * address used to construct the autokey is the unicast address\n\t * of the interface. However, if the sender is a broadcaster,\n\t * the interface broadcast address is used instead.\n\t * Notwithstanding this technobabble, if the sender is a\n\t * multicaster, the broadcast address is null, so we use the\n\t * unicast address anyway. Don't ask.\n\t */\n\tpeer = findpeer(rbufp,  hismode, &retcode);\n\tdstadr_sin = &rbufp->dstadr->sin;\n\tNTOHL_FP(&pkt->org, &p_org);\n\tNTOHL_FP(&pkt->rec, &p_rec);\n\tNTOHL_FP(&pkt->xmt, &p_xmt);\n\n\t/*\n\t * Authentication is conditioned by three switches:\n\t *\n\t * NOPEER  (RES_NOPEER) do not mobilize an association unless\n\t *         authenticated\n\t * NOTRUST (RES_DONTTRUST) do not allow access unless\n\t *         authenticated (implies NOPEER)\n\t * enable  (sys_authenticate) master NOPEER switch, by default\n\t *         on\n\t *\n\t * The NOPEER and NOTRUST can be specified on a per-client basis\n\t * using the restrict command. The enable switch if on implies\n\t * NOPEER for all clients. There are four outcomes:\n\t *\n\t * NONE    The packet has no MAC.\n\t * OK      the packet has a MAC and authentication succeeds\n\t * ERROR   the packet has a MAC and authentication fails\n\t * CRYPTO  crypto-NAK. The MAC has four octets only.\n\t *\n\t * Note: The AUTH(x, y) macro is used to filter outcomes. If x\n\t * is zero, acceptable outcomes of y are NONE and OK. If x is\n\t * one, the only acceptable outcome of y is OK.\n\t */\n\n\tif (has_mac == 0) {\n\t\trestrict_mask &= ~RES_MSSNTP;\n\t\tis_authentic = AUTH_NONE; /* not required */\n#ifdef DEBUG\n\t\tif (debug)\n\t\t\tprintf(\n\t\t\t    \"receive: at %ld %s<-%s mode %d len %d\\n\",\n\t\t\t    current_time, stoa(dstadr_sin),\n\t\t\t    stoa(&rbufp->recv_srcadr), hismode,\n\t\t\t    authlen);\n#endif\n\t} else if (has_mac == 4) {\n\t\trestrict_mask &= ~RES_MSSNTP;\n\t\tis_authentic = AUTH_CRYPTO; /* crypto-NAK */\n#ifdef DEBUG\n\t\tif (debug)\n\t\t\tprintf(\n\t\t\t    \"receive: at %ld %s<-%s mode %d keyid %08x len %d auth %d\\n\",\n\t\t\t    current_time, stoa(dstadr_sin),\n\t\t\t    stoa(&rbufp->recv_srcadr), hismode, skeyid,\n\t\t\t    authlen + has_mac, is_authentic);\n#endif\n\n#ifdef HAVE_NTP_SIGND\n\t\t/*\n\t\t * If the signature is 20 bytes long, the last 16 of\n\t\t * which are zero, then this is a Microsoft client\n\t\t * wanting AD-style authentication of the server's\n\t\t * reply.\n\t\t *\n\t\t * This is described in Microsoft's WSPP docs, in MS-SNTP:\n\t\t * http://msdn.microsoft.com/en-us/library/cc212930.aspx\n\t\t */\n\t} else if (has_mac == MAX_MD5_LEN && (restrict_mask & RES_MSSNTP) &&\n\t   (retcode == AM_FXMIT || retcode == AM_NEWPASS) &&\n\t   (memcmp(zero_key, (char *)pkt + authlen + 4, MAX_MD5_LEN - 4) ==\n\t   0)) {\n\t\tis_authentic = AUTH_NONE;\n#endif /* HAVE_NTP_SIGND */\n\n\t} else {\n\t\trestrict_mask &= ~RES_MSSNTP;\n#ifdef AUTOKEY\n\t\t/*\n\t\t * For autokey modes, generate the session key\n\t\t * and install in the key cache. Use the socket\n\t\t * broadcast or unicast address as appropriate.\n\t\t */\n\t\tif (crypto_flags && skeyid > NTP_MAXKEY) {\n\n\t\t\t/*\n\t\t\t * More on the autokey dance (AKD). A cookie is\n\t\t\t * constructed from public and private values.\n\t\t\t * For broadcast packets, the cookie is public\n\t\t\t * (zero). For packets that match no\n\t\t\t * association, the cookie is hashed from the\n\t\t\t * addresses and private value. For server\n\t\t\t * packets, the cookie was previously obtained\n\t\t\t * from the server. For symmetric modes, the\n\t\t\t * cookie was previously constructed using an\n\t\t\t * agreement protocol; however, should PKI be\n\t\t\t * unavailable, we construct a fake agreement as\n\t\t\t * the EXOR of the peer and host cookies.\n\t\t\t *\n\t\t\t * hismode\tephemeral\tpersistent\n\t\t\t * =======================================\n\t\t\t * active\t0\t\tcookie#\n\t\t\t * passive\t0%\t\tcookie#\n\t\t\t * client\tsys cookie\t0%\n\t\t\t * server\t0%\t\tsys cookie\n\t\t\t * broadcast\t0\t\t0\n\t\t\t *\n\t\t\t * # if unsync, 0\n\t\t\t * % can't happen\n\t\t\t */\n\t\t\tif (has_mac < (int)MAX_MD5_LEN) {\n\t\t\t\tsys_badauth++;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (hismode == MODE_BROADCAST) {\n\n\t\t\t\t/*\n\t\t\t\t * For broadcaster, use the interface\n\t\t\t\t * broadcast address when available;\n\t\t\t\t * otherwise, use the unicast address\n\t\t\t\t * found when the association was\n\t\t\t\t * mobilized. However, if this is from\n\t\t\t\t * the wildcard interface, game over.\n\t\t\t\t */\n\t\t\t\tif (crypto_flags && rbufp->dstadr ==\n\t\t\t\t    ANY_INTERFACE_CHOOSE(&rbufp->recv_srcadr)) {\n\t\t\t\t\tsys_restricted++;\n\t\t\t\t\treturn;\t     /* no wildcard */\n\t\t\t\t}\n\t\t\t\tpkeyid = 0;\n\t\t\t\tif (!SOCK_UNSPEC(&rbufp->dstadr->bcast))\n\t\t\t\t\tdstadr_sin =\n\t\t\t\t\t    &rbufp->dstadr->bcast;\n\t\t\t} else if (peer == NULL) {\n\t\t\t\tpkeyid = session_key(\n\t\t\t\t    &rbufp->recv_srcadr, dstadr_sin, 0,\n\t\t\t\t    sys_private, 0);\n\t\t\t} else {\n\t\t\t\tpkeyid = peer->pcookie;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The session key includes both the public\n\t\t\t * values and cookie. In case of an extension\n\t\t\t * field, the cookie used for authentication\n\t\t\t * purposes is zero. Note the hash is saved for\n\t\t\t * use later in the autokey mambo.\n\t\t\t */\n\t\t\tif (authlen > (int)LEN_PKT_NOMAC && pkeyid != 0) {\n\t\t\t\tsession_key(&rbufp->recv_srcadr,\n\t\t\t\t    dstadr_sin, skeyid, 0, 2);\n\t\t\t\ttkeyid = session_key(\n\t\t\t\t    &rbufp->recv_srcadr, dstadr_sin,\n\t\t\t\t    skeyid, pkeyid, 0);\n\t\t\t} else {\n\t\t\t\ttkeyid = session_key(\n\t\t\t\t    &rbufp->recv_srcadr, dstadr_sin,\n\t\t\t\t    skeyid, pkeyid, 2);\n\t\t\t}\n\n\t\t}\n#endif\t/* AUTOKEY */\n\n\t\t/*\n\t\t * Compute the cryptosum. Note a clogging attack may\n\t\t * succeed in bloating the key cache. If an autokey,\n\t\t * purge it immediately, since we won't be needing it\n\t\t * again. If the packet is authentic, it can mobilize an\n\t\t * association. Note that there is no key zero.\n\t\t */\n\t\tif (!authdecrypt(skeyid, (u_int32 *)pkt, authlen,\n\t\t    has_mac))\n\t\t\tis_authentic = AUTH_ERROR;\n\t\telse\n\t\t\tis_authentic = AUTH_OK;\n#ifdef AUTOKEY\n\t\tif (crypto_flags && skeyid > NTP_MAXKEY)\n\t\t\tauthtrust(skeyid, 0);\n#endif\t/* AUTOKEY */\n#ifdef DEBUG\n\t\tif (debug)\n\t\t\tprintf(\n\t\t\t    \"receive: at %ld %s<-%s mode %d keyid %08x len %d auth %d\\n\",\n\t\t\t    current_time, stoa(dstadr_sin),\n\t\t\t    stoa(&rbufp->recv_srcadr), hismode, skeyid,\n\t\t\t    authlen + has_mac, is_authentic);\n#endif\n\t}\n\n\t/*\n\t * The association matching rules are implemented by a set of\n\t * routines and an association table. A packet matching an\n\t * association is processed by the peer process for that\n\t * association. If there are no errors, an ephemeral association\n\t * is mobilized: a broadcast packet mobilizes a broadcast client\n\t * aassociation; a manycast server packet mobilizes a manycast\n\t * client association; a symmetric active packet mobilizes a\n\t * symmetric passive association.\n\t */\n\tswitch (retcode) {\n\n\t/*\n\t * This is a client mode packet not matching any association. If\n\t * an ordinary client, simply toss a server mode packet back\n\t * over the fence. If a manycast client, we have to work a\n\t * little harder.\n\t */\n\tcase AM_FXMIT:\n\n\t\t/*\n\t\t * If authentication OK, send a server reply; otherwise,\n\t\t * send a crypto-NAK.\n\t\t */\n\t\tif (!(rbufp->dstadr->flags & INT_MCASTOPEN)) {\n\t\t\tif (AUTH(restrict_mask & RES_DONTTRUST,\n\t\t\t   is_authentic)) {\n\t\t\t\tfast_xmit(rbufp, MODE_SERVER, skeyid,\n\t\t\t\t    restrict_mask);\n\t\t\t} else if (is_authentic == AUTH_ERROR) {\n\t\t\t\tfast_xmit(rbufp, MODE_SERVER, 0,\n\t\t\t\t    restrict_mask);\n\t\t\t\tsys_badauth++;\n\t\t\t} else {\n\t\t\t\tsys_restricted++;\n\t\t\t}\n\t\t\treturn;\t\t\t/* hooray */\n\t\t}\n\n\t\t/*\n\t\t * This must be manycast. Do not respond if not\n\t\t * configured as a manycast server.\n\t\t */\n\t\tif (!sys_manycastserver) {\n\t\t\tsys_restricted++;\n\t\t\treturn;\t\t\t/* not enabled */\n\t\t}\n\n#ifdef AUTOKEY\n\t\t/*\n\t\t * Do not respond if not the same group.\n\t\t */\n\t\tif (group_test(groupname, NULL)) {\n\t\t\tsys_declined++;\n\t\t\treturn;\n\t\t}\n#endif /* AUTOKEY */\n\n\t\t/*\n\t\t * Do not respond if we are not synchronized or our\n\t\t * stratum is greater than the manycaster or the\n\t\t * manycaster has already synchronized to us.\n\t\t */\n\t\tif (sys_leap == LEAP_NOTINSYNC || sys_stratum >=\n\t\t    hisstratum || (!sys_cohort && sys_stratum ==\n\t\t    hisstratum + 1) || rbufp->dstadr->addr_refid ==\n\t\t    pkt->refid) {\n\t\t\tsys_declined++;\n\t\t\treturn;\t\t\t/* no help */\n\t\t}\n\n\t\t/*\n\t\t * Respond only if authentication succeeds. Don't do a\n\t\t * crypto-NAK, as that would not be useful.\n\t\t */\n\t\tif (AUTH(restrict_mask & RES_DONTTRUST, is_authentic))\n\t\t\tfast_xmit(rbufp, MODE_SERVER, skeyid,\n\t\t\t    restrict_mask);\n\t\treturn;\t\t\t\t/* hooray */\n\n\t/*\n\t * This is a server mode packet returned in response to a client\n\t * mode packet sent to a multicast group address (for\n\t * manycastclient) or to a unicast address (for pool). The\n\t * origin timestamp is a good nonce to reliably associate the\n\t * reply with what was sent. If there is no match, that's\n\t * curious and could be an intruder attempting to clog, so we\n\t * just ignore it.\n\t *\n\t * If the packet is authentic and the manycastclient or pool\n\t * association is found, we mobilize a client association and\n\t * copy pertinent variables from the manycastclient or pool\n\t * association to the new client association. If not, just\n\t * ignore the packet.\n\t *\n\t * There is an implosion hazard at the manycast client, since\n\t * the manycast servers send the server packet immediately. If\n\t * the guy is already here, don't fire up a duplicate.\n\t */\n\tcase AM_MANYCAST:\n\n#ifdef AUTOKEY\n\t\t/*\n\t\t * Do not respond if not the same group.\n\t\t */\n\t\tif (group_test(groupname, NULL)) {\n\t\t\tsys_declined++;\n\t\t\treturn;\n\t\t}\n#endif /* AUTOKEY */\n\t\tif ((peer2 = findmanycastpeer(rbufp)) == NULL) {\n\t\t\tsys_restricted++;\n\t\t\treturn;\t\t\t/* not enabled */\n\t\t}\n\t\tif (!AUTH((!(peer2->cast_flags & MDF_POOL) &&\n\t\t    sys_authenticate) | (restrict_mask & (RES_NOPEER |\n\t\t    RES_DONTTRUST)), is_authentic)) {\n\t\t\tsys_restricted++;\n\t\t\treturn;\t\t\t/* access denied */\n\t\t}\n\n\t\t/*\n\t\t * Do not respond if unsynchronized or stratum is below\n\t\t * the floor or at or above the ceiling.\n\t\t */\n\t\tif (hisleap == LEAP_NOTINSYNC || hisstratum <\n\t\t    sys_floor || hisstratum >= sys_ceiling) {\n\t\t\tsys_declined++;\n\t\t\treturn;\t\t\t/* no help */\n\t\t}\n\t\tpeer = newpeer(&rbufp->recv_srcadr, NULL, rbufp->dstadr,\n\t\t\t       MODE_CLIENT, hisversion, peer2->minpoll,\n\t\t\t       peer2->maxpoll, FLAG_PREEMPT |\n\t\t\t       (FLAG_IBURST & peer2->flags), MDF_UCAST |\n\t\t\t       MDF_UCLNT, 0, skeyid, sys_ident);\n\t\tif (NULL == peer) {\n\t\t\tsys_declined++;\n\t\t\treturn;\t\t\t/* ignore duplicate  */\n\t\t}\n\n\t\t/*\n\t\t * After each ephemeral pool association is spun,\n\t\t * accelerate the next poll for the pool solicitor so\n\t\t * the pool will fill promptly.\n\t\t */\n\t\tif (peer2->cast_flags & MDF_POOL)\n\t\t\tpeer2->nextdate = current_time + 1;\n\n\t\t/*\n\t\t * Further processing of the solicitation response would\n\t\t * simply detect its origin timestamp as bogus for the\n\t\t * brand-new association (it matches the prototype\n\t\t * association) and tinker with peer->nextdate delaying\n\t\t * first sync.\n\t\t */\n\t\treturn;\t\t/* solicitation response handled */\n\n\t/*\n\t * This is the first packet received from a broadcast server. If\n\t * the packet is authentic and we are enabled as broadcast\n\t * client, mobilize a broadcast client association. We don't\n\t * kiss any frogs here.\n\t */\n\tcase AM_NEWBCL:\n\n#ifdef AUTOKEY\n\t\t/*\n\t\t * Do not respond if not the same group.\n\t\t */\n\t\tif (group_test(groupname, sys_ident)) {\n\t\t\tsys_declined++;\n\t\t\treturn;\n\t\t}\n#endif /* AUTOKEY */\n\t\tif (sys_bclient == 0) {\n\t\t\tsys_restricted++;\n\t\t\treturn;\t\t\t/* not enabled */\n\t\t}\n\t\tif (!AUTH(sys_authenticate | (restrict_mask &\n\t\t    (RES_NOPEER | RES_DONTTRUST)), is_authentic)) {\n\t\t\tsys_restricted++;\n\t\t\treturn;\t\t\t/* access denied */\n\t\t}\n\n\t\t/*\n\t\t * Do not respond if unsynchronized or stratum is below\n\t\t * the floor or at or above the ceiling.\n\t\t */\n\t\tif (hisleap == LEAP_NOTINSYNC || hisstratum <\n\t\t    sys_floor || hisstratum >= sys_ceiling) {\n\t\t\tsys_declined++;\n\t\t\treturn;\t\t\t/* no help */\n\t\t}\n\n#ifdef AUTOKEY\n\t\t/*\n\t\t * Do not respond if Autokey and the opcode is not a\n\t\t * CRYPTO_ASSOC response with association ID.\n\t\t */\n\t\tif (crypto_flags && skeyid > NTP_MAXKEY && (opcode &\n\t\t    0xffff0000) != (CRYPTO_ASSOC | CRYPTO_RESP)) {\n\t\t\tsys_declined++;\n\t\t\treturn;\t\t\t/* protocol error */\n\t\t}\n#endif\t/* AUTOKEY */\n\n\t\t/*\n\t\t * Broadcasts received via a multicast address may\n\t\t * arrive after a unicast volley has begun\n\t\t * with the same remote address.  newpeer() will not\n\t\t * find duplicate associations on other local endpoints\n\t\t * if a non-NULL endpoint is supplied.  multicastclient\n\t\t * ephemeral associations are unique across all local\n\t\t * endpoints.\n\t\t */\n\t\tif (!(INT_MCASTOPEN & rbufp->dstadr->flags))\n\t\t\tmatch_ep = rbufp->dstadr;\n\t\telse\n\t\t\tmatch_ep = NULL;\n\n\t\t/*\n\t\t * Determine whether to execute the initial volley.\n\t\t */\n\t\tif (sys_bdelay != 0) {\n#ifdef AUTOKEY\n\t\t\t/*\n\t\t\t * If a two-way exchange is not possible,\n\t\t\t * neither is Autokey.\n\t\t\t */\n\t\t\tif (crypto_flags && skeyid > NTP_MAXKEY) {\n\t\t\t\tsys_restricted++;\n\t\t\t\treturn;\t\t/* no autokey */\n\t\t\t}\n#endif\t/* AUTOKEY */\n\n\t\t\t/*\n\t\t\t * Do not execute the volley. Start out in\n\t\t\t * broadcast client mode.\n\t\t\t */\n\t\t\tpeer = newpeer(&rbufp->recv_srcadr, NULL,\n\t\t\t    match_ep, MODE_BCLIENT, hisversion,\n\t\t\t    pkt->ppoll, pkt->ppoll, FLAG_PREEMPT,\n\t\t\t    MDF_BCLNT, 0, skeyid, sys_ident);\n\t\t\tif (NULL == peer) {\n\t\t\t\tsys_restricted++;\n\t\t\t\treturn;\t\t/* ignore duplicate */\n\n\t\t\t} else {\n\t\t\t\tpeer->delay = sys_bdelay;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Execute the initial volley in order to calibrate the\n\t\t * propagation delay and run the Autokey protocol.\n\t\t *\n\t\t * Note that the minpoll is taken from the broadcast\n\t\t * packet, normally 6 (64 s) and that the poll interval\n\t\t * is fixed at this value.\n\t\t */\n\t\tpeer = newpeer(&rbufp->recv_srcadr, NULL, match_ep,\n\t\t    MODE_CLIENT, hisversion, pkt->ppoll, pkt->ppoll,\n\t\t    FLAG_BC_VOL | FLAG_IBURST | FLAG_PREEMPT, MDF_BCLNT,\n\t\t    0, skeyid, sys_ident);\n\t\tif (NULL == peer) {\n\t\t\tsys_restricted++;\n\t\t\treturn;\t\t\t/* ignore duplicate */\n\t\t}\n#ifdef AUTOKEY\n\t\tif (skeyid > NTP_MAXKEY)\n\t\t\tcrypto_recv(peer, rbufp);\n#endif\t/* AUTOKEY */\n\n\t\treturn;\t\t\t\t/* hooray */\n\n\t/*\n\t * This is the first packet received from a symmetric active\n\t * peer. If the packet is authentic and the first he sent,\n\t * mobilize a passive association. If not, kiss the frog.\n\t */\n\tcase AM_NEWPASS:\n\n#ifdef AUTOKEY\n\t\t/*\n\t\t * Do not respond if not the same group.\n\t\t */\n\t\tif (group_test(groupname, sys_ident)) {\n\t\t\tsys_declined++;\n\t\t\treturn;\n\t\t}\n#endif /* AUTOKEY */\n\t\tif (!AUTH(sys_authenticate | (restrict_mask &\n\t\t    (RES_NOPEER | RES_DONTTRUST)), is_authentic)) {\n\n\t\t\t/*\n\t\t\t * If authenticated but cannot mobilize an\n\t\t\t * association, send a symmetric passive\n\t\t\t * response without mobilizing an association.\n\t\t\t * This is for drat broken Windows clients. See\n\t\t\t * Microsoft KB 875424 for preferred workaround.\n\t\t\t */\n\t\t\tif (AUTH(restrict_mask & RES_DONTTRUST,\n\t\t\t    is_authentic)) {\n\t\t\t\tfast_xmit(rbufp, MODE_PASSIVE, skeyid,\n\t\t\t\t    restrict_mask);\n\t\t\t\treturn;\t\t\t/* hooray */\n\t\t\t}\n\t\t\tif (is_authentic == AUTH_ERROR) {\n\t\t\t\tfast_xmit(rbufp, MODE_ACTIVE, 0,\n\t\t\t\t    restrict_mask);\n\t\t\t\tsys_restricted++;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t/* [Bug 2941]\n\t\t\t * If we got here, the packet isn't part of an\n\t\t\t * existing association, it isn't correctly\n\t\t\t * authenticated, and it didn't meet either of\n\t\t\t * the previous two special cases so we should\n\t\t\t * just drop it on the floor.  For example,\n\t\t\t * crypto-NAKs (is_authentic == AUTH_CRYPTO)\n\t\t\t * will make it this far.  This is just\n\t\t\t * debug-printed and not logged to avoid log\n\t\t\t * flooding.\n\t\t\t */\n\t\t\tDPRINTF(1, (\"receive: at %ld refusing to mobilize passive association\"\n\t\t\t\t    \" with unknown peer %s mode %d keyid %08x len %d auth %d\\n\",\n\t\t\t\t    current_time, stoa(&rbufp->recv_srcadr),\n\t\t\t\t    hismode, skeyid, (authlen + has_mac),\n\t\t\t\t    is_authentic));\n\t\t\tsys_declined++;\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * Do not respond if synchronized and if stratum is\n\t\t * below the floor or at or above the ceiling. Note,\n\t\t * this allows an unsynchronized peer to synchronize to\n\t\t * us. It would be very strange if he did and then was\n\t\t * nipped, but that could only happen if we were\n\t\t * operating at the top end of the range.  It also means\n\t\t * we will spin an ephemeral association in response to\n\t\t * MODE_ACTIVE KoDs, which will time out eventually.\n\t\t */\n\t\tif (hisleap != LEAP_NOTINSYNC && (hisstratum <\n\t\t    sys_floor || hisstratum >= sys_ceiling)) {\n\t\t\tsys_declined++;\n\t\t\treturn;\t\t\t/* no help */\n\t\t}\n\n\t\t/*\n\t\t * The message is correctly authenticated and allowed.\n\t\t * Mobilize a symmetric passive association.\n\t\t */\n\t\tif ((peer = newpeer(&rbufp->recv_srcadr, NULL,\n\t\t    rbufp->dstadr, MODE_PASSIVE, hisversion, pkt->ppoll,\n\t\t    NTP_MAXDPOLL, 0, MDF_UCAST, 0, skeyid,\n\t\t    sys_ident)) == NULL) {\n\t\t\tsys_declined++;\n\t\t\treturn;\t\t\t/* ignore duplicate */\n\t\t}\n\t\tbreak;\n\n\n\t/*\n\t * Process regular packet. Nothing special.\n\t */\n\tcase AM_PROCPKT:\n\n#ifdef AUTOKEY\n\t\t/*\n\t\t * Do not respond if not the same group.\n\t\t */\n\t\tif (group_test(groupname, peer->ident)) {\n\t\t\tsys_declined++;\n\t\t\treturn;\n\t\t}\n#endif /* AUTOKEY */\n\t\tbreak;\n\n\t/*\n\t * A passive packet matches a passive association. This is\n\t * usually the result of reconfiguring a client on the fly. As\n\t * this association might be legitimate and this packet an\n\t * attempt to deny service, just ignore it.\n\t */\n\tcase AM_ERR:\n\t\tsys_declined++;\n\t\treturn;\n\n\t/*\n\t * For everything else there is the bit bucket.\n\t */\n\tdefault:\n\t\tsys_declined++;\n\t\treturn;\n\t}\n\n#ifdef AUTOKEY\n\t/*\n\t * If the association is configured for Autokey, the packet must\n\t * have a public key ID; if not, the packet must have a\n\t * symmetric key ID.\n\t */\n\tif (is_authentic != AUTH_CRYPTO && (((peer->flags &\n\t    FLAG_SKEY) && skeyid <= NTP_MAXKEY) || (!(peer->flags &\n\t    FLAG_SKEY) && skeyid > NTP_MAXKEY))) {\n\t\tsys_badauth++;\n\t\treturn;\n\t}\n#endif\t/* AUTOKEY */\n\tpeer->received++;\n\tpeer->flash &= ~PKT_TEST_MASK;\n\tif (peer->flags & FLAG_XBOGUS) {\n\t\tpeer->flags &= ~FLAG_XBOGUS;\n\t\tpeer->flash |= TEST3;\n\t}\n\n\t/*\n\t * Next comes a rigorous schedule of timestamp checking. If the\n\t * transmit timestamp is zero, the server has not initialized in\n\t * interleaved modes or is horribly broken.\n\t */\n\tif (L_ISZERO(&p_xmt)) {\n\t\tpeer->flash |= TEST3;\t\t\t/* unsynch */\n\n\t/*\n\t * If the transmit timestamp duplicates a previous one, the\n\t * packet is a replay. This prevents the bad guys from replaying\n\t * the most recent packet, authenticated or not.\n\t */\n\t} else if (L_ISEQU(&peer->xmt, &p_xmt)) {\n\t\tpeer->flash |= TEST1;\t\t\t/* duplicate */\n\t\tpeer->oldpkt++;\n\t\treturn;\n\n\t/*\n\t * If this is a broadcast mode packet, skip further checking. If\n\t * an initial volley, bail out now and let the client do its\n\t * stuff. If the origin timestamp is nonzero, this is an\n\t * interleaved broadcast. so restart the protocol.\n\t */\n\t} else if (hismode == MODE_BROADCAST) {\n\t\tif (!L_ISZERO(&p_org) && !(peer->flags & FLAG_XB)) {\n\t\t\tpeer->flags |= FLAG_XB;\n\t\t\tpeer->aorg = p_xmt;\n\t\t\tpeer->borg = rbufp->recv_time;\n\t\t\treport_event(PEVNT_XLEAVE, peer, NULL);\n\t\t\treturn;\n\t\t}\n\n\t/*\n\t * Check for bogus packet in basic mode. If found, switch to\n\t * interleaved mode and resynchronize, but only after confirming\n\t * the packet is not bogus in symmetric interleaved mode.\n\t */\n\t} else if (peer->flip == 0) {\n\t\tif (!L_ISEQU(&p_org, &peer->aorg)) {\n\t\t\tpeer->bogusorg++;\n\t\t\tpeer->flash |= TEST2;\t/* bogus */\n\t\t\tif (!L_ISZERO(&peer->dst) && L_ISEQU(&p_org,\n\t\t\t    &peer->dst)) {\n\t\t\t\tpeer->flip = 1;\n\t\t\t\treport_event(PEVNT_XLEAVE, peer, NULL);\n\t\t\t}\n\t\t} else {\n\t\t\tL_CLR(&peer->aorg);\n\t\t}\n\n\t/*\n\t * Check for valid nonzero timestamp fields.\n\t */\n\t} else if (L_ISZERO(&p_org) || L_ISZERO(&p_rec) ||\n\t    L_ISZERO(&peer->dst)) {\n\t\tpeer->flash |= TEST3;\t\t/* unsynch */\n\n\t/*\n\t * Check for bogus packet in interleaved symmetric mode. This\n\t * can happen if a packet is lost, duplicated or crossed. If\n\t * found, flip and resynchronize.\n\t */\n\t} else if (!L_ISZERO(&peer->dst) && !L_ISEQU(&p_org,\n\t    &peer->dst)) {\n\t\tpeer->bogusorg++;\n\t\tpeer->flags |= FLAG_XBOGUS;\n\t\tpeer->flash |= TEST2;\t\t/* bogus */\n\t}\n\n\t/*\n\t * If this is a crypto_NAK, the server cannot authenticate a\n\t * client packet. The server might have just changed keys. Clear\n\t * the association and restart the protocol.\n\t */\n\tif (is_authentic == AUTH_CRYPTO) {\n\t\treport_event(PEVNT_AUTH, peer, \"crypto_NAK\");\n\t\tpeer->flash |= TEST5;\t\t/* bad auth */\n\t\tpeer->badauth++;\n\t\tif (peer->flags & FLAG_PREEMPT) {\n\t\t\tunpeer(peer);\n\t\t\treturn;\n\t\t}\n#ifdef AUTOKEY\n\t\tif (peer->crypto)\n\t\t\tpeer_clear(peer, \"AUTH\");\n#endif\t/* AUTOKEY */\n\t\treturn;\n\n\t/*\n\t * If the digest fails or it's missing for authenticated\n\t * associations, the client cannot authenticate a server\n\t * reply to a client packet previously sent. The loopback check\n\t * is designed to avoid a bait-and-switch attack, which was\n\t * possible in past versions. If symmetric modes, return a\n\t * crypto-NAK. The peer should restart the protocol.\n\t */\n\t} else if (!AUTH(peer->keyid || has_mac ||\n\t\t\t (restrict_mask & RES_DONTTRUST), is_authentic)) {\n\t\treport_event(PEVNT_AUTH, peer, \"digest\");\n\t\tpeer->flash |= TEST5;\t\t/* bad auth */\n\t\tpeer->badauth++;\n\t\tif (has_mac &&\n\t\t    (hismode == MODE_ACTIVE || hismode == MODE_PASSIVE))\n\t\t\tfast_xmit(rbufp, MODE_ACTIVE, 0, restrict_mask);\n\t\tif (peer->flags & FLAG_PREEMPT) {\n\t\t\tunpeer(peer);\n\t\t\treturn;\n\t\t}\n#ifdef AUTOKEY\n\t\tif (peer->crypto)\n\t\t\tpeer_clear(peer, \"AUTH\");\n#endif\t/* AUTOKEY */\n\t\treturn;\n\t}\n\n\t/*\n\t * Update the state variables.\n\t */\n\tif (peer->flip == 0) {\n\t\tif (hismode != MODE_BROADCAST)\n\t\t\tpeer->rec = p_xmt;\n\t\tpeer->dst = rbufp->recv_time;\n\t}\n\tpeer->xmt = p_xmt;\n\n\t/*\n\t * Set the peer ppoll to the maximum of the packet ppoll and the\n\t * peer minpoll. If a kiss-o'-death, set the peer minpoll to\n\t * this maximum and advance the headway to give the sender some\n\t * headroom. Very intricate.\n\t */\n\tpeer->ppoll = max(peer->minpoll, pkt->ppoll);\n\tif (hismode == MODE_SERVER && hisleap == LEAP_NOTINSYNC &&\n\t    hisstratum == STRATUM_UNSPEC && memcmp(&pkt->refid,\n\t    \"RATE\", 4) == 0) {\n\t\tpeer->selbroken++;\n\t\treport_event(PEVNT_RATE, peer, NULL);\n\t\tif (pkt->ppoll > peer->minpoll)\n\t\t\tpeer->minpoll = peer->ppoll;\n\t\tpeer->burst = peer->retry = 0;\n\t\tpeer->throttle = (NTP_SHIFT + 1) * (1 << peer->minpoll);\n\t\tpoll_update(peer, pkt->ppoll);\n\t\treturn;\t\t\t\t/* kiss-o'-death */\n\t}\n\n\t/*\n\t * That was hard and I am sweaty, but the packet is squeaky\n\t * clean. Get on with real work.\n\t */\n\tpeer->timereceived = current_time;\n\tif (is_authentic == AUTH_OK)\n\t\tpeer->flags |= FLAG_AUTHENTIC;\n\telse\n\t\tpeer->flags &= ~FLAG_AUTHENTIC;\n\n#ifdef AUTOKEY\n\t/*\n\t * More autokey dance. The rules of the cha-cha are as follows:\n\t *\n\t * 1. If there is no key or the key is not auto, do nothing.\n\t *\n\t * 2. If this packet is in response to the one just previously\n\t *    sent or from a broadcast server, do the extension fields.\n\t *    Otherwise, assume bogosity and bail out.\n\t *\n\t * 3. If an extension field contains a verified signature, it is\n\t *    self-authenticated and we sit the dance.\n\t *\n\t * 4. If this is a server reply, check only to see that the\n\t *    transmitted key ID matches the received key ID.\n\t *\n\t * 5. Check to see that one or more hashes of the current key ID\n\t *    matches the previous key ID or ultimate original key ID\n\t *    obtained from the broadcaster or symmetric peer. If no\n\t *    match, sit the dance and call for new autokey values.\n\t *\n\t * In case of crypto error, fire the orchestra, stop dancing and\n\t * restart the protocol.\n\t */\n\tif (peer->flags & FLAG_SKEY) {\n\t\t/*\n\t\t * Decrement remaining autokey hashes. This isn't\n\t\t * perfect if a packet is lost, but results in no harm.\n\t\t */\n\t\tap = (struct autokey *)peer->recval.ptr;\n\t\tif (ap != NULL) {\n\t\t\tif (ap->seq > 0)\n\t\t\t\tap->seq--;\n\t\t}\n\t\tpeer->flash |= TEST8;\n\t\trval = crypto_recv(peer, rbufp);\n\t\tif (rval == XEVNT_OK) {\n\t\t\tpeer->unreach = 0;\n\t\t} else {\n\t\t\tif (rval == XEVNT_ERR) {\n\t\t\t\treport_event(PEVNT_RESTART, peer,\n\t\t\t\t    \"crypto error\");\n\t\t\t\tpeer_clear(peer, \"CRYP\");\n\t\t\t\tpeer->flash |= TEST9;\t/* bad crypt */\n\t\t\t\tif (peer->flags & FLAG_PREEMPT)\n\t\t\t\t\tunpeer(peer);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * If server mode, verify the receive key ID matches\n\t\t * the transmit key ID.\n\t\t */\n\t\tif (hismode == MODE_SERVER) {\n\t\t\tif (skeyid == peer->keyid)\n\t\t\t\tpeer->flash &= ~TEST8;\n\n\t\t/*\n\t\t * If an extension field is present, verify only that it\n\t\t * has been correctly signed. We don't need a sequence\n\t\t * check here, but the sequence continues.\n\t\t */\n\t\t} else if (!(peer->flash & TEST8)) {\n\t\t\tpeer->pkeyid = skeyid;\n\n\t\t/*\n\t\t * Now the fun part. Here, skeyid is the current ID in\n\t\t * the packet, pkeyid is the ID in the last packet and\n\t\t * tkeyid is the hash of skeyid. If the autokey values\n\t\t * have not been received, this is an automatic error.\n\t\t * If so, check that the tkeyid matches pkeyid. If not,\n\t\t * hash tkeyid and try again. If the number of hashes\n\t\t * exceeds the number remaining in the sequence, declare\n\t\t * a successful failure and refresh the autokey values.\n\t\t */\n\t\t} else if (ap != NULL) {\n\t\t\tint i;\n\n\t\t\tfor (i = 0; ; i++) {\n\t\t\t\tif (tkeyid == peer->pkeyid ||\n\t\t\t\t    tkeyid == ap->key) {\n\t\t\t\t\tpeer->flash &= ~TEST8;\n\t\t\t\t\tpeer->pkeyid = skeyid;\n\t\t\t\t\tap->seq -= i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (i > ap->seq) {\n\t\t\t\t\tpeer->crypto &=\n\t\t\t\t\t    ~CRYPTO_FLAG_AUTO;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttkeyid = session_key(\n\t\t\t\t    &rbufp->recv_srcadr, dstadr_sin,\n\t\t\t\t    tkeyid, pkeyid, 0);\n\t\t\t}\n\t\t\tif (peer->flash & TEST8)\n\t\t\t\treport_event(PEVNT_AUTH, peer, \"keylist\");\n\t\t}\n\t\tif (!(peer->crypto & CRYPTO_FLAG_PROV)) /* test 9 */\n\t\t\tpeer->flash |= TEST8;\t/* bad autokey */\n\n\t\t/*\n\t\t * The maximum lifetime of the protocol is about one\n\t\t * week before restarting the Autokey protocol to\n\t\t * refresh certificates and leapseconds values.\n\t\t */\n\t\tif (current_time > peer->refresh) {\n\t\t\treport_event(PEVNT_RESTART, peer,\n\t\t\t    \"crypto refresh\");\n\t\t\tpeer_clear(peer, \"TIME\");\n\t\t\treturn;\n\t\t}\n\t}\n#endif\t/* AUTOKEY */\n\n\t/*\n\t * The dance is complete and the flash bits have been lit. Toss\n\t * the packet over the fence for processing, which may light up\n\t * more flashers.\n\t */\n\tprocess_packet(peer, pkt, rbufp->recv_length);\n\n\t/*\n\t * In interleaved mode update the state variables. Also adjust the\n\t * transmit phase to avoid crossover.\n\t */\n\tif (peer->flip != 0) {\n\t\tpeer->rec = p_rec;\n\t\tpeer->dst = rbufp->recv_time;\n\t\tif (peer->nextdate - current_time < (1U << min(peer->ppoll,\n\t\t    peer->hpoll)) / 2)\n\t\t\tpeer->nextdate++;\n\t\telse\n\t\t\tpeer->nextdate--;\n\t}\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145717,
    "RELATED_CWE": [
      "CWE-862",
      "CWE-285",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-287"
    ],
    "code": "ConnectionExists(struct SessionHandle *data,\n                 struct connectdata *needle,\n                 struct connectdata **usethis,\n                 bool *force_reuse,\n                 bool *waitpipe)\n{\n  struct connectdata *check;\n  struct connectdata *chosen = 0;\n  bool foundPendingCandidate = FALSE;\n  bool canPipeline = IsPipeliningPossible(data, needle);\n#ifdef USE_NTLM\n  bool wantNTLMhttp = ((data->state.authhost.want & CURLAUTH_NTLM) ||\n                       (data->state.authhost.want & CURLAUTH_NTLM_WB)) &&\n    (needle->handler->protocol & PROTO_FAMILY_HTTP) ? TRUE : FALSE;\n#endif\n  struct connectbundle *bundle;\n\n  *force_reuse = FALSE;\n  *waitpipe = FALSE;\n\n  /* We can't pipe if the site is blacklisted */\n  if(canPipeline && Curl_pipeline_site_blacklisted(data, needle)) {\n    canPipeline = FALSE;\n  }\n\n  /* Look up the bundle with all the connections to this\n     particular host */\n  bundle = Curl_conncache_find_bundle(needle, data->state.conn_cache);\n  if(bundle) {\n    /* Max pipe length is zero (unlimited) for multiplexed connections */\n    size_t max_pipe_len = (bundle->multiuse != BUNDLE_MULTIPLEX)?\n      max_pipeline_length(data->multi):0;\n    size_t best_pipe_len = max_pipe_len;\n    struct curl_llist_element *curr;\n\n    infof(data, \"Found bundle for host %s: %p [%s]\\n\",\n          needle->host.name, (void *)bundle,\n          (bundle->multiuse== BUNDLE_PIPELINING?\n           \"can pipeline\":\n           (bundle->multiuse== BUNDLE_MULTIPLEX?\n            \"can multiplex\":\"serially\")));\n\n    /* We can't pipe if we don't know anything about the server */\n    if(canPipeline) {\n      if(bundle->multiuse <= BUNDLE_UNKNOWN) {\n        if((bundle->multiuse == BUNDLE_UNKNOWN) && data->set.pipewait) {\n          infof(data, \"Server doesn't support multi-use yet, wait\\n\");\n          *waitpipe = TRUE;\n          return FALSE; /* no re-use */\n        }\n\n        infof(data, \"Server doesn't support multi-use (yet)\\n\");\n        canPipeline = FALSE;\n      }\n      if((bundle->multiuse == BUNDLE_PIPELINING) &&\n         !Curl_pipeline_wanted(data->multi, CURLPIPE_HTTP1)) {\n        /* not asked for, switch off */\n        infof(data, \"Could pipeline, but not asked to!\\n\");\n        canPipeline = FALSE;\n      }\n      else if((bundle->multiuse == BUNDLE_MULTIPLEX) &&\n              !Curl_pipeline_wanted(data->multi, CURLPIPE_MULTIPLEX)) {\n        infof(data, \"Could multiplex, but not asked to!\\n\");\n        canPipeline = FALSE;\n      }\n    }\n\n    curr = bundle->conn_list->head;\n    while(curr) {\n      bool match = FALSE;\n#if defined(USE_NTLM)\n      bool credentialsMatch = FALSE;\n#endif\n      size_t pipeLen;\n\n      /*\n       * Note that if we use a HTTP proxy, we check connections to that\n       * proxy and not to the actual remote server.\n       */\n      check = curr->ptr;\n      curr = curr->next;\n\n      if(disconnect_if_dead(check, data))\n        continue;\n\n      pipeLen = check->send_pipe->size + check->recv_pipe->size;\n\n      if(canPipeline) {\n\n        if(!check->bits.multiplex) {\n          /* If not multiplexing, make sure the pipe has only GET requests */\n          struct SessionHandle* sh = gethandleathead(check->send_pipe);\n          struct SessionHandle* rh = gethandleathead(check->recv_pipe);\n          if(sh) {\n            if(!IsPipeliningPossible(sh, check))\n              continue;\n          }\n          else if(rh) {\n            if(!IsPipeliningPossible(rh, check))\n              continue;\n          }\n        }\n      }\n      else {\n        if(pipeLen > 0) {\n          /* can only happen within multi handles, and means that another easy\n             handle is using this connection */\n          continue;\n        }\n\n        if(Curl_resolver_asynch()) {\n          /* ip_addr_str[0] is NUL only if the resolving of the name hasn't\n             completed yet and until then we don't re-use this connection */\n          if(!check->ip_addr_str[0]) {\n            infof(data,\n                  \"Connection #%ld is still name resolving, can't reuse\\n\",\n                  check->connection_id);\n            continue;\n          }\n        }\n\n        if((check->sock[FIRSTSOCKET] == CURL_SOCKET_BAD) ||\n           check->bits.close) {\n          if(!check->bits.close)\n            foundPendingCandidate = TRUE;\n          /* Don't pick a connection that hasn't connected yet or that is going\n             to get closed. */\n          infof(data, \"Connection #%ld isn't open enough, can't reuse\\n\",\n                check->connection_id);\n#ifdef DEBUGBUILD\n          if(check->recv_pipe->size > 0) {\n            infof(data,\n                  \"BAD! Unconnected #%ld has a non-empty recv pipeline!\\n\",\n                  check->connection_id);\n          }\n#endif\n          continue;\n        }\n      }\n\n      if((needle->handler->flags&PROTOPT_SSL) !=\n         (check->handler->flags&PROTOPT_SSL))\n        /* don't do mixed SSL and non-SSL connections */\n        if(!(needle->handler->protocol & check->handler->protocol))\n          /* except protocols that have been upgraded via TLS */\n          continue;\n\n      if(needle->handler->flags&PROTOPT_SSL) {\n        if((data->set.ssl.verifypeer != check->verifypeer) ||\n           (data->set.ssl.verifyhost != check->verifyhost))\n          continue;\n      }\n\n      if(needle->bits.proxy != check->bits.proxy)\n        /* don't do mixed proxy and non-proxy connections */\n        continue;\n\n      if(!canPipeline && check->inuse)\n        /* this request can't be pipelined but the checked connection is\n           already in use so we skip it */\n        continue;\n\n      if(needle->localdev || needle->localport) {\n        /* If we are bound to a specific local end (IP+port), we must not\n           re-use a random other one, although if we didn't ask for a\n           particular one we can reuse one that was bound.\n\n           This comparison is a bit rough and too strict. Since the input\n           parameters can be specified in numerous ways and still end up the\n           same it would take a lot of processing to make it really accurate.\n           Instead, this matching will assume that re-uses of bound connections\n           will most likely also re-use the exact same binding parameters and\n           missing out a few edge cases shouldn't hurt anyone very much.\n        */\n        if((check->localport != needle->localport) ||\n           (check->localportrange != needle->localportrange) ||\n           !check->localdev ||\n           !needle->localdev ||\n           strcmp(check->localdev, needle->localdev))\n          continue;\n      }\n\n      if((!(needle->handler->flags & PROTOPT_CREDSPERREQUEST))\n#ifdef USE_NTLM\n         || (wantNTLMhttp || check->ntlm.state != NTLMSTATE_NONE)\n#endif\n        ) {\n        /* This protocol requires credentials per connection or is HTTP+NTLM,\n           so verify that we're using the same name and password as well */\n        if(!strequal(needle->user, check->user) ||\n           !strequal(needle->passwd, check->passwd)) {\n          /* one of them was different */\n          continue;\n        }\n#if defined(USE_NTLM)\n        credentialsMatch = TRUE;\n#endif\n      }\n\n      if(!needle->bits.httpproxy || needle->handler->flags&PROTOPT_SSL ||\n         (needle->bits.httpproxy && check->bits.httpproxy &&\n          needle->bits.tunnel_proxy && check->bits.tunnel_proxy &&\n          Curl_raw_equal(needle->proxy.name, check->proxy.name) &&\n          (needle->port == check->port))) {\n        /* The requested connection does not use a HTTP proxy or it uses SSL or\n           it is a non-SSL protocol tunneled over the same http proxy name and\n           port number or it is a non-SSL protocol which is allowed to be\n           upgraded via TLS */\n\n        if((Curl_raw_equal(needle->handler->scheme, check->handler->scheme) ||\n            needle->handler->protocol & check->handler->protocol) &&\n           Curl_raw_equal(needle->host.name, check->host.name) &&\n           needle->remote_port == check->remote_port) {\n          if(needle->handler->flags & PROTOPT_SSL) {\n            /* This is a SSL connection so verify that we're using the same\n               SSL options as well */\n            if(!Curl_ssl_config_matches(&needle->ssl_config,\n                                        &check->ssl_config)) {\n              DEBUGF(infof(data,\n                           \"Connection #%ld has different SSL parameters, \"\n                           \"can't reuse\\n\",\n                           check->connection_id));\n              continue;\n            }\n            else if(check->ssl[FIRSTSOCKET].state != ssl_connection_complete) {\n              foundPendingCandidate = TRUE;\n              DEBUGF(infof(data,\n                           \"Connection #%ld has not started SSL connect, \"\n                           \"can't reuse\\n\",\n                           check->connection_id));\n              continue;\n            }\n          }\n          match = TRUE;\n        }\n      }\n      else { /* The requested needle connection is using a proxy,\n                is the checked one using the same host, port and type? */\n        if(check->bits.proxy &&\n           (needle->proxytype == check->proxytype) &&\n           (needle->bits.tunnel_proxy == check->bits.tunnel_proxy) &&\n           Curl_raw_equal(needle->proxy.name, check->proxy.name) &&\n           needle->port == check->port) {\n          /* This is the same proxy connection, use it! */\n          match = TRUE;\n        }\n      }\n\n      if(match) {\n#if defined(USE_NTLM)\n        /* If we are looking for an HTTP+NTLM connection, check if this is\n           already authenticating with the right credentials. If not, keep\n           looking so that we can reuse NTLM connections if\n           possible. (Especially we must not reuse the same connection if\n           partway through a handshake!) */\n        if(wantNTLMhttp) {\n          if(credentialsMatch && check->ntlm.state != NTLMSTATE_NONE) {\n            chosen = check;\n\n            /* We must use this connection, no other */\n            *force_reuse = TRUE;\n            break;\n          }\n          else if(credentialsMatch)\n            /* this is a backup choice */\n            chosen = check;\n          continue;\n        }\n#endif\n\n        if(canPipeline) {\n          /* We can pipeline if we want to. Let's continue looking for\n             the optimal connection to use, i.e the shortest pipe that is not\n             blacklisted. */\n\n          if(pipeLen == 0) {\n            /* We have the optimal connection. Let's stop looking. */\n            chosen = check;\n            break;\n          }\n\n          /* We can't use the connection if the pipe is full */\n          if(max_pipe_len && (pipeLen >= max_pipe_len)) {\n            infof(data, \"Pipe is full, skip (%zu)\\n\", pipeLen);\n            continue;\n          }\n#ifdef USE_NGHTTP2\n          /* If multiplexed, make sure we don't go over concurrency limit */\n          if(check->bits.multiplex) {\n            /* Multiplexed connections can only be HTTP/2 for now */\n            struct http_conn *httpc = &check->proto.httpc;\n            if(pipeLen >= httpc->settings.max_concurrent_streams) {\n              infof(data, \"MAX_CONCURRENT_STREAMS reached, skip (%zu)\\n\",\n                    pipeLen);\n              continue;\n            }\n          }\n#endif\n          /* We can't use the connection if the pipe is penalized */\n          if(Curl_pipeline_penalized(data, check)) {\n            infof(data, \"Penalized, skip\\n\");\n            continue;\n          }\n\n          if(max_pipe_len) {\n            if(pipeLen < best_pipe_len) {\n              /* This connection has a shorter pipe so far. We'll pick this\n                 and continue searching */\n              chosen = check;\n              best_pipe_len = pipeLen;\n              continue;\n            }\n          }\n          else {\n            /* When not pipelining (== multiplexed), we have a match here! */\n            chosen = check;\n            infof(data, \"Multiplexed connection found!\\n\");\n            break;\n          }\n        }\n        else {\n          /* We have found a connection. Let's stop searching. */\n          chosen = check;\n          break;\n        }\n      }\n    }\n  }\n\n  if(chosen) {\n    *usethis = chosen;\n    return TRUE; /* yes, we found one to use! */\n  }\n\n  if(foundPendingCandidate && data->set.pipewait) {\n    infof(data,\n          \"Found pending candidate for reuse and CURLOPT_PIPEWAIT is set\\n\");\n    *waitpipe = TRUE;\n  }\n\n  return FALSE; /* no matching connecting exists */\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145928,
    "RELATED_CWE": [
      "CWE-862",
      "CWE-285",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-287"
    ],
    "code": "ConnectionExists(struct SessionHandle *data,\n                 struct connectdata *needle,\n                 struct connectdata **usethis,\n                 bool *force_reuse,\n                 bool *waitpipe)\n{\n  struct connectdata *check;\n  struct connectdata *chosen = 0;\n  bool foundPendingCandidate = FALSE;\n  bool canPipeline = IsPipeliningPossible(data, needle);\n  struct connectbundle *bundle;\n\n#ifdef USE_NTLM\n  bool wantNTLMhttp = ((data->state.authhost.want &\n                      (CURLAUTH_NTLM | CURLAUTH_NTLM_WB)) &&\n                      (needle->handler->protocol & PROTO_FAMILY_HTTP));\n  bool wantProxyNTLMhttp = (needle->bits.proxy_user_passwd &&\n                           ((data->state.authproxy.want &\n                           (CURLAUTH_NTLM | CURLAUTH_NTLM_WB)) &&\n                           (needle->handler->protocol & PROTO_FAMILY_HTTP)));\n#endif\n\n  *force_reuse = FALSE;\n  *waitpipe = FALSE;\n\n  /* We can't pipe if the site is blacklisted */\n  if(canPipeline && Curl_pipeline_site_blacklisted(data, needle)) {\n    canPipeline = FALSE;\n  }\n\n  /* Look up the bundle with all the connections to this\n     particular host */\n  bundle = Curl_conncache_find_bundle(needle, data->state.conn_cache);\n  if(bundle) {\n    /* Max pipe length is zero (unlimited) for multiplexed connections */\n    size_t max_pipe_len = (bundle->multiuse != BUNDLE_MULTIPLEX)?\n      max_pipeline_length(data->multi):0;\n    size_t best_pipe_len = max_pipe_len;\n    struct curl_llist_element *curr;\n\n    infof(data, \"Found bundle for host %s: %p [%s]\\n\",\n          needle->host.name, (void *)bundle,\n          (bundle->multiuse== BUNDLE_PIPELINING?\n           \"can pipeline\":\n           (bundle->multiuse== BUNDLE_MULTIPLEX?\n            \"can multiplex\":\"serially\")));\n\n    /* We can't pipe if we don't know anything about the server */\n    if(canPipeline) {\n      if(bundle->multiuse <= BUNDLE_UNKNOWN) {\n        if((bundle->multiuse == BUNDLE_UNKNOWN) && data->set.pipewait) {\n          infof(data, \"Server doesn't support multi-use yet, wait\\n\");\n          *waitpipe = TRUE;\n          return FALSE; /* no re-use */\n        }\n\n        infof(data, \"Server doesn't support multi-use (yet)\\n\");\n        canPipeline = FALSE;\n      }\n      if((bundle->multiuse == BUNDLE_PIPELINING) &&\n         !Curl_pipeline_wanted(data->multi, CURLPIPE_HTTP1)) {\n        /* not asked for, switch off */\n        infof(data, \"Could pipeline, but not asked to!\\n\");\n        canPipeline = FALSE;\n      }\n      else if((bundle->multiuse == BUNDLE_MULTIPLEX) &&\n              !Curl_pipeline_wanted(data->multi, CURLPIPE_MULTIPLEX)) {\n        infof(data, \"Could multiplex, but not asked to!\\n\");\n        canPipeline = FALSE;\n      }\n    }\n\n    curr = bundle->conn_list->head;\n    while(curr) {\n      bool match = FALSE;\n      size_t pipeLen;\n\n      /*\n       * Note that if we use a HTTP proxy, we check connections to that\n       * proxy and not to the actual remote server.\n       */\n      check = curr->ptr;\n      curr = curr->next;\n\n      if(disconnect_if_dead(check, data))\n        continue;\n\n      pipeLen = check->send_pipe->size + check->recv_pipe->size;\n\n      if(canPipeline) {\n\n        if(!check->bits.multiplex) {\n          /* If not multiplexing, make sure the pipe has only GET requests */\n          struct SessionHandle* sh = gethandleathead(check->send_pipe);\n          struct SessionHandle* rh = gethandleathead(check->recv_pipe);\n          if(sh) {\n            if(!IsPipeliningPossible(sh, check))\n              continue;\n          }\n          else if(rh) {\n            if(!IsPipeliningPossible(rh, check))\n              continue;\n          }\n        }\n      }\n      else {\n        if(pipeLen > 0) {\n          /* can only happen within multi handles, and means that another easy\n             handle is using this connection */\n          continue;\n        }\n\n        if(Curl_resolver_asynch()) {\n          /* ip_addr_str[0] is NUL only if the resolving of the name hasn't\n             completed yet and until then we don't re-use this connection */\n          if(!check->ip_addr_str[0]) {\n            infof(data,\n                  \"Connection #%ld is still name resolving, can't reuse\\n\",\n                  check->connection_id);\n            continue;\n          }\n        }\n\n        if((check->sock[FIRSTSOCKET] == CURL_SOCKET_BAD) ||\n           check->bits.close) {\n          if(!check->bits.close)\n            foundPendingCandidate = TRUE;\n          /* Don't pick a connection that hasn't connected yet or that is going\n             to get closed. */\n          infof(data, \"Connection #%ld isn't open enough, can't reuse\\n\",\n                check->connection_id);\n#ifdef DEBUGBUILD\n          if(check->recv_pipe->size > 0) {\n            infof(data,\n                  \"BAD! Unconnected #%ld has a non-empty recv pipeline!\\n\",\n                  check->connection_id);\n          }\n#endif\n          continue;\n        }\n      }\n\n      if((needle->handler->flags&PROTOPT_SSL) !=\n         (check->handler->flags&PROTOPT_SSL))\n        /* don't do mixed SSL and non-SSL connections */\n        if(!(needle->handler->protocol & check->handler->protocol))\n          /* except protocols that have been upgraded via TLS */\n          continue;\n\n      if(needle->handler->flags&PROTOPT_SSL) {\n        if((data->set.ssl.verifypeer != check->verifypeer) ||\n           (data->set.ssl.verifyhost != check->verifyhost))\n          continue;\n      }\n\n      if(needle->bits.proxy != check->bits.proxy)\n        /* don't do mixed proxy and non-proxy connections */\n        continue;\n\n      if(!canPipeline && check->inuse)\n        /* this request can't be pipelined but the checked connection is\n           already in use so we skip it */\n        continue;\n\n      if(needle->localdev || needle->localport) {\n        /* If we are bound to a specific local end (IP+port), we must not\n           re-use a random other one, although if we didn't ask for a\n           particular one we can reuse one that was bound.\n\n           This comparison is a bit rough and too strict. Since the input\n           parameters can be specified in numerous ways and still end up the\n           same it would take a lot of processing to make it really accurate.\n           Instead, this matching will assume that re-uses of bound connections\n           will most likely also re-use the exact same binding parameters and\n           missing out a few edge cases shouldn't hurt anyone very much.\n        */\n        if((check->localport != needle->localport) ||\n           (check->localportrange != needle->localportrange) ||\n           !check->localdev ||\n           !needle->localdev ||\n           strcmp(check->localdev, needle->localdev))\n          continue;\n      }\n\n      if(!(needle->handler->flags & PROTOPT_CREDSPERREQUEST)) {\n        /* This protocol requires credentials per connection,\n           so verify that we're using the same name and password as well */\n        if(!strequal(needle->user, check->user) ||\n           !strequal(needle->passwd, check->passwd)) {\n          /* one of them was different */\n          continue;\n        }\n      }\n\n      if(!needle->bits.httpproxy || needle->handler->flags&PROTOPT_SSL ||\n         (needle->bits.httpproxy && check->bits.httpproxy &&\n          needle->bits.tunnel_proxy && check->bits.tunnel_proxy &&\n          Curl_raw_equal(needle->proxy.name, check->proxy.name) &&\n          (needle->port == check->port))) {\n        /* The requested connection does not use a HTTP proxy or it uses SSL or\n           it is a non-SSL protocol tunneled over the same http proxy name and\n           port number or it is a non-SSL protocol which is allowed to be\n           upgraded via TLS */\n\n        if((Curl_raw_equal(needle->handler->scheme, check->handler->scheme) ||\n            needle->handler->protocol & check->handler->protocol) &&\n           Curl_raw_equal(needle->host.name, check->host.name) &&\n           needle->remote_port == check->remote_port) {\n          if(needle->handler->flags & PROTOPT_SSL) {\n            /* This is a SSL connection so verify that we're using the same\n               SSL options as well */\n            if(!Curl_ssl_config_matches(&needle->ssl_config,\n                                        &check->ssl_config)) {\n              DEBUGF(infof(data,\n                           \"Connection #%ld has different SSL parameters, \"\n                           \"can't reuse\\n\",\n                           check->connection_id));\n              continue;\n            }\n            else if(check->ssl[FIRSTSOCKET].state != ssl_connection_complete) {\n              foundPendingCandidate = TRUE;\n              DEBUGF(infof(data,\n                           \"Connection #%ld has not started SSL connect, \"\n                           \"can't reuse\\n\",\n                           check->connection_id));\n              continue;\n            }\n          }\n          match = TRUE;\n        }\n      }\n      else { /* The requested needle connection is using a proxy,\n                is the checked one using the same host, port and type? */\n        if(check->bits.proxy &&\n           (needle->proxytype == check->proxytype) &&\n           (needle->bits.tunnel_proxy == check->bits.tunnel_proxy) &&\n           Curl_raw_equal(needle->proxy.name, check->proxy.name) &&\n           needle->port == check->port) {\n          /* This is the same proxy connection, use it! */\n          match = TRUE;\n        }\n      }\n\n      if(match) {\n#if defined(USE_NTLM)\n        /* If we are looking for an HTTP+NTLM connection, check if this is\n           already authenticating with the right credentials. If not, keep\n           looking so that we can reuse NTLM connections if\n           possible. (Especially we must not reuse the same connection if\n           partway through a handshake!) */\n        if(wantNTLMhttp) {\n          if(!strequal(needle->user, check->user) ||\n             !strequal(needle->passwd, check->passwd))\n            continue;\n        }\n        else if(check->ntlm.state != NTLMSTATE_NONE) {\n          /* Connection is using NTLM auth but we don't want NTLM */\n          continue;\n        }\n\n        /* Same for Proxy NTLM authentication */\n        if(wantProxyNTLMhttp) {\n          if(!strequal(needle->proxyuser, check->proxyuser) ||\n             !strequal(needle->proxypasswd, check->proxypasswd))\n            continue;\n        }\n        else if(check->proxyntlm.state != NTLMSTATE_NONE) {\n          /* Proxy connection is using NTLM auth but we don't want NTLM */\n          continue;\n        }\n\n        if(wantNTLMhttp || wantProxyNTLMhttp) {\n          /* Credentials are already checked, we can use this connection */\n          chosen = check;\n\n          if((wantNTLMhttp &&\n             (check->ntlm.state != NTLMSTATE_NONE)) ||\n              (wantProxyNTLMhttp &&\n               (check->proxyntlm.state != NTLMSTATE_NONE))) {\n            /* We must use this connection, no other */\n            *force_reuse = TRUE;\n            break;\n          }\n\n          /* Continue look up for a better connection */\n          continue;\n        }\n#endif\n        if(canPipeline) {\n          /* We can pipeline if we want to. Let's continue looking for\n             the optimal connection to use, i.e the shortest pipe that is not\n             blacklisted. */\n\n          if(pipeLen == 0) {\n            /* We have the optimal connection. Let's stop looking. */\n            chosen = check;\n            break;\n          }\n\n          /* We can't use the connection if the pipe is full */\n          if(max_pipe_len && (pipeLen >= max_pipe_len)) {\n            infof(data, \"Pipe is full, skip (%zu)\\n\", pipeLen);\n            continue;\n          }\n#ifdef USE_NGHTTP2\n          /* If multiplexed, make sure we don't go over concurrency limit */\n          if(check->bits.multiplex) {\n            /* Multiplexed connections can only be HTTP/2 for now */\n            struct http_conn *httpc = &check->proto.httpc;\n            if(pipeLen >= httpc->settings.max_concurrent_streams) {\n              infof(data, \"MAX_CONCURRENT_STREAMS reached, skip (%zu)\\n\",\n                    pipeLen);\n              continue;\n            }\n          }\n#endif\n          /* We can't use the connection if the pipe is penalized */\n          if(Curl_pipeline_penalized(data, check)) {\n            infof(data, \"Penalized, skip\\n\");\n            continue;\n          }\n\n          if(max_pipe_len) {\n            if(pipeLen < best_pipe_len) {\n              /* This connection has a shorter pipe so far. We'll pick this\n                 and continue searching */\n              chosen = check;\n              best_pipe_len = pipeLen;\n              continue;\n            }\n          }\n          else {\n            /* When not pipelining (== multiplexed), we have a match here! */\n            chosen = check;\n            infof(data, \"Multiplexed connection found!\\n\");\n            break;\n          }\n        }\n        else {\n          /* We have found a connection. Let's stop searching. */\n          chosen = check;\n          break;\n        }\n      }\n    }\n  }\n\n  if(chosen) {\n    *usethis = chosen;\n    return TRUE; /* yes, we found one to use! */\n  }\n\n  if(foundPendingCandidate && data->set.pipewait) {\n    infof(data,\n          \"Found pending candidate for reuse and CURLOPT_PIPEWAIT is set\\n\");\n    *waitpipe = TRUE;\n  }\n\n  return FALSE; /* no matching connecting exists */\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145929,
    "RELATED_CWE": [
      "CWE-862",
      "CWE-285",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-287"
    ],
    "code": "static PyObject *checkPassword(PyObject *self, PyObject *args)\n{\n    const char *user = NULL;\n    const char *pswd = NULL;\n    const char *service = NULL;\n    const char *default_realm = NULL;\n    int result = 0;\n\n    if (!PyArg_ParseTuple(args, \"ssss\", &user, &pswd, &service, &default_realm))\n        return NULL;\n\n    result = authenticate_user_krb5pwd(user, pswd, service, default_realm);\n\n    if (result)\n        return Py_INCREF(Py_True), Py_True;\n    else\n        return NULL;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146186,
    "RELATED_CWE": [
      "CWE-862",
      "CWE-285",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-287"
    ],
    "code": "static PyObject *checkPassword(PyObject *self, PyObject *args)\n{\n    const char *user = NULL;\n    const char *pswd = NULL;\n    const char *service = NULL;\n    const char *default_realm = NULL;\n    const int verify = 1;\n    int result = 0;\n\n    if (!PyArg_ParseTuple(args, \"ssssb\", &user, &pswd, &service, &default_realm, &verify))\n        return NULL;\n\n    result = authenticate_user_krb5pwd(user, pswd, service, default_realm, verify);\n\n    if (result)\n        return Py_INCREF(Py_True), Py_True;\n    else\n        return NULL;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146187,
    "RELATED_CWE": [
      "CWE-862",
      "CWE-285",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-287"
    ],
    "code": "static void krb5_save_ccname_done(struct tevent_req *req)\n{\n    struct krb5_auth_state *state = tevent_req_data(req, struct krb5_auth_state);\n    struct krb5child_req *kr = state->kr;\n    struct pam_data *pd = state->pd;\n    int ret;\n    char *password = NULL;\n\n    if (kr->is_offline) {\n        if (dp_opt_get_bool(kr->krb5_ctx->opts,KRB5_STORE_PASSWORD_IF_OFFLINE)) {\n            krb5_pam_handler_cache_auth_step(req);\n            return;\n        }\n\n        DEBUG(4, (\"Backend is marked offline, retry later!\\n\"));\n        state->pam_status = PAM_AUTHINFO_UNAVAIL;\n        state->dp_err = DP_ERR_OFFLINE;\n        ret = EOK;\n        goto done;\n    }\n\n    if (state->be_ctx->domain->cache_credentials == TRUE) {\n\n        /* password caching failures are not fatal errors */\n        state->pam_status = PAM_SUCCESS;\n        state->dp_err = DP_ERR_OK;\n\n        switch(pd->cmd) {\n            case SSS_PAM_AUTHENTICATE:\n            case SSS_CMD_RENEW:\n            case SSS_PAM_CHAUTHTOK_PRELIM:\n                password = talloc_size(state, pd->authtok_size + 1);\n                if (password != NULL) {\n                    memcpy(password, pd->authtok, pd->authtok_size);\n                    password[pd->authtok_size] = '\\0';\n                }\n                break;\n            case SSS_PAM_CHAUTHTOK:\n                password = talloc_size(state, pd->newauthtok_size + 1);\n                if (password != NULL) {\n                    memcpy(password, pd->newauthtok, pd->newauthtok_size);\n                    password[pd->newauthtok_size] = '\\0';\n                }\n                break;\n            default:\n                DEBUG(0, (\"unsupported PAM command [%d].\\n\", pd->cmd));\n        }\n\n        if (password == NULL) {\n            DEBUG(0, (\"password not available, offline auth may not work.\\n\"));\n            ret = EOK; /* password caching failures are not fatal errors */\n            goto done;\n        }\n\n        talloc_set_destructor((TALLOC_CTX *)password, password_destructor);\n\n        ret = sysdb_cache_password(state, state->be_ctx->sysdb,\n                                   state->be_ctx->domain, pd->user,\n                                   password);\n        if (ret) {\n            DEBUG(2, (\"Failed to cache password, offline auth may not work.\"\n                      \" (%d)[%s]!?\\n\", ret, strerror(ret)));\n        }\n    }\n\n    state->pam_status = PAM_SUCCESS;\n    state->dp_err = DP_ERR_OK;\n    ret = EOK;\n\ndone:\n    if (ret == EOK) {\n        tevent_req_done(req);\n    } else {\n        tevent_req_error(req, ret);\n    }\n\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146996,
    "RELATED_CWE": [
      "CWE-862",
      "CWE-285",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-287"
    ],
    "code": "static void krb5_save_ccname_done(struct tevent_req *req)\n{\n    struct krb5_auth_state *state = tevent_req_data(req, struct krb5_auth_state);\n    struct krb5child_req *kr = state->kr;\n    struct pam_data *pd = state->pd;\n    int ret;\n    char *password = NULL;\n\n    if (kr->is_offline) {\n        if (dp_opt_get_bool(kr->krb5_ctx->opts,KRB5_STORE_PASSWORD_IF_OFFLINE)) {\n            krb5_pam_handler_cache_auth_step(req);\n            return;\n        }\n\n        DEBUG(4, (\"Backend is marked offline, retry later!\\n\"));\n        state->pam_status = PAM_AUTHINFO_UNAVAIL;\n        state->dp_err = DP_ERR_OFFLINE;\n        ret = EOK;\n        goto done;\n    }\n\n    if (state->be_ctx->domain->cache_credentials == TRUE) {\n\n        /* password caching failures are not fatal errors */\n        state->pam_status = PAM_SUCCESS;\n        state->dp_err = DP_ERR_OK;\n\n        switch(pd->cmd) {\n            case SSS_CMD_RENEW:\n                /* The authtok is set to the credential cache\n                 * during renewal. We don't want to save this\n                 * as the cached password.\n                 */\n                break;\n            case SSS_PAM_AUTHENTICATE:\n            case SSS_PAM_CHAUTHTOK_PRELIM:\n                password = talloc_size(state, pd->authtok_size + 1);\n                if (password != NULL) {\n                    memcpy(password, pd->authtok, pd->authtok_size);\n                    password[pd->authtok_size] = '\\0';\n                }\n                break;\n            case SSS_PAM_CHAUTHTOK:\n                password = talloc_size(state, pd->newauthtok_size + 1);\n                if (password != NULL) {\n                    memcpy(password, pd->newauthtok, pd->newauthtok_size);\n                    password[pd->newauthtok_size] = '\\0';\n                }\n                break;\n            default:\n                DEBUG(0, (\"unsupported PAM command [%d].\\n\", pd->cmd));\n        }\n\n        if (password == NULL) {\n            if (pd->cmd != SSS_CMD_RENEW) {\n                DEBUG(0, (\"password not available, offline auth may not work.\\n\"));\n                /* password caching failures are not fatal errors */\n            }\n            ret = EOK;\n            goto done;\n        }\n\n        talloc_set_destructor((TALLOC_CTX *)password, password_destructor);\n\n        ret = sysdb_cache_password(state, state->be_ctx->sysdb,\n                                   state->be_ctx->domain, pd->user,\n                                   password);\n        if (ret) {\n            DEBUG(2, (\"Failed to cache password, offline auth may not work.\"\n                      \" (%d)[%s]!?\\n\", ret, strerror(ret)));\n            /* password caching failures are not fatal errors */\n        }\n    }\n\n    state->pam_status = PAM_SUCCESS;\n    state->dp_err = DP_ERR_OK;\n    ret = EOK;\n\ndone:\n    if (ret == EOK) {\n        tevent_req_done(req);\n    } else {\n        tevent_req_error(req, ret);\n    }\n\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146997,
    "RELATED_CWE": [
      "CWE-862",
      "CWE-285",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-287"
    ],
    "code": "ngx_http_auth_spnego_handler(\n        ngx_http_request_t * r)\n{\n    ngx_int_t ret = NGX_DECLINED;\n    ngx_http_auth_spnego_ctx_t *ctx;\n    ngx_http_auth_spnego_loc_conf_t *alcf;\n\n    alcf = ngx_http_get_module_loc_conf(r, ngx_http_auth_spnego_module);\n\n    if (alcf->protect == 0) {\n        return NGX_DECLINED;\n    }\n\n    ctx = ngx_http_get_module_ctx(r, ngx_http_auth_spnego_module);\n    if (NULL == ctx) {\n        ctx = ngx_palloc(r->pool, sizeof(ngx_http_auth_spnego_ctx_t));\n        if (NULL == ctx) {\n            return NGX_HTTP_INTERNAL_SERVER_ERROR;\n        }\n        ctx->token.len = 0;\n        ctx->token.data = NULL;\n        ctx->head = 0;\n        ctx->ret = NGX_HTTP_UNAUTHORIZED;\n        ngx_http_set_ctx(r, ctx, ngx_http_auth_spnego_module);\n    }\n\n    spnego_debug3(\"SSO auth handling IN: token.len=%d, head=%d, ret=%d\",\n            ctx->token.len, ctx->head, ctx->ret);\n\n    if (ctx->token.len && ctx->head) {\n        spnego_debug1(\"Found token and head, returning %d\", ctx->ret);\n        return ctx->ret;\n    }\n\n    if (NULL != r->headers_in.user.data) {\n        spnego_debug0(\"User header set\");\n        return NGX_OK;\n    }\n\n    spnego_debug0(\"Begin auth\");\n\n    if (alcf->allow_basic) {\n        spnego_debug0(\"Detect basic auth\");\n        ret = ngx_http_auth_basic_user(r);\n        if (NGX_OK == ret) {\n            spnego_debug0(\"Basic auth credentials supplied by client\");\n            /* If basic auth is enabled and basic creds are supplied\n             * attempt basic auth.  If we attempt basic auth, we do\n             * not fall through to real SPNEGO */\n            if (NGX_DECLINED == ngx_http_auth_spnego_basic(r, ctx, alcf)) {\n                spnego_debug0(\"Basic auth failed\");\n                if (NGX_ERROR == ngx_http_auth_spnego_headers_basic_only(r, ctx, alcf)) {\n                    spnego_debug0(\"Error setting headers\");\n                    return (ctx->ret = NGX_HTTP_INTERNAL_SERVER_ERROR);\n                }\n                return (ctx->ret = NGX_HTTP_UNAUTHORIZED);\n            }\n\n            if (!ngx_spnego_authorized_principal(r, &r->headers_in.user, alcf)) {\n                spnego_debug0(\"User not authorized\");\n                return (ctx->ret = NGX_HTTP_FORBIDDEN);\n            }\n\n            spnego_debug0(\"Basic auth succeeded\");\n            return (ctx->ret = NGX_OK);\n        }\n    }\n\n    /* Basic auth either disabled or not supplied by client */\n    spnego_debug0(\"Detect SPNEGO token\");\n    ret = ngx_http_auth_spnego_token(r, ctx);\n    if (NGX_OK == ret) {\n        spnego_debug0(\"Client sent a reasonable Negotiate header\");\n        ret = ngx_http_auth_spnego_auth_user_gss(r, ctx, alcf);\n        if (NGX_ERROR == ret) {\n            spnego_debug0(\"GSSAPI failed\");\n            return (ctx->ret = NGX_HTTP_INTERNAL_SERVER_ERROR);\n        }\n        /* There are chances that client knows about Negotiate\n         * but doesn't support GSSAPI. We could attempt to fall\n         * back to basic here... */\n        if (NGX_DECLINED == ret) {\n            spnego_debug0(\"GSSAPI failed\");\n            if(!alcf->allow_basic) {\n                return (ctx->ret = NGX_HTTP_FORBIDDEN);\n            }\n            if (NGX_ERROR == ngx_http_auth_spnego_headers_basic_only(r, ctx, alcf)) {\n                spnego_debug0(\"Error setting headers\");\n                return (ctx->ret = NGX_HTTP_INTERNAL_SERVER_ERROR);\n            }\n            return (ctx->ret = NGX_HTTP_UNAUTHORIZED);\n        }\n\n        if (!ngx_spnego_authorized_principal(r, &r->headers_in.user, alcf)) {\n            spnego_debug0(\"User not authorized\");\n            return (ctx->ret = NGX_HTTP_FORBIDDEN);\n        }\n\n        spnego_debug0(\"GSSAPI auth succeeded\");\n    }\n\n    ngx_str_t *token_out_b64 = NULL;\n    switch(ret) {\n        case NGX_DECLINED: /* DECLINED, but not yet FORBIDDEN */\n            ctx->ret = NGX_HTTP_UNAUTHORIZED;\n            break;\n        case NGX_OK:\n            ctx->ret = NGX_OK;\n            token_out_b64 = &ctx->token_out_b64;\n            break;\n        case NGX_ERROR:\n        default:\n            ctx->ret = NGX_HTTP_INTERNAL_SERVER_ERROR;\n            break;\n    }\n\n    if (NGX_ERROR == ngx_http_auth_spnego_headers(r, ctx, token_out_b64, alcf)) {\n        spnego_debug0(\"Error setting headers\");\n        ctx->ret = NGX_HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    spnego_debug3(\"SSO auth handling OUT: token.len=%d, head=%d, ret=%d\",\n            ctx->token.len, ctx->head, ctx->ret);\n    return ctx->ret;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148798,
    "RELATED_CWE": [
      "CWE-862",
      "CWE-285",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-287"
    ],
    "code": "ngx_http_auth_spnego_handler(\n        ngx_http_request_t * r)\n{\n    ngx_int_t ret = NGX_DECLINED;\n    ngx_http_auth_spnego_ctx_t *ctx;\n    ngx_http_auth_spnego_loc_conf_t *alcf;\n\n    alcf = ngx_http_get_module_loc_conf(r, ngx_http_auth_spnego_module);\n\n    if (alcf->protect == 0) {\n        return NGX_DECLINED;\n    }\n\n    ctx = ngx_http_get_module_ctx(r, ngx_http_auth_spnego_module);\n    if (NULL == ctx) {\n        ctx = ngx_palloc(r->pool, sizeof(ngx_http_auth_spnego_ctx_t));\n        if (NULL == ctx) {\n            return NGX_HTTP_INTERNAL_SERVER_ERROR;\n        }\n        ctx->token.len = 0;\n        ctx->token.data = NULL;\n        ctx->head = 0;\n        ctx->ret = NGX_HTTP_UNAUTHORIZED;\n        ngx_http_set_ctx(r, ctx, ngx_http_auth_spnego_module);\n    }\n\n    spnego_debug3(\"SSO auth handling IN: token.len=%d, head=%d, ret=%d\",\n            ctx->token.len, ctx->head, ctx->ret);\n\n    if (ctx->token.len && ctx->head) {\n        spnego_debug1(\"Found token and head, returning %d\", ctx->ret);\n        return ctx->ret;\n    }\n\n    if (NULL != r->headers_in.user.data) {\n        spnego_debug0(\"User header set\");\n        return NGX_OK;\n    }\n\n    spnego_debug0(\"Begin auth\");\n\n    if (alcf->allow_basic) {\n        spnego_debug0(\"Detect basic auth\");\n        ret = ngx_http_auth_basic_user(r);\n        if (NGX_OK == ret) {\n            spnego_debug0(\"Basic auth credentials supplied by client\");\n            /* If basic auth is enabled and basic creds are supplied\n             * attempt basic auth.  If we attempt basic auth, we do\n             * not fall through to real SPNEGO */\n            if (NGX_OK != ngx_http_auth_spnego_basic(r, ctx, alcf)) {\n                spnego_debug0(\"Basic auth failed\");\n                if (NGX_ERROR == ngx_http_auth_spnego_headers_basic_only(r, ctx, alcf)) {\n                    spnego_debug0(\"Error setting headers\");\n                    return (ctx->ret = NGX_HTTP_INTERNAL_SERVER_ERROR);\n                }\n                return (ctx->ret = NGX_HTTP_UNAUTHORIZED);\n            }\n\n            if (!ngx_spnego_authorized_principal(r, &r->headers_in.user, alcf)) {\n                spnego_debug0(\"User not authorized\");\n                return (ctx->ret = NGX_HTTP_FORBIDDEN);\n            }\n\n            spnego_debug0(\"Basic auth succeeded\");\n            return (ctx->ret = NGX_OK);\n        }\n    }\n\n    /* Basic auth either disabled or not supplied by client */\n    spnego_debug0(\"Detect SPNEGO token\");\n    ret = ngx_http_auth_spnego_token(r, ctx);\n    if (NGX_OK == ret) {\n        spnego_debug0(\"Client sent a reasonable Negotiate header\");\n        ret = ngx_http_auth_spnego_auth_user_gss(r, ctx, alcf);\n        if (NGX_ERROR == ret) {\n            spnego_debug0(\"GSSAPI failed\");\n            return (ctx->ret = NGX_HTTP_INTERNAL_SERVER_ERROR);\n        }\n        /* There are chances that client knows about Negotiate\n         * but doesn't support GSSAPI. We could attempt to fall\n         * back to basic here... */\n        if (NGX_DECLINED == ret) {\n            spnego_debug0(\"GSSAPI failed\");\n            if(!alcf->allow_basic) {\n                return (ctx->ret = NGX_HTTP_FORBIDDEN);\n            }\n            if (NGX_ERROR == ngx_http_auth_spnego_headers_basic_only(r, ctx, alcf)) {\n                spnego_debug0(\"Error setting headers\");\n                return (ctx->ret = NGX_HTTP_INTERNAL_SERVER_ERROR);\n            }\n            return (ctx->ret = NGX_HTTP_UNAUTHORIZED);\n        }\n\n        if (!ngx_spnego_authorized_principal(r, &r->headers_in.user, alcf)) {\n            spnego_debug0(\"User not authorized\");\n            return (ctx->ret = NGX_HTTP_FORBIDDEN);\n        }\n\n        spnego_debug0(\"GSSAPI auth succeeded\");\n    }\n\n    ngx_str_t *token_out_b64 = NULL;\n    switch(ret) {\n        case NGX_DECLINED: /* DECLINED, but not yet FORBIDDEN */\n            ctx->ret = NGX_HTTP_UNAUTHORIZED;\n            break;\n        case NGX_OK:\n            ctx->ret = NGX_OK;\n            token_out_b64 = &ctx->token_out_b64;\n            break;\n        case NGX_ERROR:\n        default:\n            ctx->ret = NGX_HTTP_INTERNAL_SERVER_ERROR;\n            break;\n    }\n\n    if (NGX_ERROR == ngx_http_auth_spnego_headers(r, ctx, token_out_b64, alcf)) {\n        spnego_debug0(\"Error setting headers\");\n        ctx->ret = NGX_HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    spnego_debug3(\"SSO auth handling OUT: token.len=%d, head=%d, ret=%d\",\n            ctx->token.len, ctx->head, ctx->ret);\n    return ctx->ret;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148799,
    "RELATED_CWE": [
      "CWE-862",
      "CWE-285",
      "CWE-269"
    ]
  }
]