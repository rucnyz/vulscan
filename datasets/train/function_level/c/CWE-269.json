[
  {
    "CWE_ID": [
      "CWE-269"
    ],
    "code": "process_open(u_int32_t id)\n{\n\tu_int32_t pflags;\n\tAttrib a;\n\tchar *name;\n\tint r, handle, fd, flags, mode, status = SSH2_FX_FAILURE;\n\n\tif ((r = sshbuf_get_cstring(iqueue, &name, NULL)) != 0 ||\n\t    (r = sshbuf_get_u32(iqueue, &pflags)) != 0 || /* portable flags */\n\t    (r = decode_attrib(iqueue, &a)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"request %u: open flags %d\", id, pflags);\n\tflags = flags_from_portable(pflags);\n\tmode = (a.flags & SSH2_FILEXFER_ATTR_PERMISSIONS) ? a.perm : 0666;\n \tlogit(\"open \\\"%s\\\" flags %s mode 0%o\",\n \t    name, string_from_portable(pflags), mode);\n \tif (readonly &&\n\t    ((flags & O_ACCMODE) == O_WRONLY ||\n\t    (flags & O_ACCMODE) == O_RDWR)) {\n \t\tverbose(\"Refusing open request in read-only mode\");\n \t\tstatus = SSH2_FX_PERMISSION_DENIED;\n \t} else {\n\t\tfd = open(name, flags, mode);\n\t\tif (fd < 0) {\n\t\t\tstatus = errno_to_portable(errno);\n\t\t} else {\n\t\t\thandle = handle_new(HANDLE_FILE, name, fd, flags, NULL);\n\t\t\tif (handle < 0) {\n\t\t\t\tclose(fd);\n\t\t\t} else {\n\t\t\t\tsend_handle(id, handle);\n\t\t\t\tstatus = SSH2_FX_OK;\n\t\t\t}\n\t\t}\n\t}\n\tif (status != SSH2_FX_OK)\n\t\tsend_status(id, status);\n\tfree(name);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142297,
    "RELATED_CWE": [
      "CWE-306",
      "CWE-290",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-269"
    ],
    "code": "process_open(u_int32_t id)\n{\n\tu_int32_t pflags;\n\tAttrib a;\n\tchar *name;\n\tint r, handle, fd, flags, mode, status = SSH2_FX_FAILURE;\n\n\tif ((r = sshbuf_get_cstring(iqueue, &name, NULL)) != 0 ||\n\t    (r = sshbuf_get_u32(iqueue, &pflags)) != 0 || /* portable flags */\n\t    (r = decode_attrib(iqueue, &a)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"request %u: open flags %d\", id, pflags);\n\tflags = flags_from_portable(pflags);\n\tmode = (a.flags & SSH2_FILEXFER_ATTR_PERMISSIONS) ? a.perm : 0666;\n \tlogit(\"open \\\"%s\\\" flags %s mode 0%o\",\n \t    name, string_from_portable(pflags), mode);\n \tif (readonly &&\n\t    ((flags & O_ACCMODE) != O_RDONLY ||\n\t    (flags & (O_CREAT|O_TRUNC)) != 0)) {\n \t\tverbose(\"Refusing open request in read-only mode\");\n \t\tstatus = SSH2_FX_PERMISSION_DENIED;\n \t} else {\n\t\tfd = open(name, flags, mode);\n\t\tif (fd < 0) {\n\t\t\tstatus = errno_to_portable(errno);\n\t\t} else {\n\t\t\thandle = handle_new(HANDLE_FILE, name, fd, flags, NULL);\n\t\t\tif (handle < 0) {\n\t\t\t\tclose(fd);\n\t\t\t} else {\n\t\t\t\tsend_handle(id, handle);\n\t\t\t\tstatus = SSH2_FX_OK;\n\t\t\t}\n\t\t}\n\t}\n\tif (status != SSH2_FX_OK)\n\t\tsend_status(id, status);\n\tfree(name);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142298,
    "RELATED_CWE": [
      "CWE-306",
      "CWE-290",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-269"
    ],
    "code": "void bandwidth_pid(pid_t pid, const char *command, const char *dev, int down, int up) {\n\tEUID_ASSERT();\n\tEUID_ROOT();\n\tchar *comm = pid_proc_comm(pid);\n\tEUID_USER();\n\tif (!comm) {\n\t\tfprintf(stderr, \"Error: cannot find sandbox\\n\");\n\t\texit(1);\n\t}\n\n\tif (strcmp(comm, \"firejail\") != 0) {\n\t\tfprintf(stderr, \"Error: cannot find sandbox\\n\");\n\t\texit(1);\n\t}\n\tfree(comm);\n\t\n\tchar *name;\n\tif (asprintf(&name, \"/run/firejail/network/%d-netmap\", pid) == -1)\n\t\terrExit(\"asprintf\");\n\tstruct stat s;\n\tif (stat(name, &s) == -1) {\n\t\tfprintf(stderr, \"Error: the sandbox doesn't use a new network namespace\\n\");\n\t\texit(1);\n\t}\n\n\tpid_t child;\n\tif (find_child(pid, &child) == -1) {\n\t\tfprintf(stderr, \"Error: cannot join the network namespace\\n\");\n\t\texit(1);\n\t}\n\n\tEUID_ROOT();\n\tif (join_namespace(child, \"net\")) {\n\t\tfprintf(stderr, \"Error: cannot join the network namespace\\n\");\n\t\texit(1);\n\t}\n\n\tif (strcmp(command, \"set\") == 0)\n\t\tbandwidth_set(pid, dev, down, up);\n\telse if (strcmp(command, \"clear\") == 0)\n\t\tbandwidth_remove(pid, dev);\n\n\tchar *devname = NULL;\n\tif (dev) {\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"%s/%d-netmap\", RUN_FIREJAIL_NETWORK_DIR, (int) pid) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tFILE *fp = fopen(fname, \"r\");\n\t\tif (!fp) {\n\t\t\tfprintf(stderr, \"Error: cannot read network map file %s\\n\", fname);\n\t\t\texit(1);\n\t\t}\n\t\t\n\t\tchar buf[1024];\n\t\tint len = strlen(dev);\n\t\twhile (fgets(buf, 1024, fp)) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (*buf == '\\0')\n\t\t\t\tbreak;\n\n\t\t\tif (strncmp(buf, dev, len) == 0  && buf[len] == ':') {\n\t\t\t\tdevname = strdup(buf + len + 1);\n\t\t\t\tif (!devname)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t\tif (if_nametoindex(devname) == 0) {\n\t\t\t\t\tfprintf(stderr, \"Error: cannot find network device %s\\n\", devname);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfree(fname);\n\t\tfclose(fp);\n\t}\n\t\n\tchar *cmd = NULL;\n\tif (devname) {\n\t\tif (strcmp(command, \"set\") == 0) {\n\t\t\tif (asprintf(&cmd, \"%s/firejail/fshaper.sh --%s %s %d %d\",\n\t\t\t\tLIBDIR, command, devname, down, up) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t}\n\t\telse {\n\t\t\tif (asprintf(&cmd, \"%s/firejail/fshaper.sh --%s %s\",\n\t\t\t\tLIBDIR, command, devname) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t}\n\t}\n\telse {\n\t\tif (asprintf(&cmd, \"%s/firejail/fshaper.sh --%s\", LIBDIR, command) == -1)\n\t\t\terrExit(\"asprintf\");\n\t}\n\tassert(cmd);\n\n\tenviron = NULL;\n\n\tif (setreuid(0, 0))\n\t\terrExit(\"setreuid\");\n \tif (setregid(0, 0))\n \t\terrExit(\"setregid\");\n \n\tif (!cfg.shell)\n\t\tcfg.shell = guess_shell();\n\tif (!cfg.shell) {\n\t\tfprintf(stderr, \"Error: no POSIX shell found, please use --shell command line option\\n\");\n\t\texit(1);\n\t}\n \tchar *arg[4];\n\targ[0] = cfg.shell;\n \targ[1] = \"-c\";\n \targ[2] = cmd;\n \targ[3] = NULL;\n\tclearenv();\n\texecvp(arg[0], arg);\n\t\n\terrExit(\"execvp\");\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142673,
    "RELATED_CWE": [
      "CWE-306",
      "CWE-290",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-269"
    ],
    "code": "void bandwidth_pid(pid_t pid, const char *command, const char *dev, int down, int up) {\n\tEUID_ASSERT();\n\tEUID_ROOT();\n\tchar *comm = pid_proc_comm(pid);\n\tEUID_USER();\n\tif (!comm) {\n\t\tfprintf(stderr, \"Error: cannot find sandbox\\n\");\n\t\texit(1);\n\t}\n\n\tif (strcmp(comm, \"firejail\") != 0) {\n\t\tfprintf(stderr, \"Error: cannot find sandbox\\n\");\n\t\texit(1);\n\t}\n\tfree(comm);\n\t\n\tchar *name;\n\tif (asprintf(&name, \"/run/firejail/network/%d-netmap\", pid) == -1)\n\t\terrExit(\"asprintf\");\n\tstruct stat s;\n\tif (stat(name, &s) == -1) {\n\t\tfprintf(stderr, \"Error: the sandbox doesn't use a new network namespace\\n\");\n\t\texit(1);\n\t}\n\n\tpid_t child;\n\tif (find_child(pid, &child) == -1) {\n\t\tfprintf(stderr, \"Error: cannot join the network namespace\\n\");\n\t\texit(1);\n\t}\n\n\tEUID_ROOT();\n\tif (join_namespace(child, \"net\")) {\n\t\tfprintf(stderr, \"Error: cannot join the network namespace\\n\");\n\t\texit(1);\n\t}\n\n\tif (strcmp(command, \"set\") == 0)\n\t\tbandwidth_set(pid, dev, down, up);\n\telse if (strcmp(command, \"clear\") == 0)\n\t\tbandwidth_remove(pid, dev);\n\n\tchar *devname = NULL;\n\tif (dev) {\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"%s/%d-netmap\", RUN_FIREJAIL_NETWORK_DIR, (int) pid) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tFILE *fp = fopen(fname, \"r\");\n\t\tif (!fp) {\n\t\t\tfprintf(stderr, \"Error: cannot read network map file %s\\n\", fname);\n\t\t\texit(1);\n\t\t}\n\t\t\n\t\tchar buf[1024];\n\t\tint len = strlen(dev);\n\t\twhile (fgets(buf, 1024, fp)) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (*buf == '\\0')\n\t\t\t\tbreak;\n\n\t\t\tif (strncmp(buf, dev, len) == 0  && buf[len] == ':') {\n\t\t\t\tdevname = strdup(buf + len + 1);\n\t\t\t\tif (!devname)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t\tif (if_nametoindex(devname) == 0) {\n\t\t\t\t\tfprintf(stderr, \"Error: cannot find network device %s\\n\", devname);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfree(fname);\n\t\tfclose(fp);\n\t}\n\t\n\tchar *cmd = NULL;\n\tif (devname) {\n\t\tif (strcmp(command, \"set\") == 0) {\n\t\t\tif (asprintf(&cmd, \"%s/firejail/fshaper.sh --%s %s %d %d\",\n\t\t\t\tLIBDIR, command, devname, down, up) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t}\n\t\telse {\n\t\t\tif (asprintf(&cmd, \"%s/firejail/fshaper.sh --%s %s\",\n\t\t\t\tLIBDIR, command, devname) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t}\n\t}\n\telse {\n\t\tif (asprintf(&cmd, \"%s/firejail/fshaper.sh --%s\", LIBDIR, command) == -1)\n\t\t\terrExit(\"asprintf\");\n\t}\n\tassert(cmd);\n\n\tenviron = NULL;\n\n\tif (setreuid(0, 0))\n\t\terrExit(\"setreuid\");\n \tif (setregid(0, 0))\n \t\terrExit(\"setregid\");\n \n \tchar *arg[4];\n\targ[0] = \"/bin/sh\";\n \targ[1] = \"-c\";\n \targ[2] = cmd;\n \targ[3] = NULL;\n\tclearenv();\n\texecvp(arg[0], arg);\n\t\n\terrExit(\"execvp\");\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142674,
    "RELATED_CWE": [
      "CWE-306",
      "CWE-290",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-269"
    ],
    "code": "void inode_init_owner(struct inode *inode, const struct inode *dir,\n\t\t\tumode_t mode)\n{\n \tinode->i_uid = current_fsuid();\n \tif (dir && dir->i_mode & S_ISGID) {\n \t\tinode->i_gid = dir->i_gid;\n \t\tif (S_ISDIR(mode))\n \t\t\tmode |= S_ISGID;\n \t} else\n \t\tinode->i_gid = current_fsgid();\n \tinode->i_mode = mode;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142977,
    "RELATED_CWE": [
      "CWE-306",
      "CWE-290",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-269"
    ],
    "code": "void inode_init_owner(struct inode *inode, const struct inode *dir,\n\t\t\tumode_t mode)\n{\n \tinode->i_uid = current_fsuid();\n \tif (dir && dir->i_mode & S_ISGID) {\n \t\tinode->i_gid = dir->i_gid;\n\n\t\t/* Directories are special, and always inherit S_ISGID */\n \t\tif (S_ISDIR(mode))\n \t\t\tmode |= S_ISGID;\n\t\telse if ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP) &&\n\t\t\t !in_group_p(inode->i_gid) &&\n\t\t\t !capable_wrt_inode_uidgid(dir, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n \t} else\n \t\tinode->i_gid = current_fsgid();\n \tinode->i_mode = mode;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142978,
    "RELATED_CWE": [
      "CWE-306",
      "CWE-290",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-269"
    ],
    "code": "qboolean S_AL_Init( soundInterface_t *si )\n{\n#ifdef USE_OPENAL\n\tconst char* device = NULL;\n\tconst char* inputdevice = NULL;\n\tint i;\n\n\tif( !si ) {\n\t\treturn qfalse;\n\t}\n\n\tfor (i = 0; i < MAX_RAW_STREAMS; i++) {\n\t\tstreamSourceHandles[i] = -1;\n\t\tstreamPlaying[i] = qfalse;\n\t\tstreamSources[i] = 0;\n\t\tstreamNumBuffers[i] = 0;\n\t\tstreamBufIndex[i] = 0;\n\t}\n\n\ts_alPrecache = Cvar_Get( \"s_alPrecache\", \"1\", CVAR_ARCHIVE );\n\ts_alGain = Cvar_Get( \"s_alGain\", \"1.0\", CVAR_ARCHIVE );\n\ts_alSources = Cvar_Get( \"s_alSources\", \"96\", CVAR_ARCHIVE );\n\ts_alDopplerFactor = Cvar_Get( \"s_alDopplerFactor\", \"1.0\", CVAR_ARCHIVE );\n\ts_alDopplerSpeed = Cvar_Get( \"s_alDopplerSpeed\", \"9000\", CVAR_ARCHIVE );\n\ts_alMinDistance = Cvar_Get( \"s_alMinDistance\", \"120\", CVAR_CHEAT );\n\ts_alMaxDistance = Cvar_Get(\"s_alMaxDistance\", \"1024\", CVAR_CHEAT);\n \ts_alRolloff = Cvar_Get( \"s_alRolloff\", \"2\", CVAR_CHEAT);\n \ts_alGraceDistance = Cvar_Get(\"s_alGraceDistance\", \"512\", CVAR_CHEAT);\n \n\ts_alDriver = Cvar_Get( \"s_alDriver\", ALDRIVER_DEFAULT, CVAR_ARCHIVE | CVAR_LATCH );\n \n \ts_alInputDevice = Cvar_Get( \"s_alInputDevice\", \"\", CVAR_ARCHIVE | CVAR_LATCH );\n \ts_alDevice = Cvar_Get(\"s_alDevice\", \"\", CVAR_ARCHIVE | CVAR_LATCH);\n \n \tif( !QAL_Init( s_alDriver->string ) )\n \t{\n\t\tCom_Printf( \"Failed to load library: \\\"%s\\\".\\n\", s_alDriver->string );\n\t\tif( !Q_stricmp( s_alDriver->string, ALDRIVER_DEFAULT ) || !QAL_Init( ALDRIVER_DEFAULT ) ) {\n\t\t\treturn qfalse;\n\t\t}\n\t}\n\n\tdevice = s_alDevice->string;\n\tif(device && !*device)\n\t\tdevice = NULL;\n\n\tinputdevice = s_alInputDevice->string;\n\tif(inputdevice && !*inputdevice)\n\t\tinputdevice = NULL;\n\n\n\tenumeration_all_ext = qalcIsExtensionPresent(NULL, \"ALC_ENUMERATE_ALL_EXT\");\n\tenumeration_ext = qalcIsExtensionPresent(NULL, \"ALC_ENUMERATION_EXT\");\n\n\tif(enumeration_ext || enumeration_all_ext)\n\t{\n\t\tchar devicenames[16384] = \"\";\n\t\tconst char *devicelist;\n#ifdef _WIN32\n\t\tconst char *defaultdevice;\n#endif\n\t\tint curlen;\n\n\t\tif(enumeration_all_ext)\n\t\t{\n\t\t\tdevicelist = qalcGetString(NULL, ALC_ALL_DEVICES_SPECIFIER);\n#ifdef _WIN32\n\t\t\tdefaultdevice = qalcGetString(NULL, ALC_DEFAULT_ALL_DEVICES_SPECIFIER);\n#endif\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdevicelist = qalcGetString(NULL, ALC_DEVICE_SPECIFIER);\n#ifdef _WIN32\n\t\t\tdefaultdevice = qalcGetString(NULL, ALC_DEFAULT_DEVICE_SPECIFIER);\n#endif\n\t\t\tenumeration_ext = qtrue;\n\t\t}\n\n#ifdef _WIN32\n\t\tif(!device && defaultdevice && !strcmp(defaultdevice, \"Generic Hardware\"))\n\t\t\tdevice = \"Generic Software\";\n#endif\n\n\n\t\tif(devicelist)\n\t\t{\n\t\t\twhile((curlen = strlen(devicelist)))\n\t\t\t{\n\t\t\t\tQ_strcat(devicenames, sizeof(devicenames), devicelist);\n\t\t\t\tQ_strcat(devicenames, sizeof(devicenames), \"\\n\");\n\n\t\t\t\tdevicelist += curlen + 1;\n\t\t\t}\n\t\t}\n\n\t\ts_alAvailableDevices = Cvar_Get(\"s_alAvailableDevices\", devicenames, CVAR_ROM | CVAR_NORESTART);\n\t}\n\n\talDevice = qalcOpenDevice(device);\n\tif( !alDevice && device )\n\t{\n\t\tCom_Printf( \"Failed to open OpenAL device '%s', trying default.\\n\", device );\n\t\talDevice = qalcOpenDevice(NULL);\n\t}\n\n\tif( !alDevice )\n\t{\n\t\tQAL_Shutdown( );\n\t\tCom_Printf( \"Failed to open OpenAL device.\\n\" );\n\t\treturn qfalse;\n\t}\n\n\talContext = qalcCreateContext( alDevice, NULL );\n\tif( !alContext )\n\t{\n\t\tQAL_Shutdown( );\n\t\tqalcCloseDevice( alDevice );\n\t\tCom_Printf( \"Failed to create OpenAL context.\\n\" );\n\t\treturn qfalse;\n\t}\n\tqalcMakeContextCurrent( alContext );\n\n\tS_AL_BufferInit( );\n\tS_AL_SrcInit( );\n\n\tqalDistanceModel(AL_INVERSE_DISTANCE_CLAMPED);\n\tqalDopplerFactor( s_alDopplerFactor->value );\n\tqalSpeedOfSound( s_alDopplerSpeed->value );\n\n#ifdef USE_VOIP\n\ts_alCapture = Cvar_Get( \"s_alCapture\", \"1\", CVAR_ARCHIVE | CVAR_LATCH );\n\tif (!s_alCapture->integer)\n\t{\n\t\tCom_Printf(\"OpenAL capture support disabled by user ('+set s_alCapture 1' to enable)\\n\");\n\t}\n#if USE_MUMBLE\n\telse if (cl_useMumble->integer)\n\t{\n\t\tCom_Printf(\"OpenAL capture support disabled for Mumble support\\n\");\n\t}\n#endif\n\telse\n\t{\n#ifdef __APPLE__\n\t\tif (qalcCaptureOpenDevice == NULL)\n#else\n\t\tif (!qalcIsExtensionPresent(NULL, \"ALC_EXT_capture\"))\n#endif\n\t\t{\n\t\t\tCom_Printf(\"No ALC_EXT_capture support, can't record audio.\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tchar inputdevicenames[16384] = \"\";\n\t\t\tconst char *inputdevicelist;\n\t\t\tconst char *defaultinputdevice;\n\t\t\tint curlen;\n\n\t\t\tcapture_ext = qtrue;\n\n\t\t\tinputdevicelist = qalcGetString(NULL, ALC_CAPTURE_DEVICE_SPECIFIER);\n\t\t\tdefaultinputdevice = qalcGetString(NULL, ALC_CAPTURE_DEFAULT_DEVICE_SPECIFIER);\n\n\t\t\tif (inputdevicelist)\n\t\t\t{\n\t\t\t\twhile((curlen = strlen(inputdevicelist)))\n\t\t\t\t{\n\t\t\t\t\tQ_strcat(inputdevicenames, sizeof(inputdevicenames), inputdevicelist);\n\t\t\t\t\tQ_strcat(inputdevicenames, sizeof(inputdevicenames), \"\\n\");\n\t\t\t\t\tinputdevicelist += curlen + 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ts_alAvailableInputDevices = Cvar_Get(\"s_alAvailableInputDevices\", inputdevicenames, CVAR_ROM | CVAR_NORESTART);\n\n\t\t\tCom_Printf(\"OpenAL default capture device is '%s'\\n\", defaultinputdevice ? defaultinputdevice : \"none\");\n\t\t\talCaptureDevice = qalcCaptureOpenDevice(inputdevice, 48000, AL_FORMAT_MONO16, VOIP_MAX_PACKET_SAMPLES*4);\n\t\t\tif( !alCaptureDevice && inputdevice )\n\t\t\t{\n\t\t\t\tCom_Printf( \"Failed to open OpenAL Input device '%s', trying default.\\n\", inputdevice );\n\t\t\t\talCaptureDevice = qalcCaptureOpenDevice(NULL, 48000, AL_FORMAT_MONO16, VOIP_MAX_PACKET_SAMPLES*4);\n\t\t\t}\n\t\t\tCom_Printf( \"OpenAL capture device %s.\\n\",\n\t\t\t\t    (alCaptureDevice == NULL) ? \"failed to open\" : \"opened\");\n\t\t}\n\t}\n#endif\n\n\tsi->Shutdown = S_AL_Shutdown;\n\tsi->StartSound = S_AL_StartSound;\n\tsi->StartLocalSound = S_AL_StartLocalSound;\n\tsi->StartBackgroundTrack = S_AL_StartBackgroundTrack;\n\tsi->StopBackgroundTrack = S_AL_StopBackgroundTrack;\n\tsi->RawSamples = S_AL_RawSamples;\n\tsi->StopAllSounds = S_AL_StopAllSounds;\n\tsi->ClearLoopingSounds = S_AL_ClearLoopingSounds;\n\tsi->AddLoopingSound = S_AL_AddLoopingSound;\n\tsi->AddRealLoopingSound = S_AL_AddRealLoopingSound;\n\tsi->StopLoopingSound = S_AL_StopLoopingSound;\n\tsi->Respatialize = S_AL_Respatialize;\n\tsi->UpdateEntityPosition = S_AL_UpdateEntityPosition;\n\tsi->Update = S_AL_Update;\n\tsi->DisableSounds = S_AL_DisableSounds;\n\tsi->BeginRegistration = S_AL_BeginRegistration;\n\tsi->RegisterSound = S_AL_RegisterSound;\n\tsi->ClearSoundBuffer = S_AL_ClearSoundBuffer;\n\tsi->SoundInfo = S_AL_SoundInfo;\n\tsi->SoundList = S_AL_SoundList;\n\n#ifdef USE_VOIP\n\tsi->StartCapture = S_AL_StartCapture;\n\tsi->AvailableCaptureSamples = S_AL_AvailableCaptureSamples;\n\tsi->Capture = S_AL_Capture;\n\tsi->StopCapture = S_AL_StopCapture;\n\tsi->MasterGain = S_AL_MasterGain;\n#endif\n\n\treturn qtrue;\n#else\n\treturn qfalse;\n#endif\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144469,
    "RELATED_CWE": [
      "CWE-306",
      "CWE-290",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-269"
    ],
    "code": "qboolean S_AL_Init( soundInterface_t *si )\n{\n#ifdef USE_OPENAL\n\tconst char* device = NULL;\n\tconst char* inputdevice = NULL;\n\tint i;\n\n\tif( !si ) {\n\t\treturn qfalse;\n\t}\n\n\tfor (i = 0; i < MAX_RAW_STREAMS; i++) {\n\t\tstreamSourceHandles[i] = -1;\n\t\tstreamPlaying[i] = qfalse;\n\t\tstreamSources[i] = 0;\n\t\tstreamNumBuffers[i] = 0;\n\t\tstreamBufIndex[i] = 0;\n\t}\n\n\ts_alPrecache = Cvar_Get( \"s_alPrecache\", \"1\", CVAR_ARCHIVE );\n\ts_alGain = Cvar_Get( \"s_alGain\", \"1.0\", CVAR_ARCHIVE );\n\ts_alSources = Cvar_Get( \"s_alSources\", \"96\", CVAR_ARCHIVE );\n\ts_alDopplerFactor = Cvar_Get( \"s_alDopplerFactor\", \"1.0\", CVAR_ARCHIVE );\n\ts_alDopplerSpeed = Cvar_Get( \"s_alDopplerSpeed\", \"9000\", CVAR_ARCHIVE );\n\ts_alMinDistance = Cvar_Get( \"s_alMinDistance\", \"120\", CVAR_CHEAT );\n\ts_alMaxDistance = Cvar_Get(\"s_alMaxDistance\", \"1024\", CVAR_CHEAT);\n \ts_alRolloff = Cvar_Get( \"s_alRolloff\", \"2\", CVAR_CHEAT);\n \ts_alGraceDistance = Cvar_Get(\"s_alGraceDistance\", \"512\", CVAR_CHEAT);\n \n\ts_alDriver = Cvar_Get( \"s_alDriver\", ALDRIVER_DEFAULT, CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED );\n \n \ts_alInputDevice = Cvar_Get( \"s_alInputDevice\", \"\", CVAR_ARCHIVE | CVAR_LATCH );\n \ts_alDevice = Cvar_Get(\"s_alDevice\", \"\", CVAR_ARCHIVE | CVAR_LATCH);\n \n\tif ( COM_CompareExtension( s_alDriver->string, \".pk3\" ) )\n\t{\n\t\tCom_Printf( \"Rejecting DLL named \\\"%s\\\"\", s_alDriver->string );\n\t\treturn qfalse;\n\t}\n\n \tif( !QAL_Init( s_alDriver->string ) )\n \t{\n\t\tCom_Printf( \"Failed to load library: \\\"%s\\\".\\n\", s_alDriver->string );\n\t\tif( !Q_stricmp( s_alDriver->string, ALDRIVER_DEFAULT ) || !QAL_Init( ALDRIVER_DEFAULT ) ) {\n\t\t\treturn qfalse;\n\t\t}\n\t}\n\n\tdevice = s_alDevice->string;\n\tif(device && !*device)\n\t\tdevice = NULL;\n\n\tinputdevice = s_alInputDevice->string;\n\tif(inputdevice && !*inputdevice)\n\t\tinputdevice = NULL;\n\n\n\tenumeration_all_ext = qalcIsExtensionPresent(NULL, \"ALC_ENUMERATE_ALL_EXT\");\n\tenumeration_ext = qalcIsExtensionPresent(NULL, \"ALC_ENUMERATION_EXT\");\n\n\tif(enumeration_ext || enumeration_all_ext)\n\t{\n\t\tchar devicenames[16384] = \"\";\n\t\tconst char *devicelist;\n#ifdef _WIN32\n\t\tconst char *defaultdevice;\n#endif\n\t\tint curlen;\n\n\t\tif(enumeration_all_ext)\n\t\t{\n\t\t\tdevicelist = qalcGetString(NULL, ALC_ALL_DEVICES_SPECIFIER);\n#ifdef _WIN32\n\t\t\tdefaultdevice = qalcGetString(NULL, ALC_DEFAULT_ALL_DEVICES_SPECIFIER);\n#endif\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdevicelist = qalcGetString(NULL, ALC_DEVICE_SPECIFIER);\n#ifdef _WIN32\n\t\t\tdefaultdevice = qalcGetString(NULL, ALC_DEFAULT_DEVICE_SPECIFIER);\n#endif\n\t\t\tenumeration_ext = qtrue;\n\t\t}\n\n#ifdef _WIN32\n\t\tif(!device && defaultdevice && !strcmp(defaultdevice, \"Generic Hardware\"))\n\t\t\tdevice = \"Generic Software\";\n#endif\n\n\n\t\tif(devicelist)\n\t\t{\n\t\t\twhile((curlen = strlen(devicelist)))\n\t\t\t{\n\t\t\t\tQ_strcat(devicenames, sizeof(devicenames), devicelist);\n\t\t\t\tQ_strcat(devicenames, sizeof(devicenames), \"\\n\");\n\n\t\t\t\tdevicelist += curlen + 1;\n\t\t\t}\n\t\t}\n\n\t\ts_alAvailableDevices = Cvar_Get(\"s_alAvailableDevices\", devicenames, CVAR_ROM | CVAR_NORESTART);\n\t}\n\n\talDevice = qalcOpenDevice(device);\n\tif( !alDevice && device )\n\t{\n\t\tCom_Printf( \"Failed to open OpenAL device '%s', trying default.\\n\", device );\n\t\talDevice = qalcOpenDevice(NULL);\n\t}\n\n\tif( !alDevice )\n\t{\n\t\tQAL_Shutdown( );\n\t\tCom_Printf( \"Failed to open OpenAL device.\\n\" );\n\t\treturn qfalse;\n\t}\n\n\talContext = qalcCreateContext( alDevice, NULL );\n\tif( !alContext )\n\t{\n\t\tQAL_Shutdown( );\n\t\tqalcCloseDevice( alDevice );\n\t\tCom_Printf( \"Failed to create OpenAL context.\\n\" );\n\t\treturn qfalse;\n\t}\n\tqalcMakeContextCurrent( alContext );\n\n\tS_AL_BufferInit( );\n\tS_AL_SrcInit( );\n\n\tqalDistanceModel(AL_INVERSE_DISTANCE_CLAMPED);\n\tqalDopplerFactor( s_alDopplerFactor->value );\n\tqalSpeedOfSound( s_alDopplerSpeed->value );\n\n#ifdef USE_VOIP\n\ts_alCapture = Cvar_Get( \"s_alCapture\", \"1\", CVAR_ARCHIVE | CVAR_LATCH );\n\tif (!s_alCapture->integer)\n\t{\n\t\tCom_Printf(\"OpenAL capture support disabled by user ('+set s_alCapture 1' to enable)\\n\");\n\t}\n#if USE_MUMBLE\n\telse if (cl_useMumble->integer)\n\t{\n\t\tCom_Printf(\"OpenAL capture support disabled for Mumble support\\n\");\n\t}\n#endif\n\telse\n\t{\n#ifdef __APPLE__\n\t\tif (qalcCaptureOpenDevice == NULL)\n#else\n\t\tif (!qalcIsExtensionPresent(NULL, \"ALC_EXT_capture\"))\n#endif\n\t\t{\n\t\t\tCom_Printf(\"No ALC_EXT_capture support, can't record audio.\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tchar inputdevicenames[16384] = \"\";\n\t\t\tconst char *inputdevicelist;\n\t\t\tconst char *defaultinputdevice;\n\t\t\tint curlen;\n\n\t\t\tcapture_ext = qtrue;\n\n\t\t\tinputdevicelist = qalcGetString(NULL, ALC_CAPTURE_DEVICE_SPECIFIER);\n\t\t\tdefaultinputdevice = qalcGetString(NULL, ALC_CAPTURE_DEFAULT_DEVICE_SPECIFIER);\n\n\t\t\tif (inputdevicelist)\n\t\t\t{\n\t\t\t\twhile((curlen = strlen(inputdevicelist)))\n\t\t\t\t{\n\t\t\t\t\tQ_strcat(inputdevicenames, sizeof(inputdevicenames), inputdevicelist);\n\t\t\t\t\tQ_strcat(inputdevicenames, sizeof(inputdevicenames), \"\\n\");\n\t\t\t\t\tinputdevicelist += curlen + 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ts_alAvailableInputDevices = Cvar_Get(\"s_alAvailableInputDevices\", inputdevicenames, CVAR_ROM | CVAR_NORESTART);\n\n\t\t\tCom_Printf(\"OpenAL default capture device is '%s'\\n\", defaultinputdevice ? defaultinputdevice : \"none\");\n\t\t\talCaptureDevice = qalcCaptureOpenDevice(inputdevice, 48000, AL_FORMAT_MONO16, VOIP_MAX_PACKET_SAMPLES*4);\n\t\t\tif( !alCaptureDevice && inputdevice )\n\t\t\t{\n\t\t\t\tCom_Printf( \"Failed to open OpenAL Input device '%s', trying default.\\n\", inputdevice );\n\t\t\t\talCaptureDevice = qalcCaptureOpenDevice(NULL, 48000, AL_FORMAT_MONO16, VOIP_MAX_PACKET_SAMPLES*4);\n\t\t\t}\n\t\t\tCom_Printf( \"OpenAL capture device %s.\\n\",\n\t\t\t\t    (alCaptureDevice == NULL) ? \"failed to open\" : \"opened\");\n\t\t}\n\t}\n#endif\n\n\tsi->Shutdown = S_AL_Shutdown;\n\tsi->StartSound = S_AL_StartSound;\n\tsi->StartLocalSound = S_AL_StartLocalSound;\n\tsi->StartBackgroundTrack = S_AL_StartBackgroundTrack;\n\tsi->StopBackgroundTrack = S_AL_StopBackgroundTrack;\n\tsi->RawSamples = S_AL_RawSamples;\n\tsi->StopAllSounds = S_AL_StopAllSounds;\n\tsi->ClearLoopingSounds = S_AL_ClearLoopingSounds;\n\tsi->AddLoopingSound = S_AL_AddLoopingSound;\n\tsi->AddRealLoopingSound = S_AL_AddRealLoopingSound;\n\tsi->StopLoopingSound = S_AL_StopLoopingSound;\n\tsi->Respatialize = S_AL_Respatialize;\n\tsi->UpdateEntityPosition = S_AL_UpdateEntityPosition;\n\tsi->Update = S_AL_Update;\n\tsi->DisableSounds = S_AL_DisableSounds;\n\tsi->BeginRegistration = S_AL_BeginRegistration;\n\tsi->RegisterSound = S_AL_RegisterSound;\n\tsi->ClearSoundBuffer = S_AL_ClearSoundBuffer;\n\tsi->SoundInfo = S_AL_SoundInfo;\n\tsi->SoundList = S_AL_SoundList;\n\n#ifdef USE_VOIP\n\tsi->StartCapture = S_AL_StartCapture;\n\tsi->AvailableCaptureSamples = S_AL_AvailableCaptureSamples;\n\tsi->Capture = S_AL_Capture;\n\tsi->StopCapture = S_AL_StopCapture;\n\tsi->MasterGain = S_AL_MasterGain;\n#endif\n\n\treturn qtrue;\n#else\n\treturn qfalse;\n#endif\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144470,
    "RELATED_CWE": [
      "CWE-306",
      "CWE-290",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-269"
    ],
    "code": "qboolean S_AL_Init( soundInterface_t *si )\n{\n#ifdef USE_OPENAL\n\tconst char* device = NULL;\n\tconst char* inputdevice = NULL;\n\tint i;\n\n\tif( !si ) {\n\t\treturn qfalse;\n\t}\n\n\tfor (i = 0; i < MAX_RAW_STREAMS; i++) {\n\t\tstreamSourceHandles[i] = -1;\n\t\tstreamPlaying[i] = qfalse;\n\t\tstreamSources[i] = 0;\n\t\tstreamNumBuffers[i] = 0;\n\t\tstreamBufIndex[i] = 0;\n\t}\n\n\t// New console variables\n\ts_alPrecache = Cvar_Get( \"s_alPrecache\", \"1\", CVAR_ARCHIVE );\n\ts_alGain = Cvar_Get( \"s_alGain\", \"1.0\", CVAR_ARCHIVE );\n\ts_alSources = Cvar_Get( \"s_alSources\", \"96\", CVAR_ARCHIVE );\n\ts_alDopplerFactor = Cvar_Get( \"s_alDopplerFactor\", \"1.0\", CVAR_ARCHIVE );\n\ts_alDopplerSpeed = Cvar_Get( \"s_alDopplerSpeed\", \"9000\", CVAR_ARCHIVE );\n\ts_alMinDistance = Cvar_Get( \"s_alMinDistance\", \"120\", CVAR_CHEAT );\n\ts_alMaxDistance = Cvar_Get(\"s_alMaxDistance\", \"1024\", CVAR_CHEAT);\n\ts_alRolloff = Cvar_Get( \"s_alRolloff\", \"2\", CVAR_CHEAT);\n\ts_alGraceDistance = Cvar_Get(\"s_alGraceDistance\", \"512\", CVAR_CHEAT);\n\n\ts_alDriver = Cvar_Get( \"s_alDriver\", ALDRIVER_DEFAULT, CVAR_ARCHIVE | CVAR_LATCH );\n\n\ts_alInputDevice = Cvar_Get( \"s_alInputDevice\", \"\", CVAR_ARCHIVE | CVAR_LATCH );\n\ts_alDevice = Cvar_Get(\"s_alDevice\", \"\", CVAR_ARCHIVE | CVAR_LATCH);\n\n\t// Load QAL\n\tif( !QAL_Init( s_alDriver->string ) )\n\t{\n\t\tCom_Printf( \"Failed to load library: \\\"%s\\\".\\n\", s_alDriver->string );\n\t\tif( !Q_stricmp( s_alDriver->string, ALDRIVER_DEFAULT ) || !QAL_Init( ALDRIVER_DEFAULT ) ) {\n\t\t\treturn qfalse;\n\t\t}\n\t}\n\n\tdevice = s_alDevice->string;\n\tif(device && !*device)\n\t\tdevice = NULL;\n\n\tinputdevice = s_alInputDevice->string;\n\tif(inputdevice && !*inputdevice)\n\t\tinputdevice = NULL;\n\n\n\t// Device enumeration support\n\tenumeration_all_ext = qalcIsExtensionPresent(NULL, \"ALC_ENUMERATE_ALL_EXT\");\n\tenumeration_ext = qalcIsExtensionPresent(NULL, \"ALC_ENUMERATION_EXT\");\n\n\tif(enumeration_ext || enumeration_all_ext)\n\t{\n\t\tchar devicenames[16384] = \"\";\n\t\tconst char *devicelist;\n#ifdef _WIN32\n\t\tconst char *defaultdevice;\n#endif\n\t\tint curlen;\n\n\t\t// get all available devices + the default device name.\n\t\tif(enumeration_all_ext)\n\t\t{\n\t\t\tdevicelist = qalcGetString(NULL, ALC_ALL_DEVICES_SPECIFIER);\n#ifdef _WIN32\n\t\t\tdefaultdevice = qalcGetString(NULL, ALC_DEFAULT_ALL_DEVICES_SPECIFIER);\n#endif\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// We don't have ALC_ENUMERATE_ALL_EXT but normal enumeration.\n\t\t\tdevicelist = qalcGetString(NULL, ALC_DEVICE_SPECIFIER);\n#ifdef _WIN32\n\t\t\tdefaultdevice = qalcGetString(NULL, ALC_DEFAULT_DEVICE_SPECIFIER);\n#endif\n\t\t\tenumeration_ext = qtrue;\n\t\t}\n\n#ifdef _WIN32\n\t\t// check whether the default device is generic hardware. If it is, change to\n\t\t// Generic Software as that one works more reliably with various sound systems.\n\t\t// If it's not, use OpenAL's default selection as we don't want to ignore\n\t\t// native hardware acceleration.\n\t\tif(!device && defaultdevice && !strcmp(defaultdevice, \"Generic Hardware\"))\n\t\t\tdevice = \"Generic Software\";\n#endif\n\n\t\t// dump a list of available devices to a cvar for the user to see.\n\n\t\tif(devicelist)\n\t\t{\n\t\t\twhile((curlen = strlen(devicelist)))\n\t\t\t{\n\t\t\t\tQ_strcat(devicenames, sizeof(devicenames), devicelist);\n\t\t\t\tQ_strcat(devicenames, sizeof(devicenames), \"\\n\");\n\n\t\t\t\tdevicelist += curlen + 1;\n\t\t\t}\n\t\t}\n\n\t\ts_alAvailableDevices = Cvar_Get(\"s_alAvailableDevices\", devicenames, CVAR_ROM | CVAR_NORESTART);\n\t}\n\n\talDevice = qalcOpenDevice(device);\n\tif( !alDevice && device )\n\t{\n\t\tCom_Printf( \"Failed to open OpenAL device '%s', trying default.\\n\", device );\n\t\talDevice = qalcOpenDevice(NULL);\n\t}\n\n\tif( !alDevice )\n\t{\n\t\tQAL_Shutdown( );\n\t\tCom_Printf( \"Failed to open OpenAL device.\\n\" );\n\t\treturn qfalse;\n\t}\n\n\t// Create OpenAL context\n\talContext = qalcCreateContext( alDevice, NULL );\n\tif( !alContext )\n\t{\n\t\tQAL_Shutdown( );\n\t\tqalcCloseDevice( alDevice );\n\t\tCom_Printf( \"Failed to create OpenAL context.\\n\" );\n\t\treturn qfalse;\n\t}\n\tqalcMakeContextCurrent( alContext );\n\n\t// Initialize sources, buffers, music\n\tS_AL_BufferInit( );\n\tS_AL_SrcInit( );\n\n\t// Set up OpenAL parameters (doppler, etc)\n\tqalDistanceModel(AL_INVERSE_DISTANCE_CLAMPED);\n\tqalDopplerFactor( s_alDopplerFactor->value );\n\tqalSpeedOfSound( s_alDopplerSpeed->value );\n\n#ifdef USE_VOIP\n\t// !!! FIXME: some of these alcCaptureOpenDevice() values should be cvars.\n\t// !!! FIXME: add support for capture device enumeration.\n\t// !!! FIXME: add some better error reporting.\n\ts_alCapture = Cvar_Get( \"s_alCapture\", \"1\", CVAR_ARCHIVE | CVAR_LATCH );\n\tif (!s_alCapture->integer)\n\t{\n\t\tCom_Printf(\"OpenAL capture support disabled by user ('+set s_alCapture 1' to enable)\\n\");\n\t}\n#if USE_MUMBLE\n\telse if (cl_useMumble->integer)\n\t{\n\t\tCom_Printf(\"OpenAL capture support disabled for Mumble support\\n\");\n\t}\n#endif\n\telse\n\t{\n#ifdef __APPLE__\n\t\t// !!! FIXME: Apple has a 1.1-compliant OpenAL, which includes\n\t\t// !!! FIXME:  capture support, but they don't list it in the\n\t\t// !!! FIXME:  extension string. We need to check the version string,\n\t\t// !!! FIXME:  then the extension string, but that's too much trouble,\n\t\t// !!! FIXME:  so we'll just check the function pointer for now.\n\t\tif (qalcCaptureOpenDevice == NULL)\n#else\n\t\tif (!qalcIsExtensionPresent(NULL, \"ALC_EXT_capture\"))\n#endif\n\t\t{\n\t\t\tCom_Printf(\"No ALC_EXT_capture support, can't record audio.\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tchar inputdevicenames[16384] = \"\";\n\t\t\tconst char *inputdevicelist;\n\t\t\tconst char *defaultinputdevice;\n\t\t\tint curlen;\n\n\t\t\tcapture_ext = qtrue;\n\n\t\t\t// get all available input devices + the default input device name.\n\t\t\tinputdevicelist = qalcGetString(NULL, ALC_CAPTURE_DEVICE_SPECIFIER);\n\t\t\tdefaultinputdevice = qalcGetString(NULL, ALC_CAPTURE_DEFAULT_DEVICE_SPECIFIER);\n\n\t\t\t// dump a list of available devices to a cvar for the user to see.\n\t\t\tif (inputdevicelist)\n\t\t\t{\n\t\t\t\twhile((curlen = strlen(inputdevicelist)))\n\t\t\t\t{\n\t\t\t\t\tQ_strcat(inputdevicenames, sizeof(inputdevicenames), inputdevicelist);\n\t\t\t\t\tQ_strcat(inputdevicenames, sizeof(inputdevicenames), \"\\n\");\n\t\t\t\t\tinputdevicelist += curlen + 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ts_alAvailableInputDevices = Cvar_Get(\"s_alAvailableInputDevices\", inputdevicenames, CVAR_ROM | CVAR_NORESTART);\n\n\t\t\tCom_Printf(\"OpenAL default capture device is '%s'\\n\", defaultinputdevice ? defaultinputdevice : \"none\");\n\t\t\talCaptureDevice = qalcCaptureOpenDevice(inputdevice, 48000, AL_FORMAT_MONO16, VOIP_MAX_PACKET_SAMPLES*4);\n\t\t\tif( !alCaptureDevice && inputdevice )\n\t\t\t{\n\t\t\t\tCom_Printf( \"Failed to open OpenAL Input device '%s', trying default.\\n\", inputdevice );\n\t\t\t\talCaptureDevice = qalcCaptureOpenDevice(NULL, 48000, AL_FORMAT_MONO16, VOIP_MAX_PACKET_SAMPLES*4);\n\t\t\t}\n\t\t\tCom_Printf( \"OpenAL capture device %s.\\n\",\n\t\t\t\t    (alCaptureDevice == NULL) ? \"failed to open\" : \"opened\");\n\t\t}\n\t}\n#endif\n\n\tsi->Shutdown = S_AL_Shutdown;\n\tsi->StartSound = S_AL_StartSound;\n\tsi->StartLocalSound = S_AL_StartLocalSound;\n\tsi->StartBackgroundTrack = S_AL_StartBackgroundTrack;\n\tsi->StopBackgroundTrack = S_AL_StopBackgroundTrack;\n\tsi->RawSamples = S_AL_RawSamples;\n\tsi->StopAllSounds = S_AL_StopAllSounds;\n\tsi->ClearLoopingSounds = S_AL_ClearLoopingSounds;\n\tsi->AddLoopingSound = S_AL_AddLoopingSound;\n\tsi->AddRealLoopingSound = S_AL_AddRealLoopingSound;\n\tsi->StopLoopingSound = S_AL_StopLoopingSound;\n\tsi->Respatialize = S_AL_Respatialize;\n\tsi->UpdateEntityPosition = S_AL_UpdateEntityPosition;\n\tsi->Update = S_AL_Update;\n\tsi->DisableSounds = S_AL_DisableSounds;\n\tsi->BeginRegistration = S_AL_BeginRegistration;\n\tsi->RegisterSound = S_AL_RegisterSound;\n\tsi->ClearSoundBuffer = S_AL_ClearSoundBuffer;\n\tsi->SoundInfo = S_AL_SoundInfo;\n\tsi->SoundList = S_AL_SoundList;\n\n#ifdef USE_VOIP\n\tsi->StartCapture = S_AL_StartCapture;\n\tsi->AvailableCaptureSamples = S_AL_AvailableCaptureSamples;\n\tsi->Capture = S_AL_Capture;\n\tsi->StopCapture = S_AL_StopCapture;\n\tsi->MasterGain = S_AL_MasterGain;\n#endif\n\n\treturn qtrue;\n#else\n\treturn qfalse;\n#endif\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144771,
    "RELATED_CWE": [
      "CWE-306",
      "CWE-290",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-269"
    ],
    "code": "qboolean S_AL_Init( soundInterface_t *si )\n{\n#ifdef USE_OPENAL\n\tconst char* device = NULL;\n\tconst char* inputdevice = NULL;\n\tint i;\n\n\tif( !si ) {\n\t\treturn qfalse;\n\t}\n\n\tfor (i = 0; i < MAX_RAW_STREAMS; i++) {\n\t\tstreamSourceHandles[i] = -1;\n\t\tstreamPlaying[i] = qfalse;\n\t\tstreamSources[i] = 0;\n\t\tstreamNumBuffers[i] = 0;\n\t\tstreamBufIndex[i] = 0;\n\t}\n\n\t// New console variables\n\ts_alPrecache = Cvar_Get( \"s_alPrecache\", \"1\", CVAR_ARCHIVE );\n\ts_alGain = Cvar_Get( \"s_alGain\", \"1.0\", CVAR_ARCHIVE );\n\ts_alSources = Cvar_Get( \"s_alSources\", \"96\", CVAR_ARCHIVE );\n\ts_alDopplerFactor = Cvar_Get( \"s_alDopplerFactor\", \"1.0\", CVAR_ARCHIVE );\n\ts_alDopplerSpeed = Cvar_Get( \"s_alDopplerSpeed\", \"9000\", CVAR_ARCHIVE );\n\ts_alMinDistance = Cvar_Get( \"s_alMinDistance\", \"120\", CVAR_CHEAT );\n\ts_alMaxDistance = Cvar_Get(\"s_alMaxDistance\", \"1024\", CVAR_CHEAT);\n\ts_alRolloff = Cvar_Get( \"s_alRolloff\", \"2\", CVAR_CHEAT);\n\ts_alGraceDistance = Cvar_Get(\"s_alGraceDistance\", \"512\", CVAR_CHEAT);\n\n\ts_alDriver = Cvar_Get( \"s_alDriver\", ALDRIVER_DEFAULT, CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED );\n\n\ts_alInputDevice = Cvar_Get( \"s_alInputDevice\", \"\", CVAR_ARCHIVE | CVAR_LATCH );\n\ts_alDevice = Cvar_Get(\"s_alDevice\", \"\", CVAR_ARCHIVE | CVAR_LATCH);\n\n\tif ( COM_CompareExtension( s_alDriver->string, \".pk3\" ) )\n\t{\n\t\tCom_Printf( \"Rejecting DLL named \\\"%s\\\"\", s_alDriver->string );\n\t\treturn qfalse;\n\t}\n\n\t// Load QAL\n\tif( !QAL_Init( s_alDriver->string ) )\n\t{\n\t\tCom_Printf( \"Failed to load library: \\\"%s\\\".\\n\", s_alDriver->string );\n\t\tif( !Q_stricmp( s_alDriver->string, ALDRIVER_DEFAULT ) || !QAL_Init( ALDRIVER_DEFAULT ) ) {\n\t\t\treturn qfalse;\n\t\t}\n\t}\n\n\tdevice = s_alDevice->string;\n\tif(device && !*device)\n\t\tdevice = NULL;\n\n\tinputdevice = s_alInputDevice->string;\n\tif(inputdevice && !*inputdevice)\n\t\tinputdevice = NULL;\n\n\n\t// Device enumeration support\n\tenumeration_all_ext = qalcIsExtensionPresent(NULL, \"ALC_ENUMERATE_ALL_EXT\");\n\tenumeration_ext = qalcIsExtensionPresent(NULL, \"ALC_ENUMERATION_EXT\");\n\n\tif(enumeration_ext || enumeration_all_ext)\n\t{\n\t\tchar devicenames[16384] = \"\";\n\t\tconst char *devicelist;\n#ifdef _WIN32\n\t\tconst char *defaultdevice;\n#endif\n\t\tint curlen;\n\n\t\t// get all available devices + the default device name.\n\t\tif(enumeration_all_ext)\n\t\t{\n\t\t\tdevicelist = qalcGetString(NULL, ALC_ALL_DEVICES_SPECIFIER);\n#ifdef _WIN32\n\t\t\tdefaultdevice = qalcGetString(NULL, ALC_DEFAULT_ALL_DEVICES_SPECIFIER);\n#endif\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// We don't have ALC_ENUMERATE_ALL_EXT but normal enumeration.\n\t\t\tdevicelist = qalcGetString(NULL, ALC_DEVICE_SPECIFIER);\n#ifdef _WIN32\n\t\t\tdefaultdevice = qalcGetString(NULL, ALC_DEFAULT_DEVICE_SPECIFIER);\n#endif\n\t\t\tenumeration_ext = qtrue;\n\t\t}\n\n#ifdef _WIN32\n\t\t// check whether the default device is generic hardware. If it is, change to\n\t\t// Generic Software as that one works more reliably with various sound systems.\n\t\t// If it's not, use OpenAL's default selection as we don't want to ignore\n\t\t// native hardware acceleration.\n\t\tif(!device && defaultdevice && !strcmp(defaultdevice, \"Generic Hardware\"))\n\t\t\tdevice = \"Generic Software\";\n#endif\n\n\t\t// dump a list of available devices to a cvar for the user to see.\n\n\t\tif(devicelist)\n\t\t{\n\t\t\twhile((curlen = strlen(devicelist)))\n\t\t\t{\n\t\t\t\tQ_strcat(devicenames, sizeof(devicenames), devicelist);\n\t\t\t\tQ_strcat(devicenames, sizeof(devicenames), \"\\n\");\n\n\t\t\t\tdevicelist += curlen + 1;\n\t\t\t}\n\t\t}\n\n\t\ts_alAvailableDevices = Cvar_Get(\"s_alAvailableDevices\", devicenames, CVAR_ROM | CVAR_NORESTART);\n\t}\n\n\talDevice = qalcOpenDevice(device);\n\tif( !alDevice && device )\n\t{\n\t\tCom_Printf( \"Failed to open OpenAL device '%s', trying default.\\n\", device );\n\t\talDevice = qalcOpenDevice(NULL);\n\t}\n\n\tif( !alDevice )\n\t{\n\t\tQAL_Shutdown( );\n\t\tCom_Printf( \"Failed to open OpenAL device.\\n\" );\n\t\treturn qfalse;\n\t}\n\n\t// Create OpenAL context\n\talContext = qalcCreateContext( alDevice, NULL );\n\tif( !alContext )\n\t{\n\t\tQAL_Shutdown( );\n\t\tqalcCloseDevice( alDevice );\n\t\tCom_Printf( \"Failed to create OpenAL context.\\n\" );\n\t\treturn qfalse;\n\t}\n\tqalcMakeContextCurrent( alContext );\n\n\t// Initialize sources, buffers, music\n\tS_AL_BufferInit( );\n\tS_AL_SrcInit( );\n\n\t// Set up OpenAL parameters (doppler, etc)\n\tqalDistanceModel(AL_INVERSE_DISTANCE_CLAMPED);\n\tqalDopplerFactor( s_alDopplerFactor->value );\n\tqalSpeedOfSound( s_alDopplerSpeed->value );\n\n#ifdef USE_VOIP\n\t// !!! FIXME: some of these alcCaptureOpenDevice() values should be cvars.\n\t// !!! FIXME: add support for capture device enumeration.\n\t// !!! FIXME: add some better error reporting.\n\ts_alCapture = Cvar_Get( \"s_alCapture\", \"1\", CVAR_ARCHIVE | CVAR_LATCH );\n\tif (!s_alCapture->integer)\n\t{\n\t\tCom_Printf(\"OpenAL capture support disabled by user ('+set s_alCapture 1' to enable)\\n\");\n\t}\n#if USE_MUMBLE\n\telse if (cl_useMumble->integer)\n\t{\n\t\tCom_Printf(\"OpenAL capture support disabled for Mumble support\\n\");\n\t}\n#endif\n\telse\n\t{\n#ifdef __APPLE__\n\t\t// !!! FIXME: Apple has a 1.1-compliant OpenAL, which includes\n\t\t// !!! FIXME:  capture support, but they don't list it in the\n\t\t// !!! FIXME:  extension string. We need to check the version string,\n\t\t// !!! FIXME:  then the extension string, but that's too much trouble,\n\t\t// !!! FIXME:  so we'll just check the function pointer for now.\n\t\tif (qalcCaptureOpenDevice == NULL)\n#else\n\t\tif (!qalcIsExtensionPresent(NULL, \"ALC_EXT_capture\"))\n#endif\n\t\t{\n\t\t\tCom_Printf(\"No ALC_EXT_capture support, can't record audio.\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tchar inputdevicenames[16384] = \"\";\n\t\t\tconst char *inputdevicelist;\n\t\t\tconst char *defaultinputdevice;\n\t\t\tint curlen;\n\n\t\t\tcapture_ext = qtrue;\n\n\t\t\t// get all available input devices + the default input device name.\n\t\t\tinputdevicelist = qalcGetString(NULL, ALC_CAPTURE_DEVICE_SPECIFIER);\n\t\t\tdefaultinputdevice = qalcGetString(NULL, ALC_CAPTURE_DEFAULT_DEVICE_SPECIFIER);\n\n\t\t\t// dump a list of available devices to a cvar for the user to see.\n\t\t\tif (inputdevicelist)\n\t\t\t{\n\t\t\t\twhile((curlen = strlen(inputdevicelist)))\n\t\t\t\t{\n\t\t\t\t\tQ_strcat(inputdevicenames, sizeof(inputdevicenames), inputdevicelist);\n\t\t\t\t\tQ_strcat(inputdevicenames, sizeof(inputdevicenames), \"\\n\");\n\t\t\t\t\tinputdevicelist += curlen + 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ts_alAvailableInputDevices = Cvar_Get(\"s_alAvailableInputDevices\", inputdevicenames, CVAR_ROM | CVAR_NORESTART);\n\n\t\t\tCom_Printf(\"OpenAL default capture device is '%s'\\n\", defaultinputdevice ? defaultinputdevice : \"none\");\n\t\t\talCaptureDevice = qalcCaptureOpenDevice(inputdevice, 48000, AL_FORMAT_MONO16, VOIP_MAX_PACKET_SAMPLES*4);\n\t\t\tif( !alCaptureDevice && inputdevice )\n\t\t\t{\n\t\t\t\tCom_Printf( \"Failed to open OpenAL Input device '%s', trying default.\\n\", inputdevice );\n\t\t\t\talCaptureDevice = qalcCaptureOpenDevice(NULL, 48000, AL_FORMAT_MONO16, VOIP_MAX_PACKET_SAMPLES*4);\n\t\t\t}\n\t\t\tCom_Printf( \"OpenAL capture device %s.\\n\",\n\t\t\t\t    (alCaptureDevice == NULL) ? \"failed to open\" : \"opened\");\n\t\t}\n\t}\n#endif\n\n\tsi->Shutdown = S_AL_Shutdown;\n\tsi->StartSound = S_AL_StartSound;\n\tsi->StartLocalSound = S_AL_StartLocalSound;\n\tsi->StartBackgroundTrack = S_AL_StartBackgroundTrack;\n\tsi->StopBackgroundTrack = S_AL_StopBackgroundTrack;\n\tsi->RawSamples = S_AL_RawSamples;\n\tsi->StopAllSounds = S_AL_StopAllSounds;\n\tsi->ClearLoopingSounds = S_AL_ClearLoopingSounds;\n\tsi->AddLoopingSound = S_AL_AddLoopingSound;\n\tsi->AddRealLoopingSound = S_AL_AddRealLoopingSound;\n\tsi->StopLoopingSound = S_AL_StopLoopingSound;\n\tsi->Respatialize = S_AL_Respatialize;\n\tsi->UpdateEntityPosition = S_AL_UpdateEntityPosition;\n\tsi->Update = S_AL_Update;\n\tsi->DisableSounds = S_AL_DisableSounds;\n\tsi->BeginRegistration = S_AL_BeginRegistration;\n\tsi->RegisterSound = S_AL_RegisterSound;\n\tsi->ClearSoundBuffer = S_AL_ClearSoundBuffer;\n\tsi->SoundInfo = S_AL_SoundInfo;\n\tsi->SoundList = S_AL_SoundList;\n\n#ifdef USE_VOIP\n\tsi->StartCapture = S_AL_StartCapture;\n\tsi->AvailableCaptureSamples = S_AL_AvailableCaptureSamples;\n\tsi->Capture = S_AL_Capture;\n\tsi->StopCapture = S_AL_StopCapture;\n\tsi->MasterGain = S_AL_MasterGain;\n#endif\n\n\treturn qtrue;\n#else\n\treturn qfalse;\n#endif\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144772,
    "RELATED_CWE": [
      "CWE-306",
      "CWE-290",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-269"
    ],
    "code": "void Con_Dump_f (void)\n{\n\tint\t\tl, x, i;\n\tshort\t*line;\n\tfileHandle_t\tf;\n\tint\t\tbufferlen;\n\tchar\t*buffer;\n\tchar\tfilename[MAX_QPATH];\n\n\tif (Cmd_Argc() != 2)\n\t{\n\t\tCom_Printf (\"usage: condump <filename>\\n\");\n\t\treturn;\n\t}\n\n\tQ_strncpyz( filename, Cmd_Argv( 1 ), sizeof( filename ) );\n\tCOM_DefaultExtension( filename, sizeof( filename ), \".txt\" );\n\n\tf = FS_FOpenFileWrite( filename );\n\tif (!f)\n\t{\n\t\tCom_Printf (\"ERROR: couldn't open %s.\\n\", filename);\n\t\treturn;\n\t}\n\n\tCom_Printf (\"Dumped console text to %s.\\n\", filename );\n\n\t// skip empty lines\n\tfor (l = con.current - con.totallines + 1 ; l <= con.current ; l++)\n\t{\n\t\tline = con.text + (l%con.totallines)*con.linewidth;\n\t\tfor (x=0 ; x<con.linewidth ; x++)\n\t\t\tif ((line[x] & 0xff) != ' ')\n\t\t\t\tbreak;\n\t\tif (x != con.linewidth)\n\t\t\tbreak;\n\t}\n\n#ifdef _WIN32\n\tbufferlen = con.linewidth + 3 * sizeof ( char );\n#else\n\tbufferlen = con.linewidth + 2 * sizeof ( char );\n#endif\n\n\tbuffer = Hunk_AllocateTempMemory( bufferlen );\n\n\t// write the remaining lines\n\tbuffer[bufferlen-1] = 0;\n\tfor ( ; l <= con.current ; l++)\n\t{\n\t\tline = con.text + (l%con.totallines)*con.linewidth;\n\t\tfor(i=0; i<con.linewidth; i++)\n\t\t\tbuffer[i] = line[i] & 0xff;\n\t\tfor (x=con.linewidth-1 ; x>=0 ; x--)\n\t\t{\n\t\t\tif (buffer[x] == ' ')\n\t\t\t\tbuffer[x] = 0;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n#ifdef _WIN32\n\t\tQ_strcat(buffer, bufferlen, \"\\r\\n\");\n#else\n\t\tQ_strcat(buffer, bufferlen, \"\\n\");\n#endif\n\t\tFS_Write(buffer, strlen(buffer), f);\n\t}\n\n\tHunk_FreeTempMemory( buffer );\n\tFS_FCloseFile( f );\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144775,
    "RELATED_CWE": [
      "CWE-306",
      "CWE-290",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-269"
    ],
    "code": "void Con_Dump_f (void)\n{\n\tint\t\tl, x, i;\n\tshort\t*line;\n\tfileHandle_t\tf;\n\tint\t\tbufferlen;\n\tchar\t*buffer;\n\tchar\tfilename[MAX_QPATH];\n\n\tif (Cmd_Argc() != 2)\n\t{\n\t\tCom_Printf (\"usage: condump <filename>\\n\");\n\t\treturn;\n\t}\n\n\tQ_strncpyz( filename, Cmd_Argv( 1 ), sizeof( filename ) );\n\tCOM_DefaultExtension( filename, sizeof( filename ), \".txt\" );\n\n\tif (!COM_CompareExtension(filename, \".txt\"))\n\t{\n\t\tCom_Printf(\"Con_Dump_f: Only the \\\".txt\\\" extension is supported by this command!\\n\");\n\t\treturn;\n\t}\n\n\tf = FS_FOpenFileWrite( filename );\n\tif (!f)\n\t{\n\t\tCom_Printf (\"ERROR: couldn't open %s.\\n\", filename);\n\t\treturn;\n\t}\n\n\tCom_Printf (\"Dumped console text to %s.\\n\", filename );\n\n\t// skip empty lines\n\tfor (l = con.current - con.totallines + 1 ; l <= con.current ; l++)\n\t{\n\t\tline = con.text + (l%con.totallines)*con.linewidth;\n\t\tfor (x=0 ; x<con.linewidth ; x++)\n\t\t\tif ((line[x] & 0xff) != ' ')\n\t\t\t\tbreak;\n\t\tif (x != con.linewidth)\n\t\t\tbreak;\n\t}\n\n#ifdef _WIN32\n\tbufferlen = con.linewidth + 3 * sizeof ( char );\n#else\n\tbufferlen = con.linewidth + 2 * sizeof ( char );\n#endif\n\n\tbuffer = Hunk_AllocateTempMemory( bufferlen );\n\n\t// write the remaining lines\n\tbuffer[bufferlen-1] = 0;\n\tfor ( ; l <= con.current ; l++)\n\t{\n\t\tline = con.text + (l%con.totallines)*con.linewidth;\n\t\tfor(i=0; i<con.linewidth; i++)\n\t\t\tbuffer[i] = line[i] & 0xff;\n\t\tfor (x=con.linewidth-1 ; x>=0 ; x--)\n\t\t{\n\t\t\tif (buffer[x] == ' ')\n\t\t\t\tbuffer[x] = 0;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n#ifdef _WIN32\n\t\tQ_strcat(buffer, bufferlen, \"\\r\\n\");\n#else\n\t\tQ_strcat(buffer, bufferlen, \"\\n\");\n#endif\n\t\tFS_Write(buffer, strlen(buffer), f);\n\t}\n\n\tHunk_FreeTempMemory( buffer );\n\tFS_FCloseFile( f );\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144776,
    "RELATED_CWE": [
      "CWE-306",
      "CWE-290",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-269"
    ],
    "code": "escapes(cp, tp)\nconst char\t*cp;\nchar *tp;\n{\n    while (*cp) {\n\tint\tcval = 0, meta = 0;\n\n\tif (*cp == '\\\\' && cp[1] && index(\"mM\", cp[1]) && cp[2]) {\n\t\tmeta = 1;\n\t\tcp += 2;\n\t}\n\tif (*cp == '\\\\' && cp[1] && index(\"0123456789xXoO\", cp[1]) && cp[2]) {\n\t    NEARDATA const char hex[] = \"00112233445566778899aAbBcCdDeEfF\";\n\t    const char *dp;\n\t    int dcount = 0;\n\n\t    cp++;\n\t    if (*cp == 'x' || *cp == 'X')\n\t\tfor (++cp; *cp && (dp = index(hex, *cp)) && (dcount++ < 2); cp++)\n\t\t    cval = (cval * 16) + ((int)(dp - hex) / 2);\n\t    else if (*cp == 'o' || *cp == 'O')\n\t\tfor (++cp; *cp && (index(\"01234567\",*cp)) && (dcount++ < 3); cp++)\n\t\t    cval = (cval * 8) + (*cp - '0');\n\t    else\n\t\tfor (; *cp && (index(\"0123456789\",*cp)) && (dcount++ < 3); cp++)\n\t\t    cval = (cval * 10) + (*cp - '0');\n\t} else if (*cp == '\\\\' && cp[1]) {\t/* C-style character escapes */\n\t    switch (*++cp) {\n\t    case '\\\\': cval = '\\\\'; break;\n\t    case 'n': cval = '\\n'; break;\n\t    case 't': cval = '\\t'; break;\n\t    case 'b': cval = '\\b'; break;\n\t    case 'r': cval = '\\r'; break;\n\t    default: cval = *cp;\n\t    }\n\t    cp++;\n\t} else if (*cp == '^' && cp[1]) { /* expand control-character syntax */\n\t    cval = (*++cp & 0x1f);\n\t    cp++;\n\t} else\n\t    cval = *cp++;\n\n\tif (meta)\n\t    cval |= 0x80;\n\t*tp++ = cval;\n    }\n    *tp = '\\0';\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144898,
    "RELATED_CWE": [
      "CWE-306",
      "CWE-290",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-269"
    ],
    "code": "escapes(cp, tp)\nconst char\t*cp;\nchar *tp;\n{\n    static NEARDATA const char\n\toct[] = \"01234567\", dec[] = \"0123456789\",\n\thex[] = \"00112233445566778899aAbBcCdDeEfF\";\n    const char *dp;\n    int cval, meta, dcount;\n\n    while (*cp) {\n\t/* \\M has to be followed by something to do meta conversion,\n\t   otherwise it will just be \\M which ultimately yields 'M' */\n\tmeta = (*cp == '\\\\' && (cp[1] == 'm' || cp[1] == 'M') && cp[2]);\n\tif (meta) cp += 2;\n\n\tcval = dcount = 0; /* for decimal, octal, hexadecimal cases */\n\tif ((*cp != '\\\\' && *cp != '^') || !cp[1]) {\n\t    /* simple character, or nothing left for \\ or ^ to escape */\n\t    cval = *cp++;\n\t} else if (*cp == '^') {\t/* expand control-character syntax */\n\t    cval = (*++cp & 0x1f);\n\t    ++cp;\n\t/* remaining cases are all for backslash and we know cp[1] is not \\0 */\n\t} else if (index(dec, cp[1])) {\n\t    ++cp;\t/* move past backslash to first digit */\n\t    do {\n\t\tcval = (cval * 10) + (*cp - '0');\n\t    } while (*++cp && index(dec, *cp) && ++dcount < 3);\n\t} else if ((cp[1] == 'o' || cp[1] == 'O') &&\n\t\tcp[2] && index(oct, cp[2])) {\n\t    cp += 2;\t/* move past backslash and 'O' */\n\t    do {\n\t\tcval = (cval * 8) + (*cp - '0');\n\t    } while (*++cp && index(oct, *cp) && ++dcount < 3);\n\t} else if ((cp[1] == 'x' || cp[1] == 'X') &&\n\t\tcp[2] && (dp = index(hex, cp[2])) != 0) {\n\t    cp += 2;\t/* move past backslash and 'X' */\n\t    do {\n\t\tcval = (cval * 16) + ((int)(dp - hex) / 2);\n\t    } while (*++cp && (dp = index(hex, *cp)) != 0 && ++dcount < 2);\n\t} else {\t\t\t/* C-style character escapes */\n\t    switch (*++cp) {\n\t    case '\\\\': cval = '\\\\'; break;\n\t    case 'n': cval = '\\n'; break;\n\t    case 't': cval = '\\t'; break;\n\t    case 'b': cval = '\\b'; break;\n\t    case 'r': cval = '\\r'; break;\n\t    default: cval = *cp;\n\t    }\n\t    ++cp;\n\t}\n\n\tif (meta)\n\t    cval |= 0x80;\n\t*tp++ = (char)cval;\n    }\n    *tp = '\\0';\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144899,
    "RELATED_CWE": [
      "CWE-306",
      "CWE-290",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-269"
    ],
    "code": "static void setup_namespaces(struct lo_data *lo, struct fuse_session *se)\n{\n    pid_t child;\n    char template[] = \"virtiofsd-XXXXXX\";\n    char *tmpdir;\n\n    /*\n     * Create a new pid namespace for *child* processes.  We'll have to\n     * fork in order to enter the new pid namespace.  A new mount namespace\n     * is also needed so that we can remount /proc for the new pid\n     * namespace.\n     *\n     * Our UNIX domain sockets have been created.  Now we can move to\n     * an empty network namespace to prevent TCP/IP and other network\n     * activity in case this process is compromised.\n     */\n    if (unshare(CLONE_NEWPID | CLONE_NEWNS | CLONE_NEWNET) != 0) {\n        fuse_log(FUSE_LOG_ERR, \"unshare(CLONE_NEWPID | CLONE_NEWNS): %m\\n\");\n        exit(1);\n    }\n\n    child = fork();\n    if (child < 0) {\n        fuse_log(FUSE_LOG_ERR, \"fork() failed: %m\\n\");\n        exit(1);\n    }\n    if (child > 0) {\n        pid_t waited;\n        int wstatus;\n\n        setup_wait_parent_capabilities();\n\n        /* The parent waits for the child */\n        do {\n            waited = waitpid(child, &wstatus, 0);\n        } while (waited < 0 && errno == EINTR && !se->exited);\n\n        /* We were terminated by a signal, see fuse_signals.c */\n        if (se->exited) {\n            exit(0);\n        }\n\n        if (WIFEXITED(wstatus)) {\n            exit(WEXITSTATUS(wstatus));\n        }\n\n        exit(1);\n    }\n\n    /* Send us SIGTERM when the parent thread terminates, see prctl(2) */\n    prctl(PR_SET_PDEATHSIG, SIGTERM);\n\n    /*\n     * If the mounts have shared propagation then we want to opt out so our\n     * mount changes don't affect the parent mount namespace.\n     */\n    if (mount(NULL, \"/\", NULL, MS_REC | MS_SLAVE, NULL) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"mount(/, MS_REC|MS_SLAVE): %m\\n\");\n        exit(1);\n    }\n\n    /* The child must remount /proc to use the new pid namespace */\n    if (mount(\"proc\", \"/proc\", \"proc\",\n              MS_NODEV | MS_NOEXEC | MS_NOSUID | MS_RELATIME, NULL) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"mount(/proc): %m\\n\");\n        exit(1);\n    }\n\n    tmpdir = mkdtemp(template);\n    if (!tmpdir) {\n        fuse_log(FUSE_LOG_ERR, \"tmpdir(%s): %m\\n\", template);\n        exit(1);\n    }\n\n    if (mount(\"/proc/self/fd\", tmpdir, NULL, MS_BIND, NULL) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"mount(/proc/self/fd, %s, MS_BIND): %m\\n\",\n                 tmpdir);\n        exit(1);\n    }\n\n    /* Now we can get our /proc/self/fd directory file descriptor */\n    lo->proc_self_fd = open(tmpdir, O_PATH);\n    if (lo->proc_self_fd == -1) {\n        fuse_log(FUSE_LOG_ERR, \"open(%s, O_PATH): %m\\n\", tmpdir);\n        exit(1);\n    }\n\n    if (umount2(tmpdir, MNT_DETACH) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"umount2(%s, MNT_DETACH): %m\\n\", tmpdir);\n        exit(1);\n    }\n\n    if (rmdir(tmpdir) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"rmdir(%s): %m\\n\", tmpdir);\n    }\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144954,
    "RELATED_CWE": [
      "CWE-306",
      "CWE-290",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-269"
    ],
    "code": "static void setup_namespaces(struct lo_data *lo, struct fuse_session *se)\n{\n    pid_t child;\n\n    /*\n     * Create a new pid namespace for *child* processes.  We'll have to\n     * fork in order to enter the new pid namespace.  A new mount namespace\n     * is also needed so that we can remount /proc for the new pid\n     * namespace.\n     *\n     * Our UNIX domain sockets have been created.  Now we can move to\n     * an empty network namespace to prevent TCP/IP and other network\n     * activity in case this process is compromised.\n     */\n    if (unshare(CLONE_NEWPID | CLONE_NEWNS | CLONE_NEWNET) != 0) {\n        fuse_log(FUSE_LOG_ERR, \"unshare(CLONE_NEWPID | CLONE_NEWNS): %m\\n\");\n        exit(1);\n    }\n\n    child = fork();\n    if (child < 0) {\n        fuse_log(FUSE_LOG_ERR, \"fork() failed: %m\\n\");\n        exit(1);\n    }\n    if (child > 0) {\n        pid_t waited;\n        int wstatus;\n\n        setup_wait_parent_capabilities();\n\n        /* The parent waits for the child */\n        do {\n            waited = waitpid(child, &wstatus, 0);\n        } while (waited < 0 && errno == EINTR && !se->exited);\n\n        /* We were terminated by a signal, see fuse_signals.c */\n        if (se->exited) {\n            exit(0);\n        }\n\n        if (WIFEXITED(wstatus)) {\n            exit(WEXITSTATUS(wstatus));\n        }\n\n        exit(1);\n    }\n\n    /* Send us SIGTERM when the parent thread terminates, see prctl(2) */\n    prctl(PR_SET_PDEATHSIG, SIGTERM);\n\n    /*\n     * If the mounts have shared propagation then we want to opt out so our\n     * mount changes don't affect the parent mount namespace.\n     */\n    if (mount(NULL, \"/\", NULL, MS_REC | MS_SLAVE, NULL) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"mount(/, MS_REC|MS_SLAVE): %m\\n\");\n        exit(1);\n    }\n\n    /* The child must remount /proc to use the new pid namespace */\n    if (mount(\"proc\", \"/proc\", \"proc\",\n              MS_NODEV | MS_NOEXEC | MS_NOSUID | MS_RELATIME, NULL) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"mount(/proc): %m\\n\");\n        exit(1);\n    }\n\n    /*\n     * We only need /proc/self/fd. Prevent \"..\" from accessing parent\n     * directories of /proc/self/fd by bind-mounting it over /proc. Since / was\n     * previously remounted with MS_REC | MS_SLAVE this mount change only\n     * affects our process.\n     */\n    if (mount(\"/proc/self/fd\", \"/proc\", NULL, MS_BIND, NULL) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"mount(/proc/self/fd, MS_BIND): %m\\n\");\n        exit(1);\n    }\n\n    /* Get the /proc (actually /proc/self/fd, see above) file descriptor */\n    lo->proc_self_fd = open(\"/proc\", O_PATH);\n    if (lo->proc_self_fd == -1) {\n        fuse_log(FUSE_LOG_ERR, \"open(/proc, O_PATH): %m\\n\");\n        exit(1);\n    }\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144955,
    "RELATED_CWE": [
      "CWE-306",
      "CWE-290",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-269"
    ],
    "code": "int unit_patch_contexts(Unit *u) {\n        CGroupContext *cc;\n        ExecContext *ec;\n        unsigned i;\n        int r;\n\n        assert(u);\n\n        /* Patch in the manager defaults into the exec and cgroup\n         * contexts, _after_ the rest of the settings have been\n         * initialized */\n\n        ec = unit_get_exec_context(u);\n        if (ec) {\n                /* This only copies in the ones that need memory */\n                for (i = 0; i < _RLIMIT_MAX; i++)\n                        if (u->manager->rlimit[i] && !ec->rlimit[i]) {\n                                ec->rlimit[i] = newdup(struct rlimit, u->manager->rlimit[i], 1);\n                                if (!ec->rlimit[i])\n                                        return -ENOMEM;\n                        }\n\n                if (MANAGER_IS_USER(u->manager) &&\n                    !ec->working_directory) {\n\n                        r = get_home_dir(&ec->working_directory);\n                        if (r < 0)\n                                return r;\n\n                        /* Allow user services to run, even if the\n                         * home directory is missing */\n                        ec->working_directory_missing_ok = true;\n                }\n\n                if (ec->private_devices)\n                        ec->capability_bounding_set &= ~((UINT64_C(1) << CAP_MKNOD) | (UINT64_C(1) << CAP_SYS_RAWIO));\n\n                if (ec->protect_kernel_modules)\n                        ec->capability_bounding_set &= ~(UINT64_C(1) << CAP_SYS_MODULE);\n\n                if (ec->dynamic_user) {\n                        if (!ec->user) {\n                                r = user_from_unit_name(u, &ec->user);\n                                if (r < 0)\n                                        return r;\n                        }\n\n                        if (!ec->group) {\n                                ec->group = strdup(ec->user);\n                                if (!ec->group)\n                                        return -ENOMEM;\n                        }\n\n                        /* If the dynamic user option is on, let's make sure that the unit can't leave its UID/GID\n                         * around in the file system or on IPC objects. Hence enforce a strict sandbox. */\n\n                        ec->private_tmp = true;\n                        ec->remove_ipc = true;\n                        ec->protect_system = PROTECT_SYSTEM_STRICT;\n                        if (ec->protect_home == PROTECT_HOME_NO)\n                                ec->protect_home = PROTECT_HOME_READ_ONLY;\n                }\n        }\n\n        cc = unit_get_cgroup_context(u);\n        if (cc && ec) {\n\n                if (ec->private_devices &&\n                    cc->device_policy == CGROUP_AUTO)\n                        cc->device_policy = CGROUP_CLOSED;\n\n                if (ec->root_image &&\n                    (cc->device_policy != CGROUP_AUTO || cc->device_allow)) {\n\n                        /* When RootImage= is specified, the following devices are touched. */\n                        r = cgroup_add_device_allow(cc, \"/dev/loop-control\", \"rw\");\n                        if (r < 0)\n                                return r;\n\n                        r = cgroup_add_device_allow(cc, \"block-loop\", \"rwm\");\n                        if (r < 0)\n                                return r;\n\n                        r = cgroup_add_device_allow(cc, \"block-blkext\", \"rwm\");\n                        if (r < 0)\n                                return r;\n                }\n        }\n\n        return 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145914,
    "RELATED_CWE": [
      "CWE-306",
      "CWE-290",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-269"
    ],
    "code": "int unit_patch_contexts(Unit *u) {\n        CGroupContext *cc;\n        ExecContext *ec;\n        unsigned i;\n        int r;\n\n        assert(u);\n\n        /* Patch in the manager defaults into the exec and cgroup\n         * contexts, _after_ the rest of the settings have been\n         * initialized */\n\n        ec = unit_get_exec_context(u);\n        if (ec) {\n                /* This only copies in the ones that need memory */\n                for (i = 0; i < _RLIMIT_MAX; i++)\n                        if (u->manager->rlimit[i] && !ec->rlimit[i]) {\n                                ec->rlimit[i] = newdup(struct rlimit, u->manager->rlimit[i], 1);\n                                if (!ec->rlimit[i])\n                                        return -ENOMEM;\n                        }\n\n                if (MANAGER_IS_USER(u->manager) &&\n                    !ec->working_directory) {\n\n                        r = get_home_dir(&ec->working_directory);\n                        if (r < 0)\n                                return r;\n\n                        /* Allow user services to run, even if the\n                         * home directory is missing */\n                        ec->working_directory_missing_ok = true;\n                }\n\n                if (ec->private_devices)\n                        ec->capability_bounding_set &= ~((UINT64_C(1) << CAP_MKNOD) | (UINT64_C(1) << CAP_SYS_RAWIO));\n\n                if (ec->protect_kernel_modules)\n                        ec->capability_bounding_set &= ~(UINT64_C(1) << CAP_SYS_MODULE);\n\n                if (ec->dynamic_user) {\n                        if (!ec->user) {\n                                r = user_from_unit_name(u, &ec->user);\n                                if (r < 0)\n                                        return r;\n                        }\n\n                        if (!ec->group) {\n                                ec->group = strdup(ec->user);\n                                if (!ec->group)\n                                        return -ENOMEM;\n                        }\n\n                        /* If the dynamic user option is on, let's make sure that the unit can't leave its\n                         * UID/GID around in the file system or on IPC objects. Hence enforce a strict\n                         * sandbox. */\n\n                        ec->private_tmp = true;\n                        ec->remove_ipc = true;\n                        ec->protect_system = PROTECT_SYSTEM_STRICT;\n                        if (ec->protect_home == PROTECT_HOME_NO)\n                                ec->protect_home = PROTECT_HOME_READ_ONLY;\n\n                        /* Make sure this service can neither benefit from SUID/SGID binaries nor create\n                         * them. */\n                        ec->no_new_privileges = true;\n                        ec->restrict_suid_sgid = true;\n                }\n        }\n\n        cc = unit_get_cgroup_context(u);\n        if (cc && ec) {\n\n                if (ec->private_devices &&\n                    cc->device_policy == CGROUP_AUTO)\n                        cc->device_policy = CGROUP_CLOSED;\n\n                if (ec->root_image &&\n                    (cc->device_policy != CGROUP_AUTO || cc->device_allow)) {\n\n                        /* When RootImage= is specified, the following devices are touched. */\n                        r = cgroup_add_device_allow(cc, \"/dev/loop-control\", \"rw\");\n                        if (r < 0)\n                                return r;\n\n                        r = cgroup_add_device_allow(cc, \"block-loop\", \"rwm\");\n                        if (r < 0)\n                                return r;\n\n                        r = cgroup_add_device_allow(cc, \"block-blkext\", \"rwm\");\n                        if (r < 0)\n                                return r;\n                }\n        }\n\n        return 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145915,
    "RELATED_CWE": [
      "CWE-306",
      "CWE-290",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-269"
    ],
    "code": "static int acquire_security_info(sd_bus *bus, const char *name, struct security_info *info, AnalyzeSecurityFlags flags) {\n\n        static const struct bus_properties_map security_map[] = {\n                { \"AmbientCapabilities\",     \"t\",       NULL,                                    offsetof(struct security_info, ambient_capabilities)      },\n                { \"CapabilityBoundingSet\",   \"t\",       NULL,                                    offsetof(struct security_info, capability_bounding_set)   },\n                { \"DefaultDependencies\",     \"b\",       NULL,                                    offsetof(struct security_info, default_dependencies)      },\n                { \"Delegate\",                \"b\",       NULL,                                    offsetof(struct security_info, delegate)                  },\n                { \"DeviceAllow\",             \"a(ss)\",   property_read_device_allow,              0                                                         },\n                { \"DevicePolicy\",            \"s\",       NULL,                                    offsetof(struct security_info, device_policy)             },\n                { \"DynamicUser\",             \"b\",       NULL,                                    offsetof(struct security_info, dynamic_user)              },\n                { \"FragmentPath\",            \"s\",       NULL,                                    offsetof(struct security_info, fragment_path)             },\n                { \"IPAddressAllow\",          \"a(iayu)\", property_read_ip_address_allow,          0                                                         },\n                { \"IPAddressDeny\",           \"a(iayu)\", property_read_ip_address_allow,          0                                                         },\n                { \"Id\",                      \"s\",       NULL,                                    offsetof(struct security_info, id)                        },\n                { \"KeyringMode\",             \"s\",       NULL,                                    offsetof(struct security_info, keyring_mode)              },\n                { \"LoadState\",               \"s\",       NULL,                                    offsetof(struct security_info, load_state)                },\n                { \"LockPersonality\",         \"b\",       NULL,                                    offsetof(struct security_info, lock_personality)          },\n                { \"MemoryDenyWriteExecute\",  \"b\",       NULL,                                    offsetof(struct security_info, memory_deny_write_execute) },\n                { \"NoNewPrivileges\",         \"b\",       NULL,                                    offsetof(struct security_info, no_new_privileges)         },\n                { \"NotifyAccess\",            \"s\",       NULL,                                    offsetof(struct security_info, notify_access)             },\n                { \"PrivateDevices\",          \"b\",       NULL,                                    offsetof(struct security_info, private_devices)           },\n                { \"PrivateMounts\",           \"b\",       NULL,                                    offsetof(struct security_info, private_mounts)            },\n                { \"PrivateNetwork\",          \"b\",       NULL,                                    offsetof(struct security_info, private_network)           },\n                { \"PrivateTmp\",              \"b\",       NULL,                                    offsetof(struct security_info, private_tmp)               },\n                { \"PrivateUsers\",            \"b\",       NULL,                                    offsetof(struct security_info, private_users)             },\n                { \"ProtectControlGroups\",    \"b\",       NULL,                                    offsetof(struct security_info, protect_control_groups)    },\n                { \"ProtectHome\",             \"s\",       NULL,                                    offsetof(struct security_info, protect_home)              },\n                { \"ProtectHostname\",         \"b\",       NULL,                                    offsetof(struct security_info, protect_hostname)          },\n                { \"ProtectKernelModules\",    \"b\",       NULL,                                    offsetof(struct security_info, protect_kernel_modules)    },\n                { \"ProtectKernelTunables\",   \"b\",       NULL,                                    offsetof(struct security_info, protect_kernel_tunables)   },\n                { \"ProtectSystem\",           \"s\",       NULL,                                    offsetof(struct security_info, protect_system)            },\n                { \"RemoveIPC\",               \"b\",       NULL,                                    offsetof(struct security_info, remove_ipc)                },\n                { \"RestrictAddressFamilies\", \"(bas)\",   property_read_restrict_address_families, 0                                                         },\n                { \"RestrictNamespaces\",      \"t\",       NULL,                                    offsetof(struct security_info, restrict_namespaces)       },\n                { \"RestrictRealtime\",        \"b\",       NULL,                                    offsetof(struct security_info, restrict_realtime)         },\n                { \"RootDirectory\",           \"s\",       NULL,                                    offsetof(struct security_info, root_directory)            },\n                { \"RootImage\",               \"s\",       NULL,                                    offsetof(struct security_info, root_image)                },\n                { \"SupplementaryGroups\",     \"as\",      NULL,                                    offsetof(struct security_info, supplementary_groups)      },\n                { \"SystemCallArchitectures\", \"as\",      NULL,                                    offsetof(struct security_info, system_call_architectures) },\n                { \"SystemCallFilter\",        \"(as)\",    property_read_system_call_filter,        0                                                         },\n                { \"Type\",                    \"s\",       NULL,                                    offsetof(struct security_info, type)                      },\n                { \"UMask\",                   \"u\",       NULL,                                    offsetof(struct security_info, _umask)                    },\n                { \"User\",                    \"s\",       NULL,                                    offsetof(struct security_info, user)                      },\n                {}\n        };\n\n        _cleanup_(sd_bus_error_free) sd_bus_error error = SD_BUS_ERROR_NULL;\n        _cleanup_free_ char *path = NULL;\n        int r;\n\n        /* Note: this mangles *info on failure! */\n\n        assert(bus);\n        assert(name);\n        assert(info);\n\n        path = unit_dbus_path_from_name(name);\n        if (!path)\n                return log_oom();\n\n        r = bus_map_all_properties(bus,\n                                   \"org.freedesktop.systemd1\",\n                                   path,\n                                   security_map,\n                                   BUS_MAP_STRDUP|BUS_MAP_BOOLEAN_AS_BOOL,\n                                   &error,\n                                   NULL,\n                                   info);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to get unit properties: %s\", bus_error_message(&error, r));\n\n        if (!streq_ptr(info->load_state, \"loaded\")) {\n\n                if (FLAGS_SET(flags, ANALYZE_SECURITY_ONLY_LOADED))\n                        return -EMEDIUMTYPE;\n\n                if (streq_ptr(info->load_state, \"not-found\"))\n                        log_error(\"Unit %s not found, cannot analyze.\", name);\n                else if (streq_ptr(info->load_state, \"masked\"))\n                        log_error(\"Unit %s is masked, cannot analyze.\", name);\n                else\n                        log_error(\"Unit %s not loaded properly, cannot analyze.\", name);\n\n                return -EINVAL;\n        }\n\n        if (FLAGS_SET(flags, ANALYZE_SECURITY_ONLY_LONG_RUNNING) && streq_ptr(info->type, \"oneshot\"))\n                return -EMEDIUMTYPE;\n\n        if (info->private_devices ||\n            info->private_tmp ||\n            info->protect_control_groups ||\n            info->protect_kernel_tunables ||\n            info->protect_kernel_modules ||\n            !streq_ptr(info->protect_home, \"no\") ||\n            !streq_ptr(info->protect_system, \"no\") ||\n            info->root_image)\n                info->private_mounts = true;\n\n        if (info->protect_kernel_modules)\n                info->capability_bounding_set &= ~(UINT64_C(1) << CAP_SYS_MODULE);\n\n        if (info->private_devices)\n                info->capability_bounding_set &= ~((UINT64_C(1) << CAP_MKNOD) |\n                                                   (UINT64_C(1) << CAP_SYS_RAWIO));\n\n        return 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146168,
    "RELATED_CWE": [
      "CWE-306",
      "CWE-290",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-269"
    ],
    "code": "static int acquire_security_info(sd_bus *bus, const char *name, struct security_info *info, AnalyzeSecurityFlags flags) {\n\n        static const struct bus_properties_map security_map[] = {\n                { \"AmbientCapabilities\",     \"t\",       NULL,                                    offsetof(struct security_info, ambient_capabilities)      },\n                { \"CapabilityBoundingSet\",   \"t\",       NULL,                                    offsetof(struct security_info, capability_bounding_set)   },\n                { \"DefaultDependencies\",     \"b\",       NULL,                                    offsetof(struct security_info, default_dependencies)      },\n                { \"Delegate\",                \"b\",       NULL,                                    offsetof(struct security_info, delegate)                  },\n                { \"DeviceAllow\",             \"a(ss)\",   property_read_device_allow,              0                                                         },\n                { \"DevicePolicy\",            \"s\",       NULL,                                    offsetof(struct security_info, device_policy)             },\n                { \"DynamicUser\",             \"b\",       NULL,                                    offsetof(struct security_info, dynamic_user)              },\n                { \"FragmentPath\",            \"s\",       NULL,                                    offsetof(struct security_info, fragment_path)             },\n                { \"IPAddressAllow\",          \"a(iayu)\", property_read_ip_address_allow,          0                                                         },\n                { \"IPAddressDeny\",           \"a(iayu)\", property_read_ip_address_allow,          0                                                         },\n                { \"Id\",                      \"s\",       NULL,                                    offsetof(struct security_info, id)                        },\n                { \"KeyringMode\",             \"s\",       NULL,                                    offsetof(struct security_info, keyring_mode)              },\n                { \"LoadState\",               \"s\",       NULL,                                    offsetof(struct security_info, load_state)                },\n                { \"LockPersonality\",         \"b\",       NULL,                                    offsetof(struct security_info, lock_personality)          },\n                { \"MemoryDenyWriteExecute\",  \"b\",       NULL,                                    offsetof(struct security_info, memory_deny_write_execute) },\n                { \"NoNewPrivileges\",         \"b\",       NULL,                                    offsetof(struct security_info, no_new_privileges)         },\n                { \"NotifyAccess\",            \"s\",       NULL,                                    offsetof(struct security_info, notify_access)             },\n                { \"PrivateDevices\",          \"b\",       NULL,                                    offsetof(struct security_info, private_devices)           },\n                { \"PrivateMounts\",           \"b\",       NULL,                                    offsetof(struct security_info, private_mounts)            },\n                { \"PrivateNetwork\",          \"b\",       NULL,                                    offsetof(struct security_info, private_network)           },\n                { \"PrivateTmp\",              \"b\",       NULL,                                    offsetof(struct security_info, private_tmp)               },\n                { \"PrivateUsers\",            \"b\",       NULL,                                    offsetof(struct security_info, private_users)             },\n                { \"ProtectControlGroups\",    \"b\",       NULL,                                    offsetof(struct security_info, protect_control_groups)    },\n                { \"ProtectHome\",             \"s\",       NULL,                                    offsetof(struct security_info, protect_home)              },\n                { \"ProtectHostname\",         \"b\",       NULL,                                    offsetof(struct security_info, protect_hostname)          },\n                { \"ProtectKernelModules\",    \"b\",       NULL,                                    offsetof(struct security_info, protect_kernel_modules)    },\n                { \"ProtectKernelTunables\",   \"b\",       NULL,                                    offsetof(struct security_info, protect_kernel_tunables)   },\n                { \"ProtectSystem\",           \"s\",       NULL,                                    offsetof(struct security_info, protect_system)            },\n                { \"RemoveIPC\",               \"b\",       NULL,                                    offsetof(struct security_info, remove_ipc)                },\n                { \"RestrictAddressFamilies\", \"(bas)\",   property_read_restrict_address_families, 0                                                         },\n                { \"RestrictNamespaces\",      \"t\",       NULL,                                    offsetof(struct security_info, restrict_namespaces)       },\n                { \"RestrictRealtime\",        \"b\",       NULL,                                    offsetof(struct security_info, restrict_realtime)         },\n                { \"RestrictSUIDSGID\",        \"b\",       NULL,                                    offsetof(struct security_info, restrict_suid_sgid)        },\n                { \"RootDirectory\",           \"s\",       NULL,                                    offsetof(struct security_info, root_directory)            },\n                { \"RootImage\",               \"s\",       NULL,                                    offsetof(struct security_info, root_image)                },\n                { \"SupplementaryGroups\",     \"as\",      NULL,                                    offsetof(struct security_info, supplementary_groups)      },\n                { \"SystemCallArchitectures\", \"as\",      NULL,                                    offsetof(struct security_info, system_call_architectures) },\n                { \"SystemCallFilter\",        \"(as)\",    property_read_system_call_filter,        0                                                         },\n                { \"Type\",                    \"s\",       NULL,                                    offsetof(struct security_info, type)                      },\n                { \"UMask\",                   \"u\",       NULL,                                    offsetof(struct security_info, _umask)                    },\n                { \"User\",                    \"s\",       NULL,                                    offsetof(struct security_info, user)                      },\n                {}\n        };\n\n        _cleanup_(sd_bus_error_free) sd_bus_error error = SD_BUS_ERROR_NULL;\n        _cleanup_free_ char *path = NULL;\n        int r;\n\n        /* Note: this mangles *info on failure! */\n\n        assert(bus);\n        assert(name);\n        assert(info);\n\n        path = unit_dbus_path_from_name(name);\n        if (!path)\n                return log_oom();\n\n        r = bus_map_all_properties(bus,\n                                   \"org.freedesktop.systemd1\",\n                                   path,\n                                   security_map,\n                                   BUS_MAP_STRDUP|BUS_MAP_BOOLEAN_AS_BOOL,\n                                   &error,\n                                   NULL,\n                                   info);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to get unit properties: %s\", bus_error_message(&error, r));\n\n        if (!streq_ptr(info->load_state, \"loaded\")) {\n\n                if (FLAGS_SET(flags, ANALYZE_SECURITY_ONLY_LOADED))\n                        return -EMEDIUMTYPE;\n\n                if (streq_ptr(info->load_state, \"not-found\"))\n                        log_error(\"Unit %s not found, cannot analyze.\", name);\n                else if (streq_ptr(info->load_state, \"masked\"))\n                        log_error(\"Unit %s is masked, cannot analyze.\", name);\n                else\n                        log_error(\"Unit %s not loaded properly, cannot analyze.\", name);\n\n                return -EINVAL;\n        }\n\n        if (FLAGS_SET(flags, ANALYZE_SECURITY_ONLY_LONG_RUNNING) && streq_ptr(info->type, \"oneshot\"))\n                return -EMEDIUMTYPE;\n\n        if (info->private_devices ||\n            info->private_tmp ||\n            info->protect_control_groups ||\n            info->protect_kernel_tunables ||\n            info->protect_kernel_modules ||\n            !streq_ptr(info->protect_home, \"no\") ||\n            !streq_ptr(info->protect_system, \"no\") ||\n            info->root_image)\n                info->private_mounts = true;\n\n        if (info->protect_kernel_modules)\n                info->capability_bounding_set &= ~(UINT64_C(1) << CAP_SYS_MODULE);\n\n        if (info->private_devices)\n                info->capability_bounding_set &= ~((UINT64_C(1) << CAP_MKNOD) |\n                                                   (UINT64_C(1) << CAP_SYS_RAWIO));\n\n        return 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146169,
    "RELATED_CWE": [
      "CWE-306",
      "CWE-290",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-269"
    ],
    "code": "static int autosieve_createfolder(const char *userid, const struct auth_state *auth_state,\n                                  const char *internalname, int createsievefolder)\n{\n    const char *subf ;\n    int r = 0;\n    int n;\n\n    /* Check if internalname or userid are NULL */\n    if (userid == NULL || internalname == NULL)\n        return IMAP_MAILBOX_NONEXISTENT;\n\n    syslog(LOG_DEBUG, \"autosievefolder: autosieve_createfolder() was called for user %s, folder %s\",\n           userid, internalname);\n\n    if (config_getswitch(IMAPOPT_ANYSIEVEFOLDER)) {\n        createsievefolder = 1;\n    }\n    else if ((subf = config_getstring(IMAPOPT_AUTOCREATE_SIEVE_FOLDERS)) != NULL) {\n        strarray_t *create = strarray_split(subf, SEP, STRARRAY_TRIM);\n\n        for (n = 0; n < create->count; n++) {\n            const char *name = strarray_nth(create, n);\n            char *foldername = mboxname_user_mbox(userid, name);\n\n            if (!strcmp(foldername, internalname))\n                createsievefolder = 1;\n\n            free(foldername);\n            if (createsievefolder) break;\n        }\n\n        strarray_free(create);\n    }\n\n    // unless configured to create it, drop out now\n    if (!createsievefolder) return IMAP_MAILBOX_NONEXISTENT;\n\n    // lock the namespace and check again before trying to create\n    struct mboxlock *namespacelock = mboxname_usernamespacelock(internalname);\n\n    // did we lose the race?\n    r = mboxlist_lookup(internalname, 0, 0);\n    if (r != IMAP_MAILBOX_NONEXISTENT) goto done;\n\n    r = mboxlist_createmailbox(internalname, 0, NULL,\n                               1, userid, auth_state, 0, 0, 0, 1, NULL);\n    if (r) {\n        syslog(LOG_ERR, \"autosievefolder: User %s, folder %s creation failed. %s\",\n               userid, internalname, error_message(r));\n        goto done;\n    }\n\n    mboxlist_changesub(internalname, userid, auth_state, 1, 1, 1);\n    syslog(LOG_DEBUG, \"autosievefolder: User %s, folder %s creation succeeded\",\n           userid, internalname);\n\ndone:\n    mboxname_release(&namespacelock);\n    return r;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146310,
    "RELATED_CWE": [
      "CWE-306",
      "CWE-290",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-269"
    ],
    "code": "static int autosieve_createfolder(const char *userid, const struct auth_state *auth_state,\n                                  const char *internalname, int createsievefolder)\n{\n    const char *subf ;\n    int r = 0;\n    int n;\n\n    /* Check if internalname or userid are NULL */\n    if (userid == NULL || internalname == NULL)\n        return IMAP_MAILBOX_NONEXISTENT;\n\n    syslog(LOG_DEBUG, \"autosievefolder: autosieve_createfolder() was called for user %s, folder %s\",\n           userid, internalname);\n\n    if (config_getswitch(IMAPOPT_ANYSIEVEFOLDER)) {\n        createsievefolder = 1;\n    }\n    else if ((subf = config_getstring(IMAPOPT_AUTOCREATE_SIEVE_FOLDERS)) != NULL) {\n        strarray_t *create = strarray_split(subf, SEP, STRARRAY_TRIM);\n\n        for (n = 0; n < create->count; n++) {\n            const char *name = strarray_nth(create, n);\n            char *foldername = mboxname_user_mbox(userid, name);\n\n            if (!strcmp(foldername, internalname))\n                createsievefolder = 1;\n\n            free(foldername);\n            if (createsievefolder) break;\n        }\n\n        strarray_free(create);\n    }\n\n    // unless configured to create it, drop out now\n    if (!createsievefolder) return IMAP_MAILBOX_NONEXISTENT;\n\n    // lock the namespace and check again before trying to create\n    struct mboxlock *namespacelock = mboxname_usernamespacelock(internalname);\n\n    // did we lose the race?\n    r = mboxlist_lookup(internalname, 0, 0);\n    if (r != IMAP_MAILBOX_NONEXISTENT) goto done;\n\n    r = mboxlist_createmailbox(internalname, 0, NULL,\n                               0, userid, auth_state, 0, 0, 0, 1, NULL);\n    if (r) {\n        syslog(LOG_ERR, \"autosievefolder: User %s, folder %s creation failed. %s\",\n               userid, internalname, error_message(r));\n        goto done;\n    }\n\n    mboxlist_changesub(internalname, userid, auth_state, 1, 1, 1);\n    syslog(LOG_DEBUG, \"autosievefolder: User %s, folder %s creation succeeded\",\n           userid, internalname);\n\ndone:\n    mboxname_release(&namespacelock);\n    return r;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146311,
    "RELATED_CWE": [
      "CWE-306",
      "CWE-290",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-269"
    ],
    "code": "mwifiex_cmd_append_vsie_tlv(struct mwifiex_private *priv,\n\t\t\t    u16 vsie_mask, u8 **buffer)\n{\n\tint id, ret_len = 0;\n\tstruct mwifiex_ie_types_vendor_param_set *vs_param_set;\n\n\tif (!buffer)\n\t\treturn 0;\n\tif (!(*buffer))\n\t\treturn 0;\n\n\t/*\n\t * Traverse through the saved vendor specific IE array and append\n\t * the selected(scan/assoc/adhoc) IE as TLV to the command\n\t */\n\tfor (id = 0; id < MWIFIEX_MAX_VSIE_NUM; id++) {\n\t\tif (priv->vs_ie[id].mask & vsie_mask) {\n\t\t\tvs_param_set =\n\t\t\t\t(struct mwifiex_ie_types_vendor_param_set *)\n\t\t\t\t*buffer;\n\t\t\tvs_param_set->header.type =\n\t\t\t\tcpu_to_le16(TLV_TYPE_PASSTHROUGH);\n\t\t\tvs_param_set->header.len =\n\t\t\t\tcpu_to_le16((((u16) priv->vs_ie[id].ie[1])\n\t\t\t\t& 0x00FF) + 2);\n\t\t\tmemcpy(vs_param_set->ie, priv->vs_ie[id].ie,\n\t\t\t       le16_to_cpu(vs_param_set->header.len));\n\t\t\t*buffer += le16_to_cpu(vs_param_set->header.len) +\n\t\t\t\t   sizeof(struct mwifiex_ie_types_header);\n\t\t\tret_len += le16_to_cpu(vs_param_set->header.len) +\n\t\t\t\t   sizeof(struct mwifiex_ie_types_header);\n\t\t}\n\t}\n\treturn ret_len;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146446,
    "RELATED_CWE": [
      "CWE-306",
      "CWE-290",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-269"
    ],
    "code": "mwifiex_cmd_append_vsie_tlv(struct mwifiex_private *priv,\n\t\t\t    u16 vsie_mask, u8 **buffer)\n{\n\tint id, ret_len = 0;\n\tstruct mwifiex_ie_types_vendor_param_set *vs_param_set;\n\n\tif (!buffer)\n\t\treturn 0;\n\tif (!(*buffer))\n\t\treturn 0;\n\n\t/*\n\t * Traverse through the saved vendor specific IE array and append\n\t * the selected(scan/assoc/adhoc) IE as TLV to the command\n\t */\n\tfor (id = 0; id < MWIFIEX_MAX_VSIE_NUM; id++) {\n\t\tif (priv->vs_ie[id].mask & vsie_mask) {\n\t\t\tvs_param_set =\n\t\t\t\t(struct mwifiex_ie_types_vendor_param_set *)\n\t\t\t\t*buffer;\n\t\t\tvs_param_set->header.type =\n\t\t\t\tcpu_to_le16(TLV_TYPE_PASSTHROUGH);\n\t\t\tvs_param_set->header.len =\n\t\t\t\tcpu_to_le16((((u16) priv->vs_ie[id].ie[1])\n\t\t\t\t& 0x00FF) + 2);\n\t\t\tif (le16_to_cpu(vs_param_set->header.len) >\n\t\t\t\tMWIFIEX_MAX_VSIE_LEN) {\n\t\t\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t\t\t    \"Invalid param length!\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmemcpy(vs_param_set->ie, priv->vs_ie[id].ie,\n\t\t\t       le16_to_cpu(vs_param_set->header.len));\n\t\t\t*buffer += le16_to_cpu(vs_param_set->header.len) +\n\t\t\t\t   sizeof(struct mwifiex_ie_types_header);\n\t\t\tret_len += le16_to_cpu(vs_param_set->header.len) +\n\t\t\t\t   sizeof(struct mwifiex_ie_types_header);\n\t\t}\n\t}\n\treturn ret_len;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146447,
    "RELATED_CWE": [
      "CWE-306",
      "CWE-290",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-269"
    ],
    "code": "int nfsd_setuser(struct svc_rqst *rqstp, struct svc_export *exp)\n{\n\tstruct group_info *rqgi;\n\tstruct group_info *gi;\n\tstruct cred *new;\n\tint i;\n\tint flags = nfsexp_flags(rqstp, exp);\n\n\tvalidate_process_creds();\n\n\t/* discard any old override before preparing the new set */\n\trevert_creds(get_cred(current_real_cred()));\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tnew->fsuid = rqstp->rq_cred.cr_uid;\n\tnew->fsgid = rqstp->rq_cred.cr_gid;\n\n\trqgi = rqstp->rq_cred.cr_group_info;\n\n\tif (flags & NFSEXP_ALLSQUASH) {\n\t\tnew->fsuid = exp->ex_anon_uid;\n\t\tnew->fsgid = exp->ex_anon_gid;\n\t\tgi = groups_alloc(0);\n\t\tif (!gi)\n\t\t\tgoto oom;\n\t} else if (flags & NFSEXP_ROOTSQUASH) {\n\t\tif (uid_eq(new->fsuid, GLOBAL_ROOT_UID))\n\t\t\tnew->fsuid = exp->ex_anon_uid;\n\t\tif (gid_eq(new->fsgid, GLOBAL_ROOT_GID))\n\t\t\tnew->fsgid = exp->ex_anon_gid;\n\n\t\tgi = groups_alloc(rqgi->ngroups);\n\t\tif (!gi)\n\t\t\tgoto oom;\n\n\t\tfor (i = 0; i < rqgi->ngroups; i++) {\n\t\t\tif (gid_eq(GLOBAL_ROOT_GID, rqgi->gid[i]))\n\t\t\t\tgi->gid[i] = exp->ex_anon_gid;\n\t\t\telse\n\t\t\t\tgi->gid[i] = rqgi->gid[i];\n\n\t\t\t/* Each thread allocates its own gi, no race */\n\t\t\tgroups_sort(gi);\n\t\t}\n\t} else {\n\t\tgi = get_group_info(rqgi);\n\t}\n\n\tif (uid_eq(new->fsuid, INVALID_UID))\n\t\tnew->fsuid = exp->ex_anon_uid;\n\tif (gid_eq(new->fsgid, INVALID_GID))\n\t\tnew->fsgid = exp->ex_anon_gid;\n\n\tset_groups(new, gi);\n\tput_group_info(gi);\n\n\tif (!uid_eq(new->fsuid, GLOBAL_ROOT_UID))\n\t\tnew->cap_effective = cap_drop_nfsd_set(new->cap_effective);\n\telse\n\t\tnew->cap_effective = cap_raise_nfsd_set(new->cap_effective,\n\t\t\t\t\t\t\tnew->cap_permitted);\n\tvalidate_process_creds();\n\tput_cred(override_creds(new));\n\tput_cred(new);\n\tvalidate_process_creds();\n\treturn 0;\n\noom:\n\tabort_creds(new);\n\treturn -ENOMEM;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146712,
    "RELATED_CWE": [
      "CWE-306",
      "CWE-290",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-269"
    ],
    "code": "int nfsd_setuser(struct svc_rqst *rqstp, struct svc_export *exp)\n{\n\tstruct group_info *rqgi;\n\tstruct group_info *gi;\n\tstruct cred *new;\n\tint i;\n\tint flags = nfsexp_flags(rqstp, exp);\n\n\tvalidate_process_creds();\n\n\t/* discard any old override before preparing the new set */\n\trevert_creds(get_cred(current_real_cred()));\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tnew->fsuid = rqstp->rq_cred.cr_uid;\n\tnew->fsgid = rqstp->rq_cred.cr_gid;\n\n\trqgi = rqstp->rq_cred.cr_group_info;\n\n\tif (flags & NFSEXP_ALLSQUASH) {\n\t\tnew->fsuid = exp->ex_anon_uid;\n\t\tnew->fsgid = exp->ex_anon_gid;\n\t\tgi = groups_alloc(0);\n\t\tif (!gi)\n\t\t\tgoto oom;\n\t} else if (flags & NFSEXP_ROOTSQUASH) {\n\t\tif (uid_eq(new->fsuid, GLOBAL_ROOT_UID))\n\t\t\tnew->fsuid = exp->ex_anon_uid;\n\t\tif (gid_eq(new->fsgid, GLOBAL_ROOT_GID))\n\t\t\tnew->fsgid = exp->ex_anon_gid;\n\n\t\tgi = groups_alloc(rqgi->ngroups);\n\t\tif (!gi)\n\t\t\tgoto oom;\n\n\t\tfor (i = 0; i < rqgi->ngroups; i++) {\n\t\t\tif (gid_eq(GLOBAL_ROOT_GID, rqgi->gid[i]))\n\t\t\t\tgi->gid[i] = exp->ex_anon_gid;\n\t\t\telse\n\t\t\t\tgi->gid[i] = rqgi->gid[i];\n\t\t}\n\n\t\t/* Each thread allocates its own gi, no race */\n\t\tgroups_sort(gi);\n\t} else {\n\t\tgi = get_group_info(rqgi);\n\t}\n\n\tif (uid_eq(new->fsuid, INVALID_UID))\n\t\tnew->fsuid = exp->ex_anon_uid;\n\tif (gid_eq(new->fsgid, INVALID_GID))\n\t\tnew->fsgid = exp->ex_anon_gid;\n\n\tset_groups(new, gi);\n\tput_group_info(gi);\n\n\tif (!uid_eq(new->fsuid, GLOBAL_ROOT_UID))\n\t\tnew->cap_effective = cap_drop_nfsd_set(new->cap_effective);\n\telse\n\t\tnew->cap_effective = cap_raise_nfsd_set(new->cap_effective,\n\t\t\t\t\t\t\tnew->cap_permitted);\n\tvalidate_process_creds();\n\tput_cred(override_creds(new));\n\tput_cred(new);\n\tvalidate_process_creds();\n\treturn 0;\n\noom:\n\tabort_creds(new);\n\treturn -ENOMEM;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146713,
    "RELATED_CWE": [
      "CWE-306",
      "CWE-290",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-269"
    ],
    "code": "pam_converse (int num_msg, PAM_CONVERSE_ARG2_TYPE **msg,\n  struct pam_response **resp, void *appdata_ptr)\n{\nint sep = 0;\nstruct pam_response *reply;\n\n/* It seems that PAM frees reply[] */\n\nif (  pam_arg_ended\n   || !(reply = malloc(sizeof(struct pam_response) * num_msg)))\n  return PAM_CONV_ERR;\n\nfor (int i = 0; i < num_msg; i++)\n  {\n  uschar *arg;\n  switch (msg[i]->msg_style)\n    {\n    case PAM_PROMPT_ECHO_ON:\n    case PAM_PROMPT_ECHO_OFF:\n      if (!(arg = string_nextinlist(&pam_args, &sep, NULL, 0)))\n\t{\n\targ = US\"\";\n\tpam_arg_ended = TRUE;\n\t}\n      reply[i].resp = CS string_copy_malloc(arg); /* PAM frees resp */\n      reply[i].resp_retcode = PAM_SUCCESS;\n      break;\n\n    case PAM_TEXT_INFO:    /* Just acknowledge messages */\n    case PAM_ERROR_MSG:\n      reply[i].resp_retcode = PAM_SUCCESS;\n      reply[i].resp = NULL;\n      break;\n\n    default:  /* Must be an error of some sort... */\n      free(reply);\n      pam_conv_had_error = TRUE;\n      return PAM_CONV_ERR;\n    }\n  }\n\n*resp = reply;\nreturn PAM_SUCCESS;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147056,
    "RELATED_CWE": [
      "CWE-306",
      "CWE-290",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-269"
    ],
    "code": "pam_converse (int num_msg, PAM_CONVERSE_ARG2_TYPE **msg,\n  struct pam_response **resp, void *appdata_ptr)\n{\nint sep = 0;\nstruct pam_response *reply;\n\n/* It seems that PAM frees reply[] */\n\nif (  pam_arg_ended\n   || !(reply = malloc(sizeof(struct pam_response) * num_msg)))\n  return PAM_CONV_ERR;\n\nfor (int i = 0; i < num_msg; i++)\n  {\n  uschar *arg;\n  switch (msg[i]->msg_style)\n    {\n    case PAM_PROMPT_ECHO_ON:\n    case PAM_PROMPT_ECHO_OFF:\n      if (!(arg = string_nextinlist(&pam_args, &sep, NULL, 0)))\n\t{\n\targ = US\"\";\n\tpam_arg_ended = TRUE;\n\t}\n      reply[i].resp = strdup(CCS arg); /* Use libc malloc, PAM frees resp directly*/\n      reply[i].resp_retcode = PAM_SUCCESS;\n      break;\n\n    case PAM_TEXT_INFO:    /* Just acknowledge messages */\n    case PAM_ERROR_MSG:\n      reply[i].resp_retcode = PAM_SUCCESS;\n      reply[i].resp = NULL;\n      break;\n\n    default:  /* Must be an error of some sort... */\n      free(reply);\n      pam_conv_had_error = TRUE;\n      return PAM_CONV_ERR;\n    }\n  }\n\n*resp = reply;\nreturn PAM_SUCCESS;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147057,
    "RELATED_CWE": [
      "CWE-306",
      "CWE-290",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-269"
    ],
    "code": "configure_zone_ssutable(const cfg_obj_t *zconfig, dns_zone_t *zone,\n\t\t\tconst char *zname)\n{\n\tconst cfg_obj_t *updatepolicy = NULL;\n\tconst cfg_listelt_t *element, *element2;\n\tdns_ssutable_t *table = NULL;\n\tisc_mem_t *mctx = dns_zone_getmctx(zone);\n\tbool autoddns = false;\n\tisc_result_t result;\n\n\t(void)cfg_map_get(zconfig, \"update-policy\", &updatepolicy);\n\n\tif (updatepolicy == NULL) {\n\t\tdns_zone_setssutable(zone, NULL);\n\t\treturn (ISC_R_SUCCESS);\n\t}\n\n\tif (cfg_obj_isstring(updatepolicy) &&\n\t    strcmp(\"local\", cfg_obj_asstring(updatepolicy)) == 0) {\n\t\tautoddns = true;\n\t\tupdatepolicy = NULL;\n\t}\n\n\tresult = dns_ssutable_create(mctx, &table);\n\tif (result != ISC_R_SUCCESS)\n\t\treturn (result);\n\n\tfor (element = cfg_list_first(updatepolicy);\n\t     element != NULL;\n\t     element = cfg_list_next(element))\n\t{\n\t\tconst cfg_obj_t *stmt = cfg_listelt_value(element);\n\t\tconst cfg_obj_t *mode = cfg_tuple_get(stmt, \"mode\");\n\t\tconst cfg_obj_t *identity = cfg_tuple_get(stmt, \"identity\");\n\t\tconst cfg_obj_t *matchtype = cfg_tuple_get(stmt, \"matchtype\");\n\t\tconst cfg_obj_t *dname = cfg_tuple_get(stmt, \"name\");\n\t\tconst cfg_obj_t *typelist = cfg_tuple_get(stmt, \"types\");\n\t\tconst char *str;\n\t\tbool grant = false;\n\t\tbool usezone = false;\n\t\tdns_ssumatchtype_t mtype = DNS_SSUMATCHTYPE_NAME;\n\t\tdns_fixedname_t fname, fident;\n\t\tisc_buffer_t b;\n\t\tdns_rdatatype_t *types;\n\t\tunsigned int i, n;\n\n\t\tstr = cfg_obj_asstring(mode);\n\t\tif (strcasecmp(str, \"grant\") == 0) {\n\t\t\tgrant = true;\n\t\t} else if (strcasecmp(str, \"deny\") == 0) {\n\t\t\tgrant = false;\n\t\t} else {\n\t\t\tINSIST(0);\n\t\t\tISC_UNREACHABLE();\n\t\t}\n\n\t\tstr = cfg_obj_asstring(matchtype);\n\t\tCHECK(dns_ssu_mtypefromstring(str, &mtype));\n\t\tif (mtype == dns_ssumatchtype_subdomain) {\n\t\t\tusezone = true;\n\t\t}\n\n\t\tdns_fixedname_init(&fident);\n\t\tstr = cfg_obj_asstring(identity);\n\t\tisc_buffer_constinit(&b, str, strlen(str));\n\t\tisc_buffer_add(&b, strlen(str));\n\t\tresult = dns_name_fromtext(dns_fixedname_name(&fident), &b,\n\t\t\t\t\t   dns_rootname, 0, NULL);\n\t\tif (result != ISC_R_SUCCESS) {\n\t\t\tcfg_obj_log(identity, ns_g_lctx, ISC_LOG_ERROR,\n\t\t\t\t    \"'%s' is not a valid name\", str);\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tdns_fixedname_init(&fname);\n\t\tif (usezone) {\n\t\t\tresult = dns_name_copy(dns_zone_getorigin(zone),\n\t\t\t\t\t       dns_fixedname_name(&fname),\n\t\t\t\t\t       NULL);\n\t\t\tif (result != ISC_R_SUCCESS) {\n\t\t\t\tcfg_obj_log(identity, ns_g_lctx, ISC_LOG_ERROR,\n\t\t\t\t\t    \"error copying origin: %s\",\n\t\t\t\t\t    isc_result_totext(result));\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t} else {\n\t\t\tstr = cfg_obj_asstring(dname);\n\t\t\tisc_buffer_constinit(&b, str, strlen(str));\n\t\t\tisc_buffer_add(&b, strlen(str));\n\t\t\tresult = dns_name_fromtext(dns_fixedname_name(&fname),\n\t\t\t\t\t\t   &b, dns_rootname, 0, NULL);\n\t\t\tif (result != ISC_R_SUCCESS) {\n\t\t\t\tcfg_obj_log(identity, ns_g_lctx, ISC_LOG_ERROR,\n\t\t\t\t\t    \"'%s' is not a valid name\", str);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\n\t\tn = ns_config_listcount(typelist);\n\t\tif (n == 0)\n\t\t\ttypes = NULL;\n\t\telse {\n\t\t\ttypes = isc_mem_get(mctx, n * sizeof(dns_rdatatype_t));\n\t\t\tif (types == NULL) {\n\t\t\t\tresult = ISC_R_NOMEMORY;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\n\t\ti = 0;\n\t\tfor (element2 = cfg_list_first(typelist);\n\t\t     element2 != NULL;\n\t\t     element2 = cfg_list_next(element2))\n\t\t{\n\t\t\tconst cfg_obj_t *typeobj;\n\t\t\tisc_textregion_t r;\n\n\t\t\tINSIST(i < n);\n\n\t\t\ttypeobj = cfg_listelt_value(element2);\n\t\t\tstr = cfg_obj_asstring(typeobj);\n\t\t\tDE_CONST(str, r.base);\n\t\t\tr.length = strlen(str);\n\n\t\t\tresult = dns_rdatatype_fromtext(&types[i++], &r);\n\t\t\tif (result != ISC_R_SUCCESS) {\n\t\t\t\tcfg_obj_log(identity, ns_g_lctx, ISC_LOG_ERROR,\n\t\t\t\t\t    \"'%s' is not a valid type\", str);\n\t\t\t\tisc_mem_put(mctx, types,\n\t\t\t\t\t    n * sizeof(dns_rdatatype_t));\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\t\tINSIST(i == n);\n\n\t\tresult = dns_ssutable_addrule(table, grant,\n\t\t\t\t\t      dns_fixedname_name(&fident),\n\t\t\t\t\t      mtype,\n\t\t\t\t\t      dns_fixedname_name(&fname),\n\t\t\t\t\t      n, types);\n\t\tif (types != NULL)\n\t\t\tisc_mem_put(mctx, types, n * sizeof(dns_rdatatype_t));\n\t\tif (result != ISC_R_SUCCESS) {\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\t/*\n\t * If \"update-policy local;\" and a session key exists,\n\t * then use the default policy, which is equivalent to:\n\t * update-policy { grant <session-keyname> zonesub any; };\n\t */\n\tif (autoddns) {\n\t\tdns_rdatatype_t any = dns_rdatatype_any;\n\n\t\tif (ns_g_server->session_keyname == NULL) {\n\t\t\tisc_log_write(ns_g_lctx, NS_LOGCATEGORY_GENERAL,\n\t\t\t\t      NS_LOGMODULE_SERVER, ISC_LOG_ERROR,\n\t\t\t\t      \"failed to enable auto DDNS policy \"\n\t\t\t\t      \"for zone %s: session key not found\",\n\t\t\t\t      zname);\n\t\t\tresult = ISC_R_NOTFOUND;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tresult = dns_ssutable_addrule(table, true,\n\t\t\t\t\t      ns_g_server->session_keyname,\n\t\t\t\t\t      DNS_SSUMATCHTYPE_LOCAL,\n\t\t\t\t\t      dns_zone_getorigin(zone),\n\t\t\t\t\t      1, &any);\n\n\t\tif (result != ISC_R_SUCCESS)\n\t\t\tgoto cleanup;\n\t}\n\n\tresult = ISC_R_SUCCESS;\n\tdns_zone_setssutable(zone, table);\n\n cleanup:\n\tdns_ssutable_detach(&table);\n\treturn (result);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147096,
    "RELATED_CWE": [
      "CWE-306",
      "CWE-290",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-269"
    ],
    "code": "configure_zone_ssutable(const cfg_obj_t *zconfig, dns_zone_t *zone,\n\t\t\tconst char *zname)\n{\n\tconst cfg_obj_t *updatepolicy = NULL;\n\tconst cfg_listelt_t *element, *element2;\n\tdns_ssutable_t *table = NULL;\n\tisc_mem_t *mctx = dns_zone_getmctx(zone);\n\tbool autoddns = false;\n\tisc_result_t result;\n\n\t(void)cfg_map_get(zconfig, \"update-policy\", &updatepolicy);\n\n\tif (updatepolicy == NULL) {\n\t\tdns_zone_setssutable(zone, NULL);\n\t\treturn (ISC_R_SUCCESS);\n\t}\n\n\tif (cfg_obj_isstring(updatepolicy) &&\n\t    strcmp(\"local\", cfg_obj_asstring(updatepolicy)) == 0) {\n\t\tautoddns = true;\n\t\tupdatepolicy = NULL;\n\t}\n\n\tresult = dns_ssutable_create(mctx, &table);\n\tif (result != ISC_R_SUCCESS)\n\t\treturn (result);\n\n\tfor (element = cfg_list_first(updatepolicy);\n\t     element != NULL;\n\t     element = cfg_list_next(element))\n\t{\n\t\tconst cfg_obj_t *stmt = cfg_listelt_value(element);\n\t\tconst cfg_obj_t *mode = cfg_tuple_get(stmt, \"mode\");\n\t\tconst cfg_obj_t *identity = cfg_tuple_get(stmt, \"identity\");\n\t\tconst cfg_obj_t *matchtype = cfg_tuple_get(stmt, \"matchtype\");\n\t\tconst cfg_obj_t *dname = cfg_tuple_get(stmt, \"name\");\n\t\tconst cfg_obj_t *typelist = cfg_tuple_get(stmt, \"types\");\n\t\tconst char *str;\n\t\tbool grant = false;\n\t\tbool usezone = false;\n\t\tdns_ssumatchtype_t mtype = DNS_SSUMATCHTYPE_NAME;\n\t\tdns_fixedname_t fname, fident;\n\t\tisc_buffer_t b;\n\t\tdns_rdatatype_t *types;\n\t\tunsigned int i, n;\n\n\t\tstr = cfg_obj_asstring(mode);\n\t\tif (strcasecmp(str, \"grant\") == 0) {\n\t\t\tgrant = true;\n\t\t} else if (strcasecmp(str, \"deny\") == 0) {\n\t\t\tgrant = false;\n\t\t} else {\n\t\t\tINSIST(0);\n\t\t\tISC_UNREACHABLE();\n\t\t}\n\n\t\tstr = cfg_obj_asstring(matchtype);\n\t\tCHECK(dns_ssu_mtypefromstring(str, &mtype));\n\t\tif (mtype == dns_ssumatchtype_subdomain &&\n\t\t    strcasecmp(str, \"zonesub\") == 0) {\n\t\t\tusezone = true;\n\t\t}\n\n\t\tdns_fixedname_init(&fident);\n\t\tstr = cfg_obj_asstring(identity);\n\t\tisc_buffer_constinit(&b, str, strlen(str));\n\t\tisc_buffer_add(&b, strlen(str));\n\t\tresult = dns_name_fromtext(dns_fixedname_name(&fident), &b,\n\t\t\t\t\t   dns_rootname, 0, NULL);\n\t\tif (result != ISC_R_SUCCESS) {\n\t\t\tcfg_obj_log(identity, ns_g_lctx, ISC_LOG_ERROR,\n\t\t\t\t    \"'%s' is not a valid name\", str);\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tdns_fixedname_init(&fname);\n\t\tif (usezone) {\n\t\t\tresult = dns_name_copy(dns_zone_getorigin(zone),\n\t\t\t\t\t       dns_fixedname_name(&fname),\n\t\t\t\t\t       NULL);\n\t\t\tif (result != ISC_R_SUCCESS) {\n\t\t\t\tcfg_obj_log(identity, ns_g_lctx, ISC_LOG_ERROR,\n\t\t\t\t\t    \"error copying origin: %s\",\n\t\t\t\t\t    isc_result_totext(result));\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t} else {\n\t\t\tstr = cfg_obj_asstring(dname);\n\t\t\tisc_buffer_constinit(&b, str, strlen(str));\n\t\t\tisc_buffer_add(&b, strlen(str));\n\t\t\tresult = dns_name_fromtext(dns_fixedname_name(&fname),\n\t\t\t\t\t\t   &b, dns_rootname, 0, NULL);\n\t\t\tif (result != ISC_R_SUCCESS) {\n\t\t\t\tcfg_obj_log(identity, ns_g_lctx, ISC_LOG_ERROR,\n\t\t\t\t\t    \"'%s' is not a valid name\", str);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\n\t\tn = ns_config_listcount(typelist);\n\t\tif (n == 0)\n\t\t\ttypes = NULL;\n\t\telse {\n\t\t\ttypes = isc_mem_get(mctx, n * sizeof(dns_rdatatype_t));\n\t\t\tif (types == NULL) {\n\t\t\t\tresult = ISC_R_NOMEMORY;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\n\t\ti = 0;\n\t\tfor (element2 = cfg_list_first(typelist);\n\t\t     element2 != NULL;\n\t\t     element2 = cfg_list_next(element2))\n\t\t{\n\t\t\tconst cfg_obj_t *typeobj;\n\t\t\tisc_textregion_t r;\n\n\t\t\tINSIST(i < n);\n\n\t\t\ttypeobj = cfg_listelt_value(element2);\n\t\t\tstr = cfg_obj_asstring(typeobj);\n\t\t\tDE_CONST(str, r.base);\n\t\t\tr.length = strlen(str);\n\n\t\t\tresult = dns_rdatatype_fromtext(&types[i++], &r);\n\t\t\tif (result != ISC_R_SUCCESS) {\n\t\t\t\tcfg_obj_log(identity, ns_g_lctx, ISC_LOG_ERROR,\n\t\t\t\t\t    \"'%s' is not a valid type\", str);\n\t\t\t\tisc_mem_put(mctx, types,\n\t\t\t\t\t    n * sizeof(dns_rdatatype_t));\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\t\tINSIST(i == n);\n\n\t\tresult = dns_ssutable_addrule(table, grant,\n\t\t\t\t\t      dns_fixedname_name(&fident),\n\t\t\t\t\t      mtype,\n\t\t\t\t\t      dns_fixedname_name(&fname),\n\t\t\t\t\t      n, types);\n\t\tif (types != NULL)\n\t\t\tisc_mem_put(mctx, types, n * sizeof(dns_rdatatype_t));\n\t\tif (result != ISC_R_SUCCESS) {\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\t/*\n\t * If \"update-policy local;\" and a session key exists,\n\t * then use the default policy, which is equivalent to:\n\t * update-policy { grant <session-keyname> zonesub any; };\n\t */\n\tif (autoddns) {\n\t\tdns_rdatatype_t any = dns_rdatatype_any;\n\n\t\tif (ns_g_server->session_keyname == NULL) {\n\t\t\tisc_log_write(ns_g_lctx, NS_LOGCATEGORY_GENERAL,\n\t\t\t\t      NS_LOGMODULE_SERVER, ISC_LOG_ERROR,\n\t\t\t\t      \"failed to enable auto DDNS policy \"\n\t\t\t\t      \"for zone %s: session key not found\",\n\t\t\t\t      zname);\n\t\t\tresult = ISC_R_NOTFOUND;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tresult = dns_ssutable_addrule(table, true,\n\t\t\t\t\t      ns_g_server->session_keyname,\n\t\t\t\t\t      DNS_SSUMATCHTYPE_LOCAL,\n\t\t\t\t\t      dns_zone_getorigin(zone),\n\t\t\t\t\t      1, &any);\n\n\t\tif (result != ISC_R_SUCCESS)\n\t\t\tgoto cleanup;\n\t}\n\n\tresult = ISC_R_SUCCESS;\n\tdns_zone_setssutable(zone, table);\n\n cleanup:\n\tdns_ssutable_detach(&table);\n\treturn (result);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147097,
    "RELATED_CWE": [
      "CWE-306",
      "CWE-290",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-269"
    ],
    "code": "static int do_change_type(struct nameidata *nd, int flag)\n{\n\tstruct vfsmount *m, *mnt = nd->mnt;\n\tint recurse = flag & MS_REC;\n\tint type = flag & ~MS_REC;\n\n\tif (nd->dentry != nd->mnt->mnt_root)\n\t\treturn -EINVAL;\n\n\tdown_write(&namespace_sem);\n\tspin_lock(&vfsmount_lock);\n\tfor (m = mnt; m; m = (recurse ? next_mnt(m, mnt) : NULL))\n\t\tchange_mnt_propagation(m, type);\n\tspin_unlock(&vfsmount_lock);\n\tup_write(&namespace_sem);\n\treturn 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147516,
    "RELATED_CWE": [
      "CWE-306",
      "CWE-290",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-269"
    ],
    "code": "static int do_change_type(struct nameidata *nd, int flag)\n{\n\tstruct vfsmount *m, *mnt = nd->mnt;\n\tint recurse = flag & MS_REC;\n\tint type = flag & ~MS_REC;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (nd->dentry != nd->mnt->mnt_root)\n\t\treturn -EINVAL;\n\n\tdown_write(&namespace_sem);\n\tspin_lock(&vfsmount_lock);\n\tfor (m = mnt; m; m = (recurse ? next_mnt(m, mnt) : NULL))\n\t\tchange_mnt_propagation(m, type);\n\tspin_unlock(&vfsmount_lock);\n\tup_write(&namespace_sem);\n\treturn 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147517,
    "RELATED_CWE": [
      "CWE-306",
      "CWE-290",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-269"
    ],
    "code": "void Con_Dump_f( void ) {\n\tint l, x, i;\n\tshort   *line;\n\tfileHandle_t f;\n\tint\t\tbufferlen;\n\tchar\t*buffer;\n\tchar\tfilename[MAX_QPATH];\n\n\tif ( Cmd_Argc() != 2 ) {\n\t\tCom_Printf( \"usage: condump <filename>\\n\" );\n\t\treturn;\n\t}\n\n\tQ_strncpyz( filename, Cmd_Argv( 1 ), sizeof( filename ) );\n\tCOM_DefaultExtension( filename, sizeof( filename ), \".txt\" );\n\n\tf = FS_FOpenFileWrite( filename );\n\tif ( !f ) {\n\t\tCom_Printf (\"ERROR: couldn't open %s.\\n\", filename);\n\t\treturn;\n\t}\n\n\tCom_Printf (\"Dumped console text to %s.\\n\", filename );\n\n\t// skip empty lines\n\tfor ( l = con.current - con.totallines + 1 ; l <= con.current ; l++ )\n\t{\n\t\tline = con.text + ( l % con.totallines ) * con.linewidth;\n\t\tfor ( x = 0 ; x < con.linewidth ; x++ )\n\t\t\tif ( ( line[x] & 0xff ) != ' ' ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif ( x != con.linewidth ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n#ifdef _WIN32\n\tbufferlen = con.linewidth + 3 * sizeof ( char );\n#else\n\tbufferlen = con.linewidth + 2 * sizeof ( char );\n#endif\n\n\tbuffer = Hunk_AllocateTempMemory( bufferlen );\n\n\t// write the remaining lines\n\tbuffer[bufferlen-1] = 0;\n\tfor ( ; l <= con.current ; l++ )\n\t{\n\t\tline = con.text + ( l % con.totallines ) * con.linewidth;\n\t\tfor ( i = 0; i < con.linewidth; i++ )\n\t\t\tbuffer[i] = line[i] & 0xff;\n\t\tfor ( x = con.linewidth - 1 ; x >= 0 ; x-- )\n\t\t{\n\t\t\tif ( buffer[x] == ' ' ) {\n\t\t\t\tbuffer[x] = 0;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n#ifdef _WIN32\n\t\tQ_strcat(buffer, bufferlen, \"\\r\\n\");\n#else\n\t\tQ_strcat(buffer, bufferlen, \"\\n\");\n#endif\n\t\tFS_Write( buffer, strlen( buffer ), f );\n\t}\n\n\tHunk_FreeTempMemory( buffer );\n\tFS_FCloseFile( f );\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147854,
    "RELATED_CWE": [
      "CWE-306",
      "CWE-290",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-269"
    ],
    "code": "void Con_Dump_f( void ) {\n\tint l, x, i;\n\tshort   *line;\n\tfileHandle_t f;\n\tint\t\tbufferlen;\n\tchar\t*buffer;\n\tchar\tfilename[MAX_QPATH];\n\n\tif ( Cmd_Argc() != 2 ) {\n\t\tCom_Printf( \"usage: condump <filename>\\n\" );\n\t\treturn;\n\t}\n\n\tQ_strncpyz( filename, Cmd_Argv( 1 ), sizeof( filename ) );\n\tCOM_DefaultExtension( filename, sizeof( filename ), \".txt\" );\n\n\tif (!COM_CompareExtension(filename, \".txt\"))\n\t{\n\t\tCom_Printf(\"Con_Dump_f: Only the \\\".txt\\\" extension is supported by this command!\\n\");\n\t\treturn;\n\t}\n\n\tf = FS_FOpenFileWrite( filename );\n\tif ( !f ) {\n\t\tCom_Printf (\"ERROR: couldn't open %s.\\n\", filename);\n\t\treturn;\n\t}\n\n\tCom_Printf (\"Dumped console text to %s.\\n\", filename );\n\n\t// skip empty lines\n\tfor ( l = con.current - con.totallines + 1 ; l <= con.current ; l++ )\n\t{\n\t\tline = con.text + ( l % con.totallines ) * con.linewidth;\n\t\tfor ( x = 0 ; x < con.linewidth ; x++ )\n\t\t\tif ( ( line[x] & 0xff ) != ' ' ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif ( x != con.linewidth ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n#ifdef _WIN32\n\tbufferlen = con.linewidth + 3 * sizeof ( char );\n#else\n\tbufferlen = con.linewidth + 2 * sizeof ( char );\n#endif\n\n\tbuffer = Hunk_AllocateTempMemory( bufferlen );\n\n\t// write the remaining lines\n\tbuffer[bufferlen-1] = 0;\n\tfor ( ; l <= con.current ; l++ )\n\t{\n\t\tline = con.text + ( l % con.totallines ) * con.linewidth;\n\t\tfor ( i = 0; i < con.linewidth; i++ )\n\t\t\tbuffer[i] = line[i] & 0xff;\n\t\tfor ( x = con.linewidth - 1 ; x >= 0 ; x-- )\n\t\t{\n\t\t\tif ( buffer[x] == ' ' ) {\n\t\t\t\tbuffer[x] = 0;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n#ifdef _WIN32\n\t\tQ_strcat(buffer, bufferlen, \"\\r\\n\");\n#else\n\t\tQ_strcat(buffer, bufferlen, \"\\n\");\n#endif\n\t\tFS_Write( buffer, strlen( buffer ), f );\n\t}\n\n\tHunk_FreeTempMemory( buffer );\n\tFS_FCloseFile( f );\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147855,
    "RELATED_CWE": [
      "CWE-306",
      "CWE-290",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-269"
    ],
    "code": "static int do_mount(const char *mnt, char **typep, mode_t rootmode,\n\t\t    int fd, const char *opts, const char *dev, char **sourcep,\n\t\t    char **mnt_optsp)\n{\n\tint res;\n\tint flags = MS_NOSUID | MS_NODEV;\n\tchar *optbuf;\n\tchar *mnt_opts = NULL;\n\tconst char *s;\n\tchar *d;\n\tchar *fsname = NULL;\n\tchar *subtype = NULL;\n\tchar *source = NULL;\n\tchar *type = NULL;\n\tint blkdev = 0;\n\n\toptbuf = (char *) malloc(strlen(opts) + 128);\n\tif (!optbuf) {\n\t\tfprintf(stderr, \"%s: failed to allocate memory\\n\", progname);\n\t\treturn -1;\n\t}\n\n\tfor (s = opts, d = optbuf; *s;) {\n\t\tunsigned len;\n\t\tconst char *fsname_str = \"fsname=\";\n\t\tconst char *subtype_str = \"subtype=\";\n\t\tbool escape_ok = begins_with(s, fsname_str) ||\n\t\t\t\t begins_with(s, subtype_str);\n\t\tfor (len = 0; s[len]; len++) {\n\t\t\tif (escape_ok && s[len] == '\\\\' && s[len + 1])\n\t\t\t\tlen++;\n\t\t\telse if (s[len] == ',')\n\t\t\t\tbreak;\n\t\t}\n\t\tif (begins_with(s, fsname_str)) {\n\t\t\tif (!get_string_opt(s, len, fsname_str, &fsname))\n\t\t\t\tgoto err;\n\t\t} else if (begins_with(s, subtype_str)) {\n\t\t\tif (!get_string_opt(s, len, subtype_str, &subtype))\n\t\t\t\tgoto err;\n\t\t} else if (opt_eq(s, len, \"blkdev\")) {\n\t\t\tif (getuid() != 0) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"%s: option blkdev is privileged\\n\",\n\t\t\t\t\tprogname);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tblkdev = 1;\n\t\t} else if (opt_eq(s, len, \"auto_unmount\")) {\n\t\t\tauto_unmount = 1;\n\t\t} else if (!begins_with(s, \"fd=\") &&\n\t\t\t   !begins_with(s, \"rootmode=\") &&\n\t\t\t   !begins_with(s, \"user_id=\") &&\n\t\t\t   !begins_with(s, \"group_id=\")) {\n\t\t\tint on;\n\t\t\tint flag;\n\t\t\tint skip_option = 0;\n\t\t\tif (opt_eq(s, len, \"large_read\")) {\n\t\t\t\tstruct utsname utsname;\n\t\t\t\tunsigned kmaj, kmin;\n\t\t\t\tres = uname(&utsname);\n\t\t\t\tif (res == 0 &&\n\t\t\t\t    sscanf(utsname.release, \"%u.%u\",\n\t\t\t\t\t   &kmaj, &kmin) == 2 &&\n\t\t\t\t    (kmaj > 2 || (kmaj == 2 && kmin > 4))) {\n\t\t\t\t\tfprintf(stderr, \"%s: note: 'large_read' mount option is deprecated for %i.%i kernels\\n\", progname, kmaj, kmin);\n\t\t\t\t\tskip_option = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (getuid() != 0 && !user_allow_other &&\n\t\t\t    (opt_eq(s, len, \"allow_other\") ||\n\t\t\t     opt_eq(s, len, \"allow_root\"))) {\n\t\t\t\tfprintf(stderr, \"%s: option %.*s only allowed if 'user_allow_other' is set in %s\\n\", progname, len, s, FUSE_CONF);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tif (!skip_option) {\n\t\t\t\tif (find_mount_flag(s, len, &on, &flag)) {\n\t\t\t\t\tif (on)\n\t\t\t\t\t\tflags |= flag;\n\t\t\t\t\telse\n\t\t\t\t\t\tflags  &= ~flag;\n\t\t\t\t} else {\n\t\t\t\t\tmemcpy(d, s, len);\n\t\t\t\t\td += len;\n\t\t\t\t\t*d++ = ',';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ts += len;\n\t\tif (*s)\n\t\t\ts++;\n\t}\n\t*d = '\\0';\n\tres = get_mnt_opts(flags, optbuf, &mnt_opts);\n\tif (res == -1)\n\t\tgoto err;\n\n\tsprintf(d, \"fd=%i,rootmode=%o,user_id=%u,group_id=%u\",\n\t\tfd, rootmode, getuid(), getgid());\n\n\tsource = malloc((fsname ? strlen(fsname) : 0) +\n\t\t\t(subtype ? strlen(subtype) : 0) + strlen(dev) + 32);\n\n\ttype = malloc((subtype ? strlen(subtype) : 0) + 32);\n\tif (!type || !source) {\n\t\tfprintf(stderr, \"%s: failed to allocate memory\\n\", progname);\n\t\tgoto err;\n\t}\n\n\tif (subtype)\n\t\tsprintf(type, \"%s.%s\", blkdev ? \"fuseblk\" : \"fuse\", subtype);\n\telse\n\t\tstrcpy(type, blkdev ? \"fuseblk\" : \"fuse\");\n\n\tif (fsname)\n\t\tstrcpy(source, fsname);\n\telse\n\t\tstrcpy(source, subtype ? subtype : dev);\n\n\tres = mount_notrunc(source, mnt, type, flags, optbuf);\n\tif (res == -1 && errno == ENODEV && subtype) {\n\t\t/* Probably missing subtype support */\n\t\tstrcpy(type, blkdev ? \"fuseblk\" : \"fuse\");\n\t\tif (fsname) {\n\t\t\tif (!blkdev)\n\t\t\t\tsprintf(source, \"%s#%s\", subtype, fsname);\n\t\t} else {\n\t\t\tstrcpy(source, type);\n\t\t}\n\n\t\tres = mount_notrunc(source, mnt, type, flags, optbuf);\n\t}\n\tif (res == -1 && errno == EINVAL) {\n\t\t/* It could be an old version not supporting group_id */\n\t\tsprintf(d, \"fd=%i,rootmode=%o,user_id=%u\",\n\t\t\tfd, rootmode, getuid());\n\t\tres = mount_notrunc(source, mnt, type, flags, optbuf);\n\t}\n\tif (res == -1) {\n\t\tint errno_save = errno;\n\t\tif (blkdev && errno == ENODEV && !fuse_mnt_check_fuseblk())\n\t\t\tfprintf(stderr, \"%s: 'fuseblk' support missing\\n\",\n\t\t\t\tprogname);\n\t\telse\n\t\t\tfprintf(stderr, \"%s: mount failed: %s\\n\", progname,\n\t\t\t\tstrerror(errno_save));\n\t\tgoto err;\n\t}\n\t*sourcep = source;\n\t*typep = type;\n\t*mnt_optsp = mnt_opts;\n\tfree(fsname);\n\tfree(optbuf);\n\n\treturn 0;\n\nerr:\n\tfree(fsname);\n\tfree(subtype);\n\tfree(source);\n\tfree(type);\n\tfree(mnt_opts);\n\tfree(optbuf);\n\treturn -1;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148296,
    "RELATED_CWE": [
      "CWE-306",
      "CWE-290",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-269"
    ],
    "code": "static int do_mount(const char *mnt, char **typep, mode_t rootmode,\n\t\t    int fd, const char *opts, const char *dev, char **sourcep,\n\t\t    char **mnt_optsp)\n{\n\tint res;\n\tint flags = MS_NOSUID | MS_NODEV;\n\tchar *optbuf;\n\tchar *mnt_opts = NULL;\n\tconst char *s;\n\tchar *d;\n\tchar *fsname = NULL;\n\tchar *subtype = NULL;\n\tchar *source = NULL;\n\tchar *type = NULL;\n\tint blkdev = 0;\n\n\toptbuf = (char *) malloc(strlen(opts) + 128);\n\tif (!optbuf) {\n\t\tfprintf(stderr, \"%s: failed to allocate memory\\n\", progname);\n\t\treturn -1;\n\t}\n\n\tfor (s = opts, d = optbuf; *s;) {\n\t\tunsigned len;\n\t\tconst char *fsname_str = \"fsname=\";\n\t\tconst char *subtype_str = \"subtype=\";\n\t\tbool escape_ok = begins_with(s, fsname_str) ||\n\t\t\t\t begins_with(s, subtype_str);\n\t\tfor (len = 0; s[len]; len++) {\n\t\t\tif (escape_ok && s[len] == '\\\\' && s[len + 1])\n\t\t\t\tlen++;\n\t\t\telse if (s[len] == ',')\n\t\t\t\tbreak;\n\t\t}\n\t\tif (begins_with(s, fsname_str)) {\n\t\t\tif (!get_string_opt(s, len, fsname_str, &fsname))\n\t\t\t\tgoto err;\n\t\t} else if (begins_with(s, subtype_str)) {\n\t\t\tif (!get_string_opt(s, len, subtype_str, &subtype))\n\t\t\t\tgoto err;\n\t\t} else if (opt_eq(s, len, \"blkdev\")) {\n\t\t\tif (getuid() != 0) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"%s: option blkdev is privileged\\n\",\n\t\t\t\t\tprogname);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tblkdev = 1;\n\t\t} else if (opt_eq(s, len, \"auto_unmount\")) {\n\t\t\tauto_unmount = 1;\n\t\t} else if (!begins_with(s, \"fd=\") &&\n\t\t\t   !begins_with(s, \"rootmode=\") &&\n\t\t\t   !begins_with(s, \"user_id=\") &&\n\t\t\t   !begins_with(s, \"group_id=\")) {\n\t\t\tint on;\n\t\t\tint flag;\n\t\t\tint skip_option = 0;\n\t\t\tif (opt_eq(s, len, \"large_read\")) {\n\t\t\t\tstruct utsname utsname;\n\t\t\t\tunsigned kmaj, kmin;\n\t\t\t\tres = uname(&utsname);\n\t\t\t\tif (res == 0 &&\n\t\t\t\t    sscanf(utsname.release, \"%u.%u\",\n\t\t\t\t\t   &kmaj, &kmin) == 2 &&\n\t\t\t\t    (kmaj > 2 || (kmaj == 2 && kmin > 4))) {\n\t\t\t\t\tfprintf(stderr, \"%s: note: 'large_read' mount option is deprecated for %i.%i kernels\\n\", progname, kmaj, kmin);\n\t\t\t\t\tskip_option = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (getuid() != 0 && !user_allow_other &&\n\t\t\t    (opt_eq(s, len, \"allow_other\") ||\n\t\t\t     opt_eq(s, len, \"allow_root\"))) {\n\t\t\t\tfprintf(stderr, \"%s: option %.*s only allowed if 'user_allow_other' is set in %s\\n\", progname, len, s, FUSE_CONF);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tif (!skip_option) {\n\t\t\t\tif (find_mount_flag(s, len, &on, &flag)) {\n\t\t\t\t\tif (on)\n\t\t\t\t\t\tflags |= flag;\n\t\t\t\t\telse\n\t\t\t\t\t\tflags  &= ~flag;\n\t\t\t\t} else if (opt_eq(s, len, \"default_permissions\") ||\n\t\t\t\t\t   opt_eq(s, len, \"allow_other\") ||\n\t\t\t\t\t   begins_with(s, \"max_read=\") ||\n\t\t\t\t\t   begins_with(s, \"blksize=\")) {\n\t\t\t\t\tmemcpy(d, s, len);\n\t\t\t\t\td += len;\n\t\t\t\t\t*d++ = ',';\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"%s: unknown option '%.*s'\\n\", progname, len, s);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ts += len;\n\t\tif (*s)\n\t\t\ts++;\n\t}\n\t*d = '\\0';\n\tres = get_mnt_opts(flags, optbuf, &mnt_opts);\n\tif (res == -1)\n\t\tgoto err;\n\n\tsprintf(d, \"fd=%i,rootmode=%o,user_id=%u,group_id=%u\",\n\t\tfd, rootmode, getuid(), getgid());\n\n\tsource = malloc((fsname ? strlen(fsname) : 0) +\n\t\t\t(subtype ? strlen(subtype) : 0) + strlen(dev) + 32);\n\n\ttype = malloc((subtype ? strlen(subtype) : 0) + 32);\n\tif (!type || !source) {\n\t\tfprintf(stderr, \"%s: failed to allocate memory\\n\", progname);\n\t\tgoto err;\n\t}\n\n\tif (subtype)\n\t\tsprintf(type, \"%s.%s\", blkdev ? \"fuseblk\" : \"fuse\", subtype);\n\telse\n\t\tstrcpy(type, blkdev ? \"fuseblk\" : \"fuse\");\n\n\tif (fsname)\n\t\tstrcpy(source, fsname);\n\telse\n\t\tstrcpy(source, subtype ? subtype : dev);\n\n\tres = mount_notrunc(source, mnt, type, flags, optbuf);\n\tif (res == -1 && errno == ENODEV && subtype) {\n\t\t/* Probably missing subtype support */\n\t\tstrcpy(type, blkdev ? \"fuseblk\" : \"fuse\");\n\t\tif (fsname) {\n\t\t\tif (!blkdev)\n\t\t\t\tsprintf(source, \"%s#%s\", subtype, fsname);\n\t\t} else {\n\t\t\tstrcpy(source, type);\n\t\t}\n\n\t\tres = mount_notrunc(source, mnt, type, flags, optbuf);\n\t}\n\tif (res == -1 && errno == EINVAL) {\n\t\t/* It could be an old version not supporting group_id */\n\t\tsprintf(d, \"fd=%i,rootmode=%o,user_id=%u\",\n\t\t\tfd, rootmode, getuid());\n\t\tres = mount_notrunc(source, mnt, type, flags, optbuf);\n\t}\n\tif (res == -1) {\n\t\tint errno_save = errno;\n\t\tif (blkdev && errno == ENODEV && !fuse_mnt_check_fuseblk())\n\t\t\tfprintf(stderr, \"%s: 'fuseblk' support missing\\n\",\n\t\t\t\tprogname);\n\t\telse\n\t\t\tfprintf(stderr, \"%s: mount failed: %s\\n\", progname,\n\t\t\t\tstrerror(errno_save));\n\t\tgoto err;\n\t}\n\t*sourcep = source;\n\t*typep = type;\n\t*mnt_optsp = mnt_opts;\n\tfree(fsname);\n\tfree(optbuf);\n\n\treturn 0;\n\nerr:\n\tfree(fsname);\n\tfree(subtype);\n\tfree(source);\n\tfree(type);\n\tfree(mnt_opts);\n\tfree(optbuf);\n\treturn -1;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148297,
    "RELATED_CWE": [
      "CWE-306",
      "CWE-290",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-269"
    ],
    "code": "static int uvc_scan_chain_forward(struct uvc_video_chain *chain,\n\tstruct uvc_entity *entity, struct uvc_entity *prev)\n{\n\tstruct uvc_entity *forward;\n\tint found;\n\n\t/* Forward scan */\n\tforward = NULL;\n\tfound = 0;\n\n\twhile (1) {\n\t\tforward = uvc_entity_by_reference(chain->dev, entity->id,\n\t\t\tforward);\n\t\tif (forward == NULL)\n\t\t\tbreak;\n\t\tif (forward == prev)\n\t\t\tcontinue;\n\n\t\tswitch (UVC_ENTITY_TYPE(forward)) {\n\t\tcase UVC_VC_EXTENSION_UNIT:\n\t\t\tif (forward->bNrInPins != 1) {\n\t\t\t\tuvc_trace(UVC_TRACE_DESCR, \"Extension unit %d \"\n\t\t\t\t\t  \"has more than 1 input pin.\\n\",\n\t\t\t\t\t  entity->id);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tlist_add_tail(&forward->chain, &chain->entities);\n\t\t\tif (uvc_trace_param & UVC_TRACE_PROBE) {\n\t\t\t\tif (!found)\n\t\t\t\t\tprintk(KERN_CONT \" (->\");\n\n\t\t\t\tprintk(KERN_CONT \" XU %d\", forward->id);\n\t\t\t\tfound = 1;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase UVC_OTT_VENDOR_SPECIFIC:\n\t\tcase UVC_OTT_DISPLAY:\n\t\tcase UVC_OTT_MEDIA_TRANSPORT_OUTPUT:\n\t\tcase UVC_TT_STREAMING:\n\t\t\tif (UVC_ENTITY_IS_ITERM(forward)) {\n\t\t\t\tuvc_trace(UVC_TRACE_DESCR, \"Unsupported input \"\n\t\t\t\t\t\"terminal %u.\\n\", forward->id);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tlist_add_tail(&forward->chain, &chain->entities);\n\t\t\tif (uvc_trace_param & UVC_TRACE_PROBE) {\n\t\t\t\tif (!found)\n\t\t\t\t\tprintk(KERN_CONT \" (->\");\n\n\t\t\t\tprintk(KERN_CONT \" OT %d\", forward->id);\n\t\t\t\tfound = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (found)\n\t\tprintk(KERN_CONT \")\");\n\n\treturn 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148492,
    "RELATED_CWE": [
      "CWE-306",
      "CWE-290",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-269"
    ],
    "code": "static int uvc_scan_chain_forward(struct uvc_video_chain *chain,\n\tstruct uvc_entity *entity, struct uvc_entity *prev)\n{\n\tstruct uvc_entity *forward;\n\tint found;\n\n\t/* Forward scan */\n\tforward = NULL;\n\tfound = 0;\n\n\twhile (1) {\n\t\tforward = uvc_entity_by_reference(chain->dev, entity->id,\n\t\t\tforward);\n\t\tif (forward == NULL)\n\t\t\tbreak;\n\t\tif (forward == prev)\n\t\t\tcontinue;\n\t\tif (forward->chain.next || forward->chain.prev) {\n\t\t\tuvc_trace(UVC_TRACE_DESCR, \"Found reference to \"\n\t\t\t\t\"entity %d already in chain.\\n\", forward->id);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tswitch (UVC_ENTITY_TYPE(forward)) {\n\t\tcase UVC_VC_EXTENSION_UNIT:\n\t\t\tif (forward->bNrInPins != 1) {\n\t\t\t\tuvc_trace(UVC_TRACE_DESCR, \"Extension unit %d \"\n\t\t\t\t\t  \"has more than 1 input pin.\\n\",\n\t\t\t\t\t  entity->id);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tlist_add_tail(&forward->chain, &chain->entities);\n\t\t\tif (uvc_trace_param & UVC_TRACE_PROBE) {\n\t\t\t\tif (!found)\n\t\t\t\t\tprintk(KERN_CONT \" (->\");\n\n\t\t\t\tprintk(KERN_CONT \" XU %d\", forward->id);\n\t\t\t\tfound = 1;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase UVC_OTT_VENDOR_SPECIFIC:\n\t\tcase UVC_OTT_DISPLAY:\n\t\tcase UVC_OTT_MEDIA_TRANSPORT_OUTPUT:\n\t\tcase UVC_TT_STREAMING:\n\t\t\tif (UVC_ENTITY_IS_ITERM(forward)) {\n\t\t\t\tuvc_trace(UVC_TRACE_DESCR, \"Unsupported input \"\n\t\t\t\t\t\"terminal %u.\\n\", forward->id);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tlist_add_tail(&forward->chain, &chain->entities);\n\t\t\tif (uvc_trace_param & UVC_TRACE_PROBE) {\n\t\t\t\tif (!found)\n\t\t\t\t\tprintk(KERN_CONT \" (->\");\n\n\t\t\t\tprintk(KERN_CONT \" OT %d\", forward->id);\n\t\t\t\tfound = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (found)\n\t\tprintk(KERN_CONT \")\");\n\n\treturn 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148493,
    "RELATED_CWE": [
      "CWE-306",
      "CWE-290",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-269"
    ],
    "code": "static inline void tcp_check_send_head(struct sock *sk, struct sk_buff *skb_unlinked)\n{\n\tif (sk->sk_send_head == skb_unlinked)\n\t\tsk->sk_send_head = NULL;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148500,
    "RELATED_CWE": [
      "CWE-306",
      "CWE-290",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-269"
    ],
    "code": "static inline void tcp_check_send_head(struct sock *sk, struct sk_buff *skb_unlinked)\n{\n\tif (sk->sk_send_head == skb_unlinked)\n\t\tsk->sk_send_head = NULL;\n\tif (tcp_sk(sk)->highest_sack == skb_unlinked)\n\t\ttcp_sk(sk)->highest_sack = NULL;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148501,
    "RELATED_CWE": [
      "CWE-306",
      "CWE-290",
      "CWE-287"
    ]
  }
]