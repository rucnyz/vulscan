[
  {
    "CWE_ID": [
      "CWE-863"
    ],
    "code": "static bool add_line(String &buffer,char *line,char *in_string,\n                     bool *ml_comment, bool truncated)\n{\n  uchar inchar;\n  char buff[80], *pos, *out;\n  COMMANDS *com;\n  bool need_space= 0;\n  bool ss_comment= 0;\n  DBUG_ENTER(\"add_line\");\n\n  if (!line[0] && buffer.is_empty())\n    DBUG_RETURN(0);\n#ifdef HAVE_READLINE\n  if (status.add_to_history && line[0] && not_in_history(line))\n    add_history(line);\n#endif\n  char *end_of_line=line+(uint) strlen(line);\n\n  for (pos=out=line ; (inchar= (uchar) *pos) ; pos++)\n  {\n    if (!preserve_comments)\n    {\n      // Skip spaces at the beginning of a statement\n      if (my_isspace(charset_info,inchar) && (out == line) &&\n          buffer.is_empty())\n        continue;\n    }\n        \n#ifdef USE_MB\n    // Accept multi-byte characters as-is\n    int length;\n    if (use_mb(charset_info) &&\n        (length= my_ismbchar(charset_info, pos, end_of_line)))\n    {\n      if (!*ml_comment || preserve_comments)\n      {\n        while (length--)\n          *out++ = *pos++;\n        pos--;\n      }\n      else\n        pos+= length - 1;\n      continue;\n    }\n#endif\n    if (!*ml_comment && inchar == '\\\\' &&\n        !(*in_string && \n          (mysql.server_status & SERVER_STATUS_NO_BACKSLASH_ESCAPES)))\n    {\n      // Found possbile one character command like \\c\n\n      if (!(inchar = (uchar) *++pos))\n\tbreak;\t\t\t\t// readline adds one '\\'\n      if (*in_string || inchar == 'N')\t// \\N is short for NULL\n      {\t\t\t\t\t// Don't allow commands in string\n\t*out++='\\\\';\n\t*out++= (char) inchar;\n\tcontinue;\n      }\n      if ((com=find_command(NullS,(char) inchar)))\n      {\n        // Flush previously accepted characters\n        if (out != line)\n        {\n          buffer.append(line, (uint) (out-line));\n          out= line;\n        }\n        \n        if ((*com->func)(&buffer,pos-1) > 0)\n          DBUG_RETURN(1);                       // Quit\n        if (com->takes_params)\n        {\n          if (ss_comment)\n          {\n            /*\n              If a client-side macro appears inside a server-side comment,\n              discard all characters in the comment after the macro (that is,\n              until the end of the comment rather than the next delimiter)\n            */\n            for (pos++; *pos && (*pos != '*' || *(pos + 1) != '/'); pos++)\n              ;\n            pos--;\n          }\n          else\n          {\n            for (pos++ ;\n                 *pos && (*pos != *delimiter ||\n                          !is_prefix(pos + 1, delimiter + 1)) ; pos++)\n              ;\t// Remove parameters\n            if (!*pos)\n              pos--;\n            else \n              pos+= delimiter_length - 1; // Point at last delim char\n          }\n        }\n      }\n      else\n      {\n\tsprintf(buff,\"Unknown command '\\\\%c'.\",inchar);\n\tif (put_info(buff,INFO_ERROR) > 0)\n\t  DBUG_RETURN(1);\n\t*out++='\\\\';\n\t*out++=(char) inchar;\n\tcontinue;\n      }\n    }\n    else if (!*ml_comment && !*in_string && is_prefix(pos, delimiter))\n    {\n      // Found a statement. Continue parsing after the delimiter\n      pos+= delimiter_length;\n\n      if (preserve_comments)\n      {\n        while (my_isspace(charset_info, *pos))\n          *out++= *pos++;\n      }\n      // Flush previously accepted characters\n      if (out != line)\n      {\n        buffer.append(line, (uint32) (out-line));\n        out= line;\n      }\n\n      if (preserve_comments && ((*pos == '#') ||\n                                ((*pos == '-') &&\n                                 (pos[1] == '-') &&\n                                 my_isspace(charset_info, pos[2]))))\n      {\n        // Add trailing single line comments to this statement\n        buffer.append(pos);\n        pos+= strlen(pos);\n      }\n\n      pos--;\n\n      if ((com= find_command(buffer.c_ptr(), 0)))\n      {\n          \n        if ((*com->func)(&buffer, buffer.c_ptr()) > 0)\n          DBUG_RETURN(1);                       // Quit \n      }\n      else\n      {\n        if (com_go(&buffer, 0) > 0)             // < 0 is not fatal\n          DBUG_RETURN(1);\n      }\n      buffer.length(0);\n    }\n    else if (!*ml_comment && (!*in_string && (inchar == '#' ||\n                                              (inchar == '-' && pos[1] == '-' &&\n                              /*\n                                The third byte is either whitespace or is the\n                                end of the line -- which would occur only\n                                because of the user sending newline -- which is\n                                itself whitespace and should also match.\n                              */\n\t\t\t      (my_isspace(charset_info,pos[2]) ||\n                               !pos[2])))))\n    {\n      // Flush previously accepted characters\n      if (out != line)\n      {\n        buffer.append(line, (uint32) (out - line));\n        out= line;\n      }\n\n      // comment to end of line\n      if (preserve_comments)\n      {\n        bool started_with_nothing= !buffer.length();\n\n        buffer.append(pos);\n\n        /*\n          A single-line comment by itself gets sent immediately so that\n          client commands (delimiter, status, etc) will be interpreted on\n          the next line.\n        */\n        if (started_with_nothing)\n        {\n          if (com_go(&buffer, 0) > 0)             // < 0 is not fatal\n            DBUG_RETURN(1);\n          buffer.length(0);\n        }\n      }\n\n      break;\n    }\n    else if (!*in_string && inchar == '/' && *(pos+1) == '*' &&\n\t     *(pos+2) != '!')\n    {\n      if (preserve_comments)\n      {\n        *out++= *pos++;                       // copy '/'\n        *out++= *pos;                         // copy '*'\n      }\n      else\n        pos++;\n      *ml_comment= 1;\n      if (out != line)\n      {\n        buffer.append(line,(uint) (out-line));\n        out=line;\n      }\n    }\n    else if (*ml_comment && !ss_comment && inchar == '*' && *(pos + 1) == '/')\n    {\n      if (preserve_comments)\n      {\n        *out++= *pos++;                       // copy '*'\n        *out++= *pos;                         // copy '/'\n      }\n      else\n        pos++;\n      *ml_comment= 0;\n      if (out != line)\n      {\n        buffer.append(line, (uint32) (out - line));\n        out= line;\n      }\n      // Consumed a 2 chars or more, and will add 1 at most,\n      // so using the 'line' buffer to edit data in place is ok.\n      need_space= 1;\n    }      \n    else\n    {\t\t\t\t\t\t// Add found char to buffer\n      if (!*in_string && inchar == '/' && *(pos + 1) == '*' &&\n          *(pos + 2) == '!')\n        ss_comment= 1;\n      else if (!*in_string && ss_comment && inchar == '*' && *(pos + 1) == '/')\n        ss_comment= 0;\n      if (inchar == *in_string)\n\t*in_string= 0;\n      else if (!*ml_comment && !*in_string &&\n\t       (inchar == '\\'' || inchar == '\"' || inchar == '`'))\n\t*in_string= (char) inchar;\n      if (!*ml_comment || preserve_comments)\n      {\n        if (need_space && !my_isspace(charset_info, (char)inchar))\n          *out++= ' ';\n        need_space= 0;\n        *out++= (char) inchar;\n      }\n    }\n  }\n  if (out != line || !buffer.is_empty())\n  {\n    uint length=(uint) (out-line);\n\n    if (!truncated && (length < 9 ||\n                       my_strnncoll (charset_info, (uchar *)line, 9,\n                                     (const uchar *) \"delimiter\", 9) ||\n                       (*in_string || *ml_comment)))\n    {\n      /* \n        Don't add a new line in case there's a DELIMITER command to be \n        added to the glob buffer (e.g. on processing a line like \n        \"<command>;DELIMITER <non-eof>\") : similar to how a new line is \n        not added in the case when the DELIMITER is the first command \n        entered with an empty glob buffer. However, if the delimiter is\n        part of a string or a comment, the new line should be added. (e.g.\n        SELECT '\\ndelimiter\\n';\\n)\n      */\n      *out++='\\n';\n      length++;\n    }\n    if (buffer.length() + length >= buffer.alloced_length())\n      buffer.realloc(buffer.length()+length+IO_SIZE);\n    if ((!*ml_comment || preserve_comments) && buffer.append(line, length))\n      DBUG_RETURN(1);\n  }\n  DBUG_RETURN(0);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145246,
    "RELATED_CWE": [
      "CWE-287",
      "CWE-306",
      "CWE-862"
    ]
  },
  {
    "CWE_ID": [
      "CWE-863"
    ],
    "code": "static bool add_line(String &buffer,char *line,char *in_string,\n                     bool *ml_comment, bool truncated)\n{\n  uchar inchar;\n  char buff[80], *pos, *out;\n  COMMANDS *com;\n  bool need_space= 0;\n  bool ss_comment= 0;\n  DBUG_ENTER(\"add_line\");\n\n  if (!line[0] && buffer.is_empty())\n    DBUG_RETURN(0);\n#ifdef HAVE_READLINE\n  if (status.add_to_history && line[0] && not_in_history(line))\n    add_history(line);\n#endif\n  char *end_of_line=line+(uint) strlen(line);\n\n  for (pos=out=line ; (inchar= (uchar) *pos) ; pos++)\n  {\n    if (!preserve_comments)\n    {\n      // Skip spaces at the beginning of a statement\n      if (my_isspace(charset_info,inchar) && (out == line) &&\n          buffer.is_empty())\n        continue;\n    }\n        \n#ifdef USE_MB\n    // Accept multi-byte characters as-is\n    int length;\n    if (use_mb(charset_info) &&\n        (length= my_ismbchar(charset_info, pos, end_of_line)))\n    {\n      if (!*ml_comment || preserve_comments)\n      {\n        while (length--)\n          *out++ = *pos++;\n        pos--;\n      }\n      else\n        pos+= length - 1;\n      continue;\n    }\n#endif\n    if (!*ml_comment && inchar == '\\\\' &&\n        !(*in_string && \n          (mysql.server_status & SERVER_STATUS_NO_BACKSLASH_ESCAPES)))\n    {\n      // Found possbile one character command like \\c\n\n      if (!(inchar = (uchar) *++pos))\n\tbreak;\t\t\t\t// readline adds one '\\'\n      if (*in_string || inchar == 'N')\t// \\N is short for NULL\n      {\t\t\t\t\t// Don't allow commands in string\n\t*out++='\\\\';\n        if ((inchar == '`') && (*in_string == inchar))\n          pos--;\n        else\n\t  *out++= (char) inchar;\n\tcontinue;\n      }\n      if ((com=find_command(NullS,(char) inchar)))\n      {\n        // Flush previously accepted characters\n        if (out != line)\n        {\n          buffer.append(line, (uint) (out-line));\n          out= line;\n        }\n        \n        if ((*com->func)(&buffer,pos-1) > 0)\n          DBUG_RETURN(1);                       // Quit\n        if (com->takes_params)\n        {\n          if (ss_comment)\n          {\n            /*\n              If a client-side macro appears inside a server-side comment,\n              discard all characters in the comment after the macro (that is,\n              until the end of the comment rather than the next delimiter)\n            */\n            for (pos++; *pos && (*pos != '*' || *(pos + 1) != '/'); pos++)\n              ;\n            pos--;\n          }\n          else\n          {\n            for (pos++ ;\n                 *pos && (*pos != *delimiter ||\n                          !is_prefix(pos + 1, delimiter + 1)) ; pos++)\n              ;\t// Remove parameters\n            if (!*pos)\n              pos--;\n            else \n              pos+= delimiter_length - 1; // Point at last delim char\n          }\n        }\n      }\n      else\n      {\n\tsprintf(buff,\"Unknown command '\\\\%c'.\",inchar);\n\tif (put_info(buff,INFO_ERROR) > 0)\n\t  DBUG_RETURN(1);\n\t*out++='\\\\';\n\t*out++=(char) inchar;\n\tcontinue;\n      }\n    }\n    else if (!*ml_comment && !*in_string && is_prefix(pos, delimiter))\n    {\n      // Found a statement. Continue parsing after the delimiter\n      pos+= delimiter_length;\n\n      if (preserve_comments)\n      {\n        while (my_isspace(charset_info, *pos))\n          *out++= *pos++;\n      }\n      // Flush previously accepted characters\n      if (out != line)\n      {\n        buffer.append(line, (uint32) (out-line));\n        out= line;\n      }\n\n      if (preserve_comments && ((*pos == '#') ||\n                                ((*pos == '-') &&\n                                 (pos[1] == '-') &&\n                                 my_isspace(charset_info, pos[2]))))\n      {\n        // Add trailing single line comments to this statement\n        buffer.append(pos);\n        pos+= strlen(pos);\n      }\n\n      pos--;\n\n      if ((com= find_command(buffer.c_ptr(), 0)))\n      {\n          \n        if ((*com->func)(&buffer, buffer.c_ptr()) > 0)\n          DBUG_RETURN(1);                       // Quit \n      }\n      else\n      {\n        if (com_go(&buffer, 0) > 0)             // < 0 is not fatal\n          DBUG_RETURN(1);\n      }\n      buffer.length(0);\n    }\n    else if (!*ml_comment && (!*in_string && (inchar == '#' ||\n                                              (inchar == '-' && pos[1] == '-' &&\n                              /*\n                                The third byte is either whitespace or is the\n                                end of the line -- which would occur only\n                                because of the user sending newline -- which is\n                                itself whitespace and should also match.\n                              */\n\t\t\t      (my_isspace(charset_info,pos[2]) ||\n                               !pos[2])))))\n    {\n      // Flush previously accepted characters\n      if (out != line)\n      {\n        buffer.append(line, (uint32) (out - line));\n        out= line;\n      }\n\n      // comment to end of line\n      if (preserve_comments)\n      {\n        bool started_with_nothing= !buffer.length();\n\n        buffer.append(pos);\n\n        /*\n          A single-line comment by itself gets sent immediately so that\n          client commands (delimiter, status, etc) will be interpreted on\n          the next line.\n        */\n        if (started_with_nothing)\n        {\n          if (com_go(&buffer, 0) > 0)             // < 0 is not fatal\n            DBUG_RETURN(1);\n          buffer.length(0);\n        }\n      }\n\n      break;\n    }\n    else if (!*in_string && inchar == '/' && *(pos+1) == '*' &&\n\t     *(pos+2) != '!')\n    {\n      if (preserve_comments)\n      {\n        *out++= *pos++;                       // copy '/'\n        *out++= *pos;                         // copy '*'\n      }\n      else\n        pos++;\n      *ml_comment= 1;\n      if (out != line)\n      {\n        buffer.append(line,(uint) (out-line));\n        out=line;\n      }\n    }\n    else if (*ml_comment && !ss_comment && inchar == '*' && *(pos + 1) == '/')\n    {\n      if (preserve_comments)\n      {\n        *out++= *pos++;                       // copy '*'\n        *out++= *pos;                         // copy '/'\n      }\n      else\n        pos++;\n      *ml_comment= 0;\n      if (out != line)\n      {\n        buffer.append(line, (uint32) (out - line));\n        out= line;\n      }\n      // Consumed a 2 chars or more, and will add 1 at most,\n      // so using the 'line' buffer to edit data in place is ok.\n      need_space= 1;\n    }      \n    else\n    {\t\t\t\t\t\t// Add found char to buffer\n      if (!*in_string && inchar == '/' && *(pos + 1) == '*' &&\n          *(pos + 2) == '!')\n        ss_comment= 1;\n      else if (!*in_string && ss_comment && inchar == '*' && *(pos + 1) == '/')\n        ss_comment= 0;\n      if (inchar == *in_string)\n\t*in_string= 0;\n      else if (!*ml_comment && !*in_string &&\n\t       (inchar == '\\'' || inchar == '\"' || inchar == '`'))\n\t*in_string= (char) inchar;\n      if (!*ml_comment || preserve_comments)\n      {\n        if (need_space && !my_isspace(charset_info, (char)inchar))\n          *out++= ' ';\n        need_space= 0;\n        *out++= (char) inchar;\n      }\n    }\n  }\n  if (out != line || !buffer.is_empty())\n  {\n    uint length=(uint) (out-line);\n\n    if (!truncated && (length < 9 ||\n                       my_strnncoll (charset_info, (uchar *)line, 9,\n                                     (const uchar *) \"delimiter\", 9) ||\n                       (*in_string || *ml_comment)))\n    {\n      /* \n        Don't add a new line in case there's a DELIMITER command to be \n        added to the glob buffer (e.g. on processing a line like \n        \"<command>;DELIMITER <non-eof>\") : similar to how a new line is \n        not added in the case when the DELIMITER is the first command \n        entered with an empty glob buffer. However, if the delimiter is\n        part of a string or a comment, the new line should be added. (e.g.\n        SELECT '\\ndelimiter\\n';\\n)\n      */\n      *out++='\\n';\n      length++;\n    }\n    if (buffer.length() + length >= buffer.alloced_length())\n      buffer.realloc(buffer.length()+length+IO_SIZE);\n    if ((!*ml_comment || preserve_comments) && buffer.append(line, length))\n      DBUG_RETURN(1);\n  }\n  DBUG_RETURN(0);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145247,
    "RELATED_CWE": [
      "CWE-287",
      "CWE-306",
      "CWE-862"
    ]
  },
  {
    "CWE_ID": [
      "CWE-863"
    ],
    "code": "static inline bool nested_vmx_prepare_msr_bitmap(struct kvm_vcpu *vcpu,\n\t\t\t\t\t\t struct vmcs12 *vmcs12)\n{\n\tint msr;\n\tstruct page *page;\n\tunsigned long *msr_bitmap_l1;\n\tunsigned long *msr_bitmap_l0 = to_vmx(vcpu)->nested.vmcs02.msr_bitmap;\n\t/*\n\t * pred_cmd & spec_ctrl are trying to verify two things:\n\t *\n\t * 1. L0 gave a permission to L1 to actually passthrough the MSR. This\n\t *    ensures that we do not accidentally generate an L02 MSR bitmap\n\t *    from the L12 MSR bitmap that is too permissive.\n\t * 2. That L1 or L2s have actually used the MSR. This avoids\n\t *    unnecessarily merging of the bitmap if the MSR is unused. This\n\t *    works properly because we only update the L01 MSR bitmap lazily.\n\t *    So even if L0 should pass L1 these MSRs, the L01 bitmap is only\n\t *    updated to reflect this when L1 (or its L2s) actually write to\n\t *    the MSR.\n\t */\n\tbool pred_cmd = !msr_write_intercepted_l01(vcpu, MSR_IA32_PRED_CMD);\n\tbool spec_ctrl = !msr_write_intercepted_l01(vcpu, MSR_IA32_SPEC_CTRL);\n\n\t/* Nothing to do if the MSR bitmap is not in use.  */\n\tif (!cpu_has_vmx_msr_bitmap() ||\n\t    !nested_cpu_has(vmcs12, CPU_BASED_USE_MSR_BITMAPS))\n\t\treturn false;\n\n\tif (!nested_cpu_has_virt_x2apic_mode(vmcs12) &&\n\t    !pred_cmd && !spec_ctrl)\n\t\treturn false;\n\n\tpage = kvm_vcpu_gpa_to_page(vcpu, vmcs12->msr_bitmap);\n\tif (is_error_page(page))\n\t\treturn false;\n\n\tmsr_bitmap_l1 = (unsigned long *)kmap(page);\n\n\t/*\n\t * To keep the control flow simple, pay eight 8-byte writes (sixteen\n\t * 4-byte writes on 32-bit systems) up front to enable intercepts for\n\t * the x2APIC MSR range and selectively disable them below.\n\t */\n\tenable_x2apic_msr_intercepts(msr_bitmap_l0);\n\n\tif (nested_cpu_has_virt_x2apic_mode(vmcs12)) {\n\t\tif (nested_cpu_has_apic_reg_virt(vmcs12)) {\n\t\t\t/*\n\t\t\t * L0 need not intercept reads for MSRs between 0x800\n\t\t\t * and 0x8ff, it just lets the processor take the value\n\t\t\t * from the virtual-APIC page; take those 256 bits\n\t\t\t * directly from the L1 bitmap.\n\t\t\t */\n\t\t\tfor (msr = 0x800; msr <= 0x8ff; msr += BITS_PER_LONG) {\n\t\t\t\tunsigned word = msr / BITS_PER_LONG;\n\n\t\t\t\tmsr_bitmap_l0[word] = msr_bitmap_l1[word];\n\t\t\t}\n\t\t}\n\n\t\tnested_vmx_disable_intercept_for_msr(\n\t\t\tmsr_bitmap_l1, msr_bitmap_l0,\n\t\t\tX2APIC_MSR(APIC_TASKPRI),\n\t\t\tMSR_TYPE_W);\n\n\t\tif (nested_cpu_has_vid(vmcs12)) {\n\t\t\tnested_vmx_disable_intercept_for_msr(\n\t\t\t\tmsr_bitmap_l1, msr_bitmap_l0,\n\t\t\t\tX2APIC_MSR(APIC_EOI),\n\t\t\t\tMSR_TYPE_W);\n\t\t\tnested_vmx_disable_intercept_for_msr(\n\t\t\t\tmsr_bitmap_l1, msr_bitmap_l0,\n\t\t\t\tX2APIC_MSR(APIC_SELF_IPI),\n\t\t\t\tMSR_TYPE_W);\n\t\t}\n\t}\n\n\tif (spec_ctrl)\n\t\tnested_vmx_disable_intercept_for_msr(\n\t\t\t\t\tmsr_bitmap_l1, msr_bitmap_l0,\n\t\t\t\t\tMSR_IA32_SPEC_CTRL,\n\t\t\t\t\tMSR_TYPE_R | MSR_TYPE_W);\n\n\tif (pred_cmd)\n\t\tnested_vmx_disable_intercept_for_msr(\n\t\t\t\t\tmsr_bitmap_l1, msr_bitmap_l0,\n\t\t\t\t\tMSR_IA32_PRED_CMD,\n\t\t\t\t\tMSR_TYPE_W);\n\n\tkunmap(page);\n\tkvm_release_page_clean(page);\n\n\treturn true;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145610,
    "RELATED_CWE": [
      "CWE-287",
      "CWE-306",
      "CWE-862"
    ]
  },
  {
    "CWE_ID": [
      "CWE-863"
    ],
    "code": "static inline bool nested_vmx_prepare_msr_bitmap(struct kvm_vcpu *vcpu,\n\t\t\t\t\t\t struct vmcs12 *vmcs12)\n{\n\tint msr;\n\tstruct page *page;\n\tunsigned long *msr_bitmap_l1;\n\tunsigned long *msr_bitmap_l0 = to_vmx(vcpu)->nested.vmcs02.msr_bitmap;\n\t/*\n\t * pred_cmd & spec_ctrl are trying to verify two things:\n\t *\n\t * 1. L0 gave a permission to L1 to actually passthrough the MSR. This\n\t *    ensures that we do not accidentally generate an L02 MSR bitmap\n\t *    from the L12 MSR bitmap that is too permissive.\n\t * 2. That L1 or L2s have actually used the MSR. This avoids\n\t *    unnecessarily merging of the bitmap if the MSR is unused. This\n\t *    works properly because we only update the L01 MSR bitmap lazily.\n\t *    So even if L0 should pass L1 these MSRs, the L01 bitmap is only\n\t *    updated to reflect this when L1 (or its L2s) actually write to\n\t *    the MSR.\n\t */\n\tbool pred_cmd = !msr_write_intercepted_l01(vcpu, MSR_IA32_PRED_CMD);\n\tbool spec_ctrl = !msr_write_intercepted_l01(vcpu, MSR_IA32_SPEC_CTRL);\n\n\t/* Nothing to do if the MSR bitmap is not in use.  */\n\tif (!cpu_has_vmx_msr_bitmap() ||\n\t    !nested_cpu_has(vmcs12, CPU_BASED_USE_MSR_BITMAPS))\n\t\treturn false;\n\n\tif (!nested_cpu_has_virt_x2apic_mode(vmcs12) &&\n\t    !pred_cmd && !spec_ctrl)\n\t\treturn false;\n\n\tpage = kvm_vcpu_gpa_to_page(vcpu, vmcs12->msr_bitmap);\n\tif (is_error_page(page))\n\t\treturn false;\n\n\tmsr_bitmap_l1 = (unsigned long *)kmap(page);\n\n\t/*\n\t * To keep the control flow simple, pay eight 8-byte writes (sixteen\n\t * 4-byte writes on 32-bit systems) up front to enable intercepts for\n\t * the x2APIC MSR range and selectively disable them below.\n\t */\n\tenable_x2apic_msr_intercepts(msr_bitmap_l0);\n\n\tif (nested_cpu_has_virt_x2apic_mode(vmcs12)) {\n\t\tif (nested_cpu_has_apic_reg_virt(vmcs12)) {\n\t\t\t/*\n\t\t\t * L0 need not intercept reads for MSRs between 0x800\n\t\t\t * and 0x8ff, it just lets the processor take the value\n\t\t\t * from the virtual-APIC page; take those 256 bits\n\t\t\t * directly from the L1 bitmap.\n\t\t\t */\n\t\t\tfor (msr = 0x800; msr <= 0x8ff; msr += BITS_PER_LONG) {\n\t\t\t\tunsigned word = msr / BITS_PER_LONG;\n\n\t\t\t\tmsr_bitmap_l0[word] = msr_bitmap_l1[word];\n\t\t\t}\n\t\t}\n\n\t\tnested_vmx_disable_intercept_for_msr(\n\t\t\tmsr_bitmap_l1, msr_bitmap_l0,\n\t\t\tX2APIC_MSR(APIC_TASKPRI),\n\t\t\tMSR_TYPE_R | MSR_TYPE_W);\n\n\t\tif (nested_cpu_has_vid(vmcs12)) {\n\t\t\tnested_vmx_disable_intercept_for_msr(\n\t\t\t\tmsr_bitmap_l1, msr_bitmap_l0,\n\t\t\t\tX2APIC_MSR(APIC_EOI),\n\t\t\t\tMSR_TYPE_W);\n\t\t\tnested_vmx_disable_intercept_for_msr(\n\t\t\t\tmsr_bitmap_l1, msr_bitmap_l0,\n\t\t\t\tX2APIC_MSR(APIC_SELF_IPI),\n\t\t\t\tMSR_TYPE_W);\n\t\t}\n\t}\n\n\tif (spec_ctrl)\n\t\tnested_vmx_disable_intercept_for_msr(\n\t\t\t\t\tmsr_bitmap_l1, msr_bitmap_l0,\n\t\t\t\t\tMSR_IA32_SPEC_CTRL,\n\t\t\t\t\tMSR_TYPE_R | MSR_TYPE_W);\n\n\tif (pred_cmd)\n\t\tnested_vmx_disable_intercept_for_msr(\n\t\t\t\t\tmsr_bitmap_l1, msr_bitmap_l0,\n\t\t\t\t\tMSR_IA32_PRED_CMD,\n\t\t\t\t\tMSR_TYPE_W);\n\n\tkunmap(page);\n\tkvm_release_page_clean(page);\n\n\treturn true;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145611,
    "RELATED_CWE": [
      "CWE-287",
      "CWE-306",
      "CWE-862"
    ]
  },
  {
    "CWE_ID": [
      "CWE-863"
    ],
    "code": "ddxProcessArgument(int argc, char **argv, int i)\n{\n#define CHECK_FOR_REQUIRED_ARGUMENT() \\\n    if (((i + 1) >= argc) || (!argv[i + 1])) { \t\t\t\t\\\n      ErrorF(\"Required argument to %s not specified\\n\", argv[i]); \t\\\n      UseMsg(); \t\t\t\t\t\t\t\\\n      FatalError(\"Required argument to %s not specified\\n\", argv[i]);\t\\\n    }\n\n    /* First the options that are not allowed with elevated privileges */\n    if (!strcmp(argv[i], \"-modulepath\")) {\n        CHECK_FOR_REQUIRED_ARGUMENT();\n        xf86CheckPrivs(argv[i], argv[i + 1]);\n        xf86ModulePath = argv[i + 1];\n        xf86ModPathFrom = X_CMDLINE;\n        return 2;\n    }\n    if (!strcmp(argv[i], \"-logfile\")) {\n        CHECK_FOR_REQUIRED_ARGUMENT();\n        xf86CheckPrivs(argv[i], argv[i + 1]);\n        xf86LogFile = argv[i + 1];\n        xf86LogFileFrom = X_CMDLINE;\n        return 2;\n    }\n    if (!strcmp(argv[i], \"-config\") || !strcmp(argv[i], \"-xf86config\")) {\n        CHECK_FOR_REQUIRED_ARGUMENT();\n        xf86CheckPrivs(argv[i], argv[i + 1]);\n        xf86ConfigFile = argv[i + 1];\n        return 2;\n    }\n    if (!strcmp(argv[i], \"-configdir\")) {\n        CHECK_FOR_REQUIRED_ARGUMENT();\n        xf86CheckPrivs(argv[i], argv[i + 1]);\n        xf86ConfigDir = argv[i + 1];\n        return 2;\n    }\n    if (!strcmp(argv[i], \"-flipPixels\")) {\n        xf86FlipPixels = TRUE;\n        return 1;\n    }\n#ifdef XF86VIDMODE\n    if (!strcmp(argv[i], \"-disableVidMode\")) {\n        xf86VidModeDisabled = TRUE;\n        return 1;\n    }\n    if (!strcmp(argv[i], \"-allowNonLocalXvidtune\")) {\n        xf86VidModeAllowNonLocal = TRUE;\n        return 1;\n    }\n#endif\n    if (!strcmp(argv[i], \"-allowMouseOpenFail\")) {\n        xf86AllowMouseOpenFail = TRUE;\n        return 1;\n    }\n    if (!strcmp(argv[i], \"-ignoreABI\")) {\n        LoaderSetOptions(LDR_OPT_ABI_MISMATCH_NONFATAL);\n        return 1;\n    }\n    if (!strcmp(argv[i], \"-verbose\")) {\n        if (++i < argc && argv[i]) {\n            char *end;\n            long val;\n\n            val = strtol(argv[i], &end, 0);\n            if (*end == '\\0') {\n                xf86SetVerbosity(val);\n                return 2;\n            }\n        }\n        xf86SetVerbosity(++xf86Verbose);\n        return 1;\n    }\n    if (!strcmp(argv[i], \"-logverbose\")) {\n        if (++i < argc && argv[i]) {\n            char *end;\n            long val;\n\n            val = strtol(argv[i], &end, 0);\n            if (*end == '\\0') {\n                xf86SetLogVerbosity(val);\n                return 2;\n            }\n        }\n        xf86SetLogVerbosity(++xf86LogVerbose);\n        return 1;\n    }\n    if (!strcmp(argv[i], \"-quiet\")) {\n        xf86SetVerbosity(-1);\n        return 1;\n    }\n    if (!strcmp(argv[i], \"-showconfig\") || !strcmp(argv[i], \"-version\")) {\n        xf86PrintBanner();\n        exit(0);\n    }\n    if (!strcmp(argv[i], \"-showDefaultModulePath\")) {\n        xf86PrintDefaultModulePath();\n        exit(0);\n    }\n    if (!strcmp(argv[i], \"-showDefaultLibPath\")) {\n        xf86PrintDefaultLibraryPath();\n        exit(0);\n    }\n    /* Notice the -fp flag, but allow it to pass to the dix layer */\n    if (!strcmp(argv[i], \"-fp\")) {\n        xf86fpFlag = TRUE;\n        return 0;\n    }\n    /* Notice the -bs flag, but allow it to pass to the dix layer */\n    if (!strcmp(argv[i], \"-bs\")) {\n        xf86bsDisableFlag = TRUE;\n        return 0;\n    }\n    /* Notice the +bs flag, but allow it to pass to the dix layer */\n    if (!strcmp(argv[i], \"+bs\")) {\n        xf86bsEnableFlag = TRUE;\n        return 0;\n    }\n    /* Notice the -s flag, but allow it to pass to the dix layer */\n    if (!strcmp(argv[i], \"-s\")) {\n        xf86sFlag = TRUE;\n        return 0;\n    }\n    if (!strcmp(argv[i], \"-pixmap32\") || !strcmp(argv[i], \"-pixmap24\")) {\n        /* silently accept */\n        return 1;\n    }\n    if (!strcmp(argv[i], \"-fbbpp\")) {\n        int bpp;\n\n        CHECK_FOR_REQUIRED_ARGUMENT();\n        if (sscanf(argv[++i], \"%d\", &bpp) == 1) {\n            xf86FbBpp = bpp;\n            return 2;\n        }\n        else {\n            ErrorF(\"Invalid fbbpp\\n\");\n            return 0;\n        }\n    }\n    if (!strcmp(argv[i], \"-depth\")) {\n        int depth;\n\n        CHECK_FOR_REQUIRED_ARGUMENT();\n        if (sscanf(argv[++i], \"%d\", &depth) == 1) {\n            xf86Depth = depth;\n            return 2;\n        }\n        else {\n            ErrorF(\"Invalid depth\\n\");\n            return 0;\n        }\n    }\n    if (!strcmp(argv[i], \"-weight\")) {\n        int red, green, blue;\n\n        CHECK_FOR_REQUIRED_ARGUMENT();\n        if (sscanf(argv[++i], \"%1d%1d%1d\", &red, &green, &blue) == 3) {\n            xf86Weight.red = red;\n            xf86Weight.green = green;\n            xf86Weight.blue = blue;\n            return 2;\n        }\n        else {\n            ErrorF(\"Invalid weighting\\n\");\n            return 0;\n        }\n    }\n    if (!strcmp(argv[i], \"-gamma\") || !strcmp(argv[i], \"-rgamma\") ||\n        !strcmp(argv[i], \"-ggamma\") || !strcmp(argv[i], \"-bgamma\")) {\n        double gamma;\n\n        CHECK_FOR_REQUIRED_ARGUMENT();\n        if (sscanf(argv[++i], \"%lf\", &gamma) == 1) {\n            if (gamma < GAMMA_MIN || gamma > GAMMA_MAX) {\n                ErrorF(\"gamma out of range, only  %.2f <= gamma_value <= %.1f\"\n                       \" is valid\\n\", GAMMA_MIN, GAMMA_MAX);\n                return 0;\n            }\n            if (!strcmp(argv[i - 1], \"-gamma\"))\n                xf86Gamma.red = xf86Gamma.green = xf86Gamma.blue = gamma;\n            else if (!strcmp(argv[i - 1], \"-rgamma\"))\n                xf86Gamma.red = gamma;\n            else if (!strcmp(argv[i - 1], \"-ggamma\"))\n                xf86Gamma.green = gamma;\n            else if (!strcmp(argv[i - 1], \"-bgamma\"))\n                xf86Gamma.blue = gamma;\n            return 2;\n        }\n    }\n    if (!strcmp(argv[i], \"-layout\")) {\n        CHECK_FOR_REQUIRED_ARGUMENT();\n        xf86LayoutName = argv[++i];\n        return 2;\n    }\n    if (!strcmp(argv[i], \"-screen\")) {\n        CHECK_FOR_REQUIRED_ARGUMENT();\n        xf86ScreenName = argv[++i];\n        return 2;\n    }\n    if (!strcmp(argv[i], \"-pointer\")) {\n        CHECK_FOR_REQUIRED_ARGUMENT();\n        xf86PointerName = argv[++i];\n        return 2;\n    }\n    if (!strcmp(argv[i], \"-keyboard\")) {\n        CHECK_FOR_REQUIRED_ARGUMENT();\n        xf86KeyboardName = argv[++i];\n        return 2;\n    }\n    if (!strcmp(argv[i], \"-nosilk\")) {\n        xf86silkenMouseDisableFlag = TRUE;\n        return 1;\n    }\n#ifdef HAVE_ACPI\n    if (!strcmp(argv[i], \"-noacpi\")) {\n        xf86acpiDisableFlag = TRUE;\n        return 1;\n    }\n#endif\n    if (!strcmp(argv[i], \"-configure\")) {\n        if (getuid() != 0 && geteuid() == 0) {\n            ErrorF(\"The '-configure' option can only be used by root.\\n\");\n            exit(1);\n        }\n        xf86DoConfigure = TRUE;\n        xf86AllowMouseOpenFail = TRUE;\n        return 1;\n    }\n    if (!strcmp(argv[i], \"-showopts\")) {\n        if (getuid() != 0 && geteuid() == 0) {\n            ErrorF(\"The '-showopts' option can only be used by root.\\n\");\n            exit(1);\n        }\n        xf86DoShowOptions = TRUE;\n        return 1;\n    }\n#ifdef XSERVER_LIBPCIACCESS\n    if (!strcmp(argv[i], \"-isolateDevice\")) {\n        CHECK_FOR_REQUIRED_ARGUMENT();\n        if (strncmp(argv[++i], \"PCI:\", 4)) {\n            FatalError(\"Bus types other than PCI not yet isolable\\n\");\n        }\n        xf86PciIsolateDevice(argv[i]);\n        return 2;\n    }\n#endif\n    /* Notice cmdline xkbdir, but pass to dix as well */\n    if (!strcmp(argv[i], \"-xkbdir\")) {\n        xf86xkbdirFlag = TRUE;\n        return 0;\n    }\n    if (!strcmp(argv[i], \"-novtswitch\")) {\n        xf86Info.autoVTSwitch = FALSE;\n        return 1;\n    }\n    if (!strcmp(argv[i], \"-sharevts\")) {\n        xf86Info.ShareVTs = TRUE;\n        return 1;\n    }\n    if (!strcmp(argv[i], \"-iglx\") || !strcmp(argv[i], \"+iglx\")) {\n        xf86Info.iglxFrom = X_CMDLINE;\n        return 0;\n    }\n\n    /* OS-specific processing */\n    return xf86ProcessArgument(argc, argv, i);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146476,
    "RELATED_CWE": [
      "CWE-287",
      "CWE-306",
      "CWE-862"
    ]
  },
  {
    "CWE_ID": [
      "CWE-863"
    ],
    "code": "ddxProcessArgument(int argc, char **argv, int i)\n{\n#define CHECK_FOR_REQUIRED_ARGUMENT() \\\n    if (((i + 1) >= argc) || (!argv[i + 1])) { \t\t\t\t\\\n      ErrorF(\"Required argument to %s not specified\\n\", argv[i]); \t\\\n      UseMsg(); \t\t\t\t\t\t\t\\\n      FatalError(\"Required argument to %s not specified\\n\", argv[i]);\t\\\n    }\n\n    /* First the options that are not allowed with elevated privileges */\n    if (!strcmp(argv[i], \"-modulepath\")) {\n        CHECK_FOR_REQUIRED_ARGUMENT();\n        if (xf86PrivsElevated())\n              FatalError(\"\\nInvalid argument -modulepath \"\n                \"with elevated privileges\\n\");\n        xf86ModulePath = argv[i + 1];\n        xf86ModPathFrom = X_CMDLINE;\n        return 2;\n    }\n    if (!strcmp(argv[i], \"-logfile\")) {\n        CHECK_FOR_REQUIRED_ARGUMENT();\n        if (xf86PrivsElevated())\n              FatalError(\"\\nInvalid argument -logfile \"\n                \"with elevated privileges\\n\");\n        xf86LogFile = argv[i + 1];\n        xf86LogFileFrom = X_CMDLINE;\n        return 2;\n    }\n    if (!strcmp(argv[i], \"-config\") || !strcmp(argv[i], \"-xf86config\")) {\n        CHECK_FOR_REQUIRED_ARGUMENT();\n        xf86CheckPrivs(argv[i], argv[i + 1]);\n        xf86ConfigFile = argv[i + 1];\n        return 2;\n    }\n    if (!strcmp(argv[i], \"-configdir\")) {\n        CHECK_FOR_REQUIRED_ARGUMENT();\n        xf86CheckPrivs(argv[i], argv[i + 1]);\n        xf86ConfigDir = argv[i + 1];\n        return 2;\n    }\n    if (!strcmp(argv[i], \"-flipPixels\")) {\n        xf86FlipPixels = TRUE;\n        return 1;\n    }\n#ifdef XF86VIDMODE\n    if (!strcmp(argv[i], \"-disableVidMode\")) {\n        xf86VidModeDisabled = TRUE;\n        return 1;\n    }\n    if (!strcmp(argv[i], \"-allowNonLocalXvidtune\")) {\n        xf86VidModeAllowNonLocal = TRUE;\n        return 1;\n    }\n#endif\n    if (!strcmp(argv[i], \"-allowMouseOpenFail\")) {\n        xf86AllowMouseOpenFail = TRUE;\n        return 1;\n    }\n    if (!strcmp(argv[i], \"-ignoreABI\")) {\n        LoaderSetOptions(LDR_OPT_ABI_MISMATCH_NONFATAL);\n        return 1;\n    }\n    if (!strcmp(argv[i], \"-verbose\")) {\n        if (++i < argc && argv[i]) {\n            char *end;\n            long val;\n\n            val = strtol(argv[i], &end, 0);\n            if (*end == '\\0') {\n                xf86SetVerbosity(val);\n                return 2;\n            }\n        }\n        xf86SetVerbosity(++xf86Verbose);\n        return 1;\n    }\n    if (!strcmp(argv[i], \"-logverbose\")) {\n        if (++i < argc && argv[i]) {\n            char *end;\n            long val;\n\n            val = strtol(argv[i], &end, 0);\n            if (*end == '\\0') {\n                xf86SetLogVerbosity(val);\n                return 2;\n            }\n        }\n        xf86SetLogVerbosity(++xf86LogVerbose);\n        return 1;\n    }\n    if (!strcmp(argv[i], \"-quiet\")) {\n        xf86SetVerbosity(-1);\n        return 1;\n    }\n    if (!strcmp(argv[i], \"-showconfig\") || !strcmp(argv[i], \"-version\")) {\n        xf86PrintBanner();\n        exit(0);\n    }\n    if (!strcmp(argv[i], \"-showDefaultModulePath\")) {\n        xf86PrintDefaultModulePath();\n        exit(0);\n    }\n    if (!strcmp(argv[i], \"-showDefaultLibPath\")) {\n        xf86PrintDefaultLibraryPath();\n        exit(0);\n    }\n    /* Notice the -fp flag, but allow it to pass to the dix layer */\n    if (!strcmp(argv[i], \"-fp\")) {\n        xf86fpFlag = TRUE;\n        return 0;\n    }\n    /* Notice the -bs flag, but allow it to pass to the dix layer */\n    if (!strcmp(argv[i], \"-bs\")) {\n        xf86bsDisableFlag = TRUE;\n        return 0;\n    }\n    /* Notice the +bs flag, but allow it to pass to the dix layer */\n    if (!strcmp(argv[i], \"+bs\")) {\n        xf86bsEnableFlag = TRUE;\n        return 0;\n    }\n    /* Notice the -s flag, but allow it to pass to the dix layer */\n    if (!strcmp(argv[i], \"-s\")) {\n        xf86sFlag = TRUE;\n        return 0;\n    }\n    if (!strcmp(argv[i], \"-pixmap32\") || !strcmp(argv[i], \"-pixmap24\")) {\n        /* silently accept */\n        return 1;\n    }\n    if (!strcmp(argv[i], \"-fbbpp\")) {\n        int bpp;\n\n        CHECK_FOR_REQUIRED_ARGUMENT();\n        if (sscanf(argv[++i], \"%d\", &bpp) == 1) {\n            xf86FbBpp = bpp;\n            return 2;\n        }\n        else {\n            ErrorF(\"Invalid fbbpp\\n\");\n            return 0;\n        }\n    }\n    if (!strcmp(argv[i], \"-depth\")) {\n        int depth;\n\n        CHECK_FOR_REQUIRED_ARGUMENT();\n        if (sscanf(argv[++i], \"%d\", &depth) == 1) {\n            xf86Depth = depth;\n            return 2;\n        }\n        else {\n            ErrorF(\"Invalid depth\\n\");\n            return 0;\n        }\n    }\n    if (!strcmp(argv[i], \"-weight\")) {\n        int red, green, blue;\n\n        CHECK_FOR_REQUIRED_ARGUMENT();\n        if (sscanf(argv[++i], \"%1d%1d%1d\", &red, &green, &blue) == 3) {\n            xf86Weight.red = red;\n            xf86Weight.green = green;\n            xf86Weight.blue = blue;\n            return 2;\n        }\n        else {\n            ErrorF(\"Invalid weighting\\n\");\n            return 0;\n        }\n    }\n    if (!strcmp(argv[i], \"-gamma\") || !strcmp(argv[i], \"-rgamma\") ||\n        !strcmp(argv[i], \"-ggamma\") || !strcmp(argv[i], \"-bgamma\")) {\n        double gamma;\n\n        CHECK_FOR_REQUIRED_ARGUMENT();\n        if (sscanf(argv[++i], \"%lf\", &gamma) == 1) {\n            if (gamma < GAMMA_MIN || gamma > GAMMA_MAX) {\n                ErrorF(\"gamma out of range, only  %.2f <= gamma_value <= %.1f\"\n                       \" is valid\\n\", GAMMA_MIN, GAMMA_MAX);\n                return 0;\n            }\n            if (!strcmp(argv[i - 1], \"-gamma\"))\n                xf86Gamma.red = xf86Gamma.green = xf86Gamma.blue = gamma;\n            else if (!strcmp(argv[i - 1], \"-rgamma\"))\n                xf86Gamma.red = gamma;\n            else if (!strcmp(argv[i - 1], \"-ggamma\"))\n                xf86Gamma.green = gamma;\n            else if (!strcmp(argv[i - 1], \"-bgamma\"))\n                xf86Gamma.blue = gamma;\n            return 2;\n        }\n    }\n    if (!strcmp(argv[i], \"-layout\")) {\n        CHECK_FOR_REQUIRED_ARGUMENT();\n        xf86LayoutName = argv[++i];\n        return 2;\n    }\n    if (!strcmp(argv[i], \"-screen\")) {\n        CHECK_FOR_REQUIRED_ARGUMENT();\n        xf86ScreenName = argv[++i];\n        return 2;\n    }\n    if (!strcmp(argv[i], \"-pointer\")) {\n        CHECK_FOR_REQUIRED_ARGUMENT();\n        xf86PointerName = argv[++i];\n        return 2;\n    }\n    if (!strcmp(argv[i], \"-keyboard\")) {\n        CHECK_FOR_REQUIRED_ARGUMENT();\n        xf86KeyboardName = argv[++i];\n        return 2;\n    }\n    if (!strcmp(argv[i], \"-nosilk\")) {\n        xf86silkenMouseDisableFlag = TRUE;\n        return 1;\n    }\n#ifdef HAVE_ACPI\n    if (!strcmp(argv[i], \"-noacpi\")) {\n        xf86acpiDisableFlag = TRUE;\n        return 1;\n    }\n#endif\n    if (!strcmp(argv[i], \"-configure\")) {\n        if (getuid() != 0 && geteuid() == 0) {\n            ErrorF(\"The '-configure' option can only be used by root.\\n\");\n            exit(1);\n        }\n        xf86DoConfigure = TRUE;\n        xf86AllowMouseOpenFail = TRUE;\n        return 1;\n    }\n    if (!strcmp(argv[i], \"-showopts\")) {\n        if (getuid() != 0 && geteuid() == 0) {\n            ErrorF(\"The '-showopts' option can only be used by root.\\n\");\n            exit(1);\n        }\n        xf86DoShowOptions = TRUE;\n        return 1;\n    }\n#ifdef XSERVER_LIBPCIACCESS\n    if (!strcmp(argv[i], \"-isolateDevice\")) {\n        CHECK_FOR_REQUIRED_ARGUMENT();\n        if (strncmp(argv[++i], \"PCI:\", 4)) {\n            FatalError(\"Bus types other than PCI not yet isolable\\n\");\n        }\n        xf86PciIsolateDevice(argv[i]);\n        return 2;\n    }\n#endif\n    /* Notice cmdline xkbdir, but pass to dix as well */\n    if (!strcmp(argv[i], \"-xkbdir\")) {\n        xf86xkbdirFlag = TRUE;\n        return 0;\n    }\n    if (!strcmp(argv[i], \"-novtswitch\")) {\n        xf86Info.autoVTSwitch = FALSE;\n        return 1;\n    }\n    if (!strcmp(argv[i], \"-sharevts\")) {\n        xf86Info.ShareVTs = TRUE;\n        return 1;\n    }\n    if (!strcmp(argv[i], \"-iglx\") || !strcmp(argv[i], \"+iglx\")) {\n        xf86Info.iglxFrom = X_CMDLINE;\n        return 0;\n    }\n\n    /* OS-specific processing */\n    return xf86ProcessArgument(argc, argv, i);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146477,
    "RELATED_CWE": [
      "CWE-287",
      "CWE-306",
      "CWE-862"
    ]
  }
]