[
  {
    "CWE_ID": [
      "CWE-862"
    ],
    "code": "static void construct_get_dest_keyring(struct key **_dest_keyring)\n {\n \tstruct request_key_auth *rka;\n \tconst struct cred *cred = current_cred();\n \tstruct key *dest_keyring = *_dest_keyring, *authkey;\n \n \tkenter(\"%p\", dest_keyring);\n \n\t/* find the appropriate keyring */\n\tif (dest_keyring) {\n \t\t/* the caller supplied one */\n \t\tkey_get(dest_keyring);\n \t} else {\n \t\t/* use a default keyring; falling through the cases until we\n \t\t * find one that we actually have */\n \t\tswitch (cred->jit_keyring) {\n\t\tcase KEY_REQKEY_DEFL_DEFAULT:\n\t\tcase KEY_REQKEY_DEFL_REQUESTOR_KEYRING:\n\t\t\tif (cred->request_key_auth) {\n\t\t\t\tauthkey = cred->request_key_auth;\n\t\t\t\tdown_read(&authkey->sem);\n\t\t\t\trka = authkey->payload.data[0];\n\t\t\t\tif (!test_bit(KEY_FLAG_REVOKED,\n\t\t\t\t\t      &authkey->flags))\n \t\t\t\t\tdest_keyring =\n \t\t\t\t\t\tkey_get(rka->dest_keyring);\n \t\t\t\tup_read(&authkey->sem);\n\t\t\t\tif (dest_keyring)\n \t\t\t\t\tbreak;\n \t\t\t}\n \n \t\tcase KEY_REQKEY_DEFL_THREAD_KEYRING:\n\t\t\tdest_keyring = key_get(cred->thread_keyring);\n\t\t\tif (dest_keyring)\n\t\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_PROCESS_KEYRING:\n\t\t\tdest_keyring = key_get(cred->process_keyring);\n\t\t\tif (dest_keyring)\n\t\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_SESSION_KEYRING:\n\t\t\trcu_read_lock();\n\t\t\tdest_keyring = key_get(\n\t\t\t\trcu_dereference(cred->session_keyring));\n\t\t\trcu_read_unlock();\n\n\t\t\tif (dest_keyring)\n\t\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_USER_SESSION_KEYRING:\n\t\t\tdest_keyring =\n\t\t\t\tkey_get(cred->user->session_keyring);\n\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_USER_KEYRING:\n\t\t\tdest_keyring = key_get(cred->user->uid_keyring);\n\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_GROUP_KEYRING:\n \t\tdefault:\n \t\t\tBUG();\n \t\t}\n \t}\n \n \t*_dest_keyring = dest_keyring;\n \tkleave(\" [dk %d]\", key_serial(dest_keyring));\n\treturn;\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142257,
    "RELATED_CWE": [
      "CWE-538",
      "CWE-200",
      "CWE-35"
    ]
  },
  {
    "CWE_ID": [
      "CWE-862"
    ],
    "code": "static void construct_get_dest_keyring(struct key **_dest_keyring)\nstatic int construct_get_dest_keyring(struct key **_dest_keyring)\n {\n \tstruct request_key_auth *rka;\n \tconst struct cred *cred = current_cred();\n \tstruct key *dest_keyring = *_dest_keyring, *authkey;\n\tint ret;\n \n \tkenter(\"%p\", dest_keyring);\n \n\t/* find the appropriate keyring */\n\tif (dest_keyring) {\n \t\t/* the caller supplied one */\n \t\tkey_get(dest_keyring);\n \t} else {\n\t\tbool do_perm_check = true;\n\n \t\t/* use a default keyring; falling through the cases until we\n \t\t * find one that we actually have */\n \t\tswitch (cred->jit_keyring) {\n\t\tcase KEY_REQKEY_DEFL_DEFAULT:\n\t\tcase KEY_REQKEY_DEFL_REQUESTOR_KEYRING:\n\t\t\tif (cred->request_key_auth) {\n\t\t\t\tauthkey = cred->request_key_auth;\n\t\t\t\tdown_read(&authkey->sem);\n\t\t\t\trka = authkey->payload.data[0];\n\t\t\t\tif (!test_bit(KEY_FLAG_REVOKED,\n\t\t\t\t\t      &authkey->flags))\n \t\t\t\t\tdest_keyring =\n \t\t\t\t\t\tkey_get(rka->dest_keyring);\n \t\t\t\tup_read(&authkey->sem);\n\t\t\t\tif (dest_keyring) {\n\t\t\t\t\tdo_perm_check = false;\n \t\t\t\t\tbreak;\n\t\t\t\t}\n \t\t\t}\n \n \t\tcase KEY_REQKEY_DEFL_THREAD_KEYRING:\n\t\t\tdest_keyring = key_get(cred->thread_keyring);\n\t\t\tif (dest_keyring)\n\t\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_PROCESS_KEYRING:\n\t\t\tdest_keyring = key_get(cred->process_keyring);\n\t\t\tif (dest_keyring)\n\t\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_SESSION_KEYRING:\n\t\t\trcu_read_lock();\n\t\t\tdest_keyring = key_get(\n\t\t\t\trcu_dereference(cred->session_keyring));\n\t\t\trcu_read_unlock();\n\n\t\t\tif (dest_keyring)\n\t\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_USER_SESSION_KEYRING:\n\t\t\tdest_keyring =\n\t\t\t\tkey_get(cred->user->session_keyring);\n\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_USER_KEYRING:\n\t\t\tdest_keyring = key_get(cred->user->uid_keyring);\n\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_GROUP_KEYRING:\n \t\tdefault:\n \t\t\tBUG();\n \t\t}\n\n\t\t/*\n\t\t * Require Write permission on the keyring.  This is essential\n\t\t * because the default keyring may be the session keyring, and\n\t\t * joining a keyring only requires Search permission.\n\t\t *\n\t\t * However, this check is skipped for the \"requestor keyring\" so\n\t\t * that /sbin/request-key can itself use request_key() to add\n\t\t * keys to the original requestor's destination keyring.\n\t\t */\n\t\tif (dest_keyring && do_perm_check) {\n\t\t\tret = key_permission(make_key_ref(dest_keyring, 1),\n\t\t\t\t\t     KEY_NEED_WRITE);\n\t\t\tif (ret) {\n\t\t\t\tkey_put(dest_keyring);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n \t}\n \n \t*_dest_keyring = dest_keyring;\n \tkleave(\" [dk %d]\", key_serial(dest_keyring));\n\treturn 0;\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142258,
    "RELATED_CWE": [
      "CWE-538",
      "CWE-200",
      "CWE-35"
    ]
  },
  {
    "CWE_ID": [
      "CWE-862"
    ],
    "code": " static int rename_in_ns(int pid, char *oldname, char **newnamep)\n {\n\tint fd = -1, ofd = -1, ret, ifindex = -1;\n \tbool grab_newname = false;\n \n \tofd = lxc_preserve_ns(getpid(), \"net\");\n \tif (ofd < 0) {\n\t\tfprintf(stderr, \"Failed opening network namespace path for '%d'.\", getpid());\n\t\treturn -1;\n \t}\n \n \tfd = lxc_preserve_ns(pid, \"net\");\n \tif (fd < 0) {\n\t\tfprintf(stderr, \"Failed opening network namespace path for '%d'.\", pid);\n\t\treturn -1;\n \t}\n \n\tif (setns(fd, 0) < 0) {\n\t\tfprintf(stderr, \"setns to container network namespace\\n\");\n\t\tgoto out_err;\n \t}\n\tclose(fd); fd = -1;\n \tif (!*newnamep) {\n \t\tgrab_newname = true;\n \t\t*newnamep = VETH_DEF_NAME;\n\t\tif (!(ifindex = if_nametoindex(oldname))) {\n\t\t\tfprintf(stderr, \"failed to get netdev index\\n\");\n\t\t\tgoto out_err;\n \t\t}\n \t}\n\tif ((ret = lxc_netdev_rename_by_name(oldname, *newnamep)) < 0) {\n\t\tfprintf(stderr, \"Error %d renaming netdev %s to %s in container\\n\", ret, oldname, *newnamep);\n\t\tgoto out_err;\n \t}\n \tif (grab_newname) {\n\t\tchar ifname[IFNAMSIZ], *namep = ifname;\n \t\tif (!if_indextoname(ifindex, namep)) {\n\t\t\tfprintf(stderr, \"Failed to get new netdev name\\n\");\n\t\t\tgoto out_err;\n \t\t}\n \t\t*newnamep = strdup(namep);\n \t\tif (!*newnamep)\n\t\t\tgoto out_err;\n \t}\n\tif (setns(ofd, 0) < 0) {\n\t\tfprintf(stderr, \"Error returning to original netns\\n\");\n\t\tclose(ofd);\n\t\treturn -1;\n \t}\n\tclose(ofd);\n \n\treturn 0;\n \nout_err:\n\tif (ofd >= 0)\n\t\tclose(ofd);\n\tif (setns(ofd, 0) < 0)\n\t\tfprintf(stderr, \"Error returning to original network namespace\\n\");\n \tif (fd >= 0)\n \t\tclose(fd);\n\treturn -1;\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142647,
    "RELATED_CWE": [
      "CWE-538",
      "CWE-200",
      "CWE-35"
    ]
  },
  {
    "CWE_ID": [
      "CWE-862"
    ],
    "code": " static int rename_in_ns(int pid, char *oldname, char **newnamep)\n {\n\tuid_t ruid, suid, euid;\n\tint fret = -1;\n\tint fd = -1, ifindex = -1, ofd = -1, ret;\n \tbool grab_newname = false;\n \n \tofd = lxc_preserve_ns(getpid(), \"net\");\n \tif (ofd < 0) {\n\t\tusernic_error(\"Failed opening network namespace path for '%d'.\", getpid());\n\t\treturn fret;\n \t}\n \n \tfd = lxc_preserve_ns(pid, \"net\");\n \tif (fd < 0) {\n\t\tusernic_error(\"Failed opening network namespace path for '%d'.\", pid);\n\t\tgoto do_partial_cleanup;\n\t}\n\n\tret = getresuid(&ruid, &euid, &suid);\n\tif (ret < 0) {\n\t\tusernic_error(\"Failed to retrieve real, effective, and saved \"\n\t\t\t      \"user IDs: %s\\n\",\n\t\t\t      strerror(errno));\n\t\tgoto do_partial_cleanup;\n\t}\n\n\tret = setns(fd, CLONE_NEWNET);\n\tclose(fd);\n\tfd = -1;\n\tif (ret < 0) {\n\t\tusernic_error(\"Failed to setns() to the network namespace of \"\n\t\t\t      \"the container with PID %d: %s.\\n\",\n\t\t\t      pid, strerror(errno));\n\t\tgoto do_partial_cleanup;\n \t}\n \n\tret = setresuid(ruid, ruid, 0);\n\tif (ret < 0) {\n\t\tusernic_error(\"Failed to drop privilege by setting effective \"\n\t\t\t      \"user id and real user id to %d, and saved user \"\n\t\t\t      \"ID to 0: %s.\\n\",\n\t\t\t      ruid, strerror(errno));\n\t\t// COMMENT(brauner): It's ok to jump to do_full_cleanup here\n\t\t// since setresuid() will succeed when trying to set real,\n\t\t// effective, and saved to values they currently have.\n\t\tgoto do_full_cleanup;\n \t}\n\n \tif (!*newnamep) {\n \t\tgrab_newname = true;\n \t\t*newnamep = VETH_DEF_NAME;\n\n\t\tifindex = if_nametoindex(oldname);\n\t\tif (!ifindex) {\n\t\t\tusernic_error(\"Failed to get netdev index: %s.\\n\", strerror(errno));\n\t\t\tgoto do_full_cleanup;\n \t\t}\n \t}\n\n\tret = lxc_netdev_rename_by_name(oldname, *newnamep);\n\tif (ret < 0) {\n\t\tusernic_error(\"Error %d renaming netdev %s to %s in container.\\n\", ret, oldname, *newnamep);\n\t\tgoto do_full_cleanup;\n \t}\n\n \tif (grab_newname) {\n\t\tchar ifname[IFNAMSIZ];\n\t\tchar *namep = ifname;\n\n \t\tif (!if_indextoname(ifindex, namep)) {\n\t\t\tusernic_error(\"Failed to get new netdev name: %s.\\n\", strerror(errno));\n\t\t\tgoto do_full_cleanup;\n \t\t}\n\n \t\t*newnamep = strdup(namep);\n \t\tif (!*newnamep)\n\t\t\tgoto do_full_cleanup;\n \t}\n\n\tfret = 0;\n\ndo_full_cleanup:\n\tret = setresuid(ruid, euid, suid);\n\tif (ret < 0) {\n\t\tusernic_error(\"Failed to restore privilege by setting effective \"\n\t\t\t      \"user id to %d, real user id to %d, and saved user \"\n\t\t\t      \"ID to %d: %s.\\n\",\n\t\t\t      ruid, euid, suid, strerror(errno));\n\t\tfret = -1;\n\t\t// COMMENT(brauner): setns() should fail if setresuid() doesn't\n\t\t// succeed but there's no harm in falling through; keeps the\n\t\t// code cleaner.\n \t}\n \n\tret = setns(ofd, CLONE_NEWNET);\n\tif (ret < 0) {\n\t\tusernic_error(\"Failed to setns() to original network namespace \"\n\t\t\t      \"of PID %d: %s.\\n\",\n\t\t\t      ofd, strerror(errno));\n\t\tfret = -1;\n\t}\n \ndo_partial_cleanup:\n \tif (fd >= 0)\n \t\tclose(fd);\n\tclose(ofd);\n\n\treturn fret;\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142648,
    "RELATED_CWE": [
      "CWE-538",
      "CWE-200",
      "CWE-35"
    ]
  },
  {
    "CWE_ID": [
      "CWE-862"
    ],
    "code": "bool PlatformFontSkia::InitDefaultFont() {\n  if (g_default_font.Get())\n    return true;\n \n   bool success = false;\n   std::string family = kFallbackFontFamilyName;\n  int size_pixels = 12;\n   int style = Font::NORMAL;\n   Font::Weight weight = Font::Weight::NORMAL;\n   FontRenderParams params;\n\n  const SkiaFontDelegate* delegate = SkiaFontDelegate::instance();\n  if (delegate) {\n    delegate->GetDefaultFontDescription(&family, &size_pixels, &style, &weight,\n                                        &params);\n  } else if (default_font_description_) {\n#if defined(OS_CHROMEOS)\n    FontRenderParamsQuery query;\n    CHECK(FontList::ParseDescription(*default_font_description_,\n                                     &query.families, &query.style,\n                                     &query.pixel_size, &query.weight))\n        << \"Failed to parse font description \" << *default_font_description_;\n    params = gfx::GetFontRenderParams(query, &family);\n    size_pixels = query.pixel_size;\n    style = query.style;\n    weight = query.weight;\n#else\n    NOTREACHED();\n#endif\n  }\n\n  sk_sp<SkTypeface> typeface =\n      CreateSkTypeface(style & Font::ITALIC, weight, &family, &success);\n  if (!success)\n    return false;\n  g_default_font.Get() = new PlatformFontSkia(\n      std::move(typeface), family, size_pixels, style, weight, params);\n  return true;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143787,
    "RELATED_CWE": [
      "CWE-538",
      "CWE-200",
      "CWE-35"
    ]
  },
  {
    "CWE_ID": [
      "CWE-862"
    ],
    "code": "bool PlatformFontSkia::InitDefaultFont() {\n  if (g_default_font.Get())\n    return true;\n \n   bool success = false;\n   std::string family = kFallbackFontFamilyName;\n  int size_pixels = PlatformFont::kDefaultBaseFontSize;\n   int style = Font::NORMAL;\n   Font::Weight weight = Font::Weight::NORMAL;\n   FontRenderParams params;\n\n  const SkiaFontDelegate* delegate = SkiaFontDelegate::instance();\n  if (delegate) {\n    delegate->GetDefaultFontDescription(&family, &size_pixels, &style, &weight,\n                                        &params);\n  } else if (default_font_description_) {\n#if defined(OS_CHROMEOS)\n    FontRenderParamsQuery query;\n    CHECK(FontList::ParseDescription(*default_font_description_,\n                                     &query.families, &query.style,\n                                     &query.pixel_size, &query.weight))\n        << \"Failed to parse font description \" << *default_font_description_;\n    params = gfx::GetFontRenderParams(query, &family);\n    size_pixels = query.pixel_size;\n    style = query.style;\n    weight = query.weight;\n#else\n    NOTREACHED();\n#endif\n  }\n\n  sk_sp<SkTypeface> typeface =\n      CreateSkTypeface(style & Font::ITALIC, weight, &family, &success);\n  if (!success)\n    return false;\n  g_default_font.Get() = new PlatformFontSkia(\n      std::move(typeface), family, size_pixels, style, weight, params);\n  return true;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143788,
    "RELATED_CWE": [
      "CWE-538",
      "CWE-200",
      "CWE-35"
    ]
  },
  {
    "CWE_ID": [
      "CWE-862"
    ],
    "code": "void giveup_all(struct task_struct *tsk)\n{\n\tunsigned long usermsr;\n\n\tif (!tsk->thread.regs)\n\t\treturn;\n\n\tusermsr = tsk->thread.regs->msr;\n\n\tif ((usermsr & msr_all_available) == 0)\n\t\treturn;\n\n\tmsr_check_and_set(msr_all_available);\n\tcheck_if_tm_restore_required(tsk);\n\n\tWARN_ON((usermsr & MSR_VSX) && !((usermsr & MSR_FP) && (usermsr & MSR_VEC)));\n\n#ifdef CONFIG_PPC_FPU\n\tif (usermsr & MSR_FP)\n\t\t__giveup_fpu(tsk);\n#endif\n#ifdef CONFIG_ALTIVEC\n\tif (usermsr & MSR_VEC)\n\t\t__giveup_altivec(tsk);\n#endif\n#ifdef CONFIG_SPE\n\tif (usermsr & MSR_SPE)\n\t\t__giveup_spe(tsk);\n#endif\n\n\tmsr_check_and_clear(msr_all_available);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145400,
    "RELATED_CWE": [
      "CWE-538",
      "CWE-200",
      "CWE-35"
    ]
  },
  {
    "CWE_ID": [
      "CWE-862"
    ],
    "code": "void giveup_all(struct task_struct *tsk)\n{\n\tunsigned long usermsr;\n\n\tif (!tsk->thread.regs)\n\t\treturn;\n\n\tcheck_if_tm_restore_required(tsk);\n\n\tusermsr = tsk->thread.regs->msr;\n\n\tif ((usermsr & msr_all_available) == 0)\n\t\treturn;\n\n\tmsr_check_and_set(msr_all_available);\n\n\tWARN_ON((usermsr & MSR_VSX) && !((usermsr & MSR_FP) && (usermsr & MSR_VEC)));\n\n#ifdef CONFIG_PPC_FPU\n\tif (usermsr & MSR_FP)\n\t\t__giveup_fpu(tsk);\n#endif\n#ifdef CONFIG_ALTIVEC\n\tif (usermsr & MSR_VEC)\n\t\t__giveup_altivec(tsk);\n#endif\n#ifdef CONFIG_SPE\n\tif (usermsr & MSR_SPE)\n\t\t__giveup_spe(tsk);\n#endif\n\n\tmsr_check_and_clear(msr_all_available);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145401,
    "RELATED_CWE": [
      "CWE-538",
      "CWE-200",
      "CWE-35"
    ]
  },
  {
    "CWE_ID": [
      "CWE-862"
    ],
    "code": "base_sock_create(struct net *net, struct socket *sock, int protocol, int kern)\n{\n\tstruct sock *sk;\n\n\tif (sock->type != SOCK_RAW)\n\t\treturn -ESOCKTNOSUPPORT;\n\n\tsk = sk_alloc(net, PF_ISDN, GFP_KERNEL, &mISDN_proto, kern);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\n\tsock_init_data(sock, sk);\n\tsock->ops = &base_sock_ops;\n\tsock->state = SS_UNCONNECTED;\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\tsk->sk_protocol = protocol;\n\tsk->sk_state    = MISDN_OPEN;\n\tmISDN_sock_link(&base_sockets, sk);\n\n\treturn 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146644,
    "RELATED_CWE": [
      "CWE-538",
      "CWE-200",
      "CWE-35"
    ]
  },
  {
    "CWE_ID": [
      "CWE-862"
    ],
    "code": "data_sock_create(struct net *net, struct socket *sock, int protocol, int kern)\n{\n\tstruct sock *sk;\n\n\tif (sock->type != SOCK_DGRAM)\n\t\treturn -ESOCKTNOSUPPORT;\n\n\tsk = sk_alloc(net, PF_ISDN, GFP_KERNEL, &mISDN_proto, kern);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\n\tsock_init_data(sock, sk);\n\n\tsock->ops = &data_sock_ops;\n\tsock->state = SS_UNCONNECTED;\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\n\tsk->sk_protocol = protocol;\n\tsk->sk_state    = MISDN_OPEN;\n\tmISDN_sock_link(&data_sockets, sk);\n\n\treturn 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146645,
    "RELATED_CWE": [
      "CWE-538",
      "CWE-200",
      "CWE-35"
    ]
  },
  {
    "CWE_ID": [
      "CWE-862"
    ],
    "code": "static ssize_t acpi_table_aml_write(struct config_item *cfg,\n\t\t\t\t    const void *data, size_t size)\n{\n\tconst struct acpi_table_header *header = data;\n\tstruct acpi_table *table;\n\tint ret;\n\n\ttable = container_of(cfg, struct acpi_table, cfg);\n\n\tif (table->header) {\n\t\tpr_err(\"table already loaded\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (header->length != size) {\n\t\tpr_err(\"invalid table length\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (memcmp(header->signature, ACPI_SIG_SSDT, 4)) {\n\t\tpr_err(\"invalid table signature\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttable = container_of(cfg, struct acpi_table, cfg);\n\n\ttable->header = kmemdup(header, header->length, GFP_KERNEL);\n\tif (!table->header)\n\t\treturn -ENOMEM;\n\n\tret = acpi_load_table(table->header, &table->index);\n\tif (ret) {\n\t\tkfree(table->header);\n\t\ttable->header = NULL;\n\t}\n\n\treturn ret;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148410,
    "RELATED_CWE": [
      "CWE-538",
      "CWE-200",
      "CWE-35"
    ]
  },
  {
    "CWE_ID": [
      "CWE-862"
    ],
    "code": "static ssize_t acpi_table_aml_write(struct config_item *cfg,\n\t\t\t\t    const void *data, size_t size)\n{\n\tconst struct acpi_table_header *header = data;\n\tstruct acpi_table *table;\n\tint ret = security_locked_down(LOCKDOWN_ACPI_TABLES);\n\n\tif (ret)\n\t\treturn ret;\n\n\ttable = container_of(cfg, struct acpi_table, cfg);\n\n\tif (table->header) {\n\t\tpr_err(\"table already loaded\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (header->length != size) {\n\t\tpr_err(\"invalid table length\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (memcmp(header->signature, ACPI_SIG_SSDT, 4)) {\n\t\tpr_err(\"invalid table signature\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttable = container_of(cfg, struct acpi_table, cfg);\n\n\ttable->header = kmemdup(header, header->length, GFP_KERNEL);\n\tif (!table->header)\n\t\treturn -ENOMEM;\n\n\tret = acpi_load_table(table->header, &table->index);\n\tif (ret) {\n\t\tkfree(table->header);\n\t\ttable->header = NULL;\n\t}\n\n\treturn ret;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148411,
    "RELATED_CWE": [
      "CWE-538",
      "CWE-200",
      "CWE-35"
    ]
  },
  {
    "CWE_ID": [
      "CWE-862"
    ],
    "code": "ExecAlterObjectDependsStmt(AlterObjectDependsStmt *stmt, ObjectAddress *refAddress)\n{\n\tObjectAddress address;\n\tObjectAddress refAddr;\n\tRelation\trel;\n\n\taddress =\n\t\tget_object_address_rv(stmt->objectType, stmt->relation, (List *) stmt->object,\n\t\t\t\t\t\t\t  &rel, AccessExclusiveLock, false);\n\n\t/*\n\t * If a relation was involved, it would have been opened and locked. We\n\t * don't need the relation here, but we'll retain the lock until commit.\n\t */\n\tif (rel)\n\t\ttable_close(rel, NoLock);\n\n\trefAddr = get_object_address(OBJECT_EXTENSION, (Node *) stmt->extname,\n\t\t\t\t\t\t\t\t &rel, AccessExclusiveLock, false);\n\tAssert(rel == NULL);\n\tif (refAddress)\n\t\t*refAddress = refAddr;\n\n\trecordDependencyOn(&address, &refAddr, DEPENDENCY_AUTO_EXTENSION);\n\n\treturn address;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148538,
    "RELATED_CWE": [
      "CWE-538",
      "CWE-200",
      "CWE-35"
    ]
  },
  {
    "CWE_ID": [
      "CWE-862"
    ],
    "code": "ExecAlterObjectDependsStmt(AlterObjectDependsStmt *stmt, ObjectAddress *refAddress)\n{\n\tObjectAddress address;\n\tObjectAddress refAddr;\n\tRelation\trel;\n\n\taddress =\n\t\tget_object_address_rv(stmt->objectType, stmt->relation, (List *) stmt->object,\n\t\t\t\t\t\t\t  &rel, AccessExclusiveLock, false);\n\n\t/*\n\t * Verify that the user is entitled to run the command.\n\t *\n\t * We don't check any privileges on the extension, because that's not\n\t * needed.  The object owner is stipulating, by running this command, that\n\t * the extension owner can drop the object whenever they feel like it,\n\t * which is not considered a problem.\n\t */\n\tcheck_object_ownership(GetUserId(),\n\t\t\t\t\t\t   stmt->objectType, address, stmt->object, rel);\n\n\t/*\n\t * If a relation was involved, it would have been opened and locked. We\n\t * don't need the relation here, but we'll retain the lock until commit.\n\t */\n\tif (rel)\n\t\ttable_close(rel, NoLock);\n\n\trefAddr = get_object_address(OBJECT_EXTENSION, (Node *) stmt->extname,\n\t\t\t\t\t\t\t\t &rel, AccessExclusiveLock, false);\n\tAssert(rel == NULL);\n\tif (refAddress)\n\t\t*refAddress = refAddr;\n\n\trecordDependencyOn(&address, &refAddr, DEPENDENCY_AUTO_EXTENSION);\n\n\treturn address;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148539,
    "RELATED_CWE": [
      "CWE-538",
      "CWE-200",
      "CWE-35"
    ]
  }
]