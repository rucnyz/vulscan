[
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\n\n\nstatic void f_xeckjkbo()\n{\n    int data;\n    \n    data = 0;\n    switch(6)\n    {\n    case 6:\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            inputBuffer[recvResult] = '\\0';\n            \n            data = atoi(inputBuffer);\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(8)\n    {\n    case 7:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        if(data > 0) \n        {\n            \n            if (data < (INT_MAX/2))\n            {\n                int result = data * 2;\n                printIntLine(result);\n            }\n            else\n            {\n                printLine(\"data value is too large to perform arithmetic safely.\");\n            }\n        }\n        break;\n    }\n}\n\n\nstatic void f_shklqtma()\n{\n    int data;\n    \n    data = 0;\n    switch(6)\n    {\n    case 6:\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            inputBuffer[recvResult] = '\\0';\n            \n            data = atoi(inputBuffer);\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        if(data > 0) \n        {\n            \n            if (data < (INT_MAX/2))\n            {\n                int result = data * 2;\n                printIntLine(result);\n            }\n            else\n            {\n                printLine(\"data value is too large to perform arithmetic safely.\");\n            }\n        }\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_xbwklovs()\n{\n    int data;\n    \n    data = 0;\n    switch(5)\n    {\n    case 6:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        data = 2;\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        if(data > 0) \n        {\n            \n            int result = data * 2;\n            printIntLine(result);\n        }\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_cydzbgch()\n{\n    int data;\n    \n    data = 0;\n    switch(6)\n    {\n    case 6:\n        \n        data = 2;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        if(data > 0) \n        {\n            \n            int result = data * 2;\n            printIntLine(result);\n        }\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\nvoid f_sphwjztk()\n{\n    f_xeckjkbo();\n    f_shklqtma();\n    f_xbwklovs();\n    f_cydzbgch();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_sphwjztk();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402480,
    "original_file": "testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_15.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nvoid f_glxderbl()\n{\n    int data;\n    \n    data = 0;\n    switch(6)\n    {\n    case 6:\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            inputBuffer[recvResult] = '\\0';\n            \n            data = atoi(inputBuffer);\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        if(data > 0) \n        {\n            \n            int result = data * 2;\n            printIntLine(result);\n        }\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_glxderbl();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402481,
    "original_file": "testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_15.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\n\n\nstatic void f_escwdted()\n{\n    int data;\n    \n    data = 0;\n    switch(6)\n    {\n    case 6:\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            inputBuffer[recvResult] = '\\0';\n            \n            data = atoi(inputBuffer);\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(8)\n    {\n    case 7:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        if (data < INT_MAX)\n        {\n            ++data;\n            int result = data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n        break;\n    }\n}\n\n\nstatic void f_vgdnobvz()\n{\n    int data;\n    \n    data = 0;\n    switch(6)\n    {\n    case 6:\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            inputBuffer[recvResult] = '\\0';\n            \n            data = atoi(inputBuffer);\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        if (data < INT_MAX)\n        {\n            ++data;\n            int result = data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_atjmbvcw()\n{\n    int data;\n    \n    data = 0;\n    switch(5)\n    {\n    case 6:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        data = 2;\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n    {\n        \n        ++data;\n        int result = data;\n        printIntLine(result);\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_ujirqkfu()\n{\n    int data;\n    \n    data = 0;\n    switch(6)\n    {\n    case 6:\n        \n        data = 2;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n    {\n        \n        ++data;\n        int result = data;\n        printIntLine(result);\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\nvoid f_mueeervi()\n{\n    f_escwdted();\n    f_vgdnobvz();\n    f_atjmbvcw();\n    f_ujirqkfu();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_mueeervi();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402482,
    "original_file": "testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_15.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nvoid f_mwyjiici()\n{\n    int data;\n    \n    data = 0;\n    switch(6)\n    {\n    case 6:\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            inputBuffer[recvResult] = '\\0';\n            \n            data = atoi(inputBuffer);\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n    {\n        \n        ++data;\n        int result = data;\n        printIntLine(result);\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_mwyjiici();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402483,
    "original_file": "testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_15.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\n\n\nstatic void f_kkspjwuj()\n{\n    int data;\n    \n    data = 0;\n    switch(6)\n    {\n    case 6:\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            inputBuffer[recvResult] = '\\0';\n            \n            data = atoi(inputBuffer);\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(8)\n    {\n    case 7:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        if (data < INT_MAX)\n        {\n            data++;\n            int result = data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n        break;\n    }\n}\n\n\nstatic void f_njcntkvy()\n{\n    int data;\n    \n    data = 0;\n    switch(6)\n    {\n    case 6:\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            inputBuffer[recvResult] = '\\0';\n            \n            data = atoi(inputBuffer);\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        if (data < INT_MAX)\n        {\n            data++;\n            int result = data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_qsojfvar()\n{\n    int data;\n    \n    data = 0;\n    switch(5)\n    {\n    case 6:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        data = 2;\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n    {\n        \n        data++;\n        int result = data;\n        printIntLine(result);\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_usjunhpj()\n{\n    int data;\n    \n    data = 0;\n    switch(6)\n    {\n    case 6:\n        \n        data = 2;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n    {\n        \n        data++;\n        int result = data;\n        printIntLine(result);\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\nvoid f_feocxtcy()\n{\n    f_kkspjwuj();\n    f_njcntkvy();\n    f_qsojfvar();\n    f_usjunhpj();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_feocxtcy();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402484,
    "original_file": "testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_15.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nvoid f_cdskpvqp()\n{\n    int data;\n    \n    data = 0;\n    switch(6)\n    {\n    case 6:\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            inputBuffer[recvResult] = '\\0';\n            \n            data = atoi(inputBuffer);\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n    {\n        \n        data++;\n        int result = data;\n        printIntLine(result);\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_cdskpvqp();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402485,
    "original_file": "testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_15.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n#include <math.h>\n\n\n\n\nstatic void f_lwucyrfk()\n{\n    int data;\n    \n    data = 0;\n    switch(6)\n    {\n    case 6:\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            inputBuffer[recvResult] = '\\0';\n            \n            data = atoi(inputBuffer);\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(8)\n    {\n    case 7:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        if (data > INT_MIN && abs(data) < (long)sqrt((double)INT_MAX))\n        {\n            int result = data * data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n        break;\n    }\n}\n\n\nstatic void f_fjgyjjue()\n{\n    int data;\n    \n    data = 0;\n    switch(6)\n    {\n    case 6:\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            inputBuffer[recvResult] = '\\0';\n            \n            data = atoi(inputBuffer);\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        if (data > INT_MIN && abs(data) < (long)sqrt((double)INT_MAX))\n        {\n            int result = data * data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_gmzfwwfs()\n{\n    int data;\n    \n    data = 0;\n    switch(5)\n    {\n    case 6:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        data = 2;\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n    {\n        \n        int result = data * data;\n        printIntLine(result);\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_ualimyou()\n{\n    int data;\n    \n    data = 0;\n    switch(6)\n    {\n    case 6:\n        \n        data = 2;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n    {\n        \n        int result = data * data;\n        printIntLine(result);\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\nvoid f_mhvwzqtl()\n{\n    f_lwucyrfk();\n    f_fjgyjjue();\n    f_gmzfwwfs();\n    f_ualimyou();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_mhvwzqtl();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402486,
    "original_file": "testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_15.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n#include <math.h>\n\n\nvoid f_yblhscof()\n{\n    int data;\n    \n    data = 0;\n    switch(6)\n    {\n    case 6:\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            inputBuffer[recvResult] = '\\0';\n            \n            data = atoi(inputBuffer);\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n    {\n        \n        int result = data * data;\n        printIntLine(result);\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_yblhscof();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402487,
    "original_file": "testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_15.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\n\n\nstatic void f_ifrkuemi()\n{\n    int data;\n    \n    data = 0;\n    switch(6)\n    {\n    case 6:\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            inputBuffer[recvResult] = '\\0';\n            \n            data = atoi(inputBuffer);\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(8)\n    {\n    case 7:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        if (data < INT_MAX)\n        {\n            int result = data + 1;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n        break;\n    }\n}\n\n\nstatic void f_uwnrvfdg()\n{\n    int data;\n    \n    data = 0;\n    switch(6)\n    {\n    case 6:\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            inputBuffer[recvResult] = '\\0';\n            \n            data = atoi(inputBuffer);\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        if (data < INT_MAX)\n        {\n            int result = data + 1;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_eirdntcs()\n{\n    int data;\n    \n    data = 0;\n    switch(5)\n    {\n    case 6:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        data = 2;\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n    {\n        \n        int result = data + 1;\n        printIntLine(result);\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_gvufzobk()\n{\n    int data;\n    \n    data = 0;\n    switch(6)\n    {\n    case 6:\n        \n        data = 2;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n    {\n        \n        int result = data + 1;\n        printIntLine(result);\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\nvoid f_gyufahat()\n{\n    f_ifrkuemi();\n    f_uwnrvfdg();\n    f_eirdntcs();\n    f_gvufzobk();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_gyufahat();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402488,
    "original_file": "testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_15.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nvoid f_bpikjovg()\n{\n    int data;\n    \n    data = 0;\n    switch(6)\n    {\n    case 6:\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            inputBuffer[recvResult] = '\\0';\n            \n            data = atoi(inputBuffer);\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n    {\n        \n        int result = data + 1;\n        printIntLine(result);\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_bpikjovg();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402489,
    "original_file": "testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_15.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nstatic int staticReturnsTrue()\n{\n    return 1;\n}\n\nstatic int staticReturnsFalse()\n{\n    return 0;\n}\n\n\n\n\nstatic void f_boztzbff()\n{\n    int data;\n    \n    data = 0;\n    if(staticReturnsTrue())\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(staticReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        if(data > 0) \n        {\n            \n            if (data < (INT_MAX/2))\n            {\n                int result = data * 2;\n                printIntLine(result);\n            }\n            else\n            {\n                printLine(\"data value is too large to perform arithmetic safely.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_jwicqxnz()\n{\n    int data;\n    \n    data = 0;\n    if(staticReturnsTrue())\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(staticReturnsTrue())\n    {\n        if(data > 0) \n        {\n            \n            if (data < (INT_MAX/2))\n            {\n                int result = data * 2;\n                printIntLine(result);\n            }\n            else\n            {\n                printLine(\"data value is too large to perform arithmetic safely.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_wljpfmtf()\n{\n    int data;\n    \n    data = 0;\n    if(staticReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        data = 2;\n    }\n    if(staticReturnsTrue())\n    {\n        if(data > 0) \n        {\n            \n            int result = data * 2;\n            printIntLine(result);\n        }\n    }\n}\n\n\nstatic void f_cyykrwcm()\n{\n    int data;\n    \n    data = 0;\n    if(staticReturnsTrue())\n    {\n        \n        data = 2;\n    }\n    if(staticReturnsTrue())\n    {\n        if(data > 0) \n        {\n            \n            int result = data * 2;\n            printIntLine(result);\n        }\n    }\n}\n\nvoid f_lmfdfxdl()\n{\n    f_boztzbff();\n    f_jwicqxnz();\n    f_wljpfmtf();\n    f_cyykrwcm();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_lmfdfxdl();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402490,
    "original_file": "testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_08.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nstatic int staticReturnsTrue()\n{\n    return 1;\n}\n\nstatic int staticReturnsFalse()\n{\n    return 0;\n}\n\n\nvoid f_yijfdmwe()\n{\n    int data;\n    \n    data = 0;\n    if(staticReturnsTrue())\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(staticReturnsTrue())\n    {\n        if(data > 0) \n        {\n            \n            int result = data * 2;\n            printIntLine(result);\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_yijfdmwe();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402491,
    "original_file": "testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_08.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\n\n\nstatic void f_bjytmpsb()\n{\n    int data;\n    \n    data = 0;\n    switch(6)\n    {\n    case 6:\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET connectSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            inputBuffer[recvResult] = '\\0';\n            \n            data = atoi(inputBuffer);\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(8)\n    {\n    case 7:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        if(data > 0) \n        {\n            \n            if (data < (INT_MAX/2))\n            {\n                int result = data * 2;\n                printIntLine(result);\n            }\n            else\n            {\n                printLine(\"data value is too large to perform arithmetic safely.\");\n            }\n        }\n        break;\n    }\n}\n\n\nstatic void f_oqmsouzu()\n{\n    int data;\n    \n    data = 0;\n    switch(6)\n    {\n    case 6:\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET connectSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            inputBuffer[recvResult] = '\\0';\n            \n            data = atoi(inputBuffer);\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        if(data > 0) \n        {\n            \n            if (data < (INT_MAX/2))\n            {\n                int result = data * 2;\n                printIntLine(result);\n            }\n            else\n            {\n                printLine(\"data value is too large to perform arithmetic safely.\");\n            }\n        }\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_wcgxeotb()\n{\n    int data;\n    \n    data = 0;\n    switch(5)\n    {\n    case 6:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        data = 2;\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        if(data > 0) \n        {\n            \n            int result = data * 2;\n            printIntLine(result);\n        }\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_fyfdsqak()\n{\n    int data;\n    \n    data = 0;\n    switch(6)\n    {\n    case 6:\n        \n        data = 2;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        if(data > 0) \n        {\n            \n            int result = data * 2;\n            printIntLine(result);\n        }\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\nvoid f_fmntwxak()\n{\n    f_bjytmpsb();\n    f_oqmsouzu();\n    f_wcgxeotb();\n    f_fyfdsqak();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_fmntwxak();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402492,
    "original_file": "testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_15.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nvoid f_xucvrkam()\n{\n    int data;\n    \n    data = 0;\n    switch(6)\n    {\n    case 6:\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET connectSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            inputBuffer[recvResult] = '\\0';\n            \n            data = atoi(inputBuffer);\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        if(data > 0) \n        {\n            \n            int result = data * 2;\n            printIntLine(result);\n        }\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_xucvrkam();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402493,
    "original_file": "testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_15.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nstatic int staticReturnsTrue()\n{\n    return 1;\n}\n\nstatic int staticReturnsFalse()\n{\n    return 0;\n}\n\n\n\n\nstatic void f_dclnuwbd()\n{\n    int data;\n    \n    data = 0;\n    if(staticReturnsTrue())\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(staticReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data < INT_MAX)\n        {\n            ++data;\n            int result = data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_hlcdkqza()\n{\n    int data;\n    \n    data = 0;\n    if(staticReturnsTrue())\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(staticReturnsTrue())\n    {\n        \n        if (data < INT_MAX)\n        {\n            ++data;\n            int result = data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_fmhyiqyu()\n{\n    int data;\n    \n    data = 0;\n    if(staticReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        data = 2;\n    }\n    if(staticReturnsTrue())\n    {\n        {\n            \n            ++data;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\n\nstatic void f_hrhqqbjl()\n{\n    int data;\n    \n    data = 0;\n    if(staticReturnsTrue())\n    {\n        \n        data = 2;\n    }\n    if(staticReturnsTrue())\n    {\n        {\n            \n            ++data;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\nvoid f_lloxgspj()\n{\n    f_dclnuwbd();\n    f_hlcdkqza();\n    f_fmhyiqyu();\n    f_hrhqqbjl();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_lloxgspj();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402494,
    "original_file": "testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_08.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nstatic int staticReturnsTrue()\n{\n    return 1;\n}\n\nstatic int staticReturnsFalse()\n{\n    return 0;\n}\n\n\nvoid f_aeidwwiv()\n{\n    int data;\n    \n    data = 0;\n    if(staticReturnsTrue())\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(staticReturnsTrue())\n    {\n        {\n            \n            ++data;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_aeidwwiv();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402495,
    "original_file": "testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_08.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nstatic int staticReturnsTrue()\n{\n    return 1;\n}\n\nstatic int staticReturnsFalse()\n{\n    return 0;\n}\n\n\n\n\nstatic void f_dmtbqwur()\n{\n    int data;\n    \n    data = 0;\n    if(staticReturnsTrue())\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(staticReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data < INT_MAX)\n        {\n            data++;\n            int result = data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_dlaxiqeh()\n{\n    int data;\n    \n    data = 0;\n    if(staticReturnsTrue())\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(staticReturnsTrue())\n    {\n        \n        if (data < INT_MAX)\n        {\n            data++;\n            int result = data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_xgkmyrgg()\n{\n    int data;\n    \n    data = 0;\n    if(staticReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        data = 2;\n    }\n    if(staticReturnsTrue())\n    {\n        {\n            \n            data++;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\n\nstatic void f_ytakvzdd()\n{\n    int data;\n    \n    data = 0;\n    if(staticReturnsTrue())\n    {\n        \n        data = 2;\n    }\n    if(staticReturnsTrue())\n    {\n        {\n            \n            data++;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\nvoid f_ubrnjaib()\n{\n    f_dmtbqwur();\n    f_dlaxiqeh();\n    f_xgkmyrgg();\n    f_ytakvzdd();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ubrnjaib();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402496,
    "original_file": "testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_08.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nstatic int staticReturnsTrue()\n{\n    return 1;\n}\n\nstatic int staticReturnsFalse()\n{\n    return 0;\n}\n\n\nvoid f_usueqnmt()\n{\n    int data;\n    \n    data = 0;\n    if(staticReturnsTrue())\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(staticReturnsTrue())\n    {\n        {\n            \n            data++;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_usueqnmt();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402497,
    "original_file": "testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_08.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\n\n\nstatic void f_htvynjsu()\n{\n    int data;\n    \n    data = 0;\n    switch(6)\n    {\n    case 6:\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET connectSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            inputBuffer[recvResult] = '\\0';\n            \n            data = atoi(inputBuffer);\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(8)\n    {\n    case 7:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        if (data < INT_MAX)\n        {\n            ++data;\n            int result = data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n        break;\n    }\n}\n\n\nstatic void f_ttkixggc()\n{\n    int data;\n    \n    data = 0;\n    switch(6)\n    {\n    case 6:\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET connectSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            inputBuffer[recvResult] = '\\0';\n            \n            data = atoi(inputBuffer);\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        if (data < INT_MAX)\n        {\n            ++data;\n            int result = data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_tfqkihwt()\n{\n    int data;\n    \n    data = 0;\n    switch(5)\n    {\n    case 6:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        data = 2;\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n    {\n        \n        ++data;\n        int result = data;\n        printIntLine(result);\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_jbxvqkpy()\n{\n    int data;\n    \n    data = 0;\n    switch(6)\n    {\n    case 6:\n        \n        data = 2;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n    {\n        \n        ++data;\n        int result = data;\n        printIntLine(result);\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\nvoid f_mvtysdos()\n{\n    f_htvynjsu();\n    f_ttkixggc();\n    f_tfqkihwt();\n    f_jbxvqkpy();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_mvtysdos();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402498,
    "original_file": "testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_15.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nvoid f_scktycvh()\n{\n    int data;\n    \n    data = 0;\n    switch(6)\n    {\n    case 6:\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET connectSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            inputBuffer[recvResult] = '\\0';\n            \n            data = atoi(inputBuffer);\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n    {\n        \n        ++data;\n        int result = data;\n        printIntLine(result);\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_scktycvh();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402499,
    "original_file": "testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_15.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\n\n\nstatic void f_upyllzwx()\n{\n    int data;\n    \n    data = 0;\n    switch(6)\n    {\n    case 6:\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET connectSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            inputBuffer[recvResult] = '\\0';\n            \n            data = atoi(inputBuffer);\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(8)\n    {\n    case 7:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        if (data < INT_MAX)\n        {\n            data++;\n            int result = data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n        break;\n    }\n}\n\n\nstatic void f_ieigxukk()\n{\n    int data;\n    \n    data = 0;\n    switch(6)\n    {\n    case 6:\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET connectSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            inputBuffer[recvResult] = '\\0';\n            \n            data = atoi(inputBuffer);\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        if (data < INT_MAX)\n        {\n            data++;\n            int result = data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_cgxanrlu()\n{\n    int data;\n    \n    data = 0;\n    switch(5)\n    {\n    case 6:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        data = 2;\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n    {\n        \n        data++;\n        int result = data;\n        printIntLine(result);\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_szzqwspn()\n{\n    int data;\n    \n    data = 0;\n    switch(6)\n    {\n    case 6:\n        \n        data = 2;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n    {\n        \n        data++;\n        int result = data;\n        printIntLine(result);\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\nvoid f_kpuldndn()\n{\n    f_upyllzwx();\n    f_ieigxukk();\n    f_cgxanrlu();\n    f_szzqwspn();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_kpuldndn();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402500,
    "original_file": "testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_15.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nvoid f_esomdkds()\n{\n    int data;\n    \n    data = 0;\n    switch(6)\n    {\n    case 6:\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET connectSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            inputBuffer[recvResult] = '\\0';\n            \n            data = atoi(inputBuffer);\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n    {\n        \n        data++;\n        int result = data;\n        printIntLine(result);\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_esomdkds();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402501,
    "original_file": "testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_15.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nstatic const int STATIC_CONST_TRUE = 1; \nstatic const int STATIC_CONST_FALSE = 0; \n\n\n\n\nstatic void f_aoyackpd()\n{\n    int data;\n    \n    data = 0;\n    if(STATIC_CONST_TRUE)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(STATIC_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        if(data > 0) \n        {\n            \n            if (data < (INT_MAX/2))\n            {\n                int result = data * 2;\n                printIntLine(result);\n            }\n            else\n            {\n                printLine(\"data value is too large to perform arithmetic safely.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_ocohpntz()\n{\n    int data;\n    \n    data = 0;\n    if(STATIC_CONST_TRUE)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        if(data > 0) \n        {\n            \n            if (data < (INT_MAX/2))\n            {\n                int result = data * 2;\n                printIntLine(result);\n            }\n            else\n            {\n                printLine(\"data value is too large to perform arithmetic safely.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_azcljile()\n{\n    int data;\n    \n    data = 0;\n    if(STATIC_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        data = 2;\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        if(data > 0) \n        {\n            \n            int result = data * 2;\n            printIntLine(result);\n        }\n    }\n}\n\n\nstatic void f_eptxxdke()\n{\n    int data;\n    \n    data = 0;\n    if(STATIC_CONST_TRUE)\n    {\n        \n        data = 2;\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        if(data > 0) \n        {\n            \n            int result = data * 2;\n            printIntLine(result);\n        }\n    }\n}\n\nvoid f_dnthihzu()\n{\n    f_aoyackpd();\n    f_ocohpntz();\n    f_azcljile();\n    f_eptxxdke();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_dnthihzu();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402502,
    "original_file": "testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_04.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nstatic const int STATIC_CONST_TRUE = 1; \nstatic const int STATIC_CONST_FALSE = 0; \n\n\nvoid f_pdqzdyzl()\n{\n    int data;\n    \n    data = 0;\n    if(STATIC_CONST_TRUE)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        if(data > 0) \n        {\n            \n            int result = data * 2;\n            printIntLine(result);\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_pdqzdyzl();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402503,
    "original_file": "testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_04.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nstatic int staticTrue = 1; \nstatic int staticFalse = 0; \n\n\n\n\nstatic void f_dnfzjzxl()\n{\n    int data;\n    \n    data = 0;\n    if(staticTrue)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(staticFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        if(data > 0) \n        {\n            \n            if (data < (INT_MAX/2))\n            {\n                int result = data * 2;\n                printIntLine(result);\n            }\n            else\n            {\n                printLine(\"data value is too large to perform arithmetic safely.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_kxvdtswf()\n{\n    int data;\n    \n    data = 0;\n    if(staticTrue)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(staticTrue)\n    {\n        if(data > 0) \n        {\n            \n            if (data < (INT_MAX/2))\n            {\n                int result = data * 2;\n                printIntLine(result);\n            }\n            else\n            {\n                printLine(\"data value is too large to perform arithmetic safely.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_qxdvwfce()\n{\n    int data;\n    \n    data = 0;\n    if(staticFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        data = 2;\n    }\n    if(staticTrue)\n    {\n        if(data > 0) \n        {\n            \n            int result = data * 2;\n            printIntLine(result);\n        }\n    }\n}\n\n\nstatic void f_qqnxurmq()\n{\n    int data;\n    \n    data = 0;\n    if(staticTrue)\n    {\n        \n        data = 2;\n    }\n    if(staticTrue)\n    {\n        if(data > 0) \n        {\n            \n            int result = data * 2;\n            printIntLine(result);\n        }\n    }\n}\n\nvoid f_rijqm()\n{\n    f_dnfzjzxl();\n    f_kxvdtswf();\n    f_qxdvwfce();\n    f_qqnxurmq();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_rijqm();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402504,
    "original_file": "testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_05.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nstatic int staticTrue = 1; \nstatic int staticFalse = 0; \n\n\nvoid f_nezjovfk()\n{\n    int data;\n    \n    data = 0;\n    if(staticTrue)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(staticTrue)\n    {\n        if(data > 0) \n        {\n            \n            int result = data * 2;\n            printIntLine(result);\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_nezjovfk();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402505,
    "original_file": "testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_05.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n#include <math.h>\n\n\nstatic int staticReturnsTrue()\n{\n    return 1;\n}\n\nstatic int staticReturnsFalse()\n{\n    return 0;\n}\n\n\n\n\nstatic void f_jtedmevo()\n{\n    int data;\n    \n    data = 0;\n    if(staticReturnsTrue())\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(staticReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data > INT_MIN && abs(data) < (long)sqrt((double)INT_MAX))\n        {\n            int result = data * data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_qwvjfgiu()\n{\n    int data;\n    \n    data = 0;\n    if(staticReturnsTrue())\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(staticReturnsTrue())\n    {\n        \n        if (data > INT_MIN && abs(data) < (long)sqrt((double)INT_MAX))\n        {\n            int result = data * data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_xlqorcvh()\n{\n    int data;\n    \n    data = 0;\n    if(staticReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        data = 2;\n    }\n    if(staticReturnsTrue())\n    {\n        {\n            \n            int result = data * data;\n            printIntLine(result);\n        }\n    }\n}\n\n\nstatic void f_vgeenzjf()\n{\n    int data;\n    \n    data = 0;\n    if(staticReturnsTrue())\n    {\n        \n        data = 2;\n    }\n    if(staticReturnsTrue())\n    {\n        {\n            \n            int result = data * data;\n            printIntLine(result);\n        }\n    }\n}\n\nvoid f_yykhkacn()\n{\n    f_jtedmevo();\n    f_qwvjfgiu();\n    f_xlqorcvh();\n    f_vgeenzjf();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_yykhkacn();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402506,
    "original_file": "testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_08.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n#include <math.h>\n\n\nstatic int staticReturnsTrue()\n{\n    return 1;\n}\n\nstatic int staticReturnsFalse()\n{\n    return 0;\n}\n\n\nvoid f_qphpogtk()\n{\n    int data;\n    \n    data = 0;\n    if(staticReturnsTrue())\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(staticReturnsTrue())\n    {\n        {\n            \n            int result = data * data;\n            printIntLine(result);\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_qphpogtk();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402507,
    "original_file": "testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_08.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nstatic int staticFive = 5;\n\n\n\n\nstatic void f_hlxgabpc()\n{\n    int data;\n    \n    data = 0;\n    if(staticFive==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(staticFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        if(data > 0) \n        {\n            \n            if (data < (INT_MAX/2))\n            {\n                int result = data * 2;\n                printIntLine(result);\n            }\n            else\n            {\n                printLine(\"data value is too large to perform arithmetic safely.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_pqyccafy()\n{\n    int data;\n    \n    data = 0;\n    if(staticFive==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(staticFive==5)\n    {\n        if(data > 0) \n        {\n            \n            if (data < (INT_MAX/2))\n            {\n                int result = data * 2;\n                printIntLine(result);\n            }\n            else\n            {\n                printLine(\"data value is too large to perform arithmetic safely.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_edojmzjb()\n{\n    int data;\n    \n    data = 0;\n    if(staticFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        data = 2;\n    }\n    if(staticFive==5)\n    {\n        if(data > 0) \n        {\n            \n            int result = data * 2;\n            printIntLine(result);\n        }\n    }\n}\n\n\nstatic void f_zstsjaag()\n{\n    int data;\n    \n    data = 0;\n    if(staticFive==5)\n    {\n        \n        data = 2;\n    }\n    if(staticFive==5)\n    {\n        if(data > 0) \n        {\n            \n            int result = data * 2;\n            printIntLine(result);\n        }\n    }\n}\n\nvoid f_hzhicqzy()\n{\n    f_hlxgabpc();\n    f_pqyccafy();\n    f_edojmzjb();\n    f_zstsjaag();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_hzhicqzy();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402508,
    "original_file": "testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_07.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nstatic int staticFive = 5;\n\n\nvoid f_sgqoxopk()\n{\n    int data;\n    \n    data = 0;\n    if(staticFive==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(staticFive==5)\n    {\n        if(data > 0) \n        {\n            \n            int result = data * 2;\n            printIntLine(result);\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_sgqoxopk();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402509,
    "original_file": "testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_07.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nstatic const int STATIC_CONST_FIVE = 5;\n\n\n\n\nstatic void f_crlidnmr()\n{\n    int data;\n    \n    data = 0;\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(STATIC_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        if(data > 0) \n        {\n            \n            if (data < (INT_MAX/2))\n            {\n                int result = data * 2;\n                printIntLine(result);\n            }\n            else\n            {\n                printLine(\"data value is too large to perform arithmetic safely.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_zfijccak()\n{\n    int data;\n    \n    data = 0;\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        if(data > 0) \n        {\n            \n            if (data < (INT_MAX/2))\n            {\n                int result = data * 2;\n                printIntLine(result);\n            }\n            else\n            {\n                printLine(\"data value is too large to perform arithmetic safely.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_sxihwnwl()\n{\n    int data;\n    \n    data = 0;\n    if(STATIC_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        data = 2;\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        if(data > 0) \n        {\n            \n            int result = data * 2;\n            printIntLine(result);\n        }\n    }\n}\n\n\nstatic void f_ylletayg()\n{\n    int data;\n    \n    data = 0;\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        data = 2;\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        if(data > 0) \n        {\n            \n            int result = data * 2;\n            printIntLine(result);\n        }\n    }\n}\n\nvoid f_jtcorijb()\n{\n    f_crlidnmr();\n    f_zfijccak();\n    f_sxihwnwl();\n    f_ylletayg();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_jtcorijb();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402510,
    "original_file": "testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_06.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nstatic const int STATIC_CONST_FIVE = 5;\n\n\nvoid f_yyifnbap()\n{\n    int data;\n    \n    data = 0;\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        if(data > 0) \n        {\n            \n            int result = data * 2;\n            printIntLine(result);\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_yyifnbap();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402511,
    "original_file": "testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_06.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n#include <math.h>\n\n\n\n\nstatic void f_kibzmstv()\n{\n    int data;\n    \n    data = 0;\n    switch(6)\n    {\n    case 6:\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET connectSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            inputBuffer[recvResult] = '\\0';\n            \n            data = atoi(inputBuffer);\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(8)\n    {\n    case 7:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        if (data > INT_MIN && abs(data) < (long)sqrt((double)INT_MAX))\n        {\n            int result = data * data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n        break;\n    }\n}\n\n\nstatic void f_lpcszfrj()\n{\n    int data;\n    \n    data = 0;\n    switch(6)\n    {\n    case 6:\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET connectSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            inputBuffer[recvResult] = '\\0';\n            \n            data = atoi(inputBuffer);\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        if (data > INT_MIN && abs(data) < (long)sqrt((double)INT_MAX))\n        {\n            int result = data * data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_strjsjuo()\n{\n    int data;\n    \n    data = 0;\n    switch(5)\n    {\n    case 6:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        data = 2;\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n    {\n        \n        int result = data * data;\n        printIntLine(result);\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_jvgifwyg()\n{\n    int data;\n    \n    data = 0;\n    switch(6)\n    {\n    case 6:\n        \n        data = 2;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n    {\n        \n        int result = data * data;\n        printIntLine(result);\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\nvoid f_cnpmwrfl()\n{\n    f_kibzmstv();\n    f_lpcszfrj();\n    f_strjsjuo();\n    f_jvgifwyg();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_cnpmwrfl();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402512,
    "original_file": "testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_15.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n#include <math.h>\n\n\nvoid f_okhefmto()\n{\n    int data;\n    \n    data = 0;\n    switch(6)\n    {\n    case 6:\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET connectSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            inputBuffer[recvResult] = '\\0';\n            \n            data = atoi(inputBuffer);\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n    {\n        \n        int result = data * data;\n        printIntLine(result);\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_okhefmto();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402513,
    "original_file": "testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_15.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nstatic int staticReturnsTrue()\n{\n    return 1;\n}\n\nstatic int staticReturnsFalse()\n{\n    return 0;\n}\n\n\n\n\nstatic void f_nwtgfraz()\n{\n    int data;\n    \n    data = 0;\n    if(staticReturnsTrue())\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(staticReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data < INT_MAX)\n        {\n            int result = data + 1;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_rgzowqif()\n{\n    int data;\n    \n    data = 0;\n    if(staticReturnsTrue())\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(staticReturnsTrue())\n    {\n        \n        if (data < INT_MAX)\n        {\n            int result = data + 1;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_kutrjcgs()\n{\n    int data;\n    \n    data = 0;\n    if(staticReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        data = 2;\n    }\n    if(staticReturnsTrue())\n    {\n        {\n            \n            int result = data + 1;\n            printIntLine(result);\n        }\n    }\n}\n\n\nstatic void f_blvjakng()\n{\n    int data;\n    \n    data = 0;\n    if(staticReturnsTrue())\n    {\n        \n        data = 2;\n    }\n    if(staticReturnsTrue())\n    {\n        {\n            \n            int result = data + 1;\n            printIntLine(result);\n        }\n    }\n}\n\nvoid f_ulnwztqw()\n{\n    f_nwtgfraz();\n    f_rgzowqif();\n    f_kutrjcgs();\n    f_blvjakng();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ulnwztqw();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402514,
    "original_file": "testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_08.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nstatic int staticReturnsTrue()\n{\n    return 1;\n}\n\nstatic int staticReturnsFalse()\n{\n    return 0;\n}\n\n\nvoid f_ozsnuhbw()\n{\n    int data;\n    \n    data = 0;\n    if(staticReturnsTrue())\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(staticReturnsTrue())\n    {\n        {\n            \n            int result = data + 1;\n            printIntLine(result);\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ozsnuhbw();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402515,
    "original_file": "testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_08.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\n\n\nstatic void f_htnsysgk()\n{\n    int data;\n    \n    data = 0;\n    switch(6)\n    {\n    case 6:\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET connectSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            inputBuffer[recvResult] = '\\0';\n            \n            data = atoi(inputBuffer);\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(8)\n    {\n    case 7:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        if (data < INT_MAX)\n        {\n            int result = data + 1;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n        break;\n    }\n}\n\n\nstatic void f_wszvoiuy()\n{\n    int data;\n    \n    data = 0;\n    switch(6)\n    {\n    case 6:\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET connectSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            inputBuffer[recvResult] = '\\0';\n            \n            data = atoi(inputBuffer);\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        if (data < INT_MAX)\n        {\n            int result = data + 1;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_tuxyzamm()\n{\n    int data;\n    \n    data = 0;\n    switch(5)\n    {\n    case 6:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        data = 2;\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n    {\n        \n        int result = data + 1;\n        printIntLine(result);\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_tyzabncf()\n{\n    int data;\n    \n    data = 0;\n    switch(6)\n    {\n    case 6:\n        \n        data = 2;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n    {\n        \n        int result = data + 1;\n        printIntLine(result);\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\nvoid f_tjhslagt()\n{\n    f_htnsysgk();\n    f_wszvoiuy();\n    f_tuxyzamm();\n    f_tyzabncf();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_tjhslagt();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402516,
    "original_file": "testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_15.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nvoid f_ytrsiafp()\n{\n    int data;\n    \n    data = 0;\n    switch(6)\n    {\n    case 6:\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET connectSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            inputBuffer[recvResult] = '\\0';\n            \n            data = atoi(inputBuffer);\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n    {\n        \n        int result = data + 1;\n        printIntLine(result);\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ytrsiafp();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402517,
    "original_file": "testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_15.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nstatic int staticTrue = 1; \nstatic int staticFalse = 0; \n\n\n\n\nstatic void f_ppwwxmze()\n{\n    int data;\n    \n    data = 0;\n    if(staticTrue)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(staticFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data < INT_MAX)\n        {\n            ++data;\n            int result = data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_bxdbhtny()\n{\n    int data;\n    \n    data = 0;\n    if(staticTrue)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(staticTrue)\n    {\n        \n        if (data < INT_MAX)\n        {\n            ++data;\n            int result = data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_lytvthta()\n{\n    int data;\n    \n    data = 0;\n    if(staticFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        data = 2;\n    }\n    if(staticTrue)\n    {\n        {\n            \n            ++data;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\n\nstatic void f_jkinokuv()\n{\n    int data;\n    \n    data = 0;\n    if(staticTrue)\n    {\n        \n        data = 2;\n    }\n    if(staticTrue)\n    {\n        {\n            \n            ++data;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\nvoid f_mvqqezyn()\n{\n    f_ppwwxmze();\n    f_bxdbhtny();\n    f_lytvthta();\n    f_jkinokuv();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_mvqqezyn();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402518,
    "original_file": "testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_05.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nstatic int staticTrue = 1; \nstatic int staticFalse = 0; \n\n\nvoid f_gaxbowln()\n{\n    int data;\n    \n    data = 0;\n    if(staticTrue)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(staticTrue)\n    {\n        {\n            \n            ++data;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_gaxbowln();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402519,
    "original_file": "testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_05.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nstatic const int STATIC_CONST_TRUE = 1; \nstatic const int STATIC_CONST_FALSE = 0; \n\n\n\n\nstatic void f_vkbjrgjh()\n{\n    int data;\n    \n    data = 0;\n    if(STATIC_CONST_TRUE)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(STATIC_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data < INT_MAX)\n        {\n            ++data;\n            int result = data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_rqoebeqs()\n{\n    int data;\n    \n    data = 0;\n    if(STATIC_CONST_TRUE)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        \n        if (data < INT_MAX)\n        {\n            ++data;\n            int result = data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_wosempug()\n{\n    int data;\n    \n    data = 0;\n    if(STATIC_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        data = 2;\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            \n            ++data;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\n\nstatic void f_bcewjgjt()\n{\n    int data;\n    \n    data = 0;\n    if(STATIC_CONST_TRUE)\n    {\n        \n        data = 2;\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            \n            ++data;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\nvoid f_caosewyr()\n{\n    f_vkbjrgjh();\n    f_rqoebeqs();\n    f_wosempug();\n    f_bcewjgjt();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_caosewyr();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402520,
    "original_file": "testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_04.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nstatic const int STATIC_CONST_TRUE = 1; \nstatic const int STATIC_CONST_FALSE = 0; \n\n\nvoid f_cphktiiu()\n{\n    int data;\n    \n    data = 0;\n    if(STATIC_CONST_TRUE)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            \n            ++data;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_cphktiiu();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402521,
    "original_file": "testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_04.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nstatic int staticTrue = 1; \nstatic int staticFalse = 0; \n\n\n\n\nstatic void f_ttszzhlu()\n{\n    int data;\n    \n    data = 0;\n    if(staticTrue)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(staticFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data < INT_MAX)\n        {\n            data++;\n            int result = data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_bgnytjlr()\n{\n    int data;\n    \n    data = 0;\n    if(staticTrue)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(staticTrue)\n    {\n        \n        if (data < INT_MAX)\n        {\n            data++;\n            int result = data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_kmwrroir()\n{\n    int data;\n    \n    data = 0;\n    if(staticFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        data = 2;\n    }\n    if(staticTrue)\n    {\n        {\n            \n            data++;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\n\nstatic void f_hfnvxthv()\n{\n    int data;\n    \n    data = 0;\n    if(staticTrue)\n    {\n        \n        data = 2;\n    }\n    if(staticTrue)\n    {\n        {\n            \n            data++;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\nvoid f_ukuyzszm()\n{\n    f_ttszzhlu();\n    f_bgnytjlr();\n    f_kmwrroir();\n    f_hfnvxthv();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ukuyzszm();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402522,
    "original_file": "testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_05.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nstatic int staticTrue = 1; \nstatic int staticFalse = 0; \n\n\nvoid f_xxvjxapc()\n{\n    int data;\n    \n    data = 0;\n    if(staticTrue)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(staticTrue)\n    {\n        {\n            \n            data++;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_xxvjxapc();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402523,
    "original_file": "testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_05.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nstatic const int STATIC_CONST_TRUE = 1; \nstatic const int STATIC_CONST_FALSE = 0; \n\n\n\n\nstatic void f_ejufvkam()\n{\n    int data;\n    \n    data = 0;\n    if(STATIC_CONST_TRUE)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(STATIC_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data < INT_MAX)\n        {\n            data++;\n            int result = data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_lnoeqkix()\n{\n    int data;\n    \n    data = 0;\n    if(STATIC_CONST_TRUE)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        \n        if (data < INT_MAX)\n        {\n            data++;\n            int result = data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_tpoicdvs()\n{\n    int data;\n    \n    data = 0;\n    if(STATIC_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        data = 2;\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            \n            data++;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\n\nstatic void f_meaimazg()\n{\n    int data;\n    \n    data = 0;\n    if(STATIC_CONST_TRUE)\n    {\n        \n        data = 2;\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            \n            data++;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\nvoid f_tlwfrmei()\n{\n    f_ejufvkam();\n    f_lnoeqkix();\n    f_tpoicdvs();\n    f_meaimazg();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_tlwfrmei();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402524,
    "original_file": "testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_04.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nstatic const int STATIC_CONST_TRUE = 1; \nstatic const int STATIC_CONST_FALSE = 0; \n\n\nvoid f_utmkhmzn()\n{\n    int data;\n    \n    data = 0;\n    if(STATIC_CONST_TRUE)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            \n            data++;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_utmkhmzn();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402525,
    "original_file": "testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_04.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nstatic const int STATIC_CONST_FIVE = 5;\n\n\n\n\nstatic void f_ybjotsft()\n{\n    int data;\n    \n    data = 0;\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(STATIC_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data < INT_MAX)\n        {\n            ++data;\n            int result = data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_jjzsjpxa()\n{\n    int data;\n    \n    data = 0;\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        if (data < INT_MAX)\n        {\n            ++data;\n            int result = data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_mafmgaek()\n{\n    int data;\n    \n    data = 0;\n    if(STATIC_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        data = 2;\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            \n            ++data;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\n\nstatic void f_gxlcumwh()\n{\n    int data;\n    \n    data = 0;\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        data = 2;\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            \n            ++data;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\nvoid f_iswwvmbv()\n{\n    f_ybjotsft();\n    f_jjzsjpxa();\n    f_mafmgaek();\n    f_gxlcumwh();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_iswwvmbv();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402526,
    "original_file": "testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_06.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nstatic const int STATIC_CONST_FIVE = 5;\n\n\nvoid f_kmuzjvyy()\n{\n    int data;\n    \n    data = 0;\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            \n            ++data;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_kmuzjvyy();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402527,
    "original_file": "testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_06.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nstatic int staticFive = 5;\n\n\n\n\nstatic void f_ojeutvlo()\n{\n    int data;\n    \n    data = 0;\n    if(staticFive==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(staticFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data < INT_MAX)\n        {\n            ++data;\n            int result = data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_qqeqcqxp()\n{\n    int data;\n    \n    data = 0;\n    if(staticFive==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(staticFive==5)\n    {\n        \n        if (data < INT_MAX)\n        {\n            ++data;\n            int result = data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_ugjajrfh()\n{\n    int data;\n    \n    data = 0;\n    if(staticFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        data = 2;\n    }\n    if(staticFive==5)\n    {\n        {\n            \n            ++data;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\n\nstatic void f_fpqirlek()\n{\n    int data;\n    \n    data = 0;\n    if(staticFive==5)\n    {\n        \n        data = 2;\n    }\n    if(staticFive==5)\n    {\n        {\n            \n            ++data;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\nvoid f_wparwacn()\n{\n    f_ojeutvlo();\n    f_qqeqcqxp();\n    f_ugjajrfh();\n    f_fpqirlek();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_wparwacn();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402528,
    "original_file": "testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_07.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nstatic int staticFive = 5;\n\n\nvoid f_fcuheabv()\n{\n    int data;\n    \n    data = 0;\n    if(staticFive==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(staticFive==5)\n    {\n        {\n            \n            ++data;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_fcuheabv();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402529,
    "original_file": "testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_07.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nstatic const int STATIC_CONST_FIVE = 5;\n\n\n\n\nstatic void f_aaenwdyj()\n{\n    int data;\n    \n    data = 0;\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(STATIC_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data < INT_MAX)\n        {\n            data++;\n            int result = data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_vfeeftjz()\n{\n    int data;\n    \n    data = 0;\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        if (data < INT_MAX)\n        {\n            data++;\n            int result = data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_uzogutjr()\n{\n    int data;\n    \n    data = 0;\n    if(STATIC_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        data = 2;\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            \n            data++;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\n\nstatic void f_vmgxwsin()\n{\n    int data;\n    \n    data = 0;\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        data = 2;\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            \n            data++;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\nvoid f_glerynqx()\n{\n    f_aaenwdyj();\n    f_vfeeftjz();\n    f_uzogutjr();\n    f_vmgxwsin();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_glerynqx();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402530,
    "original_file": "testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_06.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nstatic const int STATIC_CONST_FIVE = 5;\n\n\nvoid f_jcvnagvq()\n{\n    int data;\n    \n    data = 0;\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            \n            data++;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_jcvnagvq();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402531,
    "original_file": "testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_06.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nstatic int staticFive = 5;\n\n\n\n\nstatic void f_skorcprg()\n{\n    int data;\n    \n    data = 0;\n    if(staticFive==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(staticFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data < INT_MAX)\n        {\n            data++;\n            int result = data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_bdjblmki()\n{\n    int data;\n    \n    data = 0;\n    if(staticFive==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(staticFive==5)\n    {\n        \n        if (data < INT_MAX)\n        {\n            data++;\n            int result = data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_dulspdfk()\n{\n    int data;\n    \n    data = 0;\n    if(staticFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        data = 2;\n    }\n    if(staticFive==5)\n    {\n        {\n            \n            data++;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\n\nstatic void f_gtfrwlvy()\n{\n    int data;\n    \n    data = 0;\n    if(staticFive==5)\n    {\n        \n        data = 2;\n    }\n    if(staticFive==5)\n    {\n        {\n            \n            data++;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\nvoid f_ifqasofp()\n{\n    f_skorcprg();\n    f_bdjblmki();\n    f_dulspdfk();\n    f_gtfrwlvy();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ifqasofp();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402532,
    "original_file": "testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_07.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nstatic int staticFive = 5;\n\n\nvoid f_pcynqmpn()\n{\n    int data;\n    \n    data = 0;\n    if(staticFive==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(staticFive==5)\n    {\n        {\n            \n            data++;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_pcynqmpn();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402533,
    "original_file": "testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_07.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\n\n\nstatic void f_nzdwdqsq()\n{\n    int data;\n    \n    data = 0;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        if(data > 0) \n        {\n            \n            if (data < (INT_MAX/2))\n            {\n                int result = data * 2;\n                printIntLine(result);\n            }\n            else\n            {\n                printLine(\"data value is too large to perform arithmetic safely.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_txsvbewl()\n{\n    int data;\n    \n    data = 0;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        if(data > 0) \n        {\n            \n            if (data < (INT_MAX/2))\n            {\n                int result = data * 2;\n                printIntLine(result);\n            }\n            else\n            {\n                printLine(\"data value is too large to perform arithmetic safely.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_cqvgoktw()\n{\n    int data;\n    \n    data = 0;\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        data = 2;\n    }\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        if(data > 0) \n        {\n            \n            int result = data * 2;\n            printIntLine(result);\n        }\n    }\n}\n\n\nstatic void f_euzkefai()\n{\n    int data;\n    \n    data = 0;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        \n        data = 2;\n    }\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        if(data > 0) \n        {\n            \n            int result = data * 2;\n            printIntLine(result);\n        }\n    }\n}\n\nvoid f_ghjspfmp()\n{\n    f_nzdwdqsq();\n    f_txsvbewl();\n    f_cqvgoktw();\n    f_euzkefai();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ghjspfmp();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402534,
    "original_file": "testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_13.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nvoid f_zvvjuovj()\n{\n    int data;\n    \n    data = 0;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        if(data > 0) \n        {\n            \n            int result = data * 2;\n            printIntLine(result);\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_zvvjuovj();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402535,
    "original_file": "testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_13.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\n\n\nstatic void f_arlyrcmg()\n{\n    int data;\n    \n    data = 0;\n    if(1)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(0)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        if(data > 0) \n        {\n            \n            if (data < (INT_MAX/2))\n            {\n                int result = data * 2;\n                printIntLine(result);\n            }\n            else\n            {\n                printLine(\"data value is too large to perform arithmetic safely.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_jblbwnbs()\n{\n    int data;\n    \n    data = 0;\n    if(1)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(1)\n    {\n        if(data > 0) \n        {\n            \n            if (data < (INT_MAX/2))\n            {\n                int result = data * 2;\n                printIntLine(result);\n            }\n            else\n            {\n                printLine(\"data value is too large to perform arithmetic safely.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_kmfrlayv()\n{\n    int data;\n    \n    data = 0;\n    if(0)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        data = 2;\n    }\n    if(1)\n    {\n        if(data > 0) \n        {\n            \n            int result = data * 2;\n            printIntLine(result);\n        }\n    }\n}\n\n\nstatic void f_zqtvyjgj()\n{\n    int data;\n    \n    data = 0;\n    if(1)\n    {\n        \n        data = 2;\n    }\n    if(1)\n    {\n        if(data > 0) \n        {\n            \n            int result = data * 2;\n            printIntLine(result);\n        }\n    }\n}\n\nvoid f_pnxzhguo()\n{\n    f_arlyrcmg();\n    f_jblbwnbs();\n    f_kmfrlayv();\n    f_zqtvyjgj();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_pnxzhguo();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402536,
    "original_file": "testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_02.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nvoid f_tiqpigrk()\n{\n    int data;\n    \n    data = 0;\n    if(1)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(1)\n    {\n        if(data > 0) \n        {\n            \n            int result = data * 2;\n            printIntLine(result);\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_tiqpigrk();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402537,
    "original_file": "testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_02.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\n\n\nstatic void f_uromfvtn()\n{\n    int data;\n    \n    data = 0;\n    if(globalTrue)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(globalFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        if(data > 0) \n        {\n            \n            if (data < (INT_MAX/2))\n            {\n                int result = data * 2;\n                printIntLine(result);\n            }\n            else\n            {\n                printLine(\"data value is too large to perform arithmetic safely.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_ecendabn()\n{\n    int data;\n    \n    data = 0;\n    if(globalTrue)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(globalTrue)\n    {\n        if(data > 0) \n        {\n            \n            if (data < (INT_MAX/2))\n            {\n                int result = data * 2;\n                printIntLine(result);\n            }\n            else\n            {\n                printLine(\"data value is too large to perform arithmetic safely.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_xveqhwfk()\n{\n    int data;\n    \n    data = 0;\n    if(globalFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        data = 2;\n    }\n    if(globalTrue)\n    {\n        if(data > 0) \n        {\n            \n            int result = data * 2;\n            printIntLine(result);\n        }\n    }\n}\n\n\nstatic void f_tshcggdq()\n{\n    int data;\n    \n    data = 0;\n    if(globalTrue)\n    {\n        \n        data = 2;\n    }\n    if(globalTrue)\n    {\n        if(data > 0) \n        {\n            \n            int result = data * 2;\n            printIntLine(result);\n        }\n    }\n}\n\nvoid f_lonlugbq()\n{\n    f_uromfvtn();\n    f_ecendabn();\n    f_xveqhwfk();\n    f_tshcggdq();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_lonlugbq();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402538,
    "original_file": "testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_10.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nvoid f_wvsnqkxa()\n{\n    int data;\n    \n    data = 0;\n    if(globalTrue)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(globalTrue)\n    {\n        if(data > 0) \n        {\n            \n            int result = data * 2;\n            printIntLine(result);\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_wvsnqkxa();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402539,
    "original_file": "testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_10.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\n\n\nstatic void f_pepcekqd()\n{\n    int data;\n    \n    data = 0;\n    if(globalFive==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(globalFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        if(data > 0) \n        {\n            \n            if (data < (INT_MAX/2))\n            {\n                int result = data * 2;\n                printIntLine(result);\n            }\n            else\n            {\n                printLine(\"data value is too large to perform arithmetic safely.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_peibhoyv()\n{\n    int data;\n    \n    data = 0;\n    if(globalFive==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(globalFive==5)\n    {\n        if(data > 0) \n        {\n            \n            if (data < (INT_MAX/2))\n            {\n                int result = data * 2;\n                printIntLine(result);\n            }\n            else\n            {\n                printLine(\"data value is too large to perform arithmetic safely.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_nyxwblvm()\n{\n    int data;\n    \n    data = 0;\n    if(globalFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        data = 2;\n    }\n    if(globalFive==5)\n    {\n        if(data > 0) \n        {\n            \n            int result = data * 2;\n            printIntLine(result);\n        }\n    }\n}\n\n\nstatic void f_atikrfjd()\n{\n    int data;\n    \n    data = 0;\n    if(globalFive==5)\n    {\n        \n        data = 2;\n    }\n    if(globalFive==5)\n    {\n        if(data > 0) \n        {\n            \n            int result = data * 2;\n            printIntLine(result);\n        }\n    }\n}\n\nvoid f_movwxsru()\n{\n    f_pepcekqd();\n    f_peibhoyv();\n    f_nyxwblvm();\n    f_atikrfjd();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_movwxsru();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402540,
    "original_file": "testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_14.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nvoid f_rimeptvl()\n{\n    int data;\n    \n    data = 0;\n    if(globalFive==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(globalFive==5)\n    {\n        if(data > 0) \n        {\n            \n            int result = data * 2;\n            printIntLine(result);\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_rimeptvl();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402541,
    "original_file": "testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_14.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\n\n\nstatic void f_nxybvhql()\n{\n    int data;\n    \n    data = 0;\n    if(5==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(5!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        if(data > 0) \n        {\n            \n            if (data < (INT_MAX/2))\n            {\n                int result = data * 2;\n                printIntLine(result);\n            }\n            else\n            {\n                printLine(\"data value is too large to perform arithmetic safely.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_jdvwoghh()\n{\n    int data;\n    \n    data = 0;\n    if(5==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(5==5)\n    {\n        if(data > 0) \n        {\n            \n            if (data < (INT_MAX/2))\n            {\n                int result = data * 2;\n                printIntLine(result);\n            }\n            else\n            {\n                printLine(\"data value is too large to perform arithmetic safely.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_headdqeg()\n{\n    int data;\n    \n    data = 0;\n    if(5!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        data = 2;\n    }\n    if(5==5)\n    {\n        if(data > 0) \n        {\n            \n            int result = data * 2;\n            printIntLine(result);\n        }\n    }\n}\n\n\nstatic void f_wjflcmnz()\n{\n    int data;\n    \n    data = 0;\n    if(5==5)\n    {\n        \n        data = 2;\n    }\n    if(5==5)\n    {\n        if(data > 0) \n        {\n            \n            int result = data * 2;\n            printIntLine(result);\n        }\n    }\n}\n\nvoid f_mokzvott()\n{\n    f_nxybvhql();\n    f_jdvwoghh();\n    f_headdqeg();\n    f_wjflcmnz();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_mokzvott();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402542,
    "original_file": "testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_03.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nvoid f_mvtbzqgw()\n{\n    int data;\n    \n    data = 0;\n    if(5==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(5==5)\n    {\n        if(data > 0) \n        {\n            \n            int result = data * 2;\n            printIntLine(result);\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_mvtbzqgw();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402543,
    "original_file": "testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_03.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\n\n\nstatic void f_powhctpq()\n{\n    int data;\n    \n    data = 0;\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(GLOBAL_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        if(data > 0) \n        {\n            \n            if (data < (INT_MAX/2))\n            {\n                int result = data * 2;\n                printIntLine(result);\n            }\n            else\n            {\n                printLine(\"data value is too large to perform arithmetic safely.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_oogjhcix()\n{\n    int data;\n    \n    data = 0;\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(GLOBAL_CONST_TRUE)\n    {\n        if(data > 0) \n        {\n            \n            if (data < (INT_MAX/2))\n            {\n                int result = data * 2;\n                printIntLine(result);\n            }\n            else\n            {\n                printLine(\"data value is too large to perform arithmetic safely.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_skmgntij()\n{\n    int data;\n    \n    data = 0;\n    if(GLOBAL_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        data = 2;\n    }\n    if(GLOBAL_CONST_TRUE)\n    {\n        if(data > 0) \n        {\n            \n            int result = data * 2;\n            printIntLine(result);\n        }\n    }\n}\n\n\nstatic void f_krbnnkmj()\n{\n    int data;\n    \n    data = 0;\n    if(GLOBAL_CONST_TRUE)\n    {\n        \n        data = 2;\n    }\n    if(GLOBAL_CONST_TRUE)\n    {\n        if(data > 0) \n        {\n            \n            int result = data * 2;\n            printIntLine(result);\n        }\n    }\n}\n\nvoid f_mbepmsmb()\n{\n    f_powhctpq();\n    f_oogjhcix();\n    f_skmgntij();\n    f_krbnnkmj();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_mbepmsmb();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402544,
    "original_file": "testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_09.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nvoid f_abocjkze()\n{\n    int data;\n    \n    data = 0;\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(GLOBAL_CONST_TRUE)\n    {\n        if(data > 0) \n        {\n            \n            int result = data * 2;\n            printIntLine(result);\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_abocjkze();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402545,
    "original_file": "testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_09.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\n\n\nstatic void f_svfkonjl()\n{\n    int data;\n    \n    data = 0;\n    if(globalReturnsTrue())\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(globalReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        if(data > 0) \n        {\n            \n            if (data < (INT_MAX/2))\n            {\n                int result = data * 2;\n                printIntLine(result);\n            }\n            else\n            {\n                printLine(\"data value is too large to perform arithmetic safely.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_qxplljqk()\n{\n    int data;\n    \n    data = 0;\n    if(globalReturnsTrue())\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(globalReturnsTrue())\n    {\n        if(data > 0) \n        {\n            \n            if (data < (INT_MAX/2))\n            {\n                int result = data * 2;\n                printIntLine(result);\n            }\n            else\n            {\n                printLine(\"data value is too large to perform arithmetic safely.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_nekpvvaa()\n{\n    int data;\n    \n    data = 0;\n    if(globalReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        data = 2;\n    }\n    if(globalReturnsTrue())\n    {\n        if(data > 0) \n        {\n            \n            int result = data * 2;\n            printIntLine(result);\n        }\n    }\n}\n\n\nstatic void f_sytkltso()\n{\n    int data;\n    \n    data = 0;\n    if(globalReturnsTrue())\n    {\n        \n        data = 2;\n    }\n    if(globalReturnsTrue())\n    {\n        if(data > 0) \n        {\n            \n            int result = data * 2;\n            printIntLine(result);\n        }\n    }\n}\n\nvoid f_sgatxyqt()\n{\n    f_svfkonjl();\n    f_qxplljqk();\n    f_nekpvvaa();\n    f_sytkltso();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_sgatxyqt();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402546,
    "original_file": "testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_11.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nvoid f_ygizqbgh()\n{\n    int data;\n    \n    data = 0;\n    if(globalReturnsTrue())\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(globalReturnsTrue())\n    {\n        if(data > 0) \n        {\n            \n            int result = data * 2;\n            printIntLine(result);\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ygizqbgh();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402547,
    "original_file": "testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_11.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n#include <math.h>\n\n\nstatic const int STATIC_CONST_TRUE = 1; \nstatic const int STATIC_CONST_FALSE = 0; \n\n\n\n\nstatic void f_whekpuaw()\n{\n    int data;\n    \n    data = 0;\n    if(STATIC_CONST_TRUE)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(STATIC_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data > INT_MIN && abs(data) < (long)sqrt((double)INT_MAX))\n        {\n            int result = data * data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_ztmiucxi()\n{\n    int data;\n    \n    data = 0;\n    if(STATIC_CONST_TRUE)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        \n        if (data > INT_MIN && abs(data) < (long)sqrt((double)INT_MAX))\n        {\n            int result = data * data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_qmvmnoet()\n{\n    int data;\n    \n    data = 0;\n    if(STATIC_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        data = 2;\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            \n            int result = data * data;\n            printIntLine(result);\n        }\n    }\n}\n\n\nstatic void f_fehhxhad()\n{\n    int data;\n    \n    data = 0;\n    if(STATIC_CONST_TRUE)\n    {\n        \n        data = 2;\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            \n            int result = data * data;\n            printIntLine(result);\n        }\n    }\n}\n\nvoid f_kbpeuewo()\n{\n    f_whekpuaw();\n    f_ztmiucxi();\n    f_qmvmnoet();\n    f_fehhxhad();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_kbpeuewo();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402548,
    "original_file": "testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_04.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n#include <math.h>\n\n\nstatic const int STATIC_CONST_TRUE = 1; \nstatic const int STATIC_CONST_FALSE = 0; \n\n\nvoid f_pfofmkaz()\n{\n    int data;\n    \n    data = 0;\n    if(STATIC_CONST_TRUE)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            \n            int result = data * data;\n            printIntLine(result);\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_pfofmkaz();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402549,
    "original_file": "testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_04.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n#include <math.h>\n\n\nstatic int staticTrue = 1; \nstatic int staticFalse = 0; \n\n\n\n\nstatic void f_hrtiwyok()\n{\n    int data;\n    \n    data = 0;\n    if(staticTrue)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(staticFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data > INT_MIN && abs(data) < (long)sqrt((double)INT_MAX))\n        {\n            int result = data * data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_yssnjxfs()\n{\n    int data;\n    \n    data = 0;\n    if(staticTrue)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(staticTrue)\n    {\n        \n        if (data > INT_MIN && abs(data) < (long)sqrt((double)INT_MAX))\n        {\n            int result = data * data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_abdxhdyk()\n{\n    int data;\n    \n    data = 0;\n    if(staticFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        data = 2;\n    }\n    if(staticTrue)\n    {\n        {\n            \n            int result = data * data;\n            printIntLine(result);\n        }\n    }\n}\n\n\nstatic void f_uzyljlve()\n{\n    int data;\n    \n    data = 0;\n    if(staticTrue)\n    {\n        \n        data = 2;\n    }\n    if(staticTrue)\n    {\n        {\n            \n            int result = data * data;\n            printIntLine(result);\n        }\n    }\n}\n\nvoid f_gtmngohf()\n{\n    f_hrtiwyok();\n    f_yssnjxfs();\n    f_abdxhdyk();\n    f_uzyljlve();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_gtmngohf();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402550,
    "original_file": "testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_05.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n#include <math.h>\n\n\nstatic int staticTrue = 1; \nstatic int staticFalse = 0; \n\n\nvoid f_avqbfyhw()\n{\n    int data;\n    \n    data = 0;\n    if(staticTrue)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(staticTrue)\n    {\n        {\n            \n            int result = data * data;\n            printIntLine(result);\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_avqbfyhw();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402551,
    "original_file": "testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_05.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n#include <math.h>\n\n\nstatic const int STATIC_CONST_FIVE = 5;\n\n\n\n\nstatic void f_eaozmnvc()\n{\n    int data;\n    \n    data = 0;\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(STATIC_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data > INT_MIN && abs(data) < (long)sqrt((double)INT_MAX))\n        {\n            int result = data * data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_tlgaqqlc()\n{\n    int data;\n    \n    data = 0;\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        if (data > INT_MIN && abs(data) < (long)sqrt((double)INT_MAX))\n        {\n            int result = data * data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_pswntdmy()\n{\n    int data;\n    \n    data = 0;\n    if(STATIC_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        data = 2;\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            \n            int result = data * data;\n            printIntLine(result);\n        }\n    }\n}\n\n\nstatic void f_hkclyqfe()\n{\n    int data;\n    \n    data = 0;\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        data = 2;\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            \n            int result = data * data;\n            printIntLine(result);\n        }\n    }\n}\n\nvoid f_icqocuxv()\n{\n    f_eaozmnvc();\n    f_tlgaqqlc();\n    f_pswntdmy();\n    f_hkclyqfe();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_icqocuxv();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402552,
    "original_file": "testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_06.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n#include <math.h>\n\n\nstatic const int STATIC_CONST_FIVE = 5;\n\n\nvoid f_typwlbtj()\n{\n    int data;\n    \n    data = 0;\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            \n            int result = data * data;\n            printIntLine(result);\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_typwlbtj();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402553,
    "original_file": "testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_06.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n#include <math.h>\n\n\nstatic int staticFive = 5;\n\n\n\n\nstatic void f_bfcioqbd()\n{\n    int data;\n    \n    data = 0;\n    if(staticFive==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(staticFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data > INT_MIN && abs(data) < (long)sqrt((double)INT_MAX))\n        {\n            int result = data * data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_fxdoqwea()\n{\n    int data;\n    \n    data = 0;\n    if(staticFive==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(staticFive==5)\n    {\n        \n        if (data > INT_MIN && abs(data) < (long)sqrt((double)INT_MAX))\n        {\n            int result = data * data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_axkuzadh()\n{\n    int data;\n    \n    data = 0;\n    if(staticFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        data = 2;\n    }\n    if(staticFive==5)\n    {\n        {\n            \n            int result = data * data;\n            printIntLine(result);\n        }\n    }\n}\n\n\nstatic void f_uvyvetbb()\n{\n    int data;\n    \n    data = 0;\n    if(staticFive==5)\n    {\n        \n        data = 2;\n    }\n    if(staticFive==5)\n    {\n        {\n            \n            int result = data * data;\n            printIntLine(result);\n        }\n    }\n}\n\nvoid f_nydsenwn()\n{\n    f_bfcioqbd();\n    f_fxdoqwea();\n    f_axkuzadh();\n    f_uvyvetbb();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_nydsenwn();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402554,
    "original_file": "testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_07.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n#include <math.h>\n\n\nstatic int staticFive = 5;\n\n\nvoid f_milprrmi()\n{\n    int data;\n    \n    data = 0;\n    if(staticFive==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(staticFive==5)\n    {\n        {\n            \n            int result = data * data;\n            printIntLine(result);\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_milprrmi();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402555,
    "original_file": "testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_07.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nstatic const int STATIC_CONST_TRUE = 1; \nstatic const int STATIC_CONST_FALSE = 0; \n\n\n\n\nstatic void f_bvgeauro()\n{\n    int data;\n    \n    data = 0;\n    if(STATIC_CONST_TRUE)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(STATIC_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data < INT_MAX)\n        {\n            int result = data + 1;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_sgtpupeq()\n{\n    int data;\n    \n    data = 0;\n    if(STATIC_CONST_TRUE)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        \n        if (data < INT_MAX)\n        {\n            int result = data + 1;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_yngeaycm()\n{\n    int data;\n    \n    data = 0;\n    if(STATIC_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        data = 2;\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            \n            int result = data + 1;\n            printIntLine(result);\n        }\n    }\n}\n\n\nstatic void f_ggyimatj()\n{\n    int data;\n    \n    data = 0;\n    if(STATIC_CONST_TRUE)\n    {\n        \n        data = 2;\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            \n            int result = data + 1;\n            printIntLine(result);\n        }\n    }\n}\n\nvoid f_ldbrecyi()\n{\n    f_bvgeauro();\n    f_sgtpupeq();\n    f_yngeaycm();\n    f_ggyimatj();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ldbrecyi();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402556,
    "original_file": "testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_04.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nstatic const int STATIC_CONST_TRUE = 1; \nstatic const int STATIC_CONST_FALSE = 0; \n\n\nvoid f_eldnekzq()\n{\n    int data;\n    \n    data = 0;\n    if(STATIC_CONST_TRUE)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            \n            int result = data + 1;\n            printIntLine(result);\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_eldnekzq();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402557,
    "original_file": "testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_04.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nstatic int staticTrue = 1; \nstatic int staticFalse = 0; \n\n\n\n\nstatic void f_gwpdmhzx()\n{\n    int data;\n    \n    data = 0;\n    if(staticTrue)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(staticFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data < INT_MAX)\n        {\n            int result = data + 1;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_tccnlmcr()\n{\n    int data;\n    \n    data = 0;\n    if(staticTrue)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(staticTrue)\n    {\n        \n        if (data < INT_MAX)\n        {\n            int result = data + 1;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_dqvmgxvc()\n{\n    int data;\n    \n    data = 0;\n    if(staticFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        data = 2;\n    }\n    if(staticTrue)\n    {\n        {\n            \n            int result = data + 1;\n            printIntLine(result);\n        }\n    }\n}\n\n\nstatic void f_jqjyeowb()\n{\n    int data;\n    \n    data = 0;\n    if(staticTrue)\n    {\n        \n        data = 2;\n    }\n    if(staticTrue)\n    {\n        {\n            \n            int result = data + 1;\n            printIntLine(result);\n        }\n    }\n}\n\nvoid f_kdkiuiqq()\n{\n    f_gwpdmhzx();\n    f_tccnlmcr();\n    f_dqvmgxvc();\n    f_jqjyeowb();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_kdkiuiqq();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402558,
    "original_file": "testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_05.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nstatic int staticTrue = 1; \nstatic int staticFalse = 0; \n\n\nvoid f_jfqwhfob()\n{\n    int data;\n    \n    data = 0;\n    if(staticTrue)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(staticTrue)\n    {\n        {\n            \n            int result = data + 1;\n            printIntLine(result);\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_jfqwhfob();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402559,
    "original_file": "testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_05.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\n\n\nstatic void f_axxpgeqa()\n{\n    int data;\n    \n    data = 0;\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    else\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(globalReturnsTrueOrFalse())\n    {\n        if(data > 0) \n        {\n            \n            if (data < (INT_MAX/2))\n            {\n                int result = data * 2;\n                printIntLine(result);\n            }\n            else\n            {\n                printLine(\"data value is too large to perform arithmetic safely.\");\n            }\n        }\n    }\n    else\n    {\n        if(data > 0) \n        {\n            \n            if (data < (INT_MAX/2))\n            {\n                int result = data * 2;\n                printIntLine(result);\n            }\n            else\n            {\n                printLine(\"data value is too large to perform arithmetic safely.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_xtbumnsv()\n{\n    int data;\n    \n    data = 0;\n    if(globalReturnsTrueOrFalse())\n    {\n        \n        data = 2;\n    }\n    else\n    {\n        \n        data = 2;\n    }\n    if(globalReturnsTrueOrFalse())\n    {\n        if(data > 0) \n        {\n            \n            int result = data * 2;\n            printIntLine(result);\n        }\n    }\n    else\n    {\n        if(data > 0) \n        {\n            \n            int result = data * 2;\n            printIntLine(result);\n        }\n    }\n}\n\nvoid f_qkjleoth()\n{\n    f_axxpgeqa();\n    f_xtbumnsv();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_qkjleoth();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402560,
    "original_file": "testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_12.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nvoid f_ikupfdld()\n{\n    int data;\n    \n    data = 0;\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    else\n    {\n        \n        data = 2;\n    }\n    if(globalReturnsTrueOrFalse())\n    {\n        if(data > 0) \n        {\n            \n            int result = data * 2;\n            printIntLine(result);\n        }\n    }\n    else\n    {\n        if(data > 0) \n        {\n            \n            if (data < (INT_MAX/2))\n            {\n                int result = data * 2;\n                printIntLine(result);\n            }\n            else\n            {\n                printLine(\"data value is too large to perform arithmetic safely.\");\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ikupfdld();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402561,
    "original_file": "testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_12.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nstatic int staticFive = 5;\n\n\n\n\nstatic void f_jiyhtcjr()\n{\n    int data;\n    \n    data = 0;\n    if(staticFive==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(staticFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data < INT_MAX)\n        {\n            int result = data + 1;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_zzbftxif()\n{\n    int data;\n    \n    data = 0;\n    if(staticFive==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(staticFive==5)\n    {\n        \n        if (data < INT_MAX)\n        {\n            int result = data + 1;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_kakmdkhb()\n{\n    int data;\n    \n    data = 0;\n    if(staticFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        data = 2;\n    }\n    if(staticFive==5)\n    {\n        {\n            \n            int result = data + 1;\n            printIntLine(result);\n        }\n    }\n}\n\n\nstatic void f_clwryvsr()\n{\n    int data;\n    \n    data = 0;\n    if(staticFive==5)\n    {\n        \n        data = 2;\n    }\n    if(staticFive==5)\n    {\n        {\n            \n            int result = data + 1;\n            printIntLine(result);\n        }\n    }\n}\n\nvoid f_pzqklsxa()\n{\n    f_jiyhtcjr();\n    f_zzbftxif();\n    f_kakmdkhb();\n    f_clwryvsr();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_pzqklsxa();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402562,
    "original_file": "testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_07.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nstatic int staticFive = 5;\n\n\nvoid f_qzdqgzee()\n{\n    int data;\n    \n    data = 0;\n    if(staticFive==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(staticFive==5)\n    {\n        {\n            \n            int result = data + 1;\n            printIntLine(result);\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_qzdqgzee();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402563,
    "original_file": "testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_07.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nstatic const int STATIC_CONST_FIVE = 5;\n\n\n\n\nstatic void f_jbalffis()\n{\n    int data;\n    \n    data = 0;\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(STATIC_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data < INT_MAX)\n        {\n            int result = data + 1;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_vjzzbnli()\n{\n    int data;\n    \n    data = 0;\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        if (data < INT_MAX)\n        {\n            int result = data + 1;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_ipcngylu()\n{\n    int data;\n    \n    data = 0;\n    if(STATIC_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        data = 2;\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            \n            int result = data + 1;\n            printIntLine(result);\n        }\n    }\n}\n\n\nstatic void f_bkxewgcw()\n{\n    int data;\n    \n    data = 0;\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        data = 2;\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            \n            int result = data + 1;\n            printIntLine(result);\n        }\n    }\n}\n\nvoid f_iiempbzj()\n{\n    f_jbalffis();\n    f_vjzzbnli();\n    f_ipcngylu();\n    f_bkxewgcw();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_iiempbzj();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402564,
    "original_file": "testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_06.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nstatic const int STATIC_CONST_FIVE = 5;\n\n\nvoid f_lfvofaqu()\n{\n    int data;\n    \n    data = 0;\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            \n            int result = data + 1;\n            printIntLine(result);\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_lfvofaqu();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402565,
    "original_file": "testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_06.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\n\n\nstatic void f_saahxhdn()\n{\n    int data;\n    \n    data = 0;\n    if(globalFive==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(globalFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data < INT_MAX)\n        {\n            ++data;\n            int result = data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_eztnklnj()\n{\n    int data;\n    \n    data = 0;\n    if(globalFive==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(globalFive==5)\n    {\n        \n        if (data < INT_MAX)\n        {\n            ++data;\n            int result = data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_lixjqsce()\n{\n    int data;\n    \n    data = 0;\n    if(globalFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        data = 2;\n    }\n    if(globalFive==5)\n    {\n        {\n            \n            ++data;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\n\nstatic void f_nnjdkbyj()\n{\n    int data;\n    \n    data = 0;\n    if(globalFive==5)\n    {\n        \n        data = 2;\n    }\n    if(globalFive==5)\n    {\n        {\n            \n            ++data;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\nvoid f_osnanswq()\n{\n    f_saahxhdn();\n    f_eztnklnj();\n    f_lixjqsce();\n    f_nnjdkbyj();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_osnanswq();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402566,
    "original_file": "testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_14.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nvoid f_tanpspih()\n{\n    int data;\n    \n    data = 0;\n    if(globalFive==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(globalFive==5)\n    {\n        {\n            \n            ++data;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_tanpspih();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402567,
    "original_file": "testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_14.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\n\n\nstatic void f_bfroynki()\n{\n    int data;\n    \n    data = 0;\n    if(1)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(0)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data < INT_MAX)\n        {\n            ++data;\n            int result = data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_bddrtuol()\n{\n    int data;\n    \n    data = 0;\n    if(1)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(1)\n    {\n        \n        if (data < INT_MAX)\n        {\n            ++data;\n            int result = data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_jxcegnff()\n{\n    int data;\n    \n    data = 0;\n    if(0)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        data = 2;\n    }\n    if(1)\n    {\n        {\n            \n            ++data;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\n\nstatic void f_veqplzff()\n{\n    int data;\n    \n    data = 0;\n    if(1)\n    {\n        \n        data = 2;\n    }\n    if(1)\n    {\n        {\n            \n            ++data;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\nvoid f_txvthctm()\n{\n    f_bfroynki();\n    f_bddrtuol();\n    f_jxcegnff();\n    f_veqplzff();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_txvthctm();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402568,
    "original_file": "testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_02.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nvoid f_enpaicgy()\n{\n    int data;\n    \n    data = 0;\n    if(1)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(1)\n    {\n        {\n            \n            ++data;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_enpaicgy();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402569,
    "original_file": "testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_02.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\n\n\nstatic void f_lmblunzo()\n{\n    int data;\n    \n    data = 0;\n    if(globalReturnsTrue())\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(globalReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data < INT_MAX)\n        {\n            ++data;\n            int result = data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_lmtjdrgv()\n{\n    int data;\n    \n    data = 0;\n    if(globalReturnsTrue())\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(globalReturnsTrue())\n    {\n        \n        if (data < INT_MAX)\n        {\n            ++data;\n            int result = data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_zntclrge()\n{\n    int data;\n    \n    data = 0;\n    if(globalReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        data = 2;\n    }\n    if(globalReturnsTrue())\n    {\n        {\n            \n            ++data;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\n\nstatic void f_oxyvayvj()\n{\n    int data;\n    \n    data = 0;\n    if(globalReturnsTrue())\n    {\n        \n        data = 2;\n    }\n    if(globalReturnsTrue())\n    {\n        {\n            \n            ++data;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\nvoid f_hbekwtup()\n{\n    f_lmblunzo();\n    f_lmtjdrgv();\n    f_zntclrge();\n    f_oxyvayvj();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_hbekwtup();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402570,
    "original_file": "testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_11.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nvoid f_tilqxupc()\n{\n    int data;\n    \n    data = 0;\n    if(globalReturnsTrue())\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(globalReturnsTrue())\n    {\n        {\n            \n            ++data;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_tilqxupc();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402571,
    "original_file": "testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_11.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\n\n\nstatic void f_cwfanhhc()\n{\n    int data;\n    \n    data = 0;\n    if(globalTrue)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(globalFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data < INT_MAX)\n        {\n            ++data;\n            int result = data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_exwsyjad()\n{\n    int data;\n    \n    data = 0;\n    if(globalTrue)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(globalTrue)\n    {\n        \n        if (data < INT_MAX)\n        {\n            ++data;\n            int result = data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_wnnwrixf()\n{\n    int data;\n    \n    data = 0;\n    if(globalFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        data = 2;\n    }\n    if(globalTrue)\n    {\n        {\n            \n            ++data;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\n\nstatic void f_ewaanawi()\n{\n    int data;\n    \n    data = 0;\n    if(globalTrue)\n    {\n        \n        data = 2;\n    }\n    if(globalTrue)\n    {\n        {\n            \n            ++data;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\nvoid f_xaikxonm()\n{\n    f_cwfanhhc();\n    f_exwsyjad();\n    f_wnnwrixf();\n    f_ewaanawi();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_xaikxonm();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402572,
    "original_file": "testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_10.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nvoid f_aznyuzdb()\n{\n    int data;\n    \n    data = 0;\n    if(globalTrue)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(globalTrue)\n    {\n        {\n            \n            ++data;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_aznyuzdb();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402573,
    "original_file": "testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_10.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\n\n\nstatic void f_iumaefug()\n{\n    int data;\n    \n    data = 0;\n    if(5==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(5!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data < INT_MAX)\n        {\n            ++data;\n            int result = data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_ivykndka()\n{\n    int data;\n    \n    data = 0;\n    if(5==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(5==5)\n    {\n        \n        if (data < INT_MAX)\n        {\n            ++data;\n            int result = data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_lqvzahuz()\n{\n    int data;\n    \n    data = 0;\n    if(5!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        data = 2;\n    }\n    if(5==5)\n    {\n        {\n            \n            ++data;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\n\nstatic void f_dqvaelha()\n{\n    int data;\n    \n    data = 0;\n    if(5==5)\n    {\n        \n        data = 2;\n    }\n    if(5==5)\n    {\n        {\n            \n            ++data;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\nvoid f_oqdbytln()\n{\n    f_iumaefug();\n    f_ivykndka();\n    f_lqvzahuz();\n    f_dqvaelha();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_oqdbytln();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402574,
    "original_file": "testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_03.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nvoid f_nfqgmzja()\n{\n    int data;\n    \n    data = 0;\n    if(5==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(5==5)\n    {\n        {\n            \n            ++data;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_nfqgmzja();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402575,
    "original_file": "testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_03.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\n\n\nstatic void f_sundnzfj()\n{\n    int data;\n    \n    data = 0;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data < INT_MAX)\n        {\n            ++data;\n            int result = data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_odktmwyf()\n{\n    int data;\n    \n    data = 0;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        \n        if (data < INT_MAX)\n        {\n            ++data;\n            int result = data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_vsvlqyro()\n{\n    int data;\n    \n    data = 0;\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        data = 2;\n    }\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            \n            ++data;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\n\nstatic void f_fmiixdsa()\n{\n    int data;\n    \n    data = 0;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        \n        data = 2;\n    }\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            \n            ++data;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\nvoid f_cnzvggpt()\n{\n    f_sundnzfj();\n    f_odktmwyf();\n    f_vsvlqyro();\n    f_fmiixdsa();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_cnzvggpt();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402576,
    "original_file": "testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_13.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nvoid f_dqpfwspk()\n{\n    int data;\n    \n    data = 0;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            \n            ++data;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_dqpfwspk();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402577,
    "original_file": "testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_13.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\n\n\nstatic void f_lugptcst()\n{\n    int data;\n    \n    data = 0;\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(GLOBAL_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data < INT_MAX)\n        {\n            ++data;\n            int result = data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_dnxsukgm()\n{\n    int data;\n    \n    data = 0;\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(GLOBAL_CONST_TRUE)\n    {\n        \n        if (data < INT_MAX)\n        {\n            ++data;\n            int result = data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_fmwhjpwv()\n{\n    int data;\n    \n    data = 0;\n    if(GLOBAL_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        data = 2;\n    }\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            \n            ++data;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\n\nstatic void f_siijfjsk()\n{\n    int data;\n    \n    data = 0;\n    if(GLOBAL_CONST_TRUE)\n    {\n        \n        data = 2;\n    }\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            \n            ++data;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\nvoid f_dyqubnic()\n{\n    f_lugptcst();\n    f_dnxsukgm();\n    f_fmwhjpwv();\n    f_siijfjsk();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_dyqubnic();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402578,
    "original_file": "testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_09.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nvoid f_vxjuzfoc()\n{\n    int data;\n    \n    data = 0;\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            \n            ++data;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_vxjuzfoc();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402579,
    "original_file": "testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_09.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\n\n\nstatic void f_qubhvanz()\n{\n    int data;\n    \n    data = 0;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data < INT_MAX)\n        {\n            data++;\n            int result = data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_nwsfirrv()\n{\n    int data;\n    \n    data = 0;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        \n        if (data < INT_MAX)\n        {\n            data++;\n            int result = data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_xhhayylj()\n{\n    int data;\n    \n    data = 0;\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        data = 2;\n    }\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            \n            data++;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\n\nstatic void f_iyyjzxww()\n{\n    int data;\n    \n    data = 0;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        \n        data = 2;\n    }\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            \n            data++;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\nvoid f_yqriofqj()\n{\n    f_qubhvanz();\n    f_nwsfirrv();\n    f_xhhayylj();\n    f_iyyjzxww();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_yqriofqj();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402580,
    "original_file": "testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_13.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nvoid f_lfriqwtv()\n{\n    int data;\n    \n    data = 0;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            \n            data++;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_lfriqwtv();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402581,
    "original_file": "testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_13.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\n\n\nstatic void f_nwjirqhz()\n{\n    int data;\n    \n    data = 0;\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(GLOBAL_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data < INT_MAX)\n        {\n            data++;\n            int result = data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_apktqqvj()\n{\n    int data;\n    \n    data = 0;\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(GLOBAL_CONST_TRUE)\n    {\n        \n        if (data < INT_MAX)\n        {\n            data++;\n            int result = data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_icjfuygx()\n{\n    int data;\n    \n    data = 0;\n    if(GLOBAL_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        data = 2;\n    }\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            \n            data++;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\n\nstatic void f_svaphall()\n{\n    int data;\n    \n    data = 0;\n    if(GLOBAL_CONST_TRUE)\n    {\n        \n        data = 2;\n    }\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            \n            data++;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\nvoid f_ivmbcpws()\n{\n    f_nwjirqhz();\n    f_apktqqvj();\n    f_icjfuygx();\n    f_svaphall();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ivmbcpws();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402582,
    "original_file": "testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_09.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nvoid f_afxvtolv()\n{\n    int data;\n    \n    data = 0;\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            \n            data++;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_afxvtolv();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402583,
    "original_file": "testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_09.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\n\n\nstatic void f_wsqcjirv()\n{\n    int data;\n    \n    data = 0;\n    if(globalFive==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(globalFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data < INT_MAX)\n        {\n            data++;\n            int result = data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_wvtegcgm()\n{\n    int data;\n    \n    data = 0;\n    if(globalFive==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(globalFive==5)\n    {\n        \n        if (data < INT_MAX)\n        {\n            data++;\n            int result = data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_qbaavduj()\n{\n    int data;\n    \n    data = 0;\n    if(globalFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        data = 2;\n    }\n    if(globalFive==5)\n    {\n        {\n            \n            data++;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\n\nstatic void f_czpbnocv()\n{\n    int data;\n    \n    data = 0;\n    if(globalFive==5)\n    {\n        \n        data = 2;\n    }\n    if(globalFive==5)\n    {\n        {\n            \n            data++;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\nvoid f_xqrgmyyl()\n{\n    f_wsqcjirv();\n    f_wvtegcgm();\n    f_qbaavduj();\n    f_czpbnocv();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_xqrgmyyl();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402584,
    "original_file": "testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_14.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nvoid f_lqejsouu()\n{\n    int data;\n    \n    data = 0;\n    if(globalFive==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(globalFive==5)\n    {\n        {\n            \n            data++;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_lqejsouu();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402585,
    "original_file": "testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_14.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\n\n\nstatic void f_uqqxvcsu()\n{\n    int data;\n    \n    data = 0;\n    if(globalReturnsTrue())\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(globalReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data < INT_MAX)\n        {\n            data++;\n            int result = data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_orxyflgf()\n{\n    int data;\n    \n    data = 0;\n    if(globalReturnsTrue())\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(globalReturnsTrue())\n    {\n        \n        if (data < INT_MAX)\n        {\n            data++;\n            int result = data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_pvdxswns()\n{\n    int data;\n    \n    data = 0;\n    if(globalReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        data = 2;\n    }\n    if(globalReturnsTrue())\n    {\n        {\n            \n            data++;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\n\nstatic void f_klzlhswm()\n{\n    int data;\n    \n    data = 0;\n    if(globalReturnsTrue())\n    {\n        \n        data = 2;\n    }\n    if(globalReturnsTrue())\n    {\n        {\n            \n            data++;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\nvoid f_pfavtdab()\n{\n    f_uqqxvcsu();\n    f_orxyflgf();\n    f_pvdxswns();\n    f_klzlhswm();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_pfavtdab();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402586,
    "original_file": "testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_11.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nvoid f_woggghvy()\n{\n    int data;\n    \n    data = 0;\n    if(globalReturnsTrue())\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(globalReturnsTrue())\n    {\n        {\n            \n            data++;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_woggghvy();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402587,
    "original_file": "testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_11.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\n\n\nstatic void f_qxcquhgt()\n{\n    int data;\n    \n    data = 0;\n    if(globalTrue)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(globalFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data < INT_MAX)\n        {\n            data++;\n            int result = data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_kyncniiw()\n{\n    int data;\n    \n    data = 0;\n    if(globalTrue)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(globalTrue)\n    {\n        \n        if (data < INT_MAX)\n        {\n            data++;\n            int result = data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_cmdaoosc()\n{\n    int data;\n    \n    data = 0;\n    if(globalFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        data = 2;\n    }\n    if(globalTrue)\n    {\n        {\n            \n            data++;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\n\nstatic void f_tczsarhy()\n{\n    int data;\n    \n    data = 0;\n    if(globalTrue)\n    {\n        \n        data = 2;\n    }\n    if(globalTrue)\n    {\n        {\n            \n            data++;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\nvoid f_imjnxlbr()\n{\n    f_qxcquhgt();\n    f_kyncniiw();\n    f_cmdaoosc();\n    f_tczsarhy();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_imjnxlbr();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402588,
    "original_file": "testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_10.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nvoid f_lstwuial()\n{\n    int data;\n    \n    data = 0;\n    if(globalTrue)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(globalTrue)\n    {\n        {\n            \n            data++;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_lstwuial();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402589,
    "original_file": "testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_10.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\n\n\nstatic void f_gakypkmb()\n{\n    int data;\n    \n    data = 0;\n    if(5==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(5!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data < INT_MAX)\n        {\n            data++;\n            int result = data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_uduhkmym()\n{\n    int data;\n    \n    data = 0;\n    if(5==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(5==5)\n    {\n        \n        if (data < INT_MAX)\n        {\n            data++;\n            int result = data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_mrmvxxgl()\n{\n    int data;\n    \n    data = 0;\n    if(5!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        data = 2;\n    }\n    if(5==5)\n    {\n        {\n            \n            data++;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\n\nstatic void f_hochornv()\n{\n    int data;\n    \n    data = 0;\n    if(5==5)\n    {\n        \n        data = 2;\n    }\n    if(5==5)\n    {\n        {\n            \n            data++;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\nvoid f_conylwup()\n{\n    f_gakypkmb();\n    f_uduhkmym();\n    f_mrmvxxgl();\n    f_hochornv();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_conylwup();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402590,
    "original_file": "testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_03.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nvoid f_mxahcqtl()\n{\n    int data;\n    \n    data = 0;\n    if(5==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(5==5)\n    {\n        {\n            \n            data++;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_mxahcqtl();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402591,
    "original_file": "testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_03.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\n\n\nstatic void f_hstrtdep()\n{\n    int data;\n    \n    data = 0;\n    if(1)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(0)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data < INT_MAX)\n        {\n            data++;\n            int result = data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_onwlfycl()\n{\n    int data;\n    \n    data = 0;\n    if(1)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(1)\n    {\n        \n        if (data < INT_MAX)\n        {\n            data++;\n            int result = data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_eacjwovu()\n{\n    int data;\n    \n    data = 0;\n    if(0)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        data = 2;\n    }\n    if(1)\n    {\n        {\n            \n            data++;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\n\nstatic void f_eiryjcgn()\n{\n    int data;\n    \n    data = 0;\n    if(1)\n    {\n        \n        data = 2;\n    }\n    if(1)\n    {\n        {\n            \n            data++;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\nvoid f_nbmloycy()\n{\n    f_hstrtdep();\n    f_onwlfycl();\n    f_eacjwovu();\n    f_eiryjcgn();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_nbmloycy();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402592,
    "original_file": "testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_02.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n\nvoid f_gcegazxo()\n{\n    int data;\n    \n    data = 0;\n    if(1)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(1)\n    {\n        {\n            \n            data++;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_gcegazxo();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402593,
    "original_file": "testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_02.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n#include <math.h>\n\n\n\n\nstatic void f_yxwunsdb()\n{\n    int data;\n    \n    data = 0;\n    if(globalFive==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(globalFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data > INT_MIN && abs(data) < (long)sqrt((double)INT_MAX))\n        {\n            int result = data * data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_wqmhuwjh()\n{\n    int data;\n    \n    data = 0;\n    if(globalFive==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(globalFive==5)\n    {\n        \n        if (data > INT_MIN && abs(data) < (long)sqrt((double)INT_MAX))\n        {\n            int result = data * data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_nkrrzrun()\n{\n    int data;\n    \n    data = 0;\n    if(globalFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        data = 2;\n    }\n    if(globalFive==5)\n    {\n        {\n            \n            int result = data * data;\n            printIntLine(result);\n        }\n    }\n}\n\n\nstatic void f_katqvvrz()\n{\n    int data;\n    \n    data = 0;\n    if(globalFive==5)\n    {\n        \n        data = 2;\n    }\n    if(globalFive==5)\n    {\n        {\n            \n            int result = data * data;\n            printIntLine(result);\n        }\n    }\n}\n\nvoid f_nxzixlex()\n{\n    f_yxwunsdb();\n    f_wqmhuwjh();\n    f_nkrrzrun();\n    f_katqvvrz();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_nxzixlex();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402594,
    "original_file": "testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_14.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n#include <math.h>\n\n\nvoid f_vategvsk()\n{\n    int data;\n    \n    data = 0;\n    if(globalFive==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(globalFive==5)\n    {\n        {\n            \n            int result = data * data;\n            printIntLine(result);\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_vategvsk();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402595,
    "original_file": "testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_14.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n#include <math.h>\n\n\n\n\nstatic void f_aygmhuzl()\n{\n    int data;\n    \n    data = 0;\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(GLOBAL_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data > INT_MIN && abs(data) < (long)sqrt((double)INT_MAX))\n        {\n            int result = data * data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_ggrkchgs()\n{\n    int data;\n    \n    data = 0;\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(GLOBAL_CONST_TRUE)\n    {\n        \n        if (data > INT_MIN && abs(data) < (long)sqrt((double)INT_MAX))\n        {\n            int result = data * data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_enkaqbin()\n{\n    int data;\n    \n    data = 0;\n    if(GLOBAL_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        data = 2;\n    }\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            \n            int result = data * data;\n            printIntLine(result);\n        }\n    }\n}\n\n\nstatic void f_sffjjjor()\n{\n    int data;\n    \n    data = 0;\n    if(GLOBAL_CONST_TRUE)\n    {\n        \n        data = 2;\n    }\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            \n            int result = data * data;\n            printIntLine(result);\n        }\n    }\n}\n\nvoid f_wehxkltq()\n{\n    f_aygmhuzl();\n    f_ggrkchgs();\n    f_enkaqbin();\n    f_sffjjjor();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_wehxkltq();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402596,
    "original_file": "testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_09.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n#include <math.h>\n\n\nvoid f_qlmbxybh()\n{\n    int data;\n    \n    data = 0;\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            \n            int result = data * data;\n            printIntLine(result);\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_qlmbxybh();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402597,
    "original_file": "testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_09.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n#include <math.h>\n\n\n\n\nstatic void f_fzmzlgkj()\n{\n    int data;\n    \n    data = 0;\n    if(globalTrue)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(globalFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data > INT_MIN && abs(data) < (long)sqrt((double)INT_MAX))\n        {\n            int result = data * data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_fzneqnez()\n{\n    int data;\n    \n    data = 0;\n    if(globalTrue)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(globalTrue)\n    {\n        \n        if (data > INT_MIN && abs(data) < (long)sqrt((double)INT_MAX))\n        {\n            int result = data * data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_ffibfnch()\n{\n    int data;\n    \n    data = 0;\n    if(globalFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        data = 2;\n    }\n    if(globalTrue)\n    {\n        {\n            \n            int result = data * data;\n            printIntLine(result);\n        }\n    }\n}\n\n\nstatic void f_swrsnyxu()\n{\n    int data;\n    \n    data = 0;\n    if(globalTrue)\n    {\n        \n        data = 2;\n    }\n    if(globalTrue)\n    {\n        {\n            \n            int result = data * data;\n            printIntLine(result);\n        }\n    }\n}\n\nvoid f_wtbrgsoq()\n{\n    f_fzmzlgkj();\n    f_fzneqnez();\n    f_ffibfnch();\n    f_swrsnyxu();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_wtbrgsoq();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402598,
    "original_file": "testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_10.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n#include <math.h>\n\n\nvoid f_mnuqscfy()\n{\n    int data;\n    \n    data = 0;\n    if(globalTrue)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(globalTrue)\n    {\n        {\n            \n            int result = data * data;\n            printIntLine(result);\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_mnuqscfy();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402599,
    "original_file": "testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_10.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n#include <math.h>\n\n\n\n\nstatic void f_zmbejqpb()\n{\n    int data;\n    \n    data = 0;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data > INT_MIN && abs(data) < (long)sqrt((double)INT_MAX))\n        {\n            int result = data * data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_ximwjrrp()\n{\n    int data;\n    \n    data = 0;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        \n        if (data > INT_MIN && abs(data) < (long)sqrt((double)INT_MAX))\n        {\n            int result = data * data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_cqpeybyx()\n{\n    int data;\n    \n    data = 0;\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        data = 2;\n    }\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            \n            int result = data * data;\n            printIntLine(result);\n        }\n    }\n}\n\n\nstatic void f_dmpgfbee()\n{\n    int data;\n    \n    data = 0;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        \n        data = 2;\n    }\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            \n            int result = data * data;\n            printIntLine(result);\n        }\n    }\n}\n\nvoid f_jnpxvjlj()\n{\n    f_zmbejqpb();\n    f_ximwjrrp();\n    f_cqpeybyx();\n    f_dmpgfbee();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_jnpxvjlj();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402600,
    "original_file": "testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_13.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n#include <math.h>\n\n\nvoid f_tsxukzyt()\n{\n    int data;\n    \n    data = 0;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            \n            int result = data * data;\n            printIntLine(result);\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_tsxukzyt();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402601,
    "original_file": "testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_13.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n#include <math.h>\n\n\n\n\nstatic void f_agehafsi()\n{\n    int data;\n    \n    data = 0;\n    if(5==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(5!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data > INT_MIN && abs(data) < (long)sqrt((double)INT_MAX))\n        {\n            int result = data * data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_ezimpezj()\n{\n    int data;\n    \n    data = 0;\n    if(5==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(5==5)\n    {\n        \n        if (data > INT_MIN && abs(data) < (long)sqrt((double)INT_MAX))\n        {\n            int result = data * data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n\nstatic void f_rpxfavza()\n{\n    int data;\n    \n    data = 0;\n    if(5!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        data = 2;\n    }\n    if(5==5)\n    {\n        {\n            \n            int result = data * data;\n            printIntLine(result);\n        }\n    }\n}\n\n\nstatic void f_yknnbbrt()\n{\n    int data;\n    \n    data = 0;\n    if(5==5)\n    {\n        \n        data = 2;\n    }\n    if(5==5)\n    {\n        {\n            \n            int result = data * data;\n            printIntLine(result);\n        }\n    }\n}\n\nvoid f_fytisapd()\n{\n    f_agehafsi();\n    f_ezimpezj();\n    f_rpxfavza();\n    f_yknnbbrt();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_fytisapd();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402602,
    "original_file": "testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_03.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\n#include <math.h>\n\n\nvoid f_ruvezjro()\n{\n    int data;\n    \n    data = 0;\n    if(5==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(5==5)\n    {\n        {\n            \n            int result = data * data;\n            printIntLine(result);\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ruvezjro();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 402603,
    "original_file": "testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_03.c",
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "int ring_buffer_resize(struct ring_buffer *buffer, unsigned long size,\n\t\t\tint cpu_id)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tunsigned long nr_pages;\n\tint cpu, err = 0;\n\n\t/*\n\t * Always succeed at resizing a non-existent buffer:\n\t */\n\tif (!buffer)\n\t\treturn size;\n\n\t/* Make sure the requested buffer exists */\n\tif (cpu_id != RING_BUFFER_ALL_CPUS &&\n\t    !cpumask_test_cpu(cpu_id, buffer->cpumask))\n\t\treturn size;\n\n\tsize = DIV_ROUND_UP(size, BUF_PAGE_SIZE);\n\tsize *= BUF_PAGE_SIZE;\n\n\t/* we need a minimum of two pages */\n\tif (size < BUF_PAGE_SIZE * 2)\n\t\tsize = BUF_PAGE_SIZE * 2;\n\n\tnr_pages = DIV_ROUND_UP(size, BUF_PAGE_SIZE);\n\n\t/*\n\t * Don't succeed if resizing is disabled, as a reader might be\n\t * manipulating the ring buffer and is expecting a sane state while\n\t * this is true.\n\t */\n\tif (atomic_read(&buffer->resize_disabled))\n\t\treturn -EBUSY;\n\n\t/* prevent another thread from changing buffer sizes */\n\tmutex_lock(&buffer->mutex);\n\n\tif (cpu_id == RING_BUFFER_ALL_CPUS) {\n\t\t/* calculate the pages to update */\n\t\tfor_each_buffer_cpu(buffer, cpu) {\n\t\t\tcpu_buffer = buffer->buffers[cpu];\n\n\t\t\tcpu_buffer->nr_pages_to_update = nr_pages -\n\t\t\t\t\t\t\tcpu_buffer->nr_pages;\n\t\t\t/*\n\t\t\t * nothing more to do for removing pages or no update\n\t\t\t */\n\t\t\tif (cpu_buffer->nr_pages_to_update <= 0)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * to add pages, make sure all new pages can be\n\t\t\t * allocated without receiving ENOMEM\n\t\t\t */\n\t\t\tINIT_LIST_HEAD(&cpu_buffer->new_pages);\n\t\t\tif (__rb_allocate_pages(cpu_buffer->nr_pages_to_update,\n\t\t\t\t\t\t&cpu_buffer->new_pages, cpu)) {\n\t\t\t\t/* not enough memory for new pages */\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out_err;\n\t\t\t}\n\t\t}\n\n\t\tget_online_cpus();\n\t\t/*\n\t\t * Fire off all the required work handlers\n\t\t * We can't schedule on offline CPUs, but it's not necessary\n\t\t * since we can change their buffer sizes without any race.\n\t\t */\n\t\tfor_each_buffer_cpu(buffer, cpu) {\n\t\t\tcpu_buffer = buffer->buffers[cpu];\n\t\t\tif (!cpu_buffer->nr_pages_to_update)\n\t\t\t\tcontinue;\n\n\t\t\t/* Can't run something on an offline CPU. */\n\t\t\tif (!cpu_online(cpu)) {\n\t\t\t\trb_update_pages(cpu_buffer);\n\t\t\t\tcpu_buffer->nr_pages_to_update = 0;\n\t\t\t} else {\n\t\t\t\tschedule_work_on(cpu,\n\t\t\t\t\t\t&cpu_buffer->update_pages_work);\n\t\t\t}\n\t\t}\n\n\t\t/* wait for all the updates to complete */\n\t\tfor_each_buffer_cpu(buffer, cpu) {\n\t\t\tcpu_buffer = buffer->buffers[cpu];\n\t\t\tif (!cpu_buffer->nr_pages_to_update)\n\t\t\t\tcontinue;\n\n\t\t\tif (cpu_online(cpu))\n\t\t\t\twait_for_completion(&cpu_buffer->update_done);\n\t\t\tcpu_buffer->nr_pages_to_update = 0;\n\t\t}\n\n\t\tput_online_cpus();\n\t} else {\n\t\t/* Make sure this CPU has been intitialized */\n\t\tif (!cpumask_test_cpu(cpu_id, buffer->cpumask))\n\t\t\tgoto out;\n\n\t\tcpu_buffer = buffer->buffers[cpu_id];\n\n\t\tif (nr_pages == cpu_buffer->nr_pages)\n\t\t\tgoto out;\n\n\t\tcpu_buffer->nr_pages_to_update = nr_pages -\n\t\t\t\t\t\tcpu_buffer->nr_pages;\n\n\t\tINIT_LIST_HEAD(&cpu_buffer->new_pages);\n\t\tif (cpu_buffer->nr_pages_to_update > 0 &&\n\t\t\t__rb_allocate_pages(cpu_buffer->nr_pages_to_update,\n\t\t\t\t\t    &cpu_buffer->new_pages, cpu_id)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tget_online_cpus();\n\n\t\t/* Can't run something on an offline CPU. */\n\t\tif (!cpu_online(cpu_id))\n\t\t\trb_update_pages(cpu_buffer);\n\t\telse {\n\t\t\tschedule_work_on(cpu_id,\n\t\t\t\t\t &cpu_buffer->update_pages_work);\n\t\t\twait_for_completion(&cpu_buffer->update_done);\n\t\t}\n\n\t\tcpu_buffer->nr_pages_to_update = 0;\n\t\tput_online_cpus();\n\t}\n\n out:\n\t/*\n\t * The ring buffer resize can happen with the ring buffer\n\t * enabled, so that the update disturbs the tracing as little\n\t * as possible. But if the buffer is disabled, we do not need\n\t * to worry about that, and we can take the time to verify\n\t * that the buffer is not corrupt.\n\t */\n\tif (atomic_read(&buffer->record_disabled)) {\n\t\tatomic_inc(&buffer->record_disabled);\n\t\t/*\n\t\t * Even though the buffer was disabled, we must make sure\n\t\t * that it is truly disabled before calling rb_check_pages.\n\t\t * There could have been a race between checking\n\t\t * record_disable and incrementing it.\n\t\t */\n\t\tsynchronize_sched();\n\t\tfor_each_buffer_cpu(buffer, cpu) {\n\t\t\tcpu_buffer = buffer->buffers[cpu];\n\t\t\trb_check_pages(cpu_buffer);\n\t\t}\n\t\tatomic_dec(&buffer->record_disabled);\n\t}\n\n\tmutex_unlock(&buffer->mutex);\n\treturn size;\n\n out_err:\n\tfor_each_buffer_cpu(buffer, cpu) {\n\t\tstruct buffer_page *bpage, *tmp;\n\n\t\tcpu_buffer = buffer->buffers[cpu];\n\t\tcpu_buffer->nr_pages_to_update = 0;\n\n\t\tif (list_empty(&cpu_buffer->new_pages))\n\t\t\tcontinue;\n\n\t\tlist_for_each_entry_safe(bpage, tmp, &cpu_buffer->new_pages,\n\t\t\t\t\tlist) {\n\t\t\tlist_del_init(&bpage->list);\n\t\t\tfree_buffer_page(bpage);\n\t\t}\n\t}\n\tmutex_unlock(&buffer->mutex);\n\treturn err;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149758,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "int ring_buffer_resize(struct ring_buffer *buffer, unsigned long size,\n\t\t\tint cpu_id)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tunsigned long nr_pages;\n\tint cpu, err = 0;\n\n\t/*\n\t * Always succeed at resizing a non-existent buffer:\n\t */\n\tif (!buffer)\n\t\treturn size;\n\n\t/* Make sure the requested buffer exists */\n\tif (cpu_id != RING_BUFFER_ALL_CPUS &&\n\t    !cpumask_test_cpu(cpu_id, buffer->cpumask))\n\t\treturn size;\n\n\tnr_pages = DIV_ROUND_UP(size, BUF_PAGE_SIZE);\n\n\t/* we need a minimum of two pages */\n\tif (nr_pages < 2)\n\t\tnr_pages = 2;\n\n\tsize = nr_pages * BUF_PAGE_SIZE;\n\n\t/*\n\t * Don't succeed if resizing is disabled, as a reader might be\n\t * manipulating the ring buffer and is expecting a sane state while\n\t * this is true.\n\t */\n\tif (atomic_read(&buffer->resize_disabled))\n\t\treturn -EBUSY;\n\n\t/* prevent another thread from changing buffer sizes */\n\tmutex_lock(&buffer->mutex);\n\n\tif (cpu_id == RING_BUFFER_ALL_CPUS) {\n\t\t/* calculate the pages to update */\n\t\tfor_each_buffer_cpu(buffer, cpu) {\n\t\t\tcpu_buffer = buffer->buffers[cpu];\n\n\t\t\tcpu_buffer->nr_pages_to_update = nr_pages -\n\t\t\t\t\t\t\tcpu_buffer->nr_pages;\n\t\t\t/*\n\t\t\t * nothing more to do for removing pages or no update\n\t\t\t */\n\t\t\tif (cpu_buffer->nr_pages_to_update <= 0)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * to add pages, make sure all new pages can be\n\t\t\t * allocated without receiving ENOMEM\n\t\t\t */\n\t\t\tINIT_LIST_HEAD(&cpu_buffer->new_pages);\n\t\t\tif (__rb_allocate_pages(cpu_buffer->nr_pages_to_update,\n\t\t\t\t\t\t&cpu_buffer->new_pages, cpu)) {\n\t\t\t\t/* not enough memory for new pages */\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out_err;\n\t\t\t}\n\t\t}\n\n\t\tget_online_cpus();\n\t\t/*\n\t\t * Fire off all the required work handlers\n\t\t * We can't schedule on offline CPUs, but it's not necessary\n\t\t * since we can change their buffer sizes without any race.\n\t\t */\n\t\tfor_each_buffer_cpu(buffer, cpu) {\n\t\t\tcpu_buffer = buffer->buffers[cpu];\n\t\t\tif (!cpu_buffer->nr_pages_to_update)\n\t\t\t\tcontinue;\n\n\t\t\t/* Can't run something on an offline CPU. */\n\t\t\tif (!cpu_online(cpu)) {\n\t\t\t\trb_update_pages(cpu_buffer);\n\t\t\t\tcpu_buffer->nr_pages_to_update = 0;\n\t\t\t} else {\n\t\t\t\tschedule_work_on(cpu,\n\t\t\t\t\t\t&cpu_buffer->update_pages_work);\n\t\t\t}\n\t\t}\n\n\t\t/* wait for all the updates to complete */\n\t\tfor_each_buffer_cpu(buffer, cpu) {\n\t\t\tcpu_buffer = buffer->buffers[cpu];\n\t\t\tif (!cpu_buffer->nr_pages_to_update)\n\t\t\t\tcontinue;\n\n\t\t\tif (cpu_online(cpu))\n\t\t\t\twait_for_completion(&cpu_buffer->update_done);\n\t\t\tcpu_buffer->nr_pages_to_update = 0;\n\t\t}\n\n\t\tput_online_cpus();\n\t} else {\n\t\t/* Make sure this CPU has been intitialized */\n\t\tif (!cpumask_test_cpu(cpu_id, buffer->cpumask))\n\t\t\tgoto out;\n\n\t\tcpu_buffer = buffer->buffers[cpu_id];\n\n\t\tif (nr_pages == cpu_buffer->nr_pages)\n\t\t\tgoto out;\n\n\t\tcpu_buffer->nr_pages_to_update = nr_pages -\n\t\t\t\t\t\tcpu_buffer->nr_pages;\n\n\t\tINIT_LIST_HEAD(&cpu_buffer->new_pages);\n\t\tif (cpu_buffer->nr_pages_to_update > 0 &&\n\t\t\t__rb_allocate_pages(cpu_buffer->nr_pages_to_update,\n\t\t\t\t\t    &cpu_buffer->new_pages, cpu_id)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tget_online_cpus();\n\n\t\t/* Can't run something on an offline CPU. */\n\t\tif (!cpu_online(cpu_id))\n\t\t\trb_update_pages(cpu_buffer);\n\t\telse {\n\t\t\tschedule_work_on(cpu_id,\n\t\t\t\t\t &cpu_buffer->update_pages_work);\n\t\t\twait_for_completion(&cpu_buffer->update_done);\n\t\t}\n\n\t\tcpu_buffer->nr_pages_to_update = 0;\n\t\tput_online_cpus();\n\t}\n\n out:\n\t/*\n\t * The ring buffer resize can happen with the ring buffer\n\t * enabled, so that the update disturbs the tracing as little\n\t * as possible. But if the buffer is disabled, we do not need\n\t * to worry about that, and we can take the time to verify\n\t * that the buffer is not corrupt.\n\t */\n\tif (atomic_read(&buffer->record_disabled)) {\n\t\tatomic_inc(&buffer->record_disabled);\n\t\t/*\n\t\t * Even though the buffer was disabled, we must make sure\n\t\t * that it is truly disabled before calling rb_check_pages.\n\t\t * There could have been a race between checking\n\t\t * record_disable and incrementing it.\n\t\t */\n\t\tsynchronize_sched();\n\t\tfor_each_buffer_cpu(buffer, cpu) {\n\t\t\tcpu_buffer = buffer->buffers[cpu];\n\t\t\trb_check_pages(cpu_buffer);\n\t\t}\n\t\tatomic_dec(&buffer->record_disabled);\n\t}\n\n\tmutex_unlock(&buffer->mutex);\n\treturn size;\n\n out_err:\n\tfor_each_buffer_cpu(buffer, cpu) {\n\t\tstruct buffer_page *bpage, *tmp;\n\n\t\tcpu_buffer = buffer->buffers[cpu];\n\t\tcpu_buffer->nr_pages_to_update = 0;\n\n\t\tif (list_empty(&cpu_buffer->new_pages))\n\t\t\tcontinue;\n\n\t\tlist_for_each_entry_safe(bpage, tmp, &cpu_buffer->new_pages,\n\t\t\t\t\tlist) {\n\t\t\tlist_del_init(&bpage->list);\n\t\t\tfree_buffer_page(bpage);\n\t\t}\n\t}\n\tmutex_unlock(&buffer->mutex);\n\treturn err;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149759,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static pngquant_error rwpng_read_image24_libpng(FILE *infile, png24_image *mainprog_ptr, int verbose)\n{\n    png_structp  png_ptr = NULL;\n    png_infop    info_ptr = NULL;\n    png_size_t   rowbytes;\n    int          color_type, bit_depth;\n\n    png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, mainprog_ptr,\n      rwpng_error_handler, verbose ? rwpng_warning_stderr_handler : rwpng_warning_silent_handler);\n    if (!png_ptr) {\n        return PNG_OUT_OF_MEMORY_ERROR;   /* out of memory */\n    }\n\n    info_ptr = png_create_info_struct(png_ptr);\n    if (!info_ptr) {\n        png_destroy_read_struct(&png_ptr, NULL, NULL);\n        return PNG_OUT_OF_MEMORY_ERROR;   /* out of memory */\n    }\n\n    /* setjmp() must be called in every function that calls a non-trivial\n     * libpng function */\n\n    if (setjmp(mainprog_ptr->jmpbuf)) {\n        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);\n        return LIBPNG_FATAL_ERROR;   /* fatal libpng error (via longjmp()) */\n    }\n\n#if defined(PNG_SKIP_sRGB_CHECK_PROFILE) && defined(PNG_SET_OPTION_SUPPORTED)\n    png_set_option(png_ptr, PNG_SKIP_sRGB_CHECK_PROFILE, PNG_OPTION_ON);\n#endif\n\n#if PNG_LIBPNG_VER >= 10500 && defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)\n    /* copy standard chunks too */\n    png_set_keep_unknown_chunks(png_ptr, PNG_HANDLE_CHUNK_IF_SAFE, (png_const_bytep)\"pHYs\\0iTXt\\0tEXt\\0zTXt\", 4);\n#endif\n    png_set_read_user_chunk_fn(png_ptr, &mainprog_ptr->chunks, read_chunk_callback);\n\n    struct rwpng_read_data read_data = {infile, 0};\n    png_set_read_fn(png_ptr, &read_data, user_read_data);\n\n    png_read_info(png_ptr, info_ptr);  /* read all PNG info up to image data */\n\n    /* alternatively, could make separate calls to png_get_image_width(),\n     * etc., but want bit_depth and color_type for later [don't care about\n     * compression_type and filter_type => NULLs] */\n\n    png_get_IHDR(png_ptr, info_ptr, &mainprog_ptr->width, &mainprog_ptr->height,\n                 &bit_depth, &color_type, NULL, NULL, NULL);\n\n    // For overflow safety reject images that won't fit in 32-bit\n    if (mainprog_ptr->width > INT_MAX/mainprog_ptr->height) {\n        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);\n        return PNG_OUT_OF_MEMORY_ERROR;  /* not quite true, but whatever */\n    }\n\n    /* expand palette images to RGB, low-bit-depth grayscale images to 8 bits,\n     * transparency chunks to full alpha channel; strip 16-bit-per-sample\n     * images to 8 bits per sample; and convert grayscale to RGB[A] */\n\n    /* GRR TO DO:  preserve all safe-to-copy ancillary PNG chunks */\n\n    if (!(color_type & PNG_COLOR_MASK_ALPHA)) {\n#ifdef PNG_READ_FILLER_SUPPORTED\n        png_set_expand(png_ptr);\n        png_set_filler(png_ptr, 65535L, PNG_FILLER_AFTER);\n#else\n        fprintf(stderr, \"pngquant readpng:  image is neither RGBA nor GA\\n\");\n        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);\n        mainprog_ptr->retval = WRONG_INPUT_COLOR_TYPE;\n        return mainprog_ptr->retval;\n#endif\n    }\n\n    if (bit_depth == 16) {\n        png_set_strip_16(png_ptr);\n    }\n\n    if (!(color_type & PNG_COLOR_MASK_COLOR)) {\n        png_set_gray_to_rgb(png_ptr);\n    }\n\n    /* get source gamma for gamma correction, or use sRGB default */\n    double gamma = 0.45455;\n    if (png_get_valid(png_ptr, info_ptr, PNG_INFO_sRGB)) {\n        mainprog_ptr->input_color = RWPNG_SRGB;\n        mainprog_ptr->output_color = RWPNG_SRGB;\n    } else {\n        png_get_gAMA(png_ptr, info_ptr, &gamma);\n        if (gamma > 0 && gamma <= 1.0) {\n            mainprog_ptr->input_color = RWPNG_GAMA_ONLY;\n            mainprog_ptr->output_color = RWPNG_GAMA_ONLY;\n        } else {\n            fprintf(stderr, \"pngquant readpng:  ignored out-of-range gamma %f\\n\", gamma);\n            mainprog_ptr->input_color = RWPNG_NONE;\n            mainprog_ptr->output_color = RWPNG_NONE;\n            gamma = 0.45455;\n        }\n    }\n    mainprog_ptr->gamma = gamma;\n\n    png_set_interlace_handling(png_ptr);\n\n    /* all transformations have been registered; now update info_ptr data,\n     * get rowbytes and channels, and allocate image memory */\n\n    png_read_update_info(png_ptr, info_ptr);\n\n    rowbytes = png_get_rowbytes(png_ptr, info_ptr);\n\n    if ((mainprog_ptr->rgba_data = malloc(rowbytes * mainprog_ptr->height)) == NULL) {\n        fprintf(stderr, \"pngquant readpng:  unable to allocate image data\\n\");\n        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);\n        return PNG_OUT_OF_MEMORY_ERROR;\n    }\n\n    png_bytepp row_pointers = rwpng_create_row_pointers(info_ptr, png_ptr, mainprog_ptr->rgba_data, mainprog_ptr->height, 0);\n\n    /* now we can go ahead and just read the whole image */\n\n    png_read_image(png_ptr, row_pointers);\n\n    /* and we're done!  (png_read_end() can be omitted if no processing of\n     * post-IDAT text/time/etc. is desired) */\n\n    png_read_end(png_ptr, NULL);\n\n#if USE_LCMS\n#if PNG_LIBPNG_VER < 10500\n    png_charp ProfileData;\n#else\n    png_bytep ProfileData;\n#endif\n    png_uint_32 ProfileLen;\n\n    cmsHPROFILE hInProfile = NULL;\n\n    /* color_type is read from the image before conversion to RGBA */\n    int COLOR_PNG = color_type & PNG_COLOR_MASK_COLOR;\n\n    /* embedded ICC profile */\n    if (png_get_iCCP(png_ptr, info_ptr, &(png_charp){0}, &(int){0}, &ProfileData, &ProfileLen)) {\n\n        hInProfile = cmsOpenProfileFromMem(ProfileData, ProfileLen);\n        cmsColorSpaceSignature colorspace = cmsGetColorSpace(hInProfile);\n\n        /* only RGB (and GRAY) valid for PNGs */\n        if (colorspace == cmsSigRgbData && COLOR_PNG) {\n            mainprog_ptr->input_color = RWPNG_ICCP;\n            mainprog_ptr->output_color = RWPNG_SRGB;\n        } else {\n            if (colorspace == cmsSigGrayData && !COLOR_PNG) {\n                mainprog_ptr->input_color = RWPNG_ICCP_WARN_GRAY;\n                mainprog_ptr->output_color = RWPNG_SRGB;\n            }\n            cmsCloseProfile(hInProfile);\n            hInProfile = NULL;\n        }\n    }\n\n    /* build RGB profile from cHRM and gAMA */\n    if (hInProfile == NULL && COLOR_PNG &&\n        !png_get_valid(png_ptr, info_ptr, PNG_INFO_sRGB) &&\n        png_get_valid(png_ptr, info_ptr, PNG_INFO_gAMA) &&\n        png_get_valid(png_ptr, info_ptr, PNG_INFO_cHRM)) {\n\n        cmsCIExyY WhitePoint;\n        cmsCIExyYTRIPLE Primaries;\n\n        png_get_cHRM(png_ptr, info_ptr, &WhitePoint.x, &WhitePoint.y,\n                     &Primaries.Red.x, &Primaries.Red.y,\n                     &Primaries.Green.x, &Primaries.Green.y,\n                     &Primaries.Blue.x, &Primaries.Blue.y);\n\n        WhitePoint.Y = Primaries.Red.Y = Primaries.Green.Y = Primaries.Blue.Y = 1.0;\n\n        cmsToneCurve *GammaTable[3];\n        GammaTable[0] = GammaTable[1] = GammaTable[2] = cmsBuildGamma(NULL, 1/gamma);\n\n        hInProfile = cmsCreateRGBProfile(&WhitePoint, &Primaries, GammaTable);\n\n        cmsFreeToneCurve(GammaTable[0]);\n\n        mainprog_ptr->input_color = RWPNG_GAMA_CHRM;\n        mainprog_ptr->output_color = RWPNG_SRGB;\n    }\n\n    /* transform image to sRGB colorspace */\n    if (hInProfile != NULL) {\n\n        cmsHPROFILE hOutProfile = cmsCreate_sRGBProfile();\n        cmsHTRANSFORM hTransform = cmsCreateTransform(hInProfile, TYPE_RGBA_8,\n                                                      hOutProfile, TYPE_RGBA_8,\n                                                      INTENT_PERCEPTUAL,\n                                                      omp_get_max_threads() > 1 ? cmsFLAGS_NOCACHE : 0);\n\n        #pragma omp parallel for \\\n            if (mainprog_ptr->height*mainprog_ptr->width > 8000) \\\n            schedule(static)\n        for (unsigned int i = 0; i < mainprog_ptr->height; i++) {\n            /* It is safe to use the same block for input and output,\n               when both are of the same TYPE. */\n            cmsDoTransform(hTransform, row_pointers[i],\n                                       row_pointers[i],\n                                       mainprog_ptr->width);\n        }\n\n        cmsDeleteTransform(hTransform);\n        cmsCloseProfile(hOutProfile);\n        cmsCloseProfile(hInProfile);\n\n        mainprog_ptr->gamma = 0.45455;\n    }\n#endif\n\n    png_destroy_read_struct(&png_ptr, &info_ptr, NULL);\n\n    mainprog_ptr->file_size = read_data.bytes_read;\n    mainprog_ptr->row_pointers = (unsigned char **)row_pointers;\n\n    return SUCCESS;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149760,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static pngquant_error rwpng_read_image24_libpng(FILE *infile, png24_image *mainprog_ptr, int verbose)\n{\n    png_structp  png_ptr = NULL;\n    png_infop    info_ptr = NULL;\n    png_size_t   rowbytes;\n    int          color_type, bit_depth;\n\n    png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, mainprog_ptr,\n      rwpng_error_handler, verbose ? rwpng_warning_stderr_handler : rwpng_warning_silent_handler);\n    if (!png_ptr) {\n        return PNG_OUT_OF_MEMORY_ERROR;   /* out of memory */\n    }\n\n    info_ptr = png_create_info_struct(png_ptr);\n    if (!info_ptr) {\n        png_destroy_read_struct(&png_ptr, NULL, NULL);\n        return PNG_OUT_OF_MEMORY_ERROR;   /* out of memory */\n    }\n\n    /* setjmp() must be called in every function that calls a non-trivial\n     * libpng function */\n\n    if (setjmp(mainprog_ptr->jmpbuf)) {\n        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);\n        return LIBPNG_FATAL_ERROR;   /* fatal libpng error (via longjmp()) */\n    }\n\n#if defined(PNG_SKIP_sRGB_CHECK_PROFILE) && defined(PNG_SET_OPTION_SUPPORTED)\n    png_set_option(png_ptr, PNG_SKIP_sRGB_CHECK_PROFILE, PNG_OPTION_ON);\n#endif\n\n#if PNG_LIBPNG_VER >= 10500 && defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)\n    /* copy standard chunks too */\n    png_set_keep_unknown_chunks(png_ptr, PNG_HANDLE_CHUNK_IF_SAFE, (png_const_bytep)\"pHYs\\0iTXt\\0tEXt\\0zTXt\", 4);\n#endif\n    png_set_read_user_chunk_fn(png_ptr, &mainprog_ptr->chunks, read_chunk_callback);\n\n    struct rwpng_read_data read_data = {infile, 0};\n    png_set_read_fn(png_ptr, &read_data, user_read_data);\n\n    png_read_info(png_ptr, info_ptr);  /* read all PNG info up to image data */\n\n    /* alternatively, could make separate calls to png_get_image_width(),\n     * etc., but want bit_depth and color_type for later [don't care about\n     * compression_type and filter_type => NULLs] */\n\n    png_get_IHDR(png_ptr, info_ptr, &mainprog_ptr->width, &mainprog_ptr->height,\n                 &bit_depth, &color_type, NULL, NULL, NULL);\n\n    /* expand palette images to RGB, low-bit-depth grayscale images to 8 bits,\n     * transparency chunks to full alpha channel; strip 16-bit-per-sample\n     * images to 8 bits per sample; and convert grayscale to RGB[A] */\n\n    /* GRR TO DO:  preserve all safe-to-copy ancillary PNG chunks */\n\n    if (!(color_type & PNG_COLOR_MASK_ALPHA)) {\n#ifdef PNG_READ_FILLER_SUPPORTED\n        png_set_expand(png_ptr);\n        png_set_filler(png_ptr, 65535L, PNG_FILLER_AFTER);\n#else\n        fprintf(stderr, \"pngquant readpng:  image is neither RGBA nor GA\\n\");\n        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);\n        mainprog_ptr->retval = WRONG_INPUT_COLOR_TYPE;\n        return mainprog_ptr->retval;\n#endif\n    }\n\n    if (bit_depth == 16) {\n        png_set_strip_16(png_ptr);\n    }\n\n    if (!(color_type & PNG_COLOR_MASK_COLOR)) {\n        png_set_gray_to_rgb(png_ptr);\n    }\n\n    /* get source gamma for gamma correction, or use sRGB default */\n    double gamma = 0.45455;\n    if (png_get_valid(png_ptr, info_ptr, PNG_INFO_sRGB)) {\n        mainprog_ptr->input_color = RWPNG_SRGB;\n        mainprog_ptr->output_color = RWPNG_SRGB;\n    } else {\n        png_get_gAMA(png_ptr, info_ptr, &gamma);\n        if (gamma > 0 && gamma <= 1.0) {\n            mainprog_ptr->input_color = RWPNG_GAMA_ONLY;\n            mainprog_ptr->output_color = RWPNG_GAMA_ONLY;\n        } else {\n            fprintf(stderr, \"pngquant readpng:  ignored out-of-range gamma %f\\n\", gamma);\n            mainprog_ptr->input_color = RWPNG_NONE;\n            mainprog_ptr->output_color = RWPNG_NONE;\n            gamma = 0.45455;\n        }\n    }\n    mainprog_ptr->gamma = gamma;\n\n    png_set_interlace_handling(png_ptr);\n\n    /* all transformations have been registered; now update info_ptr data,\n     * get rowbytes and channels, and allocate image memory */\n\n    png_read_update_info(png_ptr, info_ptr);\n\n    rowbytes = png_get_rowbytes(png_ptr, info_ptr);\n\n    // For overflow safety reject images that won't fit in 32-bit\n    if (rowbytes > INT_MAX/mainprog_ptr->height) {\n        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);\n        return PNG_OUT_OF_MEMORY_ERROR;\n    }\n\n    if ((mainprog_ptr->rgba_data = malloc(rowbytes * mainprog_ptr->height)) == NULL) {\n        fprintf(stderr, \"pngquant readpng:  unable to allocate image data\\n\");\n        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);\n        return PNG_OUT_OF_MEMORY_ERROR;\n    }\n\n    png_bytepp row_pointers = rwpng_create_row_pointers(info_ptr, png_ptr, mainprog_ptr->rgba_data, mainprog_ptr->height, 0);\n\n    /* now we can go ahead and just read the whole image */\n\n    png_read_image(png_ptr, row_pointers);\n\n    /* and we're done!  (png_read_end() can be omitted if no processing of\n     * post-IDAT text/time/etc. is desired) */\n\n    png_read_end(png_ptr, NULL);\n\n#if USE_LCMS\n#if PNG_LIBPNG_VER < 10500\n    png_charp ProfileData;\n#else\n    png_bytep ProfileData;\n#endif\n    png_uint_32 ProfileLen;\n\n    cmsHPROFILE hInProfile = NULL;\n\n    /* color_type is read from the image before conversion to RGBA */\n    int COLOR_PNG = color_type & PNG_COLOR_MASK_COLOR;\n\n    /* embedded ICC profile */\n    if (png_get_iCCP(png_ptr, info_ptr, &(png_charp){0}, &(int){0}, &ProfileData, &ProfileLen)) {\n\n        hInProfile = cmsOpenProfileFromMem(ProfileData, ProfileLen);\n        cmsColorSpaceSignature colorspace = cmsGetColorSpace(hInProfile);\n\n        /* only RGB (and GRAY) valid for PNGs */\n        if (colorspace == cmsSigRgbData && COLOR_PNG) {\n            mainprog_ptr->input_color = RWPNG_ICCP;\n            mainprog_ptr->output_color = RWPNG_SRGB;\n        } else {\n            if (colorspace == cmsSigGrayData && !COLOR_PNG) {\n                mainprog_ptr->input_color = RWPNG_ICCP_WARN_GRAY;\n                mainprog_ptr->output_color = RWPNG_SRGB;\n            }\n            cmsCloseProfile(hInProfile);\n            hInProfile = NULL;\n        }\n    }\n\n    /* build RGB profile from cHRM and gAMA */\n    if (hInProfile == NULL && COLOR_PNG &&\n        !png_get_valid(png_ptr, info_ptr, PNG_INFO_sRGB) &&\n        png_get_valid(png_ptr, info_ptr, PNG_INFO_gAMA) &&\n        png_get_valid(png_ptr, info_ptr, PNG_INFO_cHRM)) {\n\n        cmsCIExyY WhitePoint;\n        cmsCIExyYTRIPLE Primaries;\n\n        png_get_cHRM(png_ptr, info_ptr, &WhitePoint.x, &WhitePoint.y,\n                     &Primaries.Red.x, &Primaries.Red.y,\n                     &Primaries.Green.x, &Primaries.Green.y,\n                     &Primaries.Blue.x, &Primaries.Blue.y);\n\n        WhitePoint.Y = Primaries.Red.Y = Primaries.Green.Y = Primaries.Blue.Y = 1.0;\n\n        cmsToneCurve *GammaTable[3];\n        GammaTable[0] = GammaTable[1] = GammaTable[2] = cmsBuildGamma(NULL, 1/gamma);\n\n        hInProfile = cmsCreateRGBProfile(&WhitePoint, &Primaries, GammaTable);\n\n        cmsFreeToneCurve(GammaTable[0]);\n\n        mainprog_ptr->input_color = RWPNG_GAMA_CHRM;\n        mainprog_ptr->output_color = RWPNG_SRGB;\n    }\n\n    /* transform image to sRGB colorspace */\n    if (hInProfile != NULL) {\n\n        cmsHPROFILE hOutProfile = cmsCreate_sRGBProfile();\n        cmsHTRANSFORM hTransform = cmsCreateTransform(hInProfile, TYPE_RGBA_8,\n                                                      hOutProfile, TYPE_RGBA_8,\n                                                      INTENT_PERCEPTUAL,\n                                                      omp_get_max_threads() > 1 ? cmsFLAGS_NOCACHE : 0);\n\n        #pragma omp parallel for \\\n            if (mainprog_ptr->height*mainprog_ptr->width > 8000) \\\n            schedule(static)\n        for (unsigned int i = 0; i < mainprog_ptr->height; i++) {\n            /* It is safe to use the same block for input and output,\n               when both are of the same TYPE. */\n            cmsDoTransform(hTransform, row_pointers[i],\n                                       row_pointers[i],\n                                       mainprog_ptr->width);\n        }\n\n        cmsDeleteTransform(hTransform);\n        cmsCloseProfile(hOutProfile);\n        cmsCloseProfile(hInProfile);\n\n        mainprog_ptr->gamma = 0.45455;\n    }\n#endif\n\n    png_destroy_read_struct(&png_ptr, &info_ptr, NULL);\n\n    mainprog_ptr->file_size = read_data.bytes_read;\n    mainprog_ptr->row_pointers = (unsigned char **)row_pointers;\n\n    return SUCCESS;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149761,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static MagickBooleanType WriteBMPImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  BMPInfo\n    bmp_info;\n\n  const char\n    *option;\n\n  const StringInfo\n    *profile;\n\n  MagickBooleanType\n    have_color_info,\n    status;\n\n  MagickOffsetType\n    scene;\n\n  MemoryInfo\n    *pixel_info;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *q;\n\n  size_t\n    bytes_per_line,\n    type;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *bmp_data,\n    *pixels;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  type=4;\n  if (LocaleCompare(image_info->magick,\"BMP2\") == 0)\n    type=2;\n  else\n    if (LocaleCompare(image_info->magick,\"BMP3\") == 0)\n      type=3;\n\n  option=GetImageOption(image_info,\"bmp:format\");\n  if (option != (char *) NULL)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Format=%s\",option);\n\n      if (LocaleCompare(option,\"bmp2\") == 0)\n        type=2;\n      if (LocaleCompare(option,\"bmp3\") == 0)\n        type=3;\n      if (LocaleCompare(option,\"bmp4\") == 0)\n        type=4;\n    }\n\n  scene=0;\n  do\n  {\n    /*\n      Initialize BMP raster file header.\n    */\n    (void) TransformImageColorspace(image,sRGBColorspace,exception);\n    (void) ResetMagickMemory(&bmp_info,0,sizeof(bmp_info));\n    bmp_info.file_size=14+12;\n    if (type > 2)\n      bmp_info.file_size+=28;\n    bmp_info.offset_bits=bmp_info.file_size;\n    bmp_info.compression=BI_RGB;\n    if ((image->storage_class == PseudoClass) && (image->colors > 256))\n      (void) SetImageStorageClass(image,DirectClass,exception);\n    if (image->storage_class != DirectClass)\n      {\n        /*\n          Colormapped BMP raster.\n        */\n        bmp_info.bits_per_pixel=8;\n        if (image->colors <= 2)\n          bmp_info.bits_per_pixel=1;\n        else\n          if (image->colors <= 16)\n            bmp_info.bits_per_pixel=4;\n          else\n            if (image->colors <= 256)\n              bmp_info.bits_per_pixel=8;\n        if (image_info->compression == RLECompression)\n          bmp_info.bits_per_pixel=8;\n        bmp_info.number_colors=1U << bmp_info.bits_per_pixel;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          (void) SetImageStorageClass(image,DirectClass,exception);\n        else\n          if ((size_t) bmp_info.number_colors < image->colors)\n            (void) SetImageStorageClass(image,DirectClass,exception);\n          else\n            {\n              bmp_info.file_size+=3*(1UL << bmp_info.bits_per_pixel);\n              bmp_info.offset_bits+=3*(1UL << bmp_info.bits_per_pixel);\n              if (type > 2)\n                {\n                  bmp_info.file_size+=(1UL << bmp_info.bits_per_pixel);\n                  bmp_info.offset_bits+=(1UL << bmp_info.bits_per_pixel);\n                }\n            }\n      }\n    if (image->storage_class == DirectClass)\n      {\n        /*\n          Full color BMP raster.\n        */\n        bmp_info.number_colors=0;\n        bmp_info.bits_per_pixel=(unsigned short)\n          ((type > 3) && (image->alpha_trait != UndefinedPixelTrait) ? 32 : 24);\n        bmp_info.compression=(unsigned int) ((type > 3) &&\n          (image->alpha_trait != UndefinedPixelTrait) ?  BI_BITFIELDS : BI_RGB);\n        if ((type == 3) && (image->alpha_trait != UndefinedPixelTrait))\n          {\n            option=GetImageOption(image_info,\"bmp3:alpha\");\n            if (IsStringTrue(option))\n              bmp_info.bits_per_pixel=32;\n          }\n      }\n    bytes_per_line=4*((image->columns*bmp_info.bits_per_pixel+31)/32);\n    bmp_info.ba_offset=0;\n    profile=GetImageProfile(image,\"icc\");\n    have_color_info=(image->rendering_intent != UndefinedIntent) ||\n      (profile != (StringInfo *) NULL) || (image->gamma != 0.0) ?  MagickTrue :\n      MagickFalse;\n    if (type == 2)\n      bmp_info.size=12;\n    else\n      if ((type == 3) || ((image->alpha_trait == UndefinedPixelTrait) &&\n          (have_color_info == MagickFalse)))\n        {\n          type=3;\n          bmp_info.size=40;\n        }\n      else\n        {\n          int\n            extra_size;\n\n          bmp_info.size=108;\n          extra_size=68;\n          if ((image->rendering_intent != UndefinedIntent) ||\n              (profile != (StringInfo *) NULL))\n            {\n              bmp_info.size=124;\n              extra_size+=16;\n            }\n          bmp_info.file_size+=extra_size;\n          bmp_info.offset_bits+=extra_size;\n        }\n    bmp_info.width=(ssize_t) image->columns;\n    bmp_info.height=(ssize_t) image->rows;\n    bmp_info.planes=1;\n    bmp_info.image_size=(unsigned int) (bytes_per_line*image->rows);\n    bmp_info.file_size+=bmp_info.image_size;\n    bmp_info.x_pixels=75*39;\n    bmp_info.y_pixels=75*39;\n    switch (image->units)\n    {\n      case UndefinedResolution:\n      case PixelsPerInchResolution:\n      {\n        bmp_info.x_pixels=(unsigned int) (100.0*image->resolution.x/2.54);\n        bmp_info.y_pixels=(unsigned int) (100.0*image->resolution.y/2.54);\n        break;\n      }\n      case PixelsPerCentimeterResolution:\n      {\n        bmp_info.x_pixels=(unsigned int) (100.0*image->resolution.x);\n        bmp_info.y_pixels=(unsigned int) (100.0*image->resolution.y);\n        break;\n      }\n    }\n    bmp_info.colors_important=bmp_info.number_colors;\n    /*\n      Convert MIFF to BMP raster pixels.\n    */\n    pixel_info=AcquireVirtualMemory((size_t) bmp_info.image_size,\n      sizeof(*pixels));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    (void) ResetMagickMemory(pixels,0,(size_t) bmp_info.image_size);\n    switch (bmp_info.bits_per_pixel)\n    {\n      case 1:\n      {\n        size_t\n          bit,\n          byte;\n\n        /*\n          Convert PseudoClass image to a BMP monochrome image.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          ssize_t\n            offset;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels+(image->rows-y-1)*bytes_per_line;\n          bit=0;\n          byte=0;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            byte<<=1;\n            byte|=GetPixelIndex(image,p) != 0 ? 0x01 : 0x00;\n            bit++;\n            if (bit == 8)\n              {\n                *q++=(unsigned char) byte;\n                bit=0;\n                byte=0;\n              }\n             p+=GetPixelChannels(image);\n           }\n           if (bit != 0)\n             {\n               *q++=(unsigned char) (byte << (8-bit));\n               x++;\n             }\n          offset=(ssize_t) (image->columns+7)/8;\n          for (x=offset; x < (ssize_t) bytes_per_line; x++)\n            *q++=0x00;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case 4:\n      {\n        size_t\n          byte,\n          nibble;\n\n        ssize_t\n          offset;\n\n        /*\n          Convert PseudoClass image to a BMP monochrome image.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels+(image->rows-y-1)*bytes_per_line;\n          nibble=0;\n          byte=0;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            byte<<=4;\n            byte|=((size_t) GetPixelIndex(image,p) & 0x0f);\n            nibble++;\n            if (nibble == 2)\n              {\n                *q++=(unsigned char) byte;\n                nibble=0;\n                byte=0;\n              }\n            p+=GetPixelChannels(image);\n          }\n          if (nibble != 0)\n            {\n              *q++=(unsigned char) (byte << 4);\n              x++;\n            }\n          offset=(ssize_t) (image->columns+1)/2;\n          for (x=offset; x < (ssize_t) bytes_per_line; x++)\n            *q++=0x00;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case 8:\n      {\n        /*\n          Convert PseudoClass packet to BMP pixel.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels+(image->rows-y-1)*bytes_per_line;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *q++=(unsigned char) GetPixelIndex(image,p);\n            p+=GetPixelChannels(image);\n          }\n          for ( ; x < (ssize_t) bytes_per_line; x++)\n            *q++=0x00;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case 24:\n      {\n        /*\n          Convert DirectClass packet to BMP BGR888.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels+(image->rows-y-1)*bytes_per_line;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *q++=ScaleQuantumToChar(GetPixelBlue(image,p));\n            *q++=ScaleQuantumToChar(GetPixelGreen(image,p));\n            *q++=ScaleQuantumToChar(GetPixelRed(image,p));\n            p+=GetPixelChannels(image);\n          }\n          for (x=3L*(ssize_t) image->columns; x < (ssize_t) bytes_per_line; x++)\n            *q++=0x00;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case 32:\n      {\n        /*\n          Convert DirectClass packet to ARGB8888 pixel.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels+(image->rows-y-1)*bytes_per_line;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *q++=ScaleQuantumToChar(GetPixelBlue(image,p));\n            *q++=ScaleQuantumToChar(GetPixelGreen(image,p));\n            *q++=ScaleQuantumToChar(GetPixelRed(image,p));\n            *q++=ScaleQuantumToChar(GetPixelAlpha(image,p));\n            p+=GetPixelChannels(image);\n          }\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n    }\n    if ((type > 2) && (bmp_info.bits_per_pixel == 8))\n      if (image_info->compression != NoCompression)\n        {\n          MemoryInfo\n            *rle_info;\n\n          /*\n            Convert run-length encoded raster pixels.\n          */\n          rle_info=AcquireVirtualMemory((size_t) (2*(bytes_per_line+2)+2),\n            (image->rows+2)*sizeof(*pixels));\n          if (rle_info == (MemoryInfo *) NULL)\n            {\n              pixel_info=RelinquishVirtualMemory(pixel_info);\n              ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n            }\n          bmp_data=(unsigned char *) GetVirtualMemoryBlob(rle_info);\n          bmp_info.file_size-=bmp_info.image_size;\n          bmp_info.image_size=(unsigned int) EncodeImage(image,bytes_per_line,\n            pixels,bmp_data);\n          bmp_info.file_size+=bmp_info.image_size;\n          pixel_info=RelinquishVirtualMemory(pixel_info);\n          pixel_info=rle_info;\n          pixels=bmp_data;\n          bmp_info.compression=BI_RLE8;\n        }\n    /*\n      Write BMP for Windows, all versions, 14-byte header.\n    */\n    if (image->debug != MagickFalse)\n      {\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"   Writing BMP version %.20g datastream\",(double) type);\n        if (image->storage_class == DirectClass)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   Storage class=DirectClass\");\n        else\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   Storage class=PseudoClass\");\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"   Image depth=%.20g\",(double) image->depth);\n        if (image->alpha_trait != UndefinedPixelTrait)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   Matte=True\");\n        else\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   Matte=MagickFalse\");\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"   BMP bits_per_pixel=%.20g\",(double) bmp_info.bits_per_pixel);\n        switch ((int) bmp_info.compression)\n        {\n           case BI_RGB:\n           {\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"   Compression=BI_RGB\");\n             break;\n           }\n           case BI_RLE8:\n           {\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"   Compression=BI_RLE8\");\n             break;\n           }\n           case BI_BITFIELDS:\n           {\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"   Compression=BI_BITFIELDS\");\n             break;\n           }\n           default:\n           {\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"   Compression=UNKNOWN (%lu)\",bmp_info.compression);\n             break;\n           }\n        }\n        if (bmp_info.number_colors == 0)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   Number_colors=unspecified\");\n        else\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   Number_colors=%lu\",bmp_info.number_colors);\n      }\n    (void) WriteBlob(image,2,(unsigned char *) \"BM\");\n    (void) WriteBlobLSBLong(image,bmp_info.file_size);\n    (void) WriteBlobLSBLong(image,bmp_info.ba_offset);  /* always 0 */\n    (void) WriteBlobLSBLong(image,bmp_info.offset_bits);\n    if (type == 2)\n      {\n        /*\n          Write 12-byte version 2 bitmap header.\n        */\n        (void) WriteBlobLSBLong(image,bmp_info.size);\n        (void) WriteBlobLSBSignedShort(image,(signed short) bmp_info.width);\n        (void) WriteBlobLSBSignedShort(image,(signed short) bmp_info.height);\n        (void) WriteBlobLSBShort(image,bmp_info.planes);\n        (void) WriteBlobLSBShort(image,bmp_info.bits_per_pixel);\n      }\n    else\n      {\n        /*\n          Write 40-byte version 3+ bitmap header.\n        */\n        (void) WriteBlobLSBLong(image,bmp_info.size);\n        (void) WriteBlobLSBSignedLong(image,(signed int) bmp_info.width);\n        (void) WriteBlobLSBSignedLong(image,(signed int) bmp_info.height);\n        (void) WriteBlobLSBShort(image,bmp_info.planes);\n        (void) WriteBlobLSBShort(image,bmp_info.bits_per_pixel);\n        (void) WriteBlobLSBLong(image,bmp_info.compression);\n        (void) WriteBlobLSBLong(image,bmp_info.image_size);\n        (void) WriteBlobLSBLong(image,bmp_info.x_pixels);\n        (void) WriteBlobLSBLong(image,bmp_info.y_pixels);\n        (void) WriteBlobLSBLong(image,bmp_info.number_colors);\n        (void) WriteBlobLSBLong(image,bmp_info.colors_important);\n      }\n    if ((type > 3) && ((image->alpha_trait != UndefinedPixelTrait) ||\n        (have_color_info != MagickFalse)))\n      {\n        /*\n          Write the rest of the 108-byte BMP Version 4 header.\n        */\n        (void) WriteBlobLSBLong(image,0x00ff0000U);  /* Red mask */\n        (void) WriteBlobLSBLong(image,0x0000ff00U);  /* Green mask */\n        (void) WriteBlobLSBLong(image,0x000000ffU);  /* Blue mask */\n        (void) WriteBlobLSBLong(image,0xff000000U);  /* Alpha mask */\n        (void) WriteBlobLSBLong(image,0x73524742U);  /* sRGB */\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.red_primary.x*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.red_primary.y*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          ((1.000f-(image->chromaticity.red_primary.x+\n          image->chromaticity.red_primary.y))*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.green_primary.x*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.green_primary.y*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          ((1.000f-(image->chromaticity.green_primary.x+\n          image->chromaticity.green_primary.y))*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.blue_primary.x*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.blue_primary.y*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          ((1.000f-(image->chromaticity.blue_primary.x+\n          image->chromaticity.blue_primary.y))*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (bmp_info.gamma_scale.x*0x10000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (bmp_info.gamma_scale.y*0x10000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (bmp_info.gamma_scale.z*0x10000));\n        if ((image->rendering_intent != UndefinedIntent) ||\n            (profile != (StringInfo *) NULL))\n          {\n            ssize_t\n              intent;\n\n            switch ((int) image->rendering_intent)\n            {\n              case SaturationIntent:\n              {\n                intent=LCS_GM_BUSINESS;\n                break;\n              }\n              case RelativeIntent:\n              {\n                intent=LCS_GM_GRAPHICS;\n                break;\n              }\n              case PerceptualIntent:\n              {\n                intent=LCS_GM_IMAGES;\n                break;\n              }\n              case AbsoluteIntent:\n              {\n                intent=LCS_GM_ABS_COLORIMETRIC;\n                break;\n              }\n              default:\n              {\n                intent=0;\n                break;\n              }\n            }\n            (void) WriteBlobLSBLong(image,(unsigned int) intent);\n            (void) WriteBlobLSBLong(image,0x00);  /* dummy profile data */\n            (void) WriteBlobLSBLong(image,0x00);  /* dummy profile length */\n            (void) WriteBlobLSBLong(image,0x00);  /* reserved */\n          }\n      }\n    if (image->storage_class == PseudoClass)\n      {\n        unsigned char\n          *bmp_colormap;\n\n        /*\n          Dump colormap to file.\n        */\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Colormap: %.20g entries\",(double) image->colors);\n        bmp_colormap=(unsigned char *) AcquireQuantumMemory((size_t) (1UL <<\n          bmp_info.bits_per_pixel),4*sizeof(*bmp_colormap));\n        if (bmp_colormap == (unsigned char *) NULL)\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n        q=bmp_colormap;\n        for (i=0; i < (ssize_t) MagickMin((ssize_t) image->colors,(ssize_t) bmp_info.number_colors); i++)\n        {\n          *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].blue));\n          *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].green));\n          *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].red));\n          if (type > 2)\n            *q++=(unsigned char) 0x0;\n        }\n        for ( ; i < (ssize_t) (1UL << bmp_info.bits_per_pixel); i++)\n        {\n          *q++=(unsigned char) 0x00;\n          *q++=(unsigned char) 0x00;\n          *q++=(unsigned char) 0x00;\n          if (type > 2)\n            *q++=(unsigned char) 0x00;\n        }\n        if (type <= 2)\n          (void) WriteBlob(image,(size_t) (3*(1L << bmp_info.bits_per_pixel)),\n            bmp_colormap);\n        else\n          (void) WriteBlob(image,(size_t) (4*(1L << bmp_info.bits_per_pixel)),\n            bmp_colormap);\n        bmp_colormap=(unsigned char *) RelinquishMagickMemory(bmp_colormap);\n      }\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Pixels:  %lu bytes\",bmp_info.image_size);\n    (void) WriteBlob(image,(size_t) bmp_info.image_size,pixels);\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149764,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static MagickBooleanType WriteBMPImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  BMPInfo\n    bmp_info;\n\n  const char\n    *option;\n\n  const StringInfo\n    *profile;\n\n  MagickBooleanType\n    have_color_info,\n    status;\n\n  MagickOffsetType\n    scene;\n\n  MemoryInfo\n    *pixel_info;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *q;\n\n  size_t\n    bytes_per_line,\n    type;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *bmp_data,\n    *pixels;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  type=4;\n  if (LocaleCompare(image_info->magick,\"BMP2\") == 0)\n    type=2;\n  else\n    if (LocaleCompare(image_info->magick,\"BMP3\") == 0)\n      type=3;\n\n  option=GetImageOption(image_info,\"bmp:format\");\n  if (option != (char *) NULL)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Format=%s\",option);\n\n      if (LocaleCompare(option,\"bmp2\") == 0)\n        type=2;\n      if (LocaleCompare(option,\"bmp3\") == 0)\n        type=3;\n      if (LocaleCompare(option,\"bmp4\") == 0)\n        type=4;\n    }\n\n  scene=0;\n  do\n  {\n    /*\n      Initialize BMP raster file header.\n    */\n    (void) TransformImageColorspace(image,sRGBColorspace,exception);\n    (void) ResetMagickMemory(&bmp_info,0,sizeof(bmp_info));\n    bmp_info.file_size=14+12;\n    if (type > 2)\n      bmp_info.file_size+=28;\n    bmp_info.offset_bits=bmp_info.file_size;\n    bmp_info.compression=BI_RGB;\n    if ((image->storage_class == PseudoClass) && (image->colors > 256))\n      (void) SetImageStorageClass(image,DirectClass,exception);\n    if (image->storage_class != DirectClass)\n      {\n        /*\n          Colormapped BMP raster.\n        */\n        bmp_info.bits_per_pixel=8;\n        if (image->colors <= 2)\n          bmp_info.bits_per_pixel=1;\n        else\n          if (image->colors <= 16)\n            bmp_info.bits_per_pixel=4;\n          else\n            if (image->colors <= 256)\n              bmp_info.bits_per_pixel=8;\n        if (image_info->compression == RLECompression)\n          bmp_info.bits_per_pixel=8;\n        bmp_info.number_colors=1U << bmp_info.bits_per_pixel;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          (void) SetImageStorageClass(image,DirectClass,exception);\n        else\n          if ((size_t) bmp_info.number_colors < image->colors)\n            (void) SetImageStorageClass(image,DirectClass,exception);\n          else\n            {\n              bmp_info.file_size+=3*(1UL << bmp_info.bits_per_pixel);\n              bmp_info.offset_bits+=3*(1UL << bmp_info.bits_per_pixel);\n              if (type > 2)\n                {\n                  bmp_info.file_size+=(1UL << bmp_info.bits_per_pixel);\n                  bmp_info.offset_bits+=(1UL << bmp_info.bits_per_pixel);\n                }\n            }\n      }\n    if (image->storage_class == DirectClass)\n      {\n        /*\n          Full color BMP raster.\n        */\n        bmp_info.number_colors=0;\n        bmp_info.bits_per_pixel=(unsigned short)\n          ((type > 3) && (image->alpha_trait != UndefinedPixelTrait) ? 32 : 24);\n        bmp_info.compression=(unsigned int) ((type > 3) &&\n          (image->alpha_trait != UndefinedPixelTrait) ?  BI_BITFIELDS : BI_RGB);\n        if ((type == 3) && (image->alpha_trait != UndefinedPixelTrait))\n          {\n            option=GetImageOption(image_info,\"bmp3:alpha\");\n            if (IsStringTrue(option))\n              bmp_info.bits_per_pixel=32;\n          }\n      }\n    bytes_per_line=4*((image->columns*bmp_info.bits_per_pixel+31)/32);\n    bmp_info.ba_offset=0;\n    profile=GetImageProfile(image,\"icc\");\n    have_color_info=(image->rendering_intent != UndefinedIntent) ||\n      (profile != (StringInfo *) NULL) || (image->gamma != 0.0) ?  MagickTrue :\n      MagickFalse;\n    if (type == 2)\n      bmp_info.size=12;\n    else\n      if ((type == 3) || ((image->alpha_trait == UndefinedPixelTrait) &&\n          (have_color_info == MagickFalse)))\n        {\n          type=3;\n          bmp_info.size=40;\n        }\n      else\n        {\n          int\n            extra_size;\n\n          bmp_info.size=108;\n          extra_size=68;\n          if ((image->rendering_intent != UndefinedIntent) ||\n              (profile != (StringInfo *) NULL))\n            {\n              bmp_info.size=124;\n              extra_size+=16;\n            }\n          bmp_info.file_size+=extra_size;\n          bmp_info.offset_bits+=extra_size;\n        }\n    if ((image->columns != (signed int) image->columns) ||\n        (image->rows != (signed int) image->rows))\n      ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n    bmp_info.width=(ssize_t) image->columns;\n    bmp_info.height=(ssize_t) image->rows;\n    bmp_info.planes=1;\n    bmp_info.image_size=(unsigned long) (bytes_per_line*image->rows);\n    bmp_info.file_size+=bmp_info.image_size;\n    bmp_info.x_pixels=75*39;\n    bmp_info.y_pixels=75*39;\n    switch (image->units)\n    {\n      case UndefinedResolution:\n      case PixelsPerInchResolution:\n      {\n        bmp_info.x_pixels=(unsigned int) (100.0*image->resolution.x/2.54);\n        bmp_info.y_pixels=(unsigned int) (100.0*image->resolution.y/2.54);\n        break;\n      }\n      case PixelsPerCentimeterResolution:\n      {\n        bmp_info.x_pixels=(unsigned int) (100.0*image->resolution.x);\n        bmp_info.y_pixels=(unsigned int) (100.0*image->resolution.y);\n        break;\n      }\n    }\n    bmp_info.colors_important=bmp_info.number_colors;\n    /*\n      Convert MIFF to BMP raster pixels.\n    */\n    pixel_info=AcquireVirtualMemory((size_t) bmp_info.image_size,\n      sizeof(*pixels));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    (void) ResetMagickMemory(pixels,0,(size_t) bmp_info.image_size);\n    switch (bmp_info.bits_per_pixel)\n    {\n      case 1:\n      {\n        size_t\n          bit,\n          byte;\n\n        /*\n          Convert PseudoClass image to a BMP monochrome image.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          ssize_t\n            offset;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels+(image->rows-y-1)*bytes_per_line;\n          bit=0;\n          byte=0;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            byte<<=1;\n            byte|=GetPixelIndex(image,p) != 0 ? 0x01 : 0x00;\n            bit++;\n            if (bit == 8)\n              {\n                *q++=(unsigned char) byte;\n                bit=0;\n                byte=0;\n              }\n             p+=GetPixelChannels(image);\n           }\n           if (bit != 0)\n             {\n               *q++=(unsigned char) (byte << (8-bit));\n               x++;\n             }\n          offset=(ssize_t) (image->columns+7)/8;\n          for (x=offset; x < (ssize_t) bytes_per_line; x++)\n            *q++=0x00;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case 4:\n      {\n        size_t\n          byte,\n          nibble;\n\n        ssize_t\n          offset;\n\n        /*\n          Convert PseudoClass image to a BMP monochrome image.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels+(image->rows-y-1)*bytes_per_line;\n          nibble=0;\n          byte=0;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            byte<<=4;\n            byte|=((size_t) GetPixelIndex(image,p) & 0x0f);\n            nibble++;\n            if (nibble == 2)\n              {\n                *q++=(unsigned char) byte;\n                nibble=0;\n                byte=0;\n              }\n            p+=GetPixelChannels(image);\n          }\n          if (nibble != 0)\n            {\n              *q++=(unsigned char) (byte << 4);\n              x++;\n            }\n          offset=(ssize_t) (image->columns+1)/2;\n          for (x=offset; x < (ssize_t) bytes_per_line; x++)\n            *q++=0x00;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case 8:\n      {\n        /*\n          Convert PseudoClass packet to BMP pixel.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels+(image->rows-y-1)*bytes_per_line;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *q++=(unsigned char) GetPixelIndex(image,p);\n            p+=GetPixelChannels(image);\n          }\n          for ( ; x < (ssize_t) bytes_per_line; x++)\n            *q++=0x00;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case 24:\n      {\n        /*\n          Convert DirectClass packet to BMP BGR888.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels+(image->rows-y-1)*bytes_per_line;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *q++=ScaleQuantumToChar(GetPixelBlue(image,p));\n            *q++=ScaleQuantumToChar(GetPixelGreen(image,p));\n            *q++=ScaleQuantumToChar(GetPixelRed(image,p));\n            p+=GetPixelChannels(image);\n          }\n          for (x=3L*(ssize_t) image->columns; x < (ssize_t) bytes_per_line; x++)\n            *q++=0x00;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case 32:\n      {\n        /*\n          Convert DirectClass packet to ARGB8888 pixel.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels+(image->rows-y-1)*bytes_per_line;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *q++=ScaleQuantumToChar(GetPixelBlue(image,p));\n            *q++=ScaleQuantumToChar(GetPixelGreen(image,p));\n            *q++=ScaleQuantumToChar(GetPixelRed(image,p));\n            *q++=ScaleQuantumToChar(GetPixelAlpha(image,p));\n            p+=GetPixelChannels(image);\n          }\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n    }\n    if ((type > 2) && (bmp_info.bits_per_pixel == 8))\n      if (image_info->compression != NoCompression)\n        {\n          MemoryInfo\n            *rle_info;\n\n          /*\n            Convert run-length encoded raster pixels.\n          */\n          rle_info=AcquireVirtualMemory((size_t) (2*(bytes_per_line+2)+2),\n            (image->rows+2)*sizeof(*pixels));\n          if (rle_info == (MemoryInfo *) NULL)\n            {\n              pixel_info=RelinquishVirtualMemory(pixel_info);\n              ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n            }\n          bmp_data=(unsigned char *) GetVirtualMemoryBlob(rle_info);\n          bmp_info.file_size-=bmp_info.image_size;\n          bmp_info.image_size=(unsigned int) EncodeImage(image,bytes_per_line,\n            pixels,bmp_data);\n          bmp_info.file_size+=bmp_info.image_size;\n          pixel_info=RelinquishVirtualMemory(pixel_info);\n          pixel_info=rle_info;\n          pixels=bmp_data;\n          bmp_info.compression=BI_RLE8;\n        }\n    /*\n      Write BMP for Windows, all versions, 14-byte header.\n    */\n    if (image->debug != MagickFalse)\n      {\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"   Writing BMP version %.20g datastream\",(double) type);\n        if (image->storage_class == DirectClass)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   Storage class=DirectClass\");\n        else\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   Storage class=PseudoClass\");\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"   Image depth=%.20g\",(double) image->depth);\n        if (image->alpha_trait != UndefinedPixelTrait)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   Matte=True\");\n        else\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   Matte=MagickFalse\");\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"   BMP bits_per_pixel=%.20g\",(double) bmp_info.bits_per_pixel);\n        switch ((int) bmp_info.compression)\n        {\n           case BI_RGB:\n           {\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"   Compression=BI_RGB\");\n             break;\n           }\n           case BI_RLE8:\n           {\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"   Compression=BI_RLE8\");\n             break;\n           }\n           case BI_BITFIELDS:\n           {\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"   Compression=BI_BITFIELDS\");\n             break;\n           }\n           default:\n           {\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"   Compression=UNKNOWN (%lu)\",bmp_info.compression);\n             break;\n           }\n        }\n        if (bmp_info.number_colors == 0)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   Number_colors=unspecified\");\n        else\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   Number_colors=%lu\",bmp_info.number_colors);\n      }\n    (void) WriteBlob(image,2,(unsigned char *) \"BM\");\n    (void) WriteBlobLSBLong(image,bmp_info.file_size);\n    (void) WriteBlobLSBLong(image,bmp_info.ba_offset);  /* always 0 */\n    (void) WriteBlobLSBLong(image,bmp_info.offset_bits);\n    if (type == 2)\n      {\n        /*\n          Write 12-byte version 2 bitmap header.\n        */\n        (void) WriteBlobLSBLong(image,bmp_info.size);\n        (void) WriteBlobLSBSignedShort(image,(signed short) bmp_info.width);\n        (void) WriteBlobLSBSignedShort(image,(signed short) bmp_info.height);\n        (void) WriteBlobLSBShort(image,bmp_info.planes);\n        (void) WriteBlobLSBShort(image,bmp_info.bits_per_pixel);\n      }\n    else\n      {\n        /*\n          Write 40-byte version 3+ bitmap header.\n        */\n        (void) WriteBlobLSBLong(image,bmp_info.size);\n        (void) WriteBlobLSBSignedLong(image,(signed int) bmp_info.width);\n        (void) WriteBlobLSBSignedLong(image,(signed int) bmp_info.height);\n        (void) WriteBlobLSBShort(image,bmp_info.planes);\n        (void) WriteBlobLSBShort(image,bmp_info.bits_per_pixel);\n        (void) WriteBlobLSBLong(image,bmp_info.compression);\n        (void) WriteBlobLSBLong(image,bmp_info.image_size);\n        (void) WriteBlobLSBLong(image,bmp_info.x_pixels);\n        (void) WriteBlobLSBLong(image,bmp_info.y_pixels);\n        (void) WriteBlobLSBLong(image,bmp_info.number_colors);\n        (void) WriteBlobLSBLong(image,bmp_info.colors_important);\n      }\n    if ((type > 3) && ((image->alpha_trait != UndefinedPixelTrait) ||\n        (have_color_info != MagickFalse)))\n      {\n        /*\n          Write the rest of the 108-byte BMP Version 4 header.\n        */\n        (void) WriteBlobLSBLong(image,0x00ff0000U);  /* Red mask */\n        (void) WriteBlobLSBLong(image,0x0000ff00U);  /* Green mask */\n        (void) WriteBlobLSBLong(image,0x000000ffU);  /* Blue mask */\n        (void) WriteBlobLSBLong(image,0xff000000U);  /* Alpha mask */\n        (void) WriteBlobLSBLong(image,0x73524742U);  /* sRGB */\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.red_primary.x*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.red_primary.y*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          ((1.000f-(image->chromaticity.red_primary.x+\n          image->chromaticity.red_primary.y))*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.green_primary.x*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.green_primary.y*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          ((1.000f-(image->chromaticity.green_primary.x+\n          image->chromaticity.green_primary.y))*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.blue_primary.x*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.blue_primary.y*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          ((1.000f-(image->chromaticity.blue_primary.x+\n          image->chromaticity.blue_primary.y))*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (bmp_info.gamma_scale.x*0x10000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (bmp_info.gamma_scale.y*0x10000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (bmp_info.gamma_scale.z*0x10000));\n        if ((image->rendering_intent != UndefinedIntent) ||\n            (profile != (StringInfo *) NULL))\n          {\n            ssize_t\n              intent;\n\n            switch ((int) image->rendering_intent)\n            {\n              case SaturationIntent:\n              {\n                intent=LCS_GM_BUSINESS;\n                break;\n              }\n              case RelativeIntent:\n              {\n                intent=LCS_GM_GRAPHICS;\n                break;\n              }\n              case PerceptualIntent:\n              {\n                intent=LCS_GM_IMAGES;\n                break;\n              }\n              case AbsoluteIntent:\n              {\n                intent=LCS_GM_ABS_COLORIMETRIC;\n                break;\n              }\n              default:\n              {\n                intent=0;\n                break;\n              }\n            }\n            (void) WriteBlobLSBLong(image,(unsigned int) intent);\n            (void) WriteBlobLSBLong(image,0x00);  /* dummy profile data */\n            (void) WriteBlobLSBLong(image,0x00);  /* dummy profile length */\n            (void) WriteBlobLSBLong(image,0x00);  /* reserved */\n          }\n      }\n    if (image->storage_class == PseudoClass)\n      {\n        unsigned char\n          *bmp_colormap;\n\n        /*\n          Dump colormap to file.\n        */\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Colormap: %.20g entries\",(double) image->colors);\n        bmp_colormap=(unsigned char *) AcquireQuantumMemory((size_t) (1UL <<\n          bmp_info.bits_per_pixel),4*sizeof(*bmp_colormap));\n        if (bmp_colormap == (unsigned char *) NULL)\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n        q=bmp_colormap;\n        for (i=0; i < (ssize_t) MagickMin((ssize_t) image->colors,(ssize_t) bmp_info.number_colors); i++)\n        {\n          *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].blue));\n          *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].green));\n          *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].red));\n          if (type > 2)\n            *q++=(unsigned char) 0x0;\n        }\n        for ( ; i < (ssize_t) (1UL << bmp_info.bits_per_pixel); i++)\n        {\n          *q++=(unsigned char) 0x00;\n          *q++=(unsigned char) 0x00;\n          *q++=(unsigned char) 0x00;\n          if (type > 2)\n            *q++=(unsigned char) 0x00;\n        }\n        if (type <= 2)\n          (void) WriteBlob(image,(size_t) (3*(1L << bmp_info.bits_per_pixel)),\n            bmp_colormap);\n        else\n          (void) WriteBlob(image,(size_t) (4*(1L << bmp_info.bits_per_pixel)),\n            bmp_colormap);\n        bmp_colormap=(unsigned char *) RelinquishMagickMemory(bmp_colormap);\n      }\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Pixels:  %lu bytes\",bmp_info.image_size);\n    (void) WriteBlob(image,(size_t) bmp_info.image_size,pixels);\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149765,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "void AllocateDataSet(cmsIT8* it8)\n{\n    TABLE* t = GetTable(it8);\n\n    if (t -> Data) return;    // Already allocated\n\n    t-> nSamples   = atoi(cmsIT8GetProperty(it8, \"NUMBER_OF_FIELDS\"));\n    t-> nPatches   = atoi(cmsIT8GetProperty(it8, \"NUMBER_OF_SETS\"));\n\n    t-> Data = (char**)AllocChunk (it8, ((cmsUInt32Number) t->nSamples + 1) * ((cmsUInt32Number) t->nPatches + 1) *sizeof (char*));\n    if (t->Data == NULL) {\n\n        SynError(it8, \"AllocateDataSet: Unable to allocate data array\");\n    }\n\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149766,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "void AllocateDataSet(cmsIT8* it8)\n{\n    TABLE* t = GetTable(it8);\n\n    if (t -> Data) return;    // Already allocated\n\n    t-> nSamples   = atoi(cmsIT8GetProperty(it8, \"NUMBER_OF_FIELDS\"));\n    t-> nPatches   = atoi(cmsIT8GetProperty(it8, \"NUMBER_OF_SETS\"));\n\n    if (t -> nSamples < 0 || t->nSamples > 0x7ffe || t->nPatches < 0 || t->nPatches > 0x7ffe)\n    {\n        SynError(it8, \"AllocateDataSet: too much data\");\n    }\n    else {\n        t->Data = (char**)AllocChunk(it8, ((cmsUInt32Number)t->nSamples + 1) * ((cmsUInt32Number)t->nPatches + 1) * sizeof(char*));\n        if (t->Data == NULL) {\n\n            SynError(it8, \"AllocateDataSet: Unable to allocate data array\");\n        }\n    }\n\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149767,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "vc4_get_bcl(struct drm_device *dev, struct vc4_exec_info *exec)\n{\n\tstruct drm_vc4_submit_cl *args = exec->args;\n\tvoid *temp = NULL;\n\tvoid *bin;\n\tint ret = 0;\n\tuint32_t bin_offset = 0;\n\tuint32_t shader_rec_offset = roundup(bin_offset + args->bin_cl_size,\n\t\t\t\t\t     16);\n\tuint32_t uniforms_offset = shader_rec_offset + args->shader_rec_size;\n\tuint32_t exec_size = uniforms_offset + args->uniforms_size;\n\tuint32_t temp_size = exec_size + (sizeof(struct vc4_shader_state) *\n\t\t\t\t\t  args->shader_rec_count);\n\tstruct vc4_bo *bo;\n\n\tif (uniforms_offset < shader_rec_offset ||\n\t    exec_size < uniforms_offset ||\n\t    args->shader_rec_count >= (UINT_MAX /\n\t\t\t\t\t  sizeof(struct vc4_shader_state)) ||\n\t    temp_size < exec_size) {\n\t\tDRM_ERROR(\"overflow in exec arguments\\n\");\n\t\tgoto fail;\n\t}\n\n\t/* Allocate space where we'll store the copied in user command lists\n\t * and shader records.\n\t *\n\t * We don't just copy directly into the BOs because we need to\n\t * read the contents back for validation, and I think the\n\t * bo->vaddr is uncached access.\n\t */\n\ttemp = drm_malloc_ab(temp_size, 1);\n\tif (!temp) {\n\t\tDRM_ERROR(\"Failed to allocate storage for copying \"\n\t\t\t  \"in bin/render CLs.\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\tbin = temp + bin_offset;\n\texec->shader_rec_u = temp + shader_rec_offset;\n\texec->uniforms_u = temp + uniforms_offset;\n\texec->shader_state = temp + exec_size;\n\texec->shader_state_size = args->shader_rec_count;\n\n\tif (copy_from_user(bin,\n\t\t\t   (void __user *)(uintptr_t)args->bin_cl,\n\t\t\t   args->bin_cl_size)) {\n\t\tret = -EFAULT;\n\t\tgoto fail;\n\t}\n\n\tif (copy_from_user(exec->shader_rec_u,\n\t\t\t   (void __user *)(uintptr_t)args->shader_rec,\n\t\t\t   args->shader_rec_size)) {\n\t\tret = -EFAULT;\n\t\tgoto fail;\n\t}\n\n\tif (copy_from_user(exec->uniforms_u,\n\t\t\t   (void __user *)(uintptr_t)args->uniforms,\n\t\t\t   args->uniforms_size)) {\n\t\tret = -EFAULT;\n\t\tgoto fail;\n\t}\n\n\tbo = vc4_bo_create(dev, exec_size, true);\n\tif (IS_ERR(bo)) {\n\t\tDRM_ERROR(\"Couldn't allocate BO for binning\\n\");\n\t\tret = PTR_ERR(bo);\n\t\tgoto fail;\n\t}\n\texec->exec_bo = &bo->base;\n\n\tlist_add_tail(&to_vc4_bo(&exec->exec_bo->base)->unref_head,\n\t\t      &exec->unref_list);\n\n\texec->ct0ca = exec->exec_bo->paddr + bin_offset;\n\n\texec->bin_u = bin;\n\n\texec->shader_rec_v = exec->exec_bo->vaddr + shader_rec_offset;\n\texec->shader_rec_p = exec->exec_bo->paddr + shader_rec_offset;\n\texec->shader_rec_size = args->shader_rec_size;\n\n\texec->uniforms_v = exec->exec_bo->vaddr + uniforms_offset;\n\texec->uniforms_p = exec->exec_bo->paddr + uniforms_offset;\n\texec->uniforms_size = args->uniforms_size;\n\n\tret = vc4_validate_bin_cl(dev,\n\t\t\t\t  exec->exec_bo->vaddr + bin_offset,\n\t\t\t\t  bin,\n\t\t\t\t  exec);\n\tif (ret)\n\t\tgoto fail;\n\n\tret = vc4_validate_shader_recs(dev, exec);\n\tif (ret)\n\t\tgoto fail;\n\n\t/* Block waiting on any previous rendering into the CS's VBO,\n\t * IB, or textures, so that pixels are actually written by the\n\t * time we try to read them.\n\t */\n\tret = vc4_wait_for_seqno(dev, exec->bin_dep_seqno, ~0ull, true);\n\nfail:\n\tdrm_free_large(temp);\n\treturn ret;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149768,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "vc4_get_bcl(struct drm_device *dev, struct vc4_exec_info *exec)\n{\n\tstruct drm_vc4_submit_cl *args = exec->args;\n\tvoid *temp = NULL;\n\tvoid *bin;\n\tint ret = 0;\n\tuint32_t bin_offset = 0;\n\tuint32_t shader_rec_offset = roundup(bin_offset + args->bin_cl_size,\n\t\t\t\t\t     16);\n\tuint32_t uniforms_offset = shader_rec_offset + args->shader_rec_size;\n\tuint32_t exec_size = uniforms_offset + args->uniforms_size;\n\tuint32_t temp_size = exec_size + (sizeof(struct vc4_shader_state) *\n\t\t\t\t\t  args->shader_rec_count);\n\tstruct vc4_bo *bo;\n\n\tif (shader_rec_offset < args->bin_cl_size ||\n\t    uniforms_offset < shader_rec_offset ||\n\t    exec_size < uniforms_offset ||\n\t    args->shader_rec_count >= (UINT_MAX /\n\t\t\t\t\t  sizeof(struct vc4_shader_state)) ||\n\t    temp_size < exec_size) {\n\t\tDRM_ERROR(\"overflow in exec arguments\\n\");\n\t\tgoto fail;\n\t}\n\n\t/* Allocate space where we'll store the copied in user command lists\n\t * and shader records.\n\t *\n\t * We don't just copy directly into the BOs because we need to\n\t * read the contents back for validation, and I think the\n\t * bo->vaddr is uncached access.\n\t */\n\ttemp = drm_malloc_ab(temp_size, 1);\n\tif (!temp) {\n\t\tDRM_ERROR(\"Failed to allocate storage for copying \"\n\t\t\t  \"in bin/render CLs.\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\tbin = temp + bin_offset;\n\texec->shader_rec_u = temp + shader_rec_offset;\n\texec->uniforms_u = temp + uniforms_offset;\n\texec->shader_state = temp + exec_size;\n\texec->shader_state_size = args->shader_rec_count;\n\n\tif (copy_from_user(bin,\n\t\t\t   (void __user *)(uintptr_t)args->bin_cl,\n\t\t\t   args->bin_cl_size)) {\n\t\tret = -EFAULT;\n\t\tgoto fail;\n\t}\n\n\tif (copy_from_user(exec->shader_rec_u,\n\t\t\t   (void __user *)(uintptr_t)args->shader_rec,\n\t\t\t   args->shader_rec_size)) {\n\t\tret = -EFAULT;\n\t\tgoto fail;\n\t}\n\n\tif (copy_from_user(exec->uniforms_u,\n\t\t\t   (void __user *)(uintptr_t)args->uniforms,\n\t\t\t   args->uniforms_size)) {\n\t\tret = -EFAULT;\n\t\tgoto fail;\n\t}\n\n\tbo = vc4_bo_create(dev, exec_size, true);\n\tif (IS_ERR(bo)) {\n\t\tDRM_ERROR(\"Couldn't allocate BO for binning\\n\");\n\t\tret = PTR_ERR(bo);\n\t\tgoto fail;\n\t}\n\texec->exec_bo = &bo->base;\n\n\tlist_add_tail(&to_vc4_bo(&exec->exec_bo->base)->unref_head,\n\t\t      &exec->unref_list);\n\n\texec->ct0ca = exec->exec_bo->paddr + bin_offset;\n\n\texec->bin_u = bin;\n\n\texec->shader_rec_v = exec->exec_bo->vaddr + shader_rec_offset;\n\texec->shader_rec_p = exec->exec_bo->paddr + shader_rec_offset;\n\texec->shader_rec_size = args->shader_rec_size;\n\n\texec->uniforms_v = exec->exec_bo->vaddr + uniforms_offset;\n\texec->uniforms_p = exec->exec_bo->paddr + uniforms_offset;\n\texec->uniforms_size = args->uniforms_size;\n\n\tret = vc4_validate_bin_cl(dev,\n\t\t\t\t  exec->exec_bo->vaddr + bin_offset,\n\t\t\t\t  bin,\n\t\t\t\t  exec);\n\tif (ret)\n\t\tgoto fail;\n\n\tret = vc4_validate_shader_recs(dev, exec);\n\tif (ret)\n\t\tgoto fail;\n\n\t/* Block waiting on any previous rendering into the CS's VBO,\n\t * IB, or textures, so that pixels are actually written by the\n\t * time we try to read them.\n\t */\n\tret = vc4_wait_for_seqno(dev, exec->bin_dep_seqno, ~0ull, true);\n\nfail:\n\tdrm_free_large(temp);\n\treturn ret;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149769,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static MagickOffsetType TIFFSeekCustomStream(const MagickOffsetType offset,\n  const int whence,void *user_data)\n{\n  PhotoshopProfile\n    *profile;\n\n  profile=(PhotoshopProfile *) user_data;\n  switch (whence)\n  {\n    case SEEK_SET:\n    default:\n    {\n      if (offset < 0)\n        return(-1);\n      profile->offset=offset;\n      break;\n    }\n    case SEEK_CUR:\n    {\n      if ((profile->offset+offset) < 0)\n        return(-1);\n      profile->offset+=offset;\n      break;\n    }\n    case SEEK_END:\n    {\n      if (((MagickOffsetType) profile->length+offset) < 0)\n        return(-1);\n      profile->offset=profile->length+offset;\n      break;\n    }\n  }\n\n  return(profile->offset);\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149770,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static MagickOffsetType TIFFSeekCustomStream(const MagickOffsetType offset,\n  const int whence,void *user_data)\n{\n  PhotoshopProfile\n    *profile;\n\n  profile=(PhotoshopProfile *) user_data;\n  switch (whence)\n  {\n    case SEEK_SET:\n    default:\n    {\n      if (offset < 0)\n        return(-1);\n      profile->offset=offset;\n      break;\n    }\n    case SEEK_CUR:\n    {\n      if (((offset > 0) && (profile->offset > (SSIZE_MAX-offset))) ||\n          ((offset < 0) && (profile->offset < (-SSIZE_MAX-offset))))\n        {\n          errno=EOVERFLOW;\n          return(-1);\n        }\n      if ((profile->offset+offset) < 0)\n        return(-1);\n      profile->offset+=offset;\n      break;\n    }\n    case SEEK_END:\n    {\n      if (((MagickOffsetType) profile->length+offset) < 0)\n        return(-1);\n      profile->offset=profile->length+offset;\n      break;\n    }\n  }\n\n  return(profile->offset);\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149771,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "int perf_cpu_time_max_percent_handler(struct ctl_table *table, int write,\n\t\t\t\tvoid __user *buffer, size_t *lenp,\n\t\t\t\tloff_t *ppos)\n{\n\tint ret = proc_dointvec(table, write, buffer, lenp, ppos);\n\n\tif (ret || !write)\n\t\treturn ret;\n\n\tif (sysctl_perf_cpu_time_max_percent == 100 ||\n\t    sysctl_perf_cpu_time_max_percent == 0) {\n\t\tprintk(KERN_WARNING\n\t\t       \"perf: Dynamic interrupt throttling disabled, can hang your system!\\n\");\n\t\tWRITE_ONCE(perf_sample_allowed_ns, 0);\n\t} else {\n\t\tupdate_perf_cpu_limits();\n\t}\n\n\treturn 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149772,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "int perf_cpu_time_max_percent_handler(struct ctl_table *table, int write,\n\t\t\t\tvoid __user *buffer, size_t *lenp,\n\t\t\t\tloff_t *ppos)\n{\n\tint ret = proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n\n\tif (ret || !write)\n\t\treturn ret;\n\n\tif (sysctl_perf_cpu_time_max_percent == 100 ||\n\t    sysctl_perf_cpu_time_max_percent == 0) {\n\t\tprintk(KERN_WARNING\n\t\t       \"perf: Dynamic interrupt throttling disabled, can hang your system!\\n\");\n\t\tWRITE_ONCE(perf_sample_allowed_ns, 0);\n\t} else {\n\t\tupdate_perf_cpu_limits();\n\t}\n\n\treturn 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149773,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "int git_delta_apply(\n\tvoid **out,\n\tsize_t *out_len,\n\tconst unsigned char *base,\n\tsize_t base_len,\n\tconst unsigned char *delta,\n\tsize_t delta_len)\n{\n\tconst unsigned char *delta_end = delta + delta_len;\n\tsize_t base_sz, res_sz, alloc_sz;\n\tunsigned char *res_dp;\n\n\t*out = NULL;\n\t*out_len = 0;\n\n\t/*\n\t * Check that the base size matches the data we were given;\n\t * if not we would underflow while accessing data from the\n\t * base object, resulting in data corruption or segfault.\n\t */\n\tif ((hdr_sz(&base_sz, &delta, delta_end) < 0) || (base_sz != base_len)) {\n\t\tgiterr_set(GITERR_INVALID, \"failed to apply delta: base size does not match given data\");\n\t\treturn -1;\n\t}\n\n\tif (hdr_sz(&res_sz, &delta, delta_end) < 0) {\n\t\tgiterr_set(GITERR_INVALID, \"failed to apply delta: base size does not match given data\");\n\t\treturn -1;\n\t}\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_sz, res_sz, 1);\n\tres_dp = git__malloc(alloc_sz);\n\tGITERR_CHECK_ALLOC(res_dp);\n\n\tres_dp[res_sz] = '\\0';\n\t*out = res_dp;\n\t*out_len = res_sz;\n\n\twhile (delta < delta_end) {\n\t\tunsigned char cmd = *delta++;\n\t\tif (cmd & 0x80) {\n\t\t\t/* cmd is a copy instruction; copy from the base. */\n\t\t\tsize_t off = 0, len = 0;\n\n#define ADD_DELTA(o, shift) { if (delta < delta_end) (o) |= ((unsigned) *delta++ << shift); else goto fail; }\n\t\t\tif (cmd & 0x01) ADD_DELTA(off, 0UL);\n\t\t\tif (cmd & 0x02) ADD_DELTA(off, 8UL);\n\t\t\tif (cmd & 0x04) ADD_DELTA(off, 16UL);\n\t\t\tif (cmd & 0x08) ADD_DELTA(off, 24UL);\n\n\t\t\tif (cmd & 0x10) ADD_DELTA(len, 0UL);\n\t\t\tif (cmd & 0x20) ADD_DELTA(len, 8UL);\n\t\t\tif (cmd & 0x40) ADD_DELTA(len, 16UL);\n\t\t\tif (!len)       len = 0x10000;\n#undef ADD_DELTA\n\n\t\t\tif (base_len < off + len || res_sz < len)\n\t\t\t\tgoto fail;\n\t\t\tmemcpy(res_dp, base + off, len);\n\t\t\tres_dp += len;\n\t\t\tres_sz -= len;\n\n\t\t} else if (cmd) {\n\t\t\t/*\n\t\t\t * cmd is a literal insert instruction; copy from\n\t\t\t * the delta stream itself.\n\t\t\t */\n\t\t\tif (delta_end - delta < cmd || res_sz < cmd)\n\t\t\t\tgoto fail;\n\t\t\tmemcpy(res_dp, delta, cmd);\n\t\t\tdelta += cmd;\n\t\t\tres_dp += cmd;\n\t\t\tres_sz -= cmd;\n\n\t\t} else {\n\t\t\t/* cmd == 0 is reserved for future encodings. */\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tif (delta != delta_end || res_sz)\n\t\tgoto fail;\n\treturn 0;\n\nfail:\n\tgit__free(*out);\n\n\t*out = NULL;\n\t*out_len = 0;\n\n\tgiterr_set(GITERR_INVALID, \"failed to apply delta\");\n\treturn -1;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149774,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "int git_delta_apply(\n\tvoid **out,\n\tsize_t *out_len,\n\tconst unsigned char *base,\n\tsize_t base_len,\n\tconst unsigned char *delta,\n\tsize_t delta_len)\n{\n\tconst unsigned char *delta_end = delta + delta_len;\n\tsize_t base_sz, res_sz, alloc_sz;\n\tunsigned char *res_dp;\n\n\t*out = NULL;\n\t*out_len = 0;\n\n\t/*\n\t * Check that the base size matches the data we were given;\n\t * if not we would underflow while accessing data from the\n\t * base object, resulting in data corruption or segfault.\n\t */\n\tif ((hdr_sz(&base_sz, &delta, delta_end) < 0) || (base_sz != base_len)) {\n\t\tgiterr_set(GITERR_INVALID, \"failed to apply delta: base size does not match given data\");\n\t\treturn -1;\n\t}\n\n\tif (hdr_sz(&res_sz, &delta, delta_end) < 0) {\n\t\tgiterr_set(GITERR_INVALID, \"failed to apply delta: base size does not match given data\");\n\t\treturn -1;\n\t}\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_sz, res_sz, 1);\n\tres_dp = git__malloc(alloc_sz);\n\tGITERR_CHECK_ALLOC(res_dp);\n\n\tres_dp[res_sz] = '\\0';\n\t*out = res_dp;\n\t*out_len = res_sz;\n\n\twhile (delta < delta_end) {\n\t\tunsigned char cmd = *delta++;\n\t\tif (cmd & 0x80) {\n\t\t\t/* cmd is a copy instruction; copy from the base. */\n\t\t\tsize_t off = 0, len = 0, end;\n\n#define ADD_DELTA(o, shift) { if (delta < delta_end) (o) |= ((unsigned) *delta++ << shift); else goto fail; }\n\t\t\tif (cmd & 0x01) ADD_DELTA(off, 0UL);\n\t\t\tif (cmd & 0x02) ADD_DELTA(off, 8UL);\n\t\t\tif (cmd & 0x04) ADD_DELTA(off, 16UL);\n\t\t\tif (cmd & 0x08) ADD_DELTA(off, 24UL);\n\n\t\t\tif (cmd & 0x10) ADD_DELTA(len, 0UL);\n\t\t\tif (cmd & 0x20) ADD_DELTA(len, 8UL);\n\t\t\tif (cmd & 0x40) ADD_DELTA(len, 16UL);\n\t\t\tif (!len)       len = 0x10000;\n#undef ADD_DELTA\n\n\t\t\tif (GIT_ADD_SIZET_OVERFLOW(&end, off, len) ||\n\t\t\t    base_len < end || res_sz < len)\n\t\t\t\tgoto fail;\n\n\t\t\tmemcpy(res_dp, base + off, len);\n\t\t\tres_dp += len;\n\t\t\tres_sz -= len;\n\n\t\t} else if (cmd) {\n\t\t\t/*\n\t\t\t * cmd is a literal insert instruction; copy from\n\t\t\t * the delta stream itself.\n\t\t\t */\n\t\t\tif (delta_end - delta < cmd || res_sz < cmd)\n\t\t\t\tgoto fail;\n\t\t\tmemcpy(res_dp, delta, cmd);\n\t\t\tdelta += cmd;\n\t\t\tres_dp += cmd;\n\t\t\tres_sz -= cmd;\n\n\t\t} else {\n\t\t\t/* cmd == 0 is reserved for future encodings. */\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tif (delta != delta_end || res_sz)\n\t\tgoto fail;\n\treturn 0;\n\nfail:\n\tgit__free(*out);\n\n\t*out = NULL;\n\t*out_len = 0;\n\n\tgiterr_set(GITERR_INVALID, \"failed to apply delta\");\n\treturn -1;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149775,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static int uvesafb_setcmap(struct fb_cmap *cmap, struct fb_info *info)\n{\n\tstruct uvesafb_pal_entry *entries;\n\tint shift = 16 - dac_width;\n\tint i, err = 0;\n\n\tif (info->var.bits_per_pixel == 8) {\n\t\tif (cmap->start + cmap->len > info->cmap.start +\n\t\t    info->cmap.len || cmap->start < info->cmap.start)\n\t\t\treturn -EINVAL;\n\n\t\tentries = kmalloc(sizeof(*entries) * cmap->len, GFP_KERNEL);\n\t\tif (!entries)\n\t\t\treturn -ENOMEM;\n\n\t\tfor (i = 0; i < cmap->len; i++) {\n\t\t\tentries[i].red   = cmap->red[i]   >> shift;\n\t\t\tentries[i].green = cmap->green[i] >> shift;\n\t\t\tentries[i].blue  = cmap->blue[i]  >> shift;\n\t\t\tentries[i].pad   = 0;\n\t\t}\n\t\terr = uvesafb_setpalette(entries, cmap->len, cmap->start, info);\n\t\tkfree(entries);\n\t} else {\n\t\t/*\n\t\t * For modes with bpp > 8, we only set the pseudo palette in\n\t\t * the fb_info struct. We rely on uvesafb_setcolreg to do all\n\t\t * sanity checking.\n\t\t */\n\t\tfor (i = 0; i < cmap->len; i++) {\n\t\t\terr |= uvesafb_setcolreg(cmap->start + i, cmap->red[i],\n\t\t\t\t\t\tcmap->green[i], cmap->blue[i],\n\t\t\t\t\t\t0, info);\n\t\t}\n\t}\n\treturn err;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149776,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static int uvesafb_setcmap(struct fb_cmap *cmap, struct fb_info *info)\n{\n\tstruct uvesafb_pal_entry *entries;\n\tint shift = 16 - dac_width;\n\tint i, err = 0;\n\n\tif (info->var.bits_per_pixel == 8) {\n\t\tif (cmap->start + cmap->len > info->cmap.start +\n\t\t    info->cmap.len || cmap->start < info->cmap.start)\n\t\t\treturn -EINVAL;\n\n\t\tentries = kmalloc_array(cmap->len, sizeof(*entries),\n\t\t\t\t\tGFP_KERNEL);\n\t\tif (!entries)\n\t\t\treturn -ENOMEM;\n\n\t\tfor (i = 0; i < cmap->len; i++) {\n\t\t\tentries[i].red   = cmap->red[i]   >> shift;\n\t\t\tentries[i].green = cmap->green[i] >> shift;\n\t\t\tentries[i].blue  = cmap->blue[i]  >> shift;\n\t\t\tentries[i].pad   = 0;\n\t\t}\n\t\terr = uvesafb_setpalette(entries, cmap->len, cmap->start, info);\n\t\tkfree(entries);\n\t} else {\n\t\t/*\n\t\t * For modes with bpp > 8, we only set the pseudo palette in\n\t\t * the fb_info struct. We rely on uvesafb_setcolreg to do all\n\t\t * sanity checking.\n\t\t */\n\t\tfor (i = 0; i < cmap->len; i++) {\n\t\t\terr |= uvesafb_setcolreg(cmap->start + i, cmap->red[i],\n\t\t\t\t\t\tcmap->green[i], cmap->blue[i],\n\t\t\t\t\t\t0, info);\n\t\t}\n\t}\n\treturn err;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149777,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static int b_unpack (lua_State *L) {\n  Header h;\n  const char *fmt = luaL_checkstring(L, 1);\n  size_t ld;\n  const char *data = luaL_checklstring(L, 2, &ld);\n  size_t pos = luaL_optinteger(L, 3, 1) - 1;\n  int n = 0;  /* number of results */\n  defaultoptions(&h);\n  while (*fmt) {\n    int opt = *fmt++;\n    size_t size = optsize(L, opt, &fmt);\n    pos += gettoalign(pos, &h, opt, size);\n    luaL_argcheck(L, pos+size <= ld, 2, \"data string too short\");\n    /* stack space for item + next position */\n    luaL_checkstack(L, 2, \"too many results\");\n    switch (opt) {\n      case 'b': case 'B': case 'h': case 'H':\n      case 'l': case 'L': case 'T': case 'i':  case 'I': {  /* integer types */\n        int issigned = islower(opt);\n        lua_Number res = getinteger(data+pos, h.endian, issigned, size);\n        lua_pushnumber(L, res); n++;\n        break;\n      }\n      case 'x': {\n        break;\n      }\n      case 'f': {\n        float f;\n        memcpy(&f, data+pos, size);\n        correctbytes((char *)&f, sizeof(f), h.endian);\n        lua_pushnumber(L, f); n++;\n        break;\n      }\n      case 'd': {\n        double d;\n        memcpy(&d, data+pos, size);\n        correctbytes((char *)&d, sizeof(d), h.endian);\n        lua_pushnumber(L, d); n++;\n        break;\n      }\n      case 'c': {\n        if (size == 0) {\n          if (n == 0 || !lua_isnumber(L, -1))\n            luaL_error(L, \"format 'c0' needs a previous size\");\n          size = lua_tonumber(L, -1);\n          lua_pop(L, 1); n--;\n          luaL_argcheck(L, size <= ld && pos <= ld - size,\n                           2, \"data string too short\");\n        }\n        lua_pushlstring(L, data+pos, size); n++;\n        break;\n      }\n      case 's': {\n        const char *e = (const char *)memchr(data+pos, '\\0', ld - pos);\n        if (e == NULL)\n          luaL_error(L, \"unfinished string in data\");\n        size = (e - (data+pos)) + 1;\n        lua_pushlstring(L, data+pos, size - 1); n++;\n        break;\n      }\n      default: controloptions(L, opt, &fmt, &h);\n    }\n    pos += size;\n  }\n  lua_pushinteger(L, pos + 1);  /* next position */\n  return n + 1;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149778,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static int b_unpack (lua_State *L) {\n  Header h;\n  const char *fmt = luaL_checkstring(L, 1);\n  size_t ld;\n  const char *data = luaL_checklstring(L, 2, &ld);\n  size_t pos = luaL_optinteger(L, 3, 1);\n  luaL_argcheck(L, pos > 0, 3, \"offset must be 1 or greater\");\n  pos--; /* Lua indexes are 1-based, but here we want 0-based for C\n          * pointer math. */\n  int n = 0;  /* number of results */\n  defaultoptions(&h);\n  while (*fmt) {\n    int opt = *fmt++;\n    size_t size = optsize(L, opt, &fmt);\n    pos += gettoalign(pos, &h, opt, size);\n    luaL_argcheck(L, size <= ld && pos <= ld - size,\n                   2, \"data string too short\");\n    /* stack space for item + next position */\n    luaL_checkstack(L, 2, \"too many results\");\n    switch (opt) {\n      case 'b': case 'B': case 'h': case 'H':\n      case 'l': case 'L': case 'T': case 'i':  case 'I': {  /* integer types */\n        int issigned = islower(opt);\n        lua_Number res = getinteger(data+pos, h.endian, issigned, size);\n        lua_pushnumber(L, res); n++;\n        break;\n      }\n      case 'x': {\n        break;\n      }\n      case 'f': {\n        float f;\n        memcpy(&f, data+pos, size);\n        correctbytes((char *)&f, sizeof(f), h.endian);\n        lua_pushnumber(L, f); n++;\n        break;\n      }\n      case 'd': {\n        double d;\n        memcpy(&d, data+pos, size);\n        correctbytes((char *)&d, sizeof(d), h.endian);\n        lua_pushnumber(L, d); n++;\n        break;\n      }\n      case 'c': {\n        if (size == 0) {\n          if (n == 0 || !lua_isnumber(L, -1))\n            luaL_error(L, \"format 'c0' needs a previous size\");\n          size = lua_tonumber(L, -1);\n          lua_pop(L, 1); n--;\n          luaL_argcheck(L, size <= ld && pos <= ld - size,\n                           2, \"data string too short\");\n        }\n        lua_pushlstring(L, data+pos, size); n++;\n        break;\n      }\n      case 's': {\n        const char *e = (const char *)memchr(data+pos, '\\0', ld - pos);\n        if (e == NULL)\n          luaL_error(L, \"unfinished string in data\");\n        size = (e - (data+pos)) + 1;\n        lua_pushlstring(L, data+pos, size - 1); n++;\n        break;\n      }\n      default: controloptions(L, opt, &fmt, &h);\n    }\n    pos += size;\n  }\n  lua_pushinteger(L, pos + 1);  /* next position */\n  return n + 1;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149779,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "bool copyaudiodata (AFfilehandle infile, AFfilehandle outfile, int trackid)\n{\n\tint frameSize = afGetVirtualFrameSize(infile, trackid, 1);\n\n\tconst int kBufferFrameCount = 65536;\n\tvoid *buffer = malloc(kBufferFrameCount * frameSize);\n\n\tAFframecount totalFrames = afGetFrameCount(infile, AF_DEFAULT_TRACK);\n\tAFframecount totalFramesWritten = 0;\n\n\tbool success = true;\n\n\twhile (totalFramesWritten < totalFrames)\n\t{\n\t\tAFframecount framesToRead = totalFrames - totalFramesWritten;\n\t\tif (framesToRead > kBufferFrameCount)\n\t\t\tframesToRead = kBufferFrameCount;\n\n\t\tAFframecount framesRead = afReadFrames(infile, trackid, buffer,\n\t\t\tframesToRead);\n\n\t\tif (framesRead < framesToRead)\n\t\t{\n\t\t\tfprintf(stderr, \"Bad read of audio track data.\\n\");\n\t\t\tsuccess = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tAFframecount framesWritten = afWriteFrames(outfile, trackid, buffer,\n\t\t\tframesRead);\n\n\t\tif (framesWritten < framesRead)\n\t\t{\n\t\t\tfprintf(stderr, \"Bad write of audio track data.\\n\");\n\t\t\tsuccess = false;\n\t\t\tbreak;\n\t\t}\n\n\t\ttotalFramesWritten += framesWritten;\n\t}\n\n\tfree(buffer);\n\n\treturn success;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149780,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "bool copyaudiodata (AFfilehandle infile, AFfilehandle outfile, int trackid)\n{\n\tint frameSize = afGetVirtualFrameSize(infile, trackid, 1);\n\n\tint kBufferFrameCount = 65536;\n\tint bufferSize;\n\twhile (multiplyCheckOverflow(kBufferFrameCount, frameSize, &bufferSize))\n\t\tkBufferFrameCount /= 2;\n\tvoid *buffer = malloc(bufferSize);\n\n\tAFframecount totalFrames = afGetFrameCount(infile, AF_DEFAULT_TRACK);\n\tAFframecount totalFramesWritten = 0;\n\n\tbool success = true;\n\n\twhile (totalFramesWritten < totalFrames)\n\t{\n\t\tAFframecount framesToRead = totalFrames - totalFramesWritten;\n\t\tif (framesToRead > kBufferFrameCount)\n\t\t\tframesToRead = kBufferFrameCount;\n\n\t\tAFframecount framesRead = afReadFrames(infile, trackid, buffer,\n\t\t\tframesToRead);\n\n\t\tif (framesRead < framesToRead)\n\t\t{\n\t\t\tfprintf(stderr, \"Bad read of audio track data.\\n\");\n\t\t\tsuccess = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tAFframecount framesWritten = afWriteFrames(outfile, trackid, buffer,\n\t\t\tframesRead);\n\n\t\tif (framesWritten < framesRead)\n\t\t{\n\t\t\tfprintf(stderr, \"Bad write of audio track data.\\n\");\n\t\t\tsuccess = false;\n\t\t\tbreak;\n\t\t}\n\n\t\ttotalFramesWritten += framesWritten;\n\t}\n\n\tfree(buffer);\n\n\treturn success;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149781,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "ZEND_API void ZEND_FASTCALL _zend_hash_init(HashTable *ht, uint32_t nSize, dtor_func_t pDestructor, zend_bool persistent ZEND_FILE_LINE_DC)\n{\n\tGC_REFCOUNT(ht) = 1;\n\tGC_TYPE_INFO(ht) = IS_ARRAY;\n\tht->u.flags = (persistent ? HASH_FLAG_PERSISTENT : 0) | HASH_FLAG_APPLY_PROTECTION | HASH_FLAG_STATIC_KEYS;\n\tht->nTableSize = zend_hash_check_size(nSize);\n\tht->nTableMask = HT_MIN_MASK;\n\tHT_SET_DATA_ADDR(ht, &uninitialized_bucket);\n\tht->nNumUsed = 0;\n\tht->nNumOfElements = 0;\n\tht->nInternalPointer = HT_INVALID_IDX;\n\tht->nNextFreeElement = 0;\n\tht->pDestructor = pDestructor;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149782,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "ZEND_API void ZEND_FASTCALL _zend_hash_init(HashTable *ht, uint32_t nSize, dtor_func_t pDestructor, zend_bool persistent ZEND_FILE_LINE_DC)\n{\n\tGC_REFCOUNT(ht) = 1;\n\tGC_TYPE_INFO(ht) = IS_ARRAY;\n\tht->u.flags = (persistent ? HASH_FLAG_PERSISTENT : 0) | HASH_FLAG_APPLY_PROTECTION | HASH_FLAG_STATIC_KEYS;\n\tht->nTableMask = HT_MIN_MASK;\n\tHT_SET_DATA_ADDR(ht, &uninitialized_bucket);\n\tht->nNumUsed = 0;\n\tht->nNumOfElements = 0;\n\tht->nInternalPointer = HT_INVALID_IDX;\n\tht->nNextFreeElement = 0;\n\tht->pDestructor = pDestructor;\n\tht->nTableSize = zend_hash_check_size(nSize);\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149783,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "REGEXP *\nPerl_re_op_compile(pTHX_ SV ** const patternp, int pat_count,\n\t\t    OP *expr, const regexp_engine* eng, REGEXP *old_re,\n\t\t     bool *is_bare_re, const U32 orig_rx_flags, const U32 pm_flags)\n{\n    dVAR;\n    REGEXP *Rx;         /* Capital 'R' means points to a REGEXP */\n    STRLEN plen;\n    char *exp;\n    regnode *scan;\n    I32 flags;\n    SSize_t minlen = 0;\n    U32 rx_flags;\n    SV *pat;\n    SV** new_patternp = patternp;\n\n    /* these are all flags - maybe they should be turned\n     * into a single int with different bit masks */\n    I32 sawlookahead = 0;\n    I32 sawplus = 0;\n    I32 sawopen = 0;\n    I32 sawminmod = 0;\n\n    regex_charset initial_charset = get_regex_charset(orig_rx_flags);\n    bool recompile = 0;\n    bool runtime_code = 0;\n    scan_data_t data;\n    RExC_state_t RExC_state;\n    RExC_state_t * const pRExC_state = &RExC_state;\n#ifdef TRIE_STUDY_OPT\n    int restudied = 0;\n    RExC_state_t copyRExC_state;\n#endif\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_RE_OP_COMPILE;\n\n    DEBUG_r(if (!PL_colorset) reginitcolors());\n\n    /* Initialize these here instead of as-needed, as is quick and avoids\n     * having to test them each time otherwise */\n    if (! PL_InBitmap) {\n#ifdef DEBUGGING\n        char * dump_len_string;\n#endif\n\n        /* This is calculated here, because the Perl program that generates the\n         * static global ones doesn't currently have access to\n         * NUM_ANYOF_CODE_POINTS */\n\tPL_InBitmap = _new_invlist(2);\n\tPL_InBitmap = _add_range_to_invlist(PL_InBitmap, 0,\n                                                    NUM_ANYOF_CODE_POINTS - 1);\n#ifdef DEBUGGING\n        dump_len_string = PerlEnv_getenv(\"PERL_DUMP_RE_MAX_LEN\");\n        if (   ! dump_len_string\n            || ! grok_atoUV(dump_len_string, (UV *)&PL_dump_re_max_len, NULL))\n        {\n            PL_dump_re_max_len = 60;    /* A reasonable default */\n        }\n#endif\n    }\n\n    pRExC_state->warn_text = NULL;\n    pRExC_state->unlexed_names = NULL;\n    pRExC_state->code_blocks = NULL;\n\n    if (is_bare_re)\n\t*is_bare_re = FALSE;\n\n    if (expr && (expr->op_type == OP_LIST ||\n\t\t(expr->op_type == OP_NULL && expr->op_targ == OP_LIST))) {\n\t/* allocate code_blocks if needed */\n\tOP *o;\n\tint ncode = 0;\n\n\tfor (o = cLISTOPx(expr)->op_first; o; o = OpSIBLING(o))\n\t    if (o->op_type == OP_NULL && (o->op_flags & OPf_SPECIAL))\n\t\tncode++; /* count of DO blocks */\n\n\tif (ncode)\n            pRExC_state->code_blocks = S_alloc_code_blocks(aTHX_ ncode);\n    }\n\n    if (!pat_count) {\n        /* compile-time pattern with just OP_CONSTs and DO blocks */\n\n        int n;\n        OP *o;\n\n        /* find how many CONSTs there are */\n        assert(expr);\n        n = 0;\n        if (expr->op_type == OP_CONST)\n            n = 1;\n        else\n            for (o = cLISTOPx(expr)->op_first; o; o = OpSIBLING(o)) {\n                if (o->op_type == OP_CONST)\n                    n++;\n            }\n\n        /* fake up an SV array */\n\n        assert(!new_patternp);\n        Newx(new_patternp, n, SV*);\n        SAVEFREEPV(new_patternp);\n        pat_count = n;\n\n        n = 0;\n        if (expr->op_type == OP_CONST)\n            new_patternp[n] = cSVOPx_sv(expr);\n        else\n            for (o = cLISTOPx(expr)->op_first; o; o = OpSIBLING(o)) {\n                if (o->op_type == OP_CONST)\n                    new_patternp[n++] = cSVOPo_sv;\n            }\n\n    }\n\n    DEBUG_PARSE_r(Perl_re_printf( aTHX_\n        \"Assembling pattern from %d elements%s\\n\", pat_count,\n            orig_rx_flags & RXf_SPLIT ? \" for split\" : \"\"));\n\n    /* set expr to the first arg op */\n\n    if (pRExC_state->code_blocks && pRExC_state->code_blocks->count\n         && expr->op_type != OP_CONST)\n    {\n            expr = cLISTOPx(expr)->op_first;\n            assert(   expr->op_type == OP_PUSHMARK\n                   || (expr->op_type == OP_NULL && expr->op_targ == OP_PUSHMARK)\n                   || expr->op_type == OP_PADRANGE);\n            expr = OpSIBLING(expr);\n    }\n\n    pat = S_concat_pat(aTHX_ pRExC_state, NULL, new_patternp, pat_count,\n                        expr, &recompile, NULL);\n\n    /* handle bare (possibly after overloading) regex: foo =~ $re */\n    {\n        SV *re = pat;\n        if (SvROK(re))\n            re = SvRV(re);\n        if (SvTYPE(re) == SVt_REGEXP) {\n            if (is_bare_re)\n                *is_bare_re = TRUE;\n            SvREFCNT_inc(re);\n            DEBUG_PARSE_r(Perl_re_printf( aTHX_\n                \"Precompiled pattern%s\\n\",\n                    orig_rx_flags & RXf_SPLIT ? \" for split\" : \"\"));\n\n            return (REGEXP*)re;\n        }\n    }\n\n    exp = SvPV_nomg(pat, plen);\n\n    if (!eng->op_comp) {\n\tif ((SvUTF8(pat) && IN_BYTES)\n\t\t|| SvGMAGICAL(pat) || SvAMAGIC(pat))\n\t{\n\t    /* make a temporary copy; either to convert to bytes,\n\t     * or to avoid repeating get-magic / overloaded stringify */\n\t    pat = newSVpvn_flags(exp, plen, SVs_TEMP |\n\t\t\t\t\t(IN_BYTES ? 0 : SvUTF8(pat)));\n\t}\n\treturn CALLREGCOMP_ENG(eng, pat, orig_rx_flags);\n    }\n\n    /* ignore the utf8ness if the pattern is 0 length */\n    RExC_utf8 = RExC_orig_utf8 = (plen == 0 || IN_BYTES) ? 0 : SvUTF8(pat);\n    RExC_uni_semantics = 0;\n    RExC_contains_locale = 0;\n    RExC_strict = cBOOL(pm_flags & RXf_PMf_STRICT);\n    RExC_in_script_run = 0;\n    RExC_study_started = 0;\n    pRExC_state->runtime_code_qr = NULL;\n    RExC_frame_head= NULL;\n    RExC_frame_last= NULL;\n    RExC_frame_count= 0;\n    RExC_latest_warn_offset = 0;\n    RExC_use_BRANCHJ = 0;\n    RExC_total_parens = 0;\n    RExC_open_parens = NULL;\n    RExC_close_parens = NULL;\n    RExC_paren_names = NULL;\n    RExC_size = 0;\n    RExC_seen_d_op = FALSE;\n#ifdef DEBUGGING\n    RExC_paren_name_list = NULL;\n#endif\n\n    DEBUG_r({\n        RExC_mysv1= sv_newmortal();\n        RExC_mysv2= sv_newmortal();\n    });\n\n    DEBUG_COMPILE_r({\n            SV *dsv= sv_newmortal();\n            RE_PV_QUOTED_DECL(s, RExC_utf8, dsv, exp, plen, PL_dump_re_max_len);\n            Perl_re_printf( aTHX_  \"%sCompiling REx%s %s\\n\",\n                          PL_colors[4], PL_colors[5], s);\n        });\n\n    /* we jump here if we have to recompile, e.g., from upgrading the pattern\n     * to utf8 */\n\n    if ((pm_flags & PMf_USE_RE_EVAL)\n\t\t/* this second condition covers the non-regex literal case,\n\t\t * i.e.  $foo =~ '(?{})'. */\n\t\t|| (IN_PERL_COMPILETIME && (PL_hints & HINT_RE_EVAL))\n    )\n\truntime_code = S_has_runtime_code(aTHX_ pRExC_state, exp, plen);\n\n  redo_parse:\n    /* return old regex if pattern hasn't changed */\n    /* XXX: note in the below we have to check the flags as well as the\n     * pattern.\n     *\n     * Things get a touch tricky as we have to compare the utf8 flag\n     * independently from the compile flags.  */\n\n    if (   old_re\n        && !recompile\n        && !!RX_UTF8(old_re) == !!RExC_utf8\n        && ( RX_COMPFLAGS(old_re) == ( orig_rx_flags & RXf_PMf_FLAGCOPYMASK ) )\n\t&& RX_PRECOMP(old_re)\n\t&& RX_PRELEN(old_re) == plen\n        && memEQ(RX_PRECOMP(old_re), exp, plen)\n\t&& !runtime_code /* with runtime code, always recompile */ )\n    {\n        return old_re;\n    }\n\n    /* Allocate the pattern's SV */\n    RExC_rx_sv = Rx = (REGEXP*) newSV_type(SVt_REGEXP);\n    RExC_rx = ReANY(Rx);\n    if ( RExC_rx == NULL )\n        FAIL(\"Regexp out of space\");\n\n    rx_flags = orig_rx_flags;\n\n    if (   (UTF || RExC_uni_semantics)\n        && initial_charset == REGEX_DEPENDS_CHARSET)\n    {\n\n\t/* Set to use unicode semantics if the pattern is in utf8 and has the\n\t * 'depends' charset specified, as it means unicode when utf8  */\n\tset_regex_charset(&rx_flags, REGEX_UNICODE_CHARSET);\n        RExC_uni_semantics = 1;\n    }\n\n    RExC_pm_flags = pm_flags;\n\n    if (runtime_code) {\n        assert(TAINTING_get || !TAINT_get);\n\tif (TAINT_get)\n\t    Perl_croak(aTHX_ \"Eval-group in insecure regular expression\");\n\n\tif (!S_compile_runtime_code(aTHX_ pRExC_state, exp, plen)) {\n\t    /* whoops, we have a non-utf8 pattern, whilst run-time code\n\t     * got compiled as utf8. Try again with a utf8 pattern */\n            S_pat_upgrade_to_utf8(aTHX_ pRExC_state, &exp, &plen,\n                pRExC_state->code_blocks ? pRExC_state->code_blocks->count : 0);\n            goto redo_parse;\n\t}\n    }\n    assert(!pRExC_state->runtime_code_qr);\n\n    RExC_sawback = 0;\n\n    RExC_seen = 0;\n    RExC_maxlen = 0;\n    RExC_in_lookbehind = 0;\n    RExC_seen_zerolen = *exp == '^' ? -1 : 0;\n#ifdef EBCDIC\n    RExC_recode_x_to_native = 0;\n#endif\n    RExC_in_multi_char_class = 0;\n\n    RExC_start = RExC_copy_start_in_constructed = RExC_copy_start_in_input = RExC_precomp = exp;\n    RExC_precomp_end = RExC_end = exp + plen;\n    RExC_nestroot = 0;\n    RExC_whilem_seen = 0;\n    RExC_end_op = NULL;\n    RExC_recurse = NULL;\n    RExC_study_chunk_recursed = NULL;\n    RExC_study_chunk_recursed_bytes= 0;\n    RExC_recurse_count = 0;\n    pRExC_state->code_index = 0;\n\n    /* Initialize the string in the compiled pattern.  This is so that there is\n     * something to output if necessary */\n    set_regex_pv(pRExC_state, Rx);\n\n    DEBUG_PARSE_r({\n        Perl_re_printf( aTHX_\n            \"Starting parse and generation\\n\");\n        RExC_lastnum=0;\n        RExC_lastparse=NULL;\n    });\n\n    /* Allocate space and zero-initialize. Note, the two step process\n       of zeroing when in debug mode, thus anything assigned has to\n       happen after that */\n    if (!  RExC_size) {\n\n        /* On the first pass of the parse, we guess how big this will be.  Then\n         * we grow in one operation to that amount and then give it back.  As\n         * we go along, we re-allocate what we need.\n         *\n         * XXX Currently the guess is essentially that the pattern will be an\n         * EXACT node with one byte input, one byte output.  This is crude, and\n         * better heuristics are welcome.\n         *\n         * On any subsequent passes, we guess what we actually computed in the\n         * latest earlier pass.  Such a pass probably didn't complete so is\n         * missing stuff.  We could improve those guesses by knowing where the\n         * parse stopped, and use the length so far plus apply the above\n         * assumption to what's left. */\n        RExC_size = STR_SZ(RExC_end - RExC_start);\n    }\n\n    Newxc(RExC_rxi, sizeof(regexp_internal) + RExC_size, char, regexp_internal);\n    if ( RExC_rxi == NULL )\n        FAIL(\"Regexp out of space\");\n\n    Zero(RExC_rxi, sizeof(regexp_internal) + RExC_size, char);\n    RXi_SET( RExC_rx, RExC_rxi );\n\n    /* We start from 0 (over from 0 in the case this is a reparse.  The first\n     * node parsed will give back any excess memory we have allocated so far).\n     * */\n    RExC_size = 0;\n\n    /* non-zero initialization begins here */\n    RExC_rx->engine= eng;\n    RExC_rx->extflags = rx_flags;\n    RXp_COMPFLAGS(RExC_rx) = orig_rx_flags & RXf_PMf_FLAGCOPYMASK;\n\n    if (pm_flags & PMf_IS_QR) {\n\tRExC_rxi->code_blocks = pRExC_state->code_blocks;\n        if (RExC_rxi->code_blocks) {\n            RExC_rxi->code_blocks->refcnt++;\n        }\n    }\n\n    RExC_rx->intflags = 0;\n\n    RExC_flags = rx_flags;\t/* don't let top level (?i) bleed */\n    RExC_parse = exp;\n\n    /* This NUL is guaranteed because the pattern comes from an SV*, and the sv\n     * code makes sure the final byte is an uncounted NUL.  But should this\n     * ever not be the case, lots of things could read beyond the end of the\n     * buffer: loops like\n     *      while(isFOO(*RExC_parse)) RExC_parse++;\n     *      strchr(RExC_parse, \"foo\");\n     * etc.  So it is worth noting. */\n    assert(*RExC_end == '\\0');\n\n    RExC_naughty = 0;\n    RExC_npar = 1;\n    RExC_parens_buf_size = 0;\n    RExC_emit_start = RExC_rxi->program;\n    pRExC_state->code_index = 0;\n\n    *((char*) RExC_emit_start) = (char) REG_MAGIC;\n    RExC_emit = 1;\n\n    /* Do the parse */\n    if (reg(pRExC_state, 0, &flags, 1)) {\n\n        /* Success!, But we may need to redo the parse knowing how many parens\n         * there actually are */\n        if (IN_PARENS_PASS) {\n            flags |= RESTART_PARSE;\n        }\n\n        /* We have that number in RExC_npar */\n        RExC_total_parens = RExC_npar;\n    }\n    else if (! MUST_RESTART(flags)) {\n\tReREFCNT_dec(Rx);\n        Perl_croak(aTHX_ \"panic: reg returned failure to re_op_compile, flags=%#\" UVxf, (UV) flags);\n    }\n\n    /* Here, we either have success, or we have to redo the parse for some reason */\n    if (MUST_RESTART(flags)) {\n\n        /* It's possible to write a regexp in ascii that represents Unicode\n        codepoints outside of the byte range, such as via \\x{100}. If we\n        detect such a sequence we have to convert the entire pattern to utf8\n        and then recompile, as our sizing calculation will have been based\n        on 1 byte == 1 character, but we will need to use utf8 to encode\n        at least some part of the pattern, and therefore must convert the whole\n        thing.\n        -- dmq */\n        if (flags & NEED_UTF8) {\n\n            /* We have stored the offset of the final warning output so far.\n             * That must be adjusted.  Any variant characters between the start\n             * of the pattern and this warning count for 2 bytes in the final,\n             * so just add them again */\n            if (UNLIKELY(RExC_latest_warn_offset > 0)) {\n                RExC_latest_warn_offset +=\n                            variant_under_utf8_count((U8 *) exp, (U8 *) exp\n                                                + RExC_latest_warn_offset);\n            }\n            S_pat_upgrade_to_utf8(aTHX_ pRExC_state, &exp, &plen,\n            pRExC_state->code_blocks ? pRExC_state->code_blocks->count : 0);\n            DEBUG_PARSE_r(Perl_re_printf( aTHX_ \"Need to redo parse after upgrade\\n\"));\n        }\n        else {\n            DEBUG_PARSE_r(Perl_re_printf( aTHX_ \"Need to redo parse\\n\"));\n        }\n\n        if (ALL_PARENS_COUNTED) {\n            /* Make enough room for all the known parens, and zero it */\n            Renew(RExC_open_parens, RExC_total_parens, regnode_offset);\n            Zero(RExC_open_parens, RExC_total_parens, regnode_offset);\n            RExC_open_parens[0] = 1;    /* +1 for REG_MAGIC */\n\n            Renew(RExC_close_parens, RExC_total_parens, regnode_offset);\n            Zero(RExC_close_parens, RExC_total_parens, regnode_offset);\n        }\n        else { /* Parse did not complete.  Reinitialize the parentheses\n                  structures */\n            RExC_total_parens = 0;\n            if (RExC_open_parens) {\n                Safefree(RExC_open_parens);\n                RExC_open_parens = NULL;\n            }\n            if (RExC_close_parens) {\n                Safefree(RExC_close_parens);\n                RExC_close_parens = NULL;\n            }\n        }\n\n        /* Clean up what we did in this parse */\n        SvREFCNT_dec_NN(RExC_rx_sv);\n\n        goto redo_parse;\n    }\n\n    /* Here, we have successfully parsed and generated the pattern's program\n     * for the regex engine.  We are ready to finish things up and look for\n     * optimizations. */\n\n    /* Update the string to compile, with correct modifiers, etc */\n    set_regex_pv(pRExC_state, Rx);\n\n    RExC_rx->nparens = RExC_total_parens - 1;\n\n    /* Uses the upper 4 bits of the FLAGS field, so keep within that size */\n    if (RExC_whilem_seen > 15)\n        RExC_whilem_seen = 15;\n\n    DEBUG_PARSE_r({\n        Perl_re_printf( aTHX_\n            \"Required size %\" IVdf \" nodes\\n\", (IV)RExC_size);\n        RExC_lastnum=0;\n        RExC_lastparse=NULL;\n    });\n\n#ifdef RE_TRACK_PATTERN_OFFSETS\n    DEBUG_OFFSETS_r(Perl_re_printf( aTHX_\n                          \"%s %\" UVuf \" bytes for offset annotations.\\n\",\n                          RExC_offsets ? \"Got\" : \"Couldn't get\",\n                          (UV)((RExC_offsets[0] * 2 + 1))));\n    DEBUG_OFFSETS_r(if (RExC_offsets) {\n        const STRLEN len = RExC_offsets[0];\n        STRLEN i;\n        GET_RE_DEBUG_FLAGS_DECL;\n        Perl_re_printf( aTHX_\n                      \"Offsets: [%\" UVuf \"]\\n\\t\", (UV)RExC_offsets[0]);\n        for (i = 1; i <= len; i++) {\n            if (RExC_offsets[i*2-1] || RExC_offsets[i*2])\n                Perl_re_printf( aTHX_  \"%\" UVuf \":%\" UVuf \"[%\" UVuf \"] \",\n                (UV)i, (UV)RExC_offsets[i*2-1], (UV)RExC_offsets[i*2]);\n        }\n        Perl_re_printf( aTHX_  \"\\n\");\n    });\n\n#else\n    SetProgLen(RExC_rxi,RExC_size);\n#endif\n\n    DEBUG_OPTIMISE_r(\n        Perl_re_printf( aTHX_  \"Starting post parse optimization\\n\");\n    );\n\n    /* XXXX To minimize changes to RE engine we always allocate\n       3-units-long substrs field. */\n    Newx(RExC_rx->substrs, 1, struct reg_substr_data);\n    if (RExC_recurse_count) {\n        Newx(RExC_recurse, RExC_recurse_count, regnode *);\n        SAVEFREEPV(RExC_recurse);\n    }\n\n    if (RExC_seen & REG_RECURSE_SEEN) {\n        /* Note, RExC_total_parens is 1 + the number of parens in a pattern.\n         * So its 1 if there are no parens. */\n        RExC_study_chunk_recursed_bytes= (RExC_total_parens >> 3) +\n                                         ((RExC_total_parens & 0x07) != 0);\n        Newx(RExC_study_chunk_recursed,\n             RExC_study_chunk_recursed_bytes * RExC_total_parens, U8);\n        SAVEFREEPV(RExC_study_chunk_recursed);\n    }\n\n  reStudy:\n    RExC_rx->minlen = minlen = sawlookahead = sawplus = sawopen = sawminmod = 0;\n    DEBUG_r(\n        RExC_study_chunk_recursed_count= 0;\n    );\n    Zero(RExC_rx->substrs, 1, struct reg_substr_data);\n    if (RExC_study_chunk_recursed) {\n        Zero(RExC_study_chunk_recursed,\n             RExC_study_chunk_recursed_bytes * RExC_total_parens, U8);\n    }\n\n\n#ifdef TRIE_STUDY_OPT\n    if (!restudied) {\n        StructCopy(&zero_scan_data, &data, scan_data_t);\n        copyRExC_state = RExC_state;\n    } else {\n        U32 seen=RExC_seen;\n        DEBUG_OPTIMISE_r(Perl_re_printf( aTHX_ \"Restudying\\n\"));\n\n        RExC_state = copyRExC_state;\n        if (seen & REG_TOP_LEVEL_BRANCHES_SEEN)\n            RExC_seen |= REG_TOP_LEVEL_BRANCHES_SEEN;\n        else\n            RExC_seen &= ~REG_TOP_LEVEL_BRANCHES_SEEN;\n\tStructCopy(&zero_scan_data, &data, scan_data_t);\n    }\n#else\n    StructCopy(&zero_scan_data, &data, scan_data_t);\n#endif\n\n    /* Dig out information for optimizations. */\n    RExC_rx->extflags = RExC_flags; /* was pm_op */\n    /*dmq: removed as part of de-PMOP: pm->op_pmflags = RExC_flags; */\n\n    if (UTF)\n\tSvUTF8_on(Rx);\t/* Unicode in it? */\n    RExC_rxi->regstclass = NULL;\n    if (RExC_naughty >= TOO_NAUGHTY)\t/* Probably an expensive pattern. */\n\tRExC_rx->intflags |= PREGf_NAUGHTY;\n    scan = RExC_rxi->program + 1;\t\t/* First BRANCH. */\n\n    /* testing for BRANCH here tells us whether there is \"must appear\"\n       data in the pattern. If there is then we can use it for optimisations */\n    if (!(RExC_seen & REG_TOP_LEVEL_BRANCHES_SEEN)) { /*  Only one top-level choice.\n                                                  */\n\tSSize_t fake;\n\tSTRLEN longest_length[2];\n\tregnode_ssc ch_class; /* pointed to by data */\n\tint stclass_flag;\n\tSSize_t last_close = 0; /* pointed to by data */\n        regnode *first= scan;\n        regnode *first_next= regnext(first);\n        int i;\n\n\t/*\n\t * Skip introductions and multiplicators >= 1\n\t * so that we can extract the 'meat' of the pattern that must\n\t * match in the large if() sequence following.\n\t * NOTE that EXACT is NOT covered here, as it is normally\n\t * picked up by the optimiser separately.\n\t *\n\t * This is unfortunate as the optimiser isnt handling lookahead\n\t * properly currently.\n\t *\n\t */\n\twhile ((OP(first) == OPEN && (sawopen = 1)) ||\n\t       /* An OR of *one* alternative - should not happen now. */\n\t    (OP(first) == BRANCH && OP(first_next) != BRANCH) ||\n\t    /* for now we can't handle lookbehind IFMATCH*/\n\t    (OP(first) == IFMATCH && !first->flags && (sawlookahead = 1)) ||\n\t    (OP(first) == PLUS) ||\n\t    (OP(first) == MINMOD) ||\n\t       /* An {n,m} with n>0 */\n\t    (PL_regkind[OP(first)] == CURLY && ARG1(first) > 0) ||\n\t    (OP(first) == NOTHING && PL_regkind[OP(first_next)] != END ))\n\t{\n\t\t/*\n\t\t * the only op that could be a regnode is PLUS, all the rest\n\t\t * will be regnode_1 or regnode_2.\n\t\t *\n                 * (yves doesn't think this is true)\n\t\t */\n\t\tif (OP(first) == PLUS)\n\t\t    sawplus = 1;\n                else {\n                    if (OP(first) == MINMOD)\n                        sawminmod = 1;\n\t\t    first += regarglen[OP(first)];\n                }\n\t\tfirst = NEXTOPER(first);\n\t\tfirst_next= regnext(first);\n\t}\n\n\t/* Starting-point info. */\n      again:\n        DEBUG_PEEP(\"first:\", first, 0, 0);\n        /* Ignore EXACT as we deal with it later. */\n\tif (PL_regkind[OP(first)] == EXACT) {\n\t    if (   OP(first) == EXACT\n                || OP(first) == EXACT_ONLY8\n                || OP(first) == EXACTL)\n            {\n\t\tNOOP;\t/* Empty, get anchored substr later. */\n            }\n\t    else\n\t\tRExC_rxi->regstclass = first;\n\t}\n#ifdef TRIE_STCLASS\n\telse if (PL_regkind[OP(first)] == TRIE &&\n\t        ((reg_trie_data *)RExC_rxi->data->data[ ARG(first) ])->minlen>0)\n\t{\n            /* this can happen only on restudy */\n            RExC_rxi->regstclass = construct_ahocorasick_from_trie(pRExC_state, (regnode *)first, 0);\n\t}\n#endif\n\telse if (REGNODE_SIMPLE(OP(first)))\n\t    RExC_rxi->regstclass = first;\n\telse if (PL_regkind[OP(first)] == BOUND ||\n\t\t PL_regkind[OP(first)] == NBOUND)\n\t    RExC_rxi->regstclass = first;\n\telse if (PL_regkind[OP(first)] == BOL) {\n            RExC_rx->intflags |= (OP(first) == MBOL\n                           ? PREGf_ANCH_MBOL\n                           : PREGf_ANCH_SBOL);\n\t    first = NEXTOPER(first);\n\t    goto again;\n\t}\n\telse if (OP(first) == GPOS) {\n            RExC_rx->intflags |= PREGf_ANCH_GPOS;\n\t    first = NEXTOPER(first);\n\t    goto again;\n\t}\n\telse if ((!sawopen || !RExC_sawback) &&\n            !sawlookahead &&\n\t    (OP(first) == STAR &&\n\t    PL_regkind[OP(NEXTOPER(first))] == REG_ANY) &&\n            !(RExC_rx->intflags & PREGf_ANCH) && !pRExC_state->code_blocks)\n\t{\n\t    /* turn .* into ^.* with an implied $*=1 */\n\t    const int type =\n\t\t(OP(NEXTOPER(first)) == REG_ANY)\n                    ? PREGf_ANCH_MBOL\n                    : PREGf_ANCH_SBOL;\n            RExC_rx->intflags |= (type | PREGf_IMPLICIT);\n\t    first = NEXTOPER(first);\n\t    goto again;\n\t}\n        if (sawplus && !sawminmod && !sawlookahead\n            && (!sawopen || !RExC_sawback)\n\t    && !pRExC_state->code_blocks) /* May examine pos and $& */\n\t    /* x+ must match at the 1st pos of run of x's */\n\t    RExC_rx->intflags |= PREGf_SKIP;\n\n\t/* Scan is after the zeroth branch, first is atomic matcher. */\n#ifdef TRIE_STUDY_OPT\n\tDEBUG_PARSE_r(\n\t    if (!restudied)\n                Perl_re_printf( aTHX_  \"first at %\" IVdf \"\\n\",\n\t\t\t      (IV)(first - scan + 1))\n        );\n#else\n\tDEBUG_PARSE_r(\n            Perl_re_printf( aTHX_  \"first at %\" IVdf \"\\n\",\n\t        (IV)(first - scan + 1))\n        );\n#endif\n\n\n\t/*\n\t* If there's something expensive in the r.e., find the\n\t* longest literal string that must appear and make it the\n\t* regmust.  Resolve ties in favor of later strings, since\n\t* the regstart check works with the beginning of the r.e.\n\t* and avoiding duplication strengthens checking.  Not a\n\t* strong reason, but sufficient in the absence of others.\n\t* [Now we resolve ties in favor of the earlier string if\n\t* it happens that c_offset_min has been invalidated, since the\n\t* earlier string may buy us something the later one won't.]\n\t*/\n\n\tdata.substrs[0].str = newSVpvs(\"\");\n\tdata.substrs[1].str = newSVpvs(\"\");\n\tdata.last_found = newSVpvs(\"\");\n\tdata.cur_is_floating = 0; /* initially any found substring is fixed */\n\tENTER_with_name(\"study_chunk\");\n\tSAVEFREESV(data.substrs[0].str);\n\tSAVEFREESV(data.substrs[1].str);\n\tSAVEFREESV(data.last_found);\n\tfirst = scan;\n\tif (!RExC_rxi->regstclass) {\n\t    ssc_init(pRExC_state, &ch_class);\n\t    data.start_class = &ch_class;\n\t    stclass_flag = SCF_DO_STCLASS_AND;\n\t} else\t\t\t\t/* XXXX Check for BOUND? */\n\t    stclass_flag = 0;\n\tdata.last_closep = &last_close;\n\n        DEBUG_RExC_seen();\n        /*\n         * MAIN ENTRY FOR study_chunk() FOR m/PATTERN/\n         * (NO top level branches)\n         */\n\tminlen = study_chunk(pRExC_state, &first, &minlen, &fake,\n                             scan + RExC_size, /* Up to end */\n            &data, -1, 0, NULL,\n            SCF_DO_SUBSTR | SCF_WHILEM_VISITED_POS | stclass_flag\n                          | (restudied ? SCF_TRIE_DOING_RESTUDY : 0),\n            0);\n\n\n        CHECK_RESTUDY_GOTO_butfirst(LEAVE_with_name(\"study_chunk\"));\n\n\n\tif ( RExC_total_parens == 1 && !data.cur_is_floating\n\t     && data.last_start_min == 0 && data.last_end > 0\n\t     && !RExC_seen_zerolen\n             && !(RExC_seen & REG_VERBARG_SEEN)\n             && !(RExC_seen & REG_GPOS_SEEN)\n        ){\n\t    RExC_rx->extflags |= RXf_CHECK_ALL;\n        }\n\tscan_commit(pRExC_state, &data,&minlen, 0);\n\n\n        /* XXX this is done in reverse order because that's the way the\n         * code was before it was parameterised. Don't know whether it\n         * actually needs doing in reverse order. DAPM */\n        for (i = 1; i >= 0; i--) {\n            longest_length[i] = CHR_SVLEN(data.substrs[i].str);\n\n            if (   !(   i\n                     && SvCUR(data.substrs[0].str)  /* ok to leave SvCUR */\n                     &&    data.substrs[0].min_offset\n                        == data.substrs[1].min_offset\n                     &&    SvCUR(data.substrs[0].str)\n                        == SvCUR(data.substrs[1].str)\n                    )\n                && S_setup_longest (aTHX_ pRExC_state,\n                                        &(RExC_rx->substrs->data[i]),\n                                        &(data.substrs[i]),\n                                        longest_length[i]))\n            {\n                RExC_rx->substrs->data[i].min_offset =\n                        data.substrs[i].min_offset - data.substrs[i].lookbehind;\n\n                RExC_rx->substrs->data[i].max_offset = data.substrs[i].max_offset;\n                /* Don't offset infinity */\n                if (data.substrs[i].max_offset < SSize_t_MAX)\n                    RExC_rx->substrs->data[i].max_offset -= data.substrs[i].lookbehind;\n                SvREFCNT_inc_simple_void_NN(data.substrs[i].str);\n            }\n            else {\n                RExC_rx->substrs->data[i].substr      = NULL;\n                RExC_rx->substrs->data[i].utf8_substr = NULL;\n                longest_length[i] = 0;\n            }\n        }\n\n\tLEAVE_with_name(\"study_chunk\");\n\n\tif (RExC_rxi->regstclass\n\t    && (OP(RExC_rxi->regstclass) == REG_ANY || OP(RExC_rxi->regstclass) == SANY))\n\t    RExC_rxi->regstclass = NULL;\n\n\tif ((!(RExC_rx->substrs->data[0].substr || RExC_rx->substrs->data[0].utf8_substr)\n              || RExC_rx->substrs->data[0].min_offset)\n\t    && stclass_flag\n            && ! (ANYOF_FLAGS(data.start_class) & SSC_MATCHES_EMPTY_STRING)\n\t    && is_ssc_worth_it(pRExC_state, data.start_class))\n\t{\n\t    const U32 n = add_data(pRExC_state, STR_WITH_LEN(\"f\"));\n\n            ssc_finalize(pRExC_state, data.start_class);\n\n\t    Newx(RExC_rxi->data->data[n], 1, regnode_ssc);\n\t    StructCopy(data.start_class,\n\t\t       (regnode_ssc*)RExC_rxi->data->data[n],\n\t\t       regnode_ssc);\n\t    RExC_rxi->regstclass = (regnode*)RExC_rxi->data->data[n];\n\t    RExC_rx->intflags &= ~PREGf_SKIP;\t/* Used in find_byclass(). */\n\t    DEBUG_COMPILE_r({ SV *sv = sv_newmortal();\n                      regprop(RExC_rx, sv, (regnode*)data.start_class, NULL, pRExC_state);\n                      Perl_re_printf( aTHX_\n\t\t\t\t    \"synthetic stclass \\\"%s\\\".\\n\",\n\t\t\t\t    SvPVX_const(sv));});\n            data.start_class = NULL;\n\t}\n\n        /* A temporary algorithm prefers floated substr to fixed one of\n         * same length to dig more info. */\n\ti = (longest_length[0] <= longest_length[1]);\n        RExC_rx->substrs->check_ix = i;\n        RExC_rx->check_end_shift  = RExC_rx->substrs->data[i].end_shift;\n        RExC_rx->check_substr     = RExC_rx->substrs->data[i].substr;\n        RExC_rx->check_utf8       = RExC_rx->substrs->data[i].utf8_substr;\n        RExC_rx->check_offset_min = RExC_rx->substrs->data[i].min_offset;\n        RExC_rx->check_offset_max = RExC_rx->substrs->data[i].max_offset;\n        if (!i && (RExC_rx->intflags & (PREGf_ANCH_SBOL|PREGf_ANCH_GPOS)))\n            RExC_rx->intflags |= PREGf_NOSCAN;\n\n\tif ((RExC_rx->check_substr || RExC_rx->check_utf8) ) {\n\t    RExC_rx->extflags |= RXf_USE_INTUIT;\n\t    if (SvTAIL(RExC_rx->check_substr ? RExC_rx->check_substr : RExC_rx->check_utf8))\n\t\tRExC_rx->extflags |= RXf_INTUIT_TAIL;\n\t}\n\n\t/* XXX Unneeded? dmq (shouldn't as this is handled elsewhere)\n\tif ( (STRLEN)minlen < longest_length[1] )\n            minlen= longest_length[1];\n        if ( (STRLEN)minlen < longest_length[0] )\n            minlen= longest_length[0];\n        */\n    }\n    else {\n\t/* Several toplevels. Best we can is to set minlen. */\n\tSSize_t fake;\n\tregnode_ssc ch_class;\n\tSSize_t last_close = 0;\n\n        DEBUG_PARSE_r(Perl_re_printf( aTHX_  \"\\nMulti Top Level\\n\"));\n\n\tscan = RExC_rxi->program + 1;\n\tssc_init(pRExC_state, &ch_class);\n\tdata.start_class = &ch_class;\n\tdata.last_closep = &last_close;\n\n        DEBUG_RExC_seen();\n        /*\n         * MAIN ENTRY FOR study_chunk() FOR m/P1|P2|.../\n         * (patterns WITH top level branches)\n         */\n\tminlen = study_chunk(pRExC_state,\n            &scan, &minlen, &fake, scan + RExC_size, &data, -1, 0, NULL,\n            SCF_DO_STCLASS_AND|SCF_WHILEM_VISITED_POS|(restudied\n                                                      ? SCF_TRIE_DOING_RESTUDY\n                                                      : 0),\n            0);\n\n        CHECK_RESTUDY_GOTO_butfirst(NOOP);\n\n\tRExC_rx->check_substr = NULL;\n        RExC_rx->check_utf8 = NULL;\n        RExC_rx->substrs->data[0].substr      = NULL;\n        RExC_rx->substrs->data[0].utf8_substr = NULL;\n        RExC_rx->substrs->data[1].substr      = NULL;\n        RExC_rx->substrs->data[1].utf8_substr = NULL;\n\n        if (! (ANYOF_FLAGS(data.start_class) & SSC_MATCHES_EMPTY_STRING)\n\t    && is_ssc_worth_it(pRExC_state, data.start_class))\n        {\n\t    const U32 n = add_data(pRExC_state, STR_WITH_LEN(\"f\"));\n\n            ssc_finalize(pRExC_state, data.start_class);\n\n\t    Newx(RExC_rxi->data->data[n], 1, regnode_ssc);\n\t    StructCopy(data.start_class,\n\t\t       (regnode_ssc*)RExC_rxi->data->data[n],\n\t\t       regnode_ssc);\n\t    RExC_rxi->regstclass = (regnode*)RExC_rxi->data->data[n];\n\t    RExC_rx->intflags &= ~PREGf_SKIP;\t/* Used in find_byclass(). */\n\t    DEBUG_COMPILE_r({ SV* sv = sv_newmortal();\n                      regprop(RExC_rx, sv, (regnode*)data.start_class, NULL, pRExC_state);\n                      Perl_re_printf( aTHX_\n\t\t\t\t    \"synthetic stclass \\\"%s\\\".\\n\",\n\t\t\t\t    SvPVX_const(sv));});\n            data.start_class = NULL;\n\t}\n    }\n\n    if (RExC_seen & REG_UNBOUNDED_QUANTIFIER_SEEN) {\n        RExC_rx->extflags |= RXf_UNBOUNDED_QUANTIFIER_SEEN;\n        RExC_rx->maxlen = REG_INFTY;\n    }\n    else {\n        RExC_rx->maxlen = RExC_maxlen;\n    }\n\n    /* Guard against an embedded (?=) or (?<=) with a longer minlen than\n       the \"real\" pattern. */\n    DEBUG_OPTIMISE_r({\n        Perl_re_printf( aTHX_ \"minlen: %\" IVdf \" RExC_rx->minlen:%\" IVdf \" maxlen:%\" IVdf \"\\n\",\n                      (IV)minlen, (IV)RExC_rx->minlen, (IV)RExC_maxlen);\n    });\n    RExC_rx->minlenret = minlen;\n    if (RExC_rx->minlen < minlen)\n        RExC_rx->minlen = minlen;\n\n    if (RExC_seen & REG_RECURSE_SEEN ) {\n        RExC_rx->intflags |= PREGf_RECURSE_SEEN;\n        Newx(RExC_rx->recurse_locinput, RExC_rx->nparens + 1, char *);\n    }\n    if (RExC_seen & REG_GPOS_SEEN)\n        RExC_rx->intflags |= PREGf_GPOS_SEEN;\n    if (RExC_seen & REG_LOOKBEHIND_SEEN)\n        RExC_rx->extflags |= RXf_NO_INPLACE_SUBST; /* inplace might break the\n                                                lookbehind */\n    if (pRExC_state->code_blocks)\n\tRExC_rx->extflags |= RXf_EVAL_SEEN;\n    if (RExC_seen & REG_VERBARG_SEEN)\n    {\n\tRExC_rx->intflags |= PREGf_VERBARG_SEEN;\n        RExC_rx->extflags |= RXf_NO_INPLACE_SUBST; /* don't understand this! Yves */\n    }\n    if (RExC_seen & REG_CUTGROUP_SEEN)\n\tRExC_rx->intflags |= PREGf_CUTGROUP_SEEN;\n    if (pm_flags & PMf_USE_RE_EVAL)\n\tRExC_rx->intflags |= PREGf_USE_RE_EVAL;\n    if (RExC_paren_names)\n        RXp_PAREN_NAMES(RExC_rx) = MUTABLE_HV(SvREFCNT_inc(RExC_paren_names));\n    else\n        RXp_PAREN_NAMES(RExC_rx) = NULL;\n\n    /* If we have seen an anchor in our pattern then we set the extflag RXf_IS_ANCHORED\n     * so it can be used in pp.c */\n    if (RExC_rx->intflags & PREGf_ANCH)\n        RExC_rx->extflags |= RXf_IS_ANCHORED;\n\n\n    {\n        /* this is used to identify \"special\" patterns that might result\n         * in Perl NOT calling the regex engine and instead doing the match \"itself\",\n         * particularly special cases in split//. By having the regex compiler\n         * do this pattern matching at a regop level (instead of by inspecting the pattern)\n         * we avoid weird issues with equivalent patterns resulting in different behavior,\n         * AND we allow non Perl engines to get the same optimizations by the setting the\n         * flags appropriately - Yves */\n        regnode *first = RExC_rxi->program + 1;\n        U8 fop = OP(first);\n        regnode *next = regnext(first);\n        U8 nop = OP(next);\n\n        if (PL_regkind[fop] == NOTHING && nop == END)\n            RExC_rx->extflags |= RXf_NULL;\n        else if ((fop == MBOL || (fop == SBOL && !first->flags)) && nop == END)\n            /* when fop is SBOL first->flags will be true only when it was\n             * produced by parsing /\\A/, and not when parsing /^/. This is\n             * very important for the split code as there we want to\n             * treat /^/ as /^/m, but we do not want to treat /\\A/ as /^/m.\n             * See rt #122761 for more details. -- Yves */\n            RExC_rx->extflags |= RXf_START_ONLY;\n        else if (fop == PLUS\n                 && PL_regkind[nop] == POSIXD && FLAGS(next) == _CC_SPACE\n                 && nop == END)\n            RExC_rx->extflags |= RXf_WHITE;\n        else if ( RExC_rx->extflags & RXf_SPLIT\n                  && (fop == EXACT || fop == EXACT_ONLY8 || fop == EXACTL)\n                  && STR_LEN(first) == 1\n                  && *(STRING(first)) == ' '\n                  && nop == END )\n            RExC_rx->extflags |= (RXf_SKIPWHITE|RXf_WHITE);\n\n    }\n\n    if (RExC_contains_locale) {\n        RXp_EXTFLAGS(RExC_rx) |= RXf_TAINTED;\n    }\n\n#ifdef DEBUGGING\n    if (RExC_paren_names) {\n        RExC_rxi->name_list_idx = add_data( pRExC_state, STR_WITH_LEN(\"a\"));\n        RExC_rxi->data->data[RExC_rxi->name_list_idx]\n                                   = (void*)SvREFCNT_inc(RExC_paren_name_list);\n    } else\n#endif\n    RExC_rxi->name_list_idx = 0;\n\n    while ( RExC_recurse_count > 0 ) {\n        const regnode *scan = RExC_recurse[ --RExC_recurse_count ];\n        /*\n         * This data structure is set up in study_chunk() and is used\n         * to calculate the distance between a GOSUB regopcode and\n         * the OPEN/CURLYM (CURLYM's are special and can act like OPEN's)\n         * it refers to.\n         *\n         * If for some reason someone writes code that optimises\n         * away a GOSUB opcode then the assert should be changed to\n         * an if(scan) to guard the ARG2L_SET() - Yves\n         *\n         */\n        assert(scan && OP(scan) == GOSUB);\n        ARG2L_SET( scan, RExC_open_parens[ARG(scan)] - REGNODE_OFFSET(scan));\n    }\n\n    Newxz(RExC_rx->offs, RExC_total_parens, regexp_paren_pair);\n    /* assume we don't need to swap parens around before we match */\n    DEBUG_TEST_r({\n        Perl_re_printf( aTHX_ \"study_chunk_recursed_count: %lu\\n\",\n            (unsigned long)RExC_study_chunk_recursed_count);\n    });\n    DEBUG_DUMP_r({\n        DEBUG_RExC_seen();\n        Perl_re_printf( aTHX_ \"Final program:\\n\");\n        regdump(RExC_rx);\n    });\n\n    if (RExC_open_parens) {\n        Safefree(RExC_open_parens);\n        RExC_open_parens = NULL;\n    }\n    if (RExC_close_parens) {\n        Safefree(RExC_close_parens);\n        RExC_close_parens = NULL;\n    }\n\n#ifdef USE_ITHREADS\n    /* under ithreads the ?pat? PMf_USED flag on the pmop is simulated\n     * by setting the regexp SV to readonly-only instead. If the\n     * pattern's been recompiled, the USEDness should remain. */\n    if (old_re && SvREADONLY(old_re))\n        SvREADONLY_on(Rx);\n#endif\n    return Rx;",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149784,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "REGEXP *\nPerl_re_op_compile(pTHX_ SV ** const patternp, int pat_count,\n\t\t    OP *expr, const regexp_engine* eng, REGEXP *old_re,\n\t\t     bool *is_bare_re, const U32 orig_rx_flags, const U32 pm_flags)\n{\n    dVAR;\n    REGEXP *Rx;         /* Capital 'R' means points to a REGEXP */\n    STRLEN plen;\n    char *exp;\n    regnode *scan;\n    I32 flags;\n    SSize_t minlen = 0;\n    U32 rx_flags;\n    SV *pat;\n    SV** new_patternp = patternp;\n\n    /* these are all flags - maybe they should be turned\n     * into a single int with different bit masks */\n    I32 sawlookahead = 0;\n    I32 sawplus = 0;\n    I32 sawopen = 0;\n    I32 sawminmod = 0;\n\n    regex_charset initial_charset = get_regex_charset(orig_rx_flags);\n    bool recompile = 0;\n    bool runtime_code = 0;\n    scan_data_t data;\n    RExC_state_t RExC_state;\n    RExC_state_t * const pRExC_state = &RExC_state;\n#ifdef TRIE_STUDY_OPT\n    int restudied = 0;\n    RExC_state_t copyRExC_state;\n#endif\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_RE_OP_COMPILE;\n\n    DEBUG_r(if (!PL_colorset) reginitcolors());\n\n    /* Initialize these here instead of as-needed, as is quick and avoids\n     * having to test them each time otherwise */\n    if (! PL_InBitmap) {\n#ifdef DEBUGGING\n        char * dump_len_string;\n#endif\n\n        /* This is calculated here, because the Perl program that generates the\n         * static global ones doesn't currently have access to\n         * NUM_ANYOF_CODE_POINTS */\n\tPL_InBitmap = _new_invlist(2);\n\tPL_InBitmap = _add_range_to_invlist(PL_InBitmap, 0,\n                                                    NUM_ANYOF_CODE_POINTS - 1);\n#ifdef DEBUGGING\n        dump_len_string = PerlEnv_getenv(\"PERL_DUMP_RE_MAX_LEN\");\n        if (   ! dump_len_string\n            || ! grok_atoUV(dump_len_string, (UV *)&PL_dump_re_max_len, NULL))\n        {\n            PL_dump_re_max_len = 60;    /* A reasonable default */\n        }\n#endif\n    }\n\n    pRExC_state->warn_text = NULL;\n    pRExC_state->unlexed_names = NULL;\n    pRExC_state->code_blocks = NULL;\n\n    if (is_bare_re)\n\t*is_bare_re = FALSE;\n\n    if (expr && (expr->op_type == OP_LIST ||\n\t\t(expr->op_type == OP_NULL && expr->op_targ == OP_LIST))) {\n\t/* allocate code_blocks if needed */\n\tOP *o;\n\tint ncode = 0;\n\n\tfor (o = cLISTOPx(expr)->op_first; o; o = OpSIBLING(o))\n\t    if (o->op_type == OP_NULL && (o->op_flags & OPf_SPECIAL))\n\t\tncode++; /* count of DO blocks */\n\n\tif (ncode)\n            pRExC_state->code_blocks = S_alloc_code_blocks(aTHX_ ncode);\n    }\n\n    if (!pat_count) {\n        /* compile-time pattern with just OP_CONSTs and DO blocks */\n\n        int n;\n        OP *o;\n\n        /* find how many CONSTs there are */\n        assert(expr);\n        n = 0;\n        if (expr->op_type == OP_CONST)\n            n = 1;\n        else\n            for (o = cLISTOPx(expr)->op_first; o; o = OpSIBLING(o)) {\n                if (o->op_type == OP_CONST)\n                    n++;\n            }\n\n        /* fake up an SV array */\n\n        assert(!new_patternp);\n        Newx(new_patternp, n, SV*);\n        SAVEFREEPV(new_patternp);\n        pat_count = n;\n\n        n = 0;\n        if (expr->op_type == OP_CONST)\n            new_patternp[n] = cSVOPx_sv(expr);\n        else\n            for (o = cLISTOPx(expr)->op_first; o; o = OpSIBLING(o)) {\n                if (o->op_type == OP_CONST)\n                    new_patternp[n++] = cSVOPo_sv;\n            }\n\n    }\n\n    DEBUG_PARSE_r(Perl_re_printf( aTHX_\n        \"Assembling pattern from %d elements%s\\n\", pat_count,\n            orig_rx_flags & RXf_SPLIT ? \" for split\" : \"\"));\n\n    /* set expr to the first arg op */\n\n    if (pRExC_state->code_blocks && pRExC_state->code_blocks->count\n         && expr->op_type != OP_CONST)\n    {\n            expr = cLISTOPx(expr)->op_first;\n            assert(   expr->op_type == OP_PUSHMARK\n                   || (expr->op_type == OP_NULL && expr->op_targ == OP_PUSHMARK)\n                   || expr->op_type == OP_PADRANGE);\n            expr = OpSIBLING(expr);\n    }\n\n    pat = S_concat_pat(aTHX_ pRExC_state, NULL, new_patternp, pat_count,\n                        expr, &recompile, NULL);\n\n    /* handle bare (possibly after overloading) regex: foo =~ $re */\n    {\n        SV *re = pat;\n        if (SvROK(re))\n            re = SvRV(re);\n        if (SvTYPE(re) == SVt_REGEXP) {\n            if (is_bare_re)\n                *is_bare_re = TRUE;\n            SvREFCNT_inc(re);\n            DEBUG_PARSE_r(Perl_re_printf( aTHX_\n                \"Precompiled pattern%s\\n\",\n                    orig_rx_flags & RXf_SPLIT ? \" for split\" : \"\"));\n\n            return (REGEXP*)re;\n        }\n    }\n\n    exp = SvPV_nomg(pat, plen);\n\n    if (!eng->op_comp) {\n\tif ((SvUTF8(pat) && IN_BYTES)\n\t\t|| SvGMAGICAL(pat) || SvAMAGIC(pat))\n\t{\n\t    /* make a temporary copy; either to convert to bytes,\n\t     * or to avoid repeating get-magic / overloaded stringify */\n\t    pat = newSVpvn_flags(exp, plen, SVs_TEMP |\n\t\t\t\t\t(IN_BYTES ? 0 : SvUTF8(pat)));\n\t}\n\treturn CALLREGCOMP_ENG(eng, pat, orig_rx_flags);\n    }\n\n    /* ignore the utf8ness if the pattern is 0 length */\n    RExC_utf8 = RExC_orig_utf8 = (plen == 0 || IN_BYTES) ? 0 : SvUTF8(pat);\n    RExC_uni_semantics = 0;\n    RExC_contains_locale = 0;\n    RExC_strict = cBOOL(pm_flags & RXf_PMf_STRICT);\n    RExC_in_script_run = 0;\n    RExC_study_started = 0;\n    pRExC_state->runtime_code_qr = NULL;\n    RExC_frame_head= NULL;\n    RExC_frame_last= NULL;\n    RExC_frame_count= 0;\n    RExC_latest_warn_offset = 0;\n    RExC_use_BRANCHJ = 0;\n    RExC_total_parens = 0;\n    RExC_open_parens = NULL;\n    RExC_close_parens = NULL;\n    RExC_paren_names = NULL;\n    RExC_size = 0;\n    RExC_seen_d_op = FALSE;\n#ifdef DEBUGGING\n    RExC_paren_name_list = NULL;\n#endif\n\n    DEBUG_r({\n        RExC_mysv1= sv_newmortal();\n        RExC_mysv2= sv_newmortal();\n    });\n\n    DEBUG_COMPILE_r({\n            SV *dsv= sv_newmortal();\n            RE_PV_QUOTED_DECL(s, RExC_utf8, dsv, exp, plen, PL_dump_re_max_len);\n            Perl_re_printf( aTHX_  \"%sCompiling REx%s %s\\n\",\n                          PL_colors[4], PL_colors[5], s);\n        });\n\n    /* we jump here if we have to recompile, e.g., from upgrading the pattern\n     * to utf8 */\n\n    if ((pm_flags & PMf_USE_RE_EVAL)\n\t\t/* this second condition covers the non-regex literal case,\n\t\t * i.e.  $foo =~ '(?{})'. */\n\t\t|| (IN_PERL_COMPILETIME && (PL_hints & HINT_RE_EVAL))\n    )\n\truntime_code = S_has_runtime_code(aTHX_ pRExC_state, exp, plen);\n\n  redo_parse:\n    /* return old regex if pattern hasn't changed */\n    /* XXX: note in the below we have to check the flags as well as the\n     * pattern.\n     *\n     * Things get a touch tricky as we have to compare the utf8 flag\n     * independently from the compile flags.  */\n\n    if (   old_re\n        && !recompile\n        && !!RX_UTF8(old_re) == !!RExC_utf8\n        && ( RX_COMPFLAGS(old_re) == ( orig_rx_flags & RXf_PMf_FLAGCOPYMASK ) )\n\t&& RX_PRECOMP(old_re)\n\t&& RX_PRELEN(old_re) == plen\n        && memEQ(RX_PRECOMP(old_re), exp, plen)\n\t&& !runtime_code /* with runtime code, always recompile */ )\n    {\n        return old_re;\n    }\n\n    /* Allocate the pattern's SV */\n    RExC_rx_sv = Rx = (REGEXP*) newSV_type(SVt_REGEXP);\n    RExC_rx = ReANY(Rx);\n    if ( RExC_rx == NULL )\n        FAIL(\"Regexp out of space\");\n\n    rx_flags = orig_rx_flags;\n\n    if (   (UTF || RExC_uni_semantics)\n        && initial_charset == REGEX_DEPENDS_CHARSET)\n    {\n\n\t/* Set to use unicode semantics if the pattern is in utf8 and has the\n\t * 'depends' charset specified, as it means unicode when utf8  */\n\tset_regex_charset(&rx_flags, REGEX_UNICODE_CHARSET);\n        RExC_uni_semantics = 1;\n    }\n\n    RExC_pm_flags = pm_flags;\n\n    if (runtime_code) {\n        assert(TAINTING_get || !TAINT_get);\n\tif (TAINT_get)\n\t    Perl_croak(aTHX_ \"Eval-group in insecure regular expression\");\n\n\tif (!S_compile_runtime_code(aTHX_ pRExC_state, exp, plen)) {\n\t    /* whoops, we have a non-utf8 pattern, whilst run-time code\n\t     * got compiled as utf8. Try again with a utf8 pattern */\n            S_pat_upgrade_to_utf8(aTHX_ pRExC_state, &exp, &plen,\n                pRExC_state->code_blocks ? pRExC_state->code_blocks->count : 0);\n            goto redo_parse;\n\t}\n    }\n    assert(!pRExC_state->runtime_code_qr);\n\n    RExC_sawback = 0;\n\n    RExC_seen = 0;\n    RExC_maxlen = 0;\n    RExC_in_lookbehind = 0;\n    RExC_seen_zerolen = *exp == '^' ? -1 : 0;\n#ifdef EBCDIC\n    RExC_recode_x_to_native = 0;\n#endif\n    RExC_in_multi_char_class = 0;\n\n    RExC_start = RExC_copy_start_in_constructed = RExC_copy_start_in_input = RExC_precomp = exp;\n    RExC_precomp_end = RExC_end = exp + plen;\n    RExC_nestroot = 0;\n    RExC_whilem_seen = 0;\n    RExC_end_op = NULL;\n    RExC_recurse = NULL;\n    RExC_study_chunk_recursed = NULL;\n    RExC_study_chunk_recursed_bytes= 0;\n    RExC_recurse_count = 0;\n    pRExC_state->code_index = 0;\n\n    /* Initialize the string in the compiled pattern.  This is so that there is\n     * something to output if necessary */\n    set_regex_pv(pRExC_state, Rx);\n\n    DEBUG_PARSE_r({\n        Perl_re_printf( aTHX_\n            \"Starting parse and generation\\n\");\n        RExC_lastnum=0;\n        RExC_lastparse=NULL;\n    });\n\n    /* Allocate space and zero-initialize. Note, the two step process\n       of zeroing when in debug mode, thus anything assigned has to\n       happen after that */\n    if (!  RExC_size) {\n\n        /* On the first pass of the parse, we guess how big this will be.  Then\n         * we grow in one operation to that amount and then give it back.  As\n         * we go along, we re-allocate what we need.\n         *\n         * XXX Currently the guess is essentially that the pattern will be an\n         * EXACT node with one byte input, one byte output.  This is crude, and\n         * better heuristics are welcome.\n         *\n         * On any subsequent passes, we guess what we actually computed in the\n         * latest earlier pass.  Such a pass probably didn't complete so is\n         * missing stuff.  We could improve those guesses by knowing where the\n         * parse stopped, and use the length so far plus apply the above\n         * assumption to what's left. */\n        RExC_size = STR_SZ(RExC_end - RExC_start);\n    }\n\n    Newxc(RExC_rxi, sizeof(regexp_internal) + RExC_size, char, regexp_internal);\n    if ( RExC_rxi == NULL )\n        FAIL(\"Regexp out of space\");\n\n    Zero(RExC_rxi, sizeof(regexp_internal) + RExC_size, char);\n    RXi_SET( RExC_rx, RExC_rxi );\n\n    /* We start from 0 (over from 0 in the case this is a reparse.  The first\n     * node parsed will give back any excess memory we have allocated so far).\n     * */\n    RExC_size = 0;\n\n    /* non-zero initialization begins here */\n    RExC_rx->engine= eng;\n    RExC_rx->extflags = rx_flags;\n    RXp_COMPFLAGS(RExC_rx) = orig_rx_flags & RXf_PMf_FLAGCOPYMASK;\n\n    if (pm_flags & PMf_IS_QR) {\n\tRExC_rxi->code_blocks = pRExC_state->code_blocks;\n        if (RExC_rxi->code_blocks) {\n            RExC_rxi->code_blocks->refcnt++;\n        }\n    }\n\n    RExC_rx->intflags = 0;\n\n    RExC_flags = rx_flags;\t/* don't let top level (?i) bleed */\n    RExC_parse = exp;\n\n    /* This NUL is guaranteed because the pattern comes from an SV*, and the sv\n     * code makes sure the final byte is an uncounted NUL.  But should this\n     * ever not be the case, lots of things could read beyond the end of the\n     * buffer: loops like\n     *      while(isFOO(*RExC_parse)) RExC_parse++;\n     *      strchr(RExC_parse, \"foo\");\n     * etc.  So it is worth noting. */\n    assert(*RExC_end == '\\0');\n\n    RExC_naughty = 0;\n    RExC_npar = 1;\n    RExC_parens_buf_size = 0;\n    RExC_emit_start = RExC_rxi->program;\n    pRExC_state->code_index = 0;\n\n    *((char*) RExC_emit_start) = (char) REG_MAGIC;\n    RExC_emit = 1;\n\n    /* Do the parse */\n    if (reg(pRExC_state, 0, &flags, 1)) {\n\n        /* Success!, But we may need to redo the parse knowing how many parens\n         * there actually are */\n        if (IN_PARENS_PASS) {\n            flags |= RESTART_PARSE;\n        }\n\n        /* We have that number in RExC_npar */\n        RExC_total_parens = RExC_npar;\n\n        /* XXX For backporting, use long jumps if there is any possibility of\n         * overflow */\n        if (RExC_size > U16_MAX && ! RExC_use_BRANCHJ) {\n            RExC_use_BRANCHJ = TRUE;\n            flags |= RESTART_PARSE;\n        }\n    }\n    else if (! MUST_RESTART(flags)) {\n\tReREFCNT_dec(Rx);\n        Perl_croak(aTHX_ \"panic: reg returned failure to re_op_compile, flags=%#\" UVxf, (UV) flags);\n    }\n\n    /* Here, we either have success, or we have to redo the parse for some reason */\n    if (MUST_RESTART(flags)) {\n\n        /* It's possible to write a regexp in ascii that represents Unicode\n        codepoints outside of the byte range, such as via \\x{100}. If we\n        detect such a sequence we have to convert the entire pattern to utf8\n        and then recompile, as our sizing calculation will have been based\n        on 1 byte == 1 character, but we will need to use utf8 to encode\n        at least some part of the pattern, and therefore must convert the whole\n        thing.\n        -- dmq */\n        if (flags & NEED_UTF8) {\n\n            /* We have stored the offset of the final warning output so far.\n             * That must be adjusted.  Any variant characters between the start\n             * of the pattern and this warning count for 2 bytes in the final,\n             * so just add them again */\n            if (UNLIKELY(RExC_latest_warn_offset > 0)) {\n                RExC_latest_warn_offset +=\n                            variant_under_utf8_count((U8 *) exp, (U8 *) exp\n                                                + RExC_latest_warn_offset);\n            }\n            S_pat_upgrade_to_utf8(aTHX_ pRExC_state, &exp, &plen,\n            pRExC_state->code_blocks ? pRExC_state->code_blocks->count : 0);\n            DEBUG_PARSE_r(Perl_re_printf( aTHX_ \"Need to redo parse after upgrade\\n\"));\n        }\n        else {\n            DEBUG_PARSE_r(Perl_re_printf( aTHX_ \"Need to redo parse\\n\"));\n        }\n\n        if (ALL_PARENS_COUNTED) {\n            /* Make enough room for all the known parens, and zero it */\n            Renew(RExC_open_parens, RExC_total_parens, regnode_offset);\n            Zero(RExC_open_parens, RExC_total_parens, regnode_offset);\n            RExC_open_parens[0] = 1;    /* +1 for REG_MAGIC */\n\n            Renew(RExC_close_parens, RExC_total_parens, regnode_offset);\n            Zero(RExC_close_parens, RExC_total_parens, regnode_offset);\n        }\n        else { /* Parse did not complete.  Reinitialize the parentheses\n                  structures */\n            RExC_total_parens = 0;\n            if (RExC_open_parens) {\n                Safefree(RExC_open_parens);\n                RExC_open_parens = NULL;\n            }\n            if (RExC_close_parens) {\n                Safefree(RExC_close_parens);\n                RExC_close_parens = NULL;\n            }\n        }\n\n        /* Clean up what we did in this parse */\n        SvREFCNT_dec_NN(RExC_rx_sv);\n\n        goto redo_parse;\n    }\n\n    /* Here, we have successfully parsed and generated the pattern's program\n     * for the regex engine.  We are ready to finish things up and look for\n     * optimizations. */\n\n    /* Update the string to compile, with correct modifiers, etc */\n    set_regex_pv(pRExC_state, Rx);\n\n    RExC_rx->nparens = RExC_total_parens - 1;\n\n    /* Uses the upper 4 bits of the FLAGS field, so keep within that size */\n    if (RExC_whilem_seen > 15)\n        RExC_whilem_seen = 15;\n\n    DEBUG_PARSE_r({\n        Perl_re_printf( aTHX_\n            \"Required size %\" IVdf \" nodes\\n\", (IV)RExC_size);\n        RExC_lastnum=0;\n        RExC_lastparse=NULL;\n    });\n\n#ifdef RE_TRACK_PATTERN_OFFSETS\n    DEBUG_OFFSETS_r(Perl_re_printf( aTHX_\n                          \"%s %\" UVuf \" bytes for offset annotations.\\n\",\n                          RExC_offsets ? \"Got\" : \"Couldn't get\",\n                          (UV)((RExC_offsets[0] * 2 + 1))));\n    DEBUG_OFFSETS_r(if (RExC_offsets) {\n        const STRLEN len = RExC_offsets[0];\n        STRLEN i;\n        GET_RE_DEBUG_FLAGS_DECL;\n        Perl_re_printf( aTHX_\n                      \"Offsets: [%\" UVuf \"]\\n\\t\", (UV)RExC_offsets[0]);\n        for (i = 1; i <= len; i++) {\n            if (RExC_offsets[i*2-1] || RExC_offsets[i*2])\n                Perl_re_printf( aTHX_  \"%\" UVuf \":%\" UVuf \"[%\" UVuf \"] \",\n                (UV)i, (UV)RExC_offsets[i*2-1], (UV)RExC_offsets[i*2]);\n        }\n        Perl_re_printf( aTHX_  \"\\n\");\n    });\n\n#else\n    SetProgLen(RExC_rxi,RExC_size);\n#endif\n\n    DEBUG_OPTIMISE_r(\n        Perl_re_printf( aTHX_  \"Starting post parse optimization\\n\");\n    );\n\n    /* XXXX To minimize changes to RE engine we always allocate\n       3-units-long substrs field. */\n    Newx(RExC_rx->substrs, 1, struct reg_substr_data);\n    if (RExC_recurse_count) {\n        Newx(RExC_recurse, RExC_recurse_count, regnode *);\n        SAVEFREEPV(RExC_recurse);\n    }\n\n    if (RExC_seen & REG_RECURSE_SEEN) {\n        /* Note, RExC_total_parens is 1 + the number of parens in a pattern.\n         * So its 1 if there are no parens. */\n        RExC_study_chunk_recursed_bytes= (RExC_total_parens >> 3) +\n                                         ((RExC_total_parens & 0x07) != 0);\n        Newx(RExC_study_chunk_recursed,\n             RExC_study_chunk_recursed_bytes * RExC_total_parens, U8);\n        SAVEFREEPV(RExC_study_chunk_recursed);\n    }\n\n  reStudy:\n    RExC_rx->minlen = minlen = sawlookahead = sawplus = sawopen = sawminmod = 0;\n    DEBUG_r(\n        RExC_study_chunk_recursed_count= 0;\n    );\n    Zero(RExC_rx->substrs, 1, struct reg_substr_data);\n    if (RExC_study_chunk_recursed) {\n        Zero(RExC_study_chunk_recursed,\n             RExC_study_chunk_recursed_bytes * RExC_total_parens, U8);\n    }\n\n\n#ifdef TRIE_STUDY_OPT\n    if (!restudied) {\n        StructCopy(&zero_scan_data, &data, scan_data_t);\n        copyRExC_state = RExC_state;\n    } else {\n        U32 seen=RExC_seen;\n        DEBUG_OPTIMISE_r(Perl_re_printf( aTHX_ \"Restudying\\n\"));\n\n        RExC_state = copyRExC_state;\n        if (seen & REG_TOP_LEVEL_BRANCHES_SEEN)\n            RExC_seen |= REG_TOP_LEVEL_BRANCHES_SEEN;\n        else\n            RExC_seen &= ~REG_TOP_LEVEL_BRANCHES_SEEN;\n\tStructCopy(&zero_scan_data, &data, scan_data_t);\n    }\n#else\n    StructCopy(&zero_scan_data, &data, scan_data_t);\n#endif\n\n    /* Dig out information for optimizations. */\n    RExC_rx->extflags = RExC_flags; /* was pm_op */\n    /*dmq: removed as part of de-PMOP: pm->op_pmflags = RExC_flags; */\n\n    if (UTF)\n\tSvUTF8_on(Rx);\t/* Unicode in it? */\n    RExC_rxi->regstclass = NULL;\n    if (RExC_naughty >= TOO_NAUGHTY)\t/* Probably an expensive pattern. */\n\tRExC_rx->intflags |= PREGf_NAUGHTY;\n    scan = RExC_rxi->program + 1;\t\t/* First BRANCH. */\n\n    /* testing for BRANCH here tells us whether there is \"must appear\"\n       data in the pattern. If there is then we can use it for optimisations */\n    if (!(RExC_seen & REG_TOP_LEVEL_BRANCHES_SEEN)) { /*  Only one top-level choice.\n                                                  */\n\tSSize_t fake;\n\tSTRLEN longest_length[2];\n\tregnode_ssc ch_class; /* pointed to by data */\n\tint stclass_flag;\n\tSSize_t last_close = 0; /* pointed to by data */\n        regnode *first= scan;\n        regnode *first_next= regnext(first);\n        int i;\n\n\t/*\n\t * Skip introductions and multiplicators >= 1\n\t * so that we can extract the 'meat' of the pattern that must\n\t * match in the large if() sequence following.\n\t * NOTE that EXACT is NOT covered here, as it is normally\n\t * picked up by the optimiser separately.\n\t *\n\t * This is unfortunate as the optimiser isnt handling lookahead\n\t * properly currently.\n\t *\n\t */\n\twhile ((OP(first) == OPEN && (sawopen = 1)) ||\n\t       /* An OR of *one* alternative - should not happen now. */\n\t    (OP(first) == BRANCH && OP(first_next) != BRANCH) ||\n\t    /* for now we can't handle lookbehind IFMATCH*/\n\t    (OP(first) == IFMATCH && !first->flags && (sawlookahead = 1)) ||\n\t    (OP(first) == PLUS) ||\n\t    (OP(first) == MINMOD) ||\n\t       /* An {n,m} with n>0 */\n\t    (PL_regkind[OP(first)] == CURLY && ARG1(first) > 0) ||\n\t    (OP(first) == NOTHING && PL_regkind[OP(first_next)] != END ))\n\t{\n\t\t/*\n\t\t * the only op that could be a regnode is PLUS, all the rest\n\t\t * will be regnode_1 or regnode_2.\n\t\t *\n                 * (yves doesn't think this is true)\n\t\t */\n\t\tif (OP(first) == PLUS)\n\t\t    sawplus = 1;\n                else {\n                    if (OP(first) == MINMOD)\n                        sawminmod = 1;\n\t\t    first += regarglen[OP(first)];\n                }\n\t\tfirst = NEXTOPER(first);\n\t\tfirst_next= regnext(first);\n\t}\n\n\t/* Starting-point info. */\n      again:\n        DEBUG_PEEP(\"first:\", first, 0, 0);\n        /* Ignore EXACT as we deal with it later. */\n\tif (PL_regkind[OP(first)] == EXACT) {\n\t    if (   OP(first) == EXACT\n                || OP(first) == EXACT_ONLY8\n                || OP(first) == EXACTL)\n            {\n\t\tNOOP;\t/* Empty, get anchored substr later. */\n            }\n\t    else\n\t\tRExC_rxi->regstclass = first;\n\t}\n#ifdef TRIE_STCLASS\n\telse if (PL_regkind[OP(first)] == TRIE &&\n\t        ((reg_trie_data *)RExC_rxi->data->data[ ARG(first) ])->minlen>0)\n\t{\n            /* this can happen only on restudy */\n            RExC_rxi->regstclass = construct_ahocorasick_from_trie(pRExC_state, (regnode *)first, 0);\n\t}\n#endif\n\telse if (REGNODE_SIMPLE(OP(first)))\n\t    RExC_rxi->regstclass = first;\n\telse if (PL_regkind[OP(first)] == BOUND ||\n\t\t PL_regkind[OP(first)] == NBOUND)\n\t    RExC_rxi->regstclass = first;\n\telse if (PL_regkind[OP(first)] == BOL) {\n            RExC_rx->intflags |= (OP(first) == MBOL\n                           ? PREGf_ANCH_MBOL\n                           : PREGf_ANCH_SBOL);\n\t    first = NEXTOPER(first);\n\t    goto again;\n\t}\n\telse if (OP(first) == GPOS) {\n            RExC_rx->intflags |= PREGf_ANCH_GPOS;\n\t    first = NEXTOPER(first);\n\t    goto again;\n\t}\n\telse if ((!sawopen || !RExC_sawback) &&\n            !sawlookahead &&\n\t    (OP(first) == STAR &&\n\t    PL_regkind[OP(NEXTOPER(first))] == REG_ANY) &&\n            !(RExC_rx->intflags & PREGf_ANCH) && !pRExC_state->code_blocks)\n\t{\n\t    /* turn .* into ^.* with an implied $*=1 */\n\t    const int type =\n\t\t(OP(NEXTOPER(first)) == REG_ANY)\n                    ? PREGf_ANCH_MBOL\n                    : PREGf_ANCH_SBOL;\n            RExC_rx->intflags |= (type | PREGf_IMPLICIT);\n\t    first = NEXTOPER(first);\n\t    goto again;\n\t}\n        if (sawplus && !sawminmod && !sawlookahead\n            && (!sawopen || !RExC_sawback)\n\t    && !pRExC_state->code_blocks) /* May examine pos and $& */\n\t    /* x+ must match at the 1st pos of run of x's */\n\t    RExC_rx->intflags |= PREGf_SKIP;\n\n\t/* Scan is after the zeroth branch, first is atomic matcher. */\n#ifdef TRIE_STUDY_OPT\n\tDEBUG_PARSE_r(\n\t    if (!restudied)\n                Perl_re_printf( aTHX_  \"first at %\" IVdf \"\\n\",\n\t\t\t      (IV)(first - scan + 1))\n        );\n#else\n\tDEBUG_PARSE_r(\n            Perl_re_printf( aTHX_  \"first at %\" IVdf \"\\n\",\n\t        (IV)(first - scan + 1))\n        );\n#endif\n\n\n\t/*\n\t* If there's something expensive in the r.e., find the\n\t* longest literal string that must appear and make it the\n\t* regmust.  Resolve ties in favor of later strings, since\n\t* the regstart check works with the beginning of the r.e.\n\t* and avoiding duplication strengthens checking.  Not a\n\t* strong reason, but sufficient in the absence of others.\n\t* [Now we resolve ties in favor of the earlier string if\n\t* it happens that c_offset_min has been invalidated, since the\n\t* earlier string may buy us something the later one won't.]\n\t*/\n\n\tdata.substrs[0].str = newSVpvs(\"\");\n\tdata.substrs[1].str = newSVpvs(\"\");\n\tdata.last_found = newSVpvs(\"\");\n\tdata.cur_is_floating = 0; /* initially any found substring is fixed */\n\tENTER_with_name(\"study_chunk\");\n\tSAVEFREESV(data.substrs[0].str);\n\tSAVEFREESV(data.substrs[1].str);\n\tSAVEFREESV(data.last_found);\n\tfirst = scan;\n\tif (!RExC_rxi->regstclass) {\n\t    ssc_init(pRExC_state, &ch_class);\n\t    data.start_class = &ch_class;\n\t    stclass_flag = SCF_DO_STCLASS_AND;\n\t} else\t\t\t\t/* XXXX Check for BOUND? */\n\t    stclass_flag = 0;\n\tdata.last_closep = &last_close;\n\n        DEBUG_RExC_seen();\n        /*\n         * MAIN ENTRY FOR study_chunk() FOR m/PATTERN/\n         * (NO top level branches)\n         */\n\tminlen = study_chunk(pRExC_state, &first, &minlen, &fake,\n                             scan + RExC_size, /* Up to end */\n            &data, -1, 0, NULL,\n            SCF_DO_SUBSTR | SCF_WHILEM_VISITED_POS | stclass_flag\n                          | (restudied ? SCF_TRIE_DOING_RESTUDY : 0),\n            0);\n\n\n        CHECK_RESTUDY_GOTO_butfirst(LEAVE_with_name(\"study_chunk\"));\n\n\n\tif ( RExC_total_parens == 1 && !data.cur_is_floating\n\t     && data.last_start_min == 0 && data.last_end > 0\n\t     && !RExC_seen_zerolen\n             && !(RExC_seen & REG_VERBARG_SEEN)\n             && !(RExC_seen & REG_GPOS_SEEN)\n        ){\n\t    RExC_rx->extflags |= RXf_CHECK_ALL;\n        }\n\tscan_commit(pRExC_state, &data,&minlen, 0);\n\n\n        /* XXX this is done in reverse order because that's the way the\n         * code was before it was parameterised. Don't know whether it\n         * actually needs doing in reverse order. DAPM */\n        for (i = 1; i >= 0; i--) {\n            longest_length[i] = CHR_SVLEN(data.substrs[i].str);\n\n            if (   !(   i\n                     && SvCUR(data.substrs[0].str)  /* ok to leave SvCUR */\n                     &&    data.substrs[0].min_offset\n                        == data.substrs[1].min_offset\n                     &&    SvCUR(data.substrs[0].str)\n                        == SvCUR(data.substrs[1].str)\n                    )\n                && S_setup_longest (aTHX_ pRExC_state,\n                                        &(RExC_rx->substrs->data[i]),\n                                        &(data.substrs[i]),\n                                        longest_length[i]))\n            {\n                RExC_rx->substrs->data[i].min_offset =\n                        data.substrs[i].min_offset - data.substrs[i].lookbehind;\n\n                RExC_rx->substrs->data[i].max_offset = data.substrs[i].max_offset;\n                /* Don't offset infinity */\n                if (data.substrs[i].max_offset < SSize_t_MAX)\n                    RExC_rx->substrs->data[i].max_offset -= data.substrs[i].lookbehind;\n                SvREFCNT_inc_simple_void_NN(data.substrs[i].str);\n            }\n            else {\n                RExC_rx->substrs->data[i].substr      = NULL;\n                RExC_rx->substrs->data[i].utf8_substr = NULL;\n                longest_length[i] = 0;\n            }\n        }\n\n\tLEAVE_with_name(\"study_chunk\");\n\n\tif (RExC_rxi->regstclass\n\t    && (OP(RExC_rxi->regstclass) == REG_ANY || OP(RExC_rxi->regstclass) == SANY))\n\t    RExC_rxi->regstclass = NULL;\n\n\tif ((!(RExC_rx->substrs->data[0].substr || RExC_rx->substrs->data[0].utf8_substr)\n              || RExC_rx->substrs->data[0].min_offset)\n\t    && stclass_flag\n            && ! (ANYOF_FLAGS(data.start_class) & SSC_MATCHES_EMPTY_STRING)\n\t    && is_ssc_worth_it(pRExC_state, data.start_class))\n\t{\n\t    const U32 n = add_data(pRExC_state, STR_WITH_LEN(\"f\"));\n\n            ssc_finalize(pRExC_state, data.start_class);\n\n\t    Newx(RExC_rxi->data->data[n], 1, regnode_ssc);\n\t    StructCopy(data.start_class,\n\t\t       (regnode_ssc*)RExC_rxi->data->data[n],\n\t\t       regnode_ssc);\n\t    RExC_rxi->regstclass = (regnode*)RExC_rxi->data->data[n];\n\t    RExC_rx->intflags &= ~PREGf_SKIP;\t/* Used in find_byclass(). */\n\t    DEBUG_COMPILE_r({ SV *sv = sv_newmortal();\n                      regprop(RExC_rx, sv, (regnode*)data.start_class, NULL, pRExC_state);\n                      Perl_re_printf( aTHX_\n\t\t\t\t    \"synthetic stclass \\\"%s\\\".\\n\",\n\t\t\t\t    SvPVX_const(sv));});\n            data.start_class = NULL;\n\t}\n\n        /* A temporary algorithm prefers floated substr to fixed one of\n         * same length to dig more info. */\n\ti = (longest_length[0] <= longest_length[1]);\n        RExC_rx->substrs->check_ix = i;\n        RExC_rx->check_end_shift  = RExC_rx->substrs->data[i].end_shift;\n        RExC_rx->check_substr     = RExC_rx->substrs->data[i].substr;\n        RExC_rx->check_utf8       = RExC_rx->substrs->data[i].utf8_substr;\n        RExC_rx->check_offset_min = RExC_rx->substrs->data[i].min_offset;\n        RExC_rx->check_offset_max = RExC_rx->substrs->data[i].max_offset;\n        if (!i && (RExC_rx->intflags & (PREGf_ANCH_SBOL|PREGf_ANCH_GPOS)))\n            RExC_rx->intflags |= PREGf_NOSCAN;\n\n\tif ((RExC_rx->check_substr || RExC_rx->check_utf8) ) {\n\t    RExC_rx->extflags |= RXf_USE_INTUIT;\n\t    if (SvTAIL(RExC_rx->check_substr ? RExC_rx->check_substr : RExC_rx->check_utf8))\n\t\tRExC_rx->extflags |= RXf_INTUIT_TAIL;\n\t}\n\n\t/* XXX Unneeded? dmq (shouldn't as this is handled elsewhere)\n\tif ( (STRLEN)minlen < longest_length[1] )\n            minlen= longest_length[1];\n        if ( (STRLEN)minlen < longest_length[0] )\n            minlen= longest_length[0];\n        */\n    }\n    else {\n\t/* Several toplevels. Best we can is to set minlen. */\n\tSSize_t fake;\n\tregnode_ssc ch_class;\n\tSSize_t last_close = 0;\n\n        DEBUG_PARSE_r(Perl_re_printf( aTHX_  \"\\nMulti Top Level\\n\"));\n\n\tscan = RExC_rxi->program + 1;\n\tssc_init(pRExC_state, &ch_class);\n\tdata.start_class = &ch_class;\n\tdata.last_closep = &last_close;\n\n        DEBUG_RExC_seen();\n        /*\n         * MAIN ENTRY FOR study_chunk() FOR m/P1|P2|.../\n         * (patterns WITH top level branches)\n         */\n\tminlen = study_chunk(pRExC_state,\n            &scan, &minlen, &fake, scan + RExC_size, &data, -1, 0, NULL,\n            SCF_DO_STCLASS_AND|SCF_WHILEM_VISITED_POS|(restudied\n                                                      ? SCF_TRIE_DOING_RESTUDY\n                                                      : 0),\n            0);\n\n        CHECK_RESTUDY_GOTO_butfirst(NOOP);\n\n\tRExC_rx->check_substr = NULL;\n        RExC_rx->check_utf8 = NULL;\n        RExC_rx->substrs->data[0].substr      = NULL;\n        RExC_rx->substrs->data[0].utf8_substr = NULL;\n        RExC_rx->substrs->data[1].substr      = NULL;\n        RExC_rx->substrs->data[1].utf8_substr = NULL;\n\n        if (! (ANYOF_FLAGS(data.start_class) & SSC_MATCHES_EMPTY_STRING)\n\t    && is_ssc_worth_it(pRExC_state, data.start_class))\n        {\n\t    const U32 n = add_data(pRExC_state, STR_WITH_LEN(\"f\"));\n\n            ssc_finalize(pRExC_state, data.start_class);\n\n\t    Newx(RExC_rxi->data->data[n], 1, regnode_ssc);\n\t    StructCopy(data.start_class,\n\t\t       (regnode_ssc*)RExC_rxi->data->data[n],\n\t\t       regnode_ssc);\n\t    RExC_rxi->regstclass = (regnode*)RExC_rxi->data->data[n];\n\t    RExC_rx->intflags &= ~PREGf_SKIP;\t/* Used in find_byclass(). */\n\t    DEBUG_COMPILE_r({ SV* sv = sv_newmortal();\n                      regprop(RExC_rx, sv, (regnode*)data.start_class, NULL, pRExC_state);\n                      Perl_re_printf( aTHX_\n\t\t\t\t    \"synthetic stclass \\\"%s\\\".\\n\",\n\t\t\t\t    SvPVX_const(sv));});\n            data.start_class = NULL;\n\t}\n    }\n\n    if (RExC_seen & REG_UNBOUNDED_QUANTIFIER_SEEN) {\n        RExC_rx->extflags |= RXf_UNBOUNDED_QUANTIFIER_SEEN;\n        RExC_rx->maxlen = REG_INFTY;\n    }\n    else {\n        RExC_rx->maxlen = RExC_maxlen;\n    }\n\n    /* Guard against an embedded (?=) or (?<=) with a longer minlen than\n       the \"real\" pattern. */\n    DEBUG_OPTIMISE_r({\n        Perl_re_printf( aTHX_ \"minlen: %\" IVdf \" RExC_rx->minlen:%\" IVdf \" maxlen:%\" IVdf \"\\n\",\n                      (IV)minlen, (IV)RExC_rx->minlen, (IV)RExC_maxlen);\n    });\n    RExC_rx->minlenret = minlen;\n    if (RExC_rx->minlen < minlen)\n        RExC_rx->minlen = minlen;\n\n    if (RExC_seen & REG_RECURSE_SEEN ) {\n        RExC_rx->intflags |= PREGf_RECURSE_SEEN;\n        Newx(RExC_rx->recurse_locinput, RExC_rx->nparens + 1, char *);\n    }\n    if (RExC_seen & REG_GPOS_SEEN)\n        RExC_rx->intflags |= PREGf_GPOS_SEEN;\n    if (RExC_seen & REG_LOOKBEHIND_SEEN)\n        RExC_rx->extflags |= RXf_NO_INPLACE_SUBST; /* inplace might break the\n                                                lookbehind */\n    if (pRExC_state->code_blocks)\n\tRExC_rx->extflags |= RXf_EVAL_SEEN;\n    if (RExC_seen & REG_VERBARG_SEEN)\n    {\n\tRExC_rx->intflags |= PREGf_VERBARG_SEEN;\n        RExC_rx->extflags |= RXf_NO_INPLACE_SUBST; /* don't understand this! Yves */\n    }\n    if (RExC_seen & REG_CUTGROUP_SEEN)\n\tRExC_rx->intflags |= PREGf_CUTGROUP_SEEN;\n    if (pm_flags & PMf_USE_RE_EVAL)\n\tRExC_rx->intflags |= PREGf_USE_RE_EVAL;\n    if (RExC_paren_names)\n        RXp_PAREN_NAMES(RExC_rx) = MUTABLE_HV(SvREFCNT_inc(RExC_paren_names));\n    else\n        RXp_PAREN_NAMES(RExC_rx) = NULL;\n\n    /* If we have seen an anchor in our pattern then we set the extflag RXf_IS_ANCHORED\n     * so it can be used in pp.c */\n    if (RExC_rx->intflags & PREGf_ANCH)\n        RExC_rx->extflags |= RXf_IS_ANCHORED;\n\n\n    {\n        /* this is used to identify \"special\" patterns that might result\n         * in Perl NOT calling the regex engine and instead doing the match \"itself\",\n         * particularly special cases in split//. By having the regex compiler\n         * do this pattern matching at a regop level (instead of by inspecting the pattern)\n         * we avoid weird issues with equivalent patterns resulting in different behavior,\n         * AND we allow non Perl engines to get the same optimizations by the setting the\n         * flags appropriately - Yves */\n        regnode *first = RExC_rxi->program + 1;\n        U8 fop = OP(first);\n        regnode *next = regnext(first);\n        U8 nop = OP(next);\n\n        if (PL_regkind[fop] == NOTHING && nop == END)\n            RExC_rx->extflags |= RXf_NULL;\n        else if ((fop == MBOL || (fop == SBOL && !first->flags)) && nop == END)\n            /* when fop is SBOL first->flags will be true only when it was\n             * produced by parsing /\\A/, and not when parsing /^/. This is\n             * very important for the split code as there we want to\n             * treat /^/ as /^/m, but we do not want to treat /\\A/ as /^/m.\n             * See rt #122761 for more details. -- Yves */\n            RExC_rx->extflags |= RXf_START_ONLY;\n        else if (fop == PLUS\n                 && PL_regkind[nop] == POSIXD && FLAGS(next) == _CC_SPACE\n                 && nop == END)\n            RExC_rx->extflags |= RXf_WHITE;\n        else if ( RExC_rx->extflags & RXf_SPLIT\n                  && (fop == EXACT || fop == EXACT_ONLY8 || fop == EXACTL)\n                  && STR_LEN(first) == 1\n                  && *(STRING(first)) == ' '\n                  && nop == END )\n            RExC_rx->extflags |= (RXf_SKIPWHITE|RXf_WHITE);\n\n    }\n\n    if (RExC_contains_locale) {\n        RXp_EXTFLAGS(RExC_rx) |= RXf_TAINTED;\n    }\n\n#ifdef DEBUGGING\n    if (RExC_paren_names) {\n        RExC_rxi->name_list_idx = add_data( pRExC_state, STR_WITH_LEN(\"a\"));\n        RExC_rxi->data->data[RExC_rxi->name_list_idx]\n                                   = (void*)SvREFCNT_inc(RExC_paren_name_list);\n    } else\n#endif\n    RExC_rxi->name_list_idx = 0;\n\n    while ( RExC_recurse_count > 0 ) {\n        const regnode *scan = RExC_recurse[ --RExC_recurse_count ];\n        /*\n         * This data structure is set up in study_chunk() and is used\n         * to calculate the distance between a GOSUB regopcode and\n         * the OPEN/CURLYM (CURLYM's are special and can act like OPEN's)\n         * it refers to.\n         *\n         * If for some reason someone writes code that optimises\n         * away a GOSUB opcode then the assert should be changed to\n         * an if(scan) to guard the ARG2L_SET() - Yves\n         *\n         */\n        assert(scan && OP(scan) == GOSUB);\n        ARG2L_SET( scan, RExC_open_parens[ARG(scan)] - REGNODE_OFFSET(scan));\n    }\n\n    Newxz(RExC_rx->offs, RExC_total_parens, regexp_paren_pair);\n    /* assume we don't need to swap parens around before we match */\n    DEBUG_TEST_r({\n        Perl_re_printf( aTHX_ \"study_chunk_recursed_count: %lu\\n\",\n            (unsigned long)RExC_study_chunk_recursed_count);\n    });\n    DEBUG_DUMP_r({\n        DEBUG_RExC_seen();\n        Perl_re_printf( aTHX_ \"Final program:\\n\");\n        regdump(RExC_rx);\n    });\n\n    if (RExC_open_parens) {\n        Safefree(RExC_open_parens);\n        RExC_open_parens = NULL;\n    }\n    if (RExC_close_parens) {\n        Safefree(RExC_close_parens);\n        RExC_close_parens = NULL;\n    }\n\n#ifdef USE_ITHREADS\n    /* under ithreads the ?pat? PMf_USED flag on the pmop is simulated\n     * by setting the regexp SV to readonly-only instead. If the\n     * pattern's been recompiled, the USEDness should remain. */\n    if (old_re && SvREADONLY(old_re))\n        SvREADONLY_on(Rx);\n#endif\n    return Rx;",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149785,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "int mem_check_range(struct rxe_mem *mem, u64 iova, size_t length)\n{\n\tswitch (mem->type) {\n\tcase RXE_MEM_TYPE_DMA:\n\t\treturn 0;\n\n\tcase RXE_MEM_TYPE_MR:\n\tcase RXE_MEM_TYPE_FMR:\n\t\treturn ((iova < mem->iova) ||\n\t\t\t((iova + length) > (mem->iova + mem->length))) ?\n\t\t\t-EFAULT : 0;\n\n\tdefault:\n\t\treturn -EFAULT;\n\t}\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149786,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "int mem_check_range(struct rxe_mem *mem, u64 iova, size_t length)\n{\n\tswitch (mem->type) {\n\tcase RXE_MEM_TYPE_DMA:\n\t\treturn 0;\n\n\tcase RXE_MEM_TYPE_MR:\n\tcase RXE_MEM_TYPE_FMR:\n\t\tif (iova < mem->iova ||\n\t\t    length > mem->length ||\n\t\t    iova > mem->iova + mem->length - length)\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -EFAULT;\n\t}\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149787,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static int set_geometry(unsigned int cmd, struct floppy_struct *g,\n\t\t\t       int drive, int type, struct block_device *bdev)\n{\n\tint cnt;\n\n\t/* sanity checking for parameters. */\n\tif (g->sect <= 0 ||\n\t    g->head <= 0 ||\n\t    /* check for zero in F_SECT_PER_TRACK */\n\t    (unsigned char)((g->sect << 2) >> FD_SIZECODE(g)) == 0 ||\n\t    g->track <= 0 || g->track > UDP->tracks >> STRETCH(g) ||\n\t    /* check if reserved bits are set */\n\t    (g->stretch & ~(FD_STRETCH | FD_SWAPSIDES | FD_SECTBASEMASK)) != 0)\n\t\treturn -EINVAL;\n\tif (type) {\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t\tmutex_lock(&open_lock);\n\t\tif (lock_fdc(drive)) {\n\t\t\tmutex_unlock(&open_lock);\n\t\t\treturn -EINTR;\n\t\t}\n\t\tfloppy_type[type] = *g;\n\t\tfloppy_type[type].name = \"user format\";\n\t\tfor (cnt = type << 2; cnt < (type << 2) + 4; cnt++)\n\t\t\tfloppy_sizes[cnt] = floppy_sizes[cnt + 0x80] =\n\t\t\t    floppy_type[type].size + 1;\n\t\tprocess_fd_request();\n\t\tfor (cnt = 0; cnt < N_DRIVE; cnt++) {\n\t\t\tstruct block_device *bdev = opened_bdev[cnt];\n\t\t\tif (!bdev || ITYPE(drive_state[cnt].fd_device) != type)\n\t\t\t\tcontinue;\n\t\t\t__invalidate_device(bdev, true);\n\t\t}\n\t\tmutex_unlock(&open_lock);\n\t} else {\n\t\tint oldStretch;\n\n\t\tif (lock_fdc(drive))\n\t\t\treturn -EINTR;\n\t\tif (cmd != FDDEFPRM) {\n\t\t\t/* notice a disk change immediately, else\n\t\t\t * we lose our settings immediately*/\n\t\t\tif (poll_drive(true, FD_RAW_NEED_DISK) == -EINTR)\n\t\t\t\treturn -EINTR;\n\t\t}\n\t\toldStretch = g->stretch;\n\t\tuser_params[drive] = *g;\n\t\tif (buffer_drive == drive)\n\t\t\tSUPBOUND(buffer_max, user_params[drive].sect);\n\t\tcurrent_type[drive] = &user_params[drive];\n\t\tfloppy_sizes[drive] = user_params[drive].size;\n\t\tif (cmd == FDDEFPRM)\n\t\t\tDRS->keep_data = -1;\n\t\telse\n\t\t\tDRS->keep_data = 1;\n\t\t/* invalidation. Invalidate only when needed, i.e.\n\t\t * when there are already sectors in the buffer cache\n\t\t * whose number will change. This is useful, because\n\t\t * mtools often changes the geometry of the disk after\n\t\t * looking at the boot block */\n\t\tif (DRS->maxblock > user_params[drive].sect ||\n\t\t    DRS->maxtrack ||\n\t\t    ((user_params[drive].sect ^ oldStretch) &\n\t\t     (FD_SWAPSIDES | FD_SECTBASEMASK)))\n\t\t\tinvalidate_drive(bdev);\n\t\telse\n\t\t\tprocess_fd_request();\n\t}\n\treturn 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149788,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static int set_geometry(unsigned int cmd, struct floppy_struct *g,\n\t\t\t       int drive, int type, struct block_device *bdev)\n{\n\tint cnt;\n\n\t/* sanity checking for parameters. */\n\tif ((int)g->sect <= 0 ||\n\t    (int)g->head <= 0 ||\n\t    /* check for overflow in max_sector */\n\t    (int)(g->sect * g->head) <= 0 ||\n\t    /* check for zero in F_SECT_PER_TRACK */\n\t    (unsigned char)((g->sect << 2) >> FD_SIZECODE(g)) == 0 ||\n\t    g->track <= 0 || g->track > UDP->tracks >> STRETCH(g) ||\n\t    /* check if reserved bits are set */\n\t    (g->stretch & ~(FD_STRETCH | FD_SWAPSIDES | FD_SECTBASEMASK)) != 0)\n\t\treturn -EINVAL;\n\tif (type) {\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t\tmutex_lock(&open_lock);\n\t\tif (lock_fdc(drive)) {\n\t\t\tmutex_unlock(&open_lock);\n\t\t\treturn -EINTR;\n\t\t}\n\t\tfloppy_type[type] = *g;\n\t\tfloppy_type[type].name = \"user format\";\n\t\tfor (cnt = type << 2; cnt < (type << 2) + 4; cnt++)\n\t\t\tfloppy_sizes[cnt] = floppy_sizes[cnt + 0x80] =\n\t\t\t    floppy_type[type].size + 1;\n\t\tprocess_fd_request();\n\t\tfor (cnt = 0; cnt < N_DRIVE; cnt++) {\n\t\t\tstruct block_device *bdev = opened_bdev[cnt];\n\t\t\tif (!bdev || ITYPE(drive_state[cnt].fd_device) != type)\n\t\t\t\tcontinue;\n\t\t\t__invalidate_device(bdev, true);\n\t\t}\n\t\tmutex_unlock(&open_lock);\n\t} else {\n\t\tint oldStretch;\n\n\t\tif (lock_fdc(drive))\n\t\t\treturn -EINTR;\n\t\tif (cmd != FDDEFPRM) {\n\t\t\t/* notice a disk change immediately, else\n\t\t\t * we lose our settings immediately*/\n\t\t\tif (poll_drive(true, FD_RAW_NEED_DISK) == -EINTR)\n\t\t\t\treturn -EINTR;\n\t\t}\n\t\toldStretch = g->stretch;\n\t\tuser_params[drive] = *g;\n\t\tif (buffer_drive == drive)\n\t\t\tSUPBOUND(buffer_max, user_params[drive].sect);\n\t\tcurrent_type[drive] = &user_params[drive];\n\t\tfloppy_sizes[drive] = user_params[drive].size;\n\t\tif (cmd == FDDEFPRM)\n\t\t\tDRS->keep_data = -1;\n\t\telse\n\t\t\tDRS->keep_data = 1;\n\t\t/* invalidation. Invalidate only when needed, i.e.\n\t\t * when there are already sectors in the buffer cache\n\t\t * whose number will change. This is useful, because\n\t\t * mtools often changes the geometry of the disk after\n\t\t * looking at the boot block */\n\t\tif (DRS->maxblock > user_params[drive].sect ||\n\t\t    DRS->maxtrack ||\n\t\t    ((user_params[drive].sect ^ oldStretch) &\n\t\t     (FD_SWAPSIDES | FD_SECTBASEMASK)))\n\t\t\tinvalidate_drive(bdev);\n\t\telse\n\t\t\tprocess_fd_request();\n\t}\n\treturn 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149789,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static int __get_data_block(struct inode *inode, sector_t iblock,\n\t\t\tstruct buffer_head *bh, int create, int flag,\n\t\t\tpgoff_t *next_pgofs)\n{\n\tstruct f2fs_map_blocks map;\n\tint err;\n\n\tmap.m_lblk = iblock;\n\tmap.m_len = bh->b_size >> inode->i_blkbits;\n\tmap.m_next_pgofs = next_pgofs;\n\n\terr = f2fs_map_blocks(inode, &map, create, flag);\n\tif (!err) {\n\t\tmap_bh(bh, inode->i_sb, map.m_pblk);\n\t\tbh->b_state = (bh->b_state & ~F2FS_MAP_FLAGS) | map.m_flags;\n\t\tbh->b_size = map.m_len << inode->i_blkbits;\n\t}\n\treturn err;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149790,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static int __get_data_block(struct inode *inode, sector_t iblock,\n\t\t\tstruct buffer_head *bh, int create, int flag,\n\t\t\tpgoff_t *next_pgofs)\n{\n\tstruct f2fs_map_blocks map;\n\tint err;\n\n\tmap.m_lblk = iblock;\n\tmap.m_len = bh->b_size >> inode->i_blkbits;\n\tmap.m_next_pgofs = next_pgofs;\n\n\terr = f2fs_map_blocks(inode, &map, create, flag);\n\tif (!err) {\n\t\tmap_bh(bh, inode->i_sb, map.m_pblk);\n\t\tbh->b_state = (bh->b_state & ~F2FS_MAP_FLAGS) | map.m_flags;\n\t\tbh->b_size = (u64)map.m_len << inode->i_blkbits;\n\t}\n\treturn err;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149791,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "PHPAPI PHP_FUNCTION(fread)\n{\n\tzval *arg1;\n\tlong len;\n\tphp_stream *stream;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rl\", &arg1, &len) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &arg1);\n\n\tif (len <= 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Length parameter must be greater than 0\");\n\t\tRETURN_FALSE;\n\t}\n\n\tZ_STRVAL_P(return_value) = emalloc(len + 1);\n\tZ_STRLEN_P(return_value) = php_stream_read(stream, Z_STRVAL_P(return_value), len);\n\n\t/* needed because recv/read/gzread doesnt put a null at the end*/\n\tZ_STRVAL_P(return_value)[Z_STRLEN_P(return_value)] = 0;\n\tZ_TYPE_P(return_value) = IS_STRING;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149794,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "PHPAPI PHP_FUNCTION(fread)\n{\n\tzval *arg1;\n\tlong len;\n\tphp_stream *stream;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rl\", &arg1, &len) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &arg1);\n\n\tif (len <= 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Length parameter must be greater than 0\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (len > INT_MAX) {\n\t\t/* string length is int in 5.x so we can not read more than int */\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Length parameter must be no more than %d\", INT_MAX);\n\t\tRETURN_FALSE;\n\t}\n\n\tZ_STRVAL_P(return_value) = emalloc(len + 1);\n\tZ_STRLEN_P(return_value) = php_stream_read(stream, Z_STRVAL_P(return_value), len);\n\n\t/* needed because recv/read/gzread doesnt put a null at the end*/\n\tZ_STRVAL_P(return_value)[Z_STRLEN_P(return_value)] = 0;\n\tZ_TYPE_P(return_value) = IS_STRING;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149795,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "int amqp_handle_input(amqp_connection_state_t state, amqp_bytes_t received_data,\n                      amqp_frame_t *decoded_frame) {\n  size_t bytes_consumed;\n  void *raw_frame;\n\n  /* Returning frame_type of zero indicates either insufficient input,\n     or a complete, ignored frame was read. */\n  decoded_frame->frame_type = 0;\n\n  if (received_data.len == 0) {\n    return AMQP_STATUS_OK;\n  }\n\n  if (state->state == CONNECTION_STATE_IDLE) {\n    state->state = CONNECTION_STATE_HEADER;\n  }\n\n  bytes_consumed = consume_data(state, &received_data);\n\n  /* do we have target_size data yet? if not, return with the\n     expectation that more will arrive */\n  if (state->inbound_offset < state->target_size) {\n    return (int)bytes_consumed;\n  }\n\n  raw_frame = state->inbound_buffer.bytes;\n\n  switch (state->state) {\n    case CONNECTION_STATE_INITIAL:\n      /* check for a protocol header from the server */\n      if (memcmp(raw_frame, \"AMQP\", 4) == 0) {\n        decoded_frame->frame_type = AMQP_PSEUDOFRAME_PROTOCOL_HEADER;\n        decoded_frame->channel = 0;\n\n        decoded_frame->payload.protocol_header.transport_high =\n            amqp_d8(amqp_offset(raw_frame, 4));\n        decoded_frame->payload.protocol_header.transport_low =\n            amqp_d8(amqp_offset(raw_frame, 5));\n        decoded_frame->payload.protocol_header.protocol_version_major =\n            amqp_d8(amqp_offset(raw_frame, 6));\n        decoded_frame->payload.protocol_header.protocol_version_minor =\n            amqp_d8(amqp_offset(raw_frame, 7));\n\n        return_to_idle(state);\n        return (int)bytes_consumed;\n      }\n\n    /* it's not a protocol header; fall through to process it as a\n       regular frame header */\n\n    case CONNECTION_STATE_HEADER: {\n      amqp_channel_t channel;\n      amqp_pool_t *channel_pool;\n      /* frame length is 3 bytes in */\n      channel = amqp_d16(amqp_offset(raw_frame, 1));\n\n      state->target_size =\n          amqp_d32(amqp_offset(raw_frame, 3)) + HEADER_SIZE + FOOTER_SIZE;\n\n      if ((size_t)state->frame_max < state->target_size) {\n        return AMQP_STATUS_BAD_AMQP_DATA;\n      }\n\n      channel_pool = amqp_get_or_create_channel_pool(state, channel);\n      if (NULL == channel_pool) {\n        return AMQP_STATUS_NO_MEMORY;\n      }\n\n      amqp_pool_alloc_bytes(channel_pool, state->target_size,\n                            &state->inbound_buffer);\n      if (NULL == state->inbound_buffer.bytes) {\n        return AMQP_STATUS_NO_MEMORY;\n      }\n      memcpy(state->inbound_buffer.bytes, state->header_buffer, HEADER_SIZE);\n      raw_frame = state->inbound_buffer.bytes;\n\n      state->state = CONNECTION_STATE_BODY;\n\n      bytes_consumed += consume_data(state, &received_data);\n\n      /* do we have target_size data yet? if not, return with the\n         expectation that more will arrive */\n      if (state->inbound_offset < state->target_size) {\n        return (int)bytes_consumed;\n      }\n    }\n    /* fall through to process body */\n\n    case CONNECTION_STATE_BODY: {\n      amqp_bytes_t encoded;\n      int res;\n      amqp_pool_t *channel_pool;\n\n      /* Check frame end marker (footer) */\n      if (amqp_d8(amqp_offset(raw_frame, state->target_size - 1)) !=\n          AMQP_FRAME_END) {\n        return AMQP_STATUS_BAD_AMQP_DATA;\n      }\n\n      decoded_frame->frame_type = amqp_d8(amqp_offset(raw_frame, 0));\n      decoded_frame->channel = amqp_d16(amqp_offset(raw_frame, 1));\n\n      channel_pool =\n          amqp_get_or_create_channel_pool(state, decoded_frame->channel);\n      if (NULL == channel_pool) {\n        return AMQP_STATUS_NO_MEMORY;\n      }\n\n      switch (decoded_frame->frame_type) {\n        case AMQP_FRAME_METHOD:\n          decoded_frame->payload.method.id =\n              amqp_d32(amqp_offset(raw_frame, HEADER_SIZE));\n          encoded.bytes = amqp_offset(raw_frame, HEADER_SIZE + 4);\n          encoded.len = state->target_size - HEADER_SIZE - 4 - FOOTER_SIZE;\n\n          res = amqp_decode_method(decoded_frame->payload.method.id,\n                                   channel_pool, encoded,\n                                   &decoded_frame->payload.method.decoded);\n          if (res < 0) {\n            return res;\n          }\n\n          break;\n\n        case AMQP_FRAME_HEADER:\n          decoded_frame->payload.properties.class_id =\n              amqp_d16(amqp_offset(raw_frame, HEADER_SIZE));\n          /* unused 2-byte weight field goes here */\n          decoded_frame->payload.properties.body_size =\n              amqp_d64(amqp_offset(raw_frame, HEADER_SIZE + 4));\n          encoded.bytes = amqp_offset(raw_frame, HEADER_SIZE + 12);\n          encoded.len = state->target_size - HEADER_SIZE - 12 - FOOTER_SIZE;\n          decoded_frame->payload.properties.raw = encoded;\n\n          res = amqp_decode_properties(\n              decoded_frame->payload.properties.class_id, channel_pool, encoded,\n              &decoded_frame->payload.properties.decoded);\n          if (res < 0) {\n            return res;\n          }\n\n          break;\n\n        case AMQP_FRAME_BODY:\n          decoded_frame->payload.body_fragment.len =\n              state->target_size - HEADER_SIZE - FOOTER_SIZE;\n          decoded_frame->payload.body_fragment.bytes =\n              amqp_offset(raw_frame, HEADER_SIZE);\n          break;\n\n        case AMQP_FRAME_HEARTBEAT:\n          break;\n\n        default:\n          /* Ignore the frame */\n          decoded_frame->frame_type = 0;\n          break;\n      }\n\n      return_to_idle(state);\n      return (int)bytes_consumed;\n    }\n\n    default:\n      amqp_abort(\"Internal error: invalid amqp_connection_state_t->state %d\",\n                 state->state);\n  }\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149796,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "int amqp_handle_input(amqp_connection_state_t state, amqp_bytes_t received_data,\n                      amqp_frame_t *decoded_frame) {\n  size_t bytes_consumed;\n  void *raw_frame;\n\n  /* Returning frame_type of zero indicates either insufficient input,\n     or a complete, ignored frame was read. */\n  decoded_frame->frame_type = 0;\n\n  if (received_data.len == 0) {\n    return AMQP_STATUS_OK;\n  }\n\n  if (state->state == CONNECTION_STATE_IDLE) {\n    state->state = CONNECTION_STATE_HEADER;\n  }\n\n  bytes_consumed = consume_data(state, &received_data);\n\n  /* do we have target_size data yet? if not, return with the\n     expectation that more will arrive */\n  if (state->inbound_offset < state->target_size) {\n    return (int)bytes_consumed;\n  }\n\n  raw_frame = state->inbound_buffer.bytes;\n\n  switch (state->state) {\n    case CONNECTION_STATE_INITIAL:\n      /* check for a protocol header from the server */\n      if (memcmp(raw_frame, \"AMQP\", 4) == 0) {\n        decoded_frame->frame_type = AMQP_PSEUDOFRAME_PROTOCOL_HEADER;\n        decoded_frame->channel = 0;\n\n        decoded_frame->payload.protocol_header.transport_high =\n            amqp_d8(amqp_offset(raw_frame, 4));\n        decoded_frame->payload.protocol_header.transport_low =\n            amqp_d8(amqp_offset(raw_frame, 5));\n        decoded_frame->payload.protocol_header.protocol_version_major =\n            amqp_d8(amqp_offset(raw_frame, 6));\n        decoded_frame->payload.protocol_header.protocol_version_minor =\n            amqp_d8(amqp_offset(raw_frame, 7));\n\n        return_to_idle(state);\n        return (int)bytes_consumed;\n      }\n\n    /* it's not a protocol header; fall through to process it as a\n       regular frame header */\n\n    case CONNECTION_STATE_HEADER: {\n      amqp_channel_t channel;\n      amqp_pool_t *channel_pool;\n      uint32_t frame_size;\n\n      channel = amqp_d16(amqp_offset(raw_frame, 1));\n\n      /* frame length is 3 bytes in */\n      frame_size = amqp_d32(amqp_offset(raw_frame, 3));\n      /* To prevent the target_size calculation below from overflowing, check\n       * that the stated frame_size is smaller than a signed 32-bit. Given\n       * the library only allows configuring frame_max as an int32_t, and\n       * frame_size is uint32_t, the math below is safe from overflow. */\n      if (frame_size >= INT32_MAX) {\n        return AMQP_STATUS_BAD_AMQP_DATA;\n      }\n\n      state->target_size = frame_size + HEADER_SIZE + FOOTER_SIZE;\n      if ((size_t)state->frame_max < state->target_size) {\n        return AMQP_STATUS_BAD_AMQP_DATA;\n      }\n\n      channel_pool = amqp_get_or_create_channel_pool(state, channel);\n      if (NULL == channel_pool) {\n        return AMQP_STATUS_NO_MEMORY;\n      }\n\n      amqp_pool_alloc_bytes(channel_pool, state->target_size,\n                            &state->inbound_buffer);\n      if (NULL == state->inbound_buffer.bytes) {\n        return AMQP_STATUS_NO_MEMORY;\n      }\n      memcpy(state->inbound_buffer.bytes, state->header_buffer, HEADER_SIZE);\n      raw_frame = state->inbound_buffer.bytes;\n\n      state->state = CONNECTION_STATE_BODY;\n\n      bytes_consumed += consume_data(state, &received_data);\n\n      /* do we have target_size data yet? if not, return with the\n         expectation that more will arrive */\n      if (state->inbound_offset < state->target_size) {\n        return (int)bytes_consumed;\n      }\n    }\n    /* fall through to process body */\n\n    case CONNECTION_STATE_BODY: {\n      amqp_bytes_t encoded;\n      int res;\n      amqp_pool_t *channel_pool;\n\n      /* Check frame end marker (footer) */\n      if (amqp_d8(amqp_offset(raw_frame, state->target_size - 1)) !=\n          AMQP_FRAME_END) {\n        return AMQP_STATUS_BAD_AMQP_DATA;\n      }\n\n      decoded_frame->frame_type = amqp_d8(amqp_offset(raw_frame, 0));\n      decoded_frame->channel = amqp_d16(amqp_offset(raw_frame, 1));\n\n      channel_pool =\n          amqp_get_or_create_channel_pool(state, decoded_frame->channel);\n      if (NULL == channel_pool) {\n        return AMQP_STATUS_NO_MEMORY;\n      }\n\n      switch (decoded_frame->frame_type) {\n        case AMQP_FRAME_METHOD:\n          decoded_frame->payload.method.id =\n              amqp_d32(amqp_offset(raw_frame, HEADER_SIZE));\n          encoded.bytes = amqp_offset(raw_frame, HEADER_SIZE + 4);\n          encoded.len = state->target_size - HEADER_SIZE - 4 - FOOTER_SIZE;\n\n          res = amqp_decode_method(decoded_frame->payload.method.id,\n                                   channel_pool, encoded,\n                                   &decoded_frame->payload.method.decoded);\n          if (res < 0) {\n            return res;\n          }\n\n          break;\n\n        case AMQP_FRAME_HEADER:\n          decoded_frame->payload.properties.class_id =\n              amqp_d16(amqp_offset(raw_frame, HEADER_SIZE));\n          /* unused 2-byte weight field goes here */\n          decoded_frame->payload.properties.body_size =\n              amqp_d64(amqp_offset(raw_frame, HEADER_SIZE + 4));\n          encoded.bytes = amqp_offset(raw_frame, HEADER_SIZE + 12);\n          encoded.len = state->target_size - HEADER_SIZE - 12 - FOOTER_SIZE;\n          decoded_frame->payload.properties.raw = encoded;\n\n          res = amqp_decode_properties(\n              decoded_frame->payload.properties.class_id, channel_pool, encoded,\n              &decoded_frame->payload.properties.decoded);\n          if (res < 0) {\n            return res;\n          }\n\n          break;\n\n        case AMQP_FRAME_BODY:\n          decoded_frame->payload.body_fragment.len =\n              state->target_size - HEADER_SIZE - FOOTER_SIZE;\n          decoded_frame->payload.body_fragment.bytes =\n              amqp_offset(raw_frame, HEADER_SIZE);\n          break;\n\n        case AMQP_FRAME_HEARTBEAT:\n          break;\n\n        default:\n          /* Ignore the frame */\n          decoded_frame->frame_type = 0;\n          break;\n      }\n\n      return_to_idle(state);\n      return (int)bytes_consumed;\n    }\n\n    default:\n      amqp_abort(\"Internal error: invalid amqp_connection_state_t->state %d\",\n                 state->state);\n  }\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149797,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "choose_volume(struct archive_read *a, struct iso9660 *iso9660)\n{\n\tstruct file_info *file;\n\tint64_t skipsize;\n\tstruct vd *vd;\n\tconst void *block;\n\tchar seenJoliet;\n\n\tvd = &(iso9660->primary);\n\tif (!iso9660->opt_support_joliet)\n\t\tiso9660->seenJoliet = 0;\n\tif (iso9660->seenJoliet &&\n\t\tvd->location > iso9660->joliet.location)\n\t\t/* This condition is unlikely; by way of caution. */\n\t\tvd = &(iso9660->joliet);\n\n\tskipsize = LOGICAL_BLOCK_SIZE * vd->location;\n\tskipsize = __archive_read_consume(a, skipsize);\n\tif (skipsize < 0)\n\t\treturn ((int)skipsize);\n\tiso9660->current_position = skipsize;\n\n\tblock = __archive_read_ahead(a, vd->size, NULL);\n\tif (block == NULL) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"Failed to read full block when scanning \"\n\t\t    \"ISO9660 directory list\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\t/*\n\t * While reading Root Directory, flag seenJoliet must be zero to\n\t * avoid converting special name 0x00(Current Directory) and\n\t * next byte to UCS2.\n\t */\n\tseenJoliet = iso9660->seenJoliet;/* Save flag. */\n\tiso9660->seenJoliet = 0;\n\tfile = parse_file_info(a, NULL, block);\n\tif (file == NULL)\n\t\treturn (ARCHIVE_FATAL);\n\tiso9660->seenJoliet = seenJoliet;\n\n\t/*\n\t * If the iso image has both RockRidge and Joliet, we preferentially\n\t * use RockRidge Extensions rather than Joliet ones.\n\t */\n\tif (vd == &(iso9660->primary) && iso9660->seenRockridge\n\t    && iso9660->seenJoliet)\n\t\tiso9660->seenJoliet = 0;\n\n\tif (vd == &(iso9660->primary) && !iso9660->seenRockridge\n\t    && iso9660->seenJoliet) {\n\t\t/* Switch reading data from primary to joliet. */\n\t\tvd = &(iso9660->joliet);\n\t\tskipsize = LOGICAL_BLOCK_SIZE * vd->location;\n\t\tskipsize -= iso9660->current_position;\n\t\tskipsize = __archive_read_consume(a, skipsize);\n\t\tif (skipsize < 0)\n\t\t\treturn ((int)skipsize);\n\t\tiso9660->current_position += skipsize;\n\n\t\tblock = __archive_read_ahead(a, vd->size, NULL);\n\t\tif (block == NULL) {\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Failed to read full block when scanning \"\n\t\t\t    \"ISO9660 directory list\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tiso9660->seenJoliet = 0;\n\t\tfile = parse_file_info(a, NULL, block);\n\t\tif (file == NULL)\n\t\t\treturn (ARCHIVE_FATAL);\n\t\tiso9660->seenJoliet = seenJoliet;\n\t}\n\n\t/* Store the root directory in the pending list. */\n\tif (add_entry(a, iso9660, file) != ARCHIVE_OK)\n\t\treturn (ARCHIVE_FATAL);\n\tif (iso9660->seenRockridge) {\n\t\ta->archive.archive_format = ARCHIVE_FORMAT_ISO9660_ROCKRIDGE;\n\t\ta->archive.archive_format_name =\n\t\t    \"ISO9660 with Rockridge extensions\";\n\t}\n\n\treturn (ARCHIVE_OK);\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149798,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "choose_volume(struct archive_read *a, struct iso9660 *iso9660)\n{\n\tstruct file_info *file;\n\tint64_t skipsize;\n\tstruct vd *vd;\n\tconst void *block;\n\tchar seenJoliet;\n\n\tvd = &(iso9660->primary);\n\tif (!iso9660->opt_support_joliet)\n\t\tiso9660->seenJoliet = 0;\n\tif (iso9660->seenJoliet &&\n\t\tvd->location > iso9660->joliet.location)\n\t\t/* This condition is unlikely; by way of caution. */\n\t\tvd = &(iso9660->joliet);\n\n\tskipsize = LOGICAL_BLOCK_SIZE * (int64_t)vd->location;\n\tskipsize = __archive_read_consume(a, skipsize);\n\tif (skipsize < 0)\n\t\treturn ((int)skipsize);\n\tiso9660->current_position = skipsize;\n\n\tblock = __archive_read_ahead(a, vd->size, NULL);\n\tif (block == NULL) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"Failed to read full block when scanning \"\n\t\t    \"ISO9660 directory list\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\t/*\n\t * While reading Root Directory, flag seenJoliet must be zero to\n\t * avoid converting special name 0x00(Current Directory) and\n\t * next byte to UCS2.\n\t */\n\tseenJoliet = iso9660->seenJoliet;/* Save flag. */\n\tiso9660->seenJoliet = 0;\n\tfile = parse_file_info(a, NULL, block);\n\tif (file == NULL)\n\t\treturn (ARCHIVE_FATAL);\n\tiso9660->seenJoliet = seenJoliet;\n\n\t/*\n\t * If the iso image has both RockRidge and Joliet, we preferentially\n\t * use RockRidge Extensions rather than Joliet ones.\n\t */\n\tif (vd == &(iso9660->primary) && iso9660->seenRockridge\n\t    && iso9660->seenJoliet)\n\t\tiso9660->seenJoliet = 0;\n\n\tif (vd == &(iso9660->primary) && !iso9660->seenRockridge\n\t    && iso9660->seenJoliet) {\n\t\t/* Switch reading data from primary to joliet. */\n\t\tvd = &(iso9660->joliet);\n\t\tskipsize = LOGICAL_BLOCK_SIZE * (int64_t)vd->location;\n\t\tskipsize -= iso9660->current_position;\n\t\tskipsize = __archive_read_consume(a, skipsize);\n\t\tif (skipsize < 0)\n\t\t\treturn ((int)skipsize);\n\t\tiso9660->current_position += skipsize;\n\n\t\tblock = __archive_read_ahead(a, vd->size, NULL);\n\t\tif (block == NULL) {\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Failed to read full block when scanning \"\n\t\t\t    \"ISO9660 directory list\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tiso9660->seenJoliet = 0;\n\t\tfile = parse_file_info(a, NULL, block);\n\t\tif (file == NULL)\n\t\t\treturn (ARCHIVE_FATAL);\n\t\tiso9660->seenJoliet = seenJoliet;\n\t}\n\n\t/* Store the root directory in the pending list. */\n\tif (add_entry(a, iso9660, file) != ARCHIVE_OK)\n\t\treturn (ARCHIVE_FATAL);\n\tif (iso9660->seenRockridge) {\n\t\ta->archive.archive_format = ARCHIVE_FORMAT_ISO9660_ROCKRIDGE;\n\t\ta->archive.archive_format_name =\n\t\t    \"ISO9660 with Rockridge extensions\";\n\t}\n\n\treturn (ARCHIVE_OK);\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149799,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "void * CAPSTONE_API cs_winkernel_malloc(size_t size)\n{\n\t// Disallow zero length allocation because they waste pool header space and,\n\t// in many cases, indicate a potential validation issue in the calling code.\n\tNT_ASSERT(size);\n\n\t// FP; a use of NonPagedPool is required for Windows 7 support\n#pragma prefast(suppress : 30030)\t\t// Allocating executable POOL_TYPE memory\n\tCS_WINKERNEL_MEMBLOCK *block = (CS_WINKERNEL_MEMBLOCK *)ExAllocatePoolWithTag(\n\t\t\tNonPagedPool, size + sizeof(CS_WINKERNEL_MEMBLOCK), CS_WINKERNEL_POOL_TAG);\n\tif (!block) {\n\t\treturn NULL;\n\t}\n\tblock->size = size;\n\n\treturn block->data;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149800,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "void * CAPSTONE_API cs_winkernel_malloc(size_t size)\n{\n\t// Disallow zero length allocation because they waste pool header space and,\n\t// in many cases, indicate a potential validation issue in the calling code.\n\tNT_ASSERT(size);\n\n\t// FP; a use of NonPagedPool is required for Windows 7 support\n#pragma prefast(suppress : 30030)\t\t// Allocating executable POOL_TYPE memory\n\tsize_t number_of_bytes = 0;\n\tCS_WINKERNEL_MEMBLOCK *block = NULL;\n\t// A specially crafted size value can trigger the overflow.\n\t// If the sum in a value that overflows or underflows the capacity of the type,\n\t// the function returns NULL.\n\tif (!NT_SUCCESS(RtlSizeTAdd(size, sizeof(CS_WINKERNEL_MEMBLOCK), &number_of_bytes))) {\n\t\treturn NULL;\n\t}\n\tblock = (CS_WINKERNEL_MEMBLOCK *)ExAllocatePoolWithTag(\n\t\t\tNonPagedPool, number_of_bytes, CS_WINKERNEL_POOL_TAG);\n\tif (!block) {\n\t\treturn NULL;\n\t}\n\tblock->size = size;\n\n\treturn block->data;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149801,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "hfs_cat_traverse(HFS_INFO * hfs,\n    TSK_HFS_BTREE_CB a_cb, void *ptr)\n{\n    TSK_FS_INFO *fs = &(hfs->fs_info);\n    uint32_t cur_node;          /* node id of the current node */\n    char *node;\n\n    uint16_t nodesize;\n    uint8_t is_done = 0;\n\n    tsk_error_reset();\n\n    nodesize = tsk_getu16(fs->endian, hfs->catalog_header.nodesize);\n    if ((node = (char *) tsk_malloc(nodesize)) == NULL)\n        return 1;\n\n    /* start at root node */\n    cur_node = tsk_getu32(fs->endian, hfs->catalog_header.rootNode);\n\n    /* if the root node is zero, then the extents btree is empty */\n    /* if no files have overflow extents, the Extents B-tree still\n       exists on disk, but is an empty B-tree containing only\n       the header node */\n    if (cur_node == 0) {\n        if (tsk_verbose)\n            tsk_fprintf(stderr, \"hfs_cat_traverse: \"\n                \"empty extents btree\\n\");\n        free(node);\n        return 1;\n    }\n\n    if (tsk_verbose)\n        tsk_fprintf(stderr, \"hfs_cat_traverse: starting at \"\n            \"root node %\" PRIu32 \"; nodesize = %\"\n            PRIu16 \"\\n\", cur_node, nodesize);\n\n    /* Recurse down to the needed leaf nodes and then go forward */\n    is_done = 0;\n    while (is_done == 0) {\n        TSK_OFF_T cur_off;      /* start address of cur_node */\n        uint16_t num_rec;       /* number of records in this node */\n        ssize_t cnt;\n        hfs_btree_node *node_desc;\n\n        // sanity check\n        if (cur_node > tsk_getu32(fs->endian,\n                hfs->catalog_header.totalNodes)) {\n            tsk_error_set_errno(TSK_ERR_FS_GENFS);\n            tsk_error_set_errstr\n                (\"hfs_cat_traverse: Node %d too large for file\", cur_node);\n            free(node);\n            return 1;\n        }\n\n        // read the current node\n        cur_off = cur_node * nodesize;\n        cnt = tsk_fs_attr_read(hfs->catalog_attr, cur_off,\n            node, nodesize, 0);\n        if (cnt != nodesize) {\n            if (cnt >= 0) {\n                tsk_error_reset();\n                tsk_error_set_errno(TSK_ERR_FS_READ);\n            }\n            tsk_error_set_errstr2\n                (\"hfs_cat_traverse: Error reading node %d at offset %\"\n                PRIuOFF, cur_node, cur_off);\n            free(node);\n            return 1;\n        }\n\n        // process the header / descriptor\n        if (nodesize < sizeof(hfs_btree_node)) {\n            tsk_error_set_errno(TSK_ERR_FS_GENFS);\n            tsk_error_set_errstr\n            (\"hfs_cat_traverse: Node size %d is too small to be valid\", nodesize);\n            free(node);\n            return 1;\n        }\n        node_desc = (hfs_btree_node *) node;\n        num_rec = tsk_getu16(fs->endian, node_desc->num_rec);\n\n        if (tsk_verbose)\n            tsk_fprintf(stderr, \"hfs_cat_traverse: node %\" PRIu32\n                \" @ %\" PRIu64 \" has %\" PRIu16 \" records\\n\",\n                cur_node, cur_off, num_rec);\n\n        if (num_rec == 0) {\n            tsk_error_set_errno(TSK_ERR_FS_GENFS);\n            tsk_error_set_errstr(\"hfs_cat_traverse: zero records in node %\"\n                PRIu32, cur_node);\n            free(node);\n            return 1;\n        }\n\n        /* With an index node, find the record with the largest key that is smaller\n         * to or equal to cnid */\n        if (node_desc->type == HFS_BT_NODE_TYPE_IDX) {\n            uint32_t next_node = 0;\n            int rec;\n\n            for (rec = 0; rec < num_rec; ++rec) {\n                size_t rec_off;\n                hfs_btree_key_cat *key;\n                uint8_t retval;\n                uint16_t keylen;\n\n                // get the record offset in the node\n                rec_off =\n                    tsk_getu16(fs->endian,\n                    &node[nodesize - (rec + 1) * 2]);\n                if (rec_off > nodesize) {\n                    tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                    tsk_error_set_errstr\n                        (\"hfs_cat_traverse: offset of record %d in index node %d too large (%d vs %\"\n                        PRIu16 \")\", rec, cur_node, (int) rec_off,\n                        nodesize);\n                    free(node);\n                    return 1;\n                }\n\n                key = (hfs_btree_key_cat *) & node[rec_off];\n\n                keylen = 2 + tsk_getu16(hfs->fs_info.endian, key->key_len);\n                if ((keylen) > nodesize) {\n                    tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                    tsk_error_set_errstr\n                        (\"hfs_cat_traverse: length of key %d in index node %d too large (%d vs %\"\n                        PRIu16 \")\", rec, cur_node, keylen, nodesize);\n                    free(node);\n                    return 1;\n                }\n\n\n                /*\n                   if (tsk_verbose)\n                   tsk_fprintf(stderr,\n                   \"hfs_cat_traverse: record %\" PRIu16\n                   \" ; keylen %\" PRIu16 \" (%\" PRIu32 \")\\n\", rec,\n                   tsk_getu16(fs->endian, key->key_len),\n                   tsk_getu32(fs->endian, key->parent_cnid));\n                 */\n\n\n                /* save the info from this record unless it is too big */\n                retval =\n                    a_cb(hfs, HFS_BT_NODE_TYPE_IDX, key,\n                    cur_off + rec_off, ptr);\n                if (retval == HFS_BTREE_CB_ERR) {\n                    tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                    tsk_error_set_errstr2\n                        (\"hfs_cat_traverse: Callback returned error\");\n                    free(node);\n                    return 1;\n                }\n                // record the closest entry\n                else if ((retval == HFS_BTREE_CB_IDX_LT)\n                    || (next_node == 0)) {\n                    hfs_btree_index_record *idx_rec;\n                    int keylen =\n                        2 + hfs_get_idxkeylen(hfs, tsk_getu16(fs->endian,\n                            key->key_len), &(hfs->catalog_header));\n                    if (rec_off + keylen > nodesize) {\n                        tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                        tsk_error_set_errstr\n                            (\"hfs_cat_traverse: offset of record and keylength %d in index node %d too large (%d vs %\"\n                            PRIu16 \")\", rec, cur_node,\n                            (int) rec_off + keylen, nodesize);\n                        free(node);\n                        return 1;\n                    }\n                    idx_rec =\n                        (hfs_btree_index_record *) & node[rec_off +\n                        keylen];\n                    next_node = tsk_getu32(fs->endian, idx_rec->childNode);\n                }\n                if (retval == HFS_BTREE_CB_IDX_EQGT) {\n                    // move down to the next node\n                    break;\n                }\n            }\n            // check if we found a relevant node\n            if (next_node == 0) {\n                tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                tsk_error_set_errstr\n                    (\"hfs_cat_traverse: did not find any keys in index node %d\",\n                    cur_node);\n                is_done = 1;\n                break;\n            }\n            // TODO: Handle multinode loops\n            if (next_node == cur_node) {\n                tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                tsk_error_set_errstr\n                    (\"hfs_cat_traverse: node %d references itself as next node\",\n                    cur_node);\n                is_done = 1;\n                break;\n            }\n            cur_node = next_node;\n        }\n\n        /* With a leaf, we look for the specific record. */\n        else if (node_desc->type == HFS_BT_NODE_TYPE_LEAF) {\n            int rec;\n\n            for (rec = 0; rec < num_rec; ++rec) {\n                size_t rec_off;\n                hfs_btree_key_cat *key;\n                uint8_t retval;\n                uint16_t keylen;\n\n                // get the record offset in the node\n                rec_off =\n                    tsk_getu16(fs->endian,\n                    &node[nodesize - (rec + 1) * 2]);\n                if (rec_off > nodesize) {\n                    tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                    tsk_error_set_errstr\n                        (\"hfs_cat_traverse: offset of record %d in leaf node %d too large (%d vs %\"\n                        PRIu16 \")\", rec, cur_node, (int) rec_off,\n                        nodesize);\n                    free(node);\n                    return 1;\n                }\n                key = (hfs_btree_key_cat *) & node[rec_off];\n\n                keylen = 2 + tsk_getu16(hfs->fs_info.endian, key->key_len);\n                if ((keylen) > nodesize) {\n                    tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                    tsk_error_set_errstr\n                        (\"hfs_cat_traverse: length of key %d in leaf node %d too large (%d vs %\"\n                        PRIu16 \")\", rec, cur_node, keylen, nodesize);\n                    free(node);\n                    return 1;\n                }\n\n                /*\n                   if (tsk_verbose)\n                   tsk_fprintf(stderr,\n                   \"hfs_cat_traverse: record %\" PRIu16\n                   \"; keylen %\" PRIu16 \" (%\" PRIu32 \")\\n\", rec,\n                   tsk_getu16(fs->endian, key->key_len),\n                   tsk_getu32(fs->endian, key->parent_cnid));\n                 */\n                //                rec_cnid = tsk_getu32(fs->endian, key->file_id);\n\n                retval =\n                    a_cb(hfs, HFS_BT_NODE_TYPE_LEAF, key,\n                    cur_off + rec_off, ptr);\n                if (retval == HFS_BTREE_CB_LEAF_STOP) {\n                    is_done = 1;\n                    break;\n                }\n                else if (retval == HFS_BTREE_CB_ERR) {\n                    tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                    tsk_error_set_errstr2\n                        (\"hfs_cat_traverse: Callback returned error\");\n                    free(node);\n                    return 1;\n                }\n            }\n\n            // move right to the next node if we got this far\n            if (is_done == 0) {\n                cur_node = tsk_getu32(fs->endian, node_desc->flink);\n                if (cur_node == 0) {\n                    is_done = 1;\n                }\n                if (tsk_verbose)\n                    tsk_fprintf(stderr,\n                        \"hfs_cat_traverse: moving forward to next leaf\");\n            }\n        }\n        else {\n            tsk_error_set_errno(TSK_ERR_FS_GENFS);\n            tsk_error_set_errstr(\"hfs_cat_traverse: btree node %\" PRIu32\n                \" (%\" PRIu64 \") is neither index nor leaf (%\" PRIu8 \")\",\n                cur_node, cur_off, node_desc->type);\n            free(node);\n            return 1;\n        }\n    }\n    free(node);\n    return 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149802,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "hfs_cat_traverse(HFS_INFO * hfs,\n    TSK_HFS_BTREE_CB a_cb, void *ptr)\n{\n    TSK_FS_INFO *fs = &(hfs->fs_info);\n    uint32_t cur_node;          /* node id of the current node */\n    char *node;\n\n    uint16_t nodesize;\n    uint8_t is_done = 0;\n\n    tsk_error_reset();\n\n    nodesize = tsk_getu16(fs->endian, hfs->catalog_header.nodesize);\n    if ((node = (char *) tsk_malloc(nodesize)) == NULL)\n        return 1;\n\n    /* start at root node */\n    cur_node = tsk_getu32(fs->endian, hfs->catalog_header.rootNode);\n\n    /* if the root node is zero, then the extents btree is empty */\n    /* if no files have overflow extents, the Extents B-tree still\n       exists on disk, but is an empty B-tree containing only\n       the header node */\n    if (cur_node == 0) {\n        if (tsk_verbose)\n            tsk_fprintf(stderr, \"hfs_cat_traverse: \"\n                \"empty extents btree\\n\");\n        free(node);\n        return 1;\n    }\n\n    if (tsk_verbose)\n        tsk_fprintf(stderr, \"hfs_cat_traverse: starting at \"\n            \"root node %\" PRIu32 \"; nodesize = %\"\n            PRIu16 \"\\n\", cur_node, nodesize);\n\n    /* Recurse down to the needed leaf nodes and then go forward */\n    is_done = 0;\n    while (is_done == 0) {\n        TSK_OFF_T cur_off;      /* start address of cur_node */\n        uint16_t num_rec;       /* number of records in this node */\n        ssize_t cnt;\n        hfs_btree_node *node_desc;\n\n        // sanity check\n        if (cur_node > tsk_getu32(fs->endian,\n                hfs->catalog_header.totalNodes)) {\n            tsk_error_set_errno(TSK_ERR_FS_GENFS);\n            tsk_error_set_errstr\n                (\"hfs_cat_traverse: Node %d too large for file\", cur_node);\n            free(node);\n            return 1;\n        }\n\n        // read the current node\n        cur_off = cur_node * nodesize;\n        cnt = tsk_fs_attr_read(hfs->catalog_attr, cur_off,\n            node, nodesize, 0);\n        if (cnt != nodesize) {\n            if (cnt >= 0) {\n                tsk_error_reset();\n                tsk_error_set_errno(TSK_ERR_FS_READ);\n            }\n            tsk_error_set_errstr2\n                (\"hfs_cat_traverse: Error reading node %d at offset %\"\n                PRIuOFF, cur_node, cur_off);\n            free(node);\n            return 1;\n        }\n\n        // process the header / descriptor\n        if (nodesize < sizeof(hfs_btree_node)) {\n            tsk_error_set_errno(TSK_ERR_FS_GENFS);\n            tsk_error_set_errstr\n            (\"hfs_cat_traverse: Node size %d is too small to be valid\", nodesize);\n            free(node);\n            return 1;\n        }\n        node_desc = (hfs_btree_node *) node;\n        num_rec = tsk_getu16(fs->endian, node_desc->num_rec);\n\n        if (tsk_verbose)\n            tsk_fprintf(stderr, \"hfs_cat_traverse: node %\" PRIu32\n                \" @ %\" PRIu64 \" has %\" PRIu16 \" records\\n\",\n                cur_node, cur_off, num_rec);\n\n        if (num_rec == 0) {\n            tsk_error_set_errno(TSK_ERR_FS_GENFS);\n            tsk_error_set_errstr(\"hfs_cat_traverse: zero records in node %\"\n                PRIu32, cur_node);\n            free(node);\n            return 1;\n        }\n\n        /* With an index node, find the record with the largest key that is smaller\n         * to or equal to cnid */\n        if (node_desc->type == HFS_BT_NODE_TYPE_IDX) {\n            uint32_t next_node = 0;\n            int rec;\n\n            for (rec = 0; rec < num_rec; ++rec) {\n                size_t rec_off;\n                hfs_btree_key_cat *key;\n                uint8_t retval;\n                int keylen;\n\n                // get the record offset in the node\n                rec_off =\n                    tsk_getu16(fs->endian,\n                    &node[nodesize - (rec + 1) * 2]);\n                if (rec_off > nodesize) {\n                    tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                    tsk_error_set_errstr\n                        (\"hfs_cat_traverse: offset of record %d in index node %d too large (%d vs %\"\n                        PRIu16 \")\", rec, cur_node, (int) rec_off,\n                        nodesize);\n                    free(node);\n                    return 1;\n                }\n\n                key = (hfs_btree_key_cat *) & node[rec_off];\n\n                keylen = 2 + tsk_getu16(hfs->fs_info.endian, key->key_len);\n                if ((keylen) > nodesize) {\n                    tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                    tsk_error_set_errstr\n                        (\"hfs_cat_traverse: length of key %d in index node %d too large (%d vs %\"\n                        PRIu16 \")\", rec, cur_node, keylen, nodesize);\n                    free(node);\n                    return 1;\n                }\n\n\n                /*\n                   if (tsk_verbose)\n                   tsk_fprintf(stderr,\n                   \"hfs_cat_traverse: record %\" PRIu16\n                   \" ; keylen %\" PRIu16 \" (%\" PRIu32 \")\\n\", rec,\n                   tsk_getu16(fs->endian, key->key_len),\n                   tsk_getu32(fs->endian, key->parent_cnid));\n                 */\n\n\n                /* save the info from this record unless it is too big */\n                retval =\n                    a_cb(hfs, HFS_BT_NODE_TYPE_IDX, key,\n                    cur_off + rec_off, ptr);\n                if (retval == HFS_BTREE_CB_ERR) {\n                    tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                    tsk_error_set_errstr2\n                        (\"hfs_cat_traverse: Callback returned error\");\n                    free(node);\n                    return 1;\n                }\n                // record the closest entry\n                else if ((retval == HFS_BTREE_CB_IDX_LT)\n                    || (next_node == 0)) {\n                    hfs_btree_index_record *idx_rec;\n                    int keylen =\n                        2 + hfs_get_idxkeylen(hfs, tsk_getu16(fs->endian,\n                            key->key_len), &(hfs->catalog_header));\n                    if (rec_off + keylen > nodesize) {\n                        tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                        tsk_error_set_errstr\n                            (\"hfs_cat_traverse: offset of record and keylength %d in index node %d too large (%d vs %\"\n                            PRIu16 \")\", rec, cur_node,\n                            (int) rec_off + keylen, nodesize);\n                        free(node);\n                        return 1;\n                    }\n                    idx_rec =\n                        (hfs_btree_index_record *) & node[rec_off +\n                        keylen];\n                    next_node = tsk_getu32(fs->endian, idx_rec->childNode);\n                }\n                if (retval == HFS_BTREE_CB_IDX_EQGT) {\n                    // move down to the next node\n                    break;\n                }\n            }\n            // check if we found a relevant node\n            if (next_node == 0) {\n                tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                tsk_error_set_errstr\n                    (\"hfs_cat_traverse: did not find any keys in index node %d\",\n                    cur_node);\n                is_done = 1;\n                break;\n            }\n            // TODO: Handle multinode loops\n            if (next_node == cur_node) {\n                tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                tsk_error_set_errstr\n                    (\"hfs_cat_traverse: node %d references itself as next node\",\n                    cur_node);\n                is_done = 1;\n                break;\n            }\n            cur_node = next_node;\n        }\n\n        /* With a leaf, we look for the specific record. */\n        else if (node_desc->type == HFS_BT_NODE_TYPE_LEAF) {\n            int rec;\n\n            for (rec = 0; rec < num_rec; ++rec) {\n                size_t rec_off;\n                hfs_btree_key_cat *key;\n                uint8_t retval;\n                int keylen;\n\n                // get the record offset in the node\n                rec_off =\n                    tsk_getu16(fs->endian,\n                    &node[nodesize - (rec + 1) * 2]);\n                if (rec_off > nodesize) {\n                    tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                    tsk_error_set_errstr\n                        (\"hfs_cat_traverse: offset of record %d in leaf node %d too large (%d vs %\"\n                        PRIu16 \")\", rec, cur_node, (int) rec_off,\n                        nodesize);\n                    free(node);\n                    return 1;\n                }\n                key = (hfs_btree_key_cat *) & node[rec_off];\n\n                keylen = 2 + tsk_getu16(hfs->fs_info.endian, key->key_len);\n                if ((keylen) > nodesize) {\n                    tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                    tsk_error_set_errstr\n                        (\"hfs_cat_traverse: length of key %d in leaf node %d too large (%d vs %\"\n                        PRIu16 \")\", rec, cur_node, keylen, nodesize);\n                    free(node);\n                    return 1;\n                }\n\n                /*\n                   if (tsk_verbose)\n                   tsk_fprintf(stderr,\n                   \"hfs_cat_traverse: record %\" PRIu16\n                   \"; keylen %\" PRIu16 \" (%\" PRIu32 \")\\n\", rec,\n                   tsk_getu16(fs->endian, key->key_len),\n                   tsk_getu32(fs->endian, key->parent_cnid));\n                 */\n                //                rec_cnid = tsk_getu32(fs->endian, key->file_id);\n\n                retval =\n                    a_cb(hfs, HFS_BT_NODE_TYPE_LEAF, key,\n                    cur_off + rec_off, ptr);\n                if (retval == HFS_BTREE_CB_LEAF_STOP) {\n                    is_done = 1;\n                    break;\n                }\n                else if (retval == HFS_BTREE_CB_ERR) {\n                    tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                    tsk_error_set_errstr2\n                        (\"hfs_cat_traverse: Callback returned error\");\n                    free(node);\n                    return 1;\n                }\n            }\n\n            // move right to the next node if we got this far\n            if (is_done == 0) {\n                cur_node = tsk_getu32(fs->endian, node_desc->flink);\n                if (cur_node == 0) {\n                    is_done = 1;\n                }\n                if (tsk_verbose)\n                    tsk_fprintf(stderr,\n                        \"hfs_cat_traverse: moving forward to next leaf\");\n            }\n        }\n        else {\n            tsk_error_set_errno(TSK_ERR_FS_GENFS);\n            tsk_error_set_errstr(\"hfs_cat_traverse: btree node %\" PRIu32\n                \" (%\" PRIu64 \") is neither index nor leaf (%\" PRIu8 \")\",\n                cur_node, cur_off, node_desc->type);\n            free(node);\n            return 1;\n        }\n    }\n    free(node);\n    return 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149803,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "PyImaging_MapBuffer(PyObject* self, PyObject* args)\n{\n    Py_ssize_t y, size;\n    Imaging im;\n\n    PyObject* target;\n    Py_buffer view;\n    char* mode;\n    char* codec;\n    PyObject* bbox;\n    Py_ssize_t offset;\n    int xsize, ysize;\n    int stride;\n    int ystep;\n\n    if (!PyArg_ParseTuple(args, \"O(ii)sOn(sii)\", &target, &xsize, &ysize,\n                          &codec, &bbox, &offset, &mode, &stride, &ystep))\n        return NULL;\n\n    if (!PyImaging_CheckBuffer(target)) {\n        PyErr_SetString(PyExc_TypeError, \"expected string or buffer\");\n        return NULL;\n    }\n\n    if (stride <= 0) {\n        if (!strcmp(mode, \"L\") || !strcmp(mode, \"P\"))\n            stride = xsize;\n        else if (!strncmp(mode, \"I;16\", 4))\n            stride = xsize * 2;\n        else\n            stride = xsize * 4;\n    }\n\n    size = (Py_ssize_t) ysize * stride;\n\n    /* check buffer size */\n    if (PyImaging_GetBuffer(target, &view) < 0)\n        return NULL;\n\n    if (view.len < 0) {\n        PyErr_SetString(PyExc_ValueError, \"buffer has negative size\");\n        return NULL;\n    }\n    if (offset + size > view.len) {\n        PyErr_SetString(PyExc_ValueError, \"buffer is not large enough\");\n        return NULL;\n    }\n\n    im = ImagingNewPrologueSubtype(\n        mode, xsize, ysize, sizeof(ImagingBufferInstance)\n        );\n    if (!im)\n        return NULL;\n\n    /* setup file pointers */\n    if (ystep > 0)\n        for (y = 0; y < ysize; y++)\n            im->image[y] = (char*)view.buf + offset + y * stride;\n    else\n        for (y = 0; y < ysize; y++)\n            im->image[ysize-y-1] = (char*)view.buf + offset + y * stride;\n\n    im->destroy = mapping_destroy_buffer;\n\n    Py_INCREF(target);\n    ((ImagingBufferInstance*) im)->target = target;\n    ((ImagingBufferInstance*) im)->view = view;\n\n    if (!ImagingNewEpilogue(im))\n        return NULL;\n\n    return PyImagingNew(im);\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149804,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "PyImaging_MapBuffer(PyObject* self, PyObject* args)\n{\n    Py_ssize_t y, size;\n    Imaging im;\n\n    PyObject* target;\n    Py_buffer view;\n    char* mode;\n    char* codec;\n    PyObject* bbox;\n    Py_ssize_t offset;\n    int xsize, ysize;\n    int stride;\n    int ystep;\n\n    if (!PyArg_ParseTuple(args, \"O(ii)sOn(sii)\", &target, &xsize, &ysize,\n                          &codec, &bbox, &offset, &mode, &stride, &ystep))\n        return NULL;\n\n    if (!PyImaging_CheckBuffer(target)) {\n        PyErr_SetString(PyExc_TypeError, \"expected string or buffer\");\n        return NULL;\n    }\n\n    if (stride <= 0) {\n        if (!strcmp(mode, \"L\") || !strcmp(mode, \"P\"))\n            stride = xsize;\n        else if (!strncmp(mode, \"I;16\", 4))\n            stride = xsize * 2;\n        else\n            stride = xsize * 4;\n    }\n\n    if (ysize > INT_MAX / stride) {\n        PyErr_SetString(PyExc_MemoryError, \"Integer overflow in ysize\");\n        return NULL;\n    }\n\n    size = (Py_ssize_t) ysize * stride;\n\n    if (offset > SIZE_MAX - size) {\n        PyErr_SetString(PyExc_MemoryError, \"Integer overflow in offset\");\n        return NULL;\n    }        \n\n    /* check buffer size */\n    if (PyImaging_GetBuffer(target, &view) < 0)\n        return NULL;\n\n    if (view.len < 0) {\n        PyErr_SetString(PyExc_ValueError, \"buffer has negative size\");\n        return NULL;\n    }\n    if (offset + size > view.len) {\n        PyErr_SetString(PyExc_ValueError, \"buffer is not large enough\");\n        return NULL;\n    }\n\n    im = ImagingNewPrologueSubtype(\n        mode, xsize, ysize, sizeof(ImagingBufferInstance)\n        );\n    if (!im)\n        return NULL;\n\n    /* setup file pointers */\n    if (ystep > 0)\n        for (y = 0; y < ysize; y++)\n            im->image[y] = (char*)view.buf + offset + y * stride;\n    else\n        for (y = 0; y < ysize; y++)\n            im->image[ysize-y-1] = (char*)view.buf + offset + y * stride;\n\n    im->destroy = mapping_destroy_buffer;\n\n    Py_INCREF(target);\n    ((ImagingBufferInstance*) im)->target = target;\n    ((ImagingBufferInstance*) im)->view = view;\n\n    if (!ImagingNewEpilogue(im))\n        return NULL;\n\n    return PyImagingNew(im);\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149805,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static int read_entry(\n\tgit_index_entry **out,\n\tsize_t *out_size,\n\tgit_index *index,\n\tconst void *buffer,\n\tsize_t buffer_size,\n\tconst char *last)\n{\n\tsize_t path_length, entry_size;\n\tconst char *path_ptr;\n\tstruct entry_short source;\n\tgit_index_entry entry = {{0}};\n\tbool compressed = index->version >= INDEX_VERSION_NUMBER_COMP;\n\tchar *tmp_path = NULL;\n\n\tif (INDEX_FOOTER_SIZE + minimal_entry_size > buffer_size)\n\t\treturn -1;\n\n\t/* buffer is not guaranteed to be aligned */\n\tmemcpy(&source, buffer, sizeof(struct entry_short));\n\n\tentry.ctime.seconds = (git_time_t)ntohl(source.ctime.seconds);\n\tentry.ctime.nanoseconds = ntohl(source.ctime.nanoseconds);\n\tentry.mtime.seconds = (git_time_t)ntohl(source.mtime.seconds);\n\tentry.mtime.nanoseconds = ntohl(source.mtime.nanoseconds);\n\tentry.dev = ntohl(source.dev);\n\tentry.ino = ntohl(source.ino);\n\tentry.mode = ntohl(source.mode);\n\tentry.uid = ntohl(source.uid);\n\tentry.gid = ntohl(source.gid);\n\tentry.file_size = ntohl(source.file_size);\n\tgit_oid_cpy(&entry.id, &source.oid);\n\tentry.flags = ntohs(source.flags);\n\n\tif (entry.flags & GIT_IDXENTRY_EXTENDED) {\n\t\tuint16_t flags_raw;\n\t\tsize_t flags_offset;\n\n\t\tflags_offset = offsetof(struct entry_long, flags_extended);\n\t\tmemcpy(&flags_raw, (const char *) buffer + flags_offset,\n\t\t\tsizeof(flags_raw));\n\t\tflags_raw = ntohs(flags_raw);\n\n\t\tmemcpy(&entry.flags_extended, &flags_raw, sizeof(flags_raw));\n\t\tpath_ptr = (const char *) buffer + offsetof(struct entry_long, path);\n\t} else\n\t\tpath_ptr = (const char *) buffer + offsetof(struct entry_short, path);\n\n\tif (!compressed) {\n\t\tpath_length = entry.flags & GIT_IDXENTRY_NAMEMASK;\n\n\t\t/* if this is a very long string, we must find its\n\t\t * real length without overflowing */\n\t\tif (path_length == 0xFFF) {\n\t\t\tconst char *path_end;\n\n\t\t\tpath_end = memchr(path_ptr, '\\0', buffer_size);\n\t\t\tif (path_end == NULL)\n\t\t\t\treturn -1;\n\n\t\t\tpath_length = path_end - path_ptr;\n\t\t}\n\n\t\tentry_size = index_entry_size(path_length, 0, entry.flags);\n\t\tentry.path = (char *)path_ptr;\n\t} else {\n\t\tsize_t varint_len;\n\t\tsize_t strip_len = git_decode_varint((const unsigned char *)path_ptr,\n\t\t\t\t\t\t     &varint_len);\n\t\tsize_t last_len = strlen(last);\n\t\tsize_t prefix_len = last_len - strip_len;\n\t\tsize_t suffix_len = strlen(path_ptr + varint_len);\n\t\tsize_t path_len;\n\n\t\tif (varint_len == 0)\n\t\t\treturn index_error_invalid(\"incorrect prefix length\");\n\n\t\tGITERR_CHECK_ALLOC_ADD(&path_len, prefix_len, suffix_len);\n\t\tGITERR_CHECK_ALLOC_ADD(&path_len, path_len, 1);\n\t\ttmp_path = git__malloc(path_len);\n\t\tGITERR_CHECK_ALLOC(tmp_path);\n\n\t\tmemcpy(tmp_path, last, prefix_len);\n\t\tmemcpy(tmp_path + prefix_len, path_ptr + varint_len, suffix_len + 1);\n\t\tentry_size = index_entry_size(suffix_len, varint_len, entry.flags);\n\t\tentry.path = tmp_path;\n\t}\n\n\tif (entry_size == 0)\n\t\treturn -1;\n\n\tif (INDEX_FOOTER_SIZE + entry_size > buffer_size)\n\t\treturn -1;\n\n\tif (index_entry_dup(out, index, &entry) < 0) {\n\t\tgit__free(tmp_path);\n\t\treturn -1;\n\t}\n\n\tgit__free(tmp_path);\n\t*out_size = entry_size;\n\treturn 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149806,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static int read_entry(\n\tgit_index_entry **out,\n\tsize_t *out_size,\n\tgit_index *index,\n\tconst void *buffer,\n\tsize_t buffer_size,\n\tconst char *last)\n{\n\tsize_t path_length, entry_size;\n\tconst char *path_ptr;\n\tstruct entry_short source;\n\tgit_index_entry entry = {{0}};\n\tbool compressed = index->version >= INDEX_VERSION_NUMBER_COMP;\n\tchar *tmp_path = NULL;\n\n\tif (INDEX_FOOTER_SIZE + minimal_entry_size > buffer_size)\n\t\treturn -1;\n\n\t/* buffer is not guaranteed to be aligned */\n\tmemcpy(&source, buffer, sizeof(struct entry_short));\n\n\tentry.ctime.seconds = (git_time_t)ntohl(source.ctime.seconds);\n\tentry.ctime.nanoseconds = ntohl(source.ctime.nanoseconds);\n\tentry.mtime.seconds = (git_time_t)ntohl(source.mtime.seconds);\n\tentry.mtime.nanoseconds = ntohl(source.mtime.nanoseconds);\n\tentry.dev = ntohl(source.dev);\n\tentry.ino = ntohl(source.ino);\n\tentry.mode = ntohl(source.mode);\n\tentry.uid = ntohl(source.uid);\n\tentry.gid = ntohl(source.gid);\n\tentry.file_size = ntohl(source.file_size);\n\tgit_oid_cpy(&entry.id, &source.oid);\n\tentry.flags = ntohs(source.flags);\n\n\tif (entry.flags & GIT_IDXENTRY_EXTENDED) {\n\t\tuint16_t flags_raw;\n\t\tsize_t flags_offset;\n\n\t\tflags_offset = offsetof(struct entry_long, flags_extended);\n\t\tmemcpy(&flags_raw, (const char *) buffer + flags_offset,\n\t\t\tsizeof(flags_raw));\n\t\tflags_raw = ntohs(flags_raw);\n\n\t\tmemcpy(&entry.flags_extended, &flags_raw, sizeof(flags_raw));\n\t\tpath_ptr = (const char *) buffer + offsetof(struct entry_long, path);\n\t} else\n\t\tpath_ptr = (const char *) buffer + offsetof(struct entry_short, path);\n\n\tif (!compressed) {\n\t\tpath_length = entry.flags & GIT_IDXENTRY_NAMEMASK;\n\n\t\t/* if this is a very long string, we must find its\n\t\t * real length without overflowing */\n\t\tif (path_length == 0xFFF) {\n\t\t\tconst char *path_end;\n\n\t\t\tpath_end = memchr(path_ptr, '\\0', buffer_size);\n\t\t\tif (path_end == NULL)\n\t\t\t\treturn -1;\n\n\t\t\tpath_length = path_end - path_ptr;\n\t\t}\n\n\t\tentry_size = index_entry_size(path_length, 0, entry.flags);\n\t\tentry.path = (char *)path_ptr;\n\t} else {\n\t\tsize_t varint_len, last_len, prefix_len, suffix_len, path_len;\n\t\tuintmax_t strip_len;\n\n\t\tstrip_len = git_decode_varint((const unsigned char *)path_ptr, &varint_len);\n\t\tlast_len = strlen(last);\n\n\t\tif (varint_len == 0 || last_len < strip_len)\n\t\t\treturn index_error_invalid(\"incorrect prefix length\");\n\n\t\tprefix_len = last_len - strip_len;\n\t\tsuffix_len = strlen(path_ptr + varint_len);\n\n\t\tGITERR_CHECK_ALLOC_ADD(&path_len, prefix_len, suffix_len);\n\t\tGITERR_CHECK_ALLOC_ADD(&path_len, path_len, 1);\n\t\ttmp_path = git__malloc(path_len);\n\t\tGITERR_CHECK_ALLOC(tmp_path);\n\n\t\tmemcpy(tmp_path, last, prefix_len);\n\t\tmemcpy(tmp_path + prefix_len, path_ptr + varint_len, suffix_len + 1);\n\t\tentry_size = index_entry_size(suffix_len, varint_len, entry.flags);\n\t\tentry.path = tmp_path;\n\t}\n\n\tif (entry_size == 0)\n\t\treturn -1;\n\n\tif (INDEX_FOOTER_SIZE + entry_size > buffer_size)\n\t\treturn -1;\n\n\tif (index_entry_dup(out, index, &entry) < 0) {\n\t\tgit__free(tmp_path);\n\t\treturn -1;\n\t}\n\n\tgit__free(tmp_path);\n\t*out_size = entry_size;\n\treturn 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149807,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "read_SubStreamsInfo(struct archive_read *a, struct _7z_substream_info *ss,\n    struct _7z_folder *f, size_t numFolders)\n{\n\tconst unsigned char *p;\n\tuint64_t *usizes;\n\tsize_t unpack_streams;\n\tint type;\n\tunsigned i;\n\tuint32_t numDigests;\n\n\tmemset(ss, 0, sizeof(*ss));\n\n\tfor (i = 0; i < numFolders; i++)\n\t\tf[i].numUnpackStreams = 1;\n\n\tif ((p = header_bytes(a, 1)) == NULL)\n\t\treturn (-1);\n\ttype = *p;\n\n\tif (type == kNumUnPackStream) {\n\t\tunpack_streams = 0;\n\t\tfor (i = 0; i < numFolders; i++) {\n\t\t\tif (parse_7zip_uint64(a, &(f[i].numUnpackStreams)) < 0)\n\t\t\t\treturn (-1);\n\t\t\tif (UMAX_ENTRY < f[i].numUnpackStreams)\n\t\t\t\treturn (-1);\n\t\t\tunpack_streams += (size_t)f[i].numUnpackStreams;\n\t\t}\n\t\tif ((p = header_bytes(a, 1)) == NULL)\n\t\t\treturn (-1);\n\t\ttype = *p;\n\t} else\n\t\tunpack_streams = numFolders;\n\n\tss->unpack_streams = unpack_streams;\n\tif (unpack_streams) {\n\t\tss->unpackSizes = calloc(unpack_streams,\n\t\t    sizeof(*ss->unpackSizes));\n\t\tss->digestsDefined = calloc(unpack_streams,\n\t\t    sizeof(*ss->digestsDefined));\n\t\tss->digests = calloc(unpack_streams,\n\t\t    sizeof(*ss->digests));\n\t\tif (ss->unpackSizes == NULL || ss->digestsDefined == NULL ||\n\t\t    ss->digests == NULL)\n\t\t\treturn (-1);\n\t}\n\n\tusizes = ss->unpackSizes;\n\tfor (i = 0; i < numFolders; i++) {\n\t\tunsigned pack;\n\t\tuint64_t sum;\n\n\t\tif (f[i].numUnpackStreams == 0)\n\t\t\tcontinue;\n\n\t\tsum = 0;\n\t\tif (type == kSize) {\n\t\t\tfor (pack = 1; pack < f[i].numUnpackStreams; pack++) {\n\t\t\t\tif (parse_7zip_uint64(a, usizes) < 0)\n\t\t\t\t\treturn (-1);\n\t\t\t\tsum += *usizes++;\n\t\t\t}\n\t\t}\n\t\t*usizes++ = folder_uncompressed_size(&f[i]) - sum;\n\t}\n\n\tif (type == kSize) {\n\t\tif ((p = header_bytes(a, 1)) == NULL)\n\t\t\treturn (-1);\n\t\ttype = *p;\n\t}\n\n\tfor (i = 0; i < unpack_streams; i++) {\n\t\tss->digestsDefined[i] = 0;\n\t\tss->digests[i] = 0;\n\t}\n\n\tnumDigests = 0;\n\tfor (i = 0; i < numFolders; i++) {\n\t\tif (f[i].numUnpackStreams != 1 || !f[i].digest_defined)\n\t\t\tnumDigests += (uint32_t)f[i].numUnpackStreams;\n\t}\n\n\tif (type == kCRC) {\n\t\tstruct _7z_digests tmpDigests;\n\t\tunsigned char *digestsDefined = ss->digestsDefined;\n\t\tuint32_t * digests = ss->digests;\n\t\tint di = 0;\n\n\t\tmemset(&tmpDigests, 0, sizeof(tmpDigests));\n\t\tif (read_Digests(a, &(tmpDigests), numDigests) < 0) {\n\t\t\tfree_Digest(&tmpDigests);\n\t\t\treturn (-1);\n\t\t}\n\t\tfor (i = 0; i < numFolders; i++) {\n\t\t\tif (f[i].numUnpackStreams == 1 && f[i].digest_defined) {\n\t\t\t\t*digestsDefined++ = 1;\n\t\t\t\t*digests++ = f[i].digest;\n\t\t\t} else {\n\t\t\t\tunsigned j;\n\n\t\t\t\tfor (j = 0; j < f[i].numUnpackStreams;\n\t\t\t\t    j++, di++) {\n\t\t\t\t\t*digestsDefined++ =\n\t\t\t\t\t    tmpDigests.defineds[di];\n\t\t\t\t\t*digests++ =\n\t\t\t\t\t    tmpDigests.digests[di];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfree_Digest(&tmpDigests);\n\t\tif ((p = header_bytes(a, 1)) == NULL)\n\t\t\treturn (-1);\n\t\ttype = *p;\n\t}\n\n\t/*\n\t *  Must be kEnd.\n\t */\n\tif (type != kEnd)\n\t\treturn (-1);\n\treturn (0);\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149808,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "read_SubStreamsInfo(struct archive_read *a, struct _7z_substream_info *ss,\n    struct _7z_folder *f, size_t numFolders)\n{\n\tconst unsigned char *p;\n\tuint64_t *usizes;\n\tsize_t unpack_streams;\n\tint type;\n\tunsigned i;\n\tuint32_t numDigests;\n\n\tmemset(ss, 0, sizeof(*ss));\n\n\tfor (i = 0; i < numFolders; i++)\n\t\tf[i].numUnpackStreams = 1;\n\n\tif ((p = header_bytes(a, 1)) == NULL)\n\t\treturn (-1);\n\ttype = *p;\n\n\tif (type == kNumUnPackStream) {\n\t\tunpack_streams = 0;\n\t\tfor (i = 0; i < numFolders; i++) {\n\t\t\tif (parse_7zip_uint64(a, &(f[i].numUnpackStreams)) < 0)\n\t\t\t\treturn (-1);\n\t\t\tif (UMAX_ENTRY < f[i].numUnpackStreams)\n\t\t\t\treturn (-1);\n\t\t\tif (unpack_streams > SIZE_MAX - UMAX_ENTRY) {\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\tunpack_streams += (size_t)f[i].numUnpackStreams;\n\t\t}\n\t\tif ((p = header_bytes(a, 1)) == NULL)\n\t\t\treturn (-1);\n\t\ttype = *p;\n\t} else\n\t\tunpack_streams = numFolders;\n\n\tss->unpack_streams = unpack_streams;\n\tif (unpack_streams) {\n\t\tss->unpackSizes = calloc(unpack_streams,\n\t\t    sizeof(*ss->unpackSizes));\n\t\tss->digestsDefined = calloc(unpack_streams,\n\t\t    sizeof(*ss->digestsDefined));\n\t\tss->digests = calloc(unpack_streams,\n\t\t    sizeof(*ss->digests));\n\t\tif (ss->unpackSizes == NULL || ss->digestsDefined == NULL ||\n\t\t    ss->digests == NULL)\n\t\t\treturn (-1);\n\t}\n\n\tusizes = ss->unpackSizes;\n\tfor (i = 0; i < numFolders; i++) {\n\t\tunsigned pack;\n\t\tuint64_t sum;\n\n\t\tif (f[i].numUnpackStreams == 0)\n\t\t\tcontinue;\n\n\t\tsum = 0;\n\t\tif (type == kSize) {\n\t\t\tfor (pack = 1; pack < f[i].numUnpackStreams; pack++) {\n\t\t\t\tif (parse_7zip_uint64(a, usizes) < 0)\n\t\t\t\t\treturn (-1);\n\t\t\t\tsum += *usizes++;\n\t\t\t}\n\t\t}\n\t\t*usizes++ = folder_uncompressed_size(&f[i]) - sum;\n\t}\n\n\tif (type == kSize) {\n\t\tif ((p = header_bytes(a, 1)) == NULL)\n\t\t\treturn (-1);\n\t\ttype = *p;\n\t}\n\n\tfor (i = 0; i < unpack_streams; i++) {\n\t\tss->digestsDefined[i] = 0;\n\t\tss->digests[i] = 0;\n\t}\n\n\tnumDigests = 0;\n\tfor (i = 0; i < numFolders; i++) {\n\t\tif (f[i].numUnpackStreams != 1 || !f[i].digest_defined)\n\t\t\tnumDigests += (uint32_t)f[i].numUnpackStreams;\n\t}\n\n\tif (type == kCRC) {\n\t\tstruct _7z_digests tmpDigests;\n\t\tunsigned char *digestsDefined = ss->digestsDefined;\n\t\tuint32_t * digests = ss->digests;\n\t\tint di = 0;\n\n\t\tmemset(&tmpDigests, 0, sizeof(tmpDigests));\n\t\tif (read_Digests(a, &(tmpDigests), numDigests) < 0) {\n\t\t\tfree_Digest(&tmpDigests);\n\t\t\treturn (-1);\n\t\t}\n\t\tfor (i = 0; i < numFolders; i++) {\n\t\t\tif (f[i].numUnpackStreams == 1 && f[i].digest_defined) {\n\t\t\t\t*digestsDefined++ = 1;\n\t\t\t\t*digests++ = f[i].digest;\n\t\t\t} else {\n\t\t\t\tunsigned j;\n\n\t\t\t\tfor (j = 0; j < f[i].numUnpackStreams;\n\t\t\t\t    j++, di++) {\n\t\t\t\t\t*digestsDefined++ =\n\t\t\t\t\t    tmpDigests.defineds[di];\n\t\t\t\t\t*digests++ =\n\t\t\t\t\t    tmpDigests.digests[di];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfree_Digest(&tmpDigests);\n\t\tif ((p = header_bytes(a, 1)) == NULL)\n\t\t\treturn (-1);\n\t\ttype = *p;\n\t}\n\n\t/*\n\t *  Must be kEnd.\n\t */\n\tif (type != kEnd)\n\t\treturn (-1);\n\treturn (0);\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149809,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static BOOL gdi_Bitmap_Decompress(rdpContext* context, rdpBitmap* bitmap,\n                                  const BYTE* pSrcData, UINT32 DstWidth, UINT32 DstHeight,\n                                  UINT32 bpp, UINT32 length, BOOL compressed,\n                                  UINT32 codecId)\n{\n\tUINT32 SrcSize = length;\n\trdpGdi* gdi = context->gdi;\n\tbitmap->compressed = FALSE;\n\tbitmap->format = gdi->dstFormat;\n\tbitmap->length = DstWidth * DstHeight * GetBytesPerPixel(bitmap->format);\n\tbitmap->data = (BYTE*) _aligned_malloc(bitmap->length, 16);\n\n\tif (!bitmap->data)\n\t\treturn FALSE;\n\n\tif (compressed)\n\t{\n\t\tif (bpp < 32)\n\t\t{\n\t\t\tif (!interleaved_decompress(context->codecs->interleaved,\n\t\t\t                            pSrcData, SrcSize,\n\t\t\t                            DstWidth, DstHeight,\n\t\t\t                            bpp,\n\t\t\t                            bitmap->data, bitmap->format,\n\t\t\t                            0, 0, 0, DstWidth, DstHeight,\n\t\t\t                            &gdi->palette))\n\t\t\t\treturn FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!planar_decompress(context->codecs->planar, pSrcData, SrcSize,\n\t\t\t                       DstWidth, DstHeight,\n\t\t\t                       bitmap->data, bitmap->format, 0, 0, 0,\n\t\t\t                       DstWidth, DstHeight, TRUE))\n\t\t\t\treturn FALSE;\n\t\t}\n\t}\n\telse\n\t{\n\t\tconst UINT32 SrcFormat = gdi_get_pixel_format(bpp);\n\t\tconst size_t sbpp = GetBytesPerPixel(SrcFormat);\n\t\tconst size_t dbpp = GetBytesPerPixel(bitmap->format);\n\n\t\tif ((sbpp == 0) || (dbpp == 0))\n\t\t\treturn FALSE;\n\t\telse\n\t\t{\n\t\t\tconst size_t dstSize = SrcSize * dbpp / sbpp;\n\n\t\t\tif (dstSize  < bitmap->length)\n\t\t\t\treturn FALSE;\n\t\t}\n\n\t\tif (!freerdp_image_copy(bitmap->data, bitmap->format, 0, 0, 0,\n\t\t                        DstWidth, DstHeight, pSrcData, SrcFormat,\n\t\t                        0, 0, 0, &gdi->palette, FREERDP_FLIP_VERTICAL))\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149810,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static BOOL gdi_Bitmap_Decompress(rdpContext* context, rdpBitmap* bitmap,\n                                  const BYTE* pSrcData, UINT32 DstWidth, UINT32 DstHeight,\n                                  UINT32 bpp, UINT32 length, BOOL compressed,\n                                  UINT32 codecId)\n{\n\tUINT32 SrcSize = length;\n\trdpGdi* gdi = context->gdi;\n\tUINT32 size = DstWidth * DstHeight;\n\tbitmap->compressed = FALSE;\n\tbitmap->format = gdi->dstFormat;\n\n\tif ((GetBytesPerPixel(bitmap->format) == 0) ||\n\t    (DstWidth == 0) || (DstHeight == 0) || (DstWidth > UINT32_MAX / DstHeight) ||\n\t    (size > (UINT32_MAX / GetBytesPerPixel(bitmap->format))))\n\t\treturn FALSE;\n\n\tsize *= GetBytesPerPixel(bitmap->format);\n\tbitmap->length = size;\n\tbitmap->data = (BYTE*) _aligned_malloc(bitmap->length, 16);\n\n\tif (!bitmap->data)\n\t\treturn FALSE;\n\n\tif (compressed)\n\t{\n\t\tif (bpp < 32)\n\t\t{\n\t\t\tif (!interleaved_decompress(context->codecs->interleaved,\n\t\t\t                            pSrcData, SrcSize,\n\t\t\t                            DstWidth, DstHeight,\n\t\t\t                            bpp,\n\t\t\t                            bitmap->data, bitmap->format,\n\t\t\t                            0, 0, 0, DstWidth, DstHeight,\n\t\t\t                            &gdi->palette))\n\t\t\t\treturn FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!planar_decompress(context->codecs->planar, pSrcData, SrcSize,\n\t\t\t                       DstWidth, DstHeight,\n\t\t\t                       bitmap->data, bitmap->format, 0, 0, 0,\n\t\t\t                       DstWidth, DstHeight, TRUE))\n\t\t\t\treturn FALSE;\n\t\t}\n\t}\n\telse\n\t{\n\t\tconst UINT32 SrcFormat = gdi_get_pixel_format(bpp);\n\t\tconst size_t sbpp = GetBytesPerPixel(SrcFormat);\n\t\tconst size_t dbpp = GetBytesPerPixel(bitmap->format);\n\n\t\tif ((sbpp == 0) || (dbpp == 0))\n\t\t\treturn FALSE;\n\t\telse\n\t\t{\n\t\t\tconst size_t dstSize = SrcSize * dbpp / sbpp;\n\n\t\t\tif (dstSize  < bitmap->length)\n\t\t\t\treturn FALSE;\n\t\t}\n\n\t\tif (!freerdp_image_copy(bitmap->data, bitmap->format, 0, 0, 0,\n\t\t                        DstWidth, DstHeight, pSrcData, SrcFormat,\n\t\t                        0, 0, 0, &gdi->palette, FREERDP_FLIP_VERTICAL))\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149811,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "SWFInput_readSBits(SWFInput input, int number)\n{\n\tint num = SWFInput_readBits(input, number);\n\n\tif ( num & (1<<(number-1)) )\n\t\treturn num - (1<<number);\n\telse\n\t\treturn num;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149812,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "SWFInput_readSBits(SWFInput input, int number)\n{\n\tint num = SWFInput_readBits(input, number);\n\n\tif(number && num & (1<<(number-1)))\n\t\treturn num - (1<<number);\n\telse\n\t\treturn num;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149813,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "layer_resize(int layer, int x_size, int y_size)\n{\n\tint                 old_height;\n\tint                 old_width;\n\tstruct map_tile*    tile;\n\tint                 tile_width;\n\tint                 tile_height;\n\tstruct map_tile*    tilemap;\n\tstruct map_trigger* trigger;\n\tstruct map_zone*    zone;\n\n\tint x, y, i;\n\n\told_width = s_map->layers[layer].width;\n\told_height = s_map->layers[layer].height;\n\n\t// allocate a new tilemap and copy the old layer tiles into it.  we can't simply realloc\n\t// because the tilemap is a 2D array.\n\tif (!(tilemap = malloc(x_size * y_size * sizeof(struct map_tile))))\n\t\treturn false;\n\tfor (x = 0; x < x_size; ++x) {\n\t\tfor (y = 0; y < y_size; ++y) {\n\t\t\tif (x < old_width && y < old_height) {\n\t\t\t\ttilemap[x + y * x_size] = s_map->layers[layer].tilemap[x + y * old_width];\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttile = &tilemap[x + y * x_size];\n\t\t\t\ttile->frames_left = tileset_get_delay(s_map->tileset, 0);\n\t\t\t\ttile->tile_index = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t// free the old tilemap and substitute the new one\n\tfree(s_map->layers[layer].tilemap);\n\ts_map->layers[layer].tilemap = tilemap;\n\ts_map->layers[layer].width = x_size;\n\ts_map->layers[layer].height = y_size;\n\n\t// if we resize the largest layer, the overall map size will change.\n\t// recalcuate it.\n\ttileset_get_size(s_map->tileset, &tile_width, &tile_height);\n\ts_map->width = 0;\n\ts_map->height = 0;\n\tfor (i = 0; i < s_map->num_layers; ++i) {\n\t\tif (!s_map->layers[i].is_parallax) {\n\t\t\ts_map->width = fmax(s_map->width, s_map->layers[i].width * tile_width);\n\t\t\ts_map->height = fmax(s_map->height, s_map->layers[i].height * tile_height);\n\t\t}\n\t}\n\n\t// ensure zones and triggers remain in-bounds.  if any are completely\n\t// out-of-bounds, delete them.\n\tfor (i = (int)vector_len(s_map->zones) - 1; i >= 0; --i) {\n\t\tzone = vector_get(s_map->zones, i);\n\t\tif (zone->bounds.x1 >= s_map->width || zone->bounds.y1 >= s_map->height)\n\t\t\tvector_remove(s_map->zones, i);\n\t\telse {\n\t\t\tif (zone->bounds.x2 > s_map->width)\n\t\t\t\tzone->bounds.x2 = s_map->width;\n\t\t\tif (zone->bounds.y2 > s_map->height)\n\t\t\t\tzone->bounds.y2 = s_map->height;\n\t\t}\n\t}\n\tfor (i = (int)vector_len(s_map->triggers) - 1; i >= 0; --i) {\n\t\ttrigger = vector_get(s_map->triggers, i);\n\t\tif (trigger->x >= s_map->width || trigger->y >= s_map->height)\n\t\t\tvector_remove(s_map->triggers, i);\n\t}\n\n\treturn true;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149814,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "layer_resize(int layer, int x_size, int y_size)\n{\n\tint                 old_height;\n\tint                 old_width;\n\tstruct map_tile*    tile;\n\tint                 tile_width;\n\tint                 tile_height;\n\tstruct map_tile*    tilemap;\n\tstruct map_trigger* trigger;\n\tstruct map_zone*    zone;\n\tsize_t              tilemap_size;\n\n\tint x, y, i;\n\n\told_width = s_map->layers[layer].width;\n\told_height = s_map->layers[layer].height;\n\n\t// allocate a new tilemap and copy the old layer tiles into it.  we can't simply realloc\n\t// because the tilemap is a 2D array.\n\ttilemap_size = x_size * y_size * sizeof(struct map_tile);\n\tif (x_size == 0 || tilemap_size / x_size / sizeof(struct map_tile) != y_size\n\t\t|| !(tilemap = malloc(tilemap_size)))\n\t\treturn false;\n\tfor (x = 0; x < x_size; ++x) {\n\t\tfor (y = 0; y < y_size; ++y) {\n\t\t\tif (x < old_width && y < old_height) {\n\t\t\t\ttilemap[x + y * x_size] = s_map->layers[layer].tilemap[x + y * old_width];\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttile = &tilemap[x + y * x_size];\n\t\t\t\ttile->frames_left = tileset_get_delay(s_map->tileset, 0);\n\t\t\t\ttile->tile_index = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t// free the old tilemap and substitute the new one\n\tfree(s_map->layers[layer].tilemap);\n\ts_map->layers[layer].tilemap = tilemap;\n\ts_map->layers[layer].width = x_size;\n\ts_map->layers[layer].height = y_size;\n\n\t// if we resize the largest layer, the overall map size will change.\n\t// recalcuate it.\n\ttileset_get_size(s_map->tileset, &tile_width, &tile_height);\n\ts_map->width = 0;\n\ts_map->height = 0;\n\tfor (i = 0; i < s_map->num_layers; ++i) {\n\t\tif (!s_map->layers[i].is_parallax) {\n\t\t\ts_map->width = fmax(s_map->width, s_map->layers[i].width * tile_width);\n\t\t\ts_map->height = fmax(s_map->height, s_map->layers[i].height * tile_height);\n\t\t}\n\t}\n\n\t// ensure zones and triggers remain in-bounds.  if any are completely\n\t// out-of-bounds, delete them.\n\tfor (i = (int)vector_len(s_map->zones) - 1; i >= 0; --i) {\n\t\tzone = vector_get(s_map->zones, i);\n\t\tif (zone->bounds.x1 >= s_map->width || zone->bounds.y1 >= s_map->height)\n\t\t\tvector_remove(s_map->zones, i);\n\t\telse {\n\t\t\tif (zone->bounds.x2 > s_map->width)\n\t\t\t\tzone->bounds.x2 = s_map->width;\n\t\t\tif (zone->bounds.y2 > s_map->height)\n\t\t\t\tzone->bounds.y2 = s_map->height;\n\t\t}\n\t}\n\tfor (i = (int)vector_len(s_map->triggers) - 1; i >= 0; --i) {\n\t\ttrigger = vector_get(s_map->triggers, i);\n\t\tif (trigger->x >= s_map->width || trigger->y >= s_map->height)\n\t\t\tvector_remove(s_map->triggers, i);\n\t}\n\n\treturn true;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149815,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static MagickRealType ApplyEvaluateOperator(RandomInfo *random_info,\n  const Quantum pixel,const MagickEvaluateOperator op,\n  const MagickRealType value)\n{\n  MagickRealType\n    result;\n\n  result=0.0;\n  switch (op)\n  {\n    case UndefinedEvaluateOperator:\n      break;\n    case AbsEvaluateOperator:\n    {\n      result=(MagickRealType) fabs((double) (pixel+value));\n      break;\n    }\n    case AddEvaluateOperator:\n    {\n      result=(MagickRealType) (pixel+value);\n      break;\n    }\n    case AddModulusEvaluateOperator:\n    {\n      /*\n        This returns a 'floored modulus' of the addition which is a\n        positive result.  It differs from  % or fmod() which returns a\n        'truncated modulus' result, where floor() is replaced by trunc()\n        and could return a negative result (which is clipped).\n      */\n      result=pixel+value;\n      result-=(QuantumRange+1.0)*floor((double) result/(QuantumRange+1.0));\n      break;\n    }\n    case AndEvaluateOperator:\n    {\n      result=(MagickRealType) ((size_t) pixel & (size_t) (value+0.5));\n      break;\n    }\n    case CosineEvaluateOperator:\n    {\n      result=(MagickRealType) (QuantumRange*(0.5*cos((double) (2.0*MagickPI*\n        QuantumScale*pixel*value))+0.5));\n      break;\n    }\n    case DivideEvaluateOperator:\n    {\n      result=pixel/(value == 0.0 ? 1.0 : value);\n      break;\n    }\n    case ExponentialEvaluateOperator:\n    {\n      result=(MagickRealType) (QuantumRange*exp((double) (value*QuantumScale*\n        pixel)));\n      break;\n    }\n    case GaussianNoiseEvaluateOperator:\n    {\n      result=(MagickRealType) GenerateDifferentialNoise(random_info,pixel,\n        GaussianNoise,value);\n      break;\n    }\n    case ImpulseNoiseEvaluateOperator:\n    {\n      result=(MagickRealType) GenerateDifferentialNoise(random_info,pixel,\n        ImpulseNoise,value);\n      break;\n    }\n    case LaplacianNoiseEvaluateOperator:\n    {\n      result=(MagickRealType) GenerateDifferentialNoise(random_info,pixel,\n        LaplacianNoise,value);\n      break;\n    }\n    case LeftShiftEvaluateOperator:\n    {\n      result=(MagickRealType) ((size_t) pixel << (size_t) (value+0.5));\n      break;\n    }\n    case LogEvaluateOperator:\n    {\n      if ((QuantumScale*pixel) >= MagickEpsilon)\n        result=(MagickRealType) (QuantumRange*log((double) (QuantumScale*value*\n          pixel+1.0))/log((double) (value+1.0)));\n      break;\n    }\n    case MaxEvaluateOperator:\n    {\n      result=(MagickRealType) EvaluateMax((double) pixel,value);\n      break;\n    }\n    case MeanEvaluateOperator:\n    {\n      result=(MagickRealType) (pixel+value);\n      break;\n    }\n    case MedianEvaluateOperator:\n    {\n      result=(MagickRealType) (pixel+value);\n      break;\n    }\n    case MinEvaluateOperator:\n    {\n      result=(MagickRealType) MagickMin((double) pixel,value);\n      break;\n    }\n    case MultiplicativeNoiseEvaluateOperator:\n    {\n      result=(MagickRealType) GenerateDifferentialNoise(random_info,pixel,\n        MultiplicativeGaussianNoise,value);\n      break;\n    }\n    case MultiplyEvaluateOperator:\n    {\n      result=(MagickRealType) (value*pixel);\n      break;\n    }\n    case OrEvaluateOperator:\n    {\n      result=(MagickRealType) ((size_t) pixel | (size_t) (value+0.5));\n      break;\n    }\n    case PoissonNoiseEvaluateOperator:\n    {\n      result=(MagickRealType) GenerateDifferentialNoise(random_info,pixel,\n        PoissonNoise,value);\n      break;\n    }\n    case PowEvaluateOperator:\n    {\n      result=(MagickRealType) (QuantumRange*pow((double) (QuantumScale*pixel),\n        (double) value));\n      break;\n    }\n    case RightShiftEvaluateOperator:\n    {\n      result=(MagickRealType) ((size_t) pixel >> (size_t) (value+0.5));\n      break;\n    }\n    case RootMeanSquareEvaluateOperator:\n    {\n      result=(MagickRealType) (pixel*pixel+value);\n      break;\n    }\n    case SetEvaluateOperator:\n    {\n      result=value;\n      break;\n    }\n    case SineEvaluateOperator:\n    {\n      result=(MagickRealType) (QuantumRange*(0.5*sin((double) (2.0*MagickPI*\n        QuantumScale*pixel*value))+0.5));\n      break;\n    }\n    case SubtractEvaluateOperator:\n    {\n      result=(MagickRealType) (pixel-value);\n      break;\n    }\n    case SumEvaluateOperator:\n    {\n      result=(MagickRealType) (pixel+value);\n      break;\n    }\n    case ThresholdEvaluateOperator:\n    {\n      result=(MagickRealType) (((MagickRealType) pixel <= value) ? 0 :\n        QuantumRange);\n      break;\n    }\n    case ThresholdBlackEvaluateOperator:\n    {\n      result=(MagickRealType) (((MagickRealType) pixel <= value) ? 0 : pixel);\n      break;\n    }\n    case ThresholdWhiteEvaluateOperator:\n    {\n      result=(MagickRealType) (((MagickRealType) pixel > value) ? QuantumRange :\n        pixel);\n      break;\n    }\n    case UniformNoiseEvaluateOperator:\n    {\n      result=(MagickRealType) GenerateDifferentialNoise(random_info,pixel,\n        UniformNoise,value);\n      break;\n    }\n    case XorEvaluateOperator:\n    {\n      result=(MagickRealType) ((size_t) pixel ^ (size_t) (value+0.5));\n      break;\n    }\n  }\n  return(result);\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149816,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static MagickRealType ApplyEvaluateOperator(RandomInfo *random_info,\n  const Quantum pixel,const MagickEvaluateOperator op,\n  const MagickRealType value)\n{\n  MagickRealType\n    result;\n\n  result=0.0;\n  switch (op)\n  {\n    case UndefinedEvaluateOperator:\n      break;\n    case AbsEvaluateOperator:\n    {\n      result=(MagickRealType) fabs((double) (pixel+value));\n      break;\n    }\n    case AddEvaluateOperator:\n    {\n      result=(MagickRealType) (pixel+value);\n      break;\n    }\n    case AddModulusEvaluateOperator:\n    {\n      /*\n        This returns a 'floored modulus' of the addition which is a\n        positive result.  It differs from  % or fmod() which returns a\n        'truncated modulus' result, where floor() is replaced by trunc()\n        and could return a negative result (which is clipped).\n      */\n      result=pixel+value;\n      result-=(QuantumRange+1.0)*floor((double) result/(QuantumRange+1.0));\n      break;\n    }\n    case AndEvaluateOperator:\n    {\n      result=(MagickRealType) ((ssize_t) pixel & (ssize_t) (value+0.5));\n      break;\n    }\n    case CosineEvaluateOperator:\n    {\n      result=(MagickRealType) (QuantumRange*(0.5*cos((double) (2.0*MagickPI*\n        QuantumScale*pixel*value))+0.5));\n      break;\n    }\n    case DivideEvaluateOperator:\n    {\n      result=pixel/(value == 0.0 ? 1.0 : value);\n      break;\n    }\n    case ExponentialEvaluateOperator:\n    {\n      result=(MagickRealType) (QuantumRange*exp((double) (value*QuantumScale*\n        pixel)));\n      break;\n    }\n    case GaussianNoiseEvaluateOperator:\n    {\n      result=(MagickRealType) GenerateDifferentialNoise(random_info,pixel,\n        GaussianNoise,value);\n      break;\n    }\n    case ImpulseNoiseEvaluateOperator:\n    {\n      result=(MagickRealType) GenerateDifferentialNoise(random_info,pixel,\n        ImpulseNoise,value);\n      break;\n    }\n    case LaplacianNoiseEvaluateOperator:\n    {\n      result=(MagickRealType) GenerateDifferentialNoise(random_info,pixel,\n        LaplacianNoise,value);\n      break;\n    }\n    case LeftShiftEvaluateOperator:\n    {\n      result=(MagickRealType) ((ssize_t) pixel << (ssize_t) (value+0.5));\n      break;\n    }\n    case LogEvaluateOperator:\n    {\n      if ((QuantumScale*pixel) >= MagickEpsilon)\n        result=(MagickRealType) (QuantumRange*log((double) (QuantumScale*value*\n          pixel+1.0))/log((double) (value+1.0)));\n      break;\n    }\n    case MaxEvaluateOperator:\n    {\n      result=(MagickRealType) EvaluateMax((double) pixel,value);\n      break;\n    }\n    case MeanEvaluateOperator:\n    {\n      result=(MagickRealType) (pixel+value);\n      break;\n    }\n    case MedianEvaluateOperator:\n    {\n      result=(MagickRealType) (pixel+value);\n      break;\n    }\n    case MinEvaluateOperator:\n    {\n      result=(MagickRealType) MagickMin((double) pixel,value);\n      break;\n    }\n    case MultiplicativeNoiseEvaluateOperator:\n    {\n      result=(MagickRealType) GenerateDifferentialNoise(random_info,pixel,\n        MultiplicativeGaussianNoise,value);\n      break;\n    }\n    case MultiplyEvaluateOperator:\n    {\n      result=(MagickRealType) (value*pixel);\n      break;\n    }\n    case OrEvaluateOperator:\n    {\n      result=(MagickRealType) ((ssize_t) pixel | (ssize_t) (value+0.5));\n      break;\n    }\n    case PoissonNoiseEvaluateOperator:\n    {\n      result=(MagickRealType) GenerateDifferentialNoise(random_info,pixel,\n        PoissonNoise,value);\n      break;\n    }\n    case PowEvaluateOperator:\n    {\n      result=(MagickRealType) (QuantumRange*pow((double) (QuantumScale*pixel),\n        (double) value));\n      break;\n    }\n    case RightShiftEvaluateOperator:\n    {\n      result=(MagickRealType) ((ssize_t) pixel >> (ssize_t) (value+0.5));\n      break;\n    }\n    case RootMeanSquareEvaluateOperator:\n    {\n      result=(MagickRealType) (pixel*pixel+value);\n      break;\n    }\n    case SetEvaluateOperator:\n    {\n      result=value;\n      break;\n    }\n    case SineEvaluateOperator:\n    {\n      result=(MagickRealType) (QuantumRange*(0.5*sin((double) (2.0*MagickPI*\n        QuantumScale*pixel*value))+0.5));\n      break;\n    }\n    case SubtractEvaluateOperator:\n    {\n      result=(MagickRealType) (pixel-value);\n      break;\n    }\n    case SumEvaluateOperator:\n    {\n      result=(MagickRealType) (pixel+value);\n      break;\n    }\n    case ThresholdEvaluateOperator:\n    {\n      result=(MagickRealType) (((MagickRealType) pixel <= value) ? 0 :\n        QuantumRange);\n      break;\n    }\n    case ThresholdBlackEvaluateOperator:\n    {\n      result=(MagickRealType) (((MagickRealType) pixel <= value) ? 0 : pixel);\n      break;\n    }\n    case ThresholdWhiteEvaluateOperator:\n    {\n      result=(MagickRealType) (((MagickRealType) pixel > value) ? QuantumRange :\n        pixel);\n      break;\n    }\n    case UniformNoiseEvaluateOperator:\n    {\n      result=(MagickRealType) GenerateDifferentialNoise(random_info,pixel,\n        UniformNoise,value);\n      break;\n    }\n    case XorEvaluateOperator:\n    {\n      result=(MagickRealType) ((ssize_t) pixel ^ (ssize_t) (value+0.5));\n      break;\n    }\n  }\n  return(result);\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149817,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static int jpc_dec_process_siz(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_siz_t *siz = &ms->parms.siz;\n\tint compno;\n\tint tileno;\n\tjpc_dec_tile_t *tile;\n\tjpc_dec_tcomp_t *tcomp;\n\tint htileno;\n\tint vtileno;\n\tjpc_dec_cmpt_t *cmpt;\n\n\tdec->xstart = siz->xoff;\n\tdec->ystart = siz->yoff;\n\tdec->xend = siz->width;\n\tdec->yend = siz->height;\n\tdec->tilewidth = siz->tilewidth;\n\tdec->tileheight = siz->tileheight;\n\tdec->tilexoff = siz->tilexoff;\n\tdec->tileyoff = siz->tileyoff;\n\tdec->numcomps = siz->numcomps;\n\tif (!(dec->cp = jpc_dec_cp_create(dec->numcomps))) {\n\t\treturn -1;\n\t}\n\n\tif (!(dec->cmpts = jas_alloc2(dec->numcomps, sizeof(jpc_dec_cmpt_t)))) {\n\t\treturn -1;\n\t}\n\n\tfor (compno = 0, cmpt = dec->cmpts; compno < dec->numcomps; ++compno,\n\t  ++cmpt) {\n\t\tcmpt->prec = siz->comps[compno].prec;\n\t\tcmpt->sgnd = siz->comps[compno].sgnd;\n\t\tcmpt->hstep = siz->comps[compno].hsamp;\n\t\tcmpt->vstep = siz->comps[compno].vsamp;\n\t\tcmpt->width = JPC_CEILDIV(dec->xend, cmpt->hstep) -\n\t\t  JPC_CEILDIV(dec->xstart, cmpt->hstep);\n\t\tcmpt->height = JPC_CEILDIV(dec->yend, cmpt->vstep) -\n\t\t  JPC_CEILDIV(dec->ystart, cmpt->vstep);\n\t\tcmpt->hsubstep = 0;\n\t\tcmpt->vsubstep = 0;\n\t}\n\n\tdec->image = 0;\n\n\tdec->numhtiles = JPC_CEILDIV(dec->xend - dec->tilexoff, dec->tilewidth);\n\tdec->numvtiles = JPC_CEILDIV(dec->yend - dec->tileyoff, dec->tileheight);\n\tdec->numtiles = dec->numhtiles * dec->numvtiles;\n\tJAS_DBGLOG(10, (\"numtiles = %d; numhtiles = %d; numvtiles = %d;\\n\",\n\t  dec->numtiles, dec->numhtiles, dec->numvtiles));\n\tif (!(dec->tiles = jas_alloc2(dec->numtiles, sizeof(jpc_dec_tile_t)))) {\n\t\treturn -1;\n\t}\n\n\tfor (tileno = 0, tile = dec->tiles; tileno < dec->numtiles; ++tileno,\n\t  ++tile) {\n\t\thtileno = tileno % dec->numhtiles;\n\t\tvtileno = tileno / dec->numhtiles;\n\t\ttile->realmode = 0;\n\t\ttile->state = JPC_TILE_INIT;\n\t\ttile->xstart = JAS_MAX(dec->tilexoff + htileno * dec->tilewidth,\n\t\t  dec->xstart);\n\t\ttile->ystart = JAS_MAX(dec->tileyoff + vtileno * dec->tileheight,\n\t\t  dec->ystart);\n\t\ttile->xend = JAS_MIN(dec->tilexoff + (htileno + 1) *\n\t\t  dec->tilewidth, dec->xend);\n\t\ttile->yend = JAS_MIN(dec->tileyoff + (vtileno + 1) *\n\t\t  dec->tileheight, dec->yend);\n\t\ttile->numparts = 0;\n\t\ttile->partno = 0;\n\t\ttile->pkthdrstream = 0;\n\t\ttile->pkthdrstreampos = 0;\n\t\ttile->pptstab = 0;\n\t\ttile->cp = 0;\n\t\ttile->pi = 0;\n\t\tif (!(tile->tcomps = jas_alloc2(dec->numcomps,\n\t\t  sizeof(jpc_dec_tcomp_t)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (compno = 0, cmpt = dec->cmpts, tcomp = tile->tcomps;\n\t\t  compno < dec->numcomps; ++compno, ++cmpt, ++tcomp) {\n\t\t\ttcomp->rlvls = 0;\n\t\t\ttcomp->numrlvls = 0;\n\t\t\ttcomp->data = 0;\n\t\t\ttcomp->xstart = JPC_CEILDIV(tile->xstart, cmpt->hstep);\n\t\t\ttcomp->ystart = JPC_CEILDIV(tile->ystart, cmpt->vstep);\n\t\t\ttcomp->xend = JPC_CEILDIV(tile->xend, cmpt->hstep);\n\t\t\ttcomp->yend = JPC_CEILDIV(tile->yend, cmpt->vstep);\n\t\t\ttcomp->tsfb = 0;\n\t\t}\n\t}\n\n\tdec->pkthdrstreams = 0;\n\n\t/* We should expect to encounter other main header marker segments\n\t  or an SOT marker segment next. */\n\tdec->state = JPC_MH;\n\n\treturn 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149820,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static int jpc_dec_process_siz(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_siz_t *siz = &ms->parms.siz;\n\tint compno;\n\tint tileno;\n\tjpc_dec_tile_t *tile;\n\tjpc_dec_tcomp_t *tcomp;\n\tint htileno;\n\tint vtileno;\n\tjpc_dec_cmpt_t *cmpt;\n\tsize_t size;\n\n\tdec->xstart = siz->xoff;\n\tdec->ystart = siz->yoff;\n\tdec->xend = siz->width;\n\tdec->yend = siz->height;\n\tdec->tilewidth = siz->tilewidth;\n\tdec->tileheight = siz->tileheight;\n\tdec->tilexoff = siz->tilexoff;\n\tdec->tileyoff = siz->tileyoff;\n\tdec->numcomps = siz->numcomps;\n\tif (!(dec->cp = jpc_dec_cp_create(dec->numcomps))) {\n\t\treturn -1;\n\t}\n\n\tif (!(dec->cmpts = jas_alloc2(dec->numcomps, sizeof(jpc_dec_cmpt_t)))) {\n\t\treturn -1;\n\t}\n\n\tfor (compno = 0, cmpt = dec->cmpts; compno < dec->numcomps; ++compno,\n\t  ++cmpt) {\n\t\tcmpt->prec = siz->comps[compno].prec;\n\t\tcmpt->sgnd = siz->comps[compno].sgnd;\n\t\tcmpt->hstep = siz->comps[compno].hsamp;\n\t\tcmpt->vstep = siz->comps[compno].vsamp;\n\t\tcmpt->width = JPC_CEILDIV(dec->xend, cmpt->hstep) -\n\t\t  JPC_CEILDIV(dec->xstart, cmpt->hstep);\n\t\tcmpt->height = JPC_CEILDIV(dec->yend, cmpt->vstep) -\n\t\t  JPC_CEILDIV(dec->ystart, cmpt->vstep);\n\t\tcmpt->hsubstep = 0;\n\t\tcmpt->vsubstep = 0;\n\t}\n\n\tdec->image = 0;\n\n\tdec->numhtiles = JPC_CEILDIV(dec->xend - dec->tilexoff, dec->tilewidth);\n\tdec->numvtiles = JPC_CEILDIV(dec->yend - dec->tileyoff, dec->tileheight);\n\tif (!jas_safe_size_mul(dec->numhtiles, dec->numvtiles, &size)) {\n\t\treturn -1;\n\t}\n\tdec->numtiles = size;\n\tJAS_DBGLOG(10, (\"numtiles = %d; numhtiles = %d; numvtiles = %d;\\n\",\n\t  dec->numtiles, dec->numhtiles, dec->numvtiles));\n\tif (!(dec->tiles = jas_alloc2(dec->numtiles, sizeof(jpc_dec_tile_t)))) {\n\t\treturn -1;\n\t}\n\n\tfor (tileno = 0, tile = dec->tiles; tileno < dec->numtiles; ++tileno,\n\t  ++tile) {\n\t\thtileno = tileno % dec->numhtiles;\n\t\tvtileno = tileno / dec->numhtiles;\n\t\ttile->realmode = 0;\n\t\ttile->state = JPC_TILE_INIT;\n\t\ttile->xstart = JAS_MAX(dec->tilexoff + htileno * dec->tilewidth,\n\t\t  dec->xstart);\n\t\ttile->ystart = JAS_MAX(dec->tileyoff + vtileno * dec->tileheight,\n\t\t  dec->ystart);\n\t\ttile->xend = JAS_MIN(dec->tilexoff + (htileno + 1) *\n\t\t  dec->tilewidth, dec->xend);\n\t\ttile->yend = JAS_MIN(dec->tileyoff + (vtileno + 1) *\n\t\t  dec->tileheight, dec->yend);\n\t\ttile->numparts = 0;\n\t\ttile->partno = 0;\n\t\ttile->pkthdrstream = 0;\n\t\ttile->pkthdrstreampos = 0;\n\t\ttile->pptstab = 0;\n\t\ttile->cp = 0;\n\t\ttile->pi = 0;\n\t\tif (!(tile->tcomps = jas_alloc2(dec->numcomps,\n\t\t  sizeof(jpc_dec_tcomp_t)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (compno = 0, cmpt = dec->cmpts, tcomp = tile->tcomps;\n\t\t  compno < dec->numcomps; ++compno, ++cmpt, ++tcomp) {\n\t\t\ttcomp->rlvls = 0;\n\t\t\ttcomp->numrlvls = 0;\n\t\t\ttcomp->data = 0;\n\t\t\ttcomp->xstart = JPC_CEILDIV(tile->xstart, cmpt->hstep);\n\t\t\ttcomp->ystart = JPC_CEILDIV(tile->ystart, cmpt->vstep);\n\t\t\ttcomp->xend = JPC_CEILDIV(tile->xend, cmpt->hstep);\n\t\t\ttcomp->yend = JPC_CEILDIV(tile->yend, cmpt->vstep);\n\t\t\ttcomp->tsfb = 0;\n\t\t}\n\t}\n\n\tdec->pkthdrstreams = 0;\n\n\t/* We should expect to encounter other main header marker segments\n\t  or an SOT marker segment next. */\n\tdec->state = JPC_MH;\n\n\treturn 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149821,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static void opj_get_encoding_parameters(const opj_image_t *p_image,\n                                        const opj_cp_t *p_cp,\n                                        OPJ_UINT32 p_tileno,\n                                        OPJ_INT32 * p_tx0,\n                                        OPJ_INT32  * p_tx1,\n                                        OPJ_INT32  * p_ty0,\n                                        OPJ_INT32  * p_ty1,\n                                        OPJ_UINT32 * p_dx_min,\n                                        OPJ_UINT32 * p_dy_min,\n                                        OPJ_UINT32 * p_max_prec,\n                                        OPJ_UINT32 * p_max_res)\n{\n    /* loop */\n    OPJ_UINT32  compno, resno;\n    /* pointers */\n    const opj_tcp_t *l_tcp = 00;\n    const opj_tccp_t * l_tccp = 00;\n    const opj_image_comp_t * l_img_comp = 00;\n\n    /* position in x and y of tile */\n    OPJ_UINT32 p, q;\n\n    /* preconditions */\n    assert(p_cp != 00);\n    assert(p_image != 00);\n    assert(p_tileno < p_cp->tw * p_cp->th);\n\n    /* initializations */\n    l_tcp = &p_cp->tcps [p_tileno];\n    l_img_comp = p_image->comps;\n    l_tccp = l_tcp->tccps;\n\n    /* here calculation of tx0, tx1, ty0, ty1, maxprec, dx and dy */\n    p = p_tileno % p_cp->tw;\n    q = p_tileno / p_cp->tw;\n\n    /* find extent of tile */\n    *p_tx0 = opj_int_max((OPJ_INT32)(p_cp->tx0 + p * p_cp->tdx),\n                         (OPJ_INT32)p_image->x0);\n    *p_tx1 = opj_int_min((OPJ_INT32)(p_cp->tx0 + (p + 1) * p_cp->tdx),\n                         (OPJ_INT32)p_image->x1);\n    *p_ty0 = opj_int_max((OPJ_INT32)(p_cp->ty0 + q * p_cp->tdy),\n                         (OPJ_INT32)p_image->y0);\n    *p_ty1 = opj_int_min((OPJ_INT32)(p_cp->ty0 + (q + 1) * p_cp->tdy),\n                         (OPJ_INT32)p_image->y1);\n\n    /* max precision is 0 (can only grow) */\n    *p_max_prec = 0;\n    *p_max_res = 0;\n\n    /* take the largest value for dx_min and dy_min */\n    *p_dx_min = 0x7fffffff;\n    *p_dy_min  = 0x7fffffff;\n\n    for (compno = 0; compno < p_image->numcomps; ++compno) {\n        /* arithmetic variables to calculate */\n        OPJ_UINT32 l_level_no;\n        OPJ_INT32 l_rx0, l_ry0, l_rx1, l_ry1;\n        OPJ_INT32 l_px0, l_py0, l_px1, py1;\n        OPJ_UINT32 l_pdx, l_pdy;\n        OPJ_UINT32 l_pw, l_ph;\n        OPJ_UINT32 l_product;\n        OPJ_INT32 l_tcx0, l_tcy0, l_tcx1, l_tcy1;\n\n        l_tcx0 = opj_int_ceildiv(*p_tx0, (OPJ_INT32)l_img_comp->dx);\n        l_tcy0 = opj_int_ceildiv(*p_ty0, (OPJ_INT32)l_img_comp->dy);\n        l_tcx1 = opj_int_ceildiv(*p_tx1, (OPJ_INT32)l_img_comp->dx);\n        l_tcy1 = opj_int_ceildiv(*p_ty1, (OPJ_INT32)l_img_comp->dy);\n\n        if (l_tccp->numresolutions > *p_max_res) {\n            *p_max_res = l_tccp->numresolutions;\n        }\n\n        /* use custom size for precincts */\n        for (resno = 0; resno < l_tccp->numresolutions; ++resno) {\n            OPJ_UINT32 l_dx, l_dy;\n\n            /* precinct width and height */\n            l_pdx = l_tccp->prcw[resno];\n            l_pdy = l_tccp->prch[resno];\n\n            l_dx = l_img_comp->dx * (1u << (l_pdx + l_tccp->numresolutions - 1 - resno));\n            l_dy = l_img_comp->dy * (1u << (l_pdy + l_tccp->numresolutions - 1 - resno));\n\n            /* take the minimum size for dx for each comp and resolution */\n            *p_dx_min = opj_uint_min(*p_dx_min, l_dx);\n            *p_dy_min = opj_uint_min(*p_dy_min, l_dy);\n\n            /* various calculations of extents */\n            l_level_no = l_tccp->numresolutions - 1 - resno;\n\n            l_rx0 = opj_int_ceildivpow2(l_tcx0, (OPJ_INT32)l_level_no);\n            l_ry0 = opj_int_ceildivpow2(l_tcy0, (OPJ_INT32)l_level_no);\n            l_rx1 = opj_int_ceildivpow2(l_tcx1, (OPJ_INT32)l_level_no);\n            l_ry1 = opj_int_ceildivpow2(l_tcy1, (OPJ_INT32)l_level_no);\n\n            l_px0 = opj_int_floordivpow2(l_rx0, (OPJ_INT32)l_pdx) << l_pdx;\n            l_py0 = opj_int_floordivpow2(l_ry0, (OPJ_INT32)l_pdy) << l_pdy;\n            l_px1 = opj_int_ceildivpow2(l_rx1, (OPJ_INT32)l_pdx) << l_pdx;\n\n            py1 = opj_int_ceildivpow2(l_ry1, (OPJ_INT32)l_pdy) << l_pdy;\n\n            l_pw = (l_rx0 == l_rx1) ? 0 : (OPJ_UINT32)((l_px1 - l_px0) >> l_pdx);\n            l_ph = (l_ry0 == l_ry1) ? 0 : (OPJ_UINT32)((py1 - l_py0) >> l_pdy);\n\n            l_product = l_pw * l_ph;\n\n            /* update precision */\n            if (l_product > *p_max_prec) {\n                *p_max_prec = l_product;\n            }\n        }\n        ++l_img_comp;\n        ++l_tccp;\n    }\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 150338,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static void opj_get_encoding_parameters(const opj_image_t *p_image,\n                                        const opj_cp_t *p_cp,\n                                        OPJ_UINT32 p_tileno,\n                                        OPJ_INT32 * p_tx0,\n                                        OPJ_INT32  * p_tx1,\n                                        OPJ_INT32  * p_ty0,\n                                        OPJ_INT32  * p_ty1,\n                                        OPJ_UINT32 * p_dx_min,\n                                        OPJ_UINT32 * p_dy_min,\n                                        OPJ_UINT32 * p_max_prec,\n                                        OPJ_UINT32 * p_max_res)\n{\n    /* loop */\n    OPJ_UINT32  compno, resno;\n    /* pointers */\n    const opj_tcp_t *l_tcp = 00;\n    const opj_tccp_t * l_tccp = 00;\n    const opj_image_comp_t * l_img_comp = 00;\n\n    /* position in x and y of tile */\n    OPJ_UINT32 p, q;\n\n    /* non-corrected (in regard to image offset) tile offset */\n    OPJ_UINT32 l_tx0, l_ty0;\n\n    /* preconditions */\n    assert(p_cp != 00);\n    assert(p_image != 00);\n    assert(p_tileno < p_cp->tw * p_cp->th);\n\n    /* initializations */\n    l_tcp = &p_cp->tcps [p_tileno];\n    l_img_comp = p_image->comps;\n    l_tccp = l_tcp->tccps;\n\n    /* here calculation of tx0, tx1, ty0, ty1, maxprec, dx and dy */\n    p = p_tileno % p_cp->tw;\n    q = p_tileno / p_cp->tw;\n\n    /* find extent of tile */\n    l_tx0 = p_cp->tx0 + p *\n            p_cp->tdx; /* can't be greater than p_image->x1 so won't overflow */\n    *p_tx0 = (OPJ_INT32)opj_uint_max(l_tx0, p_image->x0);\n    *p_tx1 = (OPJ_INT32)opj_uint_min(opj_uint_adds(l_tx0, p_cp->tdx), p_image->x1);\n    l_ty0 = p_cp->ty0 + q *\n            p_cp->tdy; /* can't be greater than p_image->y1 so won't overflow */\n    *p_ty0 = (OPJ_INT32)opj_uint_max(l_ty0, p_image->y0);\n    *p_ty1 = (OPJ_INT32)opj_uint_min(opj_uint_adds(l_ty0, p_cp->tdy), p_image->y1);\n\n    /* max precision is 0 (can only grow) */\n    *p_max_prec = 0;\n    *p_max_res = 0;\n\n    /* take the largest value for dx_min and dy_min */\n    *p_dx_min = 0x7fffffff;\n    *p_dy_min  = 0x7fffffff;\n\n    for (compno = 0; compno < p_image->numcomps; ++compno) {\n        /* arithmetic variables to calculate */\n        OPJ_UINT32 l_level_no;\n        OPJ_INT32 l_rx0, l_ry0, l_rx1, l_ry1;\n        OPJ_INT32 l_px0, l_py0, l_px1, py1;\n        OPJ_UINT32 l_pdx, l_pdy;\n        OPJ_UINT32 l_pw, l_ph;\n        OPJ_UINT32 l_product;\n        OPJ_INT32 l_tcx0, l_tcy0, l_tcx1, l_tcy1;\n\n        l_tcx0 = opj_int_ceildiv(*p_tx0, (OPJ_INT32)l_img_comp->dx);\n        l_tcy0 = opj_int_ceildiv(*p_ty0, (OPJ_INT32)l_img_comp->dy);\n        l_tcx1 = opj_int_ceildiv(*p_tx1, (OPJ_INT32)l_img_comp->dx);\n        l_tcy1 = opj_int_ceildiv(*p_ty1, (OPJ_INT32)l_img_comp->dy);\n\n        if (l_tccp->numresolutions > *p_max_res) {\n            *p_max_res = l_tccp->numresolutions;\n        }\n\n        /* use custom size for precincts */\n        for (resno = 0; resno < l_tccp->numresolutions; ++resno) {\n            OPJ_UINT32 l_dx, l_dy;\n\n            /* precinct width and height */\n            l_pdx = l_tccp->prcw[resno];\n            l_pdy = l_tccp->prch[resno];\n\n            l_dx = l_img_comp->dx * (1u << (l_pdx + l_tccp->numresolutions - 1 - resno));\n            l_dy = l_img_comp->dy * (1u << (l_pdy + l_tccp->numresolutions - 1 - resno));\n\n            /* take the minimum size for dx for each comp and resolution */\n            *p_dx_min = opj_uint_min(*p_dx_min, l_dx);\n            *p_dy_min = opj_uint_min(*p_dy_min, l_dy);\n\n            /* various calculations of extents */\n            l_level_no = l_tccp->numresolutions - 1 - resno;\n\n            l_rx0 = opj_int_ceildivpow2(l_tcx0, (OPJ_INT32)l_level_no);\n            l_ry0 = opj_int_ceildivpow2(l_tcy0, (OPJ_INT32)l_level_no);\n            l_rx1 = opj_int_ceildivpow2(l_tcx1, (OPJ_INT32)l_level_no);\n            l_ry1 = opj_int_ceildivpow2(l_tcy1, (OPJ_INT32)l_level_no);\n\n            l_px0 = opj_int_floordivpow2(l_rx0, (OPJ_INT32)l_pdx) << l_pdx;\n            l_py0 = opj_int_floordivpow2(l_ry0, (OPJ_INT32)l_pdy) << l_pdy;\n            l_px1 = opj_int_ceildivpow2(l_rx1, (OPJ_INT32)l_pdx) << l_pdx;\n\n            py1 = opj_int_ceildivpow2(l_ry1, (OPJ_INT32)l_pdy) << l_pdy;\n\n            l_pw = (l_rx0 == l_rx1) ? 0 : (OPJ_UINT32)((l_px1 - l_px0) >> l_pdx);\n            l_ph = (l_ry0 == l_ry1) ? 0 : (OPJ_UINT32)((py1 - l_py0) >> l_pdy);\n\n            l_product = l_pw * l_ph;\n\n            /* update precision */\n            if (l_product > *p_max_prec) {\n                *p_max_prec = l_product;\n            }\n        }\n        ++l_img_comp;\n        ++l_tccp;\n    }\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 150339,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "void rfbScaledScreenUpdateRect(rfbScreenInfoPtr screen, rfbScreenInfoPtr ptr, int x0, int y0, int w0, int h0)\n{\n    int x,y,w,v,z;\n    int x1, y1, w1, h1;\n    int bitsPerPixel, bytesPerPixel, bytesPerLine, areaX, areaY, area2;\n    unsigned char *srcptr, *dstptr;\n\n    /* Nothing to do!!! */\n    if (screen==ptr) return;\n\n    x1 = x0;\n    y1 = y0;\n    w1 = w0;\n    h1 = h0;\n\n    rfbScaledCorrection(screen, ptr, &x1, &y1, &w1, &h1, \"rfbScaledScreenUpdateRect\");\n    x0 = ScaleX(ptr, screen, x1);\n    y0 = ScaleY(ptr, screen, y1);\n    w0 = ScaleX(ptr, screen, w1);\n    h0 = ScaleY(ptr, screen, h1);\n\n    bitsPerPixel = screen->bitsPerPixel;\n    bytesPerPixel = bitsPerPixel / 8;\n    bytesPerLine = w1 * bytesPerPixel;\n    srcptr = (unsigned char *)(screen->frameBuffer +\n     (y0 * screen->paddedWidthInBytes + x0 * bytesPerPixel));\n    dstptr = (unsigned char *)(ptr->frameBuffer +\n     ( y1 * ptr->paddedWidthInBytes + x1 * bytesPerPixel));\n    /* The area of the source framebuffer for each destination pixel */\n    areaX = ScaleX(ptr,screen,1);\n    areaY = ScaleY(ptr,screen,1);\n    area2 = areaX*areaY;\n\n\n    /* Ensure that we do not go out of bounds */\n    if ((x1+w1) > (ptr->width))\n    {\n      if (x1==0) w1=ptr->width; else x1 = ptr->width - w1;\n    }\n    if ((y1+h1) > (ptr->height))\n    {\n      if (y1==0) h1=ptr->height; else y1 = ptr->height - h1;\n    }\n    /*\n     * rfbLog(\"rfbScaledScreenUpdateRect(%dXx%dY-%dWx%dH  ->  %dXx%dY-%dWx%dH <%dx%d>) {%dWx%dH -> %dWx%dH} 0x%p\\n\",\n     *    x0, y0, w0, h0, x1, y1, w1, h1, areaX, areaY,\n     *    screen->width, screen->height, ptr->width, ptr->height, ptr->frameBuffer);\n     */\n\n    if (screen->serverFormat.trueColour) { /* Blend neighbouring pixels together */\n      unsigned char *srcptr2;\n      unsigned long pixel_value, red, green, blue;\n      unsigned int redShift = screen->serverFormat.redShift;\n      unsigned int greenShift = screen->serverFormat.greenShift;\n      unsigned int blueShift = screen->serverFormat.blueShift;\n      unsigned long redMax = screen->serverFormat.redMax;\n      unsigned long greenMax = screen->serverFormat.greenMax;\n      unsigned long blueMax = screen->serverFormat.blueMax;\n\n     /* for each *destination* pixel... */\n     for (y = 0; y < h1; y++) {\n       for (x = 0; x < w1; x++) {\n         red = green = blue = 0;\n         /* Get the totals for rgb from the source grid... */\n         for (w = 0; w < areaX; w++) {\n           for (v = 0; v < areaY; v++) {\n             srcptr2 = &srcptr[(((x * areaX) + w) * bytesPerPixel) +\n                               (v * screen->paddedWidthInBytes)];\n             pixel_value = 0;\n\n\n             switch (bytesPerPixel) {\n             case 4: pixel_value = *((unsigned int *)srcptr2);   break;\n             case 2: pixel_value = *((unsigned short *)srcptr2); break;\n             case 1: pixel_value = *((unsigned char *)srcptr2);  break;\n             default:\n               /* fixme: endianness problem? */\n               for (z = 0; z < bytesPerPixel; z++)\n                 pixel_value += (srcptr2[z] << (8 * z));\n                break;\n              }\n              /*\n              srcptr2 += bytesPerPixel;\n              */\n\n            red += ((pixel_value >> redShift) & redMax);\n            green += ((pixel_value >> greenShift) & greenMax);\n            blue += ((pixel_value >> blueShift) & blueMax);\n\n           }\n         }\n         /* We now have a total for all of the colors, find the average! */\n         red /= area2;\n         green /= area2;\n         blue /= area2;\n          /* Stuff the new value back into memory */\n         pixel_value = ((red & redMax) << redShift) | ((green & greenMax) << greenShift) | ((blue & blueMax) << blueShift);\n\n         switch (bytesPerPixel) {\n         case 4: *((unsigned int *)dstptr)   = (unsigned int)   pixel_value; break;\n         case 2: *((unsigned short *)dstptr) = (unsigned short) pixel_value; break;\n         case 1: *((unsigned char *)dstptr)  = (unsigned char)  pixel_value; break;\n         default:\n           /* fixme: endianness problem? */\n           for (z = 0; z < bytesPerPixel; z++)\n             dstptr[z]=(pixel_value >> (8 * z)) & 0xff;\n            break;\n          }\n          dstptr += bytesPerPixel;\n       }\n       srcptr += (screen->paddedWidthInBytes * areaY);\n       dstptr += (ptr->paddedWidthInBytes - bytesPerLine);\n     }\n   } else\n   { /* Not truecolour, so we can't blend. Just use the top-left pixel instead */\n     for (y = y1; y < (y1+h1); y++) {\n       for (x = x1; x < (x1+w1); x++)\n         memcpy (&ptr->frameBuffer[(y *ptr->paddedWidthInBytes) + (x * bytesPerPixel)],\n                 &screen->frameBuffer[(y * areaY * screen->paddedWidthInBytes) + (x *areaX * bytesPerPixel)], bytesPerPixel);\n     }\n  }\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 150340,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "void rfbScaledScreenUpdateRect(rfbScreenInfoPtr screen, rfbScreenInfoPtr ptr, int x0, int y0, int w0, int h0)\n{\n    int x,y,w,v,z;\n    int x1, y1, w1, h1;\n    int bitsPerPixel, bytesPerPixel, bytesPerLine, areaX, areaY, area2;\n    unsigned char *srcptr, *dstptr;\n\n    /* Nothing to do!!! */\n    if (screen==ptr) return;\n\n    x1 = x0;\n    y1 = y0;\n    w1 = w0;\n    h1 = h0;\n\n    rfbScaledCorrection(screen, ptr, &x1, &y1, &w1, &h1, \"rfbScaledScreenUpdateRect\");\n    x0 = ScaleX(ptr, screen, x1);\n    y0 = ScaleY(ptr, screen, y1);\n    w0 = ScaleX(ptr, screen, w1);\n    h0 = ScaleY(ptr, screen, h1);\n\n    bitsPerPixel = screen->bitsPerPixel;\n    bytesPerPixel = bitsPerPixel / 8;\n    bytesPerLine = w1 * bytesPerPixel;\n    srcptr = (unsigned char *)(screen->frameBuffer +\n     (y0 * screen->paddedWidthInBytes + x0 * bytesPerPixel));\n    dstptr = (unsigned char *)(ptr->frameBuffer +\n     ( y1 * ptr->paddedWidthInBytes + x1 * bytesPerPixel));\n    /* The area of the source framebuffer for each destination pixel */\n    areaX = ScaleX(ptr,screen,1);\n    areaY = ScaleY(ptr,screen,1);\n    area2 = areaX*areaY;\n\n\n    /* Ensure that we do not go out of bounds */\n    if ((x1+w1) > (ptr->width))\n    {\n      if (x1==0) w1=ptr->width; else x1 = ptr->width - w1;\n    }\n    if ((y1+h1) > (ptr->height))\n    {\n      if (y1==0) h1=ptr->height; else y1 = ptr->height - h1;\n    }\n    /*\n     * rfbLog(\"rfbScaledScreenUpdateRect(%dXx%dY-%dWx%dH  ->  %dXx%dY-%dWx%dH <%dx%d>) {%dWx%dH -> %dWx%dH} 0x%p\\n\",\n     *    x0, y0, w0, h0, x1, y1, w1, h1, areaX, areaY,\n     *    screen->width, screen->height, ptr->width, ptr->height, ptr->frameBuffer);\n     */\n\n    if (screen->serverFormat.trueColour) { /* Blend neighbouring pixels together */\n      unsigned char *srcptr2;\n      unsigned long pixel_value, red, green, blue;\n      unsigned int redShift = screen->serverFormat.redShift;\n      unsigned int greenShift = screen->serverFormat.greenShift;\n      unsigned int blueShift = screen->serverFormat.blueShift;\n      unsigned long redMax = screen->serverFormat.redMax;\n      unsigned long greenMax = screen->serverFormat.greenMax;\n      unsigned long blueMax = screen->serverFormat.blueMax;\n\n     /* for each *destination* pixel... */\n     for (y = 0; y < h1; y++) {\n       for (x = 0; x < w1; x++) {\n         red = green = blue = 0;\n         /* Get the totals for rgb from the source grid... */\n         for (w = 0; w < areaX; w++) {\n           for (v = 0; v < areaY; v++) {\n             srcptr2 = &srcptr[(((x * areaX) + w) * bytesPerPixel) +\n                               (v * screen->paddedWidthInBytes)];\n             pixel_value = 0;\n\n\n             switch (bytesPerPixel) {\n             case 4: pixel_value = *((unsigned int *)srcptr2);   break;\n             case 2: pixel_value = *((unsigned short *)srcptr2); break;\n             case 1: pixel_value = *((unsigned char *)srcptr2);  break;\n             default:\n               /* fixme: endianness problem? */\n               for (z = 0; z < bytesPerPixel; z++)\n                 pixel_value += ((unsigned long)srcptr2[z] << (8 * z));\n                break;\n              }\n              /*\n              srcptr2 += bytesPerPixel;\n              */\n\n            red += ((pixel_value >> redShift) & redMax);\n            green += ((pixel_value >> greenShift) & greenMax);\n            blue += ((pixel_value >> blueShift) & blueMax);\n\n           }\n         }\n         /* We now have a total for all of the colors, find the average! */\n         red /= area2;\n         green /= area2;\n         blue /= area2;\n          /* Stuff the new value back into memory */\n         pixel_value = ((red & redMax) << redShift) | ((green & greenMax) << greenShift) | ((blue & blueMax) << blueShift);\n\n         switch (bytesPerPixel) {\n         case 4: *((unsigned int *)dstptr)   = (unsigned int)   pixel_value; break;\n         case 2: *((unsigned short *)dstptr) = (unsigned short) pixel_value; break;\n         case 1: *((unsigned char *)dstptr)  = (unsigned char)  pixel_value; break;\n         default:\n           /* fixme: endianness problem? */\n           for (z = 0; z < bytesPerPixel; z++)\n             dstptr[z]=(pixel_value >> (8 * z)) & 0xff;\n            break;\n          }\n          dstptr += bytesPerPixel;\n       }\n       srcptr += (screen->paddedWidthInBytes * areaY);\n       dstptr += (ptr->paddedWidthInBytes - bytesPerLine);\n     }\n   } else\n   { /* Not truecolour, so we can't blend. Just use the top-left pixel instead */\n     for (y = y1; y < (y1+h1); y++) {\n       for (x = x1; x < (x1+w1); x++)\n         memcpy (&ptr->frameBuffer[(y *ptr->paddedWidthInBytes) + (x * bytesPerPixel)],\n                 &screen->frameBuffer[(y * areaY * screen->paddedWidthInBytes) + (x *areaX * bytesPerPixel)], bytesPerPixel);\n     }\n  }\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 150341,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "size_t jsuGetFreeStack() {\n#ifdef ARM\n  void *frame = __builtin_frame_address(0);\n  size_t stackPos = (size_t)((char*)frame);\n  size_t stackEnd = (size_t)((char*)&LINKER_END_VAR);\n  if (stackPos < stackEnd) return 0; // should never happen, but just in case of overflow!\n  return  stackPos - stackEnd;\n#elif defined(LINUX)\n  // On linux, we set STACK_BASE from `main`.\n  char ptr; // this is on the stack\n  extern void *STACK_BASE;\n  uint32_t count =  (uint32_t)((size_t)STACK_BASE - (size_t)&ptr);\n  return 1000000 - count; // give it 1 megabyte of stack\n#else\n  // stack depth seems pretty platform-specific :( Default to a value that disables it\n  return 1000000; // no stack depth check on this platform\n#endif\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 150342,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "size_t jsuGetFreeStack() {\n#ifdef ARM\n  void *frame = __builtin_frame_address(0);\n  size_t stackPos = (size_t)((char*)frame);\n  size_t stackEnd = (size_t)((char*)&LINKER_END_VAR);\n  if (stackPos < stackEnd) return 0; // should never happen, but just in case of overflow!\n  return  stackPos - stackEnd;\n#elif defined(LINUX)\n  // On linux, we set STACK_BASE from `main`.\n  char ptr; // this is on the stack\n  extern void *STACK_BASE;\n  uint32_t count =  (uint32_t)((size_t)STACK_BASE - (size_t)&ptr);\n  const uint32_t max_stack = 1000000; // give it 1 megabyte of stack\n  if (count>max_stack) return 0;\n  return max_stack - count;\n#else\n  // stack depth seems pretty platform-specific :( Default to a value that disables it\n  return 1000000; // no stack depth check on this platform\n#endif\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 150343,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static int ssl_parse_client_psk_identity( mbedtls_ssl_context *ssl, unsigned char **p,\n                                          const unsigned char *end )\n{\n    int ret = 0;\n    size_t n;\n\n    if( ssl->conf->f_psk == NULL &&\n        ( ssl->conf->psk == NULL || ssl->conf->psk_identity == NULL ||\n          ssl->conf->psk_identity_len == 0 || ssl->conf->psk_len == 0 ) )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"got no pre-shared key\" ) );\n        return( MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED );\n    }\n\n    /*\n     * Receive client pre-shared key identity name\n     */\n    if( *p + 2 > end )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client key exchange message\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );\n    }\n\n    n = ( (*p)[0] << 8 ) | (*p)[1];\n    *p += 2;\n\n    if( n < 1 || n > 65535 || *p + n > end )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client key exchange message\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );\n    }\n\n    if( ssl->conf->f_psk != NULL )\n    {\n        if( ssl->conf->f_psk( ssl->conf->p_psk, ssl, *p, n ) != 0 )\n            ret = MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY;\n    }\n    else\n    {\n        /* Identity is not a big secret since clients send it in the clear,\n         * but treat it carefully anyway, just in case */\n        if( n != ssl->conf->psk_identity_len ||\n            mbedtls_ssl_safer_memcmp( ssl->conf->psk_identity, *p, n ) != 0 )\n        {\n            ret = MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY;\n        }\n    }\n\n    if( ret == MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY )\n    {\n        MBEDTLS_SSL_DEBUG_BUF( 3, \"Unknown PSK identity\", *p, n );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_UNKNOWN_PSK_IDENTITY );\n        return( MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY );\n    }\n\n    *p += n;\n\n    return( 0 );\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 150344,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static int ssl_parse_client_psk_identity( mbedtls_ssl_context *ssl, unsigned char **p,\n                                          const unsigned char *end )\n{\n    int ret = 0;\n    size_t n;\n\n    if( ssl->conf->f_psk == NULL &&\n        ( ssl->conf->psk == NULL || ssl->conf->psk_identity == NULL ||\n          ssl->conf->psk_identity_len == 0 || ssl->conf->psk_len == 0 ) )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"got no pre-shared key\" ) );\n        return( MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED );\n    }\n\n    /*\n     * Receive client pre-shared key identity name\n     */\n    if( end - *p < 2 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client key exchange message\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );\n    }\n\n    n = ( (*p)[0] << 8 ) | (*p)[1];\n    *p += 2;\n\n    if( n < 1 || n > 65535 || n > (size_t) ( end - *p ) )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client key exchange message\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );\n    }\n\n    if( ssl->conf->f_psk != NULL )\n    {\n        if( ssl->conf->f_psk( ssl->conf->p_psk, ssl, *p, n ) != 0 )\n            ret = MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY;\n    }\n    else\n    {\n        /* Identity is not a big secret since clients send it in the clear,\n         * but treat it carefully anyway, just in case */\n        if( n != ssl->conf->psk_identity_len ||\n            mbedtls_ssl_safer_memcmp( ssl->conf->psk_identity, *p, n ) != 0 )\n        {\n            ret = MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY;\n        }\n    }\n\n    if( ret == MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY )\n    {\n        MBEDTLS_SSL_DEBUG_BUF( 3, \"Unknown PSK identity\", *p, n );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_UNKNOWN_PSK_IDENTITY );\n        return( MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY );\n    }\n\n    *p += n;\n\n    return( 0 );\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 150345,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": " static int get_next_block(bunzip_data *bd)\n {\n \tstruct group_data *hufGroup;\n\tint dbufCount, dbufSize, groupCount, *base, *limit, selector,\n\t\ti, j, runPos, symCount, symTotal, nSelectors, byteCount[256];\n\tint runCnt = runCnt; /* for compiler */\n \tuint8_t uc, symToByte[256], mtfSymbol[256], *selectors;\n \tuint32_t *dbuf;\n \tunsigned origPtr, t;\n \n \tdbuf = bd->dbuf;\n\tdbufSize = bd->dbufSize;\n \tselectors = bd->selectors;\n \n /* In bbox, we are ok with aborting through setjmp which is set up in start_bunzip */\n#if 0\n\t/* Reset longjmp I/O error handling */\n\ti = setjmp(bd->jmpbuf);\n\tif (i) return i;\n#endif\n\n\t/* Read in header signature and CRC, then validate signature.\n\t   (last block signature means CRC is for whole file, return now) */\n\ti = get_bits(bd, 24);\n\tj = get_bits(bd, 24);\n\tbd->headerCRC = get_bits(bd, 32);\n\tif ((i == 0x177245) && (j == 0x385090)) return RETVAL_LAST_BLOCK;\n\tif ((i != 0x314159) || (j != 0x265359)) return RETVAL_NOT_BZIP_DATA;\n\n\t/* We can add support for blockRandomised if anybody complains.  There was\n\t   some code for this in busybox 1.0.0-pre3, but nobody ever noticed that\n \t   it didn't actually work. */\n \tif (get_bits(bd, 1)) return RETVAL_OBSOLETE_INPUT;\n \torigPtr = get_bits(bd, 24);\n\tif ((int)origPtr > dbufSize) return RETVAL_DATA_ERROR;\n \n \t/* mapping table: if some byte values are never used (encoding things\n \t   like ascii text), the compression code removes the gaps to have fewer\n\t   symbols to deal with, and writes a sparse bitfield indicating which\n\t   values were present.  We make a translation table to convert the symbols\n\t   back to the corresponding bytes. */\n\tsymTotal = 0;\n\ti = 0;\n\tt = get_bits(bd, 16);\n\tdo {\n\t\tif (t & (1 << 15)) {\n\t\t\tunsigned inner_map = get_bits(bd, 16);\n\t\t\tdo {\n\t\t\t\tif (inner_map & (1 << 15))\n\t\t\t\t\tsymToByte[symTotal++] = i;\n\t\t\t\tinner_map <<= 1;\n\t\t\t\ti++;\n\t\t\t} while (i & 15);\n\t\t\ti -= 16;\n\t\t}\n\t\tt <<= 1;\n\t\ti += 16;\n\t} while (i < 256);\n\n\t/* How many different Huffman coding groups does this block use? */\n\tgroupCount = get_bits(bd, 3);\n\tif (groupCount < 2 || groupCount > MAX_GROUPS)\n\t\treturn RETVAL_DATA_ERROR;\n\n\t/* nSelectors: Every GROUP_SIZE many symbols we select a new Huffman coding\n\t   group.  Read in the group selector list, which is stored as MTF encoded\n\t   bit runs.  (MTF=Move To Front, as each value is used it's moved to the\n\t   start of the list.) */\n\tfor (i = 0; i < groupCount; i++)\n\t\tmtfSymbol[i] = i;\n\tnSelectors = get_bits(bd, 15);\n\tif (!nSelectors)\n\t\treturn RETVAL_DATA_ERROR;\n\tfor (i = 0; i < nSelectors; i++) {\n\t\tuint8_t tmp_byte;\n\t\t/* Get next value */\n\t\tint n = 0;\n\t\twhile (get_bits(bd, 1)) {\n\t\t\tif (n >= groupCount) return RETVAL_DATA_ERROR;\n\t\t\tn++;\n\t\t}\n\t\t/* Decode MTF to get the next selector */\n\t\ttmp_byte = mtfSymbol[n];\n\t\twhile (--n >= 0)\n\t\t\tmtfSymbol[n + 1] = mtfSymbol[n];\n\t\tmtfSymbol[0] = selectors[i] = tmp_byte;\n\t}\n\n\t/* Read the Huffman coding tables for each group, which code for symTotal\n\t   literal symbols, plus two run symbols (RUNA, RUNB) */\n\tsymCount = symTotal + 2;\n\tfor (j = 0; j < groupCount; j++) {\n\t\tuint8_t length[MAX_SYMBOLS];\n\t\t/* 8 bits is ALMOST enough for temp[], see below */\n\t\tunsigned temp[MAX_HUFCODE_BITS+1];\n\t\tint minLen, maxLen, pp, len_m1;\n\n\t\t/* Read Huffman code lengths for each symbol.  They're stored in\n\t\t   a way similar to mtf; record a starting value for the first symbol,\n\t\t   and an offset from the previous value for every symbol after that.\n\t\t   (Subtracting 1 before the loop and then adding it back at the end is\n\t\t   an optimization that makes the test inside the loop simpler: symbol\n\t\t   length 0 becomes negative, so an unsigned inequality catches it.) */\n\t\tlen_m1 = get_bits(bd, 5) - 1;\n\t\tfor (i = 0; i < symCount; i++) {\n\t\t\tfor (;;) {\n\t\t\t\tint two_bits;\n\t\t\t\tif ((unsigned)len_m1 > (MAX_HUFCODE_BITS-1))\n\t\t\t\t\treturn RETVAL_DATA_ERROR;\n\n\t\t\t\t/* If first bit is 0, stop.  Else second bit indicates whether\n\t\t\t\t   to increment or decrement the value.  Optimization: grab 2\n\t\t\t\t   bits and unget the second if the first was 0. */\n\t\t\t\ttwo_bits = get_bits(bd, 2);\n\t\t\t\tif (two_bits < 2) {\n\t\t\t\t\tbd->inbufBitCount++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* Add one if second bit 1, else subtract 1.  Avoids if/else */\n\t\t\t\tlen_m1 += (((two_bits+1) & 2) - 1);\n\t\t\t}\n\n\t\t\t/* Correct for the initial -1, to get the final symbol length */\n\t\t\tlength[i] = len_m1 + 1;\n\t\t}\n\n\t\t/* Find largest and smallest lengths in this group */\n\t\tminLen = maxLen = length[0];\n\t\tfor (i = 1; i < symCount; i++) {\n\t\t\tif (length[i] > maxLen) maxLen = length[i];\n\t\t\telse if (length[i] < minLen) minLen = length[i];\n\t\t}\n\n\t\t/* Calculate permute[], base[], and limit[] tables from length[].\n\t\t *\n\t\t * permute[] is the lookup table for converting Huffman coded symbols\n\t\t * into decoded symbols.  base[] is the amount to subtract from the\n\t\t * value of a Huffman symbol of a given length when using permute[].\n\t\t *\n\t\t * limit[] indicates the largest numerical value a symbol with a given\n\t\t * number of bits can have.  This is how the Huffman codes can vary in\n\t\t * length: each code with a value>limit[length] needs another bit.\n\t\t */\n\t\thufGroup = bd->groups + j;\n\t\thufGroup->minLen = minLen;\n\t\thufGroup->maxLen = maxLen;\n\n\t\t/* Note that minLen can't be smaller than 1, so we adjust the base\n\t\t   and limit array pointers so we're not always wasting the first\n\t\t   entry.  We do this again when using them (during symbol decoding). */\n\t\tbase = hufGroup->base - 1;\n\t\tlimit = hufGroup->limit - 1;\n\n\t\t/* Calculate permute[].  Concurrently, initialize temp[] and limit[]. */\n\t\tpp = 0;\n\t\tfor (i = minLen; i <= maxLen; i++) {\n\t\t\tint k;\n\t\t\ttemp[i] = limit[i] = 0;\n\t\t\tfor (k = 0; k < symCount; k++)\n\t\t\t\tif (length[k] == i)\n\t\t\t\t\thufGroup->permute[pp++] = k;\n\t\t}\n\n\t\t/* Count symbols coded for at each bit length */\n\t\t/* NB: in pathological cases, temp[8] can end ip being 256.\n\t\t * That's why uint8_t is too small for temp[]. */\n\t\tfor (i = 0; i < symCount; i++) temp[length[i]]++;\n\n\t\t/* Calculate limit[] (the largest symbol-coding value at each bit\n\t\t * length, which is (previous limit<<1)+symbols at this level), and\n\t\t * base[] (number of symbols to ignore at each bit length, which is\n\t\t * limit minus the cumulative count of symbols coded for already). */\n\t\tpp = t = 0;\n\t\tfor (i = minLen; i < maxLen;) {\n\t\t\tunsigned temp_i = temp[i];\n\n\t\t\tpp += temp_i;\n\n\t\t\t/* We read the largest possible symbol size and then unget bits\n\t\t\t   after determining how many we need, and those extra bits could\n\t\t\t   be set to anything.  (They're noise from future symbols.)  At\n\t\t\t   each level we're really only interested in the first few bits,\n\t\t\t   so here we set all the trailing to-be-ignored bits to 1 so they\n\t\t\t   don't affect the value>limit[length] comparison. */\n\t\t\tlimit[i] = (pp << (maxLen - i)) - 1;\n\t\t\tpp <<= 1;\n\t\t\tt += temp_i;\n\t\t\tbase[++i] = pp - t;\n\t\t}\n\t\tlimit[maxLen] = pp + temp[maxLen] - 1;\n\t\tlimit[maxLen+1] = INT_MAX; /* Sentinel value for reading next sym. */\n\t\tbase[minLen] = 0;\n\t}\n\n\t/* We've finished reading and digesting the block header.  Now read this\n\t   block's Huffman coded symbols from the file and undo the Huffman coding\n\t   and run length encoding, saving the result into dbuf[dbufCount++] = uc */\n\n\t/* Initialize symbol occurrence counters and symbol Move To Front table */\n\t/*memset(byteCount, 0, sizeof(byteCount)); - smaller, but slower */\n\tfor (i = 0; i < 256; i++) {\n\t\tbyteCount[i] = 0;\n\t\tmtfSymbol[i] = (uint8_t)i;\n\t}\n\n\t/* Loop through compressed symbols. */\n\n\trunPos = dbufCount = selector = 0;\n\tfor (;;) {\n\t\tint nextSym;\n\n\t\t/* Fetch next Huffman coding group from list. */\n\t\tsymCount = GROUP_SIZE - 1;\n\t\tif (selector >= nSelectors) return RETVAL_DATA_ERROR;\n\t\thufGroup = bd->groups + selectors[selector++];\n\t\tbase = hufGroup->base - 1;\n\t\tlimit = hufGroup->limit - 1;\n\n continue_this_group:\n\t\t/* Read next Huffman-coded symbol. */\n\n\t\t/* Note: It is far cheaper to read maxLen bits and back up than it is\n\t\t   to read minLen bits and then add additional bit at a time, testing\n\t\t   as we go.  Because there is a trailing last block (with file CRC),\n\t\t   there is no danger of the overread causing an unexpected EOF for a\n\t\t   valid compressed file.\n\t\t */\n\t\tif (1) {\n\t\t\t/* As a further optimization, we do the read inline\n\t\t\t   (falling back to a call to get_bits if the buffer runs dry).\n\t\t\t */\n\t\t\tint new_cnt;\n\t\t\twhile ((new_cnt = bd->inbufBitCount - hufGroup->maxLen) < 0) {\n\t\t\t\t/* bd->inbufBitCount < hufGroup->maxLen */\n\t\t\t\tif (bd->inbufPos == bd->inbufCount) {\n\t\t\t\t\tnextSym = get_bits(bd, hufGroup->maxLen);\n\t\t\t\t\tgoto got_huff_bits;\n\t\t\t\t}\n\t\t\t\tbd->inbufBits = (bd->inbufBits << 8) | bd->inbuf[bd->inbufPos++];\n\t\t\t\tbd->inbufBitCount += 8;\n\t\t\t};\n\t\t\tbd->inbufBitCount = new_cnt; /* \"bd->inbufBitCount -= hufGroup->maxLen;\" */\n\t\t\tnextSym = (bd->inbufBits >> new_cnt) & ((1 << hufGroup->maxLen) - 1);\n got_huff_bits: ;\n\t\t} else { /* unoptimized equivalent */\n\t\t\tnextSym = get_bits(bd, hufGroup->maxLen);\n\t\t}\n\t\t/* Figure how many bits are in next symbol and unget extras */\n\t\ti = hufGroup->minLen;\n\t\twhile (nextSym > limit[i]) ++i;\n\t\tj = hufGroup->maxLen - i;\n\t\tif (j < 0)\n\t\t\treturn RETVAL_DATA_ERROR;\n\t\tbd->inbufBitCount += j;\n\n\t\t/* Huffman decode value to get nextSym (with bounds checking) */\n\t\tnextSym = (nextSym >> j) - base[i];\n\t\tif ((unsigned)nextSym >= MAX_SYMBOLS)\n\t\t\treturn RETVAL_DATA_ERROR;\n\t\tnextSym = hufGroup->permute[nextSym];\n\n\t\t/* We have now decoded the symbol, which indicates either a new literal\n\t\t   byte, or a repeated run of the most recent literal byte.  First,\n\t\t   check if nextSym indicates a repeated run, and if so loop collecting\n\t\t   how many times to repeat the last literal. */\n\t\tif ((unsigned)nextSym <= SYMBOL_RUNB) { /* RUNA or RUNB */\n\n\t\t\t/* If this is the start of a new run, zero out counter */\n\t\t\tif (runPos == 0) {\n\t\t\t\trunPos = 1;\n\t\t\t\trunCnt = 0;\n\t\t\t}\n\n\t\t\t/* Neat trick that saves 1 symbol: instead of or-ing 0 or 1 at\n\t\t\t   each bit position, add 1 or 2 instead.  For example,\n\t\t\t   1011 is 1<<0 + 1<<1 + 2<<2.  1010 is 2<<0 + 2<<1 + 1<<2.\n\t\t\t   You can make any bit pattern that way using 1 less symbol than\n\t\t\t   the basic or 0/1 method (except all bits 0, which would use no\n \t\t\t   symbols, but a run of length 0 doesn't mean anything in this\n \t\t\t   context).  Thus space is saved. */\n \t\t\trunCnt += (runPos << nextSym); /* +runPos if RUNA; +2*runPos if RUNB */\n\t\t\tif (runPos < dbufSize) runPos <<= 1;\n////The 32-bit overflow of runCnt wasn't yet seen, but probably can happen.\n////This would be the fix (catches too large count way before it can overflow):\n////\t\t\tif (runCnt > bd->dbufSize) {\n////\t\t\t\tdbg(\"runCnt:%u > dbufSize:%u RETVAL_DATA_ERROR\",\n////\t\t\t\t\t\trunCnt, bd->dbufSize);\n////\t\t\t\treturn RETVAL_DATA_ERROR;\n////\t\t\t}\n \t\t\tgoto end_of_huffman_loop;\n \t\t}\n \n\t\t\t\tdbg(\"dbufCount:%d+runCnt:%d %d > dbufSize:%d RETVAL_DATA_ERROR\",\n\t\t\t\t\t\tdbufCount, runCnt, dbufCount + runCnt, dbufSize);\n\t\t\t\treturn RETVAL_DATA_ERROR;\n \t\t   literal used is the one at the head of the mtfSymbol array.) */\n \t\tif (runPos != 0) {\n \t\t\tuint8_t tmp_byte;\n\t\t\tif (dbufCount + runCnt > dbufSize) {\n\t\t\t\tdbg(\"dbufCount:%d+runCnt:%d %d > dbufSize:%d RETVAL_DATA_ERROR\",\n\t\t\t\t\t\tdbufCount, runCnt, dbufCount + runCnt, dbufSize);\n \t\t\t\treturn RETVAL_DATA_ERROR;\n \t\t\t}\n \t\t\ttmp_byte = symToByte[mtfSymbol[0]];\n \t\t\tbyteCount[tmp_byte] += runCnt;\n\t\t\twhile (--runCnt >= 0) dbuf[dbufCount++] = (uint32_t)tmp_byte;\n \t\t\trunPos = 0;\n \t\t}\n \n\t\t   as part of a run above.  Therefore 1 unused mtf position minus\n\t\t   2 non-literal nextSym values equals -1.) */\n\t\tif (dbufCount >= dbufSize) return RETVAL_DATA_ERROR;\n\t\ti = nextSym - 1;\n\t\tuc = mtfSymbol[i];\n\n\t\t/* Adjust the MTF array.  Since we typically expect to move only a\n \t\t   first symbol in the mtf array, position 0, would have been handled\n \t\t   as part of a run above.  Therefore 1 unused mtf position minus\n \t\t   2 non-literal nextSym values equals -1.) */\n\t\tif (dbufCount >= dbufSize) return RETVAL_DATA_ERROR;\n \t\ti = nextSym - 1;\n \t\tuc = mtfSymbol[i];\n\t\tuc = symToByte[uc];\n\n\t\t/* We have our literal byte.  Save it into dbuf. */\n\t\tbyteCount[uc]++;\n\t\tdbuf[dbufCount++] = (uint32_t)uc;\n\n\t\t/* Skip group initialization if we're not done with this group.  Done\n\t\t * this way to avoid compiler warning. */\n end_of_huffman_loop:\n\t\tif (--symCount >= 0) goto continue_this_group;\n\t}\n\n\t/* At this point, we've read all the Huffman-coded symbols (and repeated\n\t   runs) for this block from the input stream, and decoded them into the\n\t   intermediate buffer.  There are dbufCount many decoded bytes in dbuf[].\n\t   Now undo the Burrows-Wheeler transform on dbuf.\n\t   See http://dogma.net/markn/articles/bwt/bwt.htm\n\t */\n\n\t/* Turn byteCount into cumulative occurrence counts of 0 to n-1. */\n\tj = 0;\n\tfor (i = 0; i < 256; i++) {\n\t\tint tmp_count = j + byteCount[i];\n\t\tbyteCount[i] = j;\n\t\tj = tmp_count;\n\t}\n\n\t/* Figure out what order dbuf would be in if we sorted it. */\n\tfor (i = 0; i < dbufCount; i++) {\n\t\tuint8_t tmp_byte = (uint8_t)dbuf[i];\n\t\tint tmp_count = byteCount[tmp_byte];\n\t\tdbuf[tmp_count] |= (i << 8);\n\t\tbyteCount[tmp_byte] = tmp_count + 1;\n\t}\n\n\t/* Decode first byte by hand to initialize \"previous\" byte.  Note that it\n\t   doesn't get output, and if the first three characters are identical\n\t   it doesn't qualify as a run (hence writeRunCountdown=5). */\n\tif (dbufCount) {\n\t\tuint32_t tmp;\n\t\tif ((int)origPtr >= dbufCount) return RETVAL_DATA_ERROR;\n\t\ttmp = dbuf[origPtr];\n\t\tbd->writeCurrent = (uint8_t)tmp;\n\t\tbd->writePos = (tmp >> 8);\n\t\tbd->writeRunCountdown = 5;\n\t}\n\tbd->writeCount = dbufCount;\n\n\treturn RETVAL_OK;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141369,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": " static int get_next_block(bunzip_data *bd)\n {\n \tstruct group_data *hufGroup;\n\tint groupCount, *base, *limit, selector,\n\t\ti, j, symCount, symTotal, nSelectors, byteCount[256];\n \tuint8_t uc, symToByte[256], mtfSymbol[256], *selectors;\n \tuint32_t *dbuf;\n \tunsigned origPtr, t;\n\tunsigned dbufCount, runPos;\n\tunsigned runCnt = runCnt; /* for compiler */\n \n \tdbuf = bd->dbuf;\n \tselectors = bd->selectors;\n \n /* In bbox, we are ok with aborting through setjmp which is set up in start_bunzip */\n#if 0\n\t/* Reset longjmp I/O error handling */\n\ti = setjmp(bd->jmpbuf);\n\tif (i) return i;\n#endif\n\n\t/* Read in header signature and CRC, then validate signature.\n\t   (last block signature means CRC is for whole file, return now) */\n\ti = get_bits(bd, 24);\n\tj = get_bits(bd, 24);\n\tbd->headerCRC = get_bits(bd, 32);\n\tif ((i == 0x177245) && (j == 0x385090)) return RETVAL_LAST_BLOCK;\n\tif ((i != 0x314159) || (j != 0x265359)) return RETVAL_NOT_BZIP_DATA;\n\n\t/* We can add support for blockRandomised if anybody complains.  There was\n\t   some code for this in busybox 1.0.0-pre3, but nobody ever noticed that\n \t   it didn't actually work. */\n \tif (get_bits(bd, 1)) return RETVAL_OBSOLETE_INPUT;\n \torigPtr = get_bits(bd, 24);\n\tif (origPtr > bd->dbufSize) return RETVAL_DATA_ERROR;\n \n \t/* mapping table: if some byte values are never used (encoding things\n \t   like ascii text), the compression code removes the gaps to have fewer\n\t   symbols to deal with, and writes a sparse bitfield indicating which\n\t   values were present.  We make a translation table to convert the symbols\n\t   back to the corresponding bytes. */\n\tsymTotal = 0;\n\ti = 0;\n\tt = get_bits(bd, 16);\n\tdo {\n\t\tif (t & (1 << 15)) {\n\t\t\tunsigned inner_map = get_bits(bd, 16);\n\t\t\tdo {\n\t\t\t\tif (inner_map & (1 << 15))\n\t\t\t\t\tsymToByte[symTotal++] = i;\n\t\t\t\tinner_map <<= 1;\n\t\t\t\ti++;\n\t\t\t} while (i & 15);\n\t\t\ti -= 16;\n\t\t}\n\t\tt <<= 1;\n\t\ti += 16;\n\t} while (i < 256);\n\n\t/* How many different Huffman coding groups does this block use? */\n\tgroupCount = get_bits(bd, 3);\n\tif (groupCount < 2 || groupCount > MAX_GROUPS)\n\t\treturn RETVAL_DATA_ERROR;\n\n\t/* nSelectors: Every GROUP_SIZE many symbols we select a new Huffman coding\n\t   group.  Read in the group selector list, which is stored as MTF encoded\n\t   bit runs.  (MTF=Move To Front, as each value is used it's moved to the\n\t   start of the list.) */\n\tfor (i = 0; i < groupCount; i++)\n\t\tmtfSymbol[i] = i;\n\tnSelectors = get_bits(bd, 15);\n\tif (!nSelectors)\n\t\treturn RETVAL_DATA_ERROR;\n\tfor (i = 0; i < nSelectors; i++) {\n\t\tuint8_t tmp_byte;\n\t\t/* Get next value */\n\t\tint n = 0;\n\t\twhile (get_bits(bd, 1)) {\n\t\t\tif (n >= groupCount) return RETVAL_DATA_ERROR;\n\t\t\tn++;\n\t\t}\n\t\t/* Decode MTF to get the next selector */\n\t\ttmp_byte = mtfSymbol[n];\n\t\twhile (--n >= 0)\n\t\t\tmtfSymbol[n + 1] = mtfSymbol[n];\n\t\tmtfSymbol[0] = selectors[i] = tmp_byte;\n\t}\n\n\t/* Read the Huffman coding tables for each group, which code for symTotal\n\t   literal symbols, plus two run symbols (RUNA, RUNB) */\n\tsymCount = symTotal + 2;\n\tfor (j = 0; j < groupCount; j++) {\n\t\tuint8_t length[MAX_SYMBOLS];\n\t\t/* 8 bits is ALMOST enough for temp[], see below */\n\t\tunsigned temp[MAX_HUFCODE_BITS+1];\n\t\tint minLen, maxLen, pp, len_m1;\n\n\t\t/* Read Huffman code lengths for each symbol.  They're stored in\n\t\t   a way similar to mtf; record a starting value for the first symbol,\n\t\t   and an offset from the previous value for every symbol after that.\n\t\t   (Subtracting 1 before the loop and then adding it back at the end is\n\t\t   an optimization that makes the test inside the loop simpler: symbol\n\t\t   length 0 becomes negative, so an unsigned inequality catches it.) */\n\t\tlen_m1 = get_bits(bd, 5) - 1;\n\t\tfor (i = 0; i < symCount; i++) {\n\t\t\tfor (;;) {\n\t\t\t\tint two_bits;\n\t\t\t\tif ((unsigned)len_m1 > (MAX_HUFCODE_BITS-1))\n\t\t\t\t\treturn RETVAL_DATA_ERROR;\n\n\t\t\t\t/* If first bit is 0, stop.  Else second bit indicates whether\n\t\t\t\t   to increment or decrement the value.  Optimization: grab 2\n\t\t\t\t   bits and unget the second if the first was 0. */\n\t\t\t\ttwo_bits = get_bits(bd, 2);\n\t\t\t\tif (two_bits < 2) {\n\t\t\t\t\tbd->inbufBitCount++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* Add one if second bit 1, else subtract 1.  Avoids if/else */\n\t\t\t\tlen_m1 += (((two_bits+1) & 2) - 1);\n\t\t\t}\n\n\t\t\t/* Correct for the initial -1, to get the final symbol length */\n\t\t\tlength[i] = len_m1 + 1;\n\t\t}\n\n\t\t/* Find largest and smallest lengths in this group */\n\t\tminLen = maxLen = length[0];\n\t\tfor (i = 1; i < symCount; i++) {\n\t\t\tif (length[i] > maxLen) maxLen = length[i];\n\t\t\telse if (length[i] < minLen) minLen = length[i];\n\t\t}\n\n\t\t/* Calculate permute[], base[], and limit[] tables from length[].\n\t\t *\n\t\t * permute[] is the lookup table for converting Huffman coded symbols\n\t\t * into decoded symbols.  base[] is the amount to subtract from the\n\t\t * value of a Huffman symbol of a given length when using permute[].\n\t\t *\n\t\t * limit[] indicates the largest numerical value a symbol with a given\n\t\t * number of bits can have.  This is how the Huffman codes can vary in\n\t\t * length: each code with a value>limit[length] needs another bit.\n\t\t */\n\t\thufGroup = bd->groups + j;\n\t\thufGroup->minLen = minLen;\n\t\thufGroup->maxLen = maxLen;\n\n\t\t/* Note that minLen can't be smaller than 1, so we adjust the base\n\t\t   and limit array pointers so we're not always wasting the first\n\t\t   entry.  We do this again when using them (during symbol decoding). */\n\t\tbase = hufGroup->base - 1;\n\t\tlimit = hufGroup->limit - 1;\n\n\t\t/* Calculate permute[].  Concurrently, initialize temp[] and limit[]. */\n\t\tpp = 0;\n\t\tfor (i = minLen; i <= maxLen; i++) {\n\t\t\tint k;\n\t\t\ttemp[i] = limit[i] = 0;\n\t\t\tfor (k = 0; k < symCount; k++)\n\t\t\t\tif (length[k] == i)\n\t\t\t\t\thufGroup->permute[pp++] = k;\n\t\t}\n\n\t\t/* Count symbols coded for at each bit length */\n\t\t/* NB: in pathological cases, temp[8] can end ip being 256.\n\t\t * That's why uint8_t is too small for temp[]. */\n\t\tfor (i = 0; i < symCount; i++) temp[length[i]]++;\n\n\t\t/* Calculate limit[] (the largest symbol-coding value at each bit\n\t\t * length, which is (previous limit<<1)+symbols at this level), and\n\t\t * base[] (number of symbols to ignore at each bit length, which is\n\t\t * limit minus the cumulative count of symbols coded for already). */\n\t\tpp = t = 0;\n\t\tfor (i = minLen; i < maxLen;) {\n\t\t\tunsigned temp_i = temp[i];\n\n\t\t\tpp += temp_i;\n\n\t\t\t/* We read the largest possible symbol size and then unget bits\n\t\t\t   after determining how many we need, and those extra bits could\n\t\t\t   be set to anything.  (They're noise from future symbols.)  At\n\t\t\t   each level we're really only interested in the first few bits,\n\t\t\t   so here we set all the trailing to-be-ignored bits to 1 so they\n\t\t\t   don't affect the value>limit[length] comparison. */\n\t\t\tlimit[i] = (pp << (maxLen - i)) - 1;\n\t\t\tpp <<= 1;\n\t\t\tt += temp_i;\n\t\t\tbase[++i] = pp - t;\n\t\t}\n\t\tlimit[maxLen] = pp + temp[maxLen] - 1;\n\t\tlimit[maxLen+1] = INT_MAX; /* Sentinel value for reading next sym. */\n\t\tbase[minLen] = 0;\n\t}\n\n\t/* We've finished reading and digesting the block header.  Now read this\n\t   block's Huffman coded symbols from the file and undo the Huffman coding\n\t   and run length encoding, saving the result into dbuf[dbufCount++] = uc */\n\n\t/* Initialize symbol occurrence counters and symbol Move To Front table */\n\t/*memset(byteCount, 0, sizeof(byteCount)); - smaller, but slower */\n\tfor (i = 0; i < 256; i++) {\n\t\tbyteCount[i] = 0;\n\t\tmtfSymbol[i] = (uint8_t)i;\n\t}\n\n\t/* Loop through compressed symbols. */\n\n\trunPos = dbufCount = selector = 0;\n\tfor (;;) {\n\t\tint nextSym;\n\n\t\t/* Fetch next Huffman coding group from list. */\n\t\tsymCount = GROUP_SIZE - 1;\n\t\tif (selector >= nSelectors) return RETVAL_DATA_ERROR;\n\t\thufGroup = bd->groups + selectors[selector++];\n\t\tbase = hufGroup->base - 1;\n\t\tlimit = hufGroup->limit - 1;\n\n continue_this_group:\n\t\t/* Read next Huffman-coded symbol. */\n\n\t\t/* Note: It is far cheaper to read maxLen bits and back up than it is\n\t\t   to read minLen bits and then add additional bit at a time, testing\n\t\t   as we go.  Because there is a trailing last block (with file CRC),\n\t\t   there is no danger of the overread causing an unexpected EOF for a\n\t\t   valid compressed file.\n\t\t */\n\t\tif (1) {\n\t\t\t/* As a further optimization, we do the read inline\n\t\t\t   (falling back to a call to get_bits if the buffer runs dry).\n\t\t\t */\n\t\t\tint new_cnt;\n\t\t\twhile ((new_cnt = bd->inbufBitCount - hufGroup->maxLen) < 0) {\n\t\t\t\t/* bd->inbufBitCount < hufGroup->maxLen */\n\t\t\t\tif (bd->inbufPos == bd->inbufCount) {\n\t\t\t\t\tnextSym = get_bits(bd, hufGroup->maxLen);\n\t\t\t\t\tgoto got_huff_bits;\n\t\t\t\t}\n\t\t\t\tbd->inbufBits = (bd->inbufBits << 8) | bd->inbuf[bd->inbufPos++];\n\t\t\t\tbd->inbufBitCount += 8;\n\t\t\t};\n\t\t\tbd->inbufBitCount = new_cnt; /* \"bd->inbufBitCount -= hufGroup->maxLen;\" */\n\t\t\tnextSym = (bd->inbufBits >> new_cnt) & ((1 << hufGroup->maxLen) - 1);\n got_huff_bits: ;\n\t\t} else { /* unoptimized equivalent */\n\t\t\tnextSym = get_bits(bd, hufGroup->maxLen);\n\t\t}\n\t\t/* Figure how many bits are in next symbol and unget extras */\n\t\ti = hufGroup->minLen;\n\t\twhile (nextSym > limit[i]) ++i;\n\t\tj = hufGroup->maxLen - i;\n\t\tif (j < 0)\n\t\t\treturn RETVAL_DATA_ERROR;\n\t\tbd->inbufBitCount += j;\n\n\t\t/* Huffman decode value to get nextSym (with bounds checking) */\n\t\tnextSym = (nextSym >> j) - base[i];\n\t\tif ((unsigned)nextSym >= MAX_SYMBOLS)\n\t\t\treturn RETVAL_DATA_ERROR;\n\t\tnextSym = hufGroup->permute[nextSym];\n\n\t\t/* We have now decoded the symbol, which indicates either a new literal\n\t\t   byte, or a repeated run of the most recent literal byte.  First,\n\t\t   check if nextSym indicates a repeated run, and if so loop collecting\n\t\t   how many times to repeat the last literal. */\n\t\tif ((unsigned)nextSym <= SYMBOL_RUNB) { /* RUNA or RUNB */\n\n\t\t\t/* If this is the start of a new run, zero out counter */\n\t\t\tif (runPos == 0) {\n\t\t\t\trunPos = 1;\n\t\t\t\trunCnt = 0;\n\t\t\t}\n\n\t\t\t/* Neat trick that saves 1 symbol: instead of or-ing 0 or 1 at\n\t\t\t   each bit position, add 1 or 2 instead.  For example,\n\t\t\t   1011 is 1<<0 + 1<<1 + 2<<2.  1010 is 2<<0 + 2<<1 + 1<<2.\n\t\t\t   You can make any bit pattern that way using 1 less symbol than\n\t\t\t   the basic or 0/1 method (except all bits 0, which would use no\n \t\t\t   symbols, but a run of length 0 doesn't mean anything in this\n \t\t\t   context).  Thus space is saved. */\n \t\t\trunCnt += (runPos << nextSym); /* +runPos if RUNA; +2*runPos if RUNB */\n////The 32-bit overflow of runCnt wasn't yet seen, but probably can happen.\n////This would be the fix (catches too large count way before it can overflow):\n////\t\t\tif (runCnt > bd->dbufSize) {\n////\t\t\t\tdbg(\"runCnt:%u > dbufSize:%u RETVAL_DATA_ERROR\",\n////\t\t\t\t\t\trunCnt, bd->dbufSize);\n////\t\t\t\treturn RETVAL_DATA_ERROR;\n////\t\t\t}\n\t\t\tif (runPos < bd->dbufSize) runPos <<= 1;\n \t\t\tgoto end_of_huffman_loop;\n \t\t}\n \n\t\t\t\tdbg(\"dbufCount:%d+runCnt:%d %d > dbufSize:%d RETVAL_DATA_ERROR\",\n\t\t\t\t\t\tdbufCount, runCnt, dbufCount + runCnt, dbufSize);\n\t\t\t\treturn RETVAL_DATA_ERROR;\n \t\t   literal used is the one at the head of the mtfSymbol array.) */\n \t\tif (runPos != 0) {\n \t\t\tuint8_t tmp_byte;\n\t\t\tif (dbufCount + runCnt > bd->dbufSize) {\n\t\t\t\tdbg(\"dbufCount:%u+runCnt:%u %u > dbufSize:%u RETVAL_DATA_ERROR\",\n\t\t\t\t\t\tdbufCount, runCnt, dbufCount + runCnt, bd->dbufSize);\n \t\t\t\treturn RETVAL_DATA_ERROR;\n \t\t\t}\n \t\t\ttmp_byte = symToByte[mtfSymbol[0]];\n \t\t\tbyteCount[tmp_byte] += runCnt;\n\t\t\twhile ((int)--runCnt >= 0)\n\t\t\t\tdbuf[dbufCount++] = (uint32_t)tmp_byte;\n \t\t\trunPos = 0;\n \t\t}\n \n\t\t   as part of a run above.  Therefore 1 unused mtf position minus\n\t\t   2 non-literal nextSym values equals -1.) */\n\t\tif (dbufCount >= dbufSize) return RETVAL_DATA_ERROR;\n\t\ti = nextSym - 1;\n\t\tuc = mtfSymbol[i];\n\n\t\t/* Adjust the MTF array.  Since we typically expect to move only a\n \t\t   first symbol in the mtf array, position 0, would have been handled\n \t\t   as part of a run above.  Therefore 1 unused mtf position minus\n \t\t   2 non-literal nextSym values equals -1.) */\n\t\tif (dbufCount >= bd->dbufSize) return RETVAL_DATA_ERROR;\n \t\ti = nextSym - 1;\n \t\tuc = mtfSymbol[i];\n\t\tuc = symToByte[uc];\n\n\t\t/* We have our literal byte.  Save it into dbuf. */\n\t\tbyteCount[uc]++;\n\t\tdbuf[dbufCount++] = (uint32_t)uc;\n\n\t\t/* Skip group initialization if we're not done with this group.  Done\n\t\t * this way to avoid compiler warning. */\n end_of_huffman_loop:\n\t\tif (--symCount >= 0) goto continue_this_group;\n\t}\n\n\t/* At this point, we've read all the Huffman-coded symbols (and repeated\n\t   runs) for this block from the input stream, and decoded them into the\n\t   intermediate buffer.  There are dbufCount many decoded bytes in dbuf[].\n\t   Now undo the Burrows-Wheeler transform on dbuf.\n\t   See http://dogma.net/markn/articles/bwt/bwt.htm\n\t */\n\n\t/* Turn byteCount into cumulative occurrence counts of 0 to n-1. */\n\tj = 0;\n\tfor (i = 0; i < 256; i++) {\n\t\tint tmp_count = j + byteCount[i];\n\t\tbyteCount[i] = j;\n\t\tj = tmp_count;\n\t}\n\n\t/* Figure out what order dbuf would be in if we sorted it. */\n\tfor (i = 0; i < dbufCount; i++) {\n\t\tuint8_t tmp_byte = (uint8_t)dbuf[i];\n\t\tint tmp_count = byteCount[tmp_byte];\n\t\tdbuf[tmp_count] |= (i << 8);\n\t\tbyteCount[tmp_byte] = tmp_count + 1;\n\t}\n\n\t/* Decode first byte by hand to initialize \"previous\" byte.  Note that it\n\t   doesn't get output, and if the first three characters are identical\n\t   it doesn't qualify as a run (hence writeRunCountdown=5). */\n\tif (dbufCount) {\n\t\tuint32_t tmp;\n\t\tif ((int)origPtr >= dbufCount) return RETVAL_DATA_ERROR;\n\t\ttmp = dbuf[origPtr];\n\t\tbd->writeCurrent = (uint8_t)tmp;\n\t\tbd->writePos = (tmp >> 8);\n\t\tbd->writeRunCountdown = 5;\n\t}\n\tbd->writeCount = dbufCount;\n\n\treturn RETVAL_OK;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141370,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "XFixesFetchRegionAndBounds (Display\t    *dpy,\n\t\t\t    XserverRegion   region,\n\t\t\t    int\t\t    *nrectanglesRet,\n\t\t\t    XRectangle\t    *bounds)\n{\n    XFixesExtDisplayInfo\t*info = XFixesFindDisplay (dpy);\n    xXFixesFetchRegionReq\t*req;\n    xXFixesFetchRegionReply\trep;\n    XRectangle\t\t\t*rects;\n    int    \t\t\tnrects;\n    long    \t\t\tnbytes;\n    long\t\t\tnread;\n\n    XFixesCheckExtension (dpy, info, NULL);\n    LockDisplay (dpy);\n    GetReq (XFixesFetchRegion, req);\n    req->reqType = info->codes->major_opcode;\n    req->xfixesReqType = X_XFixesFetchRegion;\n    req->region = region;\n    *nrectanglesRet = 0;\n    if (!_XReply (dpy, (xReply *) &rep, 0, xFalse))\n    {\n\tUnlockDisplay (dpy);\n\tSyncHandle ();\n\treturn NULL;\n    }\n    bounds->x = rep.x;\n    bounds->y = rep.y;\n     bounds->y = rep.y;\n     bounds->width = rep.width;\n     bounds->height = rep.height;\n    nbytes = (long) rep.length << 2;\n    nrects = rep.length >> 1;\n    rects = Xmalloc (nrects * sizeof (XRectangle));\n     if (!rects)\n     {\n \t_XEatDataWords(dpy, rep.length);\n\t_XEatData (dpy, (unsigned long) (nbytes - nread));\n    }\n    UnlockDisplay (dpy);\n    SyncHandle();\n    *nrectanglesRet = nrects;\n    return rects;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141489,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "XFixesFetchRegionAndBounds (Display\t    *dpy,\n\t\t\t    XserverRegion   region,\n\t\t\t    int\t\t    *nrectanglesRet,\n\t\t\t    XRectangle\t    *bounds)\n{\n    XFixesExtDisplayInfo\t*info = XFixesFindDisplay (dpy);\n    xXFixesFetchRegionReq\t*req;\n    xXFixesFetchRegionReply\trep;\n    XRectangle\t\t\t*rects;\n    int    \t\t\tnrects;\n    long    \t\t\tnbytes;\n    long\t\t\tnread;\n\n    XFixesCheckExtension (dpy, info, NULL);\n    LockDisplay (dpy);\n    GetReq (XFixesFetchRegion, req);\n    req->reqType = info->codes->major_opcode;\n    req->xfixesReqType = X_XFixesFetchRegion;\n    req->region = region;\n    *nrectanglesRet = 0;\n    if (!_XReply (dpy, (xReply *) &rep, 0, xFalse))\n    {\n\tUnlockDisplay (dpy);\n\tSyncHandle ();\n\treturn NULL;\n    }\n    bounds->x = rep.x;\n    bounds->y = rep.y;\n     bounds->y = rep.y;\n     bounds->width = rep.width;\n     bounds->height = rep.height;\n\n    if (rep.length < (INT_MAX >> 2)) {\n\tnbytes = (long) rep.length << 2;\n\tnrects = rep.length >> 1;\n\trects = Xmalloc (nrects * sizeof (XRectangle));\n    } else {\n\tnbytes = 0;\n\tnrects = 0;\n\trects = NULL;\n    }\n\n     if (!rects)\n     {\n \t_XEatDataWords(dpy, rep.length);\n\t_XEatData (dpy, (unsigned long) (nbytes - nread));\n    }\n    UnlockDisplay (dpy);\n    SyncHandle();\n    *nrectanglesRet = nrects;\n    return rects;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141490,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "int vrend_create_shader(struct vrend_context *ctx,\n                        uint32_t handle,\n                        const struct pipe_stream_output_info *so_info,\n                        const char *shd_text, uint32_t offlen, uint32_t num_tokens,\n                        uint32_t type, uint32_t pkt_length)\n{\n   struct vrend_shader_selector *sel = NULL;\n   int ret_handle;\n   bool new_shader = true, long_shader = false;\n   bool finished = false;\n   int ret;\n\n   if (type > PIPE_SHADER_GEOMETRY)\n      return EINVAL;\n\n   if (offlen & VIRGL_OBJ_SHADER_OFFSET_CONT)\n      new_shader = false;\n   else if (((offlen + 3) / 4) > pkt_length)\n      long_shader = true;\n\n   /* if we have an in progress one - don't allow a new shader\n      of that type or a different handle. */\n   if (ctx->sub->long_shader_in_progress_handle[type]) {\n      if (new_shader == true)\n         return EINVAL;\n      if (handle != ctx->sub->long_shader_in_progress_handle[type])\n         return EINVAL;\n   }\n\n   if (new_shader) {\n     sel = vrend_create_shader_state(ctx, so_info, type);\n     if (sel == NULL)\n       return ENOMEM;\n\n     if (long_shader) {\n        sel->buf_len = ((offlen + 3) / 4) * 4; /* round up buffer size */\n        sel->tmp_buf = malloc(sel->buf_len);\n        if (!sel->tmp_buf) {\n           ret = ENOMEM;\n           goto error;\n        }\n        memcpy(sel->tmp_buf, shd_text, pkt_length * 4);\n        sel->buf_offset = pkt_length * 4;\n        ctx->sub->long_shader_in_progress_handle[type] = handle;\n     } else\n        finished = true;\n   } else {\n      sel = vrend_object_lookup(ctx->sub->object_hash, handle, VIRGL_OBJECT_SHADER);\n      if (!sel) {\n         fprintf(stderr, \"got continuation without original shader %d\\n\", handle);\n         ret = EINVAL;\n         goto error;\n      }\n\n      offlen &= ~VIRGL_OBJ_SHADER_OFFSET_CONT;\n      if (offlen != sel->buf_offset) {\n         fprintf(stderr, \"Got mismatched shader continuation %d vs %d\\n\",\n                 offlen, sel->buf_offset);\n          ret = EINVAL;\n          goto error;\n       }\n       if ((pkt_length * 4 + sel->buf_offset) > sel->buf_len) {\n          fprintf(stderr, \"Got too large shader continuation %d vs %d\\n\",\n                  pkt_length * 4 + sel->buf_offset, sel->buf_len);\n         shd_text = sel->tmp_buf;\n      }\n   }\n\n   if (finished) {\n      struct tgsi_token *tokens;\n\n      tokens = calloc(num_tokens + 10, sizeof(struct tgsi_token));\n      if (!tokens) {\n         ret = ENOMEM;\n         goto error;\n      }\n\n      if (vrend_dump_shaders)\n         fprintf(stderr,\"shader\\n%s\\n\", shd_text);\n      if (!tgsi_text_translate((const char *)shd_text, tokens, num_tokens + 10)) {\n         free(tokens);\n         ret = EINVAL;\n         goto error;\n      }\n\n      if (vrend_finish_shader(ctx, sel, tokens)) {\n         free(tokens);\n         ret = EINVAL;\n         goto error;\n      } else {\n         free(sel->tmp_buf);\n         sel->tmp_buf = NULL;\n      }\n      free(tokens);\n      ctx->sub->long_shader_in_progress_handle[type] = 0;\n   }\n\n   if (new_shader) {\n      ret_handle = vrend_renderer_object_insert(ctx, sel, sizeof(*sel), handle, VIRGL_OBJECT_SHADER);\n      if (ret_handle == 0) {\n         ret = ENOMEM;\n         goto error;\n      }\n   }\n\n   return 0;\n\nerror:\n   if (new_shader)\n      vrend_destroy_shader_selector(sel);\n   else\n      vrend_renderer_object_destroy(ctx, handle);\n\n   return ret;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141499,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "int vrend_create_shader(struct vrend_context *ctx,\n                        uint32_t handle,\n                        const struct pipe_stream_output_info *so_info,\n                        const char *shd_text, uint32_t offlen, uint32_t num_tokens,\n                        uint32_t type, uint32_t pkt_length)\n{\n   struct vrend_shader_selector *sel = NULL;\n   int ret_handle;\n   bool new_shader = true, long_shader = false;\n   bool finished = false;\n   int ret;\n\n   if (type > PIPE_SHADER_GEOMETRY)\n      return EINVAL;\n\n   if (offlen & VIRGL_OBJ_SHADER_OFFSET_CONT)\n      new_shader = false;\n   else if (((offlen + 3) / 4) > pkt_length)\n      long_shader = true;\n\n   /* if we have an in progress one - don't allow a new shader\n      of that type or a different handle. */\n   if (ctx->sub->long_shader_in_progress_handle[type]) {\n      if (new_shader == true)\n         return EINVAL;\n      if (handle != ctx->sub->long_shader_in_progress_handle[type])\n         return EINVAL;\n   }\n\n   if (new_shader) {\n     sel = vrend_create_shader_state(ctx, so_info, type);\n     if (sel == NULL)\n       return ENOMEM;\n\n     if (long_shader) {\n        sel->buf_len = ((offlen + 3) / 4) * 4; /* round up buffer size */\n        sel->tmp_buf = malloc(sel->buf_len);\n        if (!sel->tmp_buf) {\n           ret = ENOMEM;\n           goto error;\n        }\n        memcpy(sel->tmp_buf, shd_text, pkt_length * 4);\n        sel->buf_offset = pkt_length * 4;\n        ctx->sub->long_shader_in_progress_handle[type] = handle;\n     } else\n        finished = true;\n   } else {\n      sel = vrend_object_lookup(ctx->sub->object_hash, handle, VIRGL_OBJECT_SHADER);\n      if (!sel) {\n         fprintf(stderr, \"got continuation without original shader %d\\n\", handle);\n         ret = EINVAL;\n         goto error;\n      }\n\n      offlen &= ~VIRGL_OBJ_SHADER_OFFSET_CONT;\n      if (offlen != sel->buf_offset) {\n         fprintf(stderr, \"Got mismatched shader continuation %d vs %d\\n\",\n                 offlen, sel->buf_offset);\n          ret = EINVAL;\n          goto error;\n       }\n\n      /*make sure no overflow */\n      if (pkt_length * 4 < pkt_length ||\n          pkt_length * 4 + sel->buf_offset < pkt_length * 4 ||\n          pkt_length * 4 + sel->buf_offset < sel->buf_offset) {\n            ret = EINVAL;\n            goto error;\n          }\n\n       if ((pkt_length * 4 + sel->buf_offset) > sel->buf_len) {\n          fprintf(stderr, \"Got too large shader continuation %d vs %d\\n\",\n                  pkt_length * 4 + sel->buf_offset, sel->buf_len);\n         shd_text = sel->tmp_buf;\n      }\n   }\n\n   if (finished) {\n      struct tgsi_token *tokens;\n\n      tokens = calloc(num_tokens + 10, sizeof(struct tgsi_token));\n      if (!tokens) {\n         ret = ENOMEM;\n         goto error;\n      }\n\n      if (vrend_dump_shaders)\n         fprintf(stderr,\"shader\\n%s\\n\", shd_text);\n      if (!tgsi_text_translate((const char *)shd_text, tokens, num_tokens + 10)) {\n         free(tokens);\n         ret = EINVAL;\n         goto error;\n      }\n\n      if (vrend_finish_shader(ctx, sel, tokens)) {\n         free(tokens);\n         ret = EINVAL;\n         goto error;\n      } else {\n         free(sel->tmp_buf);\n         sel->tmp_buf = NULL;\n      }\n      free(tokens);\n      ctx->sub->long_shader_in_progress_handle[type] = 0;\n   }\n\n   if (new_shader) {\n      ret_handle = vrend_renderer_object_insert(ctx, sel, sizeof(*sel), handle, VIRGL_OBJECT_SHADER);\n      if (ret_handle == 0) {\n         ret = ENOMEM;\n         goto error;\n      }\n   }\n\n   return 0;\n\nerror:\n   if (new_shader)\n      vrend_destroy_shader_selector(sel);\n   else\n      vrend_renderer_object_destroy(ctx, handle);\n\n   return ret;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141500,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "void *nlmsg_reserve(struct nl_msg *n, size_t len, int pad)\n{\n\tvoid *buf = n->nm_nlh;\n        size_t nlmsg_len = n->nm_nlh->nlmsg_len;\n        size_t tlen;\n \n        tlen = pad ? ((len + (pad - 1)) & ~(pad - 1)) : len;\n \n        if ((tlen + nlmsg_len) > n->nm_size)\n\tn->nm_nlh->nlmsg_len += tlen;\n\n\tif (tlen > len)\n\t\tmemset(buf + len, 0, tlen - len);\n\n\tNL_DBG(2, \"msg %p: Reserved %zu (%zu) bytes, pad=%d, nlmsg_len=%d\\n\",\n\t\t  n, tlen, len, pad, n->nm_nlh->nlmsg_len);\n\n\treturn buf;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141573,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "void *nlmsg_reserve(struct nl_msg *n, size_t len, int pad)\n{\n\tvoid *buf = n->nm_nlh;\n        size_t nlmsg_len = n->nm_nlh->nlmsg_len;\n        size_t tlen;\n \n       if (len > n->nm_size)\n               return NULL;\n\n        tlen = pad ? ((len + (pad - 1)) & ~(pad - 1)) : len;\n \n        if ((tlen + nlmsg_len) > n->nm_size)\n\tn->nm_nlh->nlmsg_len += tlen;\n\n\tif (tlen > len)\n\t\tmemset(buf + len, 0, tlen - len);\n\n\tNL_DBG(2, \"msg %p: Reserved %zu (%zu) bytes, pad=%d, nlmsg_len=%d\\n\",\n\t\t  n, tlen, len, pad, n->nm_nlh->nlmsg_len);\n\n\treturn buf;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141574,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "SProcXIBarrierReleasePointer(ClientPtr client)\n{\n    xXIBarrierReleasePointerInfo *info;\n    REQUEST(xXIBarrierReleasePointerReq);\n    int i;\n\n    swaps(&stuff->length);\n     REQUEST_AT_LEAST_SIZE(xXIBarrierReleasePointerReq);\n \n     swapl(&stuff->num_barriers);\n     REQUEST_FIXED_SIZE(xXIBarrierReleasePointerReq, stuff->num_barriers * sizeof(xXIBarrierReleasePointerInfo));\n \n     info = (xXIBarrierReleasePointerInfo*) &stuff[1];\n        swapl(&info->barrier);\n        swapl(&info->eventid);\n    }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141647,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "SProcXIBarrierReleasePointer(ClientPtr client)\n{\n    xXIBarrierReleasePointerInfo *info;\n    REQUEST(xXIBarrierReleasePointerReq);\n    int i;\n\n    swaps(&stuff->length);\n     REQUEST_AT_LEAST_SIZE(xXIBarrierReleasePointerReq);\n \n     swapl(&stuff->num_barriers);\n    if (stuff->num_barriers > UINT32_MAX / sizeof(xXIBarrierReleasePointerInfo))\n        return BadLength;\n     REQUEST_FIXED_SIZE(xXIBarrierReleasePointerReq, stuff->num_barriers * sizeof(xXIBarrierReleasePointerInfo));\n \n     info = (xXIBarrierReleasePointerInfo*) &stuff[1];\n        swapl(&info->barrier);\n        swapl(&info->eventid);\n    }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141648,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "ProcDbeGetVisualInfo(ClientPtr client)\n{\n    REQUEST(xDbeGetVisualInfoReq);\n    DbeScreenPrivPtr pDbeScreenPriv;\n    xDbeGetVisualInfoReply rep;\n    Drawable *drawables;\n    DrawablePtr *pDrawables = NULL;\n    register int i, j, rc;\n    register int count;         /* number of visual infos in reply */\n    register int length;        /* length of reply */\n    ScreenPtr pScreen;\n     XdbeScreenVisualInfo *pScrVisInfo;\n \n     REQUEST_AT_LEAST_SIZE(xDbeGetVisualInfoReq);\n \n     if (stuff->n > UINT32_MAX / sizeof(DrawablePtr))\n         return BadAlloc;\n            return BadAlloc;\n        }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141651,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "ProcDbeGetVisualInfo(ClientPtr client)\n{\n    REQUEST(xDbeGetVisualInfoReq);\n    DbeScreenPrivPtr pDbeScreenPriv;\n    xDbeGetVisualInfoReply rep;\n    Drawable *drawables;\n    DrawablePtr *pDrawables = NULL;\n    register int i, j, rc;\n    register int count;         /* number of visual infos in reply */\n    register int length;        /* length of reply */\n    ScreenPtr pScreen;\n     XdbeScreenVisualInfo *pScrVisInfo;\n \n     REQUEST_AT_LEAST_SIZE(xDbeGetVisualInfoReq);\n    if (stuff->n > UINT32_MAX / sizeof(CARD32))\n        return BadLength;\n    REQUEST_FIXED_SIZE(xDbeGetVisualInfoReq, stuff->n * sizeof(CARD32));\n \n     if (stuff->n > UINT32_MAX / sizeof(DrawablePtr))\n         return BadAlloc;\n            return BadAlloc;\n        }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141652,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static long vfio_pci_ioctl(void *device_data,\n\t\t\t   unsigned int cmd, unsigned long arg)\n{\n\tstruct vfio_pci_device *vdev = device_data;\n\tunsigned long minsz;\n\n\tif (cmd == VFIO_DEVICE_GET_INFO) {\n\t\tstruct vfio_device_info info;\n\n\t\tminsz = offsetofend(struct vfio_device_info, num_irqs);\n\n\t\tif (copy_from_user(&info, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (info.argsz < minsz)\n\t\t\treturn -EINVAL;\n\n\t\tinfo.flags = VFIO_DEVICE_FLAGS_PCI;\n\n\t\tif (vdev->reset_works)\n\t\t\tinfo.flags |= VFIO_DEVICE_FLAGS_RESET;\n\n\t\tinfo.num_regions = VFIO_PCI_NUM_REGIONS + vdev->num_regions;\n\t\tinfo.num_irqs = VFIO_PCI_NUM_IRQS;\n\n\t\treturn copy_to_user((void __user *)arg, &info, minsz) ?\n\t\t\t-EFAULT : 0;\n\n\t} else if (cmd == VFIO_DEVICE_GET_REGION_INFO) {\n\t\tstruct pci_dev *pdev = vdev->pdev;\n\t\tstruct vfio_region_info info;\n\t\tstruct vfio_info_cap caps = { .buf = NULL, .size = 0 };\n\t\tint i, ret;\n\n\t\tminsz = offsetofend(struct vfio_region_info, offset);\n\n\t\tif (copy_from_user(&info, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (info.argsz < minsz)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (info.index) {\n\t\tcase VFIO_PCI_CONFIG_REGION_INDEX:\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.size = pdev->cfg_size;\n\t\t\tinfo.flags = VFIO_REGION_INFO_FLAG_READ |\n\t\t\t\t     VFIO_REGION_INFO_FLAG_WRITE;\n\t\t\tbreak;\n\t\tcase VFIO_PCI_BAR0_REGION_INDEX ... VFIO_PCI_BAR5_REGION_INDEX:\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.size = pci_resource_len(pdev, info.index);\n\t\t\tif (!info.size) {\n\t\t\t\tinfo.flags = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tinfo.flags = VFIO_REGION_INFO_FLAG_READ |\n\t\t\t\t     VFIO_REGION_INFO_FLAG_WRITE;\n\t\t\tif (vdev->bar_mmap_supported[info.index]) {\n\t\t\t\tinfo.flags |= VFIO_REGION_INFO_FLAG_MMAP;\n\t\t\t\tif (info.index == vdev->msix_bar) {\n\t\t\t\t\tret = msix_sparse_mmap_cap(vdev, &caps);\n\t\t\t\t\tif (ret)\n\t\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase VFIO_PCI_ROM_REGION_INDEX:\n\t\t{\n\t\t\tvoid __iomem *io;\n\t\t\tsize_t size;\n\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.flags = 0;\n\n\t\t\t/* Report the BAR size, not the ROM size */\n\t\t\tinfo.size = pci_resource_len(pdev, info.index);\n\t\t\tif (!info.size) {\n\t\t\t\t/* Shadow ROMs appear as PCI option ROMs */\n\t\t\t\tif (pdev->resource[PCI_ROM_RESOURCE].flags &\n\t\t\t\t\t\t\tIORESOURCE_ROM_SHADOW)\n\t\t\t\t\tinfo.size = 0x20000;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Is it really there? */\n\t\t\tio = pci_map_rom(pdev, &size);\n\t\t\tif (!io || !size) {\n\t\t\t\tinfo.size = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpci_unmap_rom(pdev, io);\n\n\t\t\tinfo.flags = VFIO_REGION_INFO_FLAG_READ;\n\t\t\tbreak;\n\t\t}\n\t\tcase VFIO_PCI_VGA_REGION_INDEX:\n\t\t\tif (!vdev->has_vga)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.size = 0xc0000;\n\t\t\tinfo.flags = VFIO_REGION_INFO_FLAG_READ |\n\t\t\t\t     VFIO_REGION_INFO_FLAG_WRITE;\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (info.index >=\n\t\t\t    VFIO_PCI_NUM_REGIONS + vdev->num_regions)\n\t\t\t\treturn -EINVAL;\n\n\t\t\ti = info.index - VFIO_PCI_NUM_REGIONS;\n\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.size = vdev->region[i].size;\n\t\t\tinfo.flags = vdev->region[i].flags;\n\n\t\t\tret = region_type_cap(vdev, &caps,\n\t\t\t\t\t      vdev->region[i].type,\n\t\t\t\t\t      vdev->region[i].subtype);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tif (caps.size) {\n\t\t\tinfo.flags |= VFIO_REGION_INFO_FLAG_CAPS;\n\t\t\tif (info.argsz < sizeof(info) + caps.size) {\n\t\t\t\tinfo.argsz = sizeof(info) + caps.size;\n\t\t\t\tinfo.cap_offset = 0;\n\t\t\t} else {\n\t\t\t\tvfio_info_cap_shift(&caps, sizeof(info));\n\t\t\t\tif (copy_to_user((void __user *)arg +\n\t\t\t\t\t\t  sizeof(info), caps.buf,\n\t\t\t\t\t\t  caps.size)) {\n\t\t\t\t\tkfree(caps.buf);\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\t}\n\t\t\t\tinfo.cap_offset = sizeof(info);\n\t\t\t}\n\n\t\t\tkfree(caps.buf);\n\t\t}\n\n\t\treturn copy_to_user((void __user *)arg, &info, minsz) ?\n\t\t\t-EFAULT : 0;\n\n\t} else if (cmd == VFIO_DEVICE_GET_IRQ_INFO) {\n\t\tstruct vfio_irq_info info;\n\n\t\tminsz = offsetofend(struct vfio_irq_info, count);\n\n\t\tif (copy_from_user(&info, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (info.argsz < minsz || info.index >= VFIO_PCI_NUM_IRQS)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (info.index) {\n\t\tcase VFIO_PCI_INTX_IRQ_INDEX ... VFIO_PCI_MSIX_IRQ_INDEX:\n\t\tcase VFIO_PCI_REQ_IRQ_INDEX:\n\t\t\tbreak;\n\t\tcase VFIO_PCI_ERR_IRQ_INDEX:\n\t\t\tif (pci_is_pcie(vdev->pdev))\n\t\t\t\tbreak;\n\t\t/* pass thru to return error */\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tinfo.flags = VFIO_IRQ_INFO_EVENTFD;\n\n\t\tinfo.count = vfio_pci_get_irq_count(vdev, info.index);\n\n\t\tif (info.index == VFIO_PCI_INTX_IRQ_INDEX)\n\t\t\tinfo.flags |= (VFIO_IRQ_INFO_MASKABLE |\n\t\t\t\t       VFIO_IRQ_INFO_AUTOMASKED);\n\t\telse\n\t\t\tinfo.flags |= VFIO_IRQ_INFO_NORESIZE;\n\n\t\treturn copy_to_user((void __user *)arg, &info, minsz) ?\n\t\t\t-EFAULT : 0;\n \n \t} else if (cmd == VFIO_DEVICE_SET_IRQS) {\n \t\tstruct vfio_irq_set hdr;\n \t\tu8 *data = NULL;\n\t\tint ret = 0;\n \n \t\tminsz = offsetofend(struct vfio_irq_set, count);\n \n \t\tif (copy_from_user(&hdr, (void __user *)arg, minsz))\n \t\t\treturn -EFAULT;\n \n \t\tif (hdr.argsz < minsz || hdr.index >= VFIO_PCI_NUM_IRQS ||\n \t\t    hdr.flags & ~(VFIO_IRQ_SET_DATA_TYPE_MASK |\n \t\t\t\t  VFIO_IRQ_SET_ACTION_TYPE_MASK))\n \t\t\treturn -EINVAL;\n \n\t\tif (!(hdr.flags & VFIO_IRQ_SET_DATA_NONE)) {\n\t\t\tsize_t size;\n\t\t\tint max = vfio_pci_get_irq_count(vdev, hdr.index);\n \n\t\t\tif (hdr.flags & VFIO_IRQ_SET_DATA_BOOL)\n\t\t\t\tsize = sizeof(uint8_t);\n\t\t\telse if (hdr.flags & VFIO_IRQ_SET_DATA_EVENTFD)\n\t\t\t\tsize = sizeof(int32_t);\n\t\t\telse\n\t\t\t\treturn -EINVAL;\n \n\t\t\tif (hdr.argsz - minsz < hdr.count * size ||\n\t\t\t    hdr.start >= max || hdr.start + hdr.count > max)\n \t\t\t\treturn -EINVAL;\n \n \t\t\tdata = memdup_user((void __user *)(arg + minsz),\n\t\t\t\t\t   hdr.count * size);\n\t\t\tif (IS_ERR(data))\n\t\t\t\treturn PTR_ERR(data);\n\t\t}\n\n\t\tmutex_lock(&vdev->igate);\n\n\t\tret = vfio_pci_set_irqs_ioctl(vdev, hdr.flags, hdr.index,\n\t\t\t\t\t      hdr.start, hdr.count, data);\n\n\t\tmutex_unlock(&vdev->igate);\n\t\tkfree(data);\n\n\t\treturn ret;\n\n\t} else if (cmd == VFIO_DEVICE_RESET) {\n\t\treturn vdev->reset_works ?\n\t\t\tpci_try_reset_function(vdev->pdev) : -EINVAL;\n\n\t} else if (cmd == VFIO_DEVICE_GET_PCI_HOT_RESET_INFO) {\n\t\tstruct vfio_pci_hot_reset_info hdr;\n\t\tstruct vfio_pci_fill_info fill = { 0 };\n\t\tstruct vfio_pci_dependent_device *devices = NULL;\n\t\tbool slot = false;\n\t\tint ret = 0;\n\n\t\tminsz = offsetofend(struct vfio_pci_hot_reset_info, count);\n\n\t\tif (copy_from_user(&hdr, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (hdr.argsz < minsz)\n\t\t\treturn -EINVAL;\n\n\t\thdr.flags = 0;\n\n\t\t/* Can we do a slot or bus reset or neither? */\n\t\tif (!pci_probe_reset_slot(vdev->pdev->slot))\n\t\t\tslot = true;\n\t\telse if (pci_probe_reset_bus(vdev->pdev->bus))\n\t\t\treturn -ENODEV;\n\n\t\t/* How many devices are affected? */\n\t\tret = vfio_pci_for_each_slot_or_bus(vdev->pdev,\n\t\t\t\t\t\t    vfio_pci_count_devs,\n\t\t\t\t\t\t    &fill.max, slot);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tWARN_ON(!fill.max); /* Should always be at least one */\n\n\t\t/*\n\t\t * If there's enough space, fill it now, otherwise return\n\t\t * -ENOSPC and the number of devices affected.\n\t\t */\n\t\tif (hdr.argsz < sizeof(hdr) + (fill.max * sizeof(*devices))) {\n\t\t\tret = -ENOSPC;\n\t\t\thdr.count = fill.max;\n\t\t\tgoto reset_info_exit;\n\t\t}\n\n\t\tdevices = kcalloc(fill.max, sizeof(*devices), GFP_KERNEL);\n\t\tif (!devices)\n\t\t\treturn -ENOMEM;\n\n\t\tfill.devices = devices;\n\n\t\tret = vfio_pci_for_each_slot_or_bus(vdev->pdev,\n\t\t\t\t\t\t    vfio_pci_fill_devs,\n\t\t\t\t\t\t    &fill, slot);\n\n\t\t/*\n\t\t * If a device was removed between counting and filling,\n\t\t * we may come up short of fill.max.  If a device was\n\t\t * added, we'll have a return of -EAGAIN above.\n\t\t */\n\t\tif (!ret)\n\t\t\thdr.count = fill.cur;\n\nreset_info_exit:\n\t\tif (copy_to_user((void __user *)arg, &hdr, minsz))\n\t\t\tret = -EFAULT;\n\n\t\tif (!ret) {\n\t\t\tif (copy_to_user((void __user *)(arg + minsz), devices,\n\t\t\t\t\t hdr.count * sizeof(*devices)))\n\t\t\t\tret = -EFAULT;\n\t\t}\n\n\t\tkfree(devices);\n\t\treturn ret;\n\n\t} else if (cmd == VFIO_DEVICE_PCI_HOT_RESET) {\n\t\tstruct vfio_pci_hot_reset hdr;\n\t\tint32_t *group_fds;\n\t\tstruct vfio_pci_group_entry *groups;\n\t\tstruct vfio_pci_group_info info;\n\t\tbool slot = false;\n\t\tint i, count = 0, ret = 0;\n\n\t\tminsz = offsetofend(struct vfio_pci_hot_reset, count);\n\n\t\tif (copy_from_user(&hdr, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (hdr.argsz < minsz || hdr.flags)\n\t\t\treturn -EINVAL;\n\n\t\t/* Can we do a slot or bus reset or neither? */\n\t\tif (!pci_probe_reset_slot(vdev->pdev->slot))\n\t\t\tslot = true;\n\t\telse if (pci_probe_reset_bus(vdev->pdev->bus))\n\t\t\treturn -ENODEV;\n\n\t\t/*\n\t\t * We can't let userspace give us an arbitrarily large\n\t\t * buffer to copy, so verify how many we think there\n\t\t * could be.  Note groups can have multiple devices so\n\t\t * one group per device is the max.\n\t\t */\n\t\tret = vfio_pci_for_each_slot_or_bus(vdev->pdev,\n\t\t\t\t\t\t    vfio_pci_count_devs,\n\t\t\t\t\t\t    &count, slot);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t/* Somewhere between 1 and count is OK */\n\t\tif (!hdr.count || hdr.count > count)\n\t\t\treturn -EINVAL;\n\n\t\tgroup_fds = kcalloc(hdr.count, sizeof(*group_fds), GFP_KERNEL);\n\t\tgroups = kcalloc(hdr.count, sizeof(*groups), GFP_KERNEL);\n\t\tif (!group_fds || !groups) {\n\t\t\tkfree(group_fds);\n\t\t\tkfree(groups);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (copy_from_user(group_fds, (void __user *)(arg + minsz),\n\t\t\t\t   hdr.count * sizeof(*group_fds))) {\n\t\t\tkfree(group_fds);\n\t\t\tkfree(groups);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\t/*\n\t\t * For each group_fd, get the group through the vfio external\n\t\t * user interface and store the group and iommu ID.  This\n\t\t * ensures the group is held across the reset.\n\t\t */\n\t\tfor (i = 0; i < hdr.count; i++) {\n\t\t\tstruct vfio_group *group;\n\t\t\tstruct fd f = fdget(group_fds[i]);\n\t\t\tif (!f.file) {\n\t\t\t\tret = -EBADF;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tgroup = vfio_group_get_external_user(f.file);\n\t\t\tfdput(f);\n\t\t\tif (IS_ERR(group)) {\n\t\t\t\tret = PTR_ERR(group);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tgroups[i].group = group;\n\t\t\tgroups[i].id = vfio_external_user_iommu_id(group);\n\t\t}\n\n\t\tkfree(group_fds);\n\n\t\t/* release reference to groups on error */\n\t\tif (ret)\n\t\t\tgoto hot_reset_release;\n\n\t\tinfo.count = hdr.count;\n\t\tinfo.groups = groups;\n\n\t\t/*\n\t\t * Test whether all the affected devices are contained\n\t\t * by the set of groups provided by the user.\n\t\t */\n\t\tret = vfio_pci_for_each_slot_or_bus(vdev->pdev,\n\t\t\t\t\t\t    vfio_pci_validate_devs,\n\t\t\t\t\t\t    &info, slot);\n\t\tif (!ret)\n\t\t\t/* User has access, do the reset */\n\t\t\tret = slot ? pci_try_reset_slot(vdev->pdev->slot) :\n\t\t\t\t     pci_try_reset_bus(vdev->pdev->bus);\n\nhot_reset_release:\n\t\tfor (i--; i >= 0; i--)\n\t\t\tvfio_group_put_external_user(groups[i].group);\n\n\t\tkfree(groups);\n\t\treturn ret;\n\t}\n\n\treturn -ENOTTY;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142053,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static long vfio_pci_ioctl(void *device_data,\n\t\t\t   unsigned int cmd, unsigned long arg)\n{\n\tstruct vfio_pci_device *vdev = device_data;\n\tunsigned long minsz;\n\n\tif (cmd == VFIO_DEVICE_GET_INFO) {\n\t\tstruct vfio_device_info info;\n\n\t\tminsz = offsetofend(struct vfio_device_info, num_irqs);\n\n\t\tif (copy_from_user(&info, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (info.argsz < minsz)\n\t\t\treturn -EINVAL;\n\n\t\tinfo.flags = VFIO_DEVICE_FLAGS_PCI;\n\n\t\tif (vdev->reset_works)\n\t\t\tinfo.flags |= VFIO_DEVICE_FLAGS_RESET;\n\n\t\tinfo.num_regions = VFIO_PCI_NUM_REGIONS + vdev->num_regions;\n\t\tinfo.num_irqs = VFIO_PCI_NUM_IRQS;\n\n\t\treturn copy_to_user((void __user *)arg, &info, minsz) ?\n\t\t\t-EFAULT : 0;\n\n\t} else if (cmd == VFIO_DEVICE_GET_REGION_INFO) {\n\t\tstruct pci_dev *pdev = vdev->pdev;\n\t\tstruct vfio_region_info info;\n\t\tstruct vfio_info_cap caps = { .buf = NULL, .size = 0 };\n\t\tint i, ret;\n\n\t\tminsz = offsetofend(struct vfio_region_info, offset);\n\n\t\tif (copy_from_user(&info, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (info.argsz < minsz)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (info.index) {\n\t\tcase VFIO_PCI_CONFIG_REGION_INDEX:\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.size = pdev->cfg_size;\n\t\t\tinfo.flags = VFIO_REGION_INFO_FLAG_READ |\n\t\t\t\t     VFIO_REGION_INFO_FLAG_WRITE;\n\t\t\tbreak;\n\t\tcase VFIO_PCI_BAR0_REGION_INDEX ... VFIO_PCI_BAR5_REGION_INDEX:\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.size = pci_resource_len(pdev, info.index);\n\t\t\tif (!info.size) {\n\t\t\t\tinfo.flags = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tinfo.flags = VFIO_REGION_INFO_FLAG_READ |\n\t\t\t\t     VFIO_REGION_INFO_FLAG_WRITE;\n\t\t\tif (vdev->bar_mmap_supported[info.index]) {\n\t\t\t\tinfo.flags |= VFIO_REGION_INFO_FLAG_MMAP;\n\t\t\t\tif (info.index == vdev->msix_bar) {\n\t\t\t\t\tret = msix_sparse_mmap_cap(vdev, &caps);\n\t\t\t\t\tif (ret)\n\t\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase VFIO_PCI_ROM_REGION_INDEX:\n\t\t{\n\t\t\tvoid __iomem *io;\n\t\t\tsize_t size;\n\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.flags = 0;\n\n\t\t\t/* Report the BAR size, not the ROM size */\n\t\t\tinfo.size = pci_resource_len(pdev, info.index);\n\t\t\tif (!info.size) {\n\t\t\t\t/* Shadow ROMs appear as PCI option ROMs */\n\t\t\t\tif (pdev->resource[PCI_ROM_RESOURCE].flags &\n\t\t\t\t\t\t\tIORESOURCE_ROM_SHADOW)\n\t\t\t\t\tinfo.size = 0x20000;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Is it really there? */\n\t\t\tio = pci_map_rom(pdev, &size);\n\t\t\tif (!io || !size) {\n\t\t\t\tinfo.size = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpci_unmap_rom(pdev, io);\n\n\t\t\tinfo.flags = VFIO_REGION_INFO_FLAG_READ;\n\t\t\tbreak;\n\t\t}\n\t\tcase VFIO_PCI_VGA_REGION_INDEX:\n\t\t\tif (!vdev->has_vga)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.size = 0xc0000;\n\t\t\tinfo.flags = VFIO_REGION_INFO_FLAG_READ |\n\t\t\t\t     VFIO_REGION_INFO_FLAG_WRITE;\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (info.index >=\n\t\t\t    VFIO_PCI_NUM_REGIONS + vdev->num_regions)\n\t\t\t\treturn -EINVAL;\n\n\t\t\ti = info.index - VFIO_PCI_NUM_REGIONS;\n\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.size = vdev->region[i].size;\n\t\t\tinfo.flags = vdev->region[i].flags;\n\n\t\t\tret = region_type_cap(vdev, &caps,\n\t\t\t\t\t      vdev->region[i].type,\n\t\t\t\t\t      vdev->region[i].subtype);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tif (caps.size) {\n\t\t\tinfo.flags |= VFIO_REGION_INFO_FLAG_CAPS;\n\t\t\tif (info.argsz < sizeof(info) + caps.size) {\n\t\t\t\tinfo.argsz = sizeof(info) + caps.size;\n\t\t\t\tinfo.cap_offset = 0;\n\t\t\t} else {\n\t\t\t\tvfio_info_cap_shift(&caps, sizeof(info));\n\t\t\t\tif (copy_to_user((void __user *)arg +\n\t\t\t\t\t\t  sizeof(info), caps.buf,\n\t\t\t\t\t\t  caps.size)) {\n\t\t\t\t\tkfree(caps.buf);\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\t}\n\t\t\t\tinfo.cap_offset = sizeof(info);\n\t\t\t}\n\n\t\t\tkfree(caps.buf);\n\t\t}\n\n\t\treturn copy_to_user((void __user *)arg, &info, minsz) ?\n\t\t\t-EFAULT : 0;\n\n\t} else if (cmd == VFIO_DEVICE_GET_IRQ_INFO) {\n\t\tstruct vfio_irq_info info;\n\n\t\tminsz = offsetofend(struct vfio_irq_info, count);\n\n\t\tif (copy_from_user(&info, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (info.argsz < minsz || info.index >= VFIO_PCI_NUM_IRQS)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (info.index) {\n\t\tcase VFIO_PCI_INTX_IRQ_INDEX ... VFIO_PCI_MSIX_IRQ_INDEX:\n\t\tcase VFIO_PCI_REQ_IRQ_INDEX:\n\t\t\tbreak;\n\t\tcase VFIO_PCI_ERR_IRQ_INDEX:\n\t\t\tif (pci_is_pcie(vdev->pdev))\n\t\t\t\tbreak;\n\t\t/* pass thru to return error */\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tinfo.flags = VFIO_IRQ_INFO_EVENTFD;\n\n\t\tinfo.count = vfio_pci_get_irq_count(vdev, info.index);\n\n\t\tif (info.index == VFIO_PCI_INTX_IRQ_INDEX)\n\t\t\tinfo.flags |= (VFIO_IRQ_INFO_MASKABLE |\n\t\t\t\t       VFIO_IRQ_INFO_AUTOMASKED);\n\t\telse\n\t\t\tinfo.flags |= VFIO_IRQ_INFO_NORESIZE;\n\n\t\treturn copy_to_user((void __user *)arg, &info, minsz) ?\n\t\t\t-EFAULT : 0;\n \n \t} else if (cmd == VFIO_DEVICE_SET_IRQS) {\n \t\tstruct vfio_irq_set hdr;\n\t\tsize_t size;\n \t\tu8 *data = NULL;\n\t\tint max, ret = 0;\n \n \t\tminsz = offsetofend(struct vfio_irq_set, count);\n \n \t\tif (copy_from_user(&hdr, (void __user *)arg, minsz))\n \t\t\treturn -EFAULT;\n \n \t\tif (hdr.argsz < minsz || hdr.index >= VFIO_PCI_NUM_IRQS ||\n\t\t    hdr.count >= (U32_MAX - hdr.start) ||\n \t\t    hdr.flags & ~(VFIO_IRQ_SET_DATA_TYPE_MASK |\n \t\t\t\t  VFIO_IRQ_SET_ACTION_TYPE_MASK))\n \t\t\treturn -EINVAL;\n \n\t\tmax = vfio_pci_get_irq_count(vdev, hdr.index);\n\t\tif (hdr.start >= max || hdr.start + hdr.count > max)\n\t\t\treturn -EINVAL;\n \n\t\tswitch (hdr.flags & VFIO_IRQ_SET_DATA_TYPE_MASK) {\n\t\tcase VFIO_IRQ_SET_DATA_NONE:\n\t\t\tsize = 0;\n\t\t\tbreak;\n\t\tcase VFIO_IRQ_SET_DATA_BOOL:\n\t\t\tsize = sizeof(uint8_t);\n\t\t\tbreak;\n\t\tcase VFIO_IRQ_SET_DATA_EVENTFD:\n\t\t\tsize = sizeof(int32_t);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n \n\t\tif (size) {\n\t\t\tif (hdr.argsz - minsz < hdr.count * size)\n \t\t\t\treturn -EINVAL;\n \n \t\t\tdata = memdup_user((void __user *)(arg + minsz),\n\t\t\t\t\t   hdr.count * size);\n\t\t\tif (IS_ERR(data))\n\t\t\t\treturn PTR_ERR(data);\n\t\t}\n\n\t\tmutex_lock(&vdev->igate);\n\n\t\tret = vfio_pci_set_irqs_ioctl(vdev, hdr.flags, hdr.index,\n\t\t\t\t\t      hdr.start, hdr.count, data);\n\n\t\tmutex_unlock(&vdev->igate);\n\t\tkfree(data);\n\n\t\treturn ret;\n\n\t} else if (cmd == VFIO_DEVICE_RESET) {\n\t\treturn vdev->reset_works ?\n\t\t\tpci_try_reset_function(vdev->pdev) : -EINVAL;\n\n\t} else if (cmd == VFIO_DEVICE_GET_PCI_HOT_RESET_INFO) {\n\t\tstruct vfio_pci_hot_reset_info hdr;\n\t\tstruct vfio_pci_fill_info fill = { 0 };\n\t\tstruct vfio_pci_dependent_device *devices = NULL;\n\t\tbool slot = false;\n\t\tint ret = 0;\n\n\t\tminsz = offsetofend(struct vfio_pci_hot_reset_info, count);\n\n\t\tif (copy_from_user(&hdr, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (hdr.argsz < minsz)\n\t\t\treturn -EINVAL;\n\n\t\thdr.flags = 0;\n\n\t\t/* Can we do a slot or bus reset or neither? */\n\t\tif (!pci_probe_reset_slot(vdev->pdev->slot))\n\t\t\tslot = true;\n\t\telse if (pci_probe_reset_bus(vdev->pdev->bus))\n\t\t\treturn -ENODEV;\n\n\t\t/* How many devices are affected? */\n\t\tret = vfio_pci_for_each_slot_or_bus(vdev->pdev,\n\t\t\t\t\t\t    vfio_pci_count_devs,\n\t\t\t\t\t\t    &fill.max, slot);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tWARN_ON(!fill.max); /* Should always be at least one */\n\n\t\t/*\n\t\t * If there's enough space, fill it now, otherwise return\n\t\t * -ENOSPC and the number of devices affected.\n\t\t */\n\t\tif (hdr.argsz < sizeof(hdr) + (fill.max * sizeof(*devices))) {\n\t\t\tret = -ENOSPC;\n\t\t\thdr.count = fill.max;\n\t\t\tgoto reset_info_exit;\n\t\t}\n\n\t\tdevices = kcalloc(fill.max, sizeof(*devices), GFP_KERNEL);\n\t\tif (!devices)\n\t\t\treturn -ENOMEM;\n\n\t\tfill.devices = devices;\n\n\t\tret = vfio_pci_for_each_slot_or_bus(vdev->pdev,\n\t\t\t\t\t\t    vfio_pci_fill_devs,\n\t\t\t\t\t\t    &fill, slot);\n\n\t\t/*\n\t\t * If a device was removed between counting and filling,\n\t\t * we may come up short of fill.max.  If a device was\n\t\t * added, we'll have a return of -EAGAIN above.\n\t\t */\n\t\tif (!ret)\n\t\t\thdr.count = fill.cur;\n\nreset_info_exit:\n\t\tif (copy_to_user((void __user *)arg, &hdr, minsz))\n\t\t\tret = -EFAULT;\n\n\t\tif (!ret) {\n\t\t\tif (copy_to_user((void __user *)(arg + minsz), devices,\n\t\t\t\t\t hdr.count * sizeof(*devices)))\n\t\t\t\tret = -EFAULT;\n\t\t}\n\n\t\tkfree(devices);\n\t\treturn ret;\n\n\t} else if (cmd == VFIO_DEVICE_PCI_HOT_RESET) {\n\t\tstruct vfio_pci_hot_reset hdr;\n\t\tint32_t *group_fds;\n\t\tstruct vfio_pci_group_entry *groups;\n\t\tstruct vfio_pci_group_info info;\n\t\tbool slot = false;\n\t\tint i, count = 0, ret = 0;\n\n\t\tminsz = offsetofend(struct vfio_pci_hot_reset, count);\n\n\t\tif (copy_from_user(&hdr, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (hdr.argsz < minsz || hdr.flags)\n\t\t\treturn -EINVAL;\n\n\t\t/* Can we do a slot or bus reset or neither? */\n\t\tif (!pci_probe_reset_slot(vdev->pdev->slot))\n\t\t\tslot = true;\n\t\telse if (pci_probe_reset_bus(vdev->pdev->bus))\n\t\t\treturn -ENODEV;\n\n\t\t/*\n\t\t * We can't let userspace give us an arbitrarily large\n\t\t * buffer to copy, so verify how many we think there\n\t\t * could be.  Note groups can have multiple devices so\n\t\t * one group per device is the max.\n\t\t */\n\t\tret = vfio_pci_for_each_slot_or_bus(vdev->pdev,\n\t\t\t\t\t\t    vfio_pci_count_devs,\n\t\t\t\t\t\t    &count, slot);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t/* Somewhere between 1 and count is OK */\n\t\tif (!hdr.count || hdr.count > count)\n\t\t\treturn -EINVAL;\n\n\t\tgroup_fds = kcalloc(hdr.count, sizeof(*group_fds), GFP_KERNEL);\n\t\tgroups = kcalloc(hdr.count, sizeof(*groups), GFP_KERNEL);\n\t\tif (!group_fds || !groups) {\n\t\t\tkfree(group_fds);\n\t\t\tkfree(groups);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (copy_from_user(group_fds, (void __user *)(arg + minsz),\n\t\t\t\t   hdr.count * sizeof(*group_fds))) {\n\t\t\tkfree(group_fds);\n\t\t\tkfree(groups);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\t/*\n\t\t * For each group_fd, get the group through the vfio external\n\t\t * user interface and store the group and iommu ID.  This\n\t\t * ensures the group is held across the reset.\n\t\t */\n\t\tfor (i = 0; i < hdr.count; i++) {\n\t\t\tstruct vfio_group *group;\n\t\t\tstruct fd f = fdget(group_fds[i]);\n\t\t\tif (!f.file) {\n\t\t\t\tret = -EBADF;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tgroup = vfio_group_get_external_user(f.file);\n\t\t\tfdput(f);\n\t\t\tif (IS_ERR(group)) {\n\t\t\t\tret = PTR_ERR(group);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tgroups[i].group = group;\n\t\t\tgroups[i].id = vfio_external_user_iommu_id(group);\n\t\t}\n\n\t\tkfree(group_fds);\n\n\t\t/* release reference to groups on error */\n\t\tif (ret)\n\t\t\tgoto hot_reset_release;\n\n\t\tinfo.count = hdr.count;\n\t\tinfo.groups = groups;\n\n\t\t/*\n\t\t * Test whether all the affected devices are contained\n\t\t * by the set of groups provided by the user.\n\t\t */\n\t\tret = vfio_pci_for_each_slot_or_bus(vdev->pdev,\n\t\t\t\t\t\t    vfio_pci_validate_devs,\n\t\t\t\t\t\t    &info, slot);\n\t\tif (!ret)\n\t\t\t/* User has access, do the reset */\n\t\t\tret = slot ? pci_try_reset_slot(vdev->pdev->slot) :\n\t\t\t\t     pci_try_reset_bus(vdev->pdev->bus);\n\nhot_reset_release:\n\t\tfor (i--; i >= 0; i--)\n\t\t\tvfio_group_put_external_user(groups[i].group);\n\n\t\tkfree(groups);\n\t\treturn ret;\n\t}\n\n\treturn -ENOTTY;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142054,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static int vfio_msi_enable(struct vfio_pci_device *vdev, int nvec, bool msix)\n{\n\tstruct pci_dev *pdev = vdev->pdev;\n\tunsigned int flag = msix ? PCI_IRQ_MSIX : PCI_IRQ_MSI;\n\tint ret;\n\n \tif (!is_irq_none(vdev))\n \t\treturn -EINVAL;\n \n\tvdev->ctx = kzalloc(nvec * sizeof(struct vfio_pci_irq_ctx), GFP_KERNEL);\n \tif (!vdev->ctx)\n \t\treturn -ENOMEM;\n \n\t/* return the number of supported vectors if we can't get all: */\n\tret = pci_alloc_irq_vectors(pdev, 1, nvec, flag);\n\tif (ret < nvec) {\n\t\tif (ret > 0)\n\t\t\tpci_free_irq_vectors(pdev);\n\t\tkfree(vdev->ctx);\n\t\treturn ret;\n\t}\n\n\tvdev->num_ctx = nvec;\n\tvdev->irq_type = msix ? VFIO_PCI_MSIX_IRQ_INDEX :\n\t\t\t\tVFIO_PCI_MSI_IRQ_INDEX;\n\n\tif (!msix) {\n\t\t/*\n\t\t * Compute the virtual hardware field for max msi vectors -\n\t\t * it is the log base 2 of the number of vectors.\n\t\t */\n\t\tvdev->msi_qmax = fls(nvec * 2 - 1) - 1;\n\t}\n\n\treturn 0;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142055,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static int vfio_msi_enable(struct vfio_pci_device *vdev, int nvec, bool msix)\n{\n\tstruct pci_dev *pdev = vdev->pdev;\n\tunsigned int flag = msix ? PCI_IRQ_MSIX : PCI_IRQ_MSI;\n\tint ret;\n\n \tif (!is_irq_none(vdev))\n \t\treturn -EINVAL;\n \n\tvdev->ctx = kcalloc(nvec, sizeof(struct vfio_pci_irq_ctx), GFP_KERNEL);\n \tif (!vdev->ctx)\n \t\treturn -ENOMEM;\n \n\t/* return the number of supported vectors if we can't get all: */\n\tret = pci_alloc_irq_vectors(pdev, 1, nvec, flag);\n\tif (ret < nvec) {\n\t\tif (ret > 0)\n\t\t\tpci_free_irq_vectors(pdev);\n\t\tkfree(vdev->ctx);\n\t\treturn ret;\n\t}\n\n\tvdev->num_ctx = nvec;\n\tvdev->irq_type = msix ? VFIO_PCI_MSIX_IRQ_INDEX :\n\t\t\t\tVFIO_PCI_MSI_IRQ_INDEX;\n\n\tif (!msix) {\n\t\t/*\n\t\t * Compute the virtual hardware field for max msi vectors -\n\t\t * it is the log base 2 of the number of vectors.\n\t\t */\n\t\tvdev->msi_qmax = fls(nvec * 2 - 1) - 1;\n\t}\n\n\treturn 0;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142056,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "BGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n{\n\tuint8_t *argb;\n\tint x, y;\n\tuint8_t *p;\n\tuint8_t *out;\n\tsize_t out_size;\n\n\tif (im == NULL) {\n\t\treturn;\n\t}\n\n\tif (!gdImageTrueColor(im)) {\n\t\tgd_error(\"Paletter image not supported by webp\");\n\t\treturn;\n\t}\n\n\tif (quality == -1) {\n \t\tquality = 80;\n \t}\n \n \targb = (uint8_t *)gdMalloc(gdImageSX(im) * 4 * gdImageSY(im));\n \tif (!argb) {\n \t\treturn;\n\t}\n\tp = argb;\n\tfor (y = 0; y < gdImageSY(im); y++) {\n\t\tfor (x = 0; x < gdImageSX(im); x++) {\n\t\t\tregister int c;\n\t\t\tregister char a;\n\t\t\tc = im->tpixels[y][x];\n\t\t\ta = gdTrueColorGetAlpha(c);\n\t\t\tif (a == 127) {\n\t\t\t\ta = 0;\n\t\t\t} else {\n\t\t\t\ta = 255 - ((a << 1) + (a >> 6));\n\t\t\t}\n\t\t\t*(p++) = gdTrueColorGetRed(c);\n\t\t\t*(p++) = gdTrueColorGetGreen(c);\n\t\t\t*(p++) = gdTrueColorGetBlue(c); \n\t\t\t*(p++) = a;\n\t\t}\n\t}\n\tout_size = WebPEncodeRGBA(argb, gdImageSX(im), gdImageSY(im), gdImageSX(im) * 4, quality, &out);\n\tif (out_size == 0) {\n\t\tgd_error(\"gd-webp encoding failed\");\n\t\tgoto freeargb;\n\t}\n\tgdPutBuf(out, out_size, outfile);\n\tfree(out);\n\nfreeargb:\n\tgdFree(argb);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142069,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "BGD_DECLARE(gdImagePtr) gdImageCreateFromWebpCtx (gdIOCtx * infile)\n{\n\tint    width, height;\n\tuint8_t   *filedata = NULL;\n\tuint8_t    *argb = NULL;\n\tunsigned char   *read, *temp;\n\tsize_t size = 0, n;\n\tgdImagePtr im;\n\tint x, y;\n\tuint8_t *p;\n\n\tdo {\n\t\ttemp = gdRealloc(filedata, size+GD_WEBP_ALLOC_STEP);\n\t\tif (temp) {\n\t\t\tfiledata = temp;\n\t\t\tread = temp + size;\n\t\t} else {\n\t\t\tif (filedata) {\n\t\t\t\tgdFree(filedata);\n\t\t\t}\n\t\t\tgd_error(\"WebP decode: realloc failed\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tn = gdGetBuf(read, GD_WEBP_ALLOC_STEP, infile);\n\t\tif (n>0 && n!=EOF) {\n\t\t\tsize += n;\n\t\t}\n\t} while (n>0 && n!=EOF);\n\n\tif (WebPGetInfo(filedata,size, &width, &height) == 0) {\n\t\tgd_error(\"gd-webp cannot get webp info\");\n\t\tgdFree(temp);\n\t\treturn NULL;\n\t}\n\n\tim = gdImageCreateTrueColor(width, height);\n\tif (!im) {\n\t\tgdFree(temp);\n\t\treturn NULL;\n\t}\n\targb = WebPDecodeARGB(filedata, size, &width, &height);\n\tif (!argb) {\n\t\tgd_error(\"gd-webp cannot allocate temporary buffer\");\n\t\tgdFree(temp);\n\t\tgdImageDestroy(im);\n\t\treturn NULL;\n\t}\n\tfor (y = 0, p = argb;  y < height; y++) {\n\t\tfor (x = 0; x < width; x++) {\n\t\t\tregister uint8_t a = gdAlphaMax - (*(p++) >> 1);\n\t\t\tregister uint8_t r = *(p++);\n\t\t\tregister uint8_t g = *(p++);\n\t\t\tregister uint8_t b = *(p++);\n\t\t\tim->tpixels[y][x] = gdTrueColorAlpha(r, g, b, a);\n\t\t}\n\t}\n\t/* do not use gdFree here, in case gdFree/alloc is mapped to something else than libc */\n\tfree(argb);\n\tgdFree(temp);\n\tim->saveAlphaFlag = 1;\n\treturn im;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142070,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "choose_volume(struct archive_read *a, struct iso9660 *iso9660)\n{\n\tstruct file_info *file;\n\tint64_t skipsize;\n\tstruct vd *vd;\n\tconst void *block;\n\tchar seenJoliet;\n\n\tvd = &(iso9660->primary);\n\tif (!iso9660->opt_support_joliet)\n\t\tiso9660->seenJoliet = 0;\n\tif (iso9660->seenJoliet &&\n\t\tvd->location > iso9660->joliet.location)\n \t\t/* This condition is unlikely; by way of caution. */\n \t\tvd = &(iso9660->joliet);\n \n\tskipsize = LOGICAL_BLOCK_SIZE * vd->location;\n \tskipsize = __archive_read_consume(a, skipsize);\n \tif (skipsize < 0)\n \t\treturn ((int)skipsize);\n\tiso9660->current_position = skipsize;\n\n\tblock = __archive_read_ahead(a, vd->size, NULL);\n\tif (block == NULL) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"Failed to read full block when scanning \"\n\t\t    \"ISO9660 directory list\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\t/*\n\t * While reading Root Directory, flag seenJoliet must be zero to\n\t * avoid converting special name 0x00(Current Directory) and\n\t * next byte to UCS2.\n\t */\n\tseenJoliet = iso9660->seenJoliet;/* Save flag. */\n\tiso9660->seenJoliet = 0;\n\tfile = parse_file_info(a, NULL, block);\n\tif (file == NULL)\n\t\treturn (ARCHIVE_FATAL);\n\tiso9660->seenJoliet = seenJoliet;\n\n\t/*\n\t * If the iso image has both RockRidge and Joliet, we preferentially\n\t * use RockRidge Extensions rather than Joliet ones.\n\t */\n\tif (vd == &(iso9660->primary) && iso9660->seenRockridge\n\t    && iso9660->seenJoliet)\n\t\tiso9660->seenJoliet = 0;\n\n\tif (vd == &(iso9660->primary) && !iso9660->seenRockridge\n \t    && iso9660->seenJoliet) {\n \t\t/* Switch reading data from primary to joliet. */\n \t\tvd = &(iso9660->joliet);\n\t\tskipsize = LOGICAL_BLOCK_SIZE * vd->location;\n \t\tskipsize -= iso9660->current_position;\n \t\tskipsize = __archive_read_consume(a, skipsize);\n \t\tif (skipsize < 0)\n\t\t\treturn ((int)skipsize);\n\t\tiso9660->current_position += skipsize;\n\n\t\tblock = __archive_read_ahead(a, vd->size, NULL);\n\t\tif (block == NULL) {\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Failed to read full block when scanning \"\n\t\t\t    \"ISO9660 directory list\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tiso9660->seenJoliet = 0;\n\t\tfile = parse_file_info(a, NULL, block);\n\t\tif (file == NULL)\n\t\t\treturn (ARCHIVE_FATAL);\n\t\tiso9660->seenJoliet = seenJoliet;\n\t}\n\n\t/* Store the root directory in the pending list. */\n\tif (add_entry(a, iso9660, file) != ARCHIVE_OK)\n\t\treturn (ARCHIVE_FATAL);\n\tif (iso9660->seenRockridge) {\n\t\ta->archive.archive_format = ARCHIVE_FORMAT_ISO9660_ROCKRIDGE;\n\t\ta->archive.archive_format_name =\n\t\t    \"ISO9660 with Rockridge extensions\";\n\t}\n\n\treturn (ARCHIVE_OK);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142095,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "choose_volume(struct archive_read *a, struct iso9660 *iso9660)\n{\n\tstruct file_info *file;\n\tint64_t skipsize;\n\tstruct vd *vd;\n\tconst void *block;\n\tchar seenJoliet;\n\n\tvd = &(iso9660->primary);\n\tif (!iso9660->opt_support_joliet)\n\t\tiso9660->seenJoliet = 0;\n\tif (iso9660->seenJoliet &&\n\t\tvd->location > iso9660->joliet.location)\n \t\t/* This condition is unlikely; by way of caution. */\n \t\tvd = &(iso9660->joliet);\n \n\tskipsize = LOGICAL_BLOCK_SIZE * (int64_t)vd->location;\n \tskipsize = __archive_read_consume(a, skipsize);\n \tif (skipsize < 0)\n \t\treturn ((int)skipsize);\n\tiso9660->current_position = skipsize;\n\n\tblock = __archive_read_ahead(a, vd->size, NULL);\n\tif (block == NULL) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"Failed to read full block when scanning \"\n\t\t    \"ISO9660 directory list\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\t/*\n\t * While reading Root Directory, flag seenJoliet must be zero to\n\t * avoid converting special name 0x00(Current Directory) and\n\t * next byte to UCS2.\n\t */\n\tseenJoliet = iso9660->seenJoliet;/* Save flag. */\n\tiso9660->seenJoliet = 0;\n\tfile = parse_file_info(a, NULL, block);\n\tif (file == NULL)\n\t\treturn (ARCHIVE_FATAL);\n\tiso9660->seenJoliet = seenJoliet;\n\n\t/*\n\t * If the iso image has both RockRidge and Joliet, we preferentially\n\t * use RockRidge Extensions rather than Joliet ones.\n\t */\n\tif (vd == &(iso9660->primary) && iso9660->seenRockridge\n\t    && iso9660->seenJoliet)\n\t\tiso9660->seenJoliet = 0;\n\n\tif (vd == &(iso9660->primary) && !iso9660->seenRockridge\n \t    && iso9660->seenJoliet) {\n \t\t/* Switch reading data from primary to joliet. */\n \t\tvd = &(iso9660->joliet);\n\t\tskipsize = LOGICAL_BLOCK_SIZE * (int64_t)vd->location;\n \t\tskipsize -= iso9660->current_position;\n \t\tskipsize = __archive_read_consume(a, skipsize);\n \t\tif (skipsize < 0)\n\t\t\treturn ((int)skipsize);\n\t\tiso9660->current_position += skipsize;\n\n\t\tblock = __archive_read_ahead(a, vd->size, NULL);\n\t\tif (block == NULL) {\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Failed to read full block when scanning \"\n\t\t\t    \"ISO9660 directory list\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tiso9660->seenJoliet = 0;\n\t\tfile = parse_file_info(a, NULL, block);\n\t\tif (file == NULL)\n\t\t\treturn (ARCHIVE_FATAL);\n\t\tiso9660->seenJoliet = seenJoliet;\n\t}\n\n\t/* Store the root directory in the pending list. */\n\tif (add_entry(a, iso9660, file) != ARCHIVE_OK)\n\t\treturn (ARCHIVE_FATAL);\n\tif (iso9660->seenRockridge) {\n\t\ta->archive.archive_format = ARCHIVE_FORMAT_ISO9660_ROCKRIDGE;\n\t\ta->archive.archive_format_name =\n\t\t    \"ISO9660 with Rockridge extensions\";\n\t}\n\n\treturn (ARCHIVE_OK);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142096,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static Image *ReadTXTImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    colorspace[MaxTextExtent],\n    text[MaxTextExtent];\n\n  Image\n    *image;\n\n  IndexPacket\n    *indexes;\n\n  long\n    x_offset,\n    y_offset;\n\n  MagickBooleanType\n    status;\n\n  MagickPixelPacket\n    pixel;\n\n  QuantumAny\n    range;\n\n  register ssize_t\n    i,\n    x;\n\n  register PixelPacket\n    *q;\n\n  ssize_t\n    count,\n    type,\n    y;\n\n  unsigned long\n    depth,\n    height,\n    max_value,\n    width;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) ResetMagickMemory(text,0,sizeof(text));\n  (void) ReadBlobString(image,text);\n  if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) != 0)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  do\n  {\n    width=0;\n    height=0;\n    max_value=0;\n    *colorspace='\\0';\n    count=(ssize_t) sscanf(text+32,\"%lu,%lu,%lu,%s\",&width,&height,&max_value,\n      colorspace);\n    if ((count != 4) || (width == 0) || (height == 0) || (max_value == 0))\n       ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n     image->columns=width;\n     image->rows=height;\n    for (depth=1; (GetQuantumRange(depth)+1) < max_value; depth++)\n      if (depth >= 64)\n        break;\n     image->depth=depth;\n     status=SetImageExtent(image,image->columns,image->rows);\n     if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    LocaleLower(colorspace);\n    i=(ssize_t) strlen(colorspace)-1;\n    image->matte=MagickFalse;\n    if ((i > 0) && (colorspace[i] == 'a'))\n      {\n        colorspace[i]='\\0';\n        image->matte=MagickTrue;\n      }\n    type=ParseCommandOption(MagickColorspaceOptions,MagickFalse,colorspace);\n    if (type < 0)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    image->colorspace=(ColorspaceType) type;\n    (void) ResetMagickMemory(&pixel,0,sizeof(pixel));\n    (void) SetImageBackgroundColor(image);\n    range=GetQuantumRange(image->depth);\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      double\n        blue,\n        green,\n        index,\n        opacity,\n        red;\n\n      red=0.0;\n      green=0.0;\n      blue=0.0;\n      index=0.0;\n      opacity=0.0;\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        if (ReadBlobString(image,text) == (char *) NULL)\n          break;\n        switch (image->colorspace)\n        {\n          case GRAYColorspace:\n          {\n            if (image->matte != MagickFalse)\n              {\n                (void) sscanf(text,\"%ld,%ld: (%lf%*[%,]%lf%*[%,]\",&x_offset,\n                  &y_offset,&red,&opacity);\n                green=red;\n                blue=red;\n                break;\n              }\n            (void) sscanf(text,\"%ld,%ld: (%lf%*[%,]\",&x_offset,&y_offset,&red);\n            green=red;\n            blue=red;\n            break;\n          }\n          case CMYKColorspace:\n          {\n            if (image->matte != MagickFalse)\n              {\n                (void) sscanf(text,\n                  \"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\",\n                  &x_offset,&y_offset,&red,&green,&blue,&index,&opacity);\n                break;\n              }\n            (void) sscanf(text,\n              \"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\",&x_offset,\n              &y_offset,&red,&green,&blue,&index);\n            break;\n          }\n          default:\n          {\n            if (image->matte != MagickFalse)\n              {\n                (void) sscanf(text,\n                  \"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\",\n                  &x_offset,&y_offset,&red,&green,&blue,&opacity);\n                break;\n              }\n            (void) sscanf(text,\"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]\",\n              &x_offset,&y_offset,&red,&green,&blue);\n            break;\n          }\n        }\n        if (strchr(text,'%') != (char *) NULL)\n          {\n            red*=0.01*range;\n            green*=0.01*range;\n            blue*=0.01*range;\n            index*=0.01*range;\n            opacity*=0.01*range;\n          }\n        if (image->colorspace == LabColorspace)\n          {\n            green+=(range+1)/2.0;\n            blue+=(range+1)/2.0;\n          }\n        pixel.red=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (red+0.5),\n          range);\n        pixel.green=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (green+0.5),\n          range);\n        pixel.blue=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (blue+0.5),\n          range);\n        pixel.index=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (index+0.5),\n          range);\n        pixel.opacity=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (opacity+\n          0.5),range);\n        q=GetAuthenticPixels(image,(ssize_t) x_offset,(ssize_t) y_offset,1,1,\n          exception);\n        if (q == (PixelPacket *) NULL)\n          continue;\n        SetPixelRed(q,pixel.red);\n        SetPixelGreen(q,pixel.green);\n        SetPixelBlue(q,pixel.blue);\n        if (image->colorspace == CMYKColorspace)\n          {\n            indexes=GetAuthenticIndexQueue(image);\n            SetPixelIndex(indexes,pixel.index);\n          }\n        if (image->matte != MagickFalse)\n          SetPixelAlpha(q,pixel.opacity);\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n      }\n    }\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    (void) ReadBlobString(image,text);\n    if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142335,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static Image *ReadTXTImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    colorspace[MaxTextExtent],\n    text[MaxTextExtent];\n\n  Image\n    *image;\n\n  IndexPacket\n    *indexes;\n\n  long\n    x_offset,\n    y_offset;\n\n  MagickBooleanType\n    status;\n\n  MagickPixelPacket\n    pixel;\n\n  QuantumAny\n    range;\n\n  register ssize_t\n    i,\n    x;\n\n  register PixelPacket\n    *q;\n\n  ssize_t\n    count,\n    type,\n    y;\n\n  unsigned long\n    depth,\n    height,\n    max_value,\n    width;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) ResetMagickMemory(text,0,sizeof(text));\n  (void) ReadBlobString(image,text);\n  if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) != 0)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  do\n  {\n    width=0;\n    height=0;\n    max_value=0;\n    *colorspace='\\0';\n    count=(ssize_t) sscanf(text+32,\"%lu,%lu,%lu,%s\",&width,&height,&max_value,\n      colorspace);\n    if ((count != 4) || (width == 0) || (height == 0) || (max_value == 0))\n       ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n     image->columns=width;\n     image->rows=height;\n    if ((max_value == 0) || (max_value > 4294967295))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    for (depth=1; (GetQuantumRange(depth)+1) < max_value; depth++) ;\n     image->depth=depth;\n     status=SetImageExtent(image,image->columns,image->rows);\n     if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    LocaleLower(colorspace);\n    i=(ssize_t) strlen(colorspace)-1;\n    image->matte=MagickFalse;\n    if ((i > 0) && (colorspace[i] == 'a'))\n      {\n        colorspace[i]='\\0';\n        image->matte=MagickTrue;\n      }\n    type=ParseCommandOption(MagickColorspaceOptions,MagickFalse,colorspace);\n    if (type < 0)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    image->colorspace=(ColorspaceType) type;\n    (void) ResetMagickMemory(&pixel,0,sizeof(pixel));\n    (void) SetImageBackgroundColor(image);\n    range=GetQuantumRange(image->depth);\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      double\n        blue,\n        green,\n        index,\n        opacity,\n        red;\n\n      red=0.0;\n      green=0.0;\n      blue=0.0;\n      index=0.0;\n      opacity=0.0;\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        if (ReadBlobString(image,text) == (char *) NULL)\n          break;\n        switch (image->colorspace)\n        {\n          case GRAYColorspace:\n          {\n            if (image->matte != MagickFalse)\n              {\n                (void) sscanf(text,\"%ld,%ld: (%lf%*[%,]%lf%*[%,]\",&x_offset,\n                  &y_offset,&red,&opacity);\n                green=red;\n                blue=red;\n                break;\n              }\n            (void) sscanf(text,\"%ld,%ld: (%lf%*[%,]\",&x_offset,&y_offset,&red);\n            green=red;\n            blue=red;\n            break;\n          }\n          case CMYKColorspace:\n          {\n            if (image->matte != MagickFalse)\n              {\n                (void) sscanf(text,\n                  \"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\",\n                  &x_offset,&y_offset,&red,&green,&blue,&index,&opacity);\n                break;\n              }\n            (void) sscanf(text,\n              \"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\",&x_offset,\n              &y_offset,&red,&green,&blue,&index);\n            break;\n          }\n          default:\n          {\n            if (image->matte != MagickFalse)\n              {\n                (void) sscanf(text,\n                  \"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\",\n                  &x_offset,&y_offset,&red,&green,&blue,&opacity);\n                break;\n              }\n            (void) sscanf(text,\"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]\",\n              &x_offset,&y_offset,&red,&green,&blue);\n            break;\n          }\n        }\n        if (strchr(text,'%') != (char *) NULL)\n          {\n            red*=0.01*range;\n            green*=0.01*range;\n            blue*=0.01*range;\n            index*=0.01*range;\n            opacity*=0.01*range;\n          }\n        if (image->colorspace == LabColorspace)\n          {\n            green+=(range+1)/2.0;\n            blue+=(range+1)/2.0;\n          }\n        pixel.red=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (red+0.5),\n          range);\n        pixel.green=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (green+0.5),\n          range);\n        pixel.blue=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (blue+0.5),\n          range);\n        pixel.index=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (index+0.5),\n          range);\n        pixel.opacity=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (opacity+\n          0.5),range);\n        q=GetAuthenticPixels(image,(ssize_t) x_offset,(ssize_t) y_offset,1,1,\n          exception);\n        if (q == (PixelPacket *) NULL)\n          continue;\n        SetPixelRed(q,pixel.red);\n        SetPixelGreen(q,pixel.green);\n        SetPixelBlue(q,pixel.blue);\n        if (image->colorspace == CMYKColorspace)\n          {\n            indexes=GetAuthenticIndexQueue(image);\n            SetPixelIndex(indexes,pixel.index);\n          }\n        if (image->matte != MagickFalse)\n          SetPixelAlpha(q,pixel.opacity);\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n      }\n    }\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    (void) ReadBlobString(image,text);\n    if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142336,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "ZEND_API void ZEND_FASTCALL _zend_hash_init(HashTable *ht, uint32_t nSize, dtor_func_t pDestructor, zend_bool persistent ZEND_FILE_LINE_DC)\n{\n \tGC_REFCOUNT(ht) = 1;\n \tGC_TYPE_INFO(ht) = IS_ARRAY;\n \tht->u.flags = (persistent ? HASH_FLAG_PERSISTENT : 0) | HASH_FLAG_APPLY_PROTECTION | HASH_FLAG_STATIC_KEYS;\n\tht->nTableSize = zend_hash_check_size(nSize);\n \tht->nTableMask = HT_MIN_MASK;\n \tHT_SET_DATA_ADDR(ht, &uninitialized_bucket);\n \tht->nNumUsed = 0;\n \tht->nNumOfElements = 0;\n \tht->nInternalPointer = HT_INVALID_IDX;\n \tht->nNextFreeElement = 0;\n \tht->pDestructor = pDestructor;\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142665,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "ZEND_API void ZEND_FASTCALL _zend_hash_init(HashTable *ht, uint32_t nSize, dtor_func_t pDestructor, zend_bool persistent ZEND_FILE_LINE_DC)\n{\n \tGC_REFCOUNT(ht) = 1;\n \tGC_TYPE_INFO(ht) = IS_ARRAY;\n \tht->u.flags = (persistent ? HASH_FLAG_PERSISTENT : 0) | HASH_FLAG_APPLY_PROTECTION | HASH_FLAG_STATIC_KEYS;\n \tht->nTableMask = HT_MIN_MASK;\n \tHT_SET_DATA_ADDR(ht, &uninitialized_bucket);\n \tht->nNumUsed = 0;\n \tht->nNumOfElements = 0;\n \tht->nInternalPointer = HT_INVALID_IDX;\n \tht->nNextFreeElement = 0;\n \tht->pDestructor = pDestructor;\n\tht->nTableSize = zend_hash_check_size(nSize);\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142666,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "jas_matrix_t *jas_seq2d_create(int xstart, int ystart, int xend, int yend)\n {\n \tjas_matrix_t *matrix;\n \tassert(xstart <= xend && ystart <= yend);\n\tif (!(matrix = jas_matrix_create(yend - ystart, xend - xstart))) {\n\t\treturn 0;\n\t}\n\tmatrix->xstart_ = xstart;\n\tmatrix->ystart_ = ystart;\n\tmatrix->xend_ = xend;\n\tmatrix->yend_ = yend;\n \treturn matrix;\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142761,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "jas_matrix_t *jas_seq2d_create(int xstart, int ystart, int xend, int yend)\njas_matrix_t *jas_seq2d_create(jas_matind_t xstart, jas_matind_t ystart,\n  jas_matind_t xend, jas_matind_t yend)\n {\n \tjas_matrix_t *matrix;\n \tassert(xstart <= xend && ystart <= yend);\n\tif (!(matrix = jas_matrix_create(yend - ystart, xend - xstart))) {\n\t\treturn 0;\n\t}\n\tmatrix->xstart_ = xstart;\n\tmatrix->ystart_ = ystart;\n\tmatrix->xend_ = xend;\n\tmatrix->yend_ = yend;\n \treturn matrix;\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142762,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static int mem_resize(jas_stream_memobj_t *m, int bufsize)\n {\n \tunsigned char *buf;\n \n\tassert(bufsize >= 0);\n \n\tJAS_DBGLOG(100, (\"mem_resize(%p, %d)\\n\", m, bufsize));\n \tif (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char))) &&\n \t  bufsize) {\n \t\tJAS_DBGLOG(100, (\"mem_resize realloc failed\\n\"));\n\t\treturn -1;\n\t}\n\tJAS_DBGLOG(100, (\"mem_resize realloc succeeded\\n\"));\n\tm->buf_ = buf;\n\tm->bufsize_ = bufsize;\n\treturn 0;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142769,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static int mem_resize(jas_stream_memobj_t *m, int bufsize)\nstatic int mem_resize(jas_stream_memobj_t *m, size_t bufsize)\n {\n \tunsigned char *buf;\n \n\t//assert(bufsize >= 0);\n\n\tJAS_DBGLOG(100, (\"mem_resize(%p, %zu)\\n\", m, bufsize));\n\tif (!bufsize) {\n\t\tjas_eprintf(\n\t\t  \"mem_resize was not really designed to handle a buffer of size 0\\n\"\n\t\t  \"This may not work.\\n\"\n\t\t);\n\t}\n \n \tif (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char))) &&\n \t  bufsize) {\n \t\tJAS_DBGLOG(100, (\"mem_resize realloc failed\\n\"));\n\t\treturn -1;\n\t}\n\tJAS_DBGLOG(100, (\"mem_resize realloc succeeded\\n\"));\n\tm->buf_ = buf;\n\tm->bufsize_ = bufsize;\n\treturn 0;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142770,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "int mem_check_range(struct rxe_mem *mem, u64 iova, size_t length)\n{\n\tswitch (mem->type) {\n\tcase RXE_MEM_TYPE_DMA:\n\t\treturn 0;\n \n \tcase RXE_MEM_TYPE_MR:\n \tcase RXE_MEM_TYPE_FMR:\n\t\treturn ((iova < mem->iova) ||\n\t\t\t((iova + length) > (mem->iova + mem->length))) ?\n\t\t\t-EFAULT : 0;\n \n \tdefault:\n \t\treturn -EFAULT;\n\t}\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142781,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "int mem_check_range(struct rxe_mem *mem, u64 iova, size_t length)\n{\n\tswitch (mem->type) {\n\tcase RXE_MEM_TYPE_DMA:\n\t\treturn 0;\n \n \tcase RXE_MEM_TYPE_MR:\n \tcase RXE_MEM_TYPE_FMR:\n\t\tif (iova < mem->iova ||\n\t\t    length > mem->length ||\n\t\t    iova > mem->iova + mem->length - length)\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n \n \tdefault:\n \t\treturn -EFAULT;\n\t}\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142782,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static MagickBooleanType WriteBMPImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  BMPInfo\n    bmp_info;\n\n  const char\n    *option;\n\n  const StringInfo\n    *profile;\n\n  MagickBooleanType\n    have_color_info,\n    status;\n\n  MagickOffsetType\n    scene;\n\n  MemoryInfo\n    *pixel_info;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *q;\n\n  size_t\n    bytes_per_line,\n    type;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *bmp_data,\n    *pixels;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  type=4;\n  if (LocaleCompare(image_info->magick,\"BMP2\") == 0)\n    type=2;\n  else\n    if (LocaleCompare(image_info->magick,\"BMP3\") == 0)\n      type=3;\n\n  option=GetImageOption(image_info,\"bmp:format\");\n  if (option != (char *) NULL)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Format=%s\",option);\n\n      if (LocaleCompare(option,\"bmp2\") == 0)\n        type=2;\n      if (LocaleCompare(option,\"bmp3\") == 0)\n        type=3;\n      if (LocaleCompare(option,\"bmp4\") == 0)\n        type=4;\n    }\n\n  scene=0;\n  do\n  {\n    /*\n      Initialize BMP raster file header.\n    */\n    (void) TransformImageColorspace(image,sRGBColorspace,exception);\n    (void) ResetMagickMemory(&bmp_info,0,sizeof(bmp_info));\n    bmp_info.file_size=14+12;\n    if (type > 2)\n      bmp_info.file_size+=28;\n    bmp_info.offset_bits=bmp_info.file_size;\n    bmp_info.compression=BI_RGB;\n    if ((image->storage_class == PseudoClass) && (image->colors > 256))\n      (void) SetImageStorageClass(image,DirectClass,exception);\n    if (image->storage_class != DirectClass)\n      {\n        /*\n          Colormapped BMP raster.\n        */\n        bmp_info.bits_per_pixel=8;\n        if (image->colors <= 2)\n          bmp_info.bits_per_pixel=1;\n        else\n          if (image->colors <= 16)\n            bmp_info.bits_per_pixel=4;\n          else\n            if (image->colors <= 256)\n              bmp_info.bits_per_pixel=8;\n        if (image_info->compression == RLECompression)\n          bmp_info.bits_per_pixel=8;\n        bmp_info.number_colors=1U << bmp_info.bits_per_pixel;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          (void) SetImageStorageClass(image,DirectClass,exception);\n        else\n          if ((size_t) bmp_info.number_colors < image->colors)\n            (void) SetImageStorageClass(image,DirectClass,exception);\n          else\n            {\n              bmp_info.file_size+=3*(1UL << bmp_info.bits_per_pixel);\n              bmp_info.offset_bits+=3*(1UL << bmp_info.bits_per_pixel);\n              if (type > 2)\n                {\n                  bmp_info.file_size+=(1UL << bmp_info.bits_per_pixel);\n                  bmp_info.offset_bits+=(1UL << bmp_info.bits_per_pixel);\n                }\n            }\n      }\n    if (image->storage_class == DirectClass)\n      {\n        /*\n          Full color BMP raster.\n        */\n        bmp_info.number_colors=0;\n        bmp_info.bits_per_pixel=(unsigned short)\n          ((type > 3) && (image->alpha_trait != UndefinedPixelTrait) ? 32 : 24);\n        bmp_info.compression=(unsigned int) ((type > 3) &&\n          (image->alpha_trait != UndefinedPixelTrait) ?  BI_BITFIELDS : BI_RGB);\n        if ((type == 3) && (image->alpha_trait != UndefinedPixelTrait))\n          {\n            option=GetImageOption(image_info,\"bmp3:alpha\");\n            if (IsStringTrue(option))\n              bmp_info.bits_per_pixel=32;\n          }\n      }\n    bytes_per_line=4*((image->columns*bmp_info.bits_per_pixel+31)/32);\n    bmp_info.ba_offset=0;\n    profile=GetImageProfile(image,\"icc\");\n    have_color_info=(image->rendering_intent != UndefinedIntent) ||\n      (profile != (StringInfo *) NULL) || (image->gamma != 0.0) ?  MagickTrue :\n      MagickFalse;\n    if (type == 2)\n      bmp_info.size=12;\n    else\n      if ((type == 3) || ((image->alpha_trait == UndefinedPixelTrait) &&\n          (have_color_info == MagickFalse)))\n        {\n          type=3;\n          bmp_info.size=40;\n        }\n      else\n        {\n          int\n            extra_size;\n\n          bmp_info.size=108;\n          extra_size=68;\n          if ((image->rendering_intent != UndefinedIntent) ||\n              (profile != (StringInfo *) NULL))\n            {\n              bmp_info.size=124;\n              extra_size+=16;\n            }\n           bmp_info.file_size+=extra_size;\n           bmp_info.offset_bits+=extra_size;\n         }\n     bmp_info.width=(ssize_t) image->columns;\n     bmp_info.height=(ssize_t) image->rows;\n     bmp_info.planes=1;\n    bmp_info.image_size=(unsigned int) (bytes_per_line*image->rows);\n     bmp_info.file_size+=bmp_info.image_size;\n     bmp_info.x_pixels=75*39;\n     bmp_info.y_pixels=75*39;\n    switch (image->units)\n    {\n      case UndefinedResolution:\n      case PixelsPerInchResolution:\n      {\n        bmp_info.x_pixels=(unsigned int) (100.0*image->resolution.x/2.54);\n        bmp_info.y_pixels=(unsigned int) (100.0*image->resolution.y/2.54);\n        break;\n      }\n      case PixelsPerCentimeterResolution:\n      {\n        bmp_info.x_pixels=(unsigned int) (100.0*image->resolution.x);\n        bmp_info.y_pixels=(unsigned int) (100.0*image->resolution.y);\n        break;\n      }\n    }\n    bmp_info.colors_important=bmp_info.number_colors;\n    /*\n      Convert MIFF to BMP raster pixels.\n    */\n    pixel_info=AcquireVirtualMemory((size_t) bmp_info.image_size,\n      sizeof(*pixels));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    (void) ResetMagickMemory(pixels,0,(size_t) bmp_info.image_size);\n    switch (bmp_info.bits_per_pixel)\n    {\n      case 1:\n      {\n        size_t\n          bit,\n          byte;\n\n        /*\n          Convert PseudoClass image to a BMP monochrome image.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          ssize_t\n            offset;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels+(image->rows-y-1)*bytes_per_line;\n          bit=0;\n          byte=0;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            byte<<=1;\n            byte|=GetPixelIndex(image,p) != 0 ? 0x01 : 0x00;\n            bit++;\n            if (bit == 8)\n              {\n                *q++=(unsigned char) byte;\n                bit=0;\n                byte=0;\n              }\n             p+=GetPixelChannels(image);\n           }\n           if (bit != 0)\n             {\n               *q++=(unsigned char) (byte << (8-bit));\n               x++;\n             }\n          offset=(ssize_t) (image->columns+7)/8;\n          for (x=offset; x < (ssize_t) bytes_per_line; x++)\n            *q++=0x00;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case 4:\n      {\n        size_t\n          byte,\n          nibble;\n\n        ssize_t\n          offset;\n\n        /*\n          Convert PseudoClass image to a BMP monochrome image.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels+(image->rows-y-1)*bytes_per_line;\n          nibble=0;\n          byte=0;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            byte<<=4;\n            byte|=((size_t) GetPixelIndex(image,p) & 0x0f);\n            nibble++;\n            if (nibble == 2)\n              {\n                *q++=(unsigned char) byte;\n                nibble=0;\n                byte=0;\n              }\n            p+=GetPixelChannels(image);\n          }\n          if (nibble != 0)\n            {\n              *q++=(unsigned char) (byte << 4);\n              x++;\n            }\n          offset=(ssize_t) (image->columns+1)/2;\n          for (x=offset; x < (ssize_t) bytes_per_line; x++)\n            *q++=0x00;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case 8:\n      {\n        /*\n          Convert PseudoClass packet to BMP pixel.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels+(image->rows-y-1)*bytes_per_line;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *q++=(unsigned char) GetPixelIndex(image,p);\n            p+=GetPixelChannels(image);\n          }\n          for ( ; x < (ssize_t) bytes_per_line; x++)\n            *q++=0x00;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case 24:\n      {\n        /*\n          Convert DirectClass packet to BMP BGR888.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels+(image->rows-y-1)*bytes_per_line;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *q++=ScaleQuantumToChar(GetPixelBlue(image,p));\n            *q++=ScaleQuantumToChar(GetPixelGreen(image,p));\n            *q++=ScaleQuantumToChar(GetPixelRed(image,p));\n            p+=GetPixelChannels(image);\n          }\n          for (x=3L*(ssize_t) image->columns; x < (ssize_t) bytes_per_line; x++)\n            *q++=0x00;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case 32:\n      {\n        /*\n          Convert DirectClass packet to ARGB8888 pixel.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels+(image->rows-y-1)*bytes_per_line;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *q++=ScaleQuantumToChar(GetPixelBlue(image,p));\n            *q++=ScaleQuantumToChar(GetPixelGreen(image,p));\n            *q++=ScaleQuantumToChar(GetPixelRed(image,p));\n            *q++=ScaleQuantumToChar(GetPixelAlpha(image,p));\n            p+=GetPixelChannels(image);\n          }\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n    }\n    if ((type > 2) && (bmp_info.bits_per_pixel == 8))\n      if (image_info->compression != NoCompression)\n        {\n          MemoryInfo\n            *rle_info;\n\n          /*\n            Convert run-length encoded raster pixels.\n          */\n          rle_info=AcquireVirtualMemory((size_t) (2*(bytes_per_line+2)+2),\n            (image->rows+2)*sizeof(*pixels));\n          if (rle_info == (MemoryInfo *) NULL)\n            {\n              pixel_info=RelinquishVirtualMemory(pixel_info);\n              ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n            }\n          bmp_data=(unsigned char *) GetVirtualMemoryBlob(rle_info);\n          bmp_info.file_size-=bmp_info.image_size;\n          bmp_info.image_size=(unsigned int) EncodeImage(image,bytes_per_line,\n            pixels,bmp_data);\n          bmp_info.file_size+=bmp_info.image_size;\n          pixel_info=RelinquishVirtualMemory(pixel_info);\n          pixel_info=rle_info;\n          pixels=bmp_data;\n          bmp_info.compression=BI_RLE8;\n        }\n    /*\n      Write BMP for Windows, all versions, 14-byte header.\n    */\n    if (image->debug != MagickFalse)\n      {\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"   Writing BMP version %.20g datastream\",(double) type);\n        if (image->storage_class == DirectClass)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   Storage class=DirectClass\");\n        else\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   Storage class=PseudoClass\");\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"   Image depth=%.20g\",(double) image->depth);\n        if (image->alpha_trait != UndefinedPixelTrait)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   Matte=True\");\n        else\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   Matte=MagickFalse\");\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"   BMP bits_per_pixel=%.20g\",(double) bmp_info.bits_per_pixel);\n        switch ((int) bmp_info.compression)\n        {\n           case BI_RGB:\n           {\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"   Compression=BI_RGB\");\n             break;\n           }\n           case BI_RLE8:\n           {\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"   Compression=BI_RLE8\");\n             break;\n           }\n           case BI_BITFIELDS:\n           {\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"   Compression=BI_BITFIELDS\");\n             break;\n           }\n           default:\n           {\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"   Compression=UNKNOWN (%lu)\",bmp_info.compression);\n             break;\n           }\n        }\n        if (bmp_info.number_colors == 0)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   Number_colors=unspecified\");\n        else\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   Number_colors=%lu\",bmp_info.number_colors);\n      }\n    (void) WriteBlob(image,2,(unsigned char *) \"BM\");\n    (void) WriteBlobLSBLong(image,bmp_info.file_size);\n    (void) WriteBlobLSBLong(image,bmp_info.ba_offset);  /* always 0 */\n    (void) WriteBlobLSBLong(image,bmp_info.offset_bits);\n    if (type == 2)\n      {\n        /*\n          Write 12-byte version 2 bitmap header.\n        */\n        (void) WriteBlobLSBLong(image,bmp_info.size);\n        (void) WriteBlobLSBSignedShort(image,(signed short) bmp_info.width);\n        (void) WriteBlobLSBSignedShort(image,(signed short) bmp_info.height);\n        (void) WriteBlobLSBShort(image,bmp_info.planes);\n        (void) WriteBlobLSBShort(image,bmp_info.bits_per_pixel);\n      }\n    else\n      {\n        /*\n          Write 40-byte version 3+ bitmap header.\n        */\n        (void) WriteBlobLSBLong(image,bmp_info.size);\n        (void) WriteBlobLSBSignedLong(image,(signed int) bmp_info.width);\n        (void) WriteBlobLSBSignedLong(image,(signed int) bmp_info.height);\n        (void) WriteBlobLSBShort(image,bmp_info.planes);\n        (void) WriteBlobLSBShort(image,bmp_info.bits_per_pixel);\n        (void) WriteBlobLSBLong(image,bmp_info.compression);\n        (void) WriteBlobLSBLong(image,bmp_info.image_size);\n        (void) WriteBlobLSBLong(image,bmp_info.x_pixels);\n        (void) WriteBlobLSBLong(image,bmp_info.y_pixels);\n        (void) WriteBlobLSBLong(image,bmp_info.number_colors);\n        (void) WriteBlobLSBLong(image,bmp_info.colors_important);\n      }\n    if ((type > 3) && ((image->alpha_trait != UndefinedPixelTrait) ||\n        (have_color_info != MagickFalse)))\n      {\n        /*\n          Write the rest of the 108-byte BMP Version 4 header.\n        */\n        (void) WriteBlobLSBLong(image,0x00ff0000U);  /* Red mask */\n        (void) WriteBlobLSBLong(image,0x0000ff00U);  /* Green mask */\n        (void) WriteBlobLSBLong(image,0x000000ffU);  /* Blue mask */\n        (void) WriteBlobLSBLong(image,0xff000000U);  /* Alpha mask */\n        (void) WriteBlobLSBLong(image,0x73524742U);  /* sRGB */\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.red_primary.x*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.red_primary.y*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          ((1.000f-(image->chromaticity.red_primary.x+\n          image->chromaticity.red_primary.y))*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.green_primary.x*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.green_primary.y*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          ((1.000f-(image->chromaticity.green_primary.x+\n          image->chromaticity.green_primary.y))*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.blue_primary.x*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.blue_primary.y*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          ((1.000f-(image->chromaticity.blue_primary.x+\n          image->chromaticity.blue_primary.y))*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (bmp_info.gamma_scale.x*0x10000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (bmp_info.gamma_scale.y*0x10000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (bmp_info.gamma_scale.z*0x10000));\n        if ((image->rendering_intent != UndefinedIntent) ||\n            (profile != (StringInfo *) NULL))\n          {\n            ssize_t\n              intent;\n\n            switch ((int) image->rendering_intent)\n            {\n              case SaturationIntent:\n              {\n                intent=LCS_GM_BUSINESS;\n                break;\n              }\n              case RelativeIntent:\n              {\n                intent=LCS_GM_GRAPHICS;\n                break;\n              }\n              case PerceptualIntent:\n              {\n                intent=LCS_GM_IMAGES;\n                break;\n              }\n              case AbsoluteIntent:\n              {\n                intent=LCS_GM_ABS_COLORIMETRIC;\n                break;\n              }\n              default:\n              {\n                intent=0;\n                break;\n              }\n            }\n            (void) WriteBlobLSBLong(image,(unsigned int) intent);\n            (void) WriteBlobLSBLong(image,0x00);  /* dummy profile data */\n            (void) WriteBlobLSBLong(image,0x00);  /* dummy profile length */\n            (void) WriteBlobLSBLong(image,0x00);  /* reserved */\n          }\n      }\n    if (image->storage_class == PseudoClass)\n      {\n        unsigned char\n          *bmp_colormap;\n\n        /*\n          Dump colormap to file.\n        */\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Colormap: %.20g entries\",(double) image->colors);\n        bmp_colormap=(unsigned char *) AcquireQuantumMemory((size_t) (1UL <<\n          bmp_info.bits_per_pixel),4*sizeof(*bmp_colormap));\n        if (bmp_colormap == (unsigned char *) NULL)\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n        q=bmp_colormap;\n        for (i=0; i < (ssize_t) MagickMin((ssize_t) image->colors,(ssize_t) bmp_info.number_colors); i++)\n        {\n          *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].blue));\n          *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].green));\n          *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].red));\n          if (type > 2)\n            *q++=(unsigned char) 0x0;\n        }\n        for ( ; i < (ssize_t) (1UL << bmp_info.bits_per_pixel); i++)\n        {\n          *q++=(unsigned char) 0x00;\n          *q++=(unsigned char) 0x00;\n          *q++=(unsigned char) 0x00;\n          if (type > 2)\n            *q++=(unsigned char) 0x00;\n        }\n        if (type <= 2)\n          (void) WriteBlob(image,(size_t) (3*(1L << bmp_info.bits_per_pixel)),\n            bmp_colormap);\n        else\n          (void) WriteBlob(image,(size_t) (4*(1L << bmp_info.bits_per_pixel)),\n            bmp_colormap);\n        bmp_colormap=(unsigned char *) RelinquishMagickMemory(bmp_colormap);\n      }\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Pixels:  %lu bytes\",bmp_info.image_size);\n    (void) WriteBlob(image,(size_t) bmp_info.image_size,pixels);\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142807,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static MagickBooleanType WriteBMPImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  BMPInfo\n    bmp_info;\n\n  const char\n    *option;\n\n  const StringInfo\n    *profile;\n\n  MagickBooleanType\n    have_color_info,\n    status;\n\n  MagickOffsetType\n    scene;\n\n  MemoryInfo\n    *pixel_info;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *q;\n\n  size_t\n    bytes_per_line,\n    type;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *bmp_data,\n    *pixels;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  type=4;\n  if (LocaleCompare(image_info->magick,\"BMP2\") == 0)\n    type=2;\n  else\n    if (LocaleCompare(image_info->magick,\"BMP3\") == 0)\n      type=3;\n\n  option=GetImageOption(image_info,\"bmp:format\");\n  if (option != (char *) NULL)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Format=%s\",option);\n\n      if (LocaleCompare(option,\"bmp2\") == 0)\n        type=2;\n      if (LocaleCompare(option,\"bmp3\") == 0)\n        type=3;\n      if (LocaleCompare(option,\"bmp4\") == 0)\n        type=4;\n    }\n\n  scene=0;\n  do\n  {\n    /*\n      Initialize BMP raster file header.\n    */\n    (void) TransformImageColorspace(image,sRGBColorspace,exception);\n    (void) ResetMagickMemory(&bmp_info,0,sizeof(bmp_info));\n    bmp_info.file_size=14+12;\n    if (type > 2)\n      bmp_info.file_size+=28;\n    bmp_info.offset_bits=bmp_info.file_size;\n    bmp_info.compression=BI_RGB;\n    if ((image->storage_class == PseudoClass) && (image->colors > 256))\n      (void) SetImageStorageClass(image,DirectClass,exception);\n    if (image->storage_class != DirectClass)\n      {\n        /*\n          Colormapped BMP raster.\n        */\n        bmp_info.bits_per_pixel=8;\n        if (image->colors <= 2)\n          bmp_info.bits_per_pixel=1;\n        else\n          if (image->colors <= 16)\n            bmp_info.bits_per_pixel=4;\n          else\n            if (image->colors <= 256)\n              bmp_info.bits_per_pixel=8;\n        if (image_info->compression == RLECompression)\n          bmp_info.bits_per_pixel=8;\n        bmp_info.number_colors=1U << bmp_info.bits_per_pixel;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          (void) SetImageStorageClass(image,DirectClass,exception);\n        else\n          if ((size_t) bmp_info.number_colors < image->colors)\n            (void) SetImageStorageClass(image,DirectClass,exception);\n          else\n            {\n              bmp_info.file_size+=3*(1UL << bmp_info.bits_per_pixel);\n              bmp_info.offset_bits+=3*(1UL << bmp_info.bits_per_pixel);\n              if (type > 2)\n                {\n                  bmp_info.file_size+=(1UL << bmp_info.bits_per_pixel);\n                  bmp_info.offset_bits+=(1UL << bmp_info.bits_per_pixel);\n                }\n            }\n      }\n    if (image->storage_class == DirectClass)\n      {\n        /*\n          Full color BMP raster.\n        */\n        bmp_info.number_colors=0;\n        bmp_info.bits_per_pixel=(unsigned short)\n          ((type > 3) && (image->alpha_trait != UndefinedPixelTrait) ? 32 : 24);\n        bmp_info.compression=(unsigned int) ((type > 3) &&\n          (image->alpha_trait != UndefinedPixelTrait) ?  BI_BITFIELDS : BI_RGB);\n        if ((type == 3) && (image->alpha_trait != UndefinedPixelTrait))\n          {\n            option=GetImageOption(image_info,\"bmp3:alpha\");\n            if (IsStringTrue(option))\n              bmp_info.bits_per_pixel=32;\n          }\n      }\n    bytes_per_line=4*((image->columns*bmp_info.bits_per_pixel+31)/32);\n    bmp_info.ba_offset=0;\n    profile=GetImageProfile(image,\"icc\");\n    have_color_info=(image->rendering_intent != UndefinedIntent) ||\n      (profile != (StringInfo *) NULL) || (image->gamma != 0.0) ?  MagickTrue :\n      MagickFalse;\n    if (type == 2)\n      bmp_info.size=12;\n    else\n      if ((type == 3) || ((image->alpha_trait == UndefinedPixelTrait) &&\n          (have_color_info == MagickFalse)))\n        {\n          type=3;\n          bmp_info.size=40;\n        }\n      else\n        {\n          int\n            extra_size;\n\n          bmp_info.size=108;\n          extra_size=68;\n          if ((image->rendering_intent != UndefinedIntent) ||\n              (profile != (StringInfo *) NULL))\n            {\n              bmp_info.size=124;\n              extra_size+=16;\n            }\n           bmp_info.file_size+=extra_size;\n           bmp_info.offset_bits+=extra_size;\n         }\n    if ((image->columns != (signed int) image->columns) ||\n        (image->rows != (signed int) image->rows))\n      ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n     bmp_info.width=(ssize_t) image->columns;\n     bmp_info.height=(ssize_t) image->rows;\n     bmp_info.planes=1;\n    bmp_info.image_size=(unsigned long) (bytes_per_line*image->rows);\n     bmp_info.file_size+=bmp_info.image_size;\n     bmp_info.x_pixels=75*39;\n     bmp_info.y_pixels=75*39;\n    switch (image->units)\n    {\n      case UndefinedResolution:\n      case PixelsPerInchResolution:\n      {\n        bmp_info.x_pixels=(unsigned int) (100.0*image->resolution.x/2.54);\n        bmp_info.y_pixels=(unsigned int) (100.0*image->resolution.y/2.54);\n        break;\n      }\n      case PixelsPerCentimeterResolution:\n      {\n        bmp_info.x_pixels=(unsigned int) (100.0*image->resolution.x);\n        bmp_info.y_pixels=(unsigned int) (100.0*image->resolution.y);\n        break;\n      }\n    }\n    bmp_info.colors_important=bmp_info.number_colors;\n    /*\n      Convert MIFF to BMP raster pixels.\n    */\n    pixel_info=AcquireVirtualMemory((size_t) bmp_info.image_size,\n      sizeof(*pixels));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    (void) ResetMagickMemory(pixels,0,(size_t) bmp_info.image_size);\n    switch (bmp_info.bits_per_pixel)\n    {\n      case 1:\n      {\n        size_t\n          bit,\n          byte;\n\n        /*\n          Convert PseudoClass image to a BMP monochrome image.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          ssize_t\n            offset;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels+(image->rows-y-1)*bytes_per_line;\n          bit=0;\n          byte=0;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            byte<<=1;\n            byte|=GetPixelIndex(image,p) != 0 ? 0x01 : 0x00;\n            bit++;\n            if (bit == 8)\n              {\n                *q++=(unsigned char) byte;\n                bit=0;\n                byte=0;\n              }\n             p+=GetPixelChannels(image);\n           }\n           if (bit != 0)\n             {\n               *q++=(unsigned char) (byte << (8-bit));\n               x++;\n             }\n          offset=(ssize_t) (image->columns+7)/8;\n          for (x=offset; x < (ssize_t) bytes_per_line; x++)\n            *q++=0x00;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case 4:\n      {\n        size_t\n          byte,\n          nibble;\n\n        ssize_t\n          offset;\n\n        /*\n          Convert PseudoClass image to a BMP monochrome image.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels+(image->rows-y-1)*bytes_per_line;\n          nibble=0;\n          byte=0;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            byte<<=4;\n            byte|=((size_t) GetPixelIndex(image,p) & 0x0f);\n            nibble++;\n            if (nibble == 2)\n              {\n                *q++=(unsigned char) byte;\n                nibble=0;\n                byte=0;\n              }\n            p+=GetPixelChannels(image);\n          }\n          if (nibble != 0)\n            {\n              *q++=(unsigned char) (byte << 4);\n              x++;\n            }\n          offset=(ssize_t) (image->columns+1)/2;\n          for (x=offset; x < (ssize_t) bytes_per_line; x++)\n            *q++=0x00;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case 8:\n      {\n        /*\n          Convert PseudoClass packet to BMP pixel.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels+(image->rows-y-1)*bytes_per_line;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *q++=(unsigned char) GetPixelIndex(image,p);\n            p+=GetPixelChannels(image);\n          }\n          for ( ; x < (ssize_t) bytes_per_line; x++)\n            *q++=0x00;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case 24:\n      {\n        /*\n          Convert DirectClass packet to BMP BGR888.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels+(image->rows-y-1)*bytes_per_line;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *q++=ScaleQuantumToChar(GetPixelBlue(image,p));\n            *q++=ScaleQuantumToChar(GetPixelGreen(image,p));\n            *q++=ScaleQuantumToChar(GetPixelRed(image,p));\n            p+=GetPixelChannels(image);\n          }\n          for (x=3L*(ssize_t) image->columns; x < (ssize_t) bytes_per_line; x++)\n            *q++=0x00;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case 32:\n      {\n        /*\n          Convert DirectClass packet to ARGB8888 pixel.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels+(image->rows-y-1)*bytes_per_line;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *q++=ScaleQuantumToChar(GetPixelBlue(image,p));\n            *q++=ScaleQuantumToChar(GetPixelGreen(image,p));\n            *q++=ScaleQuantumToChar(GetPixelRed(image,p));\n            *q++=ScaleQuantumToChar(GetPixelAlpha(image,p));\n            p+=GetPixelChannels(image);\n          }\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n    }\n    if ((type > 2) && (bmp_info.bits_per_pixel == 8))\n      if (image_info->compression != NoCompression)\n        {\n          MemoryInfo\n            *rle_info;\n\n          /*\n            Convert run-length encoded raster pixels.\n          */\n          rle_info=AcquireVirtualMemory((size_t) (2*(bytes_per_line+2)+2),\n            (image->rows+2)*sizeof(*pixels));\n          if (rle_info == (MemoryInfo *) NULL)\n            {\n              pixel_info=RelinquishVirtualMemory(pixel_info);\n              ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n            }\n          bmp_data=(unsigned char *) GetVirtualMemoryBlob(rle_info);\n          bmp_info.file_size-=bmp_info.image_size;\n          bmp_info.image_size=(unsigned int) EncodeImage(image,bytes_per_line,\n            pixels,bmp_data);\n          bmp_info.file_size+=bmp_info.image_size;\n          pixel_info=RelinquishVirtualMemory(pixel_info);\n          pixel_info=rle_info;\n          pixels=bmp_data;\n          bmp_info.compression=BI_RLE8;\n        }\n    /*\n      Write BMP for Windows, all versions, 14-byte header.\n    */\n    if (image->debug != MagickFalse)\n      {\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"   Writing BMP version %.20g datastream\",(double) type);\n        if (image->storage_class == DirectClass)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   Storage class=DirectClass\");\n        else\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   Storage class=PseudoClass\");\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"   Image depth=%.20g\",(double) image->depth);\n        if (image->alpha_trait != UndefinedPixelTrait)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   Matte=True\");\n        else\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   Matte=MagickFalse\");\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"   BMP bits_per_pixel=%.20g\",(double) bmp_info.bits_per_pixel);\n        switch ((int) bmp_info.compression)\n        {\n           case BI_RGB:\n           {\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"   Compression=BI_RGB\");\n             break;\n           }\n           case BI_RLE8:\n           {\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"   Compression=BI_RLE8\");\n             break;\n           }\n           case BI_BITFIELDS:\n           {\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"   Compression=BI_BITFIELDS\");\n             break;\n           }\n           default:\n           {\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"   Compression=UNKNOWN (%lu)\",bmp_info.compression);\n             break;\n           }\n        }\n        if (bmp_info.number_colors == 0)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   Number_colors=unspecified\");\n        else\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   Number_colors=%lu\",bmp_info.number_colors);\n      }\n    (void) WriteBlob(image,2,(unsigned char *) \"BM\");\n    (void) WriteBlobLSBLong(image,bmp_info.file_size);\n    (void) WriteBlobLSBLong(image,bmp_info.ba_offset);  /* always 0 */\n    (void) WriteBlobLSBLong(image,bmp_info.offset_bits);\n    if (type == 2)\n      {\n        /*\n          Write 12-byte version 2 bitmap header.\n        */\n        (void) WriteBlobLSBLong(image,bmp_info.size);\n        (void) WriteBlobLSBSignedShort(image,(signed short) bmp_info.width);\n        (void) WriteBlobLSBSignedShort(image,(signed short) bmp_info.height);\n        (void) WriteBlobLSBShort(image,bmp_info.planes);\n        (void) WriteBlobLSBShort(image,bmp_info.bits_per_pixel);\n      }\n    else\n      {\n        /*\n          Write 40-byte version 3+ bitmap header.\n        */\n        (void) WriteBlobLSBLong(image,bmp_info.size);\n        (void) WriteBlobLSBSignedLong(image,(signed int) bmp_info.width);\n        (void) WriteBlobLSBSignedLong(image,(signed int) bmp_info.height);\n        (void) WriteBlobLSBShort(image,bmp_info.planes);\n        (void) WriteBlobLSBShort(image,bmp_info.bits_per_pixel);\n        (void) WriteBlobLSBLong(image,bmp_info.compression);\n        (void) WriteBlobLSBLong(image,bmp_info.image_size);\n        (void) WriteBlobLSBLong(image,bmp_info.x_pixels);\n        (void) WriteBlobLSBLong(image,bmp_info.y_pixels);\n        (void) WriteBlobLSBLong(image,bmp_info.number_colors);\n        (void) WriteBlobLSBLong(image,bmp_info.colors_important);\n      }\n    if ((type > 3) && ((image->alpha_trait != UndefinedPixelTrait) ||\n        (have_color_info != MagickFalse)))\n      {\n        /*\n          Write the rest of the 108-byte BMP Version 4 header.\n        */\n        (void) WriteBlobLSBLong(image,0x00ff0000U);  /* Red mask */\n        (void) WriteBlobLSBLong(image,0x0000ff00U);  /* Green mask */\n        (void) WriteBlobLSBLong(image,0x000000ffU);  /* Blue mask */\n        (void) WriteBlobLSBLong(image,0xff000000U);  /* Alpha mask */\n        (void) WriteBlobLSBLong(image,0x73524742U);  /* sRGB */\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.red_primary.x*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.red_primary.y*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          ((1.000f-(image->chromaticity.red_primary.x+\n          image->chromaticity.red_primary.y))*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.green_primary.x*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.green_primary.y*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          ((1.000f-(image->chromaticity.green_primary.x+\n          image->chromaticity.green_primary.y))*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.blue_primary.x*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.blue_primary.y*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          ((1.000f-(image->chromaticity.blue_primary.x+\n          image->chromaticity.blue_primary.y))*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (bmp_info.gamma_scale.x*0x10000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (bmp_info.gamma_scale.y*0x10000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (bmp_info.gamma_scale.z*0x10000));\n        if ((image->rendering_intent != UndefinedIntent) ||\n            (profile != (StringInfo *) NULL))\n          {\n            ssize_t\n              intent;\n\n            switch ((int) image->rendering_intent)\n            {\n              case SaturationIntent:\n              {\n                intent=LCS_GM_BUSINESS;\n                break;\n              }\n              case RelativeIntent:\n              {\n                intent=LCS_GM_GRAPHICS;\n                break;\n              }\n              case PerceptualIntent:\n              {\n                intent=LCS_GM_IMAGES;\n                break;\n              }\n              case AbsoluteIntent:\n              {\n                intent=LCS_GM_ABS_COLORIMETRIC;\n                break;\n              }\n              default:\n              {\n                intent=0;\n                break;\n              }\n            }\n            (void) WriteBlobLSBLong(image,(unsigned int) intent);\n            (void) WriteBlobLSBLong(image,0x00);  /* dummy profile data */\n            (void) WriteBlobLSBLong(image,0x00);  /* dummy profile length */\n            (void) WriteBlobLSBLong(image,0x00);  /* reserved */\n          }\n      }\n    if (image->storage_class == PseudoClass)\n      {\n        unsigned char\n          *bmp_colormap;\n\n        /*\n          Dump colormap to file.\n        */\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Colormap: %.20g entries\",(double) image->colors);\n        bmp_colormap=(unsigned char *) AcquireQuantumMemory((size_t) (1UL <<\n          bmp_info.bits_per_pixel),4*sizeof(*bmp_colormap));\n        if (bmp_colormap == (unsigned char *) NULL)\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n        q=bmp_colormap;\n        for (i=0; i < (ssize_t) MagickMin((ssize_t) image->colors,(ssize_t) bmp_info.number_colors); i++)\n        {\n          *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].blue));\n          *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].green));\n          *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].red));\n          if (type > 2)\n            *q++=(unsigned char) 0x0;\n        }\n        for ( ; i < (ssize_t) (1UL << bmp_info.bits_per_pixel); i++)\n        {\n          *q++=(unsigned char) 0x00;\n          *q++=(unsigned char) 0x00;\n          *q++=(unsigned char) 0x00;\n          if (type > 2)\n            *q++=(unsigned char) 0x00;\n        }\n        if (type <= 2)\n          (void) WriteBlob(image,(size_t) (3*(1L << bmp_info.bits_per_pixel)),\n            bmp_colormap);\n        else\n          (void) WriteBlob(image,(size_t) (4*(1L << bmp_info.bits_per_pixel)),\n            bmp_colormap);\n        bmp_colormap=(unsigned char *) RelinquishMagickMemory(bmp_colormap);\n      }\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Pixels:  %lu bytes\",bmp_info.image_size);\n    (void) WriteBlob(image,(size_t) bmp_info.image_size,pixels);\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142808,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static int decode_level3_header(LHAFileHeader **header, LHAInputStream *stream)\n{\n\tunsigned int header_len;\n\n\n\tif (lha_decode_uint16(&RAW_DATA(header, 0)) != 4) {\n\t\treturn 0;\n\t}\n\n\n\tif (!extend_raw_data(header, stream,\n\t                     LEVEL_3_HEADER_LEN - RAW_DATA_LEN(header))) {\n\t\treturn 0;\n\t}\n\n \n \theader_len = lha_decode_uint32(&RAW_DATA(header, 24));\n \n\tif (header_len > LEVEL_3_MAX_HEADER_LEN) {\n \t\treturn 0;\n \t}\n \n\tif (!extend_raw_data(header, stream,\n\t                     header_len - RAW_DATA_LEN(header))) {\n\t\treturn 0;\n\t}\n\n\n\tmemcpy((*header)->compress_method, &RAW_DATA(header, 2), 5);\n\t(*header)->compress_method[5] = '\\0';\n\n\n\t(*header)->compressed_length = lha_decode_uint32(&RAW_DATA(header, 7));\n\t(*header)->length = lha_decode_uint32(&RAW_DATA(header, 11));\n\n\n\t(*header)->timestamp = lha_decode_uint32(&RAW_DATA(header, 15));\n\n\n\t(*header)->crc = lha_decode_uint16(&RAW_DATA(header, 21));\n\n\n\t(*header)->os_type = RAW_DATA(header, 23);\n\n\tif (!decode_extended_headers(header, 28)) {\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142815,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static int decode_level3_header(LHAFileHeader **header, LHAInputStream *stream)\n{\n\tunsigned int header_len;\n\n\n\tif (lha_decode_uint16(&RAW_DATA(header, 0)) != 4) {\n\t\treturn 0;\n\t}\n\n\n\tif (!extend_raw_data(header, stream,\n\t                     LEVEL_3_HEADER_LEN - RAW_DATA_LEN(header))) {\n\t\treturn 0;\n\t}\n\n \n \theader_len = lha_decode_uint32(&RAW_DATA(header, 24));\n \n\tif (header_len > LEVEL_3_MAX_HEADER_LEN\n\t || header_len < RAW_DATA_LEN(header)) {\n \t\treturn 0;\n \t}\n \n\tif (!extend_raw_data(header, stream,\n\t                     header_len - RAW_DATA_LEN(header))) {\n\t\treturn 0;\n\t}\n\n\n\tmemcpy((*header)->compress_method, &RAW_DATA(header, 2), 5);\n\t(*header)->compress_method[5] = '\\0';\n\n\n\t(*header)->compressed_length = lha_decode_uint32(&RAW_DATA(header, 7));\n\t(*header)->length = lha_decode_uint32(&RAW_DATA(header, 11));\n\n\n\t(*header)->timestamp = lha_decode_uint32(&RAW_DATA(header, 15));\n\n\n\t(*header)->crc = lha_decode_uint16(&RAW_DATA(header, 21));\n\n\n\t(*header)->os_type = RAW_DATA(header, 23);\n\n\tif (!decode_extended_headers(header, 28)) {\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142816,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "layer_resize(int layer, int x_size, int y_size)\n{\n\tint                 old_height;\n\tint                 old_width;\n\tstruct map_tile*    tile;\n\tint                 tile_width;\n\tint                 tile_height;\n \tstruct map_tile*    tilemap;\n \tstruct map_trigger* trigger;\n \tstruct map_zone*    zone;\n \n \tint x, y, i;\n \n\told_width = s_map->layers[layer].width;\n\told_height = s_map->layers[layer].height;\n \n\tif (!(tilemap = malloc(x_size * y_size * sizeof(struct map_tile))))\n \t\treturn false;\n \tfor (x = 0; x < x_size; ++x) {\n \t\tfor (y = 0; y < y_size; ++y) {\n\t\t\tif (x < old_width && y < old_height) {\n\t\t\t\ttilemap[x + y * x_size] = s_map->layers[layer].tilemap[x + y * old_width];\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttile = &tilemap[x + y * x_size];\n\t\t\t\ttile->frames_left = tileset_get_delay(s_map->tileset, 0);\n\t\t\t\ttile->tile_index = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tfree(s_map->layers[layer].tilemap);\n\ts_map->layers[layer].tilemap = tilemap;\n\ts_map->layers[layer].width = x_size;\n\ts_map->layers[layer].height = y_size;\n\n\ttileset_get_size(s_map->tileset, &tile_width, &tile_height);\n\ts_map->width = 0;\n\ts_map->height = 0;\n\tfor (i = 0; i < s_map->num_layers; ++i) {\n\t\tif (!s_map->layers[i].is_parallax) {\n\t\t\ts_map->width = fmax(s_map->width, s_map->layers[i].width * tile_width);\n\t\t\ts_map->height = fmax(s_map->height, s_map->layers[i].height * tile_height);\n\t\t}\n\t}\n\n\tfor (i = (int)vector_len(s_map->zones) - 1; i >= 0; --i) {\n\t\tzone = vector_get(s_map->zones, i);\n\t\tif (zone->bounds.x1 >= s_map->width || zone->bounds.y1 >= s_map->height)\n\t\t\tvector_remove(s_map->zones, i);\n\t\telse {\n\t\t\tif (zone->bounds.x2 > s_map->width)\n\t\t\t\tzone->bounds.x2 = s_map->width;\n\t\t\tif (zone->bounds.y2 > s_map->height)\n\t\t\t\tzone->bounds.y2 = s_map->height;\n\t\t}\n\t}\n\tfor (i = (int)vector_len(s_map->triggers) - 1; i >= 0; --i) {\n\t\ttrigger = vector_get(s_map->triggers, i);\n\t\tif (trigger->x >= s_map->width || trigger->y >= s_map->height)\n\t\t\tvector_remove(s_map->triggers, i);\n\t}\n\n\treturn true;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142855,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "layer_resize(int layer, int x_size, int y_size)\n{\n\tint                 old_height;\n\tint                 old_width;\n\tstruct map_tile*    tile;\n\tint                 tile_width;\n\tint                 tile_height;\n \tstruct map_tile*    tilemap;\n \tstruct map_trigger* trigger;\n \tstruct map_zone*    zone;\n\tsize_t              tilemap_size;\n \n \tint x, y, i;\n \n\told_width = s_map->layers[layer].width;\n\told_height = s_map->layers[layer].height;\n \n\ttilemap_size = x_size * y_size * sizeof(struct map_tile);\n\tif (x_size == 0 || tilemap_size / x_size / sizeof(struct map_tile) != y_size\n\t\t|| !(tilemap = malloc(tilemap_size)))\n \t\treturn false;\n \tfor (x = 0; x < x_size; ++x) {\n \t\tfor (y = 0; y < y_size; ++y) {\n\t\t\tif (x < old_width && y < old_height) {\n\t\t\t\ttilemap[x + y * x_size] = s_map->layers[layer].tilemap[x + y * old_width];\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttile = &tilemap[x + y * x_size];\n\t\t\t\ttile->frames_left = tileset_get_delay(s_map->tileset, 0);\n\t\t\t\ttile->tile_index = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tfree(s_map->layers[layer].tilemap);\n\ts_map->layers[layer].tilemap = tilemap;\n\ts_map->layers[layer].width = x_size;\n\ts_map->layers[layer].height = y_size;\n\n\ttileset_get_size(s_map->tileset, &tile_width, &tile_height);\n\ts_map->width = 0;\n\ts_map->height = 0;\n\tfor (i = 0; i < s_map->num_layers; ++i) {\n\t\tif (!s_map->layers[i].is_parallax) {\n\t\t\ts_map->width = fmax(s_map->width, s_map->layers[i].width * tile_width);\n\t\t\ts_map->height = fmax(s_map->height, s_map->layers[i].height * tile_height);\n\t\t}\n\t}\n\n\tfor (i = (int)vector_len(s_map->zones) - 1; i >= 0; --i) {\n\t\tzone = vector_get(s_map->zones, i);\n\t\tif (zone->bounds.x1 >= s_map->width || zone->bounds.y1 >= s_map->height)\n\t\t\tvector_remove(s_map->zones, i);\n\t\telse {\n\t\t\tif (zone->bounds.x2 > s_map->width)\n\t\t\t\tzone->bounds.x2 = s_map->width;\n\t\t\tif (zone->bounds.y2 > s_map->height)\n\t\t\t\tzone->bounds.y2 = s_map->height;\n\t\t}\n\t}\n\tfor (i = (int)vector_len(s_map->triggers) - 1; i >= 0; --i) {\n\t\ttrigger = vector_get(s_map->triggers, i);\n\t\tif (trigger->x >= s_map->width || trigger->y >= s_map->height)\n\t\t\tvector_remove(s_map->triggers, i);\n\t}\n\n\treturn true;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142856,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": " static inline void process_get_command(conn *c, token_t *tokens, size_t ntokens, bool return_cas) {\n     char *key;\n    size_t nkey;\n    int i = 0;\n    item *it;\n    token_t *key_token = &tokens[KEY_TOKEN];\n    char *suffix;\n    assert(c != NULL);\n\n    do {\n        while(key_token->length != 0) {\n\n            key = key_token->value;\n            nkey = key_token->length;\n\n            if(nkey > KEY_MAX_LENGTH) {\n                out_string(c, \"CLIENT_ERROR bad command line format\");\n                while (i-- > 0) {\n                    item_remove(*(c->ilist + i));\n                }\n                 return;\n             }\n \n            it = item_get(key, nkey, c, DO_UPDATE);\n             if (settings.detail_enabled) {\n                 stats_prefix_record_get(key, nkey, NULL != it);\n             }\n            if (it) {\n                if (i >= c->isize) {\n                    item **new_list = realloc(c->ilist, sizeof(item *) * c->isize * 2);\n                    if (new_list) {\n                        c->isize *= 2;\n                        c->ilist = new_list;\n                    } else {\n                        STATS_LOCK();\n                        stats.malloc_fails++;\n                        STATS_UNLOCK();\n                        item_remove(it);\n                        break;\n                    }\n                }\n\n                /*\n                 * Construct the response. Each hit adds three elements to the\n                 * outgoing data list:\n                 *   \"VALUE \"\n                 *   key\n                 *   \" \" + flags + \" \" + data length + \"\\r\\n\" + data (with \\r\\n)\n                 */\n\n                if (return_cas || !settings.inline_ascii_response)\n                {\n                  MEMCACHED_COMMAND_GET(c->sfd, ITEM_key(it), it->nkey,\n                                        it->nbytes, ITEM_get_cas(it));\n                  /* Goofy mid-flight realloc. */\n                  if (i >= c->suffixsize) {\n                    char **new_suffix_list = realloc(c->suffixlist,\n                                           sizeof(char *) * c->suffixsize * 2);\n                    if (new_suffix_list) {\n                        c->suffixsize *= 2;\n                        c->suffixlist  = new_suffix_list;\n                    } else {\n                        STATS_LOCK();\n                        stats.malloc_fails++;\n                        STATS_UNLOCK();\n                        item_remove(it);\n                        break;\n                    }\n                  }\n\n                  suffix = do_cache_alloc(c->thread->suffix_cache);\n                  if (suffix == NULL) {\n                      STATS_LOCK();\n                      stats.malloc_fails++;\n                      STATS_UNLOCK();\n                      out_of_memory(c, \"SERVER_ERROR out of memory making CAS suffix\");\n                      item_remove(it);\n                      while (i-- > 0) {\n                          item_remove(*(c->ilist + i));\n                      }\n                      return;\n                  }\n                  *(c->suffixlist + i) = suffix;\n                  int suffix_len = make_ascii_get_suffix(suffix, it, return_cas);\n                  if (add_iov(c, \"VALUE \", 6) != 0 ||\n                      add_iov(c, ITEM_key(it), it->nkey) != 0 ||\n                      (settings.inline_ascii_response && add_iov(c, ITEM_suffix(it), it->nsuffix - 2) != 0) ||\n                      add_iov(c, suffix, suffix_len) != 0)\n                      {\n                          item_remove(it);\n                          break;\n                      }\n                  if ((it->it_flags & ITEM_CHUNKED) == 0) {\n                      add_iov(c, ITEM_data(it), it->nbytes);\n                  } else if (add_chunked_item_iovs(c, it, it->nbytes) != 0) {\n                      item_remove(it);\n                      break;\n                  }\n                }\n                else\n                {\n                  MEMCACHED_COMMAND_GET(c->sfd, ITEM_key(it), it->nkey,\n                                        it->nbytes, ITEM_get_cas(it));\n                  if (add_iov(c, \"VALUE \", 6) != 0 ||\n                      add_iov(c, ITEM_key(it), it->nkey) != 0)\n                      {\n                          item_remove(it);\n                          break;\n                      }\n                  if ((it->it_flags & ITEM_CHUNKED) == 0)\n                      {\n                          if (add_iov(c, ITEM_suffix(it), it->nsuffix + it->nbytes) != 0)\n                          {\n                              item_remove(it);\n                              break;\n                          }\n                      } else if (add_iov(c, ITEM_suffix(it), it->nsuffix) != 0 ||\n                                 add_chunked_item_iovs(c, it, it->nbytes) != 0) {\n                          item_remove(it);\n                          break;\n                      }\n                }\n\n\n                if (settings.verbose > 1) {\n                    int ii;\n                    fprintf(stderr, \">%d sending key \", c->sfd);\n                    for (ii = 0; ii < it->nkey; ++ii) {\n                        fprintf(stderr, \"%c\", key[ii]);\n                    }\n                    fprintf(stderr, \"\\n\");\n                }\n\n                /* item_get() has incremented it->refcount for us */\n                pthread_mutex_lock(&c->thread->stats.mutex);\n                c->thread->stats.slab_stats[ITEM_clsid(it)].get_hits++;\n                c->thread->stats.get_cmds++;\n                pthread_mutex_unlock(&c->thread->stats.mutex);\n                *(c->ilist + i) = it;\n                i++;\n\n            } else {\n                pthread_mutex_lock(&c->thread->stats.mutex);\n                c->thread->stats.get_misses++;\n                c->thread->stats.get_cmds++;\n                pthread_mutex_unlock(&c->thread->stats.mutex);\n                MEMCACHED_COMMAND_GET(c->sfd, key, nkey, -1, 0);\n            }\n\n            key_token++;\n        }\n\n        /*\n         * If the command string hasn't been fully processed, get the next set\n         * of tokens.\n         */\n        if(key_token->value != NULL) {\n            ntokens = tokenize_command(key_token->value, tokens, MAX_TOKENS);\n            key_token = tokens;\n        }\n\n    } while(key_token->value != NULL);\n\n    c->icurr = c->ilist;\n    c->ileft = i;\n    if (return_cas || !settings.inline_ascii_response) {\n        c->suffixcurr = c->suffixlist;\n        c->suffixleft = i;\n    }\n\n    if (settings.verbose > 1)\n        fprintf(stderr, \">%d END\\n\", c->sfd);\n\n    /*\n        If the loop was terminated because of out-of-memory, it is not\n        reliable to add END\\r\\n to the buffer, because it might not end\n        in \\r\\n. So we send SERVER_ERROR instead.\n    */\n    if (key_token->value != NULL || add_iov(c, \"END\\r\\n\", 5) != 0\n        || (IS_UDP(c->transport) && build_udp_headers(c) != 0)) {\n        out_of_memory(c, \"SERVER_ERROR out of memory writing get response\");\n    }\n    else {\n        conn_set_state(c, conn_mwrite);\n        c->msgcurr = 0;\n    }\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142857,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": " static inline void process_get_command(conn *c, token_t *tokens, size_t ntokens, bool return_cas) {\n     char *key;\n    size_t nkey;\n    int i = 0;\n    item *it;\n    token_t *key_token = &tokens[KEY_TOKEN];\n    char *suffix;\n    assert(c != NULL);\n\n    do {\n        while(key_token->length != 0) {\n\n            key = key_token->value;\n            nkey = key_token->length;\n\n            if(nkey > KEY_MAX_LENGTH) {\n                out_string(c, \"CLIENT_ERROR bad command line format\");\n                while (i-- > 0) {\n                    item_remove(*(c->ilist + i));\n                }\n                 return;\n             }\n \n            it = limited_get(key, nkey, c);\n             if (settings.detail_enabled) {\n                 stats_prefix_record_get(key, nkey, NULL != it);\n             }\n            if (it) {\n                if (i >= c->isize) {\n                    item **new_list = realloc(c->ilist, sizeof(item *) * c->isize * 2);\n                    if (new_list) {\n                        c->isize *= 2;\n                        c->ilist = new_list;\n                    } else {\n                        STATS_LOCK();\n                        stats.malloc_fails++;\n                        STATS_UNLOCK();\n                        item_remove(it);\n                        break;\n                    }\n                }\n\n                /*\n                 * Construct the response. Each hit adds three elements to the\n                 * outgoing data list:\n                 *   \"VALUE \"\n                 *   key\n                 *   \" \" + flags + \" \" + data length + \"\\r\\n\" + data (with \\r\\n)\n                 */\n\n                if (return_cas || !settings.inline_ascii_response)\n                {\n                  MEMCACHED_COMMAND_GET(c->sfd, ITEM_key(it), it->nkey,\n                                        it->nbytes, ITEM_get_cas(it));\n                  /* Goofy mid-flight realloc. */\n                  if (i >= c->suffixsize) {\n                    char **new_suffix_list = realloc(c->suffixlist,\n                                           sizeof(char *) * c->suffixsize * 2);\n                    if (new_suffix_list) {\n                        c->suffixsize *= 2;\n                        c->suffixlist  = new_suffix_list;\n                    } else {\n                        STATS_LOCK();\n                        stats.malloc_fails++;\n                        STATS_UNLOCK();\n                        item_remove(it);\n                        break;\n                    }\n                  }\n\n                  suffix = do_cache_alloc(c->thread->suffix_cache);\n                  if (suffix == NULL) {\n                      STATS_LOCK();\n                      stats.malloc_fails++;\n                      STATS_UNLOCK();\n                      out_of_memory(c, \"SERVER_ERROR out of memory making CAS suffix\");\n                      item_remove(it);\n                      while (i-- > 0) {\n                          item_remove(*(c->ilist + i));\n                      }\n                      return;\n                  }\n                  *(c->suffixlist + i) = suffix;\n                  int suffix_len = make_ascii_get_suffix(suffix, it, return_cas);\n                  if (add_iov(c, \"VALUE \", 6) != 0 ||\n                      add_iov(c, ITEM_key(it), it->nkey) != 0 ||\n                      (settings.inline_ascii_response && add_iov(c, ITEM_suffix(it), it->nsuffix - 2) != 0) ||\n                      add_iov(c, suffix, suffix_len) != 0)\n                      {\n                          item_remove(it);\n                          break;\n                      }\n                  if ((it->it_flags & ITEM_CHUNKED) == 0) {\n                      add_iov(c, ITEM_data(it), it->nbytes);\n                  } else if (add_chunked_item_iovs(c, it, it->nbytes) != 0) {\n                      item_remove(it);\n                      break;\n                  }\n                }\n                else\n                {\n                  MEMCACHED_COMMAND_GET(c->sfd, ITEM_key(it), it->nkey,\n                                        it->nbytes, ITEM_get_cas(it));\n                  if (add_iov(c, \"VALUE \", 6) != 0 ||\n                      add_iov(c, ITEM_key(it), it->nkey) != 0)\n                      {\n                          item_remove(it);\n                          break;\n                      }\n                  if ((it->it_flags & ITEM_CHUNKED) == 0)\n                      {\n                          if (add_iov(c, ITEM_suffix(it), it->nsuffix + it->nbytes) != 0)\n                          {\n                              item_remove(it);\n                              break;\n                          }\n                      } else if (add_iov(c, ITEM_suffix(it), it->nsuffix) != 0 ||\n                                 add_chunked_item_iovs(c, it, it->nbytes) != 0) {\n                          item_remove(it);\n                          break;\n                      }\n                }\n\n\n                if (settings.verbose > 1) {\n                    int ii;\n                    fprintf(stderr, \">%d sending key \", c->sfd);\n                    for (ii = 0; ii < it->nkey; ++ii) {\n                        fprintf(stderr, \"%c\", key[ii]);\n                    }\n                    fprintf(stderr, \"\\n\");\n                }\n\n                /* item_get() has incremented it->refcount for us */\n                pthread_mutex_lock(&c->thread->stats.mutex);\n                c->thread->stats.slab_stats[ITEM_clsid(it)].get_hits++;\n                c->thread->stats.get_cmds++;\n                pthread_mutex_unlock(&c->thread->stats.mutex);\n                *(c->ilist + i) = it;\n                i++;\n\n            } else {\n                pthread_mutex_lock(&c->thread->stats.mutex);\n                c->thread->stats.get_misses++;\n                c->thread->stats.get_cmds++;\n                pthread_mutex_unlock(&c->thread->stats.mutex);\n                MEMCACHED_COMMAND_GET(c->sfd, key, nkey, -1, 0);\n            }\n\n            key_token++;\n        }\n\n        /*\n         * If the command string hasn't been fully processed, get the next set\n         * of tokens.\n         */\n        if(key_token->value != NULL) {\n            ntokens = tokenize_command(key_token->value, tokens, MAX_TOKENS);\n            key_token = tokens;\n        }\n\n    } while(key_token->value != NULL);\n\n    c->icurr = c->ilist;\n    c->ileft = i;\n    if (return_cas || !settings.inline_ascii_response) {\n        c->suffixcurr = c->suffixlist;\n        c->suffixleft = i;\n    }\n\n    if (settings.verbose > 1)\n        fprintf(stderr, \">%d END\\n\", c->sfd);\n\n    /*\n        If the loop was terminated because of out-of-memory, it is not\n        reliable to add END\\r\\n to the buffer, because it might not end\n        in \\r\\n. So we send SERVER_ERROR instead.\n    */\n    if (key_token->value != NULL || add_iov(c, \"END\\r\\n\", 5) != 0\n        || (IS_UDP(c->transport) && build_udp_headers(c) != 0)) {\n        out_of_memory(c, \"SERVER_ERROR out of memory writing get response\");\n    }\n    else {\n        conn_set_state(c, conn_mwrite);\n        c->msgcurr = 0;\n    }\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142858,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "int URI_FUNC(ComposeQueryEngine)(URI_CHAR * dest,\n\t\tconst URI_TYPE(QueryList) * queryList,\n\t\tint maxChars, int * charsWritten, int * charsRequired,\n\t\tUriBool spaceToPlus, UriBool normalizeBreaks) {\n\tUriBool firstItem = URI_TRUE;\n\tint ampersandLen = 0;  /* increased to 1 from second item on */\n\tURI_CHAR * write = dest;\n\n\t/* Subtract terminator */\n\tif (dest == NULL) {\n\t\t*charsRequired = 0;\n\t} else {\n\t\tmaxChars--;\n\t}\n\n\twhile (queryList != NULL) {\n\t\tconst URI_CHAR * const key = queryList->key;\n \t\tconst URI_CHAR * const value = queryList->value;\n \t\tconst int worstCase = (normalizeBreaks == URI_TRUE ? 6 : 3);\n \t\tconst int keyLen = (key == NULL) ? 0 : (int)URI_STRLEN(key);\n\t\tconst int keyRequiredChars = worstCase * keyLen;\n \t\tconst int valueLen = (value == NULL) ? 0 : (int)URI_STRLEN(value);\n\t\tconst int valueRequiredChars = worstCase * valueLen;\n \n \t\tif (dest == NULL) {\n \t\t\t(*charsRequired) += ampersandLen + keyRequiredChars + ((value == NULL)\n\t\t\t\t\t\t? 0\n\t\t\t\t\t\t: 1 + valueRequiredChars);\n\n\t\t\tif (firstItem == URI_TRUE) {\n\t\t\t\tampersandLen = 1;\n\t\t\t\tfirstItem = URI_FALSE;\n\t\t\t}\n\t\t} else {\n\t\t\tif ((write - dest) + ampersandLen + keyRequiredChars > maxChars) {\n\t\t\t\treturn URI_ERROR_OUTPUT_TOO_LARGE;\n\t\t\t}\n\n\t\t\t/* Copy key */\n\t\t\tif (firstItem == URI_TRUE) {\n\t\t\t\tampersandLen = 1;\n\t\t\t\tfirstItem = URI_FALSE;\n\t\t\t} else {\n\t\t\t\twrite[0] = _UT('&');\n\t\t\t\twrite++;\n\t\t\t}\n\t\t\twrite = URI_FUNC(EscapeEx)(key, key + keyLen,\n\t\t\t\t\twrite, spaceToPlus, normalizeBreaks);\n\n\t\t\tif (value != NULL) {\n\t\t\t\tif ((write - dest) + 1 + valueRequiredChars > maxChars) {\n\t\t\t\t\treturn URI_ERROR_OUTPUT_TOO_LARGE;\n\t\t\t\t}\n\n\t\t\t\t/* Copy value */\n\t\t\t\twrite[0] = _UT('=');\n\t\t\t\twrite++;\n\t\t\t\twrite = URI_FUNC(EscapeEx)(value, value + valueLen,\n\t\t\t\t\t\twrite, spaceToPlus, normalizeBreaks);\n\t\t\t}\n\t\t}\n\n\t\tqueryList = queryList->next;\n\t}\n\n\tif (dest != NULL) {\n\t\twrite[0] = _UT('\\0');\n\t\tif (charsWritten != NULL) {\n\t\t\t*charsWritten = (int)(write - dest) + 1; /* .. for terminator */\n\t\t}\n\t}\n\n\treturn URI_SUCCESS;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142873,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "int URI_FUNC(ComposeQueryEngine)(URI_CHAR * dest,\n\t\tconst URI_TYPE(QueryList) * queryList,\n\t\tint maxChars, int * charsWritten, int * charsRequired,\n\t\tUriBool spaceToPlus, UriBool normalizeBreaks) {\n\tUriBool firstItem = URI_TRUE;\n\tint ampersandLen = 0;  /* increased to 1 from second item on */\n\tURI_CHAR * write = dest;\n\n\t/* Subtract terminator */\n\tif (dest == NULL) {\n\t\t*charsRequired = 0;\n\t} else {\n\t\tmaxChars--;\n\t}\n\n\twhile (queryList != NULL) {\n\t\tconst URI_CHAR * const key = queryList->key;\n \t\tconst URI_CHAR * const value = queryList->value;\n \t\tconst int worstCase = (normalizeBreaks == URI_TRUE ? 6 : 3);\n \t\tconst int keyLen = (key == NULL) ? 0 : (int)URI_STRLEN(key);\n\t\tint keyRequiredChars;\n \t\tconst int valueLen = (value == NULL) ? 0 : (int)URI_STRLEN(value);\n\t\tint valueRequiredChars;\n\n\t\tif ((keyLen >= INT_MAX / worstCase) || (valueLen >= INT_MAX / worstCase)) {\n\t\t\treturn URI_ERROR_OUTPUT_TOO_LARGE;\n\t\t}\n\t\tkeyRequiredChars = worstCase * keyLen;\n\t\tvalueRequiredChars = worstCase * valueLen;\n \n \t\tif (dest == NULL) {\n \t\t\t(*charsRequired) += ampersandLen + keyRequiredChars + ((value == NULL)\n\t\t\t\t\t\t? 0\n\t\t\t\t\t\t: 1 + valueRequiredChars);\n\n\t\t\tif (firstItem == URI_TRUE) {\n\t\t\t\tampersandLen = 1;\n\t\t\t\tfirstItem = URI_FALSE;\n\t\t\t}\n\t\t} else {\n\t\t\tif ((write - dest) + ampersandLen + keyRequiredChars > maxChars) {\n\t\t\t\treturn URI_ERROR_OUTPUT_TOO_LARGE;\n\t\t\t}\n\n\t\t\t/* Copy key */\n\t\t\tif (firstItem == URI_TRUE) {\n\t\t\t\tampersandLen = 1;\n\t\t\t\tfirstItem = URI_FALSE;\n\t\t\t} else {\n\t\t\t\twrite[0] = _UT('&');\n\t\t\t\twrite++;\n\t\t\t}\n\t\t\twrite = URI_FUNC(EscapeEx)(key, key + keyLen,\n\t\t\t\t\twrite, spaceToPlus, normalizeBreaks);\n\n\t\t\tif (value != NULL) {\n\t\t\t\tif ((write - dest) + 1 + valueRequiredChars > maxChars) {\n\t\t\t\t\treturn URI_ERROR_OUTPUT_TOO_LARGE;\n\t\t\t\t}\n\n\t\t\t\t/* Copy value */\n\t\t\t\twrite[0] = _UT('=');\n\t\t\t\twrite++;\n\t\t\t\twrite = URI_FUNC(EscapeEx)(value, value + valueLen,\n\t\t\t\t\t\twrite, spaceToPlus, normalizeBreaks);\n\t\t\t}\n\t\t}\n\n\t\tqueryList = queryList->next;\n\t}\n\n\tif (dest != NULL) {\n\t\twrite[0] = _UT('\\0');\n\t\tif (charsWritten != NULL) {\n\t\t\t*charsWritten = (int)(write - dest) + 1; /* .. for terminator */\n\t\t}\n\t}\n\n\treturn URI_SUCCESS;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142874,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "void AllocateDataSet(cmsIT8* it8)\n{\n    TABLE* t = GetTable(it8);\n\n    if (t -> Data) return;    // Already allocated\n\n     t-> nSamples   = atoi(cmsIT8GetProperty(it8, \"NUMBER_OF_FIELDS\"));\n     t-> nPatches   = atoi(cmsIT8GetProperty(it8, \"NUMBER_OF_SETS\"));\n \n    t-> Data = (char**)AllocChunk (it8, ((cmsUInt32Number) t->nSamples + 1) * ((cmsUInt32Number) t->nPatches + 1) *sizeof (char*));\n    if (t->Data == NULL) {\n \n        SynError(it8, \"AllocateDataSet: Unable to allocate data array\");\n     }\n \n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142925,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "void AllocateDataSet(cmsIT8* it8)\n{\n    TABLE* t = GetTable(it8);\n\n    if (t -> Data) return;    // Already allocated\n\n     t-> nSamples   = atoi(cmsIT8GetProperty(it8, \"NUMBER_OF_FIELDS\"));\n     t-> nPatches   = atoi(cmsIT8GetProperty(it8, \"NUMBER_OF_SETS\"));\n \n    if (t -> nSamples < 0 || t->nSamples > 0x7ffe || t->nPatches < 0 || t->nPatches > 0x7ffe)\n    {\n        SynError(it8, \"AllocateDataSet: too much data\");\n    }\n    else {\n        t->Data = (char**)AllocChunk(it8, ((cmsUInt32Number)t->nSamples + 1) * ((cmsUInt32Number)t->nPatches + 1) * sizeof(char*));\n        if (t->Data == NULL) {\n \n            SynError(it8, \"AllocateDataSet: Unable to allocate data array\");\n        }\n     }\n \n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142926,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "png_check_chunk_length(png_const_structrp png_ptr, const png_uint_32 length)\n{\n   png_alloc_size_t limit = PNG_UINT_31_MAX;\n\n# ifdef PNG_SET_USER_LIMITS_SUPPORTED\n   if (png_ptr->user_chunk_malloc_max > 0 &&\n       png_ptr->user_chunk_malloc_max < limit)\n      limit = png_ptr->user_chunk_malloc_max;\n# elif PNG_USER_CHUNK_MALLOC_MAX > 0\n   if (PNG_USER_CHUNK_MALLOC_MAX < limit)\n      limit = PNG_USER_CHUNK_MALLOC_MAX;\n# endif\n   if (png_ptr->chunk_name == png_IDAT)\n    {\n       png_alloc_size_t idat_limit = PNG_UINT_31_MAX;\n       size_t row_factor =\n         (png_ptr->width * png_ptr->channels * (png_ptr->bit_depth > 8? 2: 1)\n          + 1 + (png_ptr->interlaced? 6: 0));\n       if (png_ptr->height > PNG_UINT_32_MAX/row_factor)\n         idat_limit=PNG_UINT_31_MAX;\n       else\n          idat_limit = png_ptr->height * row_factor;\n       row_factor = row_factor > 32566? 32566 : row_factor;\n      idat_limit += 6 + 5*(idat_limit/row_factor+1); /* zlib+deflate overhead */\n      idat_limit=idat_limit < PNG_UINT_31_MAX? idat_limit : PNG_UINT_31_MAX;\n      limit = limit < idat_limit? idat_limit : limit;\n   }\n\n   if (length > limit)\n   {\n      png_debug2(0,\" length = %lu, limit = %lu\",\n         (unsigned long)length,(unsigned long)limit);\n      png_chunk_error(png_ptr, \"chunk data is too large\");\n   }\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142973,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "png_check_chunk_length(png_const_structrp png_ptr, const png_uint_32 length)\n{\n   png_alloc_size_t limit = PNG_UINT_31_MAX;\n\n# ifdef PNG_SET_USER_LIMITS_SUPPORTED\n   if (png_ptr->user_chunk_malloc_max > 0 &&\n       png_ptr->user_chunk_malloc_max < limit)\n      limit = png_ptr->user_chunk_malloc_max;\n# elif PNG_USER_CHUNK_MALLOC_MAX > 0\n   if (PNG_USER_CHUNK_MALLOC_MAX < limit)\n      limit = PNG_USER_CHUNK_MALLOC_MAX;\n# endif\n   if (png_ptr->chunk_name == png_IDAT)\n    {\n       png_alloc_size_t idat_limit = PNG_UINT_31_MAX;\n       size_t row_factor =\n         (size_t)png_ptr->width\n         * (size_t)png_ptr->channels\n         * (png_ptr->bit_depth > 8? 2: 1)\n         + 1\n         + (png_ptr->interlaced? 6: 0);\n       if (png_ptr->height > PNG_UINT_32_MAX/row_factor)\n         idat_limit = PNG_UINT_31_MAX;\n       else\n          idat_limit = png_ptr->height * row_factor;\n       row_factor = row_factor > 32566? 32566 : row_factor;\n      idat_limit += 6 + 5*(idat_limit/row_factor+1); /* zlib+deflate overhead */\n      idat_limit=idat_limit < PNG_UINT_31_MAX? idat_limit : PNG_UINT_31_MAX;\n      limit = limit < idat_limit? idat_limit : limit;\n   }\n\n   if (length > limit)\n   {\n      png_debug2(0,\" length = %lu, limit = %lu\",\n         (unsigned long)length,(unsigned long)limit);\n      png_chunk_error(png_ptr, \"chunk data is too large\");\n   }\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142974,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static int uvesafb_setcmap(struct fb_cmap *cmap, struct fb_info *info)\n{\n\tstruct uvesafb_pal_entry *entries;\n\tint shift = 16 - dac_width;\n\tint i, err = 0;\n\n\tif (info->var.bits_per_pixel == 8) {\n\t\tif (cmap->start + cmap->len > info->cmap.start +\n \t\t    info->cmap.len || cmap->start < info->cmap.start)\n \t\t\treturn -EINVAL;\n \n\t\tentries = kmalloc(sizeof(*entries) * cmap->len, GFP_KERNEL);\n \t\tif (!entries)\n \t\t\treturn -ENOMEM;\n \n\t\tfor (i = 0; i < cmap->len; i++) {\n\t\t\tentries[i].red   = cmap->red[i]   >> shift;\n\t\t\tentries[i].green = cmap->green[i] >> shift;\n\t\t\tentries[i].blue  = cmap->blue[i]  >> shift;\n\t\t\tentries[i].pad   = 0;\n\t\t}\n\t\terr = uvesafb_setpalette(entries, cmap->len, cmap->start, info);\n\t\tkfree(entries);\n\t} else {\n\t\t/*\n\t\t * For modes with bpp > 8, we only set the pseudo palette in\n\t\t * the fb_info struct. We rely on uvesafb_setcolreg to do all\n\t\t * sanity checking.\n\t\t */\n\t\tfor (i = 0; i < cmap->len; i++) {\n\t\t\terr |= uvesafb_setcolreg(cmap->start + i, cmap->red[i],\n\t\t\t\t\t\tcmap->green[i], cmap->blue[i],\n\t\t\t\t\t\t0, info);\n\t\t}\n\t}\n\treturn err;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142975,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static int uvesafb_setcmap(struct fb_cmap *cmap, struct fb_info *info)\n{\n\tstruct uvesafb_pal_entry *entries;\n\tint shift = 16 - dac_width;\n\tint i, err = 0;\n\n\tif (info->var.bits_per_pixel == 8) {\n\t\tif (cmap->start + cmap->len > info->cmap.start +\n \t\t    info->cmap.len || cmap->start < info->cmap.start)\n \t\t\treturn -EINVAL;\n \n\t\tentries = kmalloc_array(cmap->len, sizeof(*entries),\n\t\t\t\t\tGFP_KERNEL);\n \t\tif (!entries)\n \t\t\treturn -ENOMEM;\n \n\t\tfor (i = 0; i < cmap->len; i++) {\n\t\t\tentries[i].red   = cmap->red[i]   >> shift;\n\t\t\tentries[i].green = cmap->green[i] >> shift;\n\t\t\tentries[i].blue  = cmap->blue[i]  >> shift;\n\t\t\tentries[i].pad   = 0;\n\t\t}\n\t\terr = uvesafb_setpalette(entries, cmap->len, cmap->start, info);\n\t\tkfree(entries);\n\t} else {\n\t\t/*\n\t\t * For modes with bpp > 8, we only set the pseudo palette in\n\t\t * the fb_info struct. We rely on uvesafb_setcolreg to do all\n\t\t * sanity checking.\n\t\t */\n\t\tfor (i = 0; i < cmap->len; i++) {\n\t\t\terr |= uvesafb_setcolreg(cmap->start + i, cmap->red[i],\n\t\t\t\t\t\tcmap->green[i], cmap->blue[i],\n\t\t\t\t\t\t0, info);\n\t\t}\n\t}\n\treturn err;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142976,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "mrb_vm_exec(mrb_state *mrb, struct RProc *proc, mrb_code *pc)\n{\n  /* mrb_assert(mrb_proc_cfunc_p(proc)) */\n  mrb_irep *irep = proc->body.irep;\n  mrb_value *pool = irep->pool;\n  mrb_sym *syms = irep->syms;\n  mrb_code i;\n  int ai = mrb_gc_arena_save(mrb);\n  struct mrb_jmpbuf *prev_jmp = mrb->jmp;\n  struct mrb_jmpbuf c_jmp;\n\n#ifdef DIRECT_THREADED\n  static void *optable[] = {\n    &&L_OP_NOP, &&L_OP_MOVE,\n    &&L_OP_LOADL, &&L_OP_LOADI, &&L_OP_LOADSYM, &&L_OP_LOADNIL,\n    &&L_OP_LOADSELF, &&L_OP_LOADT, &&L_OP_LOADF,\n    &&L_OP_GETGLOBAL, &&L_OP_SETGLOBAL, &&L_OP_GETSPECIAL, &&L_OP_SETSPECIAL,\n    &&L_OP_GETIV, &&L_OP_SETIV, &&L_OP_GETCV, &&L_OP_SETCV,\n    &&L_OP_GETCONST, &&L_OP_SETCONST, &&L_OP_GETMCNST, &&L_OP_SETMCNST,\n    &&L_OP_GETUPVAR, &&L_OP_SETUPVAR,\n    &&L_OP_JMP, &&L_OP_JMPIF, &&L_OP_JMPNOT,\n    &&L_OP_ONERR, &&L_OP_RESCUE, &&L_OP_POPERR, &&L_OP_RAISE, &&L_OP_EPUSH, &&L_OP_EPOP,\n    &&L_OP_SEND, &&L_OP_SENDB, &&L_OP_FSEND,\n    &&L_OP_CALL, &&L_OP_SUPER, &&L_OP_ARGARY, &&L_OP_ENTER,\n    &&L_OP_KARG, &&L_OP_KDICT, &&L_OP_RETURN, &&L_OP_TAILCALL, &&L_OP_BLKPUSH,\n    &&L_OP_ADD, &&L_OP_ADDI, &&L_OP_SUB, &&L_OP_SUBI, &&L_OP_MUL, &&L_OP_DIV,\n    &&L_OP_EQ, &&L_OP_LT, &&L_OP_LE, &&L_OP_GT, &&L_OP_GE,\n    &&L_OP_ARRAY, &&L_OP_ARYCAT, &&L_OP_ARYPUSH, &&L_OP_AREF, &&L_OP_ASET, &&L_OP_APOST,\n    &&L_OP_STRING, &&L_OP_STRCAT, &&L_OP_HASH,\n    &&L_OP_LAMBDA, &&L_OP_RANGE, &&L_OP_OCLASS,\n    &&L_OP_CLASS, &&L_OP_MODULE, &&L_OP_EXEC,\n    &&L_OP_METHOD, &&L_OP_SCLASS, &&L_OP_TCLASS,\n    &&L_OP_DEBUG, &&L_OP_STOP, &&L_OP_ERR,\n  };\n#endif\n\n  mrb_bool exc_catched = FALSE;\nRETRY_TRY_BLOCK:\n\n  MRB_TRY(&c_jmp) {\n\n  if (exc_catched) {\n    exc_catched = FALSE;\n    if (mrb->exc && mrb->exc->tt == MRB_TT_BREAK)\n      goto L_BREAK;\n    goto L_RAISE;\n  }\n  mrb->jmp = &c_jmp;\n  mrb->c->ci->proc = proc;\n  mrb->c->ci->nregs = irep->nregs;\n\n#define regs (mrb->c->stack)\n  INIT_DISPATCH {\n    CASE(OP_NOP) {\n      /* do nothing */\n      NEXT;\n    }\n\n    CASE(OP_MOVE) {\n      /* A B    R(A) := R(B) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      regs[a] = regs[b];\n      NEXT;\n    }\n\n    CASE(OP_LOADL) {\n      /* A Bx   R(A) := Pool(Bx) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n#ifdef MRB_WORD_BOXING\n      mrb_value val = pool[bx];\n#ifndef MRB_WITHOUT_FLOAT\n      if (mrb_float_p(val)) {\n        val = mrb_float_value(mrb, mrb_float(val));\n      }\n#endif\n      regs[a] = val;\n#else\n      regs[a] = pool[bx];\n#endif\n      NEXT;\n    }\n\n    CASE(OP_LOADI) {\n      /* A sBx  R(A) := sBx */\n      int a = GETARG_A(i);\n      mrb_int bx = GETARG_sBx(i);\n      SET_INT_VALUE(regs[a], bx);\n      NEXT;\n    }\n\n    CASE(OP_LOADSYM) {\n      /* A Bx   R(A) := Syms(Bx) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      SET_SYM_VALUE(regs[a], syms[bx]);\n      NEXT;\n    }\n\n    CASE(OP_LOADSELF) {\n      /* A      R(A) := self */\n      int a = GETARG_A(i);\n      regs[a] = regs[0];\n      NEXT;\n    }\n\n    CASE(OP_LOADT) {\n      /* A      R(A) := true */\n      int a = GETARG_A(i);\n      SET_TRUE_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_LOADF) {\n      /* A      R(A) := false */\n      int a = GETARG_A(i);\n      SET_FALSE_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETGLOBAL) {\n      /* A Bx   R(A) := getglobal(Syms(Bx)) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_value val = mrb_gv_get(mrb, syms[bx]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETGLOBAL) {\n      /* A Bx   setglobal(Syms(Bx), R(A)) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_gv_set(mrb, syms[bx], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETSPECIAL) {\n      /* A Bx   R(A) := Special[Bx] */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_value val = mrb_vm_special_get(mrb, bx);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETSPECIAL) {\n      /* A Bx   Special[Bx] := R(A) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_vm_special_set(mrb, bx, regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETIV) {\n      /* A Bx   R(A) := ivget(Bx) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_value val = mrb_vm_iv_get(mrb, syms[bx]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETIV) {\n      /* A Bx   ivset(Syms(Bx),R(A)) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_vm_iv_set(mrb, syms[bx], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETCV) {\n      /* A Bx   R(A) := cvget(Syms(Bx)) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_value val;\n      ERR_PC_SET(mrb, pc);\n      val = mrb_vm_cv_get(mrb, syms[bx]);\n      ERR_PC_CLR(mrb);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETCV) {\n      /* A Bx   cvset(Syms(Bx),R(A)) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_vm_cv_set(mrb, syms[bx], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETCONST) {\n      /* A Bx    R(A) := constget(Syms(Bx)) */\n      mrb_value val;\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_sym sym = syms[bx];\n\n      ERR_PC_SET(mrb, pc);\n      val = mrb_vm_const_get(mrb, sym);\n      ERR_PC_CLR(mrb);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETCONST) {\n      /* A Bx   constset(Syms(Bx),R(A)) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_vm_const_set(mrb, syms[bx], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETMCNST) {\n      /* A Bx   R(A) := R(A)::Syms(Bx) */\n      mrb_value val;\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n\n      ERR_PC_SET(mrb, pc);\n      val = mrb_const_get(mrb, regs[a], syms[bx]);\n      ERR_PC_CLR(mrb);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETMCNST) {\n      /* A Bx    R(A+1)::Syms(Bx) := R(A) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_const_set(mrb, regs[a+1], syms[bx], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETUPVAR) {\n      /* A B C  R(A) := uvget(B,C) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n       mrb_value *regs_a = regs + a;\n       struct REnv *e = uvenv(mrb, c);\n \n      if (!e) {\n        *regs_a = mrb_nil_value();\n       }\n       else {\n        *regs_a = e->stack[b];\n       }\n       NEXT;\n     }\n\n    CASE(OP_SETUPVAR) {\n      /* A B C  uvset(B,C,R(A)) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n\n      struct REnv *e = uvenv(mrb, c);\n\n      if (e) {\n        mrb_value *regs_a = regs + a;\n\n        if (b < MRB_ENV_STACK_LEN(e)) {\n          e->stack[b] = *regs_a;\n          mrb_write_barrier(mrb, (struct RBasic*)e);\n        }\n      }\n      NEXT;\n    }\n\n    CASE(OP_JMP) {\n      /* sBx    pc+=sBx */\n      int sbx = GETARG_sBx(i);\n      pc += sbx;\n      JUMP;\n    }\n\n    CASE(OP_JMPIF) {\n      /* A sBx  if R(A) pc+=sBx */\n      int a = GETARG_A(i);\n      int sbx = GETARG_sBx(i);\n      if (mrb_test(regs[a])) {\n        pc += sbx;\n        JUMP;\n      }\n      NEXT;\n    }\n\n    CASE(OP_JMPNOT) {\n      /* A sBx  if !R(A) pc+=sBx */\n      int a = GETARG_A(i);\n      int sbx = GETARG_sBx(i);\n      if (!mrb_test(regs[a])) {\n        pc += sbx;\n        JUMP;\n      }\n      NEXT;\n    }\n\n    CASE(OP_ONERR) {\n      /* sBx    pc+=sBx on exception */\n      int sbx = GETARG_sBx(i);\n      if (mrb->c->rsize <= mrb->c->ci->ridx) {\n        if (mrb->c->rsize == 0) mrb->c->rsize = RESCUE_STACK_INIT_SIZE;\n        else mrb->c->rsize *= 2;\n        mrb->c->rescue = (mrb_code **)mrb_realloc(mrb, mrb->c->rescue, sizeof(mrb_code*) * mrb->c->rsize);\n      }\n      mrb->c->rescue[mrb->c->ci->ridx++] = pc + sbx;\n      NEXT;\n    }\n\n    CASE(OP_RESCUE) {\n      /* A B    R(A) := exc; clear(exc); R(B) := matched (bool) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n      mrb_value exc;\n\n      if (c == 0) {\n        exc = mrb_obj_value(mrb->exc);\n        mrb->exc = 0;\n      }\n      else {           /* continued; exc taken from R(A) */\n        exc = regs[a];\n      }\n      if (b != 0) {\n        mrb_value e = regs[b];\n        struct RClass *ec;\n\n        switch (mrb_type(e)) {\n        case MRB_TT_CLASS:\n        case MRB_TT_MODULE:\n          break;\n        default:\n          {\n            mrb_value exc;\n\n            exc = mrb_exc_new_str_lit(mrb, E_TYPE_ERROR,\n                  \"class or module required for rescue clause\");\n            mrb_exc_set(mrb, exc);\n            goto L_RAISE;\n          }\n        }\n        ec = mrb_class_ptr(e);\n        regs[b] = mrb_bool_value(mrb_obj_is_kind_of(mrb, exc, ec));\n      }\n      if (a != 0 && c == 0) {\n        regs[a] = exc;\n      }\n      NEXT;\n    }\n\n    CASE(OP_POPERR) {\n      /* A      A.times{rescue_pop()} */\n      int a = GETARG_A(i);\n\n      mrb->c->ci->ridx -= a;\n      NEXT;\n    }\n\n    CASE(OP_RAISE) {\n      /* A      raise(R(A)) */\n      int a = GETARG_A(i);\n\n      mrb_exc_set(mrb, regs[a]);\n      goto L_RAISE;\n    }\n\n    CASE(OP_EPUSH) {\n      /* Bx     ensure_push(SEQ[Bx]) */\n      int bx = GETARG_Bx(i);\n      struct RProc *p;\n\n      p = mrb_closure_new(mrb, irep->reps[bx]);\n      /* push ensure_stack */\n      if (mrb->c->esize <= mrb->c->eidx+1) {\n        if (mrb->c->esize == 0) mrb->c->esize = ENSURE_STACK_INIT_SIZE;\n        else mrb->c->esize *= 2;\n        mrb->c->ensure = (struct RProc **)mrb_realloc(mrb, mrb->c->ensure, sizeof(struct RProc*) * mrb->c->esize);\n      }\n      mrb->c->ensure[mrb->c->eidx++] = p;\n      mrb->c->ensure[mrb->c->eidx] = NULL;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_EPOP) {\n      /* A      A.times{ensure_pop().call} */\n      int a = GETARG_A(i);\n      mrb_callinfo *ci = mrb->c->ci;\n      int n, epos = ci->epos;\n      mrb_value self = regs[0];\n      struct RClass *target_class = ci->target_class;\n\n      if (mrb->c->eidx <= epos) {\n        NEXT;\n      }\n\n      if (a > mrb->c->eidx - epos)\n        a = mrb->c->eidx - epos;\n      pc = pc + 1;\n      for (n=0; n<a; n++) {\n        proc = mrb->c->ensure[epos+n];\n        mrb->c->ensure[epos+n] = NULL;\n        if (proc == NULL) continue;\n        irep = proc->body.irep;\n        ci = cipush(mrb);\n        ci->mid = ci[-1].mid;\n        ci->argc = 0;\n        ci->proc = proc;\n        ci->stackent = mrb->c->stack;\n        ci->nregs = irep->nregs;\n        ci->target_class = target_class;\n        ci->pc = pc;\n        ci->acc = ci[-1].nregs;\n        mrb->c->stack += ci->acc;\n        stack_extend(mrb, ci->nregs);\n        regs[0] = self;\n        pc = irep->iseq;\n      }\n      pool = irep->pool;\n      syms = irep->syms;\n      mrb->c->eidx = epos;\n      JUMP;\n    }\n\n    CASE(OP_LOADNIL) {\n      /* A     R(A) := nil */\n      int a = GETARG_A(i);\n\n      SET_NIL_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_SENDB) {\n      /* A B C  R(A) := call(R(A),Syms(B),R(A+1),...,R(A+C),&R(A+C+1))*/\n      /* fall through */\n    };\n\n  L_SEND:\n    CASE(OP_SEND) {\n      /* A B C  R(A) := call(R(A),Syms(B),R(A+1),...,R(A+C)) */\n      int a = GETARG_A(i);\n      int n = GETARG_C(i);\n      int argc = (n == CALL_MAXARGS) ? -1 : n;\n      int bidx = (argc < 0) ? a+2 : a+n+1;\n      mrb_method_t m;\n      struct RClass *c;\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_value recv, blk;\n      mrb_sym mid = syms[GETARG_B(i)];\n\n      mrb_assert(bidx < ci->nregs);\n\n      recv = regs[a];\n      if (GET_OPCODE(i) != OP_SENDB) {\n        SET_NIL_VALUE(regs[bidx]);\n        blk = regs[bidx];\n      }\n      else {\n        blk = regs[bidx];\n        if (!mrb_nil_p(blk) && mrb_type(blk) != MRB_TT_PROC) {\n          blk = mrb_convert_type(mrb, blk, MRB_TT_PROC, \"Proc\", \"to_proc\");\n          /* The stack might have been reallocated during mrb_convert_type(),\n             see #3622 */\n          regs[bidx] = blk;\n        }\n      }\n      c = mrb_class(mrb, recv);\n      m = mrb_method_search_vm(mrb, &c, mid);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        mrb_sym missing = mrb_intern_lit(mrb, \"method_missing\");\n        m = mrb_method_search_vm(mrb, &c, missing);\n        if (MRB_METHOD_UNDEF_P(m) || (missing == mrb->c->ci->mid && mrb_obj_eq(mrb, regs[0], recv))) {\n          mrb_value args = (argc < 0) ? regs[a+1] : mrb_ary_new_from_values(mrb, n, regs+a+1);\n          ERR_PC_SET(mrb, pc);\n          mrb_method_missing(mrb, mid, recv, args);\n        }\n        if (argc >= 0) {\n          if (a+2 >= irep->nregs) {\n            stack_extend(mrb, a+3);\n          }\n          regs[a+1] = mrb_ary_new_from_values(mrb, n, regs+a+1);\n          regs[a+2] = blk;\n          argc = -1;\n        }\n        mrb_ary_unshift(mrb, regs[a+1], mrb_symbol_value(mid));\n        mid = missing;\n      }\n\n      /* push callinfo */\n      ci = cipush(mrb);\n      ci->mid = mid;\n      ci->stackent = mrb->c->stack;\n      ci->target_class = c;\n      ci->argc = argc;\n\n      ci->pc = pc + 1;\n      ci->acc = a;\n\n      /* prepare stack */\n      mrb->c->stack += a;\n\n      if (MRB_METHOD_CFUNC_P(m)) {\n        ci->nregs = (argc < 0) ? 3 : n+2;\n        if (MRB_METHOD_PROC_P(m)) {\n          struct RProc *p = MRB_METHOD_PROC(m);\n\n          ci->proc = p;\n          recv = p->body.func(mrb, recv);\n        }\n        else {\n          recv = MRB_METHOD_FUNC(m)(mrb, recv);\n        }\n        mrb_gc_arena_restore(mrb, ai);\n        mrb_gc_arena_shrink(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        ci = mrb->c->ci;\n        if (GET_OPCODE(i) == OP_SENDB) {\n          if (mrb_type(blk) == MRB_TT_PROC) {\n            struct RProc *p = mrb_proc_ptr(blk);\n            if (p && !MRB_PROC_STRICT_P(p) && MRB_PROC_ENV(p) == ci[-1].env) {\n              p->flags |= MRB_PROC_ORPHAN;\n            }\n          }\n        }\n        if (!ci->target_class) { /* return from context modifying method (resume/yield) */\n          if (ci->acc == CI_ACC_RESUMED) {\n            mrb->jmp = prev_jmp;\n            return recv;\n          }\n          else {\n            mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));\n            proc = ci[-1].proc;\n            irep = proc->body.irep;\n            pool = irep->pool;\n            syms = irep->syms;\n          }\n        }\n        mrb->c->stack[0] = recv;\n        /* pop stackpos */\n        mrb->c->stack = ci->stackent;\n        pc = ci->pc;\n        cipop(mrb);\n        JUMP;\n      }\n      else {\n        /* setup environment for calling method */\n        proc = ci->proc = MRB_METHOD_PROC(m);\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        ci->nregs = irep->nregs;\n        stack_extend(mrb, (argc < 0 && ci->nregs < 3) ? 3 : ci->nregs);\n        pc = irep->iseq;\n        JUMP;\n      }\n    }\n\n    CASE(OP_FSEND) {\n      /* A B C  R(A) := fcall(R(A),Syms(B),R(A+1),... ,R(A+C-1)) */\n      /* not implemented yet */\n      NEXT;\n    }\n\n    CASE(OP_CALL) {\n      /* A      R(A) := self.call(frame.argc, frame.argv) */\n      mrb_callinfo *ci;\n      mrb_value recv = mrb->c->stack[0];\n      struct RProc *m = mrb_proc_ptr(recv);\n\n      /* replace callinfo */\n      ci = mrb->c->ci;\n      ci->target_class = MRB_PROC_TARGET_CLASS(m);\n      ci->proc = m;\n      if (MRB_PROC_ENV_P(m)) {\n        mrb_sym mid;\n        struct REnv *e = MRB_PROC_ENV(m);\n\n        mid = e->mid;\n        if (mid) ci->mid = mid;\n        if (!e->stack) {\n          e->stack = mrb->c->stack;\n        }\n      }\n\n      /* prepare stack */\n      if (MRB_PROC_CFUNC_P(m)) {\n        recv = MRB_PROC_CFUNC(m)(mrb, recv);\n        mrb_gc_arena_restore(mrb, ai);\n        mrb_gc_arena_shrink(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        /* pop stackpos */\n        ci = mrb->c->ci;\n        mrb->c->stack = ci->stackent;\n        regs[ci->acc] = recv;\n        pc = ci->pc;\n        cipop(mrb);\n        irep = mrb->c->ci->proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        JUMP;\n      }\n      else {\n        /* setup environment for calling method */\n        proc = m;\n        irep = m->body.irep;\n        if (!irep) {\n          mrb->c->stack[0] = mrb_nil_value();\n          goto L_RETURN;\n        }\n        pool = irep->pool;\n        syms = irep->syms;\n        ci->nregs = irep->nregs;\n        stack_extend(mrb, ci->nregs);\n        if (ci->argc < 0) {\n          if (irep->nregs > 3) {\n            stack_clear(regs+3, irep->nregs-3);\n          }\n        }\n        else if (ci->argc+2 < irep->nregs) {\n          stack_clear(regs+ci->argc+2, irep->nregs-ci->argc-2);\n        }\n        if (MRB_PROC_ENV_P(m)) {\n          regs[0] = MRB_PROC_ENV(m)->stack[0];\n        }\n        pc = irep->iseq;\n        JUMP;\n      }\n    }\n\n    CASE(OP_SUPER) {\n      /* A C  R(A) := super(R(A+1),... ,R(A+C+1)) */\n      int a = GETARG_A(i);\n      int n = GETARG_C(i);\n      int argc = (n == CALL_MAXARGS) ? -1 : n;\n      int bidx = (argc < 0) ? a+2 : a+n+1;\n      mrb_method_t m;\n      struct RClass *c;\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_value recv, blk;\n      mrb_sym mid = ci->mid;\n      struct RClass* target_class = MRB_PROC_TARGET_CLASS(ci->proc);\n\n      mrb_assert(bidx < ci->nregs);\n\n      if (mid == 0 || !target_class) {\n        mrb_value exc = mrb_exc_new_str_lit(mrb, E_NOMETHOD_ERROR, \"super called outside of method\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      if (target_class->tt == MRB_TT_MODULE) {\n        target_class = ci->target_class;\n        if (target_class->tt != MRB_TT_ICLASS) {\n          mrb_value exc = mrb_exc_new_str_lit(mrb, E_RUNTIME_ERROR, \"superclass info lost [mruby limitations]\");\n          mrb_exc_set(mrb, exc);\n          goto L_RAISE;\n        }\n      }\n      recv = regs[0];\n      if (!mrb_obj_is_kind_of(mrb, recv, target_class)) {\n        mrb_value exc = mrb_exc_new_str_lit(mrb, E_TYPE_ERROR,\n                                            \"self has wrong type to call super in this context\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      blk = regs[bidx];\n      if (!mrb_nil_p(blk) && mrb_type(blk) != MRB_TT_PROC) {\n        blk = mrb_convert_type(mrb, blk, MRB_TT_PROC, \"Proc\", \"to_proc\");\n        /* The stack or ci stack might have been reallocated during\n           mrb_convert_type(), see #3622 and #3784 */\n        regs[bidx] = blk;\n        ci = mrb->c->ci;\n      }\n      c = target_class->super;\n      m = mrb_method_search_vm(mrb, &c, mid);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        mrb_sym missing = mrb_intern_lit(mrb, \"method_missing\");\n\n        if (mid != missing) {\n          c = mrb_class(mrb, recv);\n        }\n        m = mrb_method_search_vm(mrb, &c, missing);\n        if (MRB_METHOD_UNDEF_P(m)) {\n          mrb_value args = (argc < 0) ? regs[a+1] : mrb_ary_new_from_values(mrb, n, regs+a+1);\n          ERR_PC_SET(mrb, pc);\n          mrb_method_missing(mrb, mid, recv, args);\n        }\n        mid = missing;\n        if (argc >= 0) {\n          if (a+2 >= ci->nregs) {\n            stack_extend(mrb, a+3);\n          }\n          regs[a+1] = mrb_ary_new_from_values(mrb, n, regs+a+1);\n          regs[a+2] = blk;\n          argc = -1;\n        }\n        mrb_ary_unshift(mrb, regs[a+1], mrb_symbol_value(ci->mid));\n      }\n\n      /* push callinfo */\n      ci = cipush(mrb);\n      ci->mid = mid;\n      ci->stackent = mrb->c->stack;\n      ci->target_class = c;\n      ci->pc = pc + 1;\n      ci->argc = argc;\n\n      /* prepare stack */\n      mrb->c->stack += a;\n      mrb->c->stack[0] = recv;\n\n      if (MRB_METHOD_CFUNC_P(m)) {\n        mrb_value v;\n        ci->nregs = (argc < 0) ? 3 : n+2;\n        if (MRB_METHOD_PROC_P(m)) {\n          ci->proc = MRB_METHOD_PROC(m);\n        }\n        v = MRB_METHOD_CFUNC(m)(mrb, recv);\n        mrb_gc_arena_restore(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        ci = mrb->c->ci;\n        if (!ci->target_class) { /* return from context modifying method (resume/yield) */\n          if (ci->acc == CI_ACC_RESUMED) {\n            mrb->jmp = prev_jmp;\n            return v;\n          }\n          else {\n            mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));\n            proc = ci[-1].proc;\n            irep = proc->body.irep;\n            pool = irep->pool;\n            syms = irep->syms;\n          }\n        }\n        mrb->c->stack[0] = v;\n        /* pop stackpos */\n        mrb->c->stack = ci->stackent;\n        pc = ci->pc;\n        cipop(mrb);\n        JUMP;\n      }\n      else {\n        /* fill callinfo */\n        ci->acc = a;\n\n        /* setup environment for calling method */\n        proc = ci->proc = MRB_METHOD_PROC(m);\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        ci->nregs = irep->nregs;\n        stack_extend(mrb, (argc < 0 && ci->nregs < 3) ? 3 : ci->nregs);\n        pc = irep->iseq;\n        JUMP;\n      }\n    }\n\n    CASE(OP_ARGARY) {\n      /* A Bx   R(A) := argument array (16=6:1:5:4) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      int m1 = (bx>>10)&0x3f;\n      int r  = (bx>>9)&0x1;\n      int m2 = (bx>>4)&0x1f;\n      int lv = (bx>>0)&0xf;\n      mrb_value *stack;\n\n      if (mrb->c->ci->mid == 0 || mrb->c->ci->target_class == NULL) {\n        mrb_value exc;\n\n      L_NOSUPER:\n        exc = mrb_exc_new_str_lit(mrb, E_NOMETHOD_ERROR, \"super called outside of method\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      if (lv == 0) stack = regs + 1;\n      else {\n        struct REnv *e = uvenv(mrb, lv-1);\n        if (!e) goto L_NOSUPER;\n        if (MRB_ENV_STACK_LEN(e) <= m1+r+m2+1)\n          goto L_NOSUPER;\n        stack = e->stack + 1;\n      }\n      if (r == 0) {\n        regs[a] = mrb_ary_new_from_values(mrb, m1+m2, stack);\n      }\n      else {\n        mrb_value *pp = NULL;\n        struct RArray *rest;\n        int len = 0;\n\n        if (mrb_array_p(stack[m1])) {\n          struct RArray *ary = mrb_ary_ptr(stack[m1]);\n\n          pp = ARY_PTR(ary);\n          len = (int)ARY_LEN(ary);\n        }\n        regs[a] = mrb_ary_new_capa(mrb, m1+len+m2);\n        rest = mrb_ary_ptr(regs[a]);\n        if (m1 > 0) {\n          stack_copy(ARY_PTR(rest), stack, m1);\n        }\n        if (len > 0) {\n          stack_copy(ARY_PTR(rest)+m1, pp, len);\n        }\n        if (m2 > 0) {\n          stack_copy(ARY_PTR(rest)+m1+len, stack+m1+1, m2);\n        }\n        ARY_SET_LEN(rest, m1+len+m2);\n      }\n      regs[a+1] = stack[m1+r+m2];\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ENTER) {\n      /* Ax             arg setup according to flags (23=5:5:1:5:5:1:1) */\n      /* number of optional arguments times OP_JMP should follow */\n      mrb_aspec ax = GETARG_Ax(i);\n      int m1 = MRB_ASPEC_REQ(ax);\n      int o  = MRB_ASPEC_OPT(ax);\n      int r  = MRB_ASPEC_REST(ax);\n      int m2 = MRB_ASPEC_POST(ax);\n      /* unused\n      int k  = MRB_ASPEC_KEY(ax);\n      int kd = MRB_ASPEC_KDICT(ax);\n      int b  = MRB_ASPEC_BLOCK(ax);\n      */\n      int argc = mrb->c->ci->argc;\n      mrb_value *argv = regs+1;\n      mrb_value *argv0 = argv;\n      int len = m1 + o + r + m2;\n      mrb_value *blk = &argv[argc < 0 ? 1 : argc];\n\n      if (argc < 0) {\n        struct RArray *ary = mrb_ary_ptr(regs[1]);\n        argv = ARY_PTR(ary);\n        argc = (int)ARY_LEN(ary);\n        mrb_gc_protect(mrb, regs[1]);\n      }\n      if (mrb->c->ci->proc && MRB_PROC_STRICT_P(mrb->c->ci->proc)) {\n        if (argc >= 0) {\n          if (argc < m1 + m2 || (r == 0 && argc > len)) {\n            argnum_error(mrb, m1+m2);\n            goto L_RAISE;\n          }\n        }\n      }\n      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {\n        mrb_gc_protect(mrb, argv[0]);\n        argc = (int)RARRAY_LEN(argv[0]);\n        argv = RARRAY_PTR(argv[0]);\n      }\n      if (argc < len) {\n        int mlen = m2;\n        if (argc < m1+m2) {\n          if (m1 < argc)\n            mlen = argc - m1;\n          else\n            mlen = 0;\n        }\n        regs[len+1] = *blk; /* move block */\n        SET_NIL_VALUE(regs[argc+1]);\n        if (argv0 != argv) {\n          value_move(&regs[1], argv, argc-mlen); /* m1 + o */\n        }\n        if (argc < m1) {\n          stack_clear(&regs[argc+1], m1-argc);\n        }\n        if (mlen) {\n          value_move(&regs[len-m2+1], &argv[argc-mlen], mlen);\n        }\n        if (mlen < m2) {\n          stack_clear(&regs[len-m2+mlen+1], m2-mlen);\n        }\n        if (r) {\n          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);\n        }\n        if (o == 0 || argc < m1+m2) pc++;\n        else\n          pc += argc - m1 - m2 + 1;\n      }\n      else {\n        int rnum = 0;\n        if (argv0 != argv) {\n          regs[len+1] = *blk; /* move block */\n          value_move(&regs[1], argv, m1+o);\n        }\n        if (r) {\n          rnum = argc-m1-o-m2;\n          regs[m1+o+1] = mrb_ary_new_from_values(mrb, rnum, argv+m1+o);\n        }\n        if (m2) {\n          if (argc-m2 > m1) {\n            value_move(&regs[m1+o+r+1], &argv[m1+o+rnum], m2);\n          }\n        }\n        if (argv0 == argv) {\n          regs[len+1] = *blk; /* move block */\n        }\n        pc += o + 1;\n      }\n      mrb->c->ci->argc = len;\n      /* clear local (but non-argument) variables */\n      if (irep->nlocals-len-2 > 0) {\n        stack_clear(&regs[len+2], irep->nlocals-len-2);\n      }\n      JUMP;\n    }\n\n    CASE(OP_KARG) {\n      /* A B C          R(A) := kdict[Syms(B)]; if C kdict.rm(Syms(B)) */\n      /* if C == 2; raise unless kdict.empty? */\n      /* OP_JMP should follow to skip init code */\n      NEXT;\n    }\n\n    CASE(OP_KDICT) {\n      /* A C            R(A) := kdict */\n      NEXT;\n    }\n\n    L_RETURN:\n      i = MKOP_AB(OP_RETURN, GETARG_A(i), OP_R_NORMAL);\n      /* fall through */\n    CASE(OP_RETURN) {\n      /* A B     return R(A) (B=normal,in-block return/break) */\n      mrb_callinfo *ci;\n\n#define ecall_adjust() do {\\\n  ptrdiff_t cioff = ci - mrb->c->cibase;\\\n  ecall(mrb);\\\n  ci = mrb->c->cibase + cioff;\\\n} while (0)\n\n      ci = mrb->c->ci;\n      if (ci->mid) {\n        mrb_value blk;\n\n        if (ci->argc < 0) {\n          blk = regs[2];\n        }\n        else {\n          blk = regs[ci->argc+1];\n        }\n        if (mrb_type(blk) == MRB_TT_PROC) {\n          struct RProc *p = mrb_proc_ptr(blk);\n\n          if (!MRB_PROC_STRICT_P(p) &&\n              ci > mrb->c->cibase && MRB_PROC_ENV(p) == ci[-1].env) {\n            p->flags |= MRB_PROC_ORPHAN;\n          }\n        }\n      }\n\n      if (mrb->exc) {\n        mrb_callinfo *ci0;\n\n      L_RAISE:\n        ci0 = ci = mrb->c->ci;\n        if (ci == mrb->c->cibase) {\n          if (ci->ridx == 0) goto L_FTOP;\n          goto L_RESCUE;\n        }\n        while (ci[0].ridx == ci[-1].ridx) {\n          cipop(mrb);\n          mrb->c->stack = ci->stackent;\n          if (ci->acc == CI_ACC_SKIP && prev_jmp) {\n            mrb->jmp = prev_jmp;\n            MRB_THROW(prev_jmp);\n          }\n          ci = mrb->c->ci;\n          if (ci == mrb->c->cibase) {\n            if (ci->ridx == 0) {\n            L_FTOP:             /* fiber top */\n              if (mrb->c == mrb->root_c) {\n                mrb->c->stack = mrb->c->stbase;\n                goto L_STOP;\n              }\n              else {\n                struct mrb_context *c = mrb->c;\n\n                while (c->eidx > ci->epos) {\n                  ecall_adjust();\n                }\n                if (c->fib) {\n                  mrb_write_barrier(mrb, (struct RBasic*)c->fib);\n                }\n                mrb->c->status = MRB_FIBER_TERMINATED;\n                mrb->c = c->prev;\n                c->prev = NULL;\n                goto L_RAISE;\n              }\n            }\n            break;\n          }\n          /* call ensure only when we skip this callinfo */\n          if (ci[0].ridx == ci[-1].ridx) {\n            while (mrb->c->eidx > ci->epos) {\n              ecall_adjust();\n            }\n          }\n        }\n      L_RESCUE:\n        if (ci->ridx == 0) goto L_STOP;\n        proc = ci->proc;\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        if (ci < ci0) {\n          mrb->c->stack = ci[1].stackent;\n        }\n        stack_extend(mrb, irep->nregs);\n        pc = mrb->c->rescue[--ci->ridx];\n      }\n      else {\n        int acc;\n        mrb_value v;\n        struct RProc *dst;\n\n        ci = mrb->c->ci;\n        v = regs[GETARG_A(i)];\n        mrb_gc_protect(mrb, v);\n        switch (GETARG_B(i)) {\n        case OP_R_RETURN:\n          /* Fall through to OP_R_NORMAL otherwise */\n          if (ci->acc >=0 && MRB_PROC_ENV_P(proc) && !MRB_PROC_STRICT_P(proc)) {\n            mrb_callinfo *cibase = mrb->c->cibase;\n            dst = top_proc(mrb, proc);\n\n            if (MRB_PROC_ENV_P(dst)) {\n              struct REnv *e = MRB_PROC_ENV(dst);\n\n              if (!MRB_ENV_STACK_SHARED_P(e) || e->cxt != mrb->c) {\n                localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n                goto L_RAISE;\n              }\n            }\n            while (cibase <= ci && ci->proc != dst) {\n              if (ci->acc < 0) {\n                localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n                goto L_RAISE;\n              }\n              ci--;\n            }\n            if (ci <= cibase) {\n              localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n              goto L_RAISE;\n            }\n            break;\n          }\n        case OP_R_NORMAL:\n        NORMAL_RETURN:\n          if (ci == mrb->c->cibase) {\n            struct mrb_context *c;\n\n            if (!mrb->c->prev) { /* toplevel return */\n              localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n              goto L_RAISE;\n            }\n            if (mrb->c->prev->ci == mrb->c->prev->cibase) {\n              mrb_value exc = mrb_exc_new_str_lit(mrb, E_FIBER_ERROR, \"double resume\");\n              mrb_exc_set(mrb, exc);\n              goto L_RAISE;\n            }\n            while (mrb->c->eidx > 0) {\n              ecall(mrb);\n            }\n            /* automatic yield at the end */\n            c = mrb->c;\n            c->status = MRB_FIBER_TERMINATED;\n            mrb->c = c->prev;\n            c->prev = NULL;\n            mrb->c->status = MRB_FIBER_RUNNING;\n            ci = mrb->c->ci;\n          }\n          break;\n        case OP_R_BREAK:\n          if (MRB_PROC_STRICT_P(proc)) goto NORMAL_RETURN;\n          if (MRB_PROC_ORPHAN_P(proc)) { \n            mrb_value exc;\n\n          L_BREAK_ERROR:\n            exc = mrb_exc_new_str_lit(mrb, E_LOCALJUMP_ERROR,\n                                      \"break from proc-closure\");\n            mrb_exc_set(mrb, exc);\n            goto L_RAISE;\n          }\n          if (!MRB_PROC_ENV_P(proc) || !MRB_ENV_STACK_SHARED_P(MRB_PROC_ENV(proc))) {\n            goto L_BREAK_ERROR;\n          }\n          else {\n            struct REnv *e = MRB_PROC_ENV(proc);\n\n            if (e == mrb->c->cibase->env && proc != mrb->c->cibase->proc) {\n              goto L_BREAK_ERROR;\n            }\n            if (e->cxt != mrb->c) {\n              goto L_BREAK_ERROR;\n            }\n          }\n          while (mrb->c->eidx > mrb->c->ci->epos) {\n            ecall_adjust();\n          }\n          /* break from fiber block */\n          if (ci == mrb->c->cibase && ci->pc) {\n            struct mrb_context *c = mrb->c;\n\n            mrb->c = c->prev;\n            c->prev = NULL;\n            ci = mrb->c->ci;\n          }\n          if (ci->acc < 0) {\n            mrb_gc_arena_restore(mrb, ai);\n            mrb->c->vmexec = FALSE;\n            mrb->exc = (struct RObject*)break_new(mrb, proc, v);\n            mrb->jmp = prev_jmp;\n            MRB_THROW(prev_jmp);\n          }\n          if (FALSE) {\n          L_BREAK:\n            v = ((struct RBreak*)mrb->exc)->val;\n            proc = ((struct RBreak*)mrb->exc)->proc;\n            mrb->exc = NULL;\n            ci = mrb->c->ci;\n          }\n          mrb->c->stack = ci->stackent;\n          proc = proc->upper;\n          while (mrb->c->cibase < ci &&  ci[-1].proc != proc) {\n            if (ci[-1].acc == CI_ACC_SKIP) {\n              while (ci < mrb->c->ci) {\n                cipop(mrb);\n              }\n              goto L_BREAK_ERROR;\n            }\n            ci--;\n          }\n          if (ci == mrb->c->cibase) {\n            goto L_BREAK_ERROR;\n          }\n          break;\n        default:\n          /* cannot happen */\n          break;\n        }\n        while (ci < mrb->c->ci) {\n          cipop(mrb);\n        }\n        ci[0].ridx = ci[-1].ridx;\n        while (mrb->c->eidx > ci->epos) {\n          ecall_adjust();\n        }\n        if (mrb->c->vmexec && !ci->target_class) {\n          mrb_gc_arena_restore(mrb, ai);\n          mrb->c->vmexec = FALSE;\n          mrb->jmp = prev_jmp;\n          return v;\n        }\n        acc = ci->acc;\n        mrb->c->stack = ci->stackent;\n        cipop(mrb);\n        if (acc == CI_ACC_SKIP || acc == CI_ACC_DIRECT) {\n          mrb_gc_arena_restore(mrb, ai);\n          mrb->jmp = prev_jmp;\n          return v;\n        }\n        pc = ci->pc;\n        ci = mrb->c->ci;\n        DEBUG(fprintf(stderr, \"from :%s\\n\", mrb_sym2name(mrb, ci->mid)));\n        proc = mrb->c->ci->proc;\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n\n        regs[acc] = v;\n        mrb_gc_arena_restore(mrb, ai);\n      }\n      JUMP;\n    }\n\n    CASE(OP_TAILCALL) {\n      /* A B C  return call(R(A),Syms(B),R(A+1),... ,R(A+C+1)) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int n = GETARG_C(i);\n      mrb_method_t m;\n      struct RClass *c;\n      mrb_callinfo *ci;\n      mrb_value recv;\n      mrb_sym mid = syms[b];\n\n      recv = regs[a];\n      c = mrb_class(mrb, recv);\n      m = mrb_method_search_vm(mrb, &c, mid);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        mrb_value sym = mrb_symbol_value(mid);\n        mrb_sym missing = mrb_intern_lit(mrb, \"method_missing\");\n        m = mrb_method_search_vm(mrb, &c, missing);\n        if (MRB_METHOD_UNDEF_P(m)) {\n          mrb_value args;\n\n          if (n == CALL_MAXARGS) {\n            args = regs[a+1];\n          }\n          else {\n            args = mrb_ary_new_from_values(mrb, n, regs+a+1);\n          }\n          ERR_PC_SET(mrb, pc);\n          mrb_method_missing(mrb, mid, recv, args);\n        }\n        mid = missing;\n        if (n == CALL_MAXARGS) {\n          mrb_ary_unshift(mrb, regs[a+1], sym);\n        }\n        else {\n          value_move(regs+a+2, regs+a+1, ++n);\n          regs[a+1] = sym;\n        }\n      }\n\n      /* replace callinfo */\n      ci = mrb->c->ci;\n      ci->mid = mid;\n      ci->target_class = c;\n      if (n == CALL_MAXARGS) {\n        ci->argc = -1;\n      }\n      else {\n        ci->argc = n;\n      }\n\n      /* move stack */\n      value_move(mrb->c->stack, &regs[a], ci->argc+1);\n\n      if (MRB_METHOD_CFUNC_P(m)) {\n        mrb_value v = MRB_METHOD_CFUNC(m)(mrb, recv);\n        mrb->c->stack[0] = v;\n        mrb_gc_arena_restore(mrb, ai);\n        goto L_RETURN;\n      }\n      else {\n        /* setup environment for calling method */\n        struct RProc *p = MRB_METHOD_PROC(m);\n        irep = p->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        if (ci->argc < 0) {\n          stack_extend(mrb, (irep->nregs < 3) ? 3 : irep->nregs);\n        }\n        else {\n          stack_extend(mrb, irep->nregs);\n        }\n        pc = irep->iseq;\n      }\n      JUMP;\n    }\n\n    CASE(OP_BLKPUSH) {\n      /* A Bx   R(A) := block (16=6:1:5:4) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      int m1 = (bx>>10)&0x3f;\n      int r  = (bx>>9)&0x1;\n      int m2 = (bx>>4)&0x1f;\n      int lv = (bx>>0)&0xf;\n      mrb_value *stack;\n\n      if (lv == 0) stack = regs + 1;\n      else {\n        struct REnv *e = uvenv(mrb, lv-1);\n        if (!e || (!MRB_ENV_STACK_SHARED_P(e) && e->mid == 0) ||\n            MRB_ENV_STACK_LEN(e) <= m1+r+m2+1) {\n          localjump_error(mrb, LOCALJUMP_ERROR_YIELD);\n          goto L_RAISE;\n        }\n        stack = e->stack + 1;\n      }\n      if (mrb_nil_p(stack[m1+r+m2])) {\n        localjump_error(mrb, LOCALJUMP_ERROR_YIELD);\n        goto L_RAISE;\n      }\n      regs[a] = stack[m1+r+m2];\n      NEXT;\n    }\n\n#define TYPES2(a,b) ((((uint16_t)(a))<<8)|(((uint16_t)(b))&0xff))\n#define OP_MATH_BODY(op,v1,v2) do {\\\n  v1(regs[a]) = v1(regs[a]) op v2(regs[a+1]);\\\n} while(0)\n\n    CASE(OP_ADD) {\n      /* A B C  R(A) := R(A)+R(A+1) (Syms[B]=:+,C=1)*/\n      int a = GETARG_A(i);\n\n      /* need to check if op is overridden */\n      switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):\n        {\n          mrb_int x, y, z;\n          mrb_value *regs_a = regs + a;\n\n          x = mrb_fixnum(regs_a[0]);\n          y = mrb_fixnum(regs_a[1]);\n          if (mrb_int_add_overflow(x, y, &z)) {\n#ifndef MRB_WITHOUT_FLOAT\n            SET_FLOAT_VALUE(mrb, regs_a[0], (mrb_float)x + (mrb_float)y);\n            break;\n#endif\n          }\n          SET_INT_VALUE(regs[a], z);\n        }\n        break;\n#ifndef MRB_WITHOUT_FLOAT\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FLOAT):\n        {\n          mrb_int x = mrb_fixnum(regs[a]);\n          mrb_float y = mrb_float(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], (mrb_float)x + y);\n        }\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FIXNUM):\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          mrb_int y = mrb_fixnum(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], x + y);\n        }\n#else\n        OP_MATH_BODY(+,mrb_float,mrb_fixnum);\n#endif\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          mrb_float y = mrb_float(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], x + y);\n        }\n#else\n        OP_MATH_BODY(+,mrb_float,mrb_float);\n#endif\n        break;\n#endif\n      case TYPES2(MRB_TT_STRING,MRB_TT_STRING):\n        regs[a] = mrb_str_plus(mrb, regs[a], regs[a+1]);\n        break;\n      default:\n        goto L_SEND;\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_SUB) {\n      /* A B C  R(A) := R(A)-R(A+1) (Syms[B]=:-,C=1)*/\n      int a = GETARG_A(i);\n\n      /* need to check if op is overridden */\n      switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):\n        {\n          mrb_int x, y, z;\n\n          x = mrb_fixnum(regs[a]);\n          y = mrb_fixnum(regs[a+1]);\n          if (mrb_int_sub_overflow(x, y, &z)) {\n#ifndef MRB_WITHOUT_FLOAT\n            SET_FLOAT_VALUE(mrb, regs[a], (mrb_float)x - (mrb_float)y);\n            break;\n#endif\n          }\n          SET_INT_VALUE(regs[a], z);\n        }\n        break;\n#ifndef MRB_WITHOUT_FLOAT\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FLOAT):\n        {\n          mrb_int x = mrb_fixnum(regs[a]);\n          mrb_float y = mrb_float(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], (mrb_float)x - y);\n        }\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FIXNUM):\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          mrb_int y = mrb_fixnum(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], x - y);\n        }\n#else\n        OP_MATH_BODY(-,mrb_float,mrb_fixnum);\n#endif\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          mrb_float y = mrb_float(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], x - y);\n        }\n#else\n        OP_MATH_BODY(-,mrb_float,mrb_float);\n#endif\n        break;\n#endif\n      default:\n        goto L_SEND;\n      }\n      NEXT;\n    }\n\n    CASE(OP_MUL) {\n      /* A B C  R(A) := R(A)*R(A+1) (Syms[B]=:*,C=1)*/\n      int a = GETARG_A(i);\n\n      /* need to check if op is overridden */\n      switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):\n        {\n          mrb_int x, y, z;\n\n          x = mrb_fixnum(regs[a]);\n          y = mrb_fixnum(regs[a+1]);\n          if (mrb_int_mul_overflow(x, y, &z)) {\n#ifndef MRB_WITHOUT_FLOAT\n            SET_FLOAT_VALUE(mrb, regs[a], (mrb_float)x * (mrb_float)y);\n            break;\n#endif\n          }\n          SET_INT_VALUE(regs[a], z);\n        }\n        break;\n#ifndef MRB_WITHOUT_FLOAT\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FLOAT):\n        {\n          mrb_int x = mrb_fixnum(regs[a]);\n          mrb_float y = mrb_float(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], (mrb_float)x * y);\n        }\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FIXNUM):\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          mrb_int y = mrb_fixnum(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], x * y);\n        }\n#else\n        OP_MATH_BODY(*,mrb_float,mrb_fixnum);\n#endif\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          mrb_float y = mrb_float(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], x * y);\n        }\n#else\n        OP_MATH_BODY(*,mrb_float,mrb_float);\n#endif\n        break;\n#endif\n      default:\n        goto L_SEND;\n      }\n      NEXT;\n    }\n\n    CASE(OP_DIV) {\n      /* A B C  R(A) := R(A)/R(A+1) (Syms[B]=:/,C=1)*/\n      int a = GETARG_A(i);\n#ifndef MRB_WITHOUT_FLOAT\n      double x, y, f;\n#endif\n\n      /* need to check if op is overridden */\n      switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):\n#ifdef MRB_WITHOUT_FLOAT\n        {\n          mrb_int x = mrb_fixnum(regs[a]);\n          mrb_int y = mrb_fixnum(regs[a+1]);\n          SET_INT_VALUE(regs[a], y ? x / y : 0);\n        }\n        break;\n#else\n        x = (mrb_float)mrb_fixnum(regs[a]);\n        y = (mrb_float)mrb_fixnum(regs[a+1]);\n        break;\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FLOAT):\n        x = (mrb_float)mrb_fixnum(regs[a]);\n        y = mrb_float(regs[a+1]);\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FIXNUM):\n        x = mrb_float(regs[a]);\n        y = (mrb_float)mrb_fixnum(regs[a+1]);\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\n        x = mrb_float(regs[a]);\n        y = mrb_float(regs[a+1]);\n        break;\n#endif\n      default:\n        goto L_SEND;\n      }\n\n#ifndef MRB_WITHOUT_FLOAT\n      if (y == 0) {\n        if (x > 0) f = INFINITY;\n        else if (x < 0) f = -INFINITY;\n        else /* if (x == 0) */ f = NAN;\n      }\n      else {\n        f = x / y;\n      }\n      SET_FLOAT_VALUE(mrb, regs[a], f);\n#endif\n      NEXT;\n    }\n\n    CASE(OP_ADDI) {\n      /* A B C  R(A) := R(A)+C (Syms[B]=:+)*/\n      int a = GETARG_A(i);\n\n      /* need to check if + is overridden */\n      switch (mrb_type(regs[a])) {\n      case MRB_TT_FIXNUM:\n        {\n          mrb_int x = mrb_fixnum(regs[a]);\n          mrb_int y = GETARG_C(i);\n          mrb_int z;\n\n          if (mrb_int_add_overflow(x, y, &z)) {\n#ifndef MRB_WITHOUT_FLOAT\n            SET_FLOAT_VALUE(mrb, regs[a], (mrb_float)x + (mrb_float)y);\n            break;\n#endif\n          }\n          SET_INT_VALUE(regs[a], z);\n        }\n        break;\n#ifndef MRB_WITHOUT_FLOAT\n      case MRB_TT_FLOAT:\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          SET_FLOAT_VALUE(mrb, regs[a], x + GETARG_C(i));\n        }\n#else\n        mrb_float(regs[a]) += GETARG_C(i);\n#endif\n        break;\n#endif\n      default:\n        SET_INT_VALUE(regs[a+1], GETARG_C(i));\n        i = MKOP_ABC(OP_SEND, a, GETARG_B(i), 1);\n        goto L_SEND;\n      }\n      NEXT;\n    }\n\n    CASE(OP_SUBI) {\n      /* A B C  R(A) := R(A)-C (Syms[B]=:-)*/\n      int a = GETARG_A(i);\n      mrb_value *regs_a = regs + a;\n\n      /* need to check if + is overridden */\n      switch (mrb_type(regs_a[0])) {\n      case MRB_TT_FIXNUM:\n        {\n          mrb_int x = mrb_fixnum(regs_a[0]);\n          mrb_int y = GETARG_C(i);\n          mrb_int z;\n\n          if (mrb_int_sub_overflow(x, y, &z)) {\n#ifndef MRB_WITHOUT_FLOAT\n            SET_FLOAT_VALUE(mrb, regs_a[0], (mrb_float)x - (mrb_float)y);\n            break;\n#endif\n          }\n          SET_INT_VALUE(regs_a[0], z);\n        }\n        break;\n#ifndef MRB_WITHOUT_FLOAT\n      case MRB_TT_FLOAT:\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          SET_FLOAT_VALUE(mrb, regs[a], x - GETARG_C(i));\n        }\n#else\n        mrb_float(regs_a[0]) -= GETARG_C(i);\n#endif\n        break;\n#endif\n      default:\n        SET_INT_VALUE(regs_a[1], GETARG_C(i));\n        i = MKOP_ABC(OP_SEND, a, GETARG_B(i), 1);\n        goto L_SEND;\n      }\n      NEXT;\n    }\n\n#define OP_CMP_BODY(op,v1,v2) (v1(regs[a]) op v2(regs[a+1]))\n\n#ifdef MRB_WITHOUT_FLOAT\n#define OP_CMP(op) do {\\\n  int result;\\\n  /* need to check if - is overridden */\\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\\\n  case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_fixnum);\\\n    break;\\\n  default:\\\n    goto L_SEND;\\\n  }\\\n  if (result) {\\\n    SET_TRUE_VALUE(regs[a]);\\\n  }\\\n  else {\\\n    SET_FALSE_VALUE(regs[a]);\\\n  }\\\n} while(0)\n#else\n#define OP_CMP(op) do {\\\n  int result;\\\n  /* need to check if - is overridden */\\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\\\n  case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_fixnum);\\\n    break;\\\n  case TYPES2(MRB_TT_FIXNUM,MRB_TT_FLOAT):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_float);\\\n    break;\\\n  case TYPES2(MRB_TT_FLOAT,MRB_TT_FIXNUM):\\\n    result = OP_CMP_BODY(op,mrb_float,mrb_fixnum);\\\n    break;\\\n  case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\\\n    result = OP_CMP_BODY(op,mrb_float,mrb_float);\\\n    break;\\\n  default:\\\n    goto L_SEND;\\\n  }\\\n  if (result) {\\\n    SET_TRUE_VALUE(regs[a]);\\\n  }\\\n  else {\\\n    SET_FALSE_VALUE(regs[a]);\\\n  }\\\n} while(0)\n#endif\n\n    CASE(OP_EQ) {\n      /* A B C  R(A) := R(A)==R(A+1) (Syms[B]=:==,C=1)*/\n      int a = GETARG_A(i);\n      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {\n        SET_TRUE_VALUE(regs[a]);\n      }\n      else {\n        OP_CMP(==);\n      }\n      NEXT;\n    }\n\n    CASE(OP_LT) {\n      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/\n      int a = GETARG_A(i);\n      OP_CMP(<);\n      NEXT;\n    }\n\n    CASE(OP_LE) {\n      /* A B C  R(A) := R(A)<=R(A+1) (Syms[B]=:<=,C=1)*/\n      int a = GETARG_A(i);\n      OP_CMP(<=);\n      NEXT;\n    }\n\n    CASE(OP_GT) {\n      /* A B C  R(A) := R(A)>R(A+1) (Syms[B]=:>,C=1)*/\n      int a = GETARG_A(i);\n      OP_CMP(>);\n      NEXT;\n    }\n\n    CASE(OP_GE) {\n      /* A B C  R(A) := R(A)>=R(A+1) (Syms[B]=:>=,C=1)*/\n      int a = GETARG_A(i);\n      OP_CMP(>=);\n      NEXT;\n    }\n\n    CASE(OP_ARRAY) {\n      /* A B C          R(A) := ary_new(R(B),R(B+1)..R(B+C)) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n      mrb_value v = mrb_ary_new_from_values(mrb, c, &regs[b]);\n      regs[a] = v;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ARYCAT) {\n      /* A B            mrb_ary_concat(R(A),R(B)) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      mrb_value splat = mrb_ary_splat(mrb, regs[b]);\n      mrb_ary_concat(mrb, regs[a], splat);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ARYPUSH) {\n      /* A B            R(A).push(R(B)) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      mrb_ary_push(mrb, regs[a], regs[b]);\n      NEXT;\n    }\n\n    CASE(OP_AREF) {\n      /* A B C          R(A) := R(B)[C] */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n      mrb_value v = regs[b];\n\n      if (!mrb_array_p(v)) {\n        if (c == 0) {\n          regs[a] = v;\n        }\n        else {\n          SET_NIL_VALUE(regs[a]);\n        }\n      }\n      else {\n        v = mrb_ary_ref(mrb, v, c);\n        regs[a] = v;\n      }\n      NEXT;\n    }\n\n    CASE(OP_ASET) {\n      /* A B C          R(B)[C] := R(A) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n      mrb_ary_set(mrb, regs[b], c, regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_APOST) {\n      /* A B C  *R(A),R(A+1)..R(A+C) := R(A) */\n      int a = GETARG_A(i);\n      mrb_value v = regs[a];\n      int pre  = GETARG_B(i);\n      int post = GETARG_C(i);\n      struct RArray *ary;\n      int len, idx;\n\n      if (!mrb_array_p(v)) {\n        v = mrb_ary_new_from_values(mrb, 1, &regs[a]);\n      }\n      ary = mrb_ary_ptr(v);\n      len = (int)ARY_LEN(ary);\n      if (len > pre + post) {\n        v = mrb_ary_new_from_values(mrb, len - pre - post, ARY_PTR(ary)+pre);\n        regs[a++] = v;\n        while (post--) {\n          regs[a++] = ARY_PTR(ary)[len-post-1];\n        }\n      }\n      else {\n        v = mrb_ary_new_capa(mrb, 0);\n        regs[a++] = v;\n        for (idx=0; idx+pre<len; idx++) {\n          regs[a+idx] = ARY_PTR(ary)[pre+idx];\n        }\n        while (idx < post) {\n          SET_NIL_VALUE(regs[a+idx]);\n          idx++;\n        }\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_STRING) {\n      /* A Bx           R(A) := str_new(Lit(Bx)) */\n      mrb_int a = GETARG_A(i);\n      mrb_int bx = GETARG_Bx(i);\n      mrb_value str = mrb_str_dup(mrb, pool[bx]);\n\n      regs[a] = str;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_STRCAT) {\n      /* A B    R(A).concat(R(B)) */\n      mrb_int a = GETARG_A(i);\n      mrb_int b = GETARG_B(i);\n\n      mrb_str_concat(mrb, regs[a], regs[b]);\n      NEXT;\n    }\n\n    CASE(OP_HASH) {\n      /* A B C   R(A) := hash_new(R(B),R(B+1)..R(B+C)) */\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n      int lim = b+c*2;\n      mrb_value hash = mrb_hash_new_capa(mrb, c);\n\n      while (b < lim) {\n        mrb_hash_set(mrb, hash, regs[b], regs[b+1]);\n        b+=2;\n      }\n      regs[GETARG_A(i)] = hash;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_LAMBDA) {\n      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */\n      struct RProc *p;\n      int a = GETARG_A(i);\n      int b = GETARG_b(i);\n      int c = GETARG_c(i);\n      mrb_irep *nirep = irep->reps[b];\n\n      if (c & OP_L_CAPTURE) {\n        p = mrb_closure_new(mrb, nirep);\n      }\n      else {\n        p = mrb_proc_new(mrb, nirep);\n        p->flags |= MRB_PROC_SCOPE;\n      }\n      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;\n      regs[a] = mrb_obj_value(p);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_OCLASS) {\n      /* A      R(A) := ::Object */\n      regs[GETARG_A(i)] = mrb_obj_value(mrb->object_class);\n      NEXT;\n    }\n\n    CASE(OP_CLASS) {\n      /* A B    R(A) := newclass(R(A),Syms(B),R(A+1)) */\n      struct RClass *c = 0, *baseclass;\n      int a = GETARG_A(i);\n      mrb_value base, super;\n      mrb_sym id = syms[GETARG_B(i)];\n\n      base = regs[a];\n      super = regs[a+1];\n      if (mrb_nil_p(base)) {\n        baseclass = MRB_PROC_TARGET_CLASS(mrb->c->ci->proc);\n        base = mrb_obj_value(baseclass);\n      }\n      c = mrb_vm_define_class(mrb, base, super, id);\n      regs[a] = mrb_obj_value(c);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_MODULE) {\n      /* A B            R(A) := newmodule(R(A),Syms(B)) */\n      struct RClass *c = 0, *baseclass;\n      int a = GETARG_A(i);\n      mrb_value base;\n      mrb_sym id = syms[GETARG_B(i)];\n\n      base = regs[a];\n      if (mrb_nil_p(base)) {\n        baseclass = MRB_PROC_TARGET_CLASS(mrb->c->ci->proc);\n        base = mrb_obj_value(baseclass);\n      }\n      c = mrb_vm_define_module(mrb, base, id);\n      regs[a] = mrb_obj_value(c);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_EXEC) {\n      /* A Bx   R(A) := blockexec(R(A),SEQ[Bx]) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_callinfo *ci;\n      mrb_value recv = regs[a];\n      struct RProc *p;\n      mrb_irep *nirep = irep->reps[bx];\n\n      /* prepare closure */\n      p = mrb_proc_new(mrb, nirep);\n      p->c = NULL;\n      mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)proc);\n      MRB_PROC_SET_TARGET_CLASS(p, mrb_class_ptr(recv));\n      p->flags |= MRB_PROC_SCOPE;\n\n      /* prepare call stack */\n      ci = cipush(mrb);\n      ci->pc = pc + 1;\n      ci->acc = a;\n      ci->mid = 0;\n      ci->stackent = mrb->c->stack;\n      ci->argc = 0;\n      ci->target_class = mrb_class_ptr(recv);\n\n      /* prepare stack */\n      mrb->c->stack += a;\n\n      /* setup block to call */\n      ci->proc = p;\n\n      irep = p->body.irep;\n      pool = irep->pool;\n      syms = irep->syms;\n      ci->nregs = irep->nregs;\n      stack_extend(mrb, ci->nregs);\n      stack_clear(regs+1, ci->nregs-1);\n      pc = irep->iseq;\n      JUMP;\n    }\n\n    CASE(OP_METHOD) {\n      /* A B            R(A).newmethod(Syms(B),R(A+1)) */\n      int a = GETARG_A(i);\n      struct RClass *c = mrb_class_ptr(regs[a]);\n      struct RProc *p = mrb_proc_ptr(regs[a+1]);\n      mrb_method_t m;\n\n      MRB_METHOD_FROM_PROC(m, p);\n      mrb_define_method_raw(mrb, c, syms[GETARG_B(i)], m);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_SCLASS) {\n      /* A B    R(A) := R(B).singleton_class */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n\n      regs[a] = mrb_singleton_class(mrb, regs[b]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_TCLASS) {\n      /* A      R(A) := target_class */\n      if (!mrb->c->ci->target_class) {\n        mrb_value exc = mrb_exc_new_str_lit(mrb, E_TYPE_ERROR, \"no target class or module\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      regs[GETARG_A(i)] = mrb_obj_value(mrb->c->ci->target_class);\n      NEXT;\n    }\n\n    CASE(OP_RANGE) {\n      /* A B C  R(A) := range_new(R(B),R(B+1),C) */\n      int b = GETARG_B(i);\n      mrb_value val = mrb_range_new(mrb, regs[b], regs[b+1], GETARG_C(i));\n      regs[GETARG_A(i)] = val;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_DEBUG) {\n      /* A B C    debug print R(A),R(B),R(C) */\n#ifdef MRB_ENABLE_DEBUG_HOOK\n      mrb->debug_op_hook(mrb, irep, pc, regs);\n#else\n#ifndef MRB_DISABLE_STDIO\n      printf(\"OP_DEBUG %d %d %d\\n\", GETARG_A(i), GETARG_B(i), GETARG_C(i));\n#else\n      abort();\n#endif\n#endif\n      NEXT;\n    }\n\n    CASE(OP_STOP) {\n      /*        stop VM */\n    L_STOP:\n      while (mrb->c->eidx > 0) {\n        ecall(mrb);\n      }\n      ERR_PC_CLR(mrb);\n      mrb->jmp = prev_jmp;\n      if (mrb->exc) {\n        return mrb_obj_value(mrb->exc);\n      }\n      return regs[irep->nlocals];\n    }\n\n    CASE(OP_ERR) {\n      /* Bx     raise RuntimeError with message Lit(Bx) */\n      mrb_value msg = mrb_str_dup(mrb, pool[GETARG_Bx(i)]);\n      mrb_value exc;\n\n      if (GETARG_A(i) == 0) {\n        exc = mrb_exc_new_str(mrb, E_RUNTIME_ERROR, msg);\n      }\n      else {\n        exc = mrb_exc_new_str(mrb, E_LOCALJUMP_ERROR, msg);\n      }\n      ERR_PC_SET(mrb, pc);\n      mrb_exc_set(mrb, exc);\n      goto L_RAISE;\n    }\n  }\n  END_DISPATCH;\n#undef regs\n\n  }\n  MRB_CATCH(&c_jmp) {\n    exc_catched = TRUE;\n    goto RETRY_TRY_BLOCK;\n  }\n  MRB_END_EXC(&c_jmp);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143041,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "mrb_vm_exec(mrb_state *mrb, struct RProc *proc, mrb_code *pc)\n{\n  /* mrb_assert(mrb_proc_cfunc_p(proc)) */\n  mrb_irep *irep = proc->body.irep;\n  mrb_value *pool = irep->pool;\n  mrb_sym *syms = irep->syms;\n  mrb_code i;\n  int ai = mrb_gc_arena_save(mrb);\n  struct mrb_jmpbuf *prev_jmp = mrb->jmp;\n  struct mrb_jmpbuf c_jmp;\n\n#ifdef DIRECT_THREADED\n  static void *optable[] = {\n    &&L_OP_NOP, &&L_OP_MOVE,\n    &&L_OP_LOADL, &&L_OP_LOADI, &&L_OP_LOADSYM, &&L_OP_LOADNIL,\n    &&L_OP_LOADSELF, &&L_OP_LOADT, &&L_OP_LOADF,\n    &&L_OP_GETGLOBAL, &&L_OP_SETGLOBAL, &&L_OP_GETSPECIAL, &&L_OP_SETSPECIAL,\n    &&L_OP_GETIV, &&L_OP_SETIV, &&L_OP_GETCV, &&L_OP_SETCV,\n    &&L_OP_GETCONST, &&L_OP_SETCONST, &&L_OP_GETMCNST, &&L_OP_SETMCNST,\n    &&L_OP_GETUPVAR, &&L_OP_SETUPVAR,\n    &&L_OP_JMP, &&L_OP_JMPIF, &&L_OP_JMPNOT,\n    &&L_OP_ONERR, &&L_OP_RESCUE, &&L_OP_POPERR, &&L_OP_RAISE, &&L_OP_EPUSH, &&L_OP_EPOP,\n    &&L_OP_SEND, &&L_OP_SENDB, &&L_OP_FSEND,\n    &&L_OP_CALL, &&L_OP_SUPER, &&L_OP_ARGARY, &&L_OP_ENTER,\n    &&L_OP_KARG, &&L_OP_KDICT, &&L_OP_RETURN, &&L_OP_TAILCALL, &&L_OP_BLKPUSH,\n    &&L_OP_ADD, &&L_OP_ADDI, &&L_OP_SUB, &&L_OP_SUBI, &&L_OP_MUL, &&L_OP_DIV,\n    &&L_OP_EQ, &&L_OP_LT, &&L_OP_LE, &&L_OP_GT, &&L_OP_GE,\n    &&L_OP_ARRAY, &&L_OP_ARYCAT, &&L_OP_ARYPUSH, &&L_OP_AREF, &&L_OP_ASET, &&L_OP_APOST,\n    &&L_OP_STRING, &&L_OP_STRCAT, &&L_OP_HASH,\n    &&L_OP_LAMBDA, &&L_OP_RANGE, &&L_OP_OCLASS,\n    &&L_OP_CLASS, &&L_OP_MODULE, &&L_OP_EXEC,\n    &&L_OP_METHOD, &&L_OP_SCLASS, &&L_OP_TCLASS,\n    &&L_OP_DEBUG, &&L_OP_STOP, &&L_OP_ERR,\n  };\n#endif\n\n  mrb_bool exc_catched = FALSE;\nRETRY_TRY_BLOCK:\n\n  MRB_TRY(&c_jmp) {\n\n  if (exc_catched) {\n    exc_catched = FALSE;\n    if (mrb->exc && mrb->exc->tt == MRB_TT_BREAK)\n      goto L_BREAK;\n    goto L_RAISE;\n  }\n  mrb->jmp = &c_jmp;\n  mrb->c->ci->proc = proc;\n  mrb->c->ci->nregs = irep->nregs;\n\n#define regs (mrb->c->stack)\n  INIT_DISPATCH {\n    CASE(OP_NOP) {\n      /* do nothing */\n      NEXT;\n    }\n\n    CASE(OP_MOVE) {\n      /* A B    R(A) := R(B) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      regs[a] = regs[b];\n      NEXT;\n    }\n\n    CASE(OP_LOADL) {\n      /* A Bx   R(A) := Pool(Bx) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n#ifdef MRB_WORD_BOXING\n      mrb_value val = pool[bx];\n#ifndef MRB_WITHOUT_FLOAT\n      if (mrb_float_p(val)) {\n        val = mrb_float_value(mrb, mrb_float(val));\n      }\n#endif\n      regs[a] = val;\n#else\n      regs[a] = pool[bx];\n#endif\n      NEXT;\n    }\n\n    CASE(OP_LOADI) {\n      /* A sBx  R(A) := sBx */\n      int a = GETARG_A(i);\n      mrb_int bx = GETARG_sBx(i);\n      SET_INT_VALUE(regs[a], bx);\n      NEXT;\n    }\n\n    CASE(OP_LOADSYM) {\n      /* A Bx   R(A) := Syms(Bx) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      SET_SYM_VALUE(regs[a], syms[bx]);\n      NEXT;\n    }\n\n    CASE(OP_LOADSELF) {\n      /* A      R(A) := self */\n      int a = GETARG_A(i);\n      regs[a] = regs[0];\n      NEXT;\n    }\n\n    CASE(OP_LOADT) {\n      /* A      R(A) := true */\n      int a = GETARG_A(i);\n      SET_TRUE_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_LOADF) {\n      /* A      R(A) := false */\n      int a = GETARG_A(i);\n      SET_FALSE_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETGLOBAL) {\n      /* A Bx   R(A) := getglobal(Syms(Bx)) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_value val = mrb_gv_get(mrb, syms[bx]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETGLOBAL) {\n      /* A Bx   setglobal(Syms(Bx), R(A)) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_gv_set(mrb, syms[bx], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETSPECIAL) {\n      /* A Bx   R(A) := Special[Bx] */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_value val = mrb_vm_special_get(mrb, bx);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETSPECIAL) {\n      /* A Bx   Special[Bx] := R(A) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_vm_special_set(mrb, bx, regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETIV) {\n      /* A Bx   R(A) := ivget(Bx) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_value val = mrb_vm_iv_get(mrb, syms[bx]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETIV) {\n      /* A Bx   ivset(Syms(Bx),R(A)) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_vm_iv_set(mrb, syms[bx], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETCV) {\n      /* A Bx   R(A) := cvget(Syms(Bx)) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_value val;\n      ERR_PC_SET(mrb, pc);\n      val = mrb_vm_cv_get(mrb, syms[bx]);\n      ERR_PC_CLR(mrb);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETCV) {\n      /* A Bx   cvset(Syms(Bx),R(A)) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_vm_cv_set(mrb, syms[bx], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETCONST) {\n      /* A Bx    R(A) := constget(Syms(Bx)) */\n      mrb_value val;\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_sym sym = syms[bx];\n\n      ERR_PC_SET(mrb, pc);\n      val = mrb_vm_const_get(mrb, sym);\n      ERR_PC_CLR(mrb);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETCONST) {\n      /* A Bx   constset(Syms(Bx),R(A)) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_vm_const_set(mrb, syms[bx], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETMCNST) {\n      /* A Bx   R(A) := R(A)::Syms(Bx) */\n      mrb_value val;\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n\n      ERR_PC_SET(mrb, pc);\n      val = mrb_const_get(mrb, regs[a], syms[bx]);\n      ERR_PC_CLR(mrb);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETMCNST) {\n      /* A Bx    R(A+1)::Syms(Bx) := R(A) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_const_set(mrb, regs[a+1], syms[bx], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETUPVAR) {\n      /* A B C  R(A) := uvget(B,C) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n       mrb_value *regs_a = regs + a;\n       struct REnv *e = uvenv(mrb, c);\n \n      if (e && b < MRB_ENV_STACK_LEN(e)) {\n        *regs_a = e->stack[b];\n       }\n       else {\n        *regs_a = mrb_nil_value();\n       }\n       NEXT;\n     }\n\n    CASE(OP_SETUPVAR) {\n      /* A B C  uvset(B,C,R(A)) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n\n      struct REnv *e = uvenv(mrb, c);\n\n      if (e) {\n        mrb_value *regs_a = regs + a;\n\n        if (b < MRB_ENV_STACK_LEN(e)) {\n          e->stack[b] = *regs_a;\n          mrb_write_barrier(mrb, (struct RBasic*)e);\n        }\n      }\n      NEXT;\n    }\n\n    CASE(OP_JMP) {\n      /* sBx    pc+=sBx */\n      int sbx = GETARG_sBx(i);\n      pc += sbx;\n      JUMP;\n    }\n\n    CASE(OP_JMPIF) {\n      /* A sBx  if R(A) pc+=sBx */\n      int a = GETARG_A(i);\n      int sbx = GETARG_sBx(i);\n      if (mrb_test(regs[a])) {\n        pc += sbx;\n        JUMP;\n      }\n      NEXT;\n    }\n\n    CASE(OP_JMPNOT) {\n      /* A sBx  if !R(A) pc+=sBx */\n      int a = GETARG_A(i);\n      int sbx = GETARG_sBx(i);\n      if (!mrb_test(regs[a])) {\n        pc += sbx;\n        JUMP;\n      }\n      NEXT;\n    }\n\n    CASE(OP_ONERR) {\n      /* sBx    pc+=sBx on exception */\n      int sbx = GETARG_sBx(i);\n      if (mrb->c->rsize <= mrb->c->ci->ridx) {\n        if (mrb->c->rsize == 0) mrb->c->rsize = RESCUE_STACK_INIT_SIZE;\n        else mrb->c->rsize *= 2;\n        mrb->c->rescue = (mrb_code **)mrb_realloc(mrb, mrb->c->rescue, sizeof(mrb_code*) * mrb->c->rsize);\n      }\n      mrb->c->rescue[mrb->c->ci->ridx++] = pc + sbx;\n      NEXT;\n    }\n\n    CASE(OP_RESCUE) {\n      /* A B    R(A) := exc; clear(exc); R(B) := matched (bool) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n      mrb_value exc;\n\n      if (c == 0) {\n        exc = mrb_obj_value(mrb->exc);\n        mrb->exc = 0;\n      }\n      else {           /* continued; exc taken from R(A) */\n        exc = regs[a];\n      }\n      if (b != 0) {\n        mrb_value e = regs[b];\n        struct RClass *ec;\n\n        switch (mrb_type(e)) {\n        case MRB_TT_CLASS:\n        case MRB_TT_MODULE:\n          break;\n        default:\n          {\n            mrb_value exc;\n\n            exc = mrb_exc_new_str_lit(mrb, E_TYPE_ERROR,\n                  \"class or module required for rescue clause\");\n            mrb_exc_set(mrb, exc);\n            goto L_RAISE;\n          }\n        }\n        ec = mrb_class_ptr(e);\n        regs[b] = mrb_bool_value(mrb_obj_is_kind_of(mrb, exc, ec));\n      }\n      if (a != 0 && c == 0) {\n        regs[a] = exc;\n      }\n      NEXT;\n    }\n\n    CASE(OP_POPERR) {\n      /* A      A.times{rescue_pop()} */\n      int a = GETARG_A(i);\n\n      mrb->c->ci->ridx -= a;\n      NEXT;\n    }\n\n    CASE(OP_RAISE) {\n      /* A      raise(R(A)) */\n      int a = GETARG_A(i);\n\n      mrb_exc_set(mrb, regs[a]);\n      goto L_RAISE;\n    }\n\n    CASE(OP_EPUSH) {\n      /* Bx     ensure_push(SEQ[Bx]) */\n      int bx = GETARG_Bx(i);\n      struct RProc *p;\n\n      p = mrb_closure_new(mrb, irep->reps[bx]);\n      /* push ensure_stack */\n      if (mrb->c->esize <= mrb->c->eidx+1) {\n        if (mrb->c->esize == 0) mrb->c->esize = ENSURE_STACK_INIT_SIZE;\n        else mrb->c->esize *= 2;\n        mrb->c->ensure = (struct RProc **)mrb_realloc(mrb, mrb->c->ensure, sizeof(struct RProc*) * mrb->c->esize);\n      }\n      mrb->c->ensure[mrb->c->eidx++] = p;\n      mrb->c->ensure[mrb->c->eidx] = NULL;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_EPOP) {\n      /* A      A.times{ensure_pop().call} */\n      int a = GETARG_A(i);\n      mrb_callinfo *ci = mrb->c->ci;\n      int n, epos = ci->epos;\n      mrb_value self = regs[0];\n      struct RClass *target_class = ci->target_class;\n\n      if (mrb->c->eidx <= epos) {\n        NEXT;\n      }\n\n      if (a > mrb->c->eidx - epos)\n        a = mrb->c->eidx - epos;\n      pc = pc + 1;\n      for (n=0; n<a; n++) {\n        proc = mrb->c->ensure[epos+n];\n        mrb->c->ensure[epos+n] = NULL;\n        if (proc == NULL) continue;\n        irep = proc->body.irep;\n        ci = cipush(mrb);\n        ci->mid = ci[-1].mid;\n        ci->argc = 0;\n        ci->proc = proc;\n        ci->stackent = mrb->c->stack;\n        ci->nregs = irep->nregs;\n        ci->target_class = target_class;\n        ci->pc = pc;\n        ci->acc = ci[-1].nregs;\n        mrb->c->stack += ci->acc;\n        stack_extend(mrb, ci->nregs);\n        regs[0] = self;\n        pc = irep->iseq;\n      }\n      pool = irep->pool;\n      syms = irep->syms;\n      mrb->c->eidx = epos;\n      JUMP;\n    }\n\n    CASE(OP_LOADNIL) {\n      /* A     R(A) := nil */\n      int a = GETARG_A(i);\n\n      SET_NIL_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_SENDB) {\n      /* A B C  R(A) := call(R(A),Syms(B),R(A+1),...,R(A+C),&R(A+C+1))*/\n      /* fall through */\n    };\n\n  L_SEND:\n    CASE(OP_SEND) {\n      /* A B C  R(A) := call(R(A),Syms(B),R(A+1),...,R(A+C)) */\n      int a = GETARG_A(i);\n      int n = GETARG_C(i);\n      int argc = (n == CALL_MAXARGS) ? -1 : n;\n      int bidx = (argc < 0) ? a+2 : a+n+1;\n      mrb_method_t m;\n      struct RClass *c;\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_value recv, blk;\n      mrb_sym mid = syms[GETARG_B(i)];\n\n      mrb_assert(bidx < ci->nregs);\n\n      recv = regs[a];\n      if (GET_OPCODE(i) != OP_SENDB) {\n        SET_NIL_VALUE(regs[bidx]);\n        blk = regs[bidx];\n      }\n      else {\n        blk = regs[bidx];\n        if (!mrb_nil_p(blk) && mrb_type(blk) != MRB_TT_PROC) {\n          blk = mrb_convert_type(mrb, blk, MRB_TT_PROC, \"Proc\", \"to_proc\");\n          /* The stack might have been reallocated during mrb_convert_type(),\n             see #3622 */\n          regs[bidx] = blk;\n        }\n      }\n      c = mrb_class(mrb, recv);\n      m = mrb_method_search_vm(mrb, &c, mid);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        mrb_sym missing = mrb_intern_lit(mrb, \"method_missing\");\n        m = mrb_method_search_vm(mrb, &c, missing);\n        if (MRB_METHOD_UNDEF_P(m) || (missing == mrb->c->ci->mid && mrb_obj_eq(mrb, regs[0], recv))) {\n          mrb_value args = (argc < 0) ? regs[a+1] : mrb_ary_new_from_values(mrb, n, regs+a+1);\n          ERR_PC_SET(mrb, pc);\n          mrb_method_missing(mrb, mid, recv, args);\n        }\n        if (argc >= 0) {\n          if (a+2 >= irep->nregs) {\n            stack_extend(mrb, a+3);\n          }\n          regs[a+1] = mrb_ary_new_from_values(mrb, n, regs+a+1);\n          regs[a+2] = blk;\n          argc = -1;\n        }\n        mrb_ary_unshift(mrb, regs[a+1], mrb_symbol_value(mid));\n        mid = missing;\n      }\n\n      /* push callinfo */\n      ci = cipush(mrb);\n      ci->mid = mid;\n      ci->stackent = mrb->c->stack;\n      ci->target_class = c;\n      ci->argc = argc;\n\n      ci->pc = pc + 1;\n      ci->acc = a;\n\n      /* prepare stack */\n      mrb->c->stack += a;\n\n      if (MRB_METHOD_CFUNC_P(m)) {\n        ci->nregs = (argc < 0) ? 3 : n+2;\n        if (MRB_METHOD_PROC_P(m)) {\n          struct RProc *p = MRB_METHOD_PROC(m);\n\n          ci->proc = p;\n          recv = p->body.func(mrb, recv);\n        }\n        else {\n          recv = MRB_METHOD_FUNC(m)(mrb, recv);\n        }\n        mrb_gc_arena_restore(mrb, ai);\n        mrb_gc_arena_shrink(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        ci = mrb->c->ci;\n        if (GET_OPCODE(i) == OP_SENDB) {\n          if (mrb_type(blk) == MRB_TT_PROC) {\n            struct RProc *p = mrb_proc_ptr(blk);\n            if (p && !MRB_PROC_STRICT_P(p) && MRB_PROC_ENV(p) == ci[-1].env) {\n              p->flags |= MRB_PROC_ORPHAN;\n            }\n          }\n        }\n        if (!ci->target_class) { /* return from context modifying method (resume/yield) */\n          if (ci->acc == CI_ACC_RESUMED) {\n            mrb->jmp = prev_jmp;\n            return recv;\n          }\n          else {\n            mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));\n            proc = ci[-1].proc;\n            irep = proc->body.irep;\n            pool = irep->pool;\n            syms = irep->syms;\n          }\n        }\n        mrb->c->stack[0] = recv;\n        /* pop stackpos */\n        mrb->c->stack = ci->stackent;\n        pc = ci->pc;\n        cipop(mrb);\n        JUMP;\n      }\n      else {\n        /* setup environment for calling method */\n        proc = ci->proc = MRB_METHOD_PROC(m);\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        ci->nregs = irep->nregs;\n        stack_extend(mrb, (argc < 0 && ci->nregs < 3) ? 3 : ci->nregs);\n        pc = irep->iseq;\n        JUMP;\n      }\n    }\n\n    CASE(OP_FSEND) {\n      /* A B C  R(A) := fcall(R(A),Syms(B),R(A+1),... ,R(A+C-1)) */\n      /* not implemented yet */\n      NEXT;\n    }\n\n    CASE(OP_CALL) {\n      /* A      R(A) := self.call(frame.argc, frame.argv) */\n      mrb_callinfo *ci;\n      mrb_value recv = mrb->c->stack[0];\n      struct RProc *m = mrb_proc_ptr(recv);\n\n      /* replace callinfo */\n      ci = mrb->c->ci;\n      ci->target_class = MRB_PROC_TARGET_CLASS(m);\n      ci->proc = m;\n      if (MRB_PROC_ENV_P(m)) {\n        mrb_sym mid;\n        struct REnv *e = MRB_PROC_ENV(m);\n\n        mid = e->mid;\n        if (mid) ci->mid = mid;\n        if (!e->stack) {\n          e->stack = mrb->c->stack;\n        }\n      }\n\n      /* prepare stack */\n      if (MRB_PROC_CFUNC_P(m)) {\n        recv = MRB_PROC_CFUNC(m)(mrb, recv);\n        mrb_gc_arena_restore(mrb, ai);\n        mrb_gc_arena_shrink(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        /* pop stackpos */\n        ci = mrb->c->ci;\n        mrb->c->stack = ci->stackent;\n        regs[ci->acc] = recv;\n        pc = ci->pc;\n        cipop(mrb);\n        irep = mrb->c->ci->proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        JUMP;\n      }\n      else {\n        /* setup environment for calling method */\n        proc = m;\n        irep = m->body.irep;\n        if (!irep) {\n          mrb->c->stack[0] = mrb_nil_value();\n          goto L_RETURN;\n        }\n        pool = irep->pool;\n        syms = irep->syms;\n        ci->nregs = irep->nregs;\n        stack_extend(mrb, ci->nregs);\n        if (ci->argc < 0) {\n          if (irep->nregs > 3) {\n            stack_clear(regs+3, irep->nregs-3);\n          }\n        }\n        else if (ci->argc+2 < irep->nregs) {\n          stack_clear(regs+ci->argc+2, irep->nregs-ci->argc-2);\n        }\n        if (MRB_PROC_ENV_P(m)) {\n          regs[0] = MRB_PROC_ENV(m)->stack[0];\n        }\n        pc = irep->iseq;\n        JUMP;\n      }\n    }\n\n    CASE(OP_SUPER) {\n      /* A C  R(A) := super(R(A+1),... ,R(A+C+1)) */\n      int a = GETARG_A(i);\n      int n = GETARG_C(i);\n      int argc = (n == CALL_MAXARGS) ? -1 : n;\n      int bidx = (argc < 0) ? a+2 : a+n+1;\n      mrb_method_t m;\n      struct RClass *c;\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_value recv, blk;\n      mrb_sym mid = ci->mid;\n      struct RClass* target_class = MRB_PROC_TARGET_CLASS(ci->proc);\n\n      mrb_assert(bidx < ci->nregs);\n\n      if (mid == 0 || !target_class) {\n        mrb_value exc = mrb_exc_new_str_lit(mrb, E_NOMETHOD_ERROR, \"super called outside of method\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      if (target_class->tt == MRB_TT_MODULE) {\n        target_class = ci->target_class;\n        if (target_class->tt != MRB_TT_ICLASS) {\n          mrb_value exc = mrb_exc_new_str_lit(mrb, E_RUNTIME_ERROR, \"superclass info lost [mruby limitations]\");\n          mrb_exc_set(mrb, exc);\n          goto L_RAISE;\n        }\n      }\n      recv = regs[0];\n      if (!mrb_obj_is_kind_of(mrb, recv, target_class)) {\n        mrb_value exc = mrb_exc_new_str_lit(mrb, E_TYPE_ERROR,\n                                            \"self has wrong type to call super in this context\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      blk = regs[bidx];\n      if (!mrb_nil_p(blk) && mrb_type(blk) != MRB_TT_PROC) {\n        blk = mrb_convert_type(mrb, blk, MRB_TT_PROC, \"Proc\", \"to_proc\");\n        /* The stack or ci stack might have been reallocated during\n           mrb_convert_type(), see #3622 and #3784 */\n        regs[bidx] = blk;\n        ci = mrb->c->ci;\n      }\n      c = target_class->super;\n      m = mrb_method_search_vm(mrb, &c, mid);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        mrb_sym missing = mrb_intern_lit(mrb, \"method_missing\");\n\n        if (mid != missing) {\n          c = mrb_class(mrb, recv);\n        }\n        m = mrb_method_search_vm(mrb, &c, missing);\n        if (MRB_METHOD_UNDEF_P(m)) {\n          mrb_value args = (argc < 0) ? regs[a+1] : mrb_ary_new_from_values(mrb, n, regs+a+1);\n          ERR_PC_SET(mrb, pc);\n          mrb_method_missing(mrb, mid, recv, args);\n        }\n        mid = missing;\n        if (argc >= 0) {\n          if (a+2 >= ci->nregs) {\n            stack_extend(mrb, a+3);\n          }\n          regs[a+1] = mrb_ary_new_from_values(mrb, n, regs+a+1);\n          regs[a+2] = blk;\n          argc = -1;\n        }\n        mrb_ary_unshift(mrb, regs[a+1], mrb_symbol_value(ci->mid));\n      }\n\n      /* push callinfo */\n      ci = cipush(mrb);\n      ci->mid = mid;\n      ci->stackent = mrb->c->stack;\n      ci->target_class = c;\n      ci->pc = pc + 1;\n      ci->argc = argc;\n\n      /* prepare stack */\n      mrb->c->stack += a;\n      mrb->c->stack[0] = recv;\n\n      if (MRB_METHOD_CFUNC_P(m)) {\n        mrb_value v;\n        ci->nregs = (argc < 0) ? 3 : n+2;\n        if (MRB_METHOD_PROC_P(m)) {\n          ci->proc = MRB_METHOD_PROC(m);\n        }\n        v = MRB_METHOD_CFUNC(m)(mrb, recv);\n        mrb_gc_arena_restore(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        ci = mrb->c->ci;\n        if (!ci->target_class) { /* return from context modifying method (resume/yield) */\n          if (ci->acc == CI_ACC_RESUMED) {\n            mrb->jmp = prev_jmp;\n            return v;\n          }\n          else {\n            mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));\n            proc = ci[-1].proc;\n            irep = proc->body.irep;\n            pool = irep->pool;\n            syms = irep->syms;\n          }\n        }\n        mrb->c->stack[0] = v;\n        /* pop stackpos */\n        mrb->c->stack = ci->stackent;\n        pc = ci->pc;\n        cipop(mrb);\n        JUMP;\n      }\n      else {\n        /* fill callinfo */\n        ci->acc = a;\n\n        /* setup environment for calling method */\n        proc = ci->proc = MRB_METHOD_PROC(m);\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        ci->nregs = irep->nregs;\n        stack_extend(mrb, (argc < 0 && ci->nregs < 3) ? 3 : ci->nregs);\n        pc = irep->iseq;\n        JUMP;\n      }\n    }\n\n    CASE(OP_ARGARY) {\n      /* A Bx   R(A) := argument array (16=6:1:5:4) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      int m1 = (bx>>10)&0x3f;\n      int r  = (bx>>9)&0x1;\n      int m2 = (bx>>4)&0x1f;\n      int lv = (bx>>0)&0xf;\n      mrb_value *stack;\n\n      if (mrb->c->ci->mid == 0 || mrb->c->ci->target_class == NULL) {\n        mrb_value exc;\n\n      L_NOSUPER:\n        exc = mrb_exc_new_str_lit(mrb, E_NOMETHOD_ERROR, \"super called outside of method\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      if (lv == 0) stack = regs + 1;\n      else {\n        struct REnv *e = uvenv(mrb, lv-1);\n        if (!e) goto L_NOSUPER;\n        if (MRB_ENV_STACK_LEN(e) <= m1+r+m2+1)\n          goto L_NOSUPER;\n        stack = e->stack + 1;\n      }\n      if (r == 0) {\n        regs[a] = mrb_ary_new_from_values(mrb, m1+m2, stack);\n      }\n      else {\n        mrb_value *pp = NULL;\n        struct RArray *rest;\n        int len = 0;\n\n        if (mrb_array_p(stack[m1])) {\n          struct RArray *ary = mrb_ary_ptr(stack[m1]);\n\n          pp = ARY_PTR(ary);\n          len = (int)ARY_LEN(ary);\n        }\n        regs[a] = mrb_ary_new_capa(mrb, m1+len+m2);\n        rest = mrb_ary_ptr(regs[a]);\n        if (m1 > 0) {\n          stack_copy(ARY_PTR(rest), stack, m1);\n        }\n        if (len > 0) {\n          stack_copy(ARY_PTR(rest)+m1, pp, len);\n        }\n        if (m2 > 0) {\n          stack_copy(ARY_PTR(rest)+m1+len, stack+m1+1, m2);\n        }\n        ARY_SET_LEN(rest, m1+len+m2);\n      }\n      regs[a+1] = stack[m1+r+m2];\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ENTER) {\n      /* Ax             arg setup according to flags (23=5:5:1:5:5:1:1) */\n      /* number of optional arguments times OP_JMP should follow */\n      mrb_aspec ax = GETARG_Ax(i);\n      int m1 = MRB_ASPEC_REQ(ax);\n      int o  = MRB_ASPEC_OPT(ax);\n      int r  = MRB_ASPEC_REST(ax);\n      int m2 = MRB_ASPEC_POST(ax);\n      /* unused\n      int k  = MRB_ASPEC_KEY(ax);\n      int kd = MRB_ASPEC_KDICT(ax);\n      int b  = MRB_ASPEC_BLOCK(ax);\n      */\n      int argc = mrb->c->ci->argc;\n      mrb_value *argv = regs+1;\n      mrb_value *argv0 = argv;\n      int len = m1 + o + r + m2;\n      mrb_value *blk = &argv[argc < 0 ? 1 : argc];\n\n      if (argc < 0) {\n        struct RArray *ary = mrb_ary_ptr(regs[1]);\n        argv = ARY_PTR(ary);\n        argc = (int)ARY_LEN(ary);\n        mrb_gc_protect(mrb, regs[1]);\n      }\n      if (mrb->c->ci->proc && MRB_PROC_STRICT_P(mrb->c->ci->proc)) {\n        if (argc >= 0) {\n          if (argc < m1 + m2 || (r == 0 && argc > len)) {\n            argnum_error(mrb, m1+m2);\n            goto L_RAISE;\n          }\n        }\n      }\n      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {\n        mrb_gc_protect(mrb, argv[0]);\n        argc = (int)RARRAY_LEN(argv[0]);\n        argv = RARRAY_PTR(argv[0]);\n      }\n      if (argc < len) {\n        int mlen = m2;\n        if (argc < m1+m2) {\n          if (m1 < argc)\n            mlen = argc - m1;\n          else\n            mlen = 0;\n        }\n        regs[len+1] = *blk; /* move block */\n        SET_NIL_VALUE(regs[argc+1]);\n        if (argv0 != argv) {\n          value_move(&regs[1], argv, argc-mlen); /* m1 + o */\n        }\n        if (argc < m1) {\n          stack_clear(&regs[argc+1], m1-argc);\n        }\n        if (mlen) {\n          value_move(&regs[len-m2+1], &argv[argc-mlen], mlen);\n        }\n        if (mlen < m2) {\n          stack_clear(&regs[len-m2+mlen+1], m2-mlen);\n        }\n        if (r) {\n          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);\n        }\n        if (o == 0 || argc < m1+m2) pc++;\n        else\n          pc += argc - m1 - m2 + 1;\n      }\n      else {\n        int rnum = 0;\n        if (argv0 != argv) {\n          regs[len+1] = *blk; /* move block */\n          value_move(&regs[1], argv, m1+o);\n        }\n        if (r) {\n          rnum = argc-m1-o-m2;\n          regs[m1+o+1] = mrb_ary_new_from_values(mrb, rnum, argv+m1+o);\n        }\n        if (m2) {\n          if (argc-m2 > m1) {\n            value_move(&regs[m1+o+r+1], &argv[m1+o+rnum], m2);\n          }\n        }\n        if (argv0 == argv) {\n          regs[len+1] = *blk; /* move block */\n        }\n        pc += o + 1;\n      }\n      mrb->c->ci->argc = len;\n      /* clear local (but non-argument) variables */\n      if (irep->nlocals-len-2 > 0) {\n        stack_clear(&regs[len+2], irep->nlocals-len-2);\n      }\n      JUMP;\n    }\n\n    CASE(OP_KARG) {\n      /* A B C          R(A) := kdict[Syms(B)]; if C kdict.rm(Syms(B)) */\n      /* if C == 2; raise unless kdict.empty? */\n      /* OP_JMP should follow to skip init code */\n      NEXT;\n    }\n\n    CASE(OP_KDICT) {\n      /* A C            R(A) := kdict */\n      NEXT;\n    }\n\n    L_RETURN:\n      i = MKOP_AB(OP_RETURN, GETARG_A(i), OP_R_NORMAL);\n      /* fall through */\n    CASE(OP_RETURN) {\n      /* A B     return R(A) (B=normal,in-block return/break) */\n      mrb_callinfo *ci;\n\n#define ecall_adjust() do {\\\n  ptrdiff_t cioff = ci - mrb->c->cibase;\\\n  ecall(mrb);\\\n  ci = mrb->c->cibase + cioff;\\\n} while (0)\n\n      ci = mrb->c->ci;\n      if (ci->mid) {\n        mrb_value blk;\n\n        if (ci->argc < 0) {\n          blk = regs[2];\n        }\n        else {\n          blk = regs[ci->argc+1];\n        }\n        if (mrb_type(blk) == MRB_TT_PROC) {\n          struct RProc *p = mrb_proc_ptr(blk);\n\n          if (!MRB_PROC_STRICT_P(p) &&\n              ci > mrb->c->cibase && MRB_PROC_ENV(p) == ci[-1].env) {\n            p->flags |= MRB_PROC_ORPHAN;\n          }\n        }\n      }\n\n      if (mrb->exc) {\n        mrb_callinfo *ci0;\n\n      L_RAISE:\n        ci0 = ci = mrb->c->ci;\n        if (ci == mrb->c->cibase) {\n          if (ci->ridx == 0) goto L_FTOP;\n          goto L_RESCUE;\n        }\n        while (ci[0].ridx == ci[-1].ridx) {\n          cipop(mrb);\n          mrb->c->stack = ci->stackent;\n          if (ci->acc == CI_ACC_SKIP && prev_jmp) {\n            mrb->jmp = prev_jmp;\n            MRB_THROW(prev_jmp);\n          }\n          ci = mrb->c->ci;\n          if (ci == mrb->c->cibase) {\n            if (ci->ridx == 0) {\n            L_FTOP:             /* fiber top */\n              if (mrb->c == mrb->root_c) {\n                mrb->c->stack = mrb->c->stbase;\n                goto L_STOP;\n              }\n              else {\n                struct mrb_context *c = mrb->c;\n\n                while (c->eidx > ci->epos) {\n                  ecall_adjust();\n                }\n                if (c->fib) {\n                  mrb_write_barrier(mrb, (struct RBasic*)c->fib);\n                }\n                mrb->c->status = MRB_FIBER_TERMINATED;\n                mrb->c = c->prev;\n                c->prev = NULL;\n                goto L_RAISE;\n              }\n            }\n            break;\n          }\n          /* call ensure only when we skip this callinfo */\n          if (ci[0].ridx == ci[-1].ridx) {\n            while (mrb->c->eidx > ci->epos) {\n              ecall_adjust();\n            }\n          }\n        }\n      L_RESCUE:\n        if (ci->ridx == 0) goto L_STOP;\n        proc = ci->proc;\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        if (ci < ci0) {\n          mrb->c->stack = ci[1].stackent;\n        }\n        stack_extend(mrb, irep->nregs);\n        pc = mrb->c->rescue[--ci->ridx];\n      }\n      else {\n        int acc;\n        mrb_value v;\n        struct RProc *dst;\n\n        ci = mrb->c->ci;\n        v = regs[GETARG_A(i)];\n        mrb_gc_protect(mrb, v);\n        switch (GETARG_B(i)) {\n        case OP_R_RETURN:\n          /* Fall through to OP_R_NORMAL otherwise */\n          if (ci->acc >=0 && MRB_PROC_ENV_P(proc) && !MRB_PROC_STRICT_P(proc)) {\n            mrb_callinfo *cibase = mrb->c->cibase;\n            dst = top_proc(mrb, proc);\n\n            if (MRB_PROC_ENV_P(dst)) {\n              struct REnv *e = MRB_PROC_ENV(dst);\n\n              if (!MRB_ENV_STACK_SHARED_P(e) || e->cxt != mrb->c) {\n                localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n                goto L_RAISE;\n              }\n            }\n            while (cibase <= ci && ci->proc != dst) {\n              if (ci->acc < 0) {\n                localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n                goto L_RAISE;\n              }\n              ci--;\n            }\n            if (ci <= cibase) {\n              localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n              goto L_RAISE;\n            }\n            break;\n          }\n        case OP_R_NORMAL:\n        NORMAL_RETURN:\n          if (ci == mrb->c->cibase) {\n            struct mrb_context *c;\n\n            if (!mrb->c->prev) { /* toplevel return */\n              localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n              goto L_RAISE;\n            }\n            if (mrb->c->prev->ci == mrb->c->prev->cibase) {\n              mrb_value exc = mrb_exc_new_str_lit(mrb, E_FIBER_ERROR, \"double resume\");\n              mrb_exc_set(mrb, exc);\n              goto L_RAISE;\n            }\n            while (mrb->c->eidx > 0) {\n              ecall(mrb);\n            }\n            /* automatic yield at the end */\n            c = mrb->c;\n            c->status = MRB_FIBER_TERMINATED;\n            mrb->c = c->prev;\n            c->prev = NULL;\n            mrb->c->status = MRB_FIBER_RUNNING;\n            ci = mrb->c->ci;\n          }\n          break;\n        case OP_R_BREAK:\n          if (MRB_PROC_STRICT_P(proc)) goto NORMAL_RETURN;\n          if (MRB_PROC_ORPHAN_P(proc)) { \n            mrb_value exc;\n\n          L_BREAK_ERROR:\n            exc = mrb_exc_new_str_lit(mrb, E_LOCALJUMP_ERROR,\n                                      \"break from proc-closure\");\n            mrb_exc_set(mrb, exc);\n            goto L_RAISE;\n          }\n          if (!MRB_PROC_ENV_P(proc) || !MRB_ENV_STACK_SHARED_P(MRB_PROC_ENV(proc))) {\n            goto L_BREAK_ERROR;\n          }\n          else {\n            struct REnv *e = MRB_PROC_ENV(proc);\n\n            if (e == mrb->c->cibase->env && proc != mrb->c->cibase->proc) {\n              goto L_BREAK_ERROR;\n            }\n            if (e->cxt != mrb->c) {\n              goto L_BREAK_ERROR;\n            }\n          }\n          while (mrb->c->eidx > mrb->c->ci->epos) {\n            ecall_adjust();\n          }\n          /* break from fiber block */\n          if (ci == mrb->c->cibase && ci->pc) {\n            struct mrb_context *c = mrb->c;\n\n            mrb->c = c->prev;\n            c->prev = NULL;\n            ci = mrb->c->ci;\n          }\n          if (ci->acc < 0) {\n            mrb_gc_arena_restore(mrb, ai);\n            mrb->c->vmexec = FALSE;\n            mrb->exc = (struct RObject*)break_new(mrb, proc, v);\n            mrb->jmp = prev_jmp;\n            MRB_THROW(prev_jmp);\n          }\n          if (FALSE) {\n          L_BREAK:\n            v = ((struct RBreak*)mrb->exc)->val;\n            proc = ((struct RBreak*)mrb->exc)->proc;\n            mrb->exc = NULL;\n            ci = mrb->c->ci;\n          }\n          mrb->c->stack = ci->stackent;\n          proc = proc->upper;\n          while (mrb->c->cibase < ci &&  ci[-1].proc != proc) {\n            if (ci[-1].acc == CI_ACC_SKIP) {\n              while (ci < mrb->c->ci) {\n                cipop(mrb);\n              }\n              goto L_BREAK_ERROR;\n            }\n            ci--;\n          }\n          if (ci == mrb->c->cibase) {\n            goto L_BREAK_ERROR;\n          }\n          break;\n        default:\n          /* cannot happen */\n          break;\n        }\n        while (ci < mrb->c->ci) {\n          cipop(mrb);\n        }\n        ci[0].ridx = ci[-1].ridx;\n        while (mrb->c->eidx > ci->epos) {\n          ecall_adjust();\n        }\n        if (mrb->c->vmexec && !ci->target_class) {\n          mrb_gc_arena_restore(mrb, ai);\n          mrb->c->vmexec = FALSE;\n          mrb->jmp = prev_jmp;\n          return v;\n        }\n        acc = ci->acc;\n        mrb->c->stack = ci->stackent;\n        cipop(mrb);\n        if (acc == CI_ACC_SKIP || acc == CI_ACC_DIRECT) {\n          mrb_gc_arena_restore(mrb, ai);\n          mrb->jmp = prev_jmp;\n          return v;\n        }\n        pc = ci->pc;\n        ci = mrb->c->ci;\n        DEBUG(fprintf(stderr, \"from :%s\\n\", mrb_sym2name(mrb, ci->mid)));\n        proc = mrb->c->ci->proc;\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n\n        regs[acc] = v;\n        mrb_gc_arena_restore(mrb, ai);\n      }\n      JUMP;\n    }\n\n    CASE(OP_TAILCALL) {\n      /* A B C  return call(R(A),Syms(B),R(A+1),... ,R(A+C+1)) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int n = GETARG_C(i);\n      mrb_method_t m;\n      struct RClass *c;\n      mrb_callinfo *ci;\n      mrb_value recv;\n      mrb_sym mid = syms[b];\n\n      recv = regs[a];\n      c = mrb_class(mrb, recv);\n      m = mrb_method_search_vm(mrb, &c, mid);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        mrb_value sym = mrb_symbol_value(mid);\n        mrb_sym missing = mrb_intern_lit(mrb, \"method_missing\");\n        m = mrb_method_search_vm(mrb, &c, missing);\n        if (MRB_METHOD_UNDEF_P(m)) {\n          mrb_value args;\n\n          if (n == CALL_MAXARGS) {\n            args = regs[a+1];\n          }\n          else {\n            args = mrb_ary_new_from_values(mrb, n, regs+a+1);\n          }\n          ERR_PC_SET(mrb, pc);\n          mrb_method_missing(mrb, mid, recv, args);\n        }\n        mid = missing;\n        if (n == CALL_MAXARGS) {\n          mrb_ary_unshift(mrb, regs[a+1], sym);\n        }\n        else {\n          value_move(regs+a+2, regs+a+1, ++n);\n          regs[a+1] = sym;\n        }\n      }\n\n      /* replace callinfo */\n      ci = mrb->c->ci;\n      ci->mid = mid;\n      ci->target_class = c;\n      if (n == CALL_MAXARGS) {\n        ci->argc = -1;\n      }\n      else {\n        ci->argc = n;\n      }\n\n      /* move stack */\n      value_move(mrb->c->stack, &regs[a], ci->argc+1);\n\n      if (MRB_METHOD_CFUNC_P(m)) {\n        mrb_value v = MRB_METHOD_CFUNC(m)(mrb, recv);\n        mrb->c->stack[0] = v;\n        mrb_gc_arena_restore(mrb, ai);\n        goto L_RETURN;\n      }\n      else {\n        /* setup environment for calling method */\n        struct RProc *p = MRB_METHOD_PROC(m);\n        irep = p->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        if (ci->argc < 0) {\n          stack_extend(mrb, (irep->nregs < 3) ? 3 : irep->nregs);\n        }\n        else {\n          stack_extend(mrb, irep->nregs);\n        }\n        pc = irep->iseq;\n      }\n      JUMP;\n    }\n\n    CASE(OP_BLKPUSH) {\n      /* A Bx   R(A) := block (16=6:1:5:4) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      int m1 = (bx>>10)&0x3f;\n      int r  = (bx>>9)&0x1;\n      int m2 = (bx>>4)&0x1f;\n      int lv = (bx>>0)&0xf;\n      mrb_value *stack;\n\n      if (lv == 0) stack = regs + 1;\n      else {\n        struct REnv *e = uvenv(mrb, lv-1);\n        if (!e || (!MRB_ENV_STACK_SHARED_P(e) && e->mid == 0) ||\n            MRB_ENV_STACK_LEN(e) <= m1+r+m2+1) {\n          localjump_error(mrb, LOCALJUMP_ERROR_YIELD);\n          goto L_RAISE;\n        }\n        stack = e->stack + 1;\n      }\n      if (mrb_nil_p(stack[m1+r+m2])) {\n        localjump_error(mrb, LOCALJUMP_ERROR_YIELD);\n        goto L_RAISE;\n      }\n      regs[a] = stack[m1+r+m2];\n      NEXT;\n    }\n\n#define TYPES2(a,b) ((((uint16_t)(a))<<8)|(((uint16_t)(b))&0xff))\n#define OP_MATH_BODY(op,v1,v2) do {\\\n  v1(regs[a]) = v1(regs[a]) op v2(regs[a+1]);\\\n} while(0)\n\n    CASE(OP_ADD) {\n      /* A B C  R(A) := R(A)+R(A+1) (Syms[B]=:+,C=1)*/\n      int a = GETARG_A(i);\n\n      /* need to check if op is overridden */\n      switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):\n        {\n          mrb_int x, y, z;\n          mrb_value *regs_a = regs + a;\n\n          x = mrb_fixnum(regs_a[0]);\n          y = mrb_fixnum(regs_a[1]);\n          if (mrb_int_add_overflow(x, y, &z)) {\n#ifndef MRB_WITHOUT_FLOAT\n            SET_FLOAT_VALUE(mrb, regs_a[0], (mrb_float)x + (mrb_float)y);\n            break;\n#endif\n          }\n          SET_INT_VALUE(regs[a], z);\n        }\n        break;\n#ifndef MRB_WITHOUT_FLOAT\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FLOAT):\n        {\n          mrb_int x = mrb_fixnum(regs[a]);\n          mrb_float y = mrb_float(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], (mrb_float)x + y);\n        }\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FIXNUM):\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          mrb_int y = mrb_fixnum(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], x + y);\n        }\n#else\n        OP_MATH_BODY(+,mrb_float,mrb_fixnum);\n#endif\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          mrb_float y = mrb_float(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], x + y);\n        }\n#else\n        OP_MATH_BODY(+,mrb_float,mrb_float);\n#endif\n        break;\n#endif\n      case TYPES2(MRB_TT_STRING,MRB_TT_STRING):\n        regs[a] = mrb_str_plus(mrb, regs[a], regs[a+1]);\n        break;\n      default:\n        goto L_SEND;\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_SUB) {\n      /* A B C  R(A) := R(A)-R(A+1) (Syms[B]=:-,C=1)*/\n      int a = GETARG_A(i);\n\n      /* need to check if op is overridden */\n      switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):\n        {\n          mrb_int x, y, z;\n\n          x = mrb_fixnum(regs[a]);\n          y = mrb_fixnum(regs[a+1]);\n          if (mrb_int_sub_overflow(x, y, &z)) {\n#ifndef MRB_WITHOUT_FLOAT\n            SET_FLOAT_VALUE(mrb, regs[a], (mrb_float)x - (mrb_float)y);\n            break;\n#endif\n          }\n          SET_INT_VALUE(regs[a], z);\n        }\n        break;\n#ifndef MRB_WITHOUT_FLOAT\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FLOAT):\n        {\n          mrb_int x = mrb_fixnum(regs[a]);\n          mrb_float y = mrb_float(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], (mrb_float)x - y);\n        }\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FIXNUM):\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          mrb_int y = mrb_fixnum(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], x - y);\n        }\n#else\n        OP_MATH_BODY(-,mrb_float,mrb_fixnum);\n#endif\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          mrb_float y = mrb_float(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], x - y);\n        }\n#else\n        OP_MATH_BODY(-,mrb_float,mrb_float);\n#endif\n        break;\n#endif\n      default:\n        goto L_SEND;\n      }\n      NEXT;\n    }\n\n    CASE(OP_MUL) {\n      /* A B C  R(A) := R(A)*R(A+1) (Syms[B]=:*,C=1)*/\n      int a = GETARG_A(i);\n\n      /* need to check if op is overridden */\n      switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):\n        {\n          mrb_int x, y, z;\n\n          x = mrb_fixnum(regs[a]);\n          y = mrb_fixnum(regs[a+1]);\n          if (mrb_int_mul_overflow(x, y, &z)) {\n#ifndef MRB_WITHOUT_FLOAT\n            SET_FLOAT_VALUE(mrb, regs[a], (mrb_float)x * (mrb_float)y);\n            break;\n#endif\n          }\n          SET_INT_VALUE(regs[a], z);\n        }\n        break;\n#ifndef MRB_WITHOUT_FLOAT\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FLOAT):\n        {\n          mrb_int x = mrb_fixnum(regs[a]);\n          mrb_float y = mrb_float(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], (mrb_float)x * y);\n        }\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FIXNUM):\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          mrb_int y = mrb_fixnum(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], x * y);\n        }\n#else\n        OP_MATH_BODY(*,mrb_float,mrb_fixnum);\n#endif\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          mrb_float y = mrb_float(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], x * y);\n        }\n#else\n        OP_MATH_BODY(*,mrb_float,mrb_float);\n#endif\n        break;\n#endif\n      default:\n        goto L_SEND;\n      }\n      NEXT;\n    }\n\n    CASE(OP_DIV) {\n      /* A B C  R(A) := R(A)/R(A+1) (Syms[B]=:/,C=1)*/\n      int a = GETARG_A(i);\n#ifndef MRB_WITHOUT_FLOAT\n      double x, y, f;\n#endif\n\n      /* need to check if op is overridden */\n      switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):\n#ifdef MRB_WITHOUT_FLOAT\n        {\n          mrb_int x = mrb_fixnum(regs[a]);\n          mrb_int y = mrb_fixnum(regs[a+1]);\n          SET_INT_VALUE(regs[a], y ? x / y : 0);\n        }\n        break;\n#else\n        x = (mrb_float)mrb_fixnum(regs[a]);\n        y = (mrb_float)mrb_fixnum(regs[a+1]);\n        break;\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FLOAT):\n        x = (mrb_float)mrb_fixnum(regs[a]);\n        y = mrb_float(regs[a+1]);\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FIXNUM):\n        x = mrb_float(regs[a]);\n        y = (mrb_float)mrb_fixnum(regs[a+1]);\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\n        x = mrb_float(regs[a]);\n        y = mrb_float(regs[a+1]);\n        break;\n#endif\n      default:\n        goto L_SEND;\n      }\n\n#ifndef MRB_WITHOUT_FLOAT\n      if (y == 0) {\n        if (x > 0) f = INFINITY;\n        else if (x < 0) f = -INFINITY;\n        else /* if (x == 0) */ f = NAN;\n      }\n      else {\n        f = x / y;\n      }\n      SET_FLOAT_VALUE(mrb, regs[a], f);\n#endif\n      NEXT;\n    }\n\n    CASE(OP_ADDI) {\n      /* A B C  R(A) := R(A)+C (Syms[B]=:+)*/\n      int a = GETARG_A(i);\n\n      /* need to check if + is overridden */\n      switch (mrb_type(regs[a])) {\n      case MRB_TT_FIXNUM:\n        {\n          mrb_int x = mrb_fixnum(regs[a]);\n          mrb_int y = GETARG_C(i);\n          mrb_int z;\n\n          if (mrb_int_add_overflow(x, y, &z)) {\n#ifndef MRB_WITHOUT_FLOAT\n            SET_FLOAT_VALUE(mrb, regs[a], (mrb_float)x + (mrb_float)y);\n            break;\n#endif\n          }\n          SET_INT_VALUE(regs[a], z);\n        }\n        break;\n#ifndef MRB_WITHOUT_FLOAT\n      case MRB_TT_FLOAT:\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          SET_FLOAT_VALUE(mrb, regs[a], x + GETARG_C(i));\n        }\n#else\n        mrb_float(regs[a]) += GETARG_C(i);\n#endif\n        break;\n#endif\n      default:\n        SET_INT_VALUE(regs[a+1], GETARG_C(i));\n        i = MKOP_ABC(OP_SEND, a, GETARG_B(i), 1);\n        goto L_SEND;\n      }\n      NEXT;\n    }\n\n    CASE(OP_SUBI) {\n      /* A B C  R(A) := R(A)-C (Syms[B]=:-)*/\n      int a = GETARG_A(i);\n      mrb_value *regs_a = regs + a;\n\n      /* need to check if + is overridden */\n      switch (mrb_type(regs_a[0])) {\n      case MRB_TT_FIXNUM:\n        {\n          mrb_int x = mrb_fixnum(regs_a[0]);\n          mrb_int y = GETARG_C(i);\n          mrb_int z;\n\n          if (mrb_int_sub_overflow(x, y, &z)) {\n#ifndef MRB_WITHOUT_FLOAT\n            SET_FLOAT_VALUE(mrb, regs_a[0], (mrb_float)x - (mrb_float)y);\n            break;\n#endif\n          }\n          SET_INT_VALUE(regs_a[0], z);\n        }\n        break;\n#ifndef MRB_WITHOUT_FLOAT\n      case MRB_TT_FLOAT:\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          SET_FLOAT_VALUE(mrb, regs[a], x - GETARG_C(i));\n        }\n#else\n        mrb_float(regs_a[0]) -= GETARG_C(i);\n#endif\n        break;\n#endif\n      default:\n        SET_INT_VALUE(regs_a[1], GETARG_C(i));\n        i = MKOP_ABC(OP_SEND, a, GETARG_B(i), 1);\n        goto L_SEND;\n      }\n      NEXT;\n    }\n\n#define OP_CMP_BODY(op,v1,v2) (v1(regs[a]) op v2(regs[a+1]))\n\n#ifdef MRB_WITHOUT_FLOAT\n#define OP_CMP(op) do {\\\n  int result;\\\n  /* need to check if - is overridden */\\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\\\n  case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_fixnum);\\\n    break;\\\n  default:\\\n    goto L_SEND;\\\n  }\\\n  if (result) {\\\n    SET_TRUE_VALUE(regs[a]);\\\n  }\\\n  else {\\\n    SET_FALSE_VALUE(regs[a]);\\\n  }\\\n} while(0)\n#else\n#define OP_CMP(op) do {\\\n  int result;\\\n  /* need to check if - is overridden */\\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\\\n  case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_fixnum);\\\n    break;\\\n  case TYPES2(MRB_TT_FIXNUM,MRB_TT_FLOAT):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_float);\\\n    break;\\\n  case TYPES2(MRB_TT_FLOAT,MRB_TT_FIXNUM):\\\n    result = OP_CMP_BODY(op,mrb_float,mrb_fixnum);\\\n    break;\\\n  case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\\\n    result = OP_CMP_BODY(op,mrb_float,mrb_float);\\\n    break;\\\n  default:\\\n    goto L_SEND;\\\n  }\\\n  if (result) {\\\n    SET_TRUE_VALUE(regs[a]);\\\n  }\\\n  else {\\\n    SET_FALSE_VALUE(regs[a]);\\\n  }\\\n} while(0)\n#endif\n\n    CASE(OP_EQ) {\n      /* A B C  R(A) := R(A)==R(A+1) (Syms[B]=:==,C=1)*/\n      int a = GETARG_A(i);\n      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {\n        SET_TRUE_VALUE(regs[a]);\n      }\n      else {\n        OP_CMP(==);\n      }\n      NEXT;\n    }\n\n    CASE(OP_LT) {\n      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/\n      int a = GETARG_A(i);\n      OP_CMP(<);\n      NEXT;\n    }\n\n    CASE(OP_LE) {\n      /* A B C  R(A) := R(A)<=R(A+1) (Syms[B]=:<=,C=1)*/\n      int a = GETARG_A(i);\n      OP_CMP(<=);\n      NEXT;\n    }\n\n    CASE(OP_GT) {\n      /* A B C  R(A) := R(A)>R(A+1) (Syms[B]=:>,C=1)*/\n      int a = GETARG_A(i);\n      OP_CMP(>);\n      NEXT;\n    }\n\n    CASE(OP_GE) {\n      /* A B C  R(A) := R(A)>=R(A+1) (Syms[B]=:>=,C=1)*/\n      int a = GETARG_A(i);\n      OP_CMP(>=);\n      NEXT;\n    }\n\n    CASE(OP_ARRAY) {\n      /* A B C          R(A) := ary_new(R(B),R(B+1)..R(B+C)) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n      mrb_value v = mrb_ary_new_from_values(mrb, c, &regs[b]);\n      regs[a] = v;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ARYCAT) {\n      /* A B            mrb_ary_concat(R(A),R(B)) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      mrb_value splat = mrb_ary_splat(mrb, regs[b]);\n      mrb_ary_concat(mrb, regs[a], splat);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ARYPUSH) {\n      /* A B            R(A).push(R(B)) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      mrb_ary_push(mrb, regs[a], regs[b]);\n      NEXT;\n    }\n\n    CASE(OP_AREF) {\n      /* A B C          R(A) := R(B)[C] */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n      mrb_value v = regs[b];\n\n      if (!mrb_array_p(v)) {\n        if (c == 0) {\n          regs[a] = v;\n        }\n        else {\n          SET_NIL_VALUE(regs[a]);\n        }\n      }\n      else {\n        v = mrb_ary_ref(mrb, v, c);\n        regs[a] = v;\n      }\n      NEXT;\n    }\n\n    CASE(OP_ASET) {\n      /* A B C          R(B)[C] := R(A) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n      mrb_ary_set(mrb, regs[b], c, regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_APOST) {\n      /* A B C  *R(A),R(A+1)..R(A+C) := R(A) */\n      int a = GETARG_A(i);\n      mrb_value v = regs[a];\n      int pre  = GETARG_B(i);\n      int post = GETARG_C(i);\n      struct RArray *ary;\n      int len, idx;\n\n      if (!mrb_array_p(v)) {\n        v = mrb_ary_new_from_values(mrb, 1, &regs[a]);\n      }\n      ary = mrb_ary_ptr(v);\n      len = (int)ARY_LEN(ary);\n      if (len > pre + post) {\n        v = mrb_ary_new_from_values(mrb, len - pre - post, ARY_PTR(ary)+pre);\n        regs[a++] = v;\n        while (post--) {\n          regs[a++] = ARY_PTR(ary)[len-post-1];\n        }\n      }\n      else {\n        v = mrb_ary_new_capa(mrb, 0);\n        regs[a++] = v;\n        for (idx=0; idx+pre<len; idx++) {\n          regs[a+idx] = ARY_PTR(ary)[pre+idx];\n        }\n        while (idx < post) {\n          SET_NIL_VALUE(regs[a+idx]);\n          idx++;\n        }\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_STRING) {\n      /* A Bx           R(A) := str_new(Lit(Bx)) */\n      mrb_int a = GETARG_A(i);\n      mrb_int bx = GETARG_Bx(i);\n      mrb_value str = mrb_str_dup(mrb, pool[bx]);\n\n      regs[a] = str;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_STRCAT) {\n      /* A B    R(A).concat(R(B)) */\n      mrb_int a = GETARG_A(i);\n      mrb_int b = GETARG_B(i);\n\n      mrb_str_concat(mrb, regs[a], regs[b]);\n      NEXT;\n    }\n\n    CASE(OP_HASH) {\n      /* A B C   R(A) := hash_new(R(B),R(B+1)..R(B+C)) */\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n      int lim = b+c*2;\n      mrb_value hash = mrb_hash_new_capa(mrb, c);\n\n      while (b < lim) {\n        mrb_hash_set(mrb, hash, regs[b], regs[b+1]);\n        b+=2;\n      }\n      regs[GETARG_A(i)] = hash;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_LAMBDA) {\n      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */\n      struct RProc *p;\n      int a = GETARG_A(i);\n      int b = GETARG_b(i);\n      int c = GETARG_c(i);\n      mrb_irep *nirep = irep->reps[b];\n\n      if (c & OP_L_CAPTURE) {\n        p = mrb_closure_new(mrb, nirep);\n      }\n      else {\n        p = mrb_proc_new(mrb, nirep);\n        p->flags |= MRB_PROC_SCOPE;\n      }\n      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;\n      regs[a] = mrb_obj_value(p);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_OCLASS) {\n      /* A      R(A) := ::Object */\n      regs[GETARG_A(i)] = mrb_obj_value(mrb->object_class);\n      NEXT;\n    }\n\n    CASE(OP_CLASS) {\n      /* A B    R(A) := newclass(R(A),Syms(B),R(A+1)) */\n      struct RClass *c = 0, *baseclass;\n      int a = GETARG_A(i);\n      mrb_value base, super;\n      mrb_sym id = syms[GETARG_B(i)];\n\n      base = regs[a];\n      super = regs[a+1];\n      if (mrb_nil_p(base)) {\n        baseclass = MRB_PROC_TARGET_CLASS(mrb->c->ci->proc);\n        base = mrb_obj_value(baseclass);\n      }\n      c = mrb_vm_define_class(mrb, base, super, id);\n      regs[a] = mrb_obj_value(c);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_MODULE) {\n      /* A B            R(A) := newmodule(R(A),Syms(B)) */\n      struct RClass *c = 0, *baseclass;\n      int a = GETARG_A(i);\n      mrb_value base;\n      mrb_sym id = syms[GETARG_B(i)];\n\n      base = regs[a];\n      if (mrb_nil_p(base)) {\n        baseclass = MRB_PROC_TARGET_CLASS(mrb->c->ci->proc);\n        base = mrb_obj_value(baseclass);\n      }\n      c = mrb_vm_define_module(mrb, base, id);\n      regs[a] = mrb_obj_value(c);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_EXEC) {\n      /* A Bx   R(A) := blockexec(R(A),SEQ[Bx]) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_callinfo *ci;\n      mrb_value recv = regs[a];\n      struct RProc *p;\n      mrb_irep *nirep = irep->reps[bx];\n\n      /* prepare closure */\n      p = mrb_proc_new(mrb, nirep);\n      p->c = NULL;\n      mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)proc);\n      MRB_PROC_SET_TARGET_CLASS(p, mrb_class_ptr(recv));\n      p->flags |= MRB_PROC_SCOPE;\n\n      /* prepare call stack */\n      ci = cipush(mrb);\n      ci->pc = pc + 1;\n      ci->acc = a;\n      ci->mid = 0;\n      ci->stackent = mrb->c->stack;\n      ci->argc = 0;\n      ci->target_class = mrb_class_ptr(recv);\n\n      /* prepare stack */\n      mrb->c->stack += a;\n\n      /* setup block to call */\n      ci->proc = p;\n\n      irep = p->body.irep;\n      pool = irep->pool;\n      syms = irep->syms;\n      ci->nregs = irep->nregs;\n      stack_extend(mrb, ci->nregs);\n      stack_clear(regs+1, ci->nregs-1);\n      pc = irep->iseq;\n      JUMP;\n    }\n\n    CASE(OP_METHOD) {\n      /* A B            R(A).newmethod(Syms(B),R(A+1)) */\n      int a = GETARG_A(i);\n      struct RClass *c = mrb_class_ptr(regs[a]);\n      struct RProc *p = mrb_proc_ptr(regs[a+1]);\n      mrb_method_t m;\n\n      MRB_METHOD_FROM_PROC(m, p);\n      mrb_define_method_raw(mrb, c, syms[GETARG_B(i)], m);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_SCLASS) {\n      /* A B    R(A) := R(B).singleton_class */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n\n      regs[a] = mrb_singleton_class(mrb, regs[b]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_TCLASS) {\n      /* A      R(A) := target_class */\n      if (!mrb->c->ci->target_class) {\n        mrb_value exc = mrb_exc_new_str_lit(mrb, E_TYPE_ERROR, \"no target class or module\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      regs[GETARG_A(i)] = mrb_obj_value(mrb->c->ci->target_class);\n      NEXT;\n    }\n\n    CASE(OP_RANGE) {\n      /* A B C  R(A) := range_new(R(B),R(B+1),C) */\n      int b = GETARG_B(i);\n      mrb_value val = mrb_range_new(mrb, regs[b], regs[b+1], GETARG_C(i));\n      regs[GETARG_A(i)] = val;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_DEBUG) {\n      /* A B C    debug print R(A),R(B),R(C) */\n#ifdef MRB_ENABLE_DEBUG_HOOK\n      mrb->debug_op_hook(mrb, irep, pc, regs);\n#else\n#ifndef MRB_DISABLE_STDIO\n      printf(\"OP_DEBUG %d %d %d\\n\", GETARG_A(i), GETARG_B(i), GETARG_C(i));\n#else\n      abort();\n#endif\n#endif\n      NEXT;\n    }\n\n    CASE(OP_STOP) {\n      /*        stop VM */\n    L_STOP:\n      while (mrb->c->eidx > 0) {\n        ecall(mrb);\n      }\n      ERR_PC_CLR(mrb);\n      mrb->jmp = prev_jmp;\n      if (mrb->exc) {\n        return mrb_obj_value(mrb->exc);\n      }\n      return regs[irep->nlocals];\n    }\n\n    CASE(OP_ERR) {\n      /* Bx     raise RuntimeError with message Lit(Bx) */\n      mrb_value msg = mrb_str_dup(mrb, pool[GETARG_Bx(i)]);\n      mrb_value exc;\n\n      if (GETARG_A(i) == 0) {\n        exc = mrb_exc_new_str(mrb, E_RUNTIME_ERROR, msg);\n      }\n      else {\n        exc = mrb_exc_new_str(mrb, E_LOCALJUMP_ERROR, msg);\n      }\n      ERR_PC_SET(mrb, pc);\n      mrb_exc_set(mrb, exc);\n      goto L_RAISE;\n    }\n  }\n  END_DISPATCH;\n#undef regs\n\n  }\n  MRB_CATCH(&c_jmp) {\n    exc_catched = TRUE;\n    goto RETRY_TRY_BLOCK;\n  }\n  MRB_END_EXC(&c_jmp);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143042,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static BOOL gdi_Bitmap_Decompress(rdpContext* context, rdpBitmap* bitmap,\n                                  const BYTE* pSrcData, UINT32 DstWidth, UINT32 DstHeight,\n                                  UINT32 bpp, UINT32 length, BOOL compressed,\n                                  UINT32 codecId)\n {\n \tUINT32 SrcSize = length;\n \trdpGdi* gdi = context->gdi;\n \tbitmap->compressed = FALSE;\n \tbitmap->format = gdi->dstFormat;\n\tbitmap->length = DstWidth * DstHeight * GetBytesPerPixel(bitmap->format);\n \tbitmap->data = (BYTE*) _aligned_malloc(bitmap->length, 16);\n \n \tif (!bitmap->data)\n\t\treturn FALSE;\n\n\tif (compressed)\n\t{\n\t\tif (bpp < 32)\n\t\t{\n\t\t\tif (!interleaved_decompress(context->codecs->interleaved,\n\t\t\t                            pSrcData, SrcSize,\n\t\t\t                            DstWidth, DstHeight,\n\t\t\t                            bpp,\n\t\t\t                            bitmap->data, bitmap->format,\n\t\t\t                            0, 0, 0, DstWidth, DstHeight,\n\t\t\t                            &gdi->palette))\n\t\t\t\treturn FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!planar_decompress(context->codecs->planar, pSrcData, SrcSize,\n\t\t\t                       DstWidth, DstHeight,\n\t\t\t                       bitmap->data, bitmap->format, 0, 0, 0,\n\t\t\t                       DstWidth, DstHeight, TRUE))\n\t\t\t\treturn FALSE;\n\t\t}\n\t}\n\telse\n\t{\n\t\tconst UINT32 SrcFormat = gdi_get_pixel_format(bpp);\n\t\tconst size_t sbpp = GetBytesPerPixel(SrcFormat);\n\t\tconst size_t dbpp = GetBytesPerPixel(bitmap->format);\n\n\t\tif ((sbpp == 0) || (dbpp == 0))\n\t\t\treturn FALSE;\n\t\telse\n\t\t{\n\t\t\tconst size_t dstSize = SrcSize * dbpp / sbpp;\n\n\t\t\tif (dstSize  < bitmap->length)\n\t\t\t\treturn FALSE;\n\t\t}\n\n\t\tif (!freerdp_image_copy(bitmap->data, bitmap->format, 0, 0, 0,\n\t\t                        DstWidth, DstHeight, pSrcData, SrcFormat,\n\t\t                        0, 0, 0, &gdi->palette, FREERDP_FLIP_VERTICAL))\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143059,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static BOOL gdi_Bitmap_Decompress(rdpContext* context, rdpBitmap* bitmap,\n                                  const BYTE* pSrcData, UINT32 DstWidth, UINT32 DstHeight,\n                                  UINT32 bpp, UINT32 length, BOOL compressed,\n                                  UINT32 codecId)\n {\n \tUINT32 SrcSize = length;\n \trdpGdi* gdi = context->gdi;\n\tUINT32 size = DstWidth * DstHeight;\n \tbitmap->compressed = FALSE;\n \tbitmap->format = gdi->dstFormat;\n\n\tif ((GetBytesPerPixel(bitmap->format) == 0) ||\n\t    (DstWidth == 0) || (DstHeight == 0) || (DstWidth > UINT32_MAX / DstHeight) ||\n\t    (size > (UINT32_MAX / GetBytesPerPixel(bitmap->format))))\n\t\treturn FALSE;\n\n\tsize *= GetBytesPerPixel(bitmap->format);\n\tbitmap->length = size;\n \tbitmap->data = (BYTE*) _aligned_malloc(bitmap->length, 16);\n \n \tif (!bitmap->data)\n\t\treturn FALSE;\n\n\tif (compressed)\n\t{\n\t\tif (bpp < 32)\n\t\t{\n\t\t\tif (!interleaved_decompress(context->codecs->interleaved,\n\t\t\t                            pSrcData, SrcSize,\n\t\t\t                            DstWidth, DstHeight,\n\t\t\t                            bpp,\n\t\t\t                            bitmap->data, bitmap->format,\n\t\t\t                            0, 0, 0, DstWidth, DstHeight,\n\t\t\t                            &gdi->palette))\n\t\t\t\treturn FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!planar_decompress(context->codecs->planar, pSrcData, SrcSize,\n\t\t\t                       DstWidth, DstHeight,\n\t\t\t                       bitmap->data, bitmap->format, 0, 0, 0,\n\t\t\t                       DstWidth, DstHeight, TRUE))\n\t\t\t\treturn FALSE;\n\t\t}\n\t}\n\telse\n\t{\n\t\tconst UINT32 SrcFormat = gdi_get_pixel_format(bpp);\n\t\tconst size_t sbpp = GetBytesPerPixel(SrcFormat);\n\t\tconst size_t dbpp = GetBytesPerPixel(bitmap->format);\n\n\t\tif ((sbpp == 0) || (dbpp == 0))\n\t\t\treturn FALSE;\n\t\telse\n\t\t{\n\t\t\tconst size_t dstSize = SrcSize * dbpp / sbpp;\n\n\t\t\tif (dstSize  < bitmap->length)\n\t\t\t\treturn FALSE;\n\t\t}\n\n\t\tif (!freerdp_image_copy(bitmap->data, bitmap->format, 0, 0, 0,\n\t\t                        DstWidth, DstHeight, pSrcData, SrcFormat,\n\t\t                        0, 0, 0, &gdi->palette, FREERDP_FLIP_VERTICAL))\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143060,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static int futex_requeue(u32 __user *uaddr1, unsigned int flags,\n\t\t\t u32 __user *uaddr2, int nr_wake, int nr_requeue,\n\t\t\t u32 *cmpval, int requeue_pi)\n{\n\tunion futex_key key1 = FUTEX_KEY_INIT, key2 = FUTEX_KEY_INIT;\n\tint drop_count = 0, task_count = 0, ret;\n\tstruct futex_pi_state *pi_state = NULL;\n\tstruct futex_hash_bucket *hb1, *hb2;\n \tstruct futex_q *this, *next;\n \tDEFINE_WAKE_Q(wake_q);\n \n \t/*\n \t * When PI not supported: return -ENOSYS if requeue_pi is true,\n \t * consequently the compiler knows requeue_pi is always false past\n\t * this point which will optimize away all the conditional code\n\t * further down.\n\t */\n\tif (!IS_ENABLED(CONFIG_FUTEX_PI) && requeue_pi)\n\t\treturn -ENOSYS;\n\n\tif (requeue_pi) {\n\t\t/*\n\t\t * Requeue PI only works on two distinct uaddrs. This\n\t\t * check is only valid for private futexes. See below.\n\t\t */\n\t\tif (uaddr1 == uaddr2)\n\t\t\treturn -EINVAL;\n\n\t\t/*\n\t\t * requeue_pi requires a pi_state, try to allocate it now\n\t\t * without any locks in case it fails.\n\t\t */\n\t\tif (refill_pi_state_cache())\n\t\t\treturn -ENOMEM;\n\t\t/*\n\t\t * requeue_pi must wake as many tasks as it can, up to nr_wake\n\t\t * + nr_requeue, since it acquires the rt_mutex prior to\n\t\t * returning to userspace, so as to not leave the rt_mutex with\n\t\t * waiters and no owner.  However, second and third wake-ups\n\t\t * cannot be predicted as they involve race conditions with the\n\t\t * first wake and a fault while looking up the pi_state.  Both\n\t\t * pthread_cond_signal() and pthread_cond_broadcast() should\n\t\t * use nr_wake=1.\n\t\t */\n\t\tif (nr_wake != 1)\n\t\t\treturn -EINVAL;\n\t}\n\nretry:\n\tret = get_futex_key(uaddr1, flags & FLAGS_SHARED, &key1, VERIFY_READ);\n\tif (unlikely(ret != 0))\n\t\tgoto out;\n\tret = get_futex_key(uaddr2, flags & FLAGS_SHARED, &key2,\n\t\t\t    requeue_pi ? VERIFY_WRITE : VERIFY_READ);\n\tif (unlikely(ret != 0))\n\t\tgoto out_put_key1;\n\n\t/*\n\t * The check above which compares uaddrs is not sufficient for\n\t * shared futexes. We need to compare the keys:\n\t */\n\tif (requeue_pi && match_futex(&key1, &key2)) {\n\t\tret = -EINVAL;\n\t\tgoto out_put_keys;\n\t}\n\n\thb1 = hash_futex(&key1);\n\thb2 = hash_futex(&key2);\n\nretry_private:\n\thb_waiters_inc(hb2);\n\tdouble_lock_hb(hb1, hb2);\n\n\tif (likely(cmpval != NULL)) {\n\t\tu32 curval;\n\n\t\tret = get_futex_value_locked(&curval, uaddr1);\n\n\t\tif (unlikely(ret)) {\n\t\t\tdouble_unlock_hb(hb1, hb2);\n\t\t\thb_waiters_dec(hb2);\n\n\t\t\tret = get_user(curval, uaddr1);\n\t\t\tif (ret)\n\t\t\t\tgoto out_put_keys;\n\n\t\t\tif (!(flags & FLAGS_SHARED))\n\t\t\t\tgoto retry_private;\n\n\t\t\tput_futex_key(&key2);\n\t\t\tput_futex_key(&key1);\n\t\t\tgoto retry;\n\t\t}\n\t\tif (curval != *cmpval) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tif (requeue_pi && (task_count - nr_wake < nr_requeue)) {\n\t\t/*\n\t\t * Attempt to acquire uaddr2 and wake the top waiter. If we\n\t\t * intend to requeue waiters, force setting the FUTEX_WAITERS\n\t\t * bit.  We force this here where we are able to easily handle\n\t\t * faults rather in the requeue loop below.\n\t\t */\n\t\tret = futex_proxy_trylock_atomic(uaddr2, hb1, hb2, &key1,\n\t\t\t\t\t\t &key2, &pi_state, nr_requeue);\n\n\t\t/*\n\t\t * At this point the top_waiter has either taken uaddr2 or is\n\t\t * waiting on it.  If the former, then the pi_state will not\n\t\t * exist yet, look it up one more time to ensure we have a\n\t\t * reference to it. If the lock was taken, ret contains the\n\t\t * vpid of the top waiter task.\n\t\t * If the lock was not taken, we have pi_state and an initial\n\t\t * refcount on it. In case of an error we have nothing.\n\t\t */\n\t\tif (ret > 0) {\n\t\t\tWARN_ON(pi_state);\n\t\t\tdrop_count++;\n\t\t\ttask_count++;\n\t\t\t/*\n\t\t\t * If we acquired the lock, then the user space value\n\t\t\t * of uaddr2 should be vpid. It cannot be changed by\n\t\t\t * the top waiter as it is blocked on hb2 lock if it\n\t\t\t * tries to do so. If something fiddled with it behind\n\t\t\t * our back the pi state lookup might unearth it. So\n\t\t\t * we rather use the known value than rereading and\n\t\t\t * handing potential crap to lookup_pi_state.\n\t\t\t *\n\t\t\t * If that call succeeds then we have pi_state and an\n\t\t\t * initial refcount on it.\n\t\t\t */\n\t\t\tret = lookup_pi_state(uaddr2, ret, hb2, &key2, &pi_state);\n\t\t}\n\n\t\tswitch (ret) {\n\t\tcase 0:\n\t\t\t/* We hold a reference on the pi state. */\n\t\t\tbreak;\n\n\t\t\t/* If the above failed, then pi_state is NULL */\n\t\tcase -EFAULT:\n\t\t\tdouble_unlock_hb(hb1, hb2);\n\t\t\thb_waiters_dec(hb2);\n\t\t\tput_futex_key(&key2);\n\t\t\tput_futex_key(&key1);\n\t\t\tret = fault_in_user_writeable(uaddr2);\n\t\t\tif (!ret)\n\t\t\t\tgoto retry;\n\t\t\tgoto out;\n\t\tcase -EAGAIN:\n\t\t\t/*\n\t\t\t * Two reasons for this:\n\t\t\t * - Owner is exiting and we just wait for the\n\t\t\t *   exit to complete.\n\t\t\t * - The user space value changed.\n\t\t\t */\n\t\t\tdouble_unlock_hb(hb1, hb2);\n\t\t\thb_waiters_dec(hb2);\n\t\t\tput_futex_key(&key2);\n\t\t\tput_futex_key(&key1);\n\t\t\tcond_resched();\n\t\t\tgoto retry;\n\t\tdefault:\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tplist_for_each_entry_safe(this, next, &hb1->chain, list) {\n\t\tif (task_count - nr_wake >= nr_requeue)\n\t\t\tbreak;\n\n\t\tif (!match_futex(&this->key, &key1))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * FUTEX_WAIT_REQEUE_PI and FUTEX_CMP_REQUEUE_PI should always\n\t\t * be paired with each other and no other futex ops.\n\t\t *\n\t\t * We should never be requeueing a futex_q with a pi_state,\n\t\t * which is awaiting a futex_unlock_pi().\n\t\t */\n\t\tif ((requeue_pi && !this->rt_waiter) ||\n\t\t    (!requeue_pi && this->rt_waiter) ||\n\t\t    this->pi_state) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Wake nr_wake waiters.  For requeue_pi, if we acquired the\n\t\t * lock, we already woke the top_waiter.  If not, it will be\n\t\t * woken by futex_unlock_pi().\n\t\t */\n\t\tif (++task_count <= nr_wake && !requeue_pi) {\n\t\t\tmark_wake_futex(&wake_q, this);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Ensure we requeue to the expected futex for requeue_pi. */\n\t\tif (requeue_pi && !match_futex(this->requeue_pi_key, &key2)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Requeue nr_requeue waiters and possibly one more in the case\n\t\t * of requeue_pi if we couldn't acquire the lock atomically.\n\t\t */\n\t\tif (requeue_pi) {\n\t\t\t/*\n\t\t\t * Prepare the waiter to take the rt_mutex. Take a\n\t\t\t * refcount on the pi_state and store the pointer in\n\t\t\t * the futex_q object of the waiter.\n\t\t\t */\n\t\t\tget_pi_state(pi_state);\n\t\t\tthis->pi_state = pi_state;\n\t\t\tret = rt_mutex_start_proxy_lock(&pi_state->pi_mutex,\n\t\t\t\t\t\t\tthis->rt_waiter,\n\t\t\t\t\t\t\tthis->task);\n\t\t\tif (ret == 1) {\n\t\t\t\t/*\n\t\t\t\t * We got the lock. We do neither drop the\n\t\t\t\t * refcount on pi_state nor clear\n\t\t\t\t * this->pi_state because the waiter needs the\n\t\t\t\t * pi_state for cleaning up the user space\n\t\t\t\t * value. It will drop the refcount after\n\t\t\t\t * doing so.\n\t\t\t\t */\n\t\t\t\trequeue_pi_wake_futex(this, &key2, hb2);\n\t\t\t\tdrop_count++;\n\t\t\t\tcontinue;\n\t\t\t} else if (ret) {\n\t\t\t\t/*\n\t\t\t\t * rt_mutex_start_proxy_lock() detected a\n\t\t\t\t * potential deadlock when we tried to queue\n\t\t\t\t * that waiter. Drop the pi_state reference\n\t\t\t\t * which we took above and remove the pointer\n\t\t\t\t * to the state from the waiters futex_q\n\t\t\t\t * object.\n\t\t\t\t */\n\t\t\t\tthis->pi_state = NULL;\n\t\t\t\tput_pi_state(pi_state);\n\t\t\t\t/*\n\t\t\t\t * We stop queueing more waiters and let user\n\t\t\t\t * space deal with the mess.\n\t\t\t\t */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trequeue_futex(this, hb1, hb2, &key2);\n\t\tdrop_count++;\n\t}\n\n\t/*\n\t * We took an extra initial reference to the pi_state either\n\t * in futex_proxy_trylock_atomic() or in lookup_pi_state(). We\n\t * need to drop it here again.\n\t */\n\tput_pi_state(pi_state);\n\nout_unlock:\n\tdouble_unlock_hb(hb1, hb2);\n\twake_up_q(&wake_q);\n\thb_waiters_dec(hb2);\n\n\t/*\n\t * drop_futex_key_refs() must be called outside the spinlocks. During\n\t * the requeue we moved futex_q's from the hash bucket at key1 to the\n\t * one at key2 and updated their key pointer.  We no longer need to\n\t * hold the references to key1.\n\t */\n\twhile (--drop_count >= 0)\n\t\tdrop_futex_key_refs(&key1);\n\nout_put_keys:\n\tput_futex_key(&key2);\nout_put_key1:\n\tput_futex_key(&key1);\nout:\n\treturn ret ? ret : task_count;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143081,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static int futex_requeue(u32 __user *uaddr1, unsigned int flags,\n\t\t\t u32 __user *uaddr2, int nr_wake, int nr_requeue,\n\t\t\t u32 *cmpval, int requeue_pi)\n{\n\tunion futex_key key1 = FUTEX_KEY_INIT, key2 = FUTEX_KEY_INIT;\n\tint drop_count = 0, task_count = 0, ret;\n\tstruct futex_pi_state *pi_state = NULL;\n\tstruct futex_hash_bucket *hb1, *hb2;\n \tstruct futex_q *this, *next;\n \tDEFINE_WAKE_Q(wake_q);\n \n\tif (nr_wake < 0 || nr_requeue < 0)\n\t\treturn -EINVAL;\n\n \t/*\n \t * When PI not supported: return -ENOSYS if requeue_pi is true,\n \t * consequently the compiler knows requeue_pi is always false past\n\t * this point which will optimize away all the conditional code\n\t * further down.\n\t */\n\tif (!IS_ENABLED(CONFIG_FUTEX_PI) && requeue_pi)\n\t\treturn -ENOSYS;\n\n\tif (requeue_pi) {\n\t\t/*\n\t\t * Requeue PI only works on two distinct uaddrs. This\n\t\t * check is only valid for private futexes. See below.\n\t\t */\n\t\tif (uaddr1 == uaddr2)\n\t\t\treturn -EINVAL;\n\n\t\t/*\n\t\t * requeue_pi requires a pi_state, try to allocate it now\n\t\t * without any locks in case it fails.\n\t\t */\n\t\tif (refill_pi_state_cache())\n\t\t\treturn -ENOMEM;\n\t\t/*\n\t\t * requeue_pi must wake as many tasks as it can, up to nr_wake\n\t\t * + nr_requeue, since it acquires the rt_mutex prior to\n\t\t * returning to userspace, so as to not leave the rt_mutex with\n\t\t * waiters and no owner.  However, second and third wake-ups\n\t\t * cannot be predicted as they involve race conditions with the\n\t\t * first wake and a fault while looking up the pi_state.  Both\n\t\t * pthread_cond_signal() and pthread_cond_broadcast() should\n\t\t * use nr_wake=1.\n\t\t */\n\t\tif (nr_wake != 1)\n\t\t\treturn -EINVAL;\n\t}\n\nretry:\n\tret = get_futex_key(uaddr1, flags & FLAGS_SHARED, &key1, VERIFY_READ);\n\tif (unlikely(ret != 0))\n\t\tgoto out;\n\tret = get_futex_key(uaddr2, flags & FLAGS_SHARED, &key2,\n\t\t\t    requeue_pi ? VERIFY_WRITE : VERIFY_READ);\n\tif (unlikely(ret != 0))\n\t\tgoto out_put_key1;\n\n\t/*\n\t * The check above which compares uaddrs is not sufficient for\n\t * shared futexes. We need to compare the keys:\n\t */\n\tif (requeue_pi && match_futex(&key1, &key2)) {\n\t\tret = -EINVAL;\n\t\tgoto out_put_keys;\n\t}\n\n\thb1 = hash_futex(&key1);\n\thb2 = hash_futex(&key2);\n\nretry_private:\n\thb_waiters_inc(hb2);\n\tdouble_lock_hb(hb1, hb2);\n\n\tif (likely(cmpval != NULL)) {\n\t\tu32 curval;\n\n\t\tret = get_futex_value_locked(&curval, uaddr1);\n\n\t\tif (unlikely(ret)) {\n\t\t\tdouble_unlock_hb(hb1, hb2);\n\t\t\thb_waiters_dec(hb2);\n\n\t\t\tret = get_user(curval, uaddr1);\n\t\t\tif (ret)\n\t\t\t\tgoto out_put_keys;\n\n\t\t\tif (!(flags & FLAGS_SHARED))\n\t\t\t\tgoto retry_private;\n\n\t\t\tput_futex_key(&key2);\n\t\t\tput_futex_key(&key1);\n\t\t\tgoto retry;\n\t\t}\n\t\tif (curval != *cmpval) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tif (requeue_pi && (task_count - nr_wake < nr_requeue)) {\n\t\t/*\n\t\t * Attempt to acquire uaddr2 and wake the top waiter. If we\n\t\t * intend to requeue waiters, force setting the FUTEX_WAITERS\n\t\t * bit.  We force this here where we are able to easily handle\n\t\t * faults rather in the requeue loop below.\n\t\t */\n\t\tret = futex_proxy_trylock_atomic(uaddr2, hb1, hb2, &key1,\n\t\t\t\t\t\t &key2, &pi_state, nr_requeue);\n\n\t\t/*\n\t\t * At this point the top_waiter has either taken uaddr2 or is\n\t\t * waiting on it.  If the former, then the pi_state will not\n\t\t * exist yet, look it up one more time to ensure we have a\n\t\t * reference to it. If the lock was taken, ret contains the\n\t\t * vpid of the top waiter task.\n\t\t * If the lock was not taken, we have pi_state and an initial\n\t\t * refcount on it. In case of an error we have nothing.\n\t\t */\n\t\tif (ret > 0) {\n\t\t\tWARN_ON(pi_state);\n\t\t\tdrop_count++;\n\t\t\ttask_count++;\n\t\t\t/*\n\t\t\t * If we acquired the lock, then the user space value\n\t\t\t * of uaddr2 should be vpid. It cannot be changed by\n\t\t\t * the top waiter as it is blocked on hb2 lock if it\n\t\t\t * tries to do so. If something fiddled with it behind\n\t\t\t * our back the pi state lookup might unearth it. So\n\t\t\t * we rather use the known value than rereading and\n\t\t\t * handing potential crap to lookup_pi_state.\n\t\t\t *\n\t\t\t * If that call succeeds then we have pi_state and an\n\t\t\t * initial refcount on it.\n\t\t\t */\n\t\t\tret = lookup_pi_state(uaddr2, ret, hb2, &key2, &pi_state);\n\t\t}\n\n\t\tswitch (ret) {\n\t\tcase 0:\n\t\t\t/* We hold a reference on the pi state. */\n\t\t\tbreak;\n\n\t\t\t/* If the above failed, then pi_state is NULL */\n\t\tcase -EFAULT:\n\t\t\tdouble_unlock_hb(hb1, hb2);\n\t\t\thb_waiters_dec(hb2);\n\t\t\tput_futex_key(&key2);\n\t\t\tput_futex_key(&key1);\n\t\t\tret = fault_in_user_writeable(uaddr2);\n\t\t\tif (!ret)\n\t\t\t\tgoto retry;\n\t\t\tgoto out;\n\t\tcase -EAGAIN:\n\t\t\t/*\n\t\t\t * Two reasons for this:\n\t\t\t * - Owner is exiting and we just wait for the\n\t\t\t *   exit to complete.\n\t\t\t * - The user space value changed.\n\t\t\t */\n\t\t\tdouble_unlock_hb(hb1, hb2);\n\t\t\thb_waiters_dec(hb2);\n\t\t\tput_futex_key(&key2);\n\t\t\tput_futex_key(&key1);\n\t\t\tcond_resched();\n\t\t\tgoto retry;\n\t\tdefault:\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tplist_for_each_entry_safe(this, next, &hb1->chain, list) {\n\t\tif (task_count - nr_wake >= nr_requeue)\n\t\t\tbreak;\n\n\t\tif (!match_futex(&this->key, &key1))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * FUTEX_WAIT_REQEUE_PI and FUTEX_CMP_REQUEUE_PI should always\n\t\t * be paired with each other and no other futex ops.\n\t\t *\n\t\t * We should never be requeueing a futex_q with a pi_state,\n\t\t * which is awaiting a futex_unlock_pi().\n\t\t */\n\t\tif ((requeue_pi && !this->rt_waiter) ||\n\t\t    (!requeue_pi && this->rt_waiter) ||\n\t\t    this->pi_state) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Wake nr_wake waiters.  For requeue_pi, if we acquired the\n\t\t * lock, we already woke the top_waiter.  If not, it will be\n\t\t * woken by futex_unlock_pi().\n\t\t */\n\t\tif (++task_count <= nr_wake && !requeue_pi) {\n\t\t\tmark_wake_futex(&wake_q, this);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Ensure we requeue to the expected futex for requeue_pi. */\n\t\tif (requeue_pi && !match_futex(this->requeue_pi_key, &key2)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Requeue nr_requeue waiters and possibly one more in the case\n\t\t * of requeue_pi if we couldn't acquire the lock atomically.\n\t\t */\n\t\tif (requeue_pi) {\n\t\t\t/*\n\t\t\t * Prepare the waiter to take the rt_mutex. Take a\n\t\t\t * refcount on the pi_state and store the pointer in\n\t\t\t * the futex_q object of the waiter.\n\t\t\t */\n\t\t\tget_pi_state(pi_state);\n\t\t\tthis->pi_state = pi_state;\n\t\t\tret = rt_mutex_start_proxy_lock(&pi_state->pi_mutex,\n\t\t\t\t\t\t\tthis->rt_waiter,\n\t\t\t\t\t\t\tthis->task);\n\t\t\tif (ret == 1) {\n\t\t\t\t/*\n\t\t\t\t * We got the lock. We do neither drop the\n\t\t\t\t * refcount on pi_state nor clear\n\t\t\t\t * this->pi_state because the waiter needs the\n\t\t\t\t * pi_state for cleaning up the user space\n\t\t\t\t * value. It will drop the refcount after\n\t\t\t\t * doing so.\n\t\t\t\t */\n\t\t\t\trequeue_pi_wake_futex(this, &key2, hb2);\n\t\t\t\tdrop_count++;\n\t\t\t\tcontinue;\n\t\t\t} else if (ret) {\n\t\t\t\t/*\n\t\t\t\t * rt_mutex_start_proxy_lock() detected a\n\t\t\t\t * potential deadlock when we tried to queue\n\t\t\t\t * that waiter. Drop the pi_state reference\n\t\t\t\t * which we took above and remove the pointer\n\t\t\t\t * to the state from the waiters futex_q\n\t\t\t\t * object.\n\t\t\t\t */\n\t\t\t\tthis->pi_state = NULL;\n\t\t\t\tput_pi_state(pi_state);\n\t\t\t\t/*\n\t\t\t\t * We stop queueing more waiters and let user\n\t\t\t\t * space deal with the mess.\n\t\t\t\t */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trequeue_futex(this, hb1, hb2, &key2);\n\t\tdrop_count++;\n\t}\n\n\t/*\n\t * We took an extra initial reference to the pi_state either\n\t * in futex_proxy_trylock_atomic() or in lookup_pi_state(). We\n\t * need to drop it here again.\n\t */\n\tput_pi_state(pi_state);\n\nout_unlock:\n\tdouble_unlock_hb(hb1, hb2);\n\twake_up_q(&wake_q);\n\thb_waiters_dec(hb2);\n\n\t/*\n\t * drop_futex_key_refs() must be called outside the spinlocks. During\n\t * the requeue we moved futex_q's from the hash bucket at key1 to the\n\t * one at key2 and updated their key pointer.  We no longer need to\n\t * hold the references to key1.\n\t */\n\twhile (--drop_count >= 0)\n\t\tdrop_futex_key_refs(&key1);\n\nout_put_keys:\n\tput_futex_key(&key2);\nout_put_key1:\n\tput_futex_key(&key1);\nout:\n\treturn ret ? ret : task_count;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143082,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static int __get_data_block(struct inode *inode, sector_t iblock,\n\t\t\tstruct buffer_head *bh, int create, int flag,\n\t\t\tpgoff_t *next_pgofs)\n{\n\tstruct f2fs_map_blocks map;\n\tint err;\n\n\tmap.m_lblk = iblock;\n\tmap.m_len = bh->b_size >> inode->i_blkbits;\n\tmap.m_next_pgofs = next_pgofs;\n\n\terr = f2fs_map_blocks(inode, &map, create, flag);\n \tif (!err) {\n \t\tmap_bh(bh, inode->i_sb, map.m_pblk);\n \t\tbh->b_state = (bh->b_state & ~F2FS_MAP_FLAGS) | map.m_flags;\n\t\tbh->b_size = map.m_len << inode->i_blkbits;\n \t}\n \treturn err;\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143109,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static int __get_data_block(struct inode *inode, sector_t iblock,\n\t\t\tstruct buffer_head *bh, int create, int flag,\n\t\t\tpgoff_t *next_pgofs)\n{\n\tstruct f2fs_map_blocks map;\n\tint err;\n\n\tmap.m_lblk = iblock;\n\tmap.m_len = bh->b_size >> inode->i_blkbits;\n\tmap.m_next_pgofs = next_pgofs;\n\n\terr = f2fs_map_blocks(inode, &map, create, flag);\n \tif (!err) {\n \t\tmap_bh(bh, inode->i_sb, map.m_pblk);\n \t\tbh->b_state = (bh->b_state & ~F2FS_MAP_FLAGS) | map.m_flags;\n\t\tbh->b_size = (u64)map.m_len << inode->i_blkbits;\n \t}\n \treturn err;\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143110,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "int perf_cpu_time_max_percent_handler(struct ctl_table *table, int write,\n \t\t\t\tvoid __user *buffer, size_t *lenp,\n \t\t\t\tloff_t *ppos)\n {\n\tint ret = proc_dointvec(table, write, buffer, lenp, ppos);\n \n \tif (ret || !write)\n \t\treturn ret;\n\n\tif (sysctl_perf_cpu_time_max_percent == 100 ||\n\t    sysctl_perf_cpu_time_max_percent == 0) {\n\t\tprintk(KERN_WARNING\n\t\t       \"perf: Dynamic interrupt throttling disabled, can hang your system!\\n\");\n\t\tWRITE_ONCE(perf_sample_allowed_ns, 0);\n\t} else {\n\t\tupdate_perf_cpu_limits();\n\t}\n\n\treturn 0;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143111,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "int perf_cpu_time_max_percent_handler(struct ctl_table *table, int write,\n \t\t\t\tvoid __user *buffer, size_t *lenp,\n \t\t\t\tloff_t *ppos)\n {\n\tint ret = proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n \n \tif (ret || !write)\n \t\treturn ret;\n\n\tif (sysctl_perf_cpu_time_max_percent == 100 ||\n\t    sysctl_perf_cpu_time_max_percent == 0) {\n\t\tprintk(KERN_WARNING\n\t\t       \"perf: Dynamic interrupt throttling disabled, can hang your system!\\n\");\n\t\tWRITE_ONCE(perf_sample_allowed_ns, 0);\n\t} else {\n\t\tupdate_perf_cpu_limits();\n\t}\n\n\treturn 0;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143112,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static int ssl_parse_client_psk_identity( mbedtls_ssl_context *ssl, unsigned char **p,\n                                          const unsigned char *end )\n{\n    int ret = 0;\n    size_t n;\n\n    if( ssl->conf->f_psk == NULL &&\n        ( ssl->conf->psk == NULL || ssl->conf->psk_identity == NULL ||\n          ssl->conf->psk_identity_len == 0 || ssl->conf->psk_len == 0 ) )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"got no pre-shared key\" ) );\n        return( MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED );\n    }\n\n     /*\n      * Receive client pre-shared key identity name\n      */\n    if( *p + 2 > end )\n     {\n         MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client key exchange message\" ) );\n         return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );\n    }\n\n     n = ( (*p)[0] << 8 ) | (*p)[1];\n     *p += 2;\n \n    if( n < 1 || n > 65535 || *p + n > end )\n     {\n         MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client key exchange message\" ) );\n         return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );\n    }\n\n    if( ssl->conf->f_psk != NULL )\n    {\n        if( ssl->conf->f_psk( ssl->conf->p_psk, ssl, *p, n ) != 0 )\n            ret = MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY;\n    }\n    else\n    {\n        /* Identity is not a big secret since clients send it in the clear,\n         * but treat it carefully anyway, just in case */\n        if( n != ssl->conf->psk_identity_len ||\n            mbedtls_ssl_safer_memcmp( ssl->conf->psk_identity, *p, n ) != 0 )\n        {\n            ret = MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY;\n        }\n    }\n\n    if( ret == MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY )\n    {\n        MBEDTLS_SSL_DEBUG_BUF( 3, \"Unknown PSK identity\", *p, n );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_UNKNOWN_PSK_IDENTITY );\n        return( MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY );\n    }\n\n    *p += n;\n\n    return( 0 );\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143135,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static int ssl_parse_client_psk_identity( mbedtls_ssl_context *ssl, unsigned char **p,\n                                          const unsigned char *end )\n{\n    int ret = 0;\n    size_t n;\n\n    if( ssl->conf->f_psk == NULL &&\n        ( ssl->conf->psk == NULL || ssl->conf->psk_identity == NULL ||\n          ssl->conf->psk_identity_len == 0 || ssl->conf->psk_len == 0 ) )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"got no pre-shared key\" ) );\n        return( MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED );\n    }\n\n     /*\n      * Receive client pre-shared key identity name\n      */\n    if( end - *p < 2 )\n     {\n         MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client key exchange message\" ) );\n         return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );\n    }\n\n     n = ( (*p)[0] << 8 ) | (*p)[1];\n     *p += 2;\n \n    if( n < 1 || n > 65535 || n > (size_t) ( end - *p ) )\n     {\n         MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client key exchange message\" ) );\n         return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );\n    }\n\n    if( ssl->conf->f_psk != NULL )\n    {\n        if( ssl->conf->f_psk( ssl->conf->p_psk, ssl, *p, n ) != 0 )\n            ret = MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY;\n    }\n    else\n    {\n        /* Identity is not a big secret since clients send it in the clear,\n         * but treat it carefully anyway, just in case */\n        if( n != ssl->conf->psk_identity_len ||\n            mbedtls_ssl_safer_memcmp( ssl->conf->psk_identity, *p, n ) != 0 )\n        {\n            ret = MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY;\n        }\n    }\n\n    if( ret == MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY )\n    {\n        MBEDTLS_SSL_DEBUG_BUF( 3, \"Unknown PSK identity\", *p, n );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_UNKNOWN_PSK_IDENTITY );\n        return( MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY );\n    }\n\n    *p += n;\n\n    return( 0 );\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143136,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static void Process_ipfix_template_withdraw(exporter_ipfix_domain_t *exporter, void *DataPtr, uint32_t size_left, FlowSource_t *fs) {\nipfix_template_record_t *ipfix_template_record;\n\n \twhile ( size_left ) {\n \t\tuint32_t id;\n \n \t\tipfix_template_record = (ipfix_template_record_t *)DataPtr;\n \t\tsize_left \t\t-= 4;\n\n\t\tid \t  = ntohs(ipfix_template_record->TemplateID);\n\n\t\tif ( id == IPFIX_TEMPLATE_FLOWSET_ID ) {\n\t\t\tremove_all_translation_tables(exporter);\n\t\t\tReInitExtensionMapList(fs);\n\t\t} else {\n\t\t\tremove_translation_table(fs, exporter, id);\n\t\t}\n\n\t\tDataPtr = DataPtr + 4;\n\t\tif ( size_left < 4 ) {\n\t\t\tdbg_printf(\"Skip %u bytes padding\\n\", size_left);\n\t\t\tsize_left = 0;\n\t\t}\n\t}\n \n} // End of Process_ipfix_template_withdraw\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143211,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static void Process_ipfix_template_withdraw(exporter_ipfix_domain_t *exporter, void *DataPtr, uint32_t size_left, FlowSource_t *fs) {\nipfix_template_record_t *ipfix_template_record;\n\n \twhile ( size_left ) {\n \t\tuint32_t id;\n \n\t\tif ( size_left < 4 ) {\n\t\t\tLogError(\"Process_ipfix [%u] Template withdraw size error at %s line %u\" , \n\t\t\t\texporter->info.id, __FILE__, __LINE__, strerror (errno));\n\t\t\tsize_left = 0;\n\t\t\tcontinue;\n\t\t}\n\n\n \t\tipfix_template_record = (ipfix_template_record_t *)DataPtr;\n \t\tsize_left \t\t-= 4;\n\n\t\tid \t  = ntohs(ipfix_template_record->TemplateID);\n\n\t\tif ( id == IPFIX_TEMPLATE_FLOWSET_ID ) {\n\t\t\tremove_all_translation_tables(exporter);\n\t\t\tReInitExtensionMapList(fs);\n\t\t} else {\n\t\t\tremove_translation_table(fs, exporter, id);\n\t\t}\n\n\t\tDataPtr = DataPtr + 4;\n\t\tif ( size_left < 4 ) {\n\t\t\tdbg_printf(\"Skip %u bytes padding\\n\", size_left);\n\t\t\tsize_left = 0;\n\t\t}\n\t}\n \n} // End of Process_ipfix_template_withdraw\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143212,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static void opj_get_encoding_parameters(const opj_image_t *p_image,\n                                        const opj_cp_t *p_cp,\n                                        OPJ_UINT32 p_tileno,\n                                        OPJ_INT32 * p_tx0,\n                                        OPJ_INT32  * p_tx1,\n                                        OPJ_INT32  * p_ty0,\n                                        OPJ_INT32  * p_ty1,\n                                        OPJ_UINT32 * p_dx_min,\n                                        OPJ_UINT32 * p_dy_min,\n                                        OPJ_UINT32 * p_max_prec,\n                                        OPJ_UINT32 * p_max_res)\n{\n    /* loop */\n    OPJ_UINT32  compno, resno;\n    /* pointers */\n    const opj_tcp_t *l_tcp = 00;\n    const opj_tccp_t * l_tccp = 00;\n    const opj_image_comp_t * l_img_comp = 00;\n\n     /* position in x and y of tile */\n     OPJ_UINT32 p, q;\n \n     /* preconditions */\n     assert(p_cp != 00);\n     assert(p_image != 00);\n    assert(p_tileno < p_cp->tw * p_cp->th);\n\n    /* initializations */\n    l_tcp = &p_cp->tcps [p_tileno];\n    l_img_comp = p_image->comps;\n    l_tccp = l_tcp->tccps;\n\n    /* here calculation of tx0, tx1, ty0, ty1, maxprec, dx and dy */\n    p = p_tileno % p_cp->tw;\n     q = p_tileno / p_cp->tw;\n \n     /* find extent of tile */\n    *p_tx0 = opj_int_max((OPJ_INT32)(p_cp->tx0 + p * p_cp->tdx),\n                         (OPJ_INT32)p_image->x0);\n    *p_tx1 = opj_int_min((OPJ_INT32)(p_cp->tx0 + (p + 1) * p_cp->tdx),\n                         (OPJ_INT32)p_image->x1);\n    *p_ty0 = opj_int_max((OPJ_INT32)(p_cp->ty0 + q * p_cp->tdy),\n                         (OPJ_INT32)p_image->y0);\n    *p_ty1 = opj_int_min((OPJ_INT32)(p_cp->ty0 + (q + 1) * p_cp->tdy),\n                         (OPJ_INT32)p_image->y1);\n \n     /* max precision is 0 (can only grow) */\n     *p_max_prec = 0;\n    *p_max_res = 0;\n\n    /* take the largest value for dx_min and dy_min */\n    *p_dx_min = 0x7fffffff;\n    *p_dy_min  = 0x7fffffff;\n\n    for (compno = 0; compno < p_image->numcomps; ++compno) {\n        /* arithmetic variables to calculate */\n        OPJ_UINT32 l_level_no;\n        OPJ_INT32 l_rx0, l_ry0, l_rx1, l_ry1;\n        OPJ_INT32 l_px0, l_py0, l_px1, py1;\n        OPJ_UINT32 l_pdx, l_pdy;\n        OPJ_UINT32 l_pw, l_ph;\n        OPJ_UINT32 l_product;\n        OPJ_INT32 l_tcx0, l_tcy0, l_tcx1, l_tcy1;\n\n        l_tcx0 = opj_int_ceildiv(*p_tx0, (OPJ_INT32)l_img_comp->dx);\n        l_tcy0 = opj_int_ceildiv(*p_ty0, (OPJ_INT32)l_img_comp->dy);\n        l_tcx1 = opj_int_ceildiv(*p_tx1, (OPJ_INT32)l_img_comp->dx);\n        l_tcy1 = opj_int_ceildiv(*p_ty1, (OPJ_INT32)l_img_comp->dy);\n\n        if (l_tccp->numresolutions > *p_max_res) {\n            *p_max_res = l_tccp->numresolutions;\n        }\n\n        /* use custom size for precincts */\n        for (resno = 0; resno < l_tccp->numresolutions; ++resno) {\n            OPJ_UINT32 l_dx, l_dy;\n\n            /* precinct width and height */\n            l_pdx = l_tccp->prcw[resno];\n            l_pdy = l_tccp->prch[resno];\n\n            l_dx = l_img_comp->dx * (1u << (l_pdx + l_tccp->numresolutions - 1 - resno));\n            l_dy = l_img_comp->dy * (1u << (l_pdy + l_tccp->numresolutions - 1 - resno));\n\n            /* take the minimum size for dx for each comp and resolution */\n            *p_dx_min = opj_uint_min(*p_dx_min, l_dx);\n            *p_dy_min = opj_uint_min(*p_dy_min, l_dy);\n\n            /* various calculations of extents */\n            l_level_no = l_tccp->numresolutions - 1 - resno;\n\n            l_rx0 = opj_int_ceildivpow2(l_tcx0, (OPJ_INT32)l_level_no);\n            l_ry0 = opj_int_ceildivpow2(l_tcy0, (OPJ_INT32)l_level_no);\n            l_rx1 = opj_int_ceildivpow2(l_tcx1, (OPJ_INT32)l_level_no);\n            l_ry1 = opj_int_ceildivpow2(l_tcy1, (OPJ_INT32)l_level_no);\n\n            l_px0 = opj_int_floordivpow2(l_rx0, (OPJ_INT32)l_pdx) << l_pdx;\n            l_py0 = opj_int_floordivpow2(l_ry0, (OPJ_INT32)l_pdy) << l_pdy;\n            l_px1 = opj_int_ceildivpow2(l_rx1, (OPJ_INT32)l_pdx) << l_pdx;\n\n            py1 = opj_int_ceildivpow2(l_ry1, (OPJ_INT32)l_pdy) << l_pdy;\n\n            l_pw = (l_rx0 == l_rx1) ? 0 : (OPJ_UINT32)((l_px1 - l_px0) >> l_pdx);\n            l_ph = (l_ry0 == l_ry1) ? 0 : (OPJ_UINT32)((py1 - l_py0) >> l_pdy);\n\n            l_product = l_pw * l_ph;\n\n            /* update precision */\n            if (l_product > *p_max_prec) {\n                *p_max_prec = l_product;\n            }\n        }\n        ++l_img_comp;\n        ++l_tccp;\n    }\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143311,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static void opj_get_encoding_parameters(const opj_image_t *p_image,\n                                        const opj_cp_t *p_cp,\n                                        OPJ_UINT32 p_tileno,\n                                        OPJ_INT32 * p_tx0,\n                                        OPJ_INT32  * p_tx1,\n                                        OPJ_INT32  * p_ty0,\n                                        OPJ_INT32  * p_ty1,\n                                        OPJ_UINT32 * p_dx_min,\n                                        OPJ_UINT32 * p_dy_min,\n                                        OPJ_UINT32 * p_max_prec,\n                                        OPJ_UINT32 * p_max_res)\n{\n    /* loop */\n    OPJ_UINT32  compno, resno;\n    /* pointers */\n    const opj_tcp_t *l_tcp = 00;\n    const opj_tccp_t * l_tccp = 00;\n    const opj_image_comp_t * l_img_comp = 00;\n\n     /* position in x and y of tile */\n     OPJ_UINT32 p, q;\n \n    /* non-corrected (in regard to image offset) tile offset */\n    OPJ_UINT32 l_tx0, l_ty0;\n\n     /* preconditions */\n     assert(p_cp != 00);\n     assert(p_image != 00);\n    assert(p_tileno < p_cp->tw * p_cp->th);\n\n    /* initializations */\n    l_tcp = &p_cp->tcps [p_tileno];\n    l_img_comp = p_image->comps;\n    l_tccp = l_tcp->tccps;\n\n    /* here calculation of tx0, tx1, ty0, ty1, maxprec, dx and dy */\n    p = p_tileno % p_cp->tw;\n     q = p_tileno / p_cp->tw;\n \n     /* find extent of tile */\n    l_tx0 = p_cp->tx0 + p *\n            p_cp->tdx; /* can't be greater than p_image->x1 so won't overflow */\n    *p_tx0 = (OPJ_INT32)opj_uint_max(l_tx0, p_image->x0);\n    *p_tx1 = (OPJ_INT32)opj_uint_min(opj_uint_adds(l_tx0, p_cp->tdx), p_image->x1);\n    l_ty0 = p_cp->ty0 + q *\n            p_cp->tdy; /* can't be greater than p_image->y1 so won't overflow */\n    *p_ty0 = (OPJ_INT32)opj_uint_max(l_ty0, p_image->y0);\n    *p_ty1 = (OPJ_INT32)opj_uint_min(opj_uint_adds(l_ty0, p_cp->tdy), p_image->y1);\n \n     /* max precision is 0 (can only grow) */\n     *p_max_prec = 0;\n    *p_max_res = 0;\n\n    /* take the largest value for dx_min and dy_min */\n    *p_dx_min = 0x7fffffff;\n    *p_dy_min  = 0x7fffffff;\n\n    for (compno = 0; compno < p_image->numcomps; ++compno) {\n        /* arithmetic variables to calculate */\n        OPJ_UINT32 l_level_no;\n        OPJ_INT32 l_rx0, l_ry0, l_rx1, l_ry1;\n        OPJ_INT32 l_px0, l_py0, l_px1, py1;\n        OPJ_UINT32 l_pdx, l_pdy;\n        OPJ_UINT32 l_pw, l_ph;\n        OPJ_UINT32 l_product;\n        OPJ_INT32 l_tcx0, l_tcy0, l_tcx1, l_tcy1;\n\n        l_tcx0 = opj_int_ceildiv(*p_tx0, (OPJ_INT32)l_img_comp->dx);\n        l_tcy0 = opj_int_ceildiv(*p_ty0, (OPJ_INT32)l_img_comp->dy);\n        l_tcx1 = opj_int_ceildiv(*p_tx1, (OPJ_INT32)l_img_comp->dx);\n        l_tcy1 = opj_int_ceildiv(*p_ty1, (OPJ_INT32)l_img_comp->dy);\n\n        if (l_tccp->numresolutions > *p_max_res) {\n            *p_max_res = l_tccp->numresolutions;\n        }\n\n        /* use custom size for precincts */\n        for (resno = 0; resno < l_tccp->numresolutions; ++resno) {\n            OPJ_UINT32 l_dx, l_dy;\n\n            /* precinct width and height */\n            l_pdx = l_tccp->prcw[resno];\n            l_pdy = l_tccp->prch[resno];\n\n            l_dx = l_img_comp->dx * (1u << (l_pdx + l_tccp->numresolutions - 1 - resno));\n            l_dy = l_img_comp->dy * (1u << (l_pdy + l_tccp->numresolutions - 1 - resno));\n\n            /* take the minimum size for dx for each comp and resolution */\n            *p_dx_min = opj_uint_min(*p_dx_min, l_dx);\n            *p_dy_min = opj_uint_min(*p_dy_min, l_dy);\n\n            /* various calculations of extents */\n            l_level_no = l_tccp->numresolutions - 1 - resno;\n\n            l_rx0 = opj_int_ceildivpow2(l_tcx0, (OPJ_INT32)l_level_no);\n            l_ry0 = opj_int_ceildivpow2(l_tcy0, (OPJ_INT32)l_level_no);\n            l_rx1 = opj_int_ceildivpow2(l_tcx1, (OPJ_INT32)l_level_no);\n            l_ry1 = opj_int_ceildivpow2(l_tcy1, (OPJ_INT32)l_level_no);\n\n            l_px0 = opj_int_floordivpow2(l_rx0, (OPJ_INT32)l_pdx) << l_pdx;\n            l_py0 = opj_int_floordivpow2(l_ry0, (OPJ_INT32)l_pdy) << l_pdy;\n            l_px1 = opj_int_ceildivpow2(l_rx1, (OPJ_INT32)l_pdx) << l_pdx;\n\n            py1 = opj_int_ceildivpow2(l_ry1, (OPJ_INT32)l_pdy) << l_pdy;\n\n            l_pw = (l_rx0 == l_rx1) ? 0 : (OPJ_UINT32)((l_px1 - l_px0) >> l_pdx);\n            l_ph = (l_ry0 == l_ry1) ? 0 : (OPJ_UINT32)((py1 - l_py0) >> l_pdy);\n\n            l_product = l_pw * l_ph;\n\n            /* update precision */\n            if (l_product > *p_max_prec) {\n                *p_max_prec = l_product;\n            }\n        }\n        ++l_img_comp;\n        ++l_tccp;\n    }\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143312,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "void gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quantization)\n{\n\tuint8_t *argb;\n\tint x, y;\n\tuint8_t *p;\n\tuint8_t *out;\n\tsize_t out_size;\n\n\tif (im == NULL) {\n\t\treturn;\n\t}\n\n\tif (!gdImageTrueColor(im)) {\n\t\tzend_error(E_ERROR, \"Paletter image not supported by webp\");\n\t\treturn;\n\t}\n\n\tif (quantization == -1) {\n \t\tquantization = 80;\n \t}\n \n \targb = (uint8_t *)gdMalloc(gdImageSX(im) * 4 * gdImageSY(im));\n \tif (!argb) {\n \t\treturn;\n\t}\n\tp = argb;\n\tfor (y = 0; y < gdImageSY(im); y++) {\n\t\tfor (x = 0; x < gdImageSX(im); x++) {\n\t\t\tregister int c;\n\t\t\tregister char a;\n\t\t\tc = im->tpixels[y][x];\n\t\t\ta = gdTrueColorGetAlpha(c);\n\t\t\tif (a == 127) {\n\t\t\t\ta = 0;\n\t\t\t} else {\n\t\t\t\ta = 255 - ((a << 1) + (a >> 6));\n\t\t\t}\n\t\t\t*(p++) = gdTrueColorGetRed(c);\n\t\t\t*(p++) = gdTrueColorGetGreen(c);\n\t\t\t*(p++) = gdTrueColorGetBlue(c); \n\t\t\t*(p++) = a;\n\t\t}\n\t}\n\tout_size = WebPEncodeRGBA(argb, gdImageSX(im), gdImageSY(im), gdImageSX(im) * 4, quantization, &out);\n\tif (out_size == 0) {\n\t\tzend_error(E_ERROR, \"gd-webp encoding failed\");\n\t\tgoto freeargb;\n\t}\n\tgdPutBuf(out, out_size, outfile);\n\tfree(out);\n\nfreeargb:\n\tgdFree(argb);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143423,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "void gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quantization)\n{\n\tuint8_t *argb;\n\tint x, y;\n\tuint8_t *p;\n\tuint8_t *out;\n\tsize_t out_size;\n\n\tif (im == NULL) {\n\t\treturn;\n\t}\n\n\tif (!gdImageTrueColor(im)) {\n\t\tzend_error(E_ERROR, \"Paletter image not supported by webp\");\n\t\treturn;\n\t}\n\n\tif (quantization == -1) {\n \t\tquantization = 80;\n \t}\n \n\tif (overflow2(gdImageSX(im), 4)) {\n\t\treturn;\n\t}\n\n\tif (overflow2(gdImageSX(im) * 4, gdImageSY(im))) {\n\t\treturn;\n\t}\n\n \targb = (uint8_t *)gdMalloc(gdImageSX(im) * 4 * gdImageSY(im));\n \tif (!argb) {\n \t\treturn;\n\t}\n\tp = argb;\n\tfor (y = 0; y < gdImageSY(im); y++) {\n\t\tfor (x = 0; x < gdImageSX(im); x++) {\n\t\t\tregister int c;\n\t\t\tregister char a;\n\t\t\tc = im->tpixels[y][x];\n\t\t\ta = gdTrueColorGetAlpha(c);\n\t\t\tif (a == 127) {\n\t\t\t\ta = 0;\n\t\t\t} else {\n\t\t\t\ta = 255 - ((a << 1) + (a >> 6));\n\t\t\t}\n\t\t\t*(p++) = gdTrueColorGetRed(c);\n\t\t\t*(p++) = gdTrueColorGetGreen(c);\n\t\t\t*(p++) = gdTrueColorGetBlue(c); \n\t\t\t*(p++) = a;\n\t\t}\n\t}\n\tout_size = WebPEncodeRGBA(argb, gdImageSX(im), gdImageSY(im), gdImageSX(im) * 4, quantization, &out);\n\tif (out_size == 0) {\n\t\tzend_error(E_ERROR, \"gd-webp encoding failed\");\n\t\tgoto freeargb;\n\t}\n\tgdPutBuf(out, out_size, outfile);\n\tfree(out);\n\nfreeargb:\n\tgdFree(argb);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143424,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static int read_entry(\n\tgit_index_entry **out,\n\tsize_t *out_size,\n\tgit_index *index,\n\tconst void *buffer,\n\tsize_t buffer_size,\n\tconst char *last)\n{\n\tsize_t path_length, entry_size;\n\tconst char *path_ptr;\n\tstruct entry_short source;\n\tgit_index_entry entry = {{0}};\n\tbool compressed = index->version >= INDEX_VERSION_NUMBER_COMP;\n\tchar *tmp_path = NULL;\n\n\tif (INDEX_FOOTER_SIZE + minimal_entry_size > buffer_size)\n\t\treturn -1;\n\n\t/* buffer is not guaranteed to be aligned */\n\tmemcpy(&source, buffer, sizeof(struct entry_short));\n\n\tentry.ctime.seconds = (git_time_t)ntohl(source.ctime.seconds);\n\tentry.ctime.nanoseconds = ntohl(source.ctime.nanoseconds);\n\tentry.mtime.seconds = (git_time_t)ntohl(source.mtime.seconds);\n\tentry.mtime.nanoseconds = ntohl(source.mtime.nanoseconds);\n\tentry.dev = ntohl(source.dev);\n\tentry.ino = ntohl(source.ino);\n\tentry.mode = ntohl(source.mode);\n\tentry.uid = ntohl(source.uid);\n\tentry.gid = ntohl(source.gid);\n\tentry.file_size = ntohl(source.file_size);\n\tgit_oid_cpy(&entry.id, &source.oid);\n\tentry.flags = ntohs(source.flags);\n\n\tif (entry.flags & GIT_IDXENTRY_EXTENDED) {\n\t\tuint16_t flags_raw;\n\t\tsize_t flags_offset;\n\n\t\tflags_offset = offsetof(struct entry_long, flags_extended);\n\t\tmemcpy(&flags_raw, (const char *) buffer + flags_offset,\n\t\t\tsizeof(flags_raw));\n\t\tflags_raw = ntohs(flags_raw);\n\n\t\tmemcpy(&entry.flags_extended, &flags_raw, sizeof(flags_raw));\n\t\tpath_ptr = (const char *) buffer + offsetof(struct entry_long, path);\n\t} else\n\t\tpath_ptr = (const char *) buffer + offsetof(struct entry_short, path);\n\n\tif (!compressed) {\n\t\tpath_length = entry.flags & GIT_IDXENTRY_NAMEMASK;\n\n\t\t/* if this is a very long string, we must find its\n\t\t * real length without overflowing */\n\t\tif (path_length == 0xFFF) {\n\t\t\tconst char *path_end;\n\n\t\t\tpath_end = memchr(path_ptr, '\\0', buffer_size);\n\t\t\tif (path_end == NULL)\n\t\t\t\treturn -1;\n\n\t\t\tpath_length = path_end - path_ptr;\n\t\t}\n\n\t\tentry_size = index_entry_size(path_length, 0, entry.flags);\n\t\tentry.path = (char *)path_ptr;\n\t} else {\n\t\tsize_t varint_len, last_len, prefix_len, suffix_len, path_len;\n\t\tuintmax_t strip_len;\n\n\t\tstrip_len = git_decode_varint((const unsigned char *)path_ptr, &varint_len);\n\t\tlast_len = strlen(last);\n\n\t\tif (varint_len == 0 || last_len < strip_len)\n\t\t\treturn index_error_invalid(\"incorrect prefix length\");\n\n\t\tprefix_len = last_len - strip_len;\n\t\tsuffix_len = strlen(path_ptr + varint_len);\n \n \t\tGITERR_CHECK_ALLOC_ADD(&path_len, prefix_len, suffix_len);\n \t\tGITERR_CHECK_ALLOC_ADD(&path_len, path_len, 1);\n \t\ttmp_path = git__malloc(path_len);\n \t\tGITERR_CHECK_ALLOC(tmp_path);\n \n\t\tmemcpy(tmp_path, last, prefix_len);\n\t\tmemcpy(tmp_path + prefix_len, path_ptr + varint_len, suffix_len + 1);\n\t\tentry_size = index_entry_size(suffix_len, varint_len, entry.flags);\n\t\tentry.path = tmp_path;\n\t}\n\n\tif (entry_size == 0)\n\t\treturn -1;\n\n\tif (INDEX_FOOTER_SIZE + entry_size > buffer_size)\n\t\treturn -1;\n\n\tif (index_entry_dup(out, index, &entry) < 0) {\n\t\tgit__free(tmp_path);\n\t\treturn -1;\n\t}\n\n\tgit__free(tmp_path);\n\t*out_size = entry_size;\n\treturn 0;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143509,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static int read_entry(\n\tgit_index_entry **out,\n\tsize_t *out_size,\n\tgit_index *index,\n\tconst void *buffer,\n\tsize_t buffer_size,\n\tconst char *last)\n{\n\tsize_t path_length, entry_size;\n\tconst char *path_ptr;\n\tstruct entry_short source;\n\tgit_index_entry entry = {{0}};\n\tbool compressed = index->version >= INDEX_VERSION_NUMBER_COMP;\n\tchar *tmp_path = NULL;\n\n\tif (INDEX_FOOTER_SIZE + minimal_entry_size > buffer_size)\n\t\treturn -1;\n\n\t/* buffer is not guaranteed to be aligned */\n\tmemcpy(&source, buffer, sizeof(struct entry_short));\n\n\tentry.ctime.seconds = (git_time_t)ntohl(source.ctime.seconds);\n\tentry.ctime.nanoseconds = ntohl(source.ctime.nanoseconds);\n\tentry.mtime.seconds = (git_time_t)ntohl(source.mtime.seconds);\n\tentry.mtime.nanoseconds = ntohl(source.mtime.nanoseconds);\n\tentry.dev = ntohl(source.dev);\n\tentry.ino = ntohl(source.ino);\n\tentry.mode = ntohl(source.mode);\n\tentry.uid = ntohl(source.uid);\n\tentry.gid = ntohl(source.gid);\n\tentry.file_size = ntohl(source.file_size);\n\tgit_oid_cpy(&entry.id, &source.oid);\n\tentry.flags = ntohs(source.flags);\n\n\tif (entry.flags & GIT_IDXENTRY_EXTENDED) {\n\t\tuint16_t flags_raw;\n\t\tsize_t flags_offset;\n\n\t\tflags_offset = offsetof(struct entry_long, flags_extended);\n\t\tmemcpy(&flags_raw, (const char *) buffer + flags_offset,\n\t\t\tsizeof(flags_raw));\n\t\tflags_raw = ntohs(flags_raw);\n\n\t\tmemcpy(&entry.flags_extended, &flags_raw, sizeof(flags_raw));\n\t\tpath_ptr = (const char *) buffer + offsetof(struct entry_long, path);\n\t} else\n\t\tpath_ptr = (const char *) buffer + offsetof(struct entry_short, path);\n\n\tif (!compressed) {\n\t\tpath_length = entry.flags & GIT_IDXENTRY_NAMEMASK;\n\n\t\t/* if this is a very long string, we must find its\n\t\t * real length without overflowing */\n\t\tif (path_length == 0xFFF) {\n\t\t\tconst char *path_end;\n\n\t\t\tpath_end = memchr(path_ptr, '\\0', buffer_size);\n\t\t\tif (path_end == NULL)\n\t\t\t\treturn -1;\n\n\t\t\tpath_length = path_end - path_ptr;\n\t\t}\n\n\t\tentry_size = index_entry_size(path_length, 0, entry.flags);\n\t\tentry.path = (char *)path_ptr;\n\t} else {\n\t\tsize_t varint_len, last_len, prefix_len, suffix_len, path_len;\n\t\tuintmax_t strip_len;\n\n\t\tstrip_len = git_decode_varint((const unsigned char *)path_ptr, &varint_len);\n\t\tlast_len = strlen(last);\n\n\t\tif (varint_len == 0 || last_len < strip_len)\n\t\t\treturn index_error_invalid(\"incorrect prefix length\");\n\n\t\tprefix_len = last_len - strip_len;\n\t\tsuffix_len = strlen(path_ptr + varint_len);\n \n \t\tGITERR_CHECK_ALLOC_ADD(&path_len, prefix_len, suffix_len);\n \t\tGITERR_CHECK_ALLOC_ADD(&path_len, path_len, 1);\n\n\t\tif (path_len > GIT_PATH_MAX)\n\t\t\treturn index_error_invalid(\"unreasonable path length\");\n\n \t\ttmp_path = git__malloc(path_len);\n \t\tGITERR_CHECK_ALLOC(tmp_path);\n \n\t\tmemcpy(tmp_path, last, prefix_len);\n\t\tmemcpy(tmp_path + prefix_len, path_ptr + varint_len, suffix_len + 1);\n\t\tentry_size = index_entry_size(suffix_len, varint_len, entry.flags);\n\t\tentry.path = tmp_path;\n\t}\n\n\tif (entry_size == 0)\n\t\treturn -1;\n\n\tif (INDEX_FOOTER_SIZE + entry_size > buffer_size)\n\t\treturn -1;\n\n\tif (index_entry_dup(out, index, &entry) < 0) {\n\t\tgit__free(tmp_path);\n\t\treturn -1;\n\t}\n\n\tgit__free(tmp_path);\n\t*out_size = entry_size;\n\treturn 0;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143510,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "void opj_get_all_encoding_parameters(   const opj_image_t *p_image,\n                                        const opj_cp_t *p_cp,\n                                        OPJ_UINT32 tileno,\n                                        OPJ_INT32 * p_tx0,\n                                        OPJ_INT32 * p_tx1,\n                                        OPJ_INT32 * p_ty0,\n                                        OPJ_INT32 * p_ty1,\n                                        OPJ_UINT32 * p_dx_min,\n                                        OPJ_UINT32 * p_dy_min,\n                                        OPJ_UINT32 * p_max_prec,\n                                        OPJ_UINT32 * p_max_res,\n                                        OPJ_UINT32 ** p_resolutions )\n{\n\t/* loop*/\n\tOPJ_UINT32 compno, resno;\n\n\t/* pointers*/\n\tconst opj_tcp_t *tcp = 00;\n\tconst opj_tccp_t * l_tccp = 00;\n\tconst opj_image_comp_t * l_img_comp = 00;\n\n\t/* to store l_dx, l_dy, w and h for each resolution and component.*/\n\tOPJ_UINT32 * lResolutionPtr;\n\n\t/* position in x and y of tile*/\n\tOPJ_UINT32 p, q;\n\n\t/* preconditions in debug*/\n\tassert(p_cp != 00);\n\tassert(p_image != 00);\n\tassert(tileno < p_cp->tw * p_cp->th);\n\n\t/* initializations*/\n\ttcp = &p_cp->tcps [tileno];\n\tl_tccp = tcp->tccps;\n\tl_img_comp = p_image->comps;\n\n\t/* position in x and y of tile*/\n\tp = tileno % p_cp->tw;\n \tq = tileno / p_cp->tw;\n \n \t/* here calculation of tx0, tx1, ty0, ty1, maxprec, l_dx and l_dy */\n\t*p_tx0 = opj_int_max((OPJ_INT32)(p_cp->tx0 + p * p_cp->tdx), (OPJ_INT32)p_image->x0);\n\t*p_tx1 = opj_int_min((OPJ_INT32)(p_cp->tx0 + (p + 1) * p_cp->tdx), (OPJ_INT32)p_image->x1);\n\t*p_ty0 = opj_int_max((OPJ_INT32)(p_cp->ty0 + q * p_cp->tdy), (OPJ_INT32)p_image->y0);\n\t*p_ty1 = opj_int_min((OPJ_INT32)(p_cp->ty0 + (q + 1) * p_cp->tdy), (OPJ_INT32)p_image->y1);\n \n \t/* max precision and resolution is 0 (can only grow)*/\n \t*p_max_prec = 0;\n\t*p_max_res = 0;\n\n\t/* take the largest value for dx_min and dy_min*/\n\t*p_dx_min = 0x7fffffff;\n\t*p_dy_min = 0x7fffffff;\n\n\tfor (compno = 0; compno < p_image->numcomps; ++compno) {\n\t\t/* aritmetic variables to calculate*/\n\t\tOPJ_UINT32 l_level_no;\n\t\tOPJ_INT32 l_rx0, l_ry0, l_rx1, l_ry1;\n\t\tOPJ_INT32 l_px0, l_py0, l_px1, py1;\n\t\tOPJ_UINT32 l_product;\n\t\tOPJ_INT32 l_tcx0, l_tcy0, l_tcx1, l_tcy1;\n\t\tOPJ_UINT32 l_pdx, l_pdy , l_pw , l_ph;\n\n\t\tlResolutionPtr = p_resolutions[compno];\n\n\t\tl_tcx0 = opj_int_ceildiv(*p_tx0, (OPJ_INT32)l_img_comp->dx);\n\t\tl_tcy0 = opj_int_ceildiv(*p_ty0, (OPJ_INT32)l_img_comp->dy);\n\t\tl_tcx1 = opj_int_ceildiv(*p_tx1, (OPJ_INT32)l_img_comp->dx);\n\t\tl_tcy1 = opj_int_ceildiv(*p_ty1, (OPJ_INT32)l_img_comp->dy);\n\n\t\tif (l_tccp->numresolutions > *p_max_res) {\n\t\t\t*p_max_res = l_tccp->numresolutions;\n\t\t}\n\n\t\t/* use custom size for precincts*/\n\t\tl_level_no = l_tccp->numresolutions - 1;\n\t\tfor (resno = 0; resno < l_tccp->numresolutions; ++resno) {\n\t\t\tOPJ_UINT32 l_dx, l_dy;\n\n\t\t\t/* precinct width and height*/\n\t\t\tl_pdx = l_tccp->prcw[resno];\n\t\t\tl_pdy = l_tccp->prch[resno];\n\t\t\t*lResolutionPtr++ = l_pdx;\n\t\t\t*lResolutionPtr++ = l_pdy;\n\t\t\tl_dx = l_img_comp->dx * (1u << (l_pdx + l_level_no));\n\t\t\tl_dy = l_img_comp->dy * (1u << (l_pdy + l_level_no));\n\t\t\t/* take the minimum size for l_dx for each comp and resolution*/\n\t\t\t*p_dx_min = (OPJ_UINT32)opj_int_min((OPJ_INT32)*p_dx_min, (OPJ_INT32)l_dx);\n\t\t\t*p_dy_min = (OPJ_UINT32)opj_int_min((OPJ_INT32)*p_dy_min, (OPJ_INT32)l_dy);\n\n\t\t\t/* various calculations of extents*/\n\t\t\tl_rx0 = opj_int_ceildivpow2(l_tcx0, (OPJ_INT32)l_level_no);\n\t\t\tl_ry0 = opj_int_ceildivpow2(l_tcy0, (OPJ_INT32)l_level_no);\n\t\t\tl_rx1 = opj_int_ceildivpow2(l_tcx1, (OPJ_INT32)l_level_no);\n\t\t\tl_ry1 = opj_int_ceildivpow2(l_tcy1, (OPJ_INT32)l_level_no);\n\t\t\tl_px0 = opj_int_floordivpow2(l_rx0, (OPJ_INT32)l_pdx) << l_pdx;\n\t\t\tl_py0 = opj_int_floordivpow2(l_ry0, (OPJ_INT32)l_pdy) << l_pdy;\n\t\t\tl_px1 = opj_int_ceildivpow2(l_rx1, (OPJ_INT32)l_pdx) << l_pdx;\n\t\t\tpy1 = opj_int_ceildivpow2(l_ry1, (OPJ_INT32)l_pdy) << l_pdy;\n\t\t\tl_pw = (l_rx0==l_rx1)?0:(OPJ_UINT32)((l_px1 - l_px0) >> l_pdx);\n\t\t\tl_ph = (l_ry0==l_ry1)?0:(OPJ_UINT32)((py1 - l_py0) >> l_pdy);\n\t\t\t*lResolutionPtr++ = l_pw;\n\t\t\t*lResolutionPtr++ = l_ph;\n\t\t\tl_product = l_pw * l_ph;\n\t\t\t\n            /* update precision*/\n\t\t\tif (l_product > *p_max_prec) {\n\t\t\t\t*p_max_prec = l_product;\n\t\t\t}\n\n\t\t\t--l_level_no;\n\t\t}\n\t\t++l_tccp;\n\t\t++l_img_comp;\n\t}\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143519,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "void opj_get_all_encoding_parameters(   const opj_image_t *p_image,\n                                        const opj_cp_t *p_cp,\n                                        OPJ_UINT32 tileno,\n                                        OPJ_INT32 * p_tx0,\n                                        OPJ_INT32 * p_tx1,\n                                        OPJ_INT32 * p_ty0,\n                                        OPJ_INT32 * p_ty1,\n                                        OPJ_UINT32 * p_dx_min,\n                                        OPJ_UINT32 * p_dy_min,\n                                        OPJ_UINT32 * p_max_prec,\n                                        OPJ_UINT32 * p_max_res,\n                                        OPJ_UINT32 ** p_resolutions )\n{\n\t/* loop*/\n\tOPJ_UINT32 compno, resno;\n\n\t/* pointers*/\n\tconst opj_tcp_t *tcp = 00;\n\tconst opj_tccp_t * l_tccp = 00;\n\tconst opj_image_comp_t * l_img_comp = 00;\n\n\t/* to store l_dx, l_dy, w and h for each resolution and component.*/\n\tOPJ_UINT32 * lResolutionPtr;\n\n\t/* position in x and y of tile*/\n\tOPJ_UINT32 p, q;\n\n\t/* preconditions in debug*/\n\tassert(p_cp != 00);\n\tassert(p_image != 00);\n\tassert(tileno < p_cp->tw * p_cp->th);\n\n\t/* initializations*/\n\ttcp = &p_cp->tcps [tileno];\n\tl_tccp = tcp->tccps;\n\tl_img_comp = p_image->comps;\n\n\t/* position in x and y of tile*/\n\tp = tileno % p_cp->tw;\n \tq = tileno / p_cp->tw;\n \n \t/* here calculation of tx0, tx1, ty0, ty1, maxprec, l_dx and l_dy */\n\t*p_tx0 = (OPJ_INT32)opj_uint_max(p_cp->tx0 + p * p_cp->tdx, p_image->x0);\n\t*p_tx1 = (OPJ_INT32)opj_uint_min(p_cp->tx0 + (p + 1) * p_cp->tdx, p_image->x1);\n\t*p_ty0 = (OPJ_INT32)opj_uint_max(p_cp->ty0 + q * p_cp->tdy, p_image->y0);\n\t*p_ty1 = (OPJ_INT32)opj_uint_min(p_cp->ty0 + (q + 1) * p_cp->tdy, p_image->y1);\n \n \t/* max precision and resolution is 0 (can only grow)*/\n \t*p_max_prec = 0;\n\t*p_max_res = 0;\n\n\t/* take the largest value for dx_min and dy_min*/\n\t*p_dx_min = 0x7fffffff;\n\t*p_dy_min = 0x7fffffff;\n\n\tfor (compno = 0; compno < p_image->numcomps; ++compno) {\n\t\t/* aritmetic variables to calculate*/\n\t\tOPJ_UINT32 l_level_no;\n\t\tOPJ_INT32 l_rx0, l_ry0, l_rx1, l_ry1;\n\t\tOPJ_INT32 l_px0, l_py0, l_px1, py1;\n\t\tOPJ_UINT32 l_product;\n\t\tOPJ_INT32 l_tcx0, l_tcy0, l_tcx1, l_tcy1;\n\t\tOPJ_UINT32 l_pdx, l_pdy , l_pw , l_ph;\n\n\t\tlResolutionPtr = p_resolutions[compno];\n\n\t\tl_tcx0 = opj_int_ceildiv(*p_tx0, (OPJ_INT32)l_img_comp->dx);\n\t\tl_tcy0 = opj_int_ceildiv(*p_ty0, (OPJ_INT32)l_img_comp->dy);\n\t\tl_tcx1 = opj_int_ceildiv(*p_tx1, (OPJ_INT32)l_img_comp->dx);\n\t\tl_tcy1 = opj_int_ceildiv(*p_ty1, (OPJ_INT32)l_img_comp->dy);\n\n\t\tif (l_tccp->numresolutions > *p_max_res) {\n\t\t\t*p_max_res = l_tccp->numresolutions;\n\t\t}\n\n\t\t/* use custom size for precincts*/\n\t\tl_level_no = l_tccp->numresolutions - 1;\n\t\tfor (resno = 0; resno < l_tccp->numresolutions; ++resno) {\n\t\t\tOPJ_UINT32 l_dx, l_dy;\n\n\t\t\t/* precinct width and height*/\n\t\t\tl_pdx = l_tccp->prcw[resno];\n\t\t\tl_pdy = l_tccp->prch[resno];\n\t\t\t*lResolutionPtr++ = l_pdx;\n\t\t\t*lResolutionPtr++ = l_pdy;\n\t\t\tl_dx = l_img_comp->dx * (1u << (l_pdx + l_level_no));\n\t\t\tl_dy = l_img_comp->dy * (1u << (l_pdy + l_level_no));\n\t\t\t/* take the minimum size for l_dx for each comp and resolution*/\n\t\t\t*p_dx_min = (OPJ_UINT32)opj_int_min((OPJ_INT32)*p_dx_min, (OPJ_INT32)l_dx);\n\t\t\t*p_dy_min = (OPJ_UINT32)opj_int_min((OPJ_INT32)*p_dy_min, (OPJ_INT32)l_dy);\n\n\t\t\t/* various calculations of extents*/\n\t\t\tl_rx0 = opj_int_ceildivpow2(l_tcx0, (OPJ_INT32)l_level_no);\n\t\t\tl_ry0 = opj_int_ceildivpow2(l_tcy0, (OPJ_INT32)l_level_no);\n\t\t\tl_rx1 = opj_int_ceildivpow2(l_tcx1, (OPJ_INT32)l_level_no);\n\t\t\tl_ry1 = opj_int_ceildivpow2(l_tcy1, (OPJ_INT32)l_level_no);\n\t\t\tl_px0 = opj_int_floordivpow2(l_rx0, (OPJ_INT32)l_pdx) << l_pdx;\n\t\t\tl_py0 = opj_int_floordivpow2(l_ry0, (OPJ_INT32)l_pdy) << l_pdy;\n\t\t\tl_px1 = opj_int_ceildivpow2(l_rx1, (OPJ_INT32)l_pdx) << l_pdx;\n\t\t\tpy1 = opj_int_ceildivpow2(l_ry1, (OPJ_INT32)l_pdy) << l_pdy;\n\t\t\tl_pw = (l_rx0==l_rx1)?0:(OPJ_UINT32)((l_px1 - l_px0) >> l_pdx);\n\t\t\tl_ph = (l_ry0==l_ry1)?0:(OPJ_UINT32)((py1 - l_py0) >> l_pdy);\n\t\t\t*lResolutionPtr++ = l_pw;\n\t\t\t*lResolutionPtr++ = l_ph;\n\t\t\tl_product = l_pw * l_ph;\n\t\t\t\n            /* update precision*/\n\t\t\tif (l_product > *p_max_prec) {\n\t\t\t\t*p_max_prec = l_product;\n\t\t\t}\n\n\t\t\t--l_level_no;\n\t\t}\n\t\t++l_tccp;\n\t\t++l_img_comp;\n\t}\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143520,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "ChooserContextBase::GetGrantedObjects(const GURL& requesting_origin,\n                                      const GURL& embedding_origin) {\n  DCHECK_EQ(requesting_origin, requesting_origin.GetOrigin());\n  DCHECK_EQ(embedding_origin, embedding_origin.GetOrigin());\n\n  if (!CanRequestObjectPermission(requesting_origin, embedding_origin))\n     return {};\n \n   std::vector<std::unique_ptr<Object>> results;\n  auto* info = new content_settings::SettingInfo();\n   std::unique_ptr<base::DictionaryValue> setting =\n      GetWebsiteSetting(requesting_origin, embedding_origin, info);\n   std::unique_ptr<base::Value> objects;\n   if (!setting->Remove(kObjectListKey, &objects))\n     return results;\n\n  std::unique_ptr<base::ListValue> object_list =\n      base::ListValue::From(std::move(objects));\n  if (!object_list)\n    return results;\n\n  for (auto& object : *object_list) {\n     base::DictionaryValue* object_dict;\n     if (object.GetAsDictionary(&object_dict) && IsValidObject(*object_dict)) {\n       results.push_back(std::make_unique<Object>(\n          requesting_origin, embedding_origin, object_dict, info->source,\n           host_content_settings_map_->is_incognito()));\n     }\n   }\n  return results;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143619,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "ChooserContextBase::GetGrantedObjects(const GURL& requesting_origin,\n                                      const GURL& embedding_origin) {\n  DCHECK_EQ(requesting_origin, requesting_origin.GetOrigin());\n  DCHECK_EQ(embedding_origin, embedding_origin.GetOrigin());\n\n  if (!CanRequestObjectPermission(requesting_origin, embedding_origin))\n     return {};\n \n   std::vector<std::unique_ptr<Object>> results;\n  content_settings::SettingInfo info;\n   std::unique_ptr<base::DictionaryValue> setting =\n      GetWebsiteSetting(requesting_origin, embedding_origin, &info);\n   std::unique_ptr<base::Value> objects;\n   if (!setting->Remove(kObjectListKey, &objects))\n     return results;\n\n  std::unique_ptr<base::ListValue> object_list =\n      base::ListValue::From(std::move(objects));\n  if (!object_list)\n    return results;\n\n  for (auto& object : *object_list) {\n     base::DictionaryValue* object_dict;\n     if (object.GetAsDictionary(&object_dict) && IsValidObject(*object_dict)) {\n       results.push_back(std::make_unique<Object>(\n          requesting_origin, embedding_origin, object_dict, info.source,\n           host_content_settings_map_->is_incognito()));\n     }\n   }\n  return results;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143620,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "void AXTree::PopulateOrderedSetItems(const AXNode* ordered_set,\n                                     const AXNode* local_parent,\n                                     std::vector<const AXNode*>& items,\n                                     bool node_is_radio_button) const {\n  if (!(ordered_set == local_parent)) {\n    if (local_parent->data().role == ordered_set->data().role)\n      return;\n  }\n\n   for (int i = 0; i < local_parent->child_count(); ++i) {\n     const AXNode* child = local_parent->GetUnignoredChildAtIndex(i);\n \n     if (node_is_radio_button &&\n         child->data().role == ax::mojom::Role::kRadioButton)\n      items.push_back(child);\n\n    if (!node_is_radio_button && child->SetRoleMatchesItemRole(ordered_set))\n      items.push_back(child);\n\n    if (child->data().role == ax::mojom::Role::kGenericContainer ||\n        child->data().role == ax::mojom::Role::kIgnored) {\n      PopulateOrderedSetItems(ordered_set, child, items, node_is_radio_button);\n    }\n  }\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143623,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "void AXTree::PopulateOrderedSetItems(const AXNode* ordered_set,\n                                     const AXNode* local_parent,\n                                     std::vector<const AXNode*>& items,\n                                     bool node_is_radio_button) const {\n  if (!(ordered_set == local_parent)) {\n    if (local_parent->data().role == ordered_set->data().role)\n      return;\n  }\n\n   for (int i = 0; i < local_parent->child_count(); ++i) {\n     const AXNode* child = local_parent->GetUnignoredChildAtIndex(i);\n \n    // Invisible children should not be counted.\n    // However, in the collapsed container case (e.g. a combobox), items can\n    // still be chosen/navigated. However, the options in these collapsed\n    // containers are historically marked invisible. Therefore, in that case,\n    // count the invisible items. Only check 2 levels up, as combobox containers\n    // are never higher.\n    if (child->data().HasState(ax::mojom::State::kInvisible) &&\n        !IsCollapsed(local_parent) && !IsCollapsed(local_parent->parent())) {\n      continue;\n    }\n\n     if (node_is_radio_button &&\n         child->data().role == ax::mojom::Role::kRadioButton)\n      items.push_back(child);\n\n    if (!node_is_radio_button && child->SetRoleMatchesItemRole(ordered_set))\n      items.push_back(child);\n\n    if (child->data().role == ax::mojom::Role::kGenericContainer ||\n        child->data().role == ax::mojom::Role::kIgnored) {\n      PopulateOrderedSetItems(ordered_set, child, items, node_is_radio_button);\n    }\n  }\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143624,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "String TextCodecUTF8::Decode(const char* bytes,\n                             wtf_size_t length,\n                             FlushBehavior flush,\n                             bool stop_on_error,\n                             bool& saw_error) {\n  const bool do_flush = flush != FlushBehavior::kDoNotFlush;\n  StringBuffer<LChar> buffer(partial_sequence_size_ + length);\n \n   const uint8_t* source = reinterpret_cast<const uint8_t*>(bytes);\n   const uint8_t* end = source + length;\n  const uint8_t* aligned_end = AlignToMachineWord(end);\n  LChar* destination = buffer.Characters();\n\n  do {\n    if (partial_sequence_size_) {\n      LChar* destination_for_handle_partial_sequence = destination;\n      const uint8_t* source_for_handle_partial_sequence = source;\n      if (HandlePartialSequence(destination_for_handle_partial_sequence,\n                                source_for_handle_partial_sequence, end,\n                                do_flush, stop_on_error, saw_error)) {\n        source = source_for_handle_partial_sequence;\n        goto upConvertTo16Bit;\n      }\n      destination = destination_for_handle_partial_sequence;\n      source = source_for_handle_partial_sequence;\n      if (partial_sequence_size_)\n        break;\n    }\n\n    while (source < end) {\n      if (IsASCII(*source)) {\n        if (IsAlignedToMachineWord(source)) {\n          while (source < aligned_end) {\n            MachineWord chunk =\n                *reinterpret_cast_ptr<const MachineWord*>(source);\n            if (!IsAllASCII<LChar>(chunk))\n              break;\n            CopyASCIIMachineWord(destination, source);\n            source += sizeof(MachineWord);\n            destination += sizeof(MachineWord);\n          }\n          if (source == end)\n            break;\n          if (!IsASCII(*source))\n            continue;\n        }\n        *destination++ = *source++;\n        continue;\n      }\n      int count = NonASCIISequenceLength(*source);\n      int character;\n      if (count == 0) {\n        character = kNonCharacter1;\n      } else {\n        if (count > end - source) {\n          SECURITY_DCHECK(end - source <\n                          static_cast<ptrdiff_t>(sizeof(partial_sequence_)));\n          DCHECK(!partial_sequence_size_);\n          partial_sequence_size_ = static_cast<wtf_size_t>(end - source);\n          memcpy(partial_sequence_, source, partial_sequence_size_);\n          source = end;\n          break;\n        }\n        character = DecodeNonASCIISequence(source, count);\n      }\n      if (IsNonCharacter(character)) {\n        saw_error = true;\n        if (stop_on_error)\n          break;\n\n        goto upConvertTo16Bit;\n      }\n      if (character > 0xff)\n        goto upConvertTo16Bit;\n\n      source += count;\n      *destination++ = static_cast<LChar>(character);\n    }\n  } while (do_flush && partial_sequence_size_);\n\n  buffer.Shrink(static_cast<wtf_size_t>(destination - buffer.Characters()));\n\n   return String::Adopt(buffer);\n \n upConvertTo16Bit:\n  StringBuffer<UChar> buffer16(partial_sequence_size_ + length);\n \n   UChar* destination16 = buffer16.Characters();\n \n  for (LChar* converted8 = buffer.Characters(); converted8 < destination;)\n    *destination16++ = *converted8++;\n\n  do {\n    if (partial_sequence_size_) {\n      UChar* destination_for_handle_partial_sequence = destination16;\n      const uint8_t* source_for_handle_partial_sequence = source;\n      HandlePartialSequence(destination_for_handle_partial_sequence,\n                            source_for_handle_partial_sequence, end, do_flush,\n                            stop_on_error, saw_error);\n      destination16 = destination_for_handle_partial_sequence;\n      source = source_for_handle_partial_sequence;\n      if (partial_sequence_size_)\n        break;\n    }\n\n    while (source < end) {\n      if (IsASCII(*source)) {\n        if (IsAlignedToMachineWord(source)) {\n          while (source < aligned_end) {\n            MachineWord chunk =\n                *reinterpret_cast_ptr<const MachineWord*>(source);\n            if (!IsAllASCII<LChar>(chunk))\n              break;\n            CopyASCIIMachineWord(destination16, source);\n            source += sizeof(MachineWord);\n            destination16 += sizeof(MachineWord);\n          }\n          if (source == end)\n            break;\n          if (!IsASCII(*source))\n            continue;\n        }\n        *destination16++ = *source++;\n        continue;\n      }\n      int count = NonASCIISequenceLength(*source);\n      int character;\n      if (count == 0) {\n        character = kNonCharacter1;\n      } else {\n        if (count > end - source) {\n          SECURITY_DCHECK(end - source <\n                          static_cast<ptrdiff_t>(sizeof(partial_sequence_)));\n          DCHECK(!partial_sequence_size_);\n          partial_sequence_size_ = static_cast<wtf_size_t>(end - source);\n          memcpy(partial_sequence_, source, partial_sequence_size_);\n          source = end;\n          break;\n        }\n        character = DecodeNonASCIISequence(source, count);\n      }\n      if (IsNonCharacter(character)) {\n        saw_error = true;\n        if (stop_on_error)\n          break;\n        *destination16++ = kReplacementCharacter;\n        source -= character;\n        continue;\n      }\n      source += count;\n      destination16 = AppendCharacter(destination16, character);\n    }\n  } while (do_flush && partial_sequence_size_);\n\n  buffer16.Shrink(\n      static_cast<wtf_size_t>(destination16 - buffer16.Characters()));\n\n  return String::Adopt(buffer16);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143677,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "String TextCodecUTF8::Decode(const char* bytes,\n                             wtf_size_t length,\n                             FlushBehavior flush,\n                             bool stop_on_error,\n                             bool& saw_error) {\n  const bool do_flush = flush != FlushBehavior::kDoNotFlush;\n  StringBuffer<LChar> buffer(\n      base::CheckAdd(partial_sequence_size_, length).ValueOrDie());\n \n   const uint8_t* source = reinterpret_cast<const uint8_t*>(bytes);\n   const uint8_t* end = source + length;\n  const uint8_t* aligned_end = AlignToMachineWord(end);\n  LChar* destination = buffer.Characters();\n\n  do {\n    if (partial_sequence_size_) {\n      LChar* destination_for_handle_partial_sequence = destination;\n      const uint8_t* source_for_handle_partial_sequence = source;\n      if (HandlePartialSequence(destination_for_handle_partial_sequence,\n                                source_for_handle_partial_sequence, end,\n                                do_flush, stop_on_error, saw_error)) {\n        source = source_for_handle_partial_sequence;\n        goto upConvertTo16Bit;\n      }\n      destination = destination_for_handle_partial_sequence;\n      source = source_for_handle_partial_sequence;\n      if (partial_sequence_size_)\n        break;\n    }\n\n    while (source < end) {\n      if (IsASCII(*source)) {\n        if (IsAlignedToMachineWord(source)) {\n          while (source < aligned_end) {\n            MachineWord chunk =\n                *reinterpret_cast_ptr<const MachineWord*>(source);\n            if (!IsAllASCII<LChar>(chunk))\n              break;\n            CopyASCIIMachineWord(destination, source);\n            source += sizeof(MachineWord);\n            destination += sizeof(MachineWord);\n          }\n          if (source == end)\n            break;\n          if (!IsASCII(*source))\n            continue;\n        }\n        *destination++ = *source++;\n        continue;\n      }\n      int count = NonASCIISequenceLength(*source);\n      int character;\n      if (count == 0) {\n        character = kNonCharacter1;\n      } else {\n        if (count > end - source) {\n          SECURITY_DCHECK(end - source <\n                          static_cast<ptrdiff_t>(sizeof(partial_sequence_)));\n          DCHECK(!partial_sequence_size_);\n          partial_sequence_size_ = static_cast<wtf_size_t>(end - source);\n          memcpy(partial_sequence_, source, partial_sequence_size_);\n          source = end;\n          break;\n        }\n        character = DecodeNonASCIISequence(source, count);\n      }\n      if (IsNonCharacter(character)) {\n        saw_error = true;\n        if (stop_on_error)\n          break;\n\n        goto upConvertTo16Bit;\n      }\n      if (character > 0xff)\n        goto upConvertTo16Bit;\n\n      source += count;\n      *destination++ = static_cast<LChar>(character);\n    }\n  } while (do_flush && partial_sequence_size_);\n\n  buffer.Shrink(static_cast<wtf_size_t>(destination - buffer.Characters()));\n\n   return String::Adopt(buffer);\n \n upConvertTo16Bit:\n  StringBuffer<UChar> buffer16(\n      base::CheckAdd(partial_sequence_size_, length).ValueOrDie());\n \n   UChar* destination16 = buffer16.Characters();\n \n  for (LChar* converted8 = buffer.Characters(); converted8 < destination;)\n    *destination16++ = *converted8++;\n\n  do {\n    if (partial_sequence_size_) {\n      UChar* destination_for_handle_partial_sequence = destination16;\n      const uint8_t* source_for_handle_partial_sequence = source;\n      HandlePartialSequence(destination_for_handle_partial_sequence,\n                            source_for_handle_partial_sequence, end, do_flush,\n                            stop_on_error, saw_error);\n      destination16 = destination_for_handle_partial_sequence;\n      source = source_for_handle_partial_sequence;\n      if (partial_sequence_size_)\n        break;\n    }\n\n    while (source < end) {\n      if (IsASCII(*source)) {\n        if (IsAlignedToMachineWord(source)) {\n          while (source < aligned_end) {\n            MachineWord chunk =\n                *reinterpret_cast_ptr<const MachineWord*>(source);\n            if (!IsAllASCII<LChar>(chunk))\n              break;\n            CopyASCIIMachineWord(destination16, source);\n            source += sizeof(MachineWord);\n            destination16 += sizeof(MachineWord);\n          }\n          if (source == end)\n            break;\n          if (!IsASCII(*source))\n            continue;\n        }\n        *destination16++ = *source++;\n        continue;\n      }\n      int count = NonASCIISequenceLength(*source);\n      int character;\n      if (count == 0) {\n        character = kNonCharacter1;\n      } else {\n        if (count > end - source) {\n          SECURITY_DCHECK(end - source <\n                          static_cast<ptrdiff_t>(sizeof(partial_sequence_)));\n          DCHECK(!partial_sequence_size_);\n          partial_sequence_size_ = static_cast<wtf_size_t>(end - source);\n          memcpy(partial_sequence_, source, partial_sequence_size_);\n          source = end;\n          break;\n        }\n        character = DecodeNonASCIISequence(source, count);\n      }\n      if (IsNonCharacter(character)) {\n        saw_error = true;\n        if (stop_on_error)\n          break;\n        *destination16++ = kReplacementCharacter;\n        source -= character;\n        continue;\n      }\n      source += count;\n      destination16 = AppendCharacter(destination16, character);\n    }\n  } while (do_flush && partial_sequence_size_);\n\n  buffer16.Shrink(\n      static_cast<wtf_size_t>(destination16 - buffer16.Characters()));\n\n  return String::Adopt(buffer16);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143678,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "OperationID FileSystemOperationRunner::BeginOperation(\n     std::unique_ptr<FileSystemOperation> operation) {\n   OperationID id = next_operation_id_++;\n \n  operations_.emplace(id, std::move(operation));\n   return id;\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143761,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "OperationID FileSystemOperationRunner::BeginOperation(\n     std::unique_ptr<FileSystemOperation> operation) {\n   OperationID id = next_operation_id_++;\n \n  operations_[id] = std::move(operation);\n   return id;\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143762,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "AMediaCodecCryptoInfo *AMediaCodecCryptoInfo_new(\n int numsubsamples,\n uint8_t key[16],\n uint8_t iv[16],\n cryptoinfo_mode_t mode,\n size_t *clearbytes,\n\n         size_t *encryptedbytes) {\n \n    size_t cryptosize = sizeof(AMediaCodecCryptoInfo) + sizeof(size_t) * numsubsamples * 2;\n     AMediaCodecCryptoInfo *ret = (AMediaCodecCryptoInfo*) malloc(cryptosize);\n     if (!ret) {\n         ALOGE(\"couldn't allocate %zu bytes\", cryptosize);\n return NULL;\n }\n    ret->numsubsamples = numsubsamples;\n    memcpy(ret->key, key, 16);\n    memcpy(ret->iv, iv, 16);\n    ret->mode = mode;\n    ret->pattern.encryptBlocks = 0;\n    ret->pattern.skipBlocks = 0;\n\n    ret->clearbytes = (size_t*) (ret + 1); // point immediately after the struct\n    ret->encryptedbytes = ret->clearbytes + numsubsamples; // point after the clear sizes\n\n    memcpy(ret->clearbytes, clearbytes, numsubsamples * sizeof(size_t));\n    memcpy(ret->encryptedbytes, encryptedbytes, numsubsamples * sizeof(size_t));\n\n return ret;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143921,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "AMediaCodecCryptoInfo *AMediaCodecCryptoInfo_new(\n int numsubsamples,\n uint8_t key[16],\n uint8_t iv[16],\n cryptoinfo_mode_t mode,\n size_t *clearbytes,\n\n         size_t *encryptedbytes) {\n \n    size_t cryptosize;\n    // = sizeof(AMediaCodecCryptoInfo) + sizeof(size_t) * numsubsamples * 2;\n    if (__builtin_mul_overflow(sizeof(size_t) * 2, numsubsamples, &cryptosize) ||\n            __builtin_add_overflow(cryptosize, sizeof(AMediaCodecCryptoInfo), &cryptosize)) {\n        ALOGE(\"crypto size overflow\");\n        return NULL;\n    }\n     AMediaCodecCryptoInfo *ret = (AMediaCodecCryptoInfo*) malloc(cryptosize);\n     if (!ret) {\n         ALOGE(\"couldn't allocate %zu bytes\", cryptosize);\n return NULL;\n }\n    ret->numsubsamples = numsubsamples;\n    memcpy(ret->key, key, 16);\n    memcpy(ret->iv, iv, 16);\n    ret->mode = mode;\n    ret->pattern.encryptBlocks = 0;\n    ret->pattern.skipBlocks = 0;\n\n    ret->clearbytes = (size_t*) (ret + 1); // point immediately after the struct\n    ret->encryptedbytes = ret->clearbytes + numsubsamples; // point after the clear sizes\n\n    memcpy(ret->clearbytes, clearbytes, numsubsamples * sizeof(size_t));\n    memcpy(ret->encryptedbytes, encryptedbytes, numsubsamples * sizeof(size_t));\n\n return ret;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143922,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "void ihevcd_parse_sei_payload(codec_t *ps_codec,\n                              UWORD32 u4_payload_type,\n                              UWORD32 u4_payload_size,\n                              WORD8 i1_nal_type)\n{\n parse_ctxt_t *ps_parse = &ps_codec->s_parse;\n bitstrm_t *ps_bitstrm = &ps_parse->s_bitstrm;\n    WORD32 payload_bits_remaining = 0;\n sps_t *ps_sps;\n\n    UWORD32 i;\n\n for(i = 0; i < MAX_SPS_CNT; i++)\n {\n        ps_sps = ps_codec->ps_sps_base + i;\n if(ps_sps->i1_sps_valid)\n {\n break;\n }\n }\n if(NULL == ps_sps)\n {\n return;\n }\n\n if(NAL_PREFIX_SEI == i1_nal_type)\n {\n switch(u4_payload_type)\n {\n case SEI_BUFFERING_PERIOD:\n                ps_parse->s_sei_params.i1_sei_parameters_present_flag = 1;\n                ihevcd_parse_buffering_period_sei(ps_codec, ps_sps);\n break;\n\n case SEI_PICTURE_TIMING:\n                ps_parse->s_sei_params.i1_sei_parameters_present_flag = 1;\n                ihevcd_parse_pic_timing_sei(ps_codec, ps_sps);\n break;\n\n case SEI_TIME_CODE:\n                ps_parse->s_sei_params.i1_sei_parameters_present_flag = 1;\n                ihevcd_parse_time_code_sei(ps_codec);\n break;\n\n case SEI_MASTERING_DISPLAY_COLOUR_VOLUME:\n                ps_parse->s_sei_params.i4_sei_mastering_disp_colour_vol_params_present_flags = 1;\n                ihevcd_parse_mastering_disp_params_sei(ps_codec);\n break;\n\n \n             case SEI_USER_DATA_REGISTERED_ITU_T_T35:\n                 ps_parse->s_sei_params.i1_sei_parameters_present_flag = 1;\n                ihevcd_parse_user_data_registered_itu_t_t35(ps_codec,\n                                                            u4_payload_size);\n                 break;\n \n             default:\n for(i = 0; i < u4_payload_size; i++)\n {\n                    ihevcd_bits_flush(ps_bitstrm, 8);\n }\n break;\n }\n }\n else /* NAL_SUFFIX_SEI */\n {\n switch(u4_payload_type)\n\n         {\n             case SEI_USER_DATA_REGISTERED_ITU_T_T35:\n                 ps_parse->s_sei_params.i1_sei_parameters_present_flag = 1;\n                ihevcd_parse_user_data_registered_itu_t_t35(ps_codec,\n                                                            u4_payload_size);\n                 break;\n \n             default:\n for(i = 0; i < u4_payload_size; i++)\n {\n                    ihevcd_bits_flush(ps_bitstrm, 8);\n }\n break;\n }\n }\n\n /**\n     * By definition the underlying bitstream terminates in a byte-aligned manner.\n     * 1. Extract all bar the last MIN(bitsremaining,nine) bits as reserved_payload_extension_data\n     * 2. Examine the final 8 bits to determine the payload_bit_equal_to_one marker\n     * 3. Extract the remainingreserved_payload_extension_data bits.\n     *\n     * If there are fewer than 9 bits available, extract them.\n     */\n\n    payload_bits_remaining = ihevcd_bits_num_bits_remaining(ps_bitstrm);\n if(payload_bits_remaining) /* more_data_in_payload() */\n {\n        WORD32 final_bits;\n        WORD32 final_payload_bits = 0;\n        WORD32 mask = 0xFF;\n        UWORD32 u4_dummy;\n        UWORD32 u4_reserved_payload_extension_data;\n        UNUSED(u4_dummy);\n        UNUSED(u4_reserved_payload_extension_data);\n\n while(payload_bits_remaining > 9)\n {\n            BITS_PARSE(\"reserved_payload_extension_data\",\n                       u4_reserved_payload_extension_data, ps_bitstrm, 1);\n            payload_bits_remaining--;\n }\n\n        final_bits = ihevcd_bits_nxt(ps_bitstrm, payload_bits_remaining);\n\n while(final_bits & (mask >> final_payload_bits))\n {\n            final_payload_bits++;\n continue;\n }\n\n while(payload_bits_remaining > (9 - final_payload_bits))\n {\n            BITS_PARSE(\"reserved_payload_extension_data\",\n                       u4_reserved_payload_extension_data, ps_bitstrm, 1);\n            payload_bits_remaining--;\n }\n\n        BITS_PARSE(\"payload_bit_equal_to_one\", u4_dummy, ps_bitstrm, 1);\n        payload_bits_remaining--;\n while(payload_bits_remaining)\n {\n            BITS_PARSE(\"payload_bit_equal_to_zero\", u4_dummy, ps_bitstrm, 1);\n            payload_bits_remaining--;\n }\n }\n\n return;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143925,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "void ihevcd_parse_sei_payload(codec_t *ps_codec,\n                              UWORD32 u4_payload_type,\n                              UWORD32 u4_payload_size,\n                              WORD8 i1_nal_type)\n{\n parse_ctxt_t *ps_parse = &ps_codec->s_parse;\n bitstrm_t *ps_bitstrm = &ps_parse->s_bitstrm;\n    WORD32 payload_bits_remaining = 0;\n sps_t *ps_sps;\n\n    UWORD32 i;\n\n for(i = 0; i < MAX_SPS_CNT; i++)\n {\n        ps_sps = ps_codec->ps_sps_base + i;\n if(ps_sps->i1_sps_valid)\n {\n break;\n }\n }\n if(NULL == ps_sps)\n {\n return;\n }\n\n if(NAL_PREFIX_SEI == i1_nal_type)\n {\n switch(u4_payload_type)\n {\n case SEI_BUFFERING_PERIOD:\n                ps_parse->s_sei_params.i1_sei_parameters_present_flag = 1;\n                ihevcd_parse_buffering_period_sei(ps_codec, ps_sps);\n break;\n\n case SEI_PICTURE_TIMING:\n                ps_parse->s_sei_params.i1_sei_parameters_present_flag = 1;\n                ihevcd_parse_pic_timing_sei(ps_codec, ps_sps);\n break;\n\n case SEI_TIME_CODE:\n                ps_parse->s_sei_params.i1_sei_parameters_present_flag = 1;\n                ihevcd_parse_time_code_sei(ps_codec);\n break;\n\n case SEI_MASTERING_DISPLAY_COLOUR_VOLUME:\n                ps_parse->s_sei_params.i4_sei_mastering_disp_colour_vol_params_present_flags = 1;\n                ihevcd_parse_mastering_disp_params_sei(ps_codec);\n break;\n\n \n             case SEI_USER_DATA_REGISTERED_ITU_T_T35:\n                 ps_parse->s_sei_params.i1_sei_parameters_present_flag = 1;\n                if(ps_parse->s_sei_params.i4_sei_user_data_cnt >= USER_DATA_MAX)\n                {\n                    for(i = 0; i < u4_payload_size / 4; i++)\n                    {\n                        ihevcd_bits_flush(ps_bitstrm, 4 * 8);\n                    }\n\n                    ihevcd_bits_flush(ps_bitstrm, (u4_payload_size - i * 4) * 8);\n                }\n                else\n                {\n                    ihevcd_parse_user_data_registered_itu_t_t35(ps_codec,\n                                                                u4_payload_size);\n                }\n                 break;\n \n             default:\n for(i = 0; i < u4_payload_size; i++)\n {\n                    ihevcd_bits_flush(ps_bitstrm, 8);\n }\n break;\n }\n }\n else /* NAL_SUFFIX_SEI */\n {\n switch(u4_payload_type)\n\n         {\n             case SEI_USER_DATA_REGISTERED_ITU_T_T35:\n                 ps_parse->s_sei_params.i1_sei_parameters_present_flag = 1;\n                if(ps_parse->s_sei_params.i4_sei_user_data_cnt >= USER_DATA_MAX)\n                {\n                    for(i = 0; i < u4_payload_size / 4; i++)\n                    {\n                        ihevcd_bits_flush(ps_bitstrm, 4 * 8);\n                    }\n\n                    ihevcd_bits_flush(ps_bitstrm, (u4_payload_size - i * 4) * 8);\n                }\n                else\n                {\n                    ihevcd_parse_user_data_registered_itu_t_t35(ps_codec,\n                                                                u4_payload_size);\n                }\n                 break;\n \n             default:\n for(i = 0; i < u4_payload_size; i++)\n {\n                    ihevcd_bits_flush(ps_bitstrm, 8);\n }\n break;\n }\n }\n\n /**\n     * By definition the underlying bitstream terminates in a byte-aligned manner.\n     * 1. Extract all bar the last MIN(bitsremaining,nine) bits as reserved_payload_extension_data\n     * 2. Examine the final 8 bits to determine the payload_bit_equal_to_one marker\n     * 3. Extract the remainingreserved_payload_extension_data bits.\n     *\n     * If there are fewer than 9 bits available, extract them.\n     */\n\n    payload_bits_remaining = ihevcd_bits_num_bits_remaining(ps_bitstrm);\n if(payload_bits_remaining) /* more_data_in_payload() */\n {\n        WORD32 final_bits;\n        WORD32 final_payload_bits = 0;\n        WORD32 mask = 0xFF;\n        UWORD32 u4_dummy;\n        UWORD32 u4_reserved_payload_extension_data;\n        UNUSED(u4_dummy);\n        UNUSED(u4_reserved_payload_extension_data);\n\n while(payload_bits_remaining > 9)\n {\n            BITS_PARSE(\"reserved_payload_extension_data\",\n                       u4_reserved_payload_extension_data, ps_bitstrm, 1);\n            payload_bits_remaining--;\n }\n\n        final_bits = ihevcd_bits_nxt(ps_bitstrm, payload_bits_remaining);\n\n while(final_bits & (mask >> final_payload_bits))\n {\n            final_payload_bits++;\n continue;\n }\n\n while(payload_bits_remaining > (9 - final_payload_bits))\n {\n            BITS_PARSE(\"reserved_payload_extension_data\",\n                       u4_reserved_payload_extension_data, ps_bitstrm, 1);\n            payload_bits_remaining--;\n }\n\n        BITS_PARSE(\"payload_bit_equal_to_one\", u4_dummy, ps_bitstrm, 1);\n        payload_bits_remaining--;\n while(payload_bits_remaining)\n {\n            BITS_PARSE(\"payload_bit_equal_to_zero\", u4_dummy, ps_bitstrm, 1);\n            payload_bits_remaining--;\n }\n }\n\n return;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143926,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "_gd2GetHeader (gdIOCtxPtr in, int *sx, int *sy,\n               int *cs, int *vers, int *fmt, int *ncx, int *ncy,\n               t_chunk_info ** chunkIdx)\n{\n\tint i;\n\tint ch;\n\tchar id[5];\n\tt_chunk_info *cidx;\n\tint sidx;\n\tint nc;\n\n\tGD2_DBG (printf (\"Reading gd2 header info\\n\"));\n\n\tfor (i = 0; i < 4; i++) {\n\t\tch = gdGetC (in);\n\t\tif (ch == EOF) {\n\t\t\tgoto fail1;\n\t\t};\n\t\tid[i] = ch;\n\t};\n\tid[4] = 0;\n\n\tGD2_DBG (printf (\"Got file code: %s\\n\", id));\n\n\t/* Equiv. of 'magick'.  */\n\tif (strcmp (id, GD2_ID) != 0) {\n\t\tGD2_DBG (printf (\"Not a valid gd2 file\\n\"));\n\t\tgoto fail1;\n\t};\n\n\t/* Version */\n\tif (gdGetWord (vers, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"Version: %d\\n\", *vers));\n\n\tif ((*vers != 1) && (*vers != 2)) {\n\t\tGD2_DBG (printf (\"Bad version: %d\\n\", *vers));\n\t\tgoto fail1;\n\t};\n\n\t/* Image Size */\n\tif (!gdGetWord (sx, in)) {\n\t\tGD2_DBG (printf (\"Could not get x-size\\n\"));\n\t\tgoto fail1;\n\t}\n\tif (!gdGetWord (sy, in)) {\n\t\tGD2_DBG (printf (\"Could not get y-size\\n\"));\n\t\tgoto fail1;\n\t}\n\tGD2_DBG (printf (\"Image is %dx%d\\n\", *sx, *sy));\n\n\t/* Chunk Size (pixels, not bytes!) */\n\tif (gdGetWord (cs, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"ChunkSize: %d\\n\", *cs));\n\n\tif ((*cs < GD2_CHUNKSIZE_MIN) || (*cs > GD2_CHUNKSIZE_MAX)) {\n\t\tGD2_DBG (printf (\"Bad chunk size: %d\\n\", *cs));\n\t\tgoto fail1;\n\t};\n\n\t/* Data Format */\n\tif (gdGetWord (fmt, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"Format: %d\\n\", *fmt));\n\n\tif ((*fmt != GD2_FMT_RAW) && (*fmt != GD2_FMT_COMPRESSED) &&\n\t        (*fmt != GD2_FMT_TRUECOLOR_RAW) &&\n\t        (*fmt != GD2_FMT_TRUECOLOR_COMPRESSED)) {\n\t\tGD2_DBG (printf (\"Bad data format: %d\\n\", *fmt));\n\t\tgoto fail1;\n\t};\n\n\n\t/* # of chunks wide */\n\tif (gdGetWord (ncx, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"%d Chunks Wide\\n\", *ncx));\n\n\t/* # of chunks high */\n\tif (gdGetWord (ncy, in) != 1) {\n\t\tgoto fail1;\n\t};\n \tGD2_DBG (printf (\"%d Chunks vertically\\n\", *ncy));\n \n \tif (gd2_compressed (*fmt)) {\n \t\tnc = (*ncx) * (*ncy);\n \n \t\tGD2_DBG (printf (\"Reading %d chunk index entries\\n\", nc));\n\t\tif (overflow2(sizeof(t_chunk_info), nc)) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tsidx = sizeof (t_chunk_info) * nc;\n\t\tif (sidx <= 0) {\n\t\t\tgoto fail1;\n\t\t}\n\n\t\tcidx = gdCalloc (sidx, 1);\n\t\tif (cidx == NULL) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tfor (i = 0; i < nc; i++) {\n\t\t\tif (gdGetInt (&cidx[i].offset, in) != 1) {\n\t\t\t\tgoto fail2;\n\t\t\t};\n\t\t\tif (gdGetInt (&cidx[i].size, in) != 1) {\n\t\t\t\tgoto fail2;\n\t\t\t};\n\t\t\tif (cidx[i].offset < 0 || cidx[i].size < 0)\n\t\t\t\tgoto fail2;\n\t\t};\n\t\t*chunkIdx = cidx;\n\t};\n\n\tGD2_DBG (printf (\"gd2 header complete\\n\"));\n\n\treturn 1;\nfail2:\n\tgdFree(cidx);\nfail1:\n\treturn 0;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144119,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "_gd2GetHeader (gdIOCtxPtr in, int *sx, int *sy,\n               int *cs, int *vers, int *fmt, int *ncx, int *ncy,\n               t_chunk_info ** chunkIdx)\n{\n\tint i;\n\tint ch;\n\tchar id[5];\n\tt_chunk_info *cidx;\n\tint sidx;\n\tint nc;\n\n\tGD2_DBG (printf (\"Reading gd2 header info\\n\"));\n\n\tfor (i = 0; i < 4; i++) {\n\t\tch = gdGetC (in);\n\t\tif (ch == EOF) {\n\t\t\tgoto fail1;\n\t\t};\n\t\tid[i] = ch;\n\t};\n\tid[4] = 0;\n\n\tGD2_DBG (printf (\"Got file code: %s\\n\", id));\n\n\t/* Equiv. of 'magick'.  */\n\tif (strcmp (id, GD2_ID) != 0) {\n\t\tGD2_DBG (printf (\"Not a valid gd2 file\\n\"));\n\t\tgoto fail1;\n\t};\n\n\t/* Version */\n\tif (gdGetWord (vers, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"Version: %d\\n\", *vers));\n\n\tif ((*vers != 1) && (*vers != 2)) {\n\t\tGD2_DBG (printf (\"Bad version: %d\\n\", *vers));\n\t\tgoto fail1;\n\t};\n\n\t/* Image Size */\n\tif (!gdGetWord (sx, in)) {\n\t\tGD2_DBG (printf (\"Could not get x-size\\n\"));\n\t\tgoto fail1;\n\t}\n\tif (!gdGetWord (sy, in)) {\n\t\tGD2_DBG (printf (\"Could not get y-size\\n\"));\n\t\tgoto fail1;\n\t}\n\tGD2_DBG (printf (\"Image is %dx%d\\n\", *sx, *sy));\n\n\t/* Chunk Size (pixels, not bytes!) */\n\tif (gdGetWord (cs, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"ChunkSize: %d\\n\", *cs));\n\n\tif ((*cs < GD2_CHUNKSIZE_MIN) || (*cs > GD2_CHUNKSIZE_MAX)) {\n\t\tGD2_DBG (printf (\"Bad chunk size: %d\\n\", *cs));\n\t\tgoto fail1;\n\t};\n\n\t/* Data Format */\n\tif (gdGetWord (fmt, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"Format: %d\\n\", *fmt));\n\n\tif ((*fmt != GD2_FMT_RAW) && (*fmt != GD2_FMT_COMPRESSED) &&\n\t        (*fmt != GD2_FMT_TRUECOLOR_RAW) &&\n\t        (*fmt != GD2_FMT_TRUECOLOR_COMPRESSED)) {\n\t\tGD2_DBG (printf (\"Bad data format: %d\\n\", *fmt));\n\t\tgoto fail1;\n\t};\n\n\n\t/* # of chunks wide */\n\tif (gdGetWord (ncx, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"%d Chunks Wide\\n\", *ncx));\n\n\t/* # of chunks high */\n\tif (gdGetWord (ncy, in) != 1) {\n\t\tgoto fail1;\n\t};\n \tGD2_DBG (printf (\"%d Chunks vertically\\n\", *ncy));\n \n \tif (gd2_compressed (*fmt)) {\n\t\tif (*ncx <= 0 || *ncy <= 0 || *ncx > INT_MAX / *ncy) {\n\t\t\tGD2_DBG(printf (\"Illegal chunk counts: %d * %d\\n\", *ncx, *ncy));\n\t\t\tgoto fail1;\n\t\t}\n \t\tnc = (*ncx) * (*ncy);\n \n \t\tGD2_DBG (printf (\"Reading %d chunk index entries\\n\", nc));\n\t\tif (overflow2(sizeof(t_chunk_info), nc)) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tsidx = sizeof (t_chunk_info) * nc;\n\t\tif (sidx <= 0) {\n\t\t\tgoto fail1;\n\t\t}\n\n\t\tcidx = gdCalloc (sidx, 1);\n\t\tif (cidx == NULL) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tfor (i = 0; i < nc; i++) {\n\t\t\tif (gdGetInt (&cidx[i].offset, in) != 1) {\n\t\t\t\tgoto fail2;\n\t\t\t};\n\t\t\tif (gdGetInt (&cidx[i].size, in) != 1) {\n\t\t\t\tgoto fail2;\n\t\t\t};\n\t\t\tif (cidx[i].offset < 0 || cidx[i].size < 0)\n\t\t\t\tgoto fail2;\n\t\t};\n\t\t*chunkIdx = cidx;\n\t};\n\n\tGD2_DBG (printf (\"gd2 header complete\\n\"));\n\n\treturn 1;\nfail2:\n\tgdFree(cidx);\nfail1:\n\treturn 0;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144120,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static MagickOffsetType TIFFSeekCustomStream(const MagickOffsetType offset,\n  const int whence,void *user_data)\n{\n  PhotoshopProfile\n    *profile;\n\n  profile=(PhotoshopProfile *) user_data;\n  switch (whence)\n  {\n    case SEEK_SET:\n    default:\n    {\n      if (offset < 0)\n        return(-1);\n      profile->offset=offset;\n      break;\n     }\n     case SEEK_CUR:\n     {\n       if ((profile->offset+offset) < 0)\n         return(-1);\n       profile->offset+=offset;\n      break;\n    }\n    case SEEK_END:\n    {\n      if (((MagickOffsetType) profile->length+offset) < 0)\n        return(-1);\n      profile->offset=profile->length+offset;\n      break;\n    }\n  }\n\n  return(profile->offset);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144177,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static MagickOffsetType TIFFSeekCustomStream(const MagickOffsetType offset,\n  const int whence,void *user_data)\n{\n  PhotoshopProfile\n    *profile;\n\n  profile=(PhotoshopProfile *) user_data;\n  switch (whence)\n  {\n    case SEEK_SET:\n    default:\n    {\n      if (offset < 0)\n        return(-1);\n      profile->offset=offset;\n      break;\n     }\n     case SEEK_CUR:\n     {\n      if (((offset > 0) && (profile->offset > (SSIZE_MAX-offset))) ||\n          ((offset < 0) && (profile->offset < (-SSIZE_MAX-offset))))\n        {\n          errno=EOVERFLOW;\n          return(-1);\n        }\n       if ((profile->offset+offset) < 0)\n         return(-1);\n       profile->offset+=offset;\n      break;\n    }\n    case SEEK_END:\n    {\n      if (((MagickOffsetType) profile->length+offset) < 0)\n        return(-1);\n      profile->offset=profile->length+offset;\n      break;\n    }\n  }\n\n  return(profile->offset);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144178,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static int burl_normalize_2F_to_slash_fix (buffer *b, int qs, int i)\n{\n    char * const s = b->ptr;\n    const int blen = (int)buffer_string_length(b);\n    const int used = qs < 0 ? blen : qs;\n    int j = i;\n    for (; i < used; ++i, ++j) {\n        s[j] = s[i];\n        if (s[i] == '%' && s[i+1] == '2' && s[i+2] == 'F') {\n            s[j] = '/';\n            i+=2;\n         }\n     }\n     if (qs >= 0) {\n        memmove(s+j, s+qs, blen - qs);\n        j += blen - qs;\n     }\n     buffer_string_set_length(b, j);\n     return qs;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144183,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static int burl_normalize_2F_to_slash_fix (buffer *b, int qs, int i)\n{\n    char * const s = b->ptr;\n    const int blen = (int)buffer_string_length(b);\n    const int used = qs < 0 ? blen : qs;\n    int j = i;\n    for (; i < used; ++i, ++j) {\n        s[j] = s[i];\n        if (s[i] == '%' && s[i+1] == '2' && s[i+2] == 'F') {\n            s[j] = '/';\n            i+=2;\n         }\n     }\n     if (qs >= 0) {\n        const int qslen = blen - qs;\n        memmove(s+j, s+qs, (size_t)qslen);\n        qs = j;\n        j += qslen;\n     }\n     buffer_string_set_length(b, j);\n     return qs;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144184,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "bool PPB_ImageData_Impl::Init(PP_ImageDataFormat format,\n                              int width, int height,\n                              bool init_to_zero) {\n  if (!IsImageDataFormatSupported(format))\n     return false;  // Only support this one format for now.\n   if (width <= 0 || height <= 0)\n     return false;\n  if (static_cast<int64>(width) * static_cast<int64>(height) * 4 >=\n      std::numeric_limits<int32>::max())\n     return false;  // Prevent overflow of signed 32-bit ints.\n \n   format_ = format;\n  width_ = width;\n  height_ = height;\n  return backend_->Init(this, format, width, height, init_to_zero);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144215,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "bool PPB_ImageData_Impl::Init(PP_ImageDataFormat format,\n                              int width, int height,\n                              bool init_to_zero) {\n  if (!IsImageDataFormatSupported(format))\n     return false;  // Only support this one format for now.\n   if (width <= 0 || height <= 0)\n     return false;\n  if (static_cast<int64>(width) * static_cast<int64>(height) >=\n      std::numeric_limits<int32>::max() / 4)\n     return false;  // Prevent overflow of signed 32-bit ints.\n \n   format_ = format;\n  width_ = width;\n  height_ = height;\n  return backend_->Init(this, format, width, height, init_to_zero);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144216,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "status_t BnSoundTriggerHwService::onTransact(\n uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags)\n{\n switch(code) {\n\n         case LIST_MODULES: {\n             CHECK_INTERFACE(ISoundTriggerHwService, data, reply);\n             unsigned int numModulesReq = data.readInt32();\n             unsigned int numModules = numModulesReq;\n             struct sound_trigger_module_descriptor *modules =\n                     (struct sound_trigger_module_descriptor *)calloc(numModulesReq,\n                                                    sizeof(struct sound_trigger_module_descriptor));\n             status_t status = listModules(modules, &numModules);\n             reply->writeInt32(status);\n             reply->writeInt32(numModules);\n            ALOGV(\"LIST_MODULES status %d got numModules %d\", status, numModules);\n\n if (status == NO_ERROR) {\n if (numModulesReq > numModules) {\n                    numModulesReq = numModules;\n }\n                reply->write(modules,\n                             numModulesReq * sizeof(struct sound_trigger_module_descriptor));\n }\n            free(modules);\n return NO_ERROR;\n }\n\n case ATTACH: {\n            CHECK_INTERFACE(ISoundTriggerHwService, data, reply);\n sound_trigger_module_handle_t handle;\n            data.read(&handle, sizeof(sound_trigger_module_handle_t));\n            sp<ISoundTriggerClient> client =\n                    interface_cast<ISoundTriggerClient>(data.readStrongBinder());\n            sp<ISoundTrigger> module;\n status_t status = attach(handle, client, module);\n            reply->writeInt32(status);\n if (module != 0) {\n                reply->writeInt32(1);\n                reply->writeStrongBinder(IInterface::asBinder(module));\n } else {\n                reply->writeInt32(0);\n }\n return NO_ERROR;\n } break;\n\n case SET_CAPTURE_STATE: {\n            CHECK_INTERFACE(ISoundTriggerHwService, data, reply);\n            reply->writeInt32(setCaptureState((bool)data.readInt32()));\n return NO_ERROR;\n } break;\n\n default:\n return BBinder::onTransact(code, data, reply, flags);\n }\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144265,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "status_t BnSoundTriggerHwService::onTransact(\n uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags)\n{\n switch(code) {\n\n         case LIST_MODULES: {\n             CHECK_INTERFACE(ISoundTriggerHwService, data, reply);\n             unsigned int numModulesReq = data.readInt32();\n            if (numModulesReq > MAX_ITEMS_PER_LIST) {\n                numModulesReq = MAX_ITEMS_PER_LIST;\n            }\n             unsigned int numModules = numModulesReq;\n             struct sound_trigger_module_descriptor *modules =\n                     (struct sound_trigger_module_descriptor *)calloc(numModulesReq,\n                                                    sizeof(struct sound_trigger_module_descriptor));\n            if (modules == NULL) {\n                reply->writeInt32(NO_MEMORY);\n                reply->writeInt32(0);\n                return NO_ERROR;\n            }\n             status_t status = listModules(modules, &numModules);\n             reply->writeInt32(status);\n             reply->writeInt32(numModules);\n            ALOGV(\"LIST_MODULES status %d got numModules %d\", status, numModules);\n\n if (status == NO_ERROR) {\n if (numModulesReq > numModules) {\n                    numModulesReq = numModules;\n }\n                reply->write(modules,\n                             numModulesReq * sizeof(struct sound_trigger_module_descriptor));\n }\n            free(modules);\n return NO_ERROR;\n }\n\n case ATTACH: {\n            CHECK_INTERFACE(ISoundTriggerHwService, data, reply);\n sound_trigger_module_handle_t handle;\n            data.read(&handle, sizeof(sound_trigger_module_handle_t));\n            sp<ISoundTriggerClient> client =\n                    interface_cast<ISoundTriggerClient>(data.readStrongBinder());\n            sp<ISoundTrigger> module;\n status_t status = attach(handle, client, module);\n            reply->writeInt32(status);\n if (module != 0) {\n                reply->writeInt32(1);\n                reply->writeStrongBinder(IInterface::asBinder(module));\n } else {\n                reply->writeInt32(0);\n }\n return NO_ERROR;\n } break;\n\n case SET_CAPTURE_STATE: {\n            CHECK_INTERFACE(ISoundTriggerHwService, data, reply);\n            reply->writeInt32(setCaptureState((bool)data.readInt32()));\n return NO_ERROR;\n } break;\n\n default:\n return BBinder::onTransact(code, data, reply, flags);\n }\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144266,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "XcursorCommentCreate (XcursorUInt comment_type, int length)\n{\n    XcursorComment  *comment;\n\n    if (length > XCURSOR_COMMENT_MAX_LEN)\n\treturn NULL;\n {\n     XcursorComment  *comment;\n \n    if (length > XCURSOR_COMMENT_MAX_LEN)\n \treturn NULL;\n \n     comment = malloc (sizeof (XcursorComment) + length + 1);\n    comment->comment[0] = '\\0';\n    return comment;\n}\n\nvoid\nXcursorCommentDestroy (XcursorComment *comment)\n{\n    free (comment);\n}\n\nXcursorComments *\nXcursorCommentsCreate (int size)\n{\n    XcursorComments *comments;\n\n    comments = malloc (sizeof (XcursorComments) +\n\t\t       size * sizeof (XcursorComment *));\n    if (!comments)\n\treturn NULL;\n    comments->ncomment = 0;\n    comments->comments = (XcursorComment **) (comments + 1);\n    return comments;\n}\n\nvoid\nXcursorCommentsDestroy (XcursorComments *comments)\n{\n    int\tn;\n\n    if (!comments)\n        return;\n\n    for (n = 0; n < comments->ncomment; n++)\n\tXcursorCommentDestroy (comments->comments[n]);\n    free (comments);\n}\n\nstatic XcursorBool\n_XcursorReadUInt (XcursorFile *file, XcursorUInt *u)\n{\n    unsigned char   bytes[4];\n\n    if (!file || !u)\n        return XcursorFalse;\n\n    if ((*file->read) (file, bytes, 4) != 4)\n\treturn XcursorFalse;\n    *u = ((bytes[0] << 0) |\n\t  (bytes[1] << 8) |\n\t  (bytes[2] << 16) |\n\t  (bytes[3] << 24));\n    return XcursorTrue;\n}\n\nstatic XcursorBool\n_XcursorReadBytes (XcursorFile *file, char *bytes, int length)\n{\n    if (!file || !bytes || (*file->read) (file, (unsigned char *) bytes, length) != length)\n\treturn XcursorFalse;\n    return XcursorTrue;\n}\n\nstatic XcursorBool\n_XcursorWriteUInt (XcursorFile *file, XcursorUInt u)\n{\n    unsigned char   bytes[4];\n\n    if (!file)\n        return XcursorFalse;\n\n    bytes[0] = u;\n    bytes[1] = u >>  8;\n    bytes[2] = u >> 16;\n    bytes[3] = u >> 24;\n    if ((*file->write) (file, bytes, 4) != 4)\n\treturn XcursorFalse;\n    return XcursorTrue;\n}\n\nstatic XcursorBool\n_XcursorWriteBytes (XcursorFile *file, char *bytes, int length)\n{\n    if (!file || !bytes || (*file->write) (file, (unsigned char *) bytes, length) != length)\n\treturn XcursorFalse;\n    return XcursorTrue;\n}\n\nstatic void\n_XcursorFileHeaderDestroy (XcursorFileHeader *fileHeader)\n{\n    free (fileHeader);\n}\n\nstatic XcursorFileHeader *\n_XcursorFileHeaderCreate (XcursorUInt ntoc)\n{\n    XcursorFileHeader\t*fileHeader;\n\n    if (ntoc > 0x10000)\n\treturn NULL;\n    fileHeader = malloc (sizeof (XcursorFileHeader) +\n\t\t\t ntoc * sizeof (XcursorFileToc));\n    if (!fileHeader)\n\treturn NULL;\n    fileHeader->magic = XCURSOR_MAGIC;\n    fileHeader->header = XCURSOR_FILE_HEADER_LEN;\n    fileHeader->version = XCURSOR_FILE_VERSION;\n    fileHeader->ntoc = ntoc;\n    fileHeader->tocs = (XcursorFileToc *) (fileHeader + 1);\n    return fileHeader;\n}\n\nstatic XcursorFileHeader *\n_XcursorReadFileHeader (XcursorFile *file)\n{\n    XcursorFileHeader\thead, *fileHeader;\n    XcursorUInt\t\tskip;\n    int\t\t\tn;\n\n    if (!file)\n        return NULL;\n\n    if (!_XcursorReadUInt (file, &head.magic))\n\treturn NULL;\n    if (head.magic != XCURSOR_MAGIC)\n\treturn NULL;\n    if (!_XcursorReadUInt (file, &head.header))\n\treturn NULL;\n    if (!_XcursorReadUInt (file, &head.version))\n\treturn NULL;\n    if (!_XcursorReadUInt (file, &head.ntoc))\n\treturn NULL;\n    skip = head.header - XCURSOR_FILE_HEADER_LEN;\n    if (skip)\n\tif ((*file->seek) (file, skip, SEEK_CUR) == EOF)\n\t    return NULL;\n    fileHeader = _XcursorFileHeaderCreate (head.ntoc);\n    if (!fileHeader)\n\treturn NULL;\n    fileHeader->magic = head.magic;\n    fileHeader->header = head.header;\n    fileHeader->version = head.version;\n    fileHeader->ntoc = head.ntoc;\n    for (n = 0; n < fileHeader->ntoc; n++)\n    {\n\tif (!_XcursorReadUInt (file, &fileHeader->tocs[n].type))\n\t    break;\n\tif (!_XcursorReadUInt (file, &fileHeader->tocs[n].subtype))\n\t    break;\n\tif (!_XcursorReadUInt (file, &fileHeader->tocs[n].position))\n\t    break;\n    }\n    if (n != fileHeader->ntoc)\n    {\n\t_XcursorFileHeaderDestroy (fileHeader);\n\treturn NULL;\n    }\n    return fileHeader;\n}\n\nstatic XcursorUInt\n_XcursorFileHeaderLength (XcursorFileHeader *fileHeader)\n{\n    return (XCURSOR_FILE_HEADER_LEN +\n\t    fileHeader->ntoc * XCURSOR_FILE_TOC_LEN);\n}\n\nstatic XcursorBool\n_XcursorWriteFileHeader (XcursorFile *file, XcursorFileHeader *fileHeader)\n{\n    int\ttoc;\n\n    if (!file || !fileHeader)\n        return XcursorFalse;\n\n    if (!_XcursorWriteUInt (file, fileHeader->magic))\n\treturn XcursorFalse;\n    if (!_XcursorWriteUInt (file, fileHeader->header))\n\treturn XcursorFalse;\n    if (!_XcursorWriteUInt (file, fileHeader->version))\n\treturn XcursorFalse;\n    if (!_XcursorWriteUInt (file, fileHeader->ntoc))\n\treturn XcursorFalse;\n    for (toc = 0; toc < fileHeader->ntoc; toc++)\n    {\n\tif (!_XcursorWriteUInt (file, fileHeader->tocs[toc].type))\n\t    return XcursorFalse;\n\tif (!_XcursorWriteUInt (file, fileHeader->tocs[toc].subtype))\n\t    return XcursorFalse;\n\tif (!_XcursorWriteUInt (file, fileHeader->tocs[toc].position))\n\t    return XcursorFalse;\n    }\n    return XcursorTrue;\n}\n\nstatic XcursorBool\n_XcursorSeekToToc (XcursorFile\t\t*file,\n\t\t   XcursorFileHeader\t*fileHeader,\n\t\t   int\t\t\ttoc)\n{\n    if (!file || !fileHeader || \\\n        (*file->seek) (file, fileHeader->tocs[toc].position, SEEK_SET) == EOF)\n\treturn XcursorFalse;\n    return XcursorTrue;\n}\n\nstatic XcursorBool\n_XcursorFileReadChunkHeader (XcursorFile\t*file,\n\t\t\t     XcursorFileHeader\t*fileHeader,\n\t\t\t     int\t\ttoc,\n\t\t\t     XcursorChunkHeader\t*chunkHeader)\n{\n    if (!file || !fileHeader || !chunkHeader)\n        return XcursorFalse;\n    if (!_XcursorSeekToToc (file, fileHeader, toc))\n\treturn XcursorFalse;\n    if (!_XcursorReadUInt (file, &chunkHeader->header))\n\treturn XcursorFalse;\n    if (!_XcursorReadUInt (file, &chunkHeader->type))\n\treturn XcursorFalse;\n    if (!_XcursorReadUInt (file, &chunkHeader->subtype))\n\treturn XcursorFalse;\n    if (!_XcursorReadUInt (file, &chunkHeader->version))\n\treturn XcursorFalse;\n    /* sanity check */\n    if (chunkHeader->type != fileHeader->tocs[toc].type ||\n\tchunkHeader->subtype != fileHeader->tocs[toc].subtype)\n\treturn XcursorFalse;\n    return XcursorTrue;\n}\n\nstatic XcursorBool\n_XcursorFileWriteChunkHeader (XcursorFile\t    *file,\n\t\t\t      XcursorFileHeader\t    *fileHeader,\n\t\t\t      int\t\t    toc,\n\t\t\t      XcursorChunkHeader    *chunkHeader)\n{\n    if (!file || !fileHeader || !chunkHeader)\n        return XcursorFalse;\n    if (!_XcursorSeekToToc (file, fileHeader, toc))\n\treturn XcursorFalse;\n    if (!_XcursorWriteUInt (file, chunkHeader->header))\n\treturn XcursorFalse;\n    if (!_XcursorWriteUInt (file, chunkHeader->type))\n\treturn XcursorFalse;\n    if (!_XcursorWriteUInt (file, chunkHeader->subtype))\n\treturn XcursorFalse;\n    if (!_XcursorWriteUInt (file, chunkHeader->version))\n\treturn XcursorFalse;\n    return XcursorTrue;\n}\n\n#define dist(a,b)   ((a) > (b) ? (a) - (b) : (b) - (a))\n\nstatic XcursorDim\n_XcursorFindBestSize (XcursorFileHeader *fileHeader,\n\t\t      XcursorDim\tsize,\n\t\t      int\t\t*nsizesp)\n{\n    int\t\tn;\n    int\t\tnsizes = 0;\n    XcursorDim\tbestSize = 0;\n    XcursorDim\tthisSize;\n\n    if (!fileHeader || !nsizesp)\n        return 0;\n\n    for (n = 0; n < fileHeader->ntoc; n++)\n    {\n\tif (fileHeader->tocs[n].type != XCURSOR_IMAGE_TYPE)\n\t    continue;\n\tthisSize = fileHeader->tocs[n].subtype;\n\tif (!bestSize || dist (thisSize, size) < dist (bestSize, size))\n\t{\n\t    bestSize = thisSize;\n\t    nsizes = 1;\n\t}\n\telse if (thisSize == bestSize)\n\t    nsizes++;\n    }\n    *nsizesp = nsizes;\n    return bestSize;\n}\n\nstatic int\n_XcursorFindImageToc (XcursorFileHeader\t*fileHeader,\n\t\t      XcursorDim\tsize,\n\t\t      int\t\tcount)\n{\n    int\t\t\ttoc;\n    XcursorDim\t\tthisSize;\n\n    if (!fileHeader)\n        return 0;\n\n    for (toc = 0; toc < fileHeader->ntoc; toc++)\n    {\n\tif (fileHeader->tocs[toc].type != XCURSOR_IMAGE_TYPE)\n\t    continue;\n\tthisSize = fileHeader->tocs[toc].subtype;\n\tif (thisSize != size)\n\t    continue;\n\tif (!count)\n\t    break;\n\tcount--;\n    }\n    if (toc == fileHeader->ntoc)\n\treturn -1;\n    return toc;\n}\n\nstatic XcursorImage *\n_XcursorReadImage (XcursorFile\t\t*file,\n\t\t   XcursorFileHeader\t*fileHeader,\n\t\t   int\t\t\ttoc)\n{\n    XcursorChunkHeader\tchunkHeader;\n    XcursorImage\thead;\n    XcursorImage\t*image;\n    int\t\t\tn;\n    XcursorPixel\t*p;\n\n    if (!file || !fileHeader)\n        return NULL;\n\n    if (!_XcursorFileReadChunkHeader (file, fileHeader, toc, &chunkHeader))\n\treturn NULL;\n    if (!_XcursorReadUInt (file, &head.width))\n\treturn NULL;\n    if (!_XcursorReadUInt (file, &head.height))\n\treturn NULL;\n    if (!_XcursorReadUInt (file, &head.xhot))\n\treturn NULL;\n    if (!_XcursorReadUInt (file, &head.yhot))\n\treturn NULL;\n    if (!_XcursorReadUInt (file, &head.delay))\n\treturn NULL;\n    /* sanity check data */\n    if (head.width >= 0x10000 || head.height > 0x10000)\n\treturn NULL;\n     if (!_XcursorReadUInt (file, &head.delay))\n \treturn NULL;\n     /* sanity check data */\n    if (head.width >= 0x10000 || head.height > 0x10000)\n \treturn NULL;\n     if (head.width == 0 || head.height == 0)\n \treturn NULL;\n\timage->version = chunkHeader.version;\n    image->size = chunkHeader.subtype;\n \n     /* Create the image and initialize it */\n     image = XcursorImageCreate (head.width, head.height);\n     if (chunkHeader.version < image->version)\n \timage->version = chunkHeader.version;\n     image->size = chunkHeader.subtype;\n\t{\n\t    XcursorImageDestroy (image);\n\t    return NULL;\n\t}\n\tp++;\n    }\n    return image;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144275,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "XcursorCommentCreate (XcursorUInt comment_type, int length)\n{\n    XcursorComment  *comment;\n\n    if (length > XCURSOR_COMMENT_MAX_LEN)\n\treturn NULL;\n {\n     XcursorComment  *comment;\n \n    if (length < 0 || length > XCURSOR_COMMENT_MAX_LEN)\n \treturn NULL;\n \n     comment = malloc (sizeof (XcursorComment) + length + 1);\n    comment->comment[0] = '\\0';\n    return comment;\n}\n\nvoid\nXcursorCommentDestroy (XcursorComment *comment)\n{\n    free (comment);\n}\n\nXcursorComments *\nXcursorCommentsCreate (int size)\n{\n    XcursorComments *comments;\n\n    comments = malloc (sizeof (XcursorComments) +\n\t\t       size * sizeof (XcursorComment *));\n    if (!comments)\n\treturn NULL;\n    comments->ncomment = 0;\n    comments->comments = (XcursorComment **) (comments + 1);\n    return comments;\n}\n\nvoid\nXcursorCommentsDestroy (XcursorComments *comments)\n{\n    int\tn;\n\n    if (!comments)\n        return;\n\n    for (n = 0; n < comments->ncomment; n++)\n\tXcursorCommentDestroy (comments->comments[n]);\n    free (comments);\n}\n\nstatic XcursorBool\n_XcursorReadUInt (XcursorFile *file, XcursorUInt *u)\n{\n    unsigned char   bytes[4];\n\n    if (!file || !u)\n        return XcursorFalse;\n\n    if ((*file->read) (file, bytes, 4) != 4)\n\treturn XcursorFalse;\n    *u = ((bytes[0] << 0) |\n\t  (bytes[1] << 8) |\n\t  (bytes[2] << 16) |\n\t  (bytes[3] << 24));\n    return XcursorTrue;\n}\n\nstatic XcursorBool\n_XcursorReadBytes (XcursorFile *file, char *bytes, int length)\n{\n    if (!file || !bytes || (*file->read) (file, (unsigned char *) bytes, length) != length)\n\treturn XcursorFalse;\n    return XcursorTrue;\n}\n\nstatic XcursorBool\n_XcursorWriteUInt (XcursorFile *file, XcursorUInt u)\n{\n    unsigned char   bytes[4];\n\n    if (!file)\n        return XcursorFalse;\n\n    bytes[0] = u;\n    bytes[1] = u >>  8;\n    bytes[2] = u >> 16;\n    bytes[3] = u >> 24;\n    if ((*file->write) (file, bytes, 4) != 4)\n\treturn XcursorFalse;\n    return XcursorTrue;\n}\n\nstatic XcursorBool\n_XcursorWriteBytes (XcursorFile *file, char *bytes, int length)\n{\n    if (!file || !bytes || (*file->write) (file, (unsigned char *) bytes, length) != length)\n\treturn XcursorFalse;\n    return XcursorTrue;\n}\n\nstatic void\n_XcursorFileHeaderDestroy (XcursorFileHeader *fileHeader)\n{\n    free (fileHeader);\n}\n\nstatic XcursorFileHeader *\n_XcursorFileHeaderCreate (XcursorUInt ntoc)\n{\n    XcursorFileHeader\t*fileHeader;\n\n    if (ntoc > 0x10000)\n\treturn NULL;\n    fileHeader = malloc (sizeof (XcursorFileHeader) +\n\t\t\t ntoc * sizeof (XcursorFileToc));\n    if (!fileHeader)\n\treturn NULL;\n    fileHeader->magic = XCURSOR_MAGIC;\n    fileHeader->header = XCURSOR_FILE_HEADER_LEN;\n    fileHeader->version = XCURSOR_FILE_VERSION;\n    fileHeader->ntoc = ntoc;\n    fileHeader->tocs = (XcursorFileToc *) (fileHeader + 1);\n    return fileHeader;\n}\n\nstatic XcursorFileHeader *\n_XcursorReadFileHeader (XcursorFile *file)\n{\n    XcursorFileHeader\thead, *fileHeader;\n    XcursorUInt\t\tskip;\n    int\t\t\tn;\n\n    if (!file)\n        return NULL;\n\n    if (!_XcursorReadUInt (file, &head.magic))\n\treturn NULL;\n    if (head.magic != XCURSOR_MAGIC)\n\treturn NULL;\n    if (!_XcursorReadUInt (file, &head.header))\n\treturn NULL;\n    if (!_XcursorReadUInt (file, &head.version))\n\treturn NULL;\n    if (!_XcursorReadUInt (file, &head.ntoc))\n\treturn NULL;\n    skip = head.header - XCURSOR_FILE_HEADER_LEN;\n    if (skip)\n\tif ((*file->seek) (file, skip, SEEK_CUR) == EOF)\n\t    return NULL;\n    fileHeader = _XcursorFileHeaderCreate (head.ntoc);\n    if (!fileHeader)\n\treturn NULL;\n    fileHeader->magic = head.magic;\n    fileHeader->header = head.header;\n    fileHeader->version = head.version;\n    fileHeader->ntoc = head.ntoc;\n    for (n = 0; n < fileHeader->ntoc; n++)\n    {\n\tif (!_XcursorReadUInt (file, &fileHeader->tocs[n].type))\n\t    break;\n\tif (!_XcursorReadUInt (file, &fileHeader->tocs[n].subtype))\n\t    break;\n\tif (!_XcursorReadUInt (file, &fileHeader->tocs[n].position))\n\t    break;\n    }\n    if (n != fileHeader->ntoc)\n    {\n\t_XcursorFileHeaderDestroy (fileHeader);\n\treturn NULL;\n    }\n    return fileHeader;\n}\n\nstatic XcursorUInt\n_XcursorFileHeaderLength (XcursorFileHeader *fileHeader)\n{\n    return (XCURSOR_FILE_HEADER_LEN +\n\t    fileHeader->ntoc * XCURSOR_FILE_TOC_LEN);\n}\n\nstatic XcursorBool\n_XcursorWriteFileHeader (XcursorFile *file, XcursorFileHeader *fileHeader)\n{\n    int\ttoc;\n\n    if (!file || !fileHeader)\n        return XcursorFalse;\n\n    if (!_XcursorWriteUInt (file, fileHeader->magic))\n\treturn XcursorFalse;\n    if (!_XcursorWriteUInt (file, fileHeader->header))\n\treturn XcursorFalse;\n    if (!_XcursorWriteUInt (file, fileHeader->version))\n\treturn XcursorFalse;\n    if (!_XcursorWriteUInt (file, fileHeader->ntoc))\n\treturn XcursorFalse;\n    for (toc = 0; toc < fileHeader->ntoc; toc++)\n    {\n\tif (!_XcursorWriteUInt (file, fileHeader->tocs[toc].type))\n\t    return XcursorFalse;\n\tif (!_XcursorWriteUInt (file, fileHeader->tocs[toc].subtype))\n\t    return XcursorFalse;\n\tif (!_XcursorWriteUInt (file, fileHeader->tocs[toc].position))\n\t    return XcursorFalse;\n    }\n    return XcursorTrue;\n}\n\nstatic XcursorBool\n_XcursorSeekToToc (XcursorFile\t\t*file,\n\t\t   XcursorFileHeader\t*fileHeader,\n\t\t   int\t\t\ttoc)\n{\n    if (!file || !fileHeader || \\\n        (*file->seek) (file, fileHeader->tocs[toc].position, SEEK_SET) == EOF)\n\treturn XcursorFalse;\n    return XcursorTrue;\n}\n\nstatic XcursorBool\n_XcursorFileReadChunkHeader (XcursorFile\t*file,\n\t\t\t     XcursorFileHeader\t*fileHeader,\n\t\t\t     int\t\ttoc,\n\t\t\t     XcursorChunkHeader\t*chunkHeader)\n{\n    if (!file || !fileHeader || !chunkHeader)\n        return XcursorFalse;\n    if (!_XcursorSeekToToc (file, fileHeader, toc))\n\treturn XcursorFalse;\n    if (!_XcursorReadUInt (file, &chunkHeader->header))\n\treturn XcursorFalse;\n    if (!_XcursorReadUInt (file, &chunkHeader->type))\n\treturn XcursorFalse;\n    if (!_XcursorReadUInt (file, &chunkHeader->subtype))\n\treturn XcursorFalse;\n    if (!_XcursorReadUInt (file, &chunkHeader->version))\n\treturn XcursorFalse;\n    /* sanity check */\n    if (chunkHeader->type != fileHeader->tocs[toc].type ||\n\tchunkHeader->subtype != fileHeader->tocs[toc].subtype)\n\treturn XcursorFalse;\n    return XcursorTrue;\n}\n\nstatic XcursorBool\n_XcursorFileWriteChunkHeader (XcursorFile\t    *file,\n\t\t\t      XcursorFileHeader\t    *fileHeader,\n\t\t\t      int\t\t    toc,\n\t\t\t      XcursorChunkHeader    *chunkHeader)\n{\n    if (!file || !fileHeader || !chunkHeader)\n        return XcursorFalse;\n    if (!_XcursorSeekToToc (file, fileHeader, toc))\n\treturn XcursorFalse;\n    if (!_XcursorWriteUInt (file, chunkHeader->header))\n\treturn XcursorFalse;\n    if (!_XcursorWriteUInt (file, chunkHeader->type))\n\treturn XcursorFalse;\n    if (!_XcursorWriteUInt (file, chunkHeader->subtype))\n\treturn XcursorFalse;\n    if (!_XcursorWriteUInt (file, chunkHeader->version))\n\treturn XcursorFalse;\n    return XcursorTrue;\n}\n\n#define dist(a,b)   ((a) > (b) ? (a) - (b) : (b) - (a))\n\nstatic XcursorDim\n_XcursorFindBestSize (XcursorFileHeader *fileHeader,\n\t\t      XcursorDim\tsize,\n\t\t      int\t\t*nsizesp)\n{\n    int\t\tn;\n    int\t\tnsizes = 0;\n    XcursorDim\tbestSize = 0;\n    XcursorDim\tthisSize;\n\n    if (!fileHeader || !nsizesp)\n        return 0;\n\n    for (n = 0; n < fileHeader->ntoc; n++)\n    {\n\tif (fileHeader->tocs[n].type != XCURSOR_IMAGE_TYPE)\n\t    continue;\n\tthisSize = fileHeader->tocs[n].subtype;\n\tif (!bestSize || dist (thisSize, size) < dist (bestSize, size))\n\t{\n\t    bestSize = thisSize;\n\t    nsizes = 1;\n\t}\n\telse if (thisSize == bestSize)\n\t    nsizes++;\n    }\n    *nsizesp = nsizes;\n    return bestSize;\n}\n\nstatic int\n_XcursorFindImageToc (XcursorFileHeader\t*fileHeader,\n\t\t      XcursorDim\tsize,\n\t\t      int\t\tcount)\n{\n    int\t\t\ttoc;\n    XcursorDim\t\tthisSize;\n\n    if (!fileHeader)\n        return 0;\n\n    for (toc = 0; toc < fileHeader->ntoc; toc++)\n    {\n\tif (fileHeader->tocs[toc].type != XCURSOR_IMAGE_TYPE)\n\t    continue;\n\tthisSize = fileHeader->tocs[toc].subtype;\n\tif (thisSize != size)\n\t    continue;\n\tif (!count)\n\t    break;\n\tcount--;\n    }\n    if (toc == fileHeader->ntoc)\n\treturn -1;\n    return toc;\n}\n\nstatic XcursorImage *\n_XcursorReadImage (XcursorFile\t\t*file,\n\t\t   XcursorFileHeader\t*fileHeader,\n\t\t   int\t\t\ttoc)\n{\n    XcursorChunkHeader\tchunkHeader;\n    XcursorImage\thead;\n    XcursorImage\t*image;\n    int\t\t\tn;\n    XcursorPixel\t*p;\n\n    if (!file || !fileHeader)\n        return NULL;\n\n    if (!_XcursorFileReadChunkHeader (file, fileHeader, toc, &chunkHeader))\n\treturn NULL;\n    if (!_XcursorReadUInt (file, &head.width))\n\treturn NULL;\n    if (!_XcursorReadUInt (file, &head.height))\n\treturn NULL;\n    if (!_XcursorReadUInt (file, &head.xhot))\n\treturn NULL;\n    if (!_XcursorReadUInt (file, &head.yhot))\n\treturn NULL;\n    if (!_XcursorReadUInt (file, &head.delay))\n\treturn NULL;\n    /* sanity check data */\n    if (head.width >= 0x10000 || head.height > 0x10000)\n\treturn NULL;\n     if (!_XcursorReadUInt (file, &head.delay))\n \treturn NULL;\n     /* sanity check data */\n    if (head.width > XCURSOR_IMAGE_MAX_SIZE  ||\n\thead.height > XCURSOR_IMAGE_MAX_SIZE)\n \treturn NULL;\n     if (head.width == 0 || head.height == 0)\n \treturn NULL;\n\timage->version = chunkHeader.version;\n    image->size = chunkHeader.subtype;\n \n     /* Create the image and initialize it */\n     image = XcursorImageCreate (head.width, head.height);\n    if (image == NULL)\n\treturn NULL;\n     if (chunkHeader.version < image->version)\n \timage->version = chunkHeader.version;\n     image->size = chunkHeader.subtype;\n\t{\n\t    XcursorImageDestroy (image);\n\t    return NULL;\n\t}\n\tp++;\n    }\n    return image;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144276,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "void net_tx_pkt_init(struct NetTxPkt **pkt, PCIDevice *pci_dev,\n    uint32_t max_frags, bool has_virt_hdr)\n{\n    struct NetTxPkt *p = g_malloc0(sizeof *p);\n \n     p->pci_dev = pci_dev;\n \n    p->vec = g_malloc((sizeof *p->vec) *\n        (max_frags + NET_TX_PKT_PL_START_FRAG));\n \n    p->raw = g_malloc((sizeof *p->raw) * max_frags);\n \n     p->max_payload_frags = max_frags;\n     p->max_raw_frags = max_frags;\n    p->max_raw_frags = max_frags;\n    p->has_virt_hdr = has_virt_hdr;\n    p->vec[NET_TX_PKT_VHDR_FRAG].iov_base = &p->virt_hdr;\n    p->vec[NET_TX_PKT_VHDR_FRAG].iov_len =\n        p->has_virt_hdr ? sizeof p->virt_hdr : 0;\n    p->vec[NET_TX_PKT_L2HDR_FRAG].iov_base = &p->l2_hdr;\n    p->vec[NET_TX_PKT_L3HDR_FRAG].iov_base = &p->l3_hdr;\n\n    *pkt = p;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144331,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "void net_tx_pkt_init(struct NetTxPkt **pkt, PCIDevice *pci_dev,\n    uint32_t max_frags, bool has_virt_hdr)\n{\n    struct NetTxPkt *p = g_malloc0(sizeof *p);\n \n     p->pci_dev = pci_dev;\n \n    p->vec = g_new(struct iovec, max_frags + NET_TX_PKT_PL_START_FRAG);\n \n    p->raw = g_new(struct iovec, max_frags);\n \n     p->max_payload_frags = max_frags;\n     p->max_raw_frags = max_frags;\n    p->max_raw_frags = max_frags;\n    p->has_virt_hdr = has_virt_hdr;\n    p->vec[NET_TX_PKT_VHDR_FRAG].iov_base = &p->virt_hdr;\n    p->vec[NET_TX_PKT_VHDR_FRAG].iov_len =\n        p->has_virt_hdr ? sizeof p->virt_hdr : 0;\n    p->vec[NET_TX_PKT_L2HDR_FRAG].iov_base = &p->l2_hdr;\n    p->vec[NET_TX_PKT_L3HDR_FRAG].iov_base = &p->l3_hdr;\n\n    *pkt = p;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144332,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "Chunk::Chunk( ContainerChunk* parent, RIFF_MetaHandler* handler, bool skip, ChunkType c )\n{\n\tchunkType = c; // base class assumption\n\tthis->parent = parent;\n\tthis->oldSize = 0;\n\tthis->hasChange = false; // [2414649] valid assumption at creation time\n\n\tXMP_IO* file = handler->parent->ioRef;\n \n \tthis->oldPos = file->Offset();\n \tthis->id = XIO::ReadUns32_LE( file );\n\tthis->oldSize = XIO::ReadUns32_LE( file ) + 8;\n \n \tXMP_Int64 chunkEnd = this->oldPos + this->oldSize;\n\tif ( parent != 0 ) chunkLimit = parent->oldPos + parent->oldSize;\n\tif ( chunkEnd > chunkLimit ) {\n\t\tbool isUpdate = XMP_OptionIsSet ( handler->parent->openFlags, kXMPFiles_OpenForUpdate );\n\t\tbool repairFile = XMP_OptionIsSet ( handler->parent->openFlags, kXMPFiles_OpenRepairFile );\n\t\tif ( (! isUpdate) || (repairFile && (parent == 0)) ) {\n\t\t\tthis->oldSize = chunkLimit - this->oldPos;\n\t\t} else {\n\t\t\tXMP_Throw ( \"Bad RIFF chunk size\", kXMPErr_BadFileFormat );\n\t\t}\n\t}\n\n\tthis->newSize = this->oldSize;\n\tthis->needSizeFix = false;\n\n\tif ( skip ) file->Seek ( (this->oldSize - 8), kXMP_SeekFromCurrent );\n\n\tif ( this->parent != NULL )\n\t{\n\t\tthis->parent->children.push_back( this );\n\t\tif( this->chunkType == chunk_VALUE )\n\t\t\tthis->parent->childmap.insert( std::make_pair( this->id, (ValueChunk*) this ) );\n\t}\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144393,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "Chunk::Chunk( ContainerChunk* parent, RIFF_MetaHandler* handler, bool skip, ChunkType c )\n{\n\tchunkType = c; // base class assumption\n\tthis->parent = parent;\n\tthis->oldSize = 0;\n\tthis->hasChange = false; // [2414649] valid assumption at creation time\n\n\tXMP_IO* file = handler->parent->ioRef;\n \n \tthis->oldPos = file->Offset();\n \tthis->id = XIO::ReadUns32_LE( file );\n\tthis->oldSize = XIO::ReadUns32_LE( file );\n\tthis->oldSize += 8;\n \n \tXMP_Int64 chunkEnd = this->oldPos + this->oldSize;\n\tif ( parent != 0 ) chunkLimit = parent->oldPos + parent->oldSize;\n\tif ( chunkEnd > chunkLimit ) {\n\t\tbool isUpdate = XMP_OptionIsSet ( handler->parent->openFlags, kXMPFiles_OpenForUpdate );\n\t\tbool repairFile = XMP_OptionIsSet ( handler->parent->openFlags, kXMPFiles_OpenRepairFile );\n\t\tif ( (! isUpdate) || (repairFile && (parent == 0)) ) {\n\t\t\tthis->oldSize = chunkLimit - this->oldPos;\n\t\t} else {\n\t\t\tXMP_Throw ( \"Bad RIFF chunk size\", kXMPErr_BadFileFormat );\n\t\t}\n\t}\n\n\tthis->newSize = this->oldSize;\n\tthis->needSizeFix = false;\n\n\tif ( skip ) file->Seek ( (this->oldSize - 8), kXMP_SeekFromCurrent );\n\n\tif ( this->parent != NULL )\n\t{\n\t\tthis->parent->children.push_back( this );\n\t\tif( this->chunkType == chunk_VALUE )\n\t\t\tthis->parent->childmap.insert( std::make_pair( this->id, (ValueChunk*) this ) );\n\t}\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144394,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static int cloop_open(BlockDriverState *bs, QDict *options, int flags,\n                      Error **errp)\n{\n    BDRVCloopState *s = bs->opaque;\n    uint32_t offsets_size, max_compressed_block_size = 1, i;\n    int ret;\n\n    bs->read_only = 1;\n\n    /* read header */\n    ret = bdrv_pread(bs->file, 128, &s->block_size, 4);\n    if (ret < 0) {\n        return ret;\n    }\n    s->block_size = be32_to_cpu(s->block_size);\n    if (s->block_size % 512) {\n        error_setg(errp, \"block_size %u must be a multiple of 512\",\n                   s->block_size);\n        return -EINVAL;\n    }\n    if (s->block_size == 0) {\n        error_setg(errp, \"block_size cannot be zero\");\n        return -EINVAL;\n    }\n\n    /* cloop's create_compressed_fs.c warns about block sizes beyond 256 KB but\n     * we can accept more.  Prevent ridiculous values like 4 GB - 1 since we\n     * need a buffer this big.\n     */\n    if (s->block_size > MAX_BLOCK_SIZE) {\n        error_setg(errp, \"block_size %u must be %u MB or less\",\n                   s->block_size,\n                   MAX_BLOCK_SIZE / (1024 * 1024));\n        return -EINVAL;\n    }\n\n    ret = bdrv_pread(bs->file, 128 + 4, &s->n_blocks, 4);\n    if (ret < 0) {\n        return ret;\n    }\n     s->n_blocks = be32_to_cpu(s->n_blocks);\n \n     /* read offsets */\n     offsets_size = s->n_blocks * sizeof(uint64_t);\n     s->offsets = g_malloc(offsets_size);\n        if (i > 0) {\n            uint32_t size = s->offsets[i] - s->offsets[i - 1];\n            if (size > max_compressed_block_size) {\n                max_compressed_block_size = size;\n            }\n        }\n    }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144399,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static int cloop_open(BlockDriverState *bs, QDict *options, int flags,\n                      Error **errp)\n{\n    BDRVCloopState *s = bs->opaque;\n    uint32_t offsets_size, max_compressed_block_size = 1, i;\n    int ret;\n\n    bs->read_only = 1;\n\n    /* read header */\n    ret = bdrv_pread(bs->file, 128, &s->block_size, 4);\n    if (ret < 0) {\n        return ret;\n    }\n    s->block_size = be32_to_cpu(s->block_size);\n    if (s->block_size % 512) {\n        error_setg(errp, \"block_size %u must be a multiple of 512\",\n                   s->block_size);\n        return -EINVAL;\n    }\n    if (s->block_size == 0) {\n        error_setg(errp, \"block_size cannot be zero\");\n        return -EINVAL;\n    }\n\n    /* cloop's create_compressed_fs.c warns about block sizes beyond 256 KB but\n     * we can accept more.  Prevent ridiculous values like 4 GB - 1 since we\n     * need a buffer this big.\n     */\n    if (s->block_size > MAX_BLOCK_SIZE) {\n        error_setg(errp, \"block_size %u must be %u MB or less\",\n                   s->block_size,\n                   MAX_BLOCK_SIZE / (1024 * 1024));\n        return -EINVAL;\n    }\n\n    ret = bdrv_pread(bs->file, 128 + 4, &s->n_blocks, 4);\n    if (ret < 0) {\n        return ret;\n    }\n     s->n_blocks = be32_to_cpu(s->n_blocks);\n \n     /* read offsets */\n    if (s->n_blocks > UINT32_MAX / sizeof(uint64_t)) {\n        /* Prevent integer overflow */\n        error_setg(errp, \"n_blocks %u must be %zu or less\",\n                   s->n_blocks,\n                   UINT32_MAX / sizeof(uint64_t));\n        return -EINVAL;\n    }\n     offsets_size = s->n_blocks * sizeof(uint64_t);\n     s->offsets = g_malloc(offsets_size);\n        if (i > 0) {\n            uint32_t size = s->offsets[i] - s->offsets[i - 1];\n            if (size > max_compressed_block_size) {\n                max_compressed_block_size = size;\n            }\n        }\n    }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144400,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static int bochs_open(BlockDriverState *bs, QDict *options, int flags,\n                      Error **errp)\n{\n    BDRVBochsState *s = bs->opaque;\n    uint32_t i;\n    struct bochs_header bochs;\n    int ret;\n\n    bs->read_only = 1; // no write support yet\n\n    ret = bdrv_pread(bs->file, 0, &bochs, sizeof(bochs));\n    if (ret < 0) {\n        return ret;\n    }\n\n    if (strcmp(bochs.magic, HEADER_MAGIC) ||\n        strcmp(bochs.type, REDOLOG_TYPE) ||\n        strcmp(bochs.subtype, GROWING_TYPE) ||\n\t((le32_to_cpu(bochs.version) != HEADER_VERSION) &&\n\t(le32_to_cpu(bochs.version) != HEADER_V1))) {\n        error_setg(errp, \"Image not in Bochs format\");\n        return -EINVAL;\n    }\n\n    if (le32_to_cpu(bochs.version) == HEADER_V1) {\n        bs->total_sectors = le64_to_cpu(bochs.extra.redolog_v1.disk) / 512;\n    } else {\n         bs->total_sectors = le64_to_cpu(bochs.extra.redolog.disk) / 512;\n     }\n \n     s->catalog_size = le32_to_cpu(bochs.catalog);\n     s->catalog_bitmap = g_malloc(s->catalog_size * 4);\n \n     ret = bdrv_pread(bs->file, le32_to_cpu(bochs.header), s->catalog_bitmap,\n\n    s->data_offset = le32_to_cpu(bochs.header) + (s->catalog_size * 4);\n\n    s->bitmap_blocks = 1 + (le32_to_cpu(bochs.bitmap) - 1) / 512;\n    s->extent_blocks = 1 + (le32_to_cpu(bochs.extent) - 1) / 512;\n\n    s->extent_size = le32_to_cpu(bochs.extent);\n\n    qemu_co_mutex_init(&s->lock);\n    return 0;\n\nfail:\n \n     s->extent_size = le32_to_cpu(bochs.extent);\n \n     qemu_co_mutex_init(&s->lock);\n     return 0;\n    extent_index = offset / s->extent_size;\n    extent_offset = (offset % s->extent_size) / 512;\n\n    if (s->catalog_bitmap[extent_index] == 0xffffffff) {\n\treturn -1; /* not allocated */\n    }\n\n    bitmap_offset = s->data_offset + (512 * s->catalog_bitmap[extent_index] *\n\t(s->extent_blocks + s->bitmap_blocks));\n\n    /* read in bitmap for current extent */\n    if (bdrv_pread(bs->file, bitmap_offset + (extent_offset / 8),\n                   &bitmap_entry, 1) != 1) {\n        return -1;\n    }\n\n    if (!((bitmap_entry >> (extent_offset % 8)) & 1)) {\n\treturn -1; /* not allocated */\n    }\n\n    return bitmap_offset + (512 * (s->bitmap_blocks + extent_offset));\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144401,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static int bochs_open(BlockDriverState *bs, QDict *options, int flags,\n                      Error **errp)\n{\n    BDRVBochsState *s = bs->opaque;\n    uint32_t i;\n    struct bochs_header bochs;\n    int ret;\n\n    bs->read_only = 1; // no write support yet\n\n    ret = bdrv_pread(bs->file, 0, &bochs, sizeof(bochs));\n    if (ret < 0) {\n        return ret;\n    }\n\n    if (strcmp(bochs.magic, HEADER_MAGIC) ||\n        strcmp(bochs.type, REDOLOG_TYPE) ||\n        strcmp(bochs.subtype, GROWING_TYPE) ||\n\t((le32_to_cpu(bochs.version) != HEADER_VERSION) &&\n\t(le32_to_cpu(bochs.version) != HEADER_V1))) {\n        error_setg(errp, \"Image not in Bochs format\");\n        return -EINVAL;\n    }\n\n    if (le32_to_cpu(bochs.version) == HEADER_V1) {\n        bs->total_sectors = le64_to_cpu(bochs.extra.redolog_v1.disk) / 512;\n    } else {\n         bs->total_sectors = le64_to_cpu(bochs.extra.redolog.disk) / 512;\n     }\n \n    /* Limit to 1M entries to avoid unbounded allocation. This is what is\n     * needed for the largest image that bximage can create (~8 TB). */\n     s->catalog_size = le32_to_cpu(bochs.catalog);\n    if (s->catalog_size > 0x100000) {\n        error_setg(errp, \"Catalog size is too large\");\n        return -EFBIG;\n    }\n\n     s->catalog_bitmap = g_malloc(s->catalog_size * 4);\n \n     ret = bdrv_pread(bs->file, le32_to_cpu(bochs.header), s->catalog_bitmap,\n\n    s->data_offset = le32_to_cpu(bochs.header) + (s->catalog_size * 4);\n\n    s->bitmap_blocks = 1 + (le32_to_cpu(bochs.bitmap) - 1) / 512;\n    s->extent_blocks = 1 + (le32_to_cpu(bochs.extent) - 1) / 512;\n\n    s->extent_size = le32_to_cpu(bochs.extent);\n\n    qemu_co_mutex_init(&s->lock);\n    return 0;\n\nfail:\n \n     s->extent_size = le32_to_cpu(bochs.extent);\n \n    if (s->catalog_size < bs->total_sectors / s->extent_size) {\n        error_setg(errp, \"Catalog size is too small for this disk size\");\n        ret = -EINVAL;\n        goto fail;\n    }\n\n     qemu_co_mutex_init(&s->lock);\n     return 0;\n    extent_index = offset / s->extent_size;\n    extent_offset = (offset % s->extent_size) / 512;\n\n    if (s->catalog_bitmap[extent_index] == 0xffffffff) {\n\treturn -1; /* not allocated */\n    }\n\n    bitmap_offset = s->data_offset + (512 * s->catalog_bitmap[extent_index] *\n\t(s->extent_blocks + s->bitmap_blocks));\n\n    /* read in bitmap for current extent */\n    if (bdrv_pread(bs->file, bitmap_offset + (extent_offset / 8),\n                   &bitmap_entry, 1) != 1) {\n        return -1;\n    }\n\n    if (!((bitmap_entry >> (extent_offset % 8)) & 1)) {\n\treturn -1; /* not allocated */\n    }\n\n    return bitmap_offset + (512 * (s->bitmap_blocks + extent_offset));\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144402,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": " static int get_refcount(BlockDriverState *bs, int64_t cluster_index)\n {\n     BDRVQcowState *s = bs->opaque;\n    int refcount_table_index, block_index;\n     int64_t refcount_block_offset;\n     int ret;\n     uint16_t *refcount_block;\n    uint16_t refcount;\n\n    refcount_table_index = cluster_index >> (s->cluster_bits - REFCOUNT_SHIFT);\n    if (refcount_table_index >= s->refcount_table_size)\n        return 0;\n    refcount_block_offset =\n        s->refcount_table[refcount_table_index] & REFT_OFFSET_MASK;\n    if (!refcount_block_offset)\n        return 0;\n\n    ret = qcow2_cache_get(bs, s->refcount_block_cache, refcount_block_offset,\n        (void**) &refcount_block);\n    if (ret < 0) {\n        return ret;\n    }\n\n    block_index = cluster_index &\n        ((1 << (s->cluster_bits - REFCOUNT_SHIFT)) - 1);\n    refcount = be16_to_cpu(refcount_block[block_index]);\n\n    ret = qcow2_cache_put(bs, s->refcount_block_cache,\n        (void**) &refcount_block);\n    if (ret < 0) {\n        return ret;\n    }\n\n    return refcount;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144403,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": " static int get_refcount(BlockDriverState *bs, int64_t cluster_index)\n {\n     BDRVQcowState *s = bs->opaque;\n    uint64_t refcount_table_index, block_index;\n     int64_t refcount_block_offset;\n     int ret;\n     uint16_t *refcount_block;\n    uint16_t refcount;\n\n    refcount_table_index = cluster_index >> (s->cluster_bits - REFCOUNT_SHIFT);\n    if (refcount_table_index >= s->refcount_table_size)\n        return 0;\n    refcount_block_offset =\n        s->refcount_table[refcount_table_index] & REFT_OFFSET_MASK;\n    if (!refcount_block_offset)\n        return 0;\n\n    ret = qcow2_cache_get(bs, s->refcount_block_cache, refcount_block_offset,\n        (void**) &refcount_block);\n    if (ret < 0) {\n        return ret;\n    }\n\n    block_index = cluster_index &\n        ((1 << (s->cluster_bits - REFCOUNT_SHIFT)) - 1);\n    refcount = be16_to_cpu(refcount_block[block_index]);\n\n    ret = qcow2_cache_put(bs, s->refcount_block_cache,\n        (void**) &refcount_block);\n    if (ret < 0) {\n        return ret;\n    }\n\n    return refcount;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144404,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "int qcow2_snapshot_load_tmp(BlockDriverState *bs,\n                            const char *snapshot_id,\n                            const char *name,\n                            Error **errp)\n{\n    int i, snapshot_index;\n    BDRVQcowState *s = bs->opaque;\n    QCowSnapshot *sn;\n    uint64_t *new_l1_table;\n    int new_l1_bytes;\n    int ret;\n\n    assert(bs->read_only);\n\n    /* Search the snapshot */\n    snapshot_index = find_snapshot_by_id_and_name(bs, snapshot_id, name);\n    if (snapshot_index < 0) {\n        error_setg(errp,\n                   \"Can't find snapshot\");\n        return -ENOENT;\n    }\n     sn = &s->snapshots[snapshot_index];\n \n     /* Allocate and read in the snapshot's L1 table */\n     new_l1_bytes = sn->l1_size * sizeof(uint64_t);\n     new_l1_table = g_malloc0(align_offset(new_l1_bytes, 512));\n        return ret;\n    }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144405,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "int qcow2_snapshot_load_tmp(BlockDriverState *bs,\n                            const char *snapshot_id,\n                            const char *name,\n                            Error **errp)\n{\n    int i, snapshot_index;\n    BDRVQcowState *s = bs->opaque;\n    QCowSnapshot *sn;\n    uint64_t *new_l1_table;\n    int new_l1_bytes;\n    int ret;\n\n    assert(bs->read_only);\n\n    /* Search the snapshot */\n    snapshot_index = find_snapshot_by_id_and_name(bs, snapshot_id, name);\n    if (snapshot_index < 0) {\n        error_setg(errp,\n                   \"Can't find snapshot\");\n        return -ENOENT;\n    }\n     sn = &s->snapshots[snapshot_index];\n \n     /* Allocate and read in the snapshot's L1 table */\n    if (sn->l1_size > QCOW_MAX_L1_SIZE) {\n        error_setg(errp, \"Snapshot L1 table too large\");\n        return -EFBIG;\n    }\n     new_l1_bytes = sn->l1_size * sizeof(uint64_t);\n     new_l1_table = g_malloc0(align_offset(new_l1_bytes, 512));\n        return ret;\n    }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144406,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": " static int bdrv_check_request(BlockDriverState *bs, int64_t sector_num,\n                               int nb_sectors)\n {\n     return bdrv_check_byte_request(bs, sector_num * BDRV_SECTOR_SIZE,\n                                    nb_sectors * BDRV_SECTOR_SIZE);\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144407,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": " static int bdrv_check_request(BlockDriverState *bs, int64_t sector_num,\n                               int nb_sectors)\n {\n    if (nb_sectors > INT_MAX / BDRV_SECTOR_SIZE) {\n        return -EIO;\n    }\n\n     return bdrv_check_byte_request(bs, sector_num * BDRV_SECTOR_SIZE,\n                                    nb_sectors * BDRV_SECTOR_SIZE);\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144408,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "int qcow2_grow_l1_table(BlockDriverState *bs, uint64_t min_size,\n                        bool exact_size)\n{\n    BDRVQcowState *s = bs->opaque;\n    int new_l1_size2, ret, i;\n    uint64_t *new_l1_table;\n    int64_t old_l1_table_offset, old_l1_size;\n    int64_t new_l1_table_offset, new_l1_size;\n    uint8_t data[12];\n\n    if (min_size <= s->l1_size)\n        return 0;\n\n    if (exact_size) {\n        new_l1_size = min_size;\n    } else {\n        /* Bump size up to reduce the number of times we have to grow */\n        new_l1_size = s->l1_size;\n        if (new_l1_size == 0) {\n            new_l1_size = 1;\n        }\n        while (min_size > new_l1_size) {\n            new_l1_size = (new_l1_size * 3 + 1) / 2;\n         }\n     }\n \n    if (new_l1_size > INT_MAX) {\n         return -EFBIG;\n     }\n#ifdef DEBUG_ALLOC2\n    fprintf(stderr, \"grow l1_table from %d to %\" PRId64 \"\\n\",\n            s->l1_size, new_l1_size);\n#endif\n\n    new_l1_size2 = sizeof(uint64_t) * new_l1_size;\n    new_l1_table = g_malloc0(align_offset(new_l1_size2, 512));\n    memcpy(new_l1_table, s->l1_table, s->l1_size * sizeof(uint64_t));\n\n    /* write new table (align to cluster) */\n    BLKDBG_EVENT(bs->file, BLKDBG_L1_GROW_ALLOC_TABLE);\n    new_l1_table_offset = qcow2_alloc_clusters(bs, new_l1_size2);\n    if (new_l1_table_offset < 0) {\n        g_free(new_l1_table);\n        return new_l1_table_offset;\n    }\n\n    ret = qcow2_cache_flush(bs, s->refcount_block_cache);\n    if (ret < 0) {\n        goto fail;\n    }\n\n    /* the L1 position has not yet been updated, so these clusters must\n     * indeed be completely free */\n    ret = qcow2_pre_write_overlap_check(bs, 0, new_l1_table_offset,\n                                        new_l1_size2);\n    if (ret < 0) {\n        goto fail;\n    }\n\n    BLKDBG_EVENT(bs->file, BLKDBG_L1_GROW_WRITE_TABLE);\n    for(i = 0; i < s->l1_size; i++)\n        new_l1_table[i] = cpu_to_be64(new_l1_table[i]);\n    ret = bdrv_pwrite_sync(bs->file, new_l1_table_offset, new_l1_table, new_l1_size2);\n    if (ret < 0)\n        goto fail;\n    for(i = 0; i < s->l1_size; i++)\n        new_l1_table[i] = be64_to_cpu(new_l1_table[i]);\n\n    /* set new table */\n    BLKDBG_EVENT(bs->file, BLKDBG_L1_GROW_ACTIVATE_TABLE);\n    cpu_to_be32w((uint32_t*)data, new_l1_size);\n    stq_be_p(data + 4, new_l1_table_offset);\n    ret = bdrv_pwrite_sync(bs->file, offsetof(QCowHeader, l1_size), data,sizeof(data));\n    if (ret < 0) {\n        goto fail;\n    }\n    g_free(s->l1_table);\n    old_l1_table_offset = s->l1_table_offset;\n    s->l1_table_offset = new_l1_table_offset;\n    s->l1_table = new_l1_table;\n    old_l1_size = s->l1_size;\n    s->l1_size = new_l1_size;\n    qcow2_free_clusters(bs, old_l1_table_offset, old_l1_size * sizeof(uint64_t),\n                        QCOW2_DISCARD_OTHER);\n    return 0;\n fail:\n    g_free(new_l1_table);\n    qcow2_free_clusters(bs, new_l1_table_offset, new_l1_size2,\n                        QCOW2_DISCARD_OTHER);\n    return ret;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144409,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "int qcow2_grow_l1_table(BlockDriverState *bs, uint64_t min_size,\n                        bool exact_size)\n{\n    BDRVQcowState *s = bs->opaque;\n    int new_l1_size2, ret, i;\n    uint64_t *new_l1_table;\n    int64_t old_l1_table_offset, old_l1_size;\n    int64_t new_l1_table_offset, new_l1_size;\n    uint8_t data[12];\n\n    if (min_size <= s->l1_size)\n        return 0;\n\n    if (exact_size) {\n        new_l1_size = min_size;\n    } else {\n        /* Bump size up to reduce the number of times we have to grow */\n        new_l1_size = s->l1_size;\n        if (new_l1_size == 0) {\n            new_l1_size = 1;\n        }\n        while (min_size > new_l1_size) {\n            new_l1_size = (new_l1_size * 3 + 1) / 2;\n         }\n     }\n \n    if (new_l1_size > INT_MAX / sizeof(uint64_t)) {\n         return -EFBIG;\n     }\n#ifdef DEBUG_ALLOC2\n    fprintf(stderr, \"grow l1_table from %d to %\" PRId64 \"\\n\",\n            s->l1_size, new_l1_size);\n#endif\n\n    new_l1_size2 = sizeof(uint64_t) * new_l1_size;\n    new_l1_table = g_malloc0(align_offset(new_l1_size2, 512));\n    memcpy(new_l1_table, s->l1_table, s->l1_size * sizeof(uint64_t));\n\n    /* write new table (align to cluster) */\n    BLKDBG_EVENT(bs->file, BLKDBG_L1_GROW_ALLOC_TABLE);\n    new_l1_table_offset = qcow2_alloc_clusters(bs, new_l1_size2);\n    if (new_l1_table_offset < 0) {\n        g_free(new_l1_table);\n        return new_l1_table_offset;\n    }\n\n    ret = qcow2_cache_flush(bs, s->refcount_block_cache);\n    if (ret < 0) {\n        goto fail;\n    }\n\n    /* the L1 position has not yet been updated, so these clusters must\n     * indeed be completely free */\n    ret = qcow2_pre_write_overlap_check(bs, 0, new_l1_table_offset,\n                                        new_l1_size2);\n    if (ret < 0) {\n        goto fail;\n    }\n\n    BLKDBG_EVENT(bs->file, BLKDBG_L1_GROW_WRITE_TABLE);\n    for(i = 0; i < s->l1_size; i++)\n        new_l1_table[i] = cpu_to_be64(new_l1_table[i]);\n    ret = bdrv_pwrite_sync(bs->file, new_l1_table_offset, new_l1_table, new_l1_size2);\n    if (ret < 0)\n        goto fail;\n    for(i = 0; i < s->l1_size; i++)\n        new_l1_table[i] = be64_to_cpu(new_l1_table[i]);\n\n    /* set new table */\n    BLKDBG_EVENT(bs->file, BLKDBG_L1_GROW_ACTIVATE_TABLE);\n    cpu_to_be32w((uint32_t*)data, new_l1_size);\n    stq_be_p(data + 4, new_l1_table_offset);\n    ret = bdrv_pwrite_sync(bs->file, offsetof(QCowHeader, l1_size), data,sizeof(data));\n    if (ret < 0) {\n        goto fail;\n    }\n    g_free(s->l1_table);\n    old_l1_table_offset = s->l1_table_offset;\n    s->l1_table_offset = new_l1_table_offset;\n    s->l1_table = new_l1_table;\n    old_l1_size = s->l1_size;\n    s->l1_size = new_l1_size;\n    qcow2_free_clusters(bs, old_l1_table_offset, old_l1_size * sizeof(uint64_t),\n                        QCOW2_DISCARD_OTHER);\n    return 0;\n fail:\n    g_free(new_l1_table);\n    qcow2_free_clusters(bs, new_l1_table_offset, new_l1_size2,\n                        QCOW2_DISCARD_OTHER);\n    return ret;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144410,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static int b_unpack (lua_State *L) {\n  Header h;\n   const char *fmt = luaL_checkstring(L, 1);\n   size_t ld;\n   const char *data = luaL_checklstring(L, 2, &ld);\n  size_t pos = luaL_optinteger(L, 3, 1) - 1;\n   int n = 0;  /* number of results */\n   defaultoptions(&h);\n   while (*fmt) {\n     int opt = *fmt++;\n     size_t size = optsize(L, opt, &fmt);\n     pos += gettoalign(pos, &h, opt, size);\n    luaL_argcheck(L, pos+size <= ld, 2, \"data string too short\");\n     /* stack space for item + next position */\n     luaL_checkstack(L, 2, \"too many results\");\n     switch (opt) {\n      case 'b': case 'B': case 'h': case 'H':\n      case 'l': case 'L': case 'T': case 'i':  case 'I': {  /* integer types */\n        int issigned = islower(opt);\n        lua_Number res = getinteger(data+pos, h.endian, issigned, size);\n        lua_pushnumber(L, res); n++;\n        break;\n      }\n      case 'x': {\n        break;\n      }\n      case 'f': {\n        float f;\n        memcpy(&f, data+pos, size);\n        correctbytes((char *)&f, sizeof(f), h.endian);\n        lua_pushnumber(L, f); n++;\n        break;\n      }\n      case 'd': {\n        double d;\n        memcpy(&d, data+pos, size);\n        correctbytes((char *)&d, sizeof(d), h.endian);\n        lua_pushnumber(L, d); n++;\n        break;\n      }\n      case 'c': {\n        if (size == 0) {\n          if (n == 0 || !lua_isnumber(L, -1))\n            luaL_error(L, \"format 'c0' needs a previous size\");\n          size = lua_tonumber(L, -1);\n          lua_pop(L, 1); n--;\n          luaL_argcheck(L, size <= ld && pos <= ld - size,\n                           2, \"data string too short\");\n        }\n        lua_pushlstring(L, data+pos, size); n++;\n        break;\n      }\n      case 's': {\n        const char *e = (const char *)memchr(data+pos, '\\0', ld - pos);\n        if (e == NULL)\n          luaL_error(L, \"unfinished string in data\");\n        size = (e - (data+pos)) + 1;\n        lua_pushlstring(L, data+pos, size - 1); n++;\n        break;\n      }\n      default: controloptions(L, opt, &fmt, &h);\n    }\n    pos += size;\n  }\n  lua_pushinteger(L, pos + 1);  /* next position */\n  return n + 1;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144447,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static int b_unpack (lua_State *L) {\n  Header h;\n   const char *fmt = luaL_checkstring(L, 1);\n   size_t ld;\n   const char *data = luaL_checklstring(L, 2, &ld);\n  size_t pos = luaL_optinteger(L, 3, 1);\n  luaL_argcheck(L, pos > 0, 3, \"offset must be 1 or greater\");\n  pos--; /* Lua indexes are 1-based, but here we want 0-based for C\n          * pointer math. */\n   int n = 0;  /* number of results */\n   defaultoptions(&h);\n   while (*fmt) {\n     int opt = *fmt++;\n     size_t size = optsize(L, opt, &fmt);\n     pos += gettoalign(pos, &h, opt, size);\n    luaL_argcheck(L, size <= ld && pos <= ld - size,\n                   2, \"data string too short\");\n     /* stack space for item + next position */\n     luaL_checkstack(L, 2, \"too many results\");\n     switch (opt) {\n      case 'b': case 'B': case 'h': case 'H':\n      case 'l': case 'L': case 'T': case 'i':  case 'I': {  /* integer types */\n        int issigned = islower(opt);\n        lua_Number res = getinteger(data+pos, h.endian, issigned, size);\n        lua_pushnumber(L, res); n++;\n        break;\n      }\n      case 'x': {\n        break;\n      }\n      case 'f': {\n        float f;\n        memcpy(&f, data+pos, size);\n        correctbytes((char *)&f, sizeof(f), h.endian);\n        lua_pushnumber(L, f); n++;\n        break;\n      }\n      case 'd': {\n        double d;\n        memcpy(&d, data+pos, size);\n        correctbytes((char *)&d, sizeof(d), h.endian);\n        lua_pushnumber(L, d); n++;\n        break;\n      }\n      case 'c': {\n        if (size == 0) {\n          if (n == 0 || !lua_isnumber(L, -1))\n            luaL_error(L, \"format 'c0' needs a previous size\");\n          size = lua_tonumber(L, -1);\n          lua_pop(L, 1); n--;\n          luaL_argcheck(L, size <= ld && pos <= ld - size,\n                           2, \"data string too short\");\n        }\n        lua_pushlstring(L, data+pos, size); n++;\n        break;\n      }\n      case 's': {\n        const char *e = (const char *)memchr(data+pos, '\\0', ld - pos);\n        if (e == NULL)\n          luaL_error(L, \"unfinished string in data\");\n        size = (e - (data+pos)) + 1;\n        lua_pushlstring(L, data+pos, size - 1); n++;\n        break;\n      }\n      default: controloptions(L, opt, &fmt, &h);\n    }\n    pos += size;\n  }\n  lua_pushinteger(L, pos + 1);  /* next position */\n  return n + 1;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144448,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static int getnum (lua_State *L, const char **fmt, int df) {\n   if (!isdigit(**fmt))  /* no number? */\n     return df;  /* return default value */\n   else {\n     int a = 0;\n     do {\n      if (a > (INT_MAX / 10) || a * 10 > (INT_MAX - (**fmt - '0')))\n        luaL_error(L, \"integral size overflow\");\n       a = a*10 + *((*fmt)++) - '0';\n     } while (isdigit(**fmt));\n     return a;\n  }\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144471,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static int getnum (lua_State *L, const char **fmt, int df) {\nstatic int getnum (const char **fmt, int df) {\n   if (!isdigit(**fmt))  /* no number? */\n     return df;  /* return default value */\n   else {\n     int a = 0;\n     do {\n       a = a*10 + *((*fmt)++) - '0';\n     } while (isdigit(**fmt));\n     return a;\n  }\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144472,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "size_t jsuGetFreeStack() {\n#ifdef ARM\n  void *frame = __builtin_frame_address(0);\n  size_t stackPos = (size_t)((char*)frame);\n  size_t stackEnd = (size_t)((char*)&LINKER_END_VAR);\n  if (stackPos < stackEnd) return 0; // should never happen, but just in case of overflow!\n  return  stackPos - stackEnd;\n#elif defined(LINUX)\n  // On linux, we set STACK_BASE from `main`.\n  char ptr; // this is on the stack\n  extern void *STACK_BASE;\n  uint32_t count =  (uint32_t)((size_t)STACK_BASE - (size_t)&ptr);\n  return 1000000 - count; // give it 1 megabyte of stack\n#else\n  // stack depth seems pretty platform-specific :( Default to a value that disables it\n  return 1000000; // no stack depth check on this platform\n#endif\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144485,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "size_t jsuGetFreeStack() {\n#ifdef ARM\n  void *frame = __builtin_frame_address(0);\n  size_t stackPos = (size_t)((char*)frame);\n  size_t stackEnd = (size_t)((char*)&LINKER_END_VAR);\n  if (stackPos < stackEnd) return 0; // should never happen, but just in case of overflow!\n  return  stackPos - stackEnd;\n#elif defined(LINUX)\n   char ptr; // this is on the stack\n   extern void *STACK_BASE;\n   uint32_t count =  (uint32_t)((size_t)STACK_BASE - (size_t)&ptr);\n  const uint32_t max_stack = 1000000; // give it 1 megabyte of stack\n  if (count>max_stack) return 0;\n  return max_stack - count;\n #else\n   return 1000000; // no stack depth check on this platform\n#endif\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144486,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static int parallels_open(BlockDriverState *bs, QDict *options, int flags,\n                          Error **errp)\n{\n    BDRVParallelsState *s = bs->opaque;\n    int i;\n    struct parallels_header ph;\n    int ret;\n\n    bs->read_only = 1; // no write support yet\n\n    ret = bdrv_pread(bs->file, 0, &ph, sizeof(ph));\n    if (ret < 0) {\n        goto fail;\n    }\n\n    if (memcmp(ph.magic, HEADER_MAGIC, 16) ||\n        (le32_to_cpu(ph.version) != HEADER_VERSION)) {\n        error_setg(errp, \"Image not in Parallels format\");\n        ret = -EINVAL;\n        goto fail;\n    }\n\n    bs->total_sectors = le32_to_cpu(ph.nb_sectors);\n\n    s->tracks = le32_to_cpu(ph.tracks);\n\n    s->catalog_size = le32_to_cpu(ph.catalog_entries);\n    s->catalog_bitmap = g_malloc(s->catalog_size * 4);\n\n    ret = bdrv_pread(bs->file, 64, s->catalog_bitmap, s->catalog_size * 4);\n    if (ret < 0) {\n        goto fail;\n    }\n\n    for (i = 0; i < s->catalog_size; i++)\n\tle32_to_cpus(&s->catalog_bitmap[i]);\n\n    qemu_co_mutex_init(&s->lock);\n    return 0;\n\nfail:\n    g_free(s->catalog_bitmap);\n    return ret;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144491,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static int parallels_open(BlockDriverState *bs, QDict *options, int flags,\n                          Error **errp)\n{\n    BDRVParallelsState *s = bs->opaque;\n    int i;\n    struct parallels_header ph;\n    int ret;\n\n    bs->read_only = 1; // no write support yet\n\n    ret = bdrv_pread(bs->file, 0, &ph, sizeof(ph));\n    if (ret < 0) {\n        goto fail;\n    }\n\n    if (memcmp(ph.magic, HEADER_MAGIC, 16) ||\n        (le32_to_cpu(ph.version) != HEADER_VERSION)) {\n        error_setg(errp, \"Image not in Parallels format\");\n        ret = -EINVAL;\n        goto fail;\n    }\n\n    bs->total_sectors = le32_to_cpu(ph.nb_sectors);\n\n     s->tracks = le32_to_cpu(ph.tracks);\n \n     s->catalog_size = le32_to_cpu(ph.catalog_entries);\n    if (s->catalog_size > INT_MAX / 4) {\n        error_setg(errp, \"Catalog too large\");\n        ret = -EFBIG;\n        goto fail;\n    }\n     s->catalog_bitmap = g_malloc(s->catalog_size * 4);\n \n     ret = bdrv_pread(bs->file, 64, s->catalog_bitmap, s->catalog_size * 4);\n\tle32_to_cpus(&s->catalog_bitmap[i]);\n\n    qemu_co_mutex_init(&s->lock);\n    return 0;\n\nfail:\n    g_free(s->catalog_bitmap);\n    return ret;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144492,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static pngquant_error rwpng_read_image24_libpng(FILE *infile, png24_image *mainprog_ptr, int verbose)\n{\n    png_structp  png_ptr = NULL;\n    png_infop    info_ptr = NULL;\n    png_size_t   rowbytes;\n    int          color_type, bit_depth;\n\n    png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, mainprog_ptr,\n      rwpng_error_handler, verbose ? rwpng_warning_stderr_handler : rwpng_warning_silent_handler);\n    if (!png_ptr) {\n        return PNG_OUT_OF_MEMORY_ERROR;   /* out of memory */\n    }\n\n    info_ptr = png_create_info_struct(png_ptr);\n    if (!info_ptr) {\n        png_destroy_read_struct(&png_ptr, NULL, NULL);\n        return PNG_OUT_OF_MEMORY_ERROR;   /* out of memory */\n    }\n\n    /* setjmp() must be called in every function that calls a non-trivial\n     * libpng function */\n\n    if (setjmp(mainprog_ptr->jmpbuf)) {\n        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);\n        return LIBPNG_FATAL_ERROR;   /* fatal libpng error (via longjmp()) */\n    }\n\n#if defined(PNG_SKIP_sRGB_CHECK_PROFILE) && defined(PNG_SET_OPTION_SUPPORTED)\n    png_set_option(png_ptr, PNG_SKIP_sRGB_CHECK_PROFILE, PNG_OPTION_ON);\n#endif\n\n#if PNG_LIBPNG_VER >= 10500 && defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)\n    /* copy standard chunks too */\n    png_set_keep_unknown_chunks(png_ptr, PNG_HANDLE_CHUNK_IF_SAFE, (png_const_bytep)\"pHYs\\0iTXt\\0tEXt\\0zTXt\", 4);\n#endif\n    png_set_read_user_chunk_fn(png_ptr, &mainprog_ptr->chunks, read_chunk_callback);\n\n    struct rwpng_read_data read_data = {infile, 0};\n    png_set_read_fn(png_ptr, &read_data, user_read_data);\n\n    png_read_info(png_ptr, info_ptr);  /* read all PNG info up to image data */\n\n    /* alternatively, could make separate calls to png_get_image_width(),\n     * etc., but want bit_depth and color_type for later [don't care about\n     * compression_type and filter_type => NULLs] */\n\n    png_get_IHDR(png_ptr, info_ptr, &mainprog_ptr->width, &mainprog_ptr->height,\n                 &bit_depth, &color_type, NULL, NULL, NULL);\n\n    // For overflow safety reject images that won't fit in 32-bit\n    if (mainprog_ptr->width > INT_MAX/mainprog_ptr->height) {\n        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);\n        return PNG_OUT_OF_MEMORY_ERROR;  /* not quite true, but whatever */\n    }\n\n    /* expand palette images to RGB, low-bit-depth grayscale images to 8 bits,\n     * transparency chunks to full alpha channel; strip 16-bit-per-sample\n     * images to 8 bits per sample; and convert grayscale to RGB[A] */\n\n    /* GRR TO DO:  preserve all safe-to-copy ancillary PNG chunks */\n\n    if (!(color_type & PNG_COLOR_MASK_ALPHA)) {\n#ifdef PNG_READ_FILLER_SUPPORTED\n        png_set_expand(png_ptr);\n        png_set_filler(png_ptr, 65535L, PNG_FILLER_AFTER);\n#else\n        fprintf(stderr, \"pngquant readpng:  image is neither RGBA nor GA\\n\");\n        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);\n        mainprog_ptr->retval = WRONG_INPUT_COLOR_TYPE;\n        return mainprog_ptr->retval;\n#endif\n    }\n\n    if (bit_depth == 16) {\n        png_set_strip_16(png_ptr);\n    }\n\n    if (!(color_type & PNG_COLOR_MASK_COLOR)) {\n        png_set_gray_to_rgb(png_ptr);\n    }\n\n    /* get source gamma for gamma correction, or use sRGB default */\n    double gamma = 0.45455;\n    if (png_get_valid(png_ptr, info_ptr, PNG_INFO_sRGB)) {\n        mainprog_ptr->input_color = RWPNG_SRGB;\n        mainprog_ptr->output_color = RWPNG_SRGB;\n    } else {\n        png_get_gAMA(png_ptr, info_ptr, &gamma);\n        if (gamma > 0 && gamma <= 1.0) {\n            mainprog_ptr->input_color = RWPNG_GAMA_ONLY;\n            mainprog_ptr->output_color = RWPNG_GAMA_ONLY;\n        } else {\n            fprintf(stderr, \"pngquant readpng:  ignored out-of-range gamma %f\\n\", gamma);\n            mainprog_ptr->input_color = RWPNG_NONE;\n            mainprog_ptr->output_color = RWPNG_NONE;\n            gamma = 0.45455;\n        }\n    }\n    mainprog_ptr->gamma = gamma;\n\n    png_set_interlace_handling(png_ptr);\n\n    /* all transformations have been registered; now update info_ptr data,\n     * get rowbytes and channels, and allocate image memory */\n\n    png_read_update_info(png_ptr, info_ptr);\n\n    rowbytes = png_get_rowbytes(png_ptr, info_ptr);\n\n    if ((mainprog_ptr->rgba_data = malloc(rowbytes * mainprog_ptr->height)) == NULL) {\n        fprintf(stderr, \"pngquant readpng:  unable to allocate image data\\n\");\n        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);\n        return PNG_OUT_OF_MEMORY_ERROR;\n    }\n\n    png_bytepp row_pointers = rwpng_create_row_pointers(info_ptr, png_ptr, mainprog_ptr->rgba_data, mainprog_ptr->height, 0);\n\n    /* now we can go ahead and just read the whole image */\n\n    png_read_image(png_ptr, row_pointers);\n\n    /* and we're done!  (png_read_end() can be omitted if no processing of\n     * post-IDAT text/time/etc. is desired) */\n\n    png_read_end(png_ptr, NULL);\n\n#if USE_LCMS\n#if PNG_LIBPNG_VER < 10500\n    png_charp ProfileData;\n#else\n    png_bytep ProfileData;\n#endif\n    png_uint_32 ProfileLen;\n\n    cmsHPROFILE hInProfile = NULL;\n\n    /* color_type is read from the image before conversion to RGBA */\n    int COLOR_PNG = color_type & PNG_COLOR_MASK_COLOR;\n\n    /* embedded ICC profile */\n    if (png_get_iCCP(png_ptr, info_ptr, &(png_charp){0}, &(int){0}, &ProfileData, &ProfileLen)) {\n\n        hInProfile = cmsOpenProfileFromMem(ProfileData, ProfileLen);\n        cmsColorSpaceSignature colorspace = cmsGetColorSpace(hInProfile);\n\n        /* only RGB (and GRAY) valid for PNGs */\n        if (colorspace == cmsSigRgbData && COLOR_PNG) {\n            mainprog_ptr->input_color = RWPNG_ICCP;\n            mainprog_ptr->output_color = RWPNG_SRGB;\n        } else {\n            if (colorspace == cmsSigGrayData && !COLOR_PNG) {\n                mainprog_ptr->input_color = RWPNG_ICCP_WARN_GRAY;\n                mainprog_ptr->output_color = RWPNG_SRGB;\n            }\n            cmsCloseProfile(hInProfile);\n            hInProfile = NULL;\n        }\n    }\n\n    /* build RGB profile from cHRM and gAMA */\n    if (hInProfile == NULL && COLOR_PNG &&\n        !png_get_valid(png_ptr, info_ptr, PNG_INFO_sRGB) &&\n        png_get_valid(png_ptr, info_ptr, PNG_INFO_gAMA) &&\n        png_get_valid(png_ptr, info_ptr, PNG_INFO_cHRM)) {\n\n        cmsCIExyY WhitePoint;\n        cmsCIExyYTRIPLE Primaries;\n\n        png_get_cHRM(png_ptr, info_ptr, &WhitePoint.x, &WhitePoint.y,\n                     &Primaries.Red.x, &Primaries.Red.y,\n                     &Primaries.Green.x, &Primaries.Green.y,\n                     &Primaries.Blue.x, &Primaries.Blue.y);\n\n        WhitePoint.Y = Primaries.Red.Y = Primaries.Green.Y = Primaries.Blue.Y = 1.0;\n\n        cmsToneCurve *GammaTable[3];\n        GammaTable[0] = GammaTable[1] = GammaTable[2] = cmsBuildGamma(NULL, 1/gamma);\n\n        hInProfile = cmsCreateRGBProfile(&WhitePoint, &Primaries, GammaTable);\n\n        cmsFreeToneCurve(GammaTable[0]);\n\n        mainprog_ptr->input_color = RWPNG_GAMA_CHRM;\n        mainprog_ptr->output_color = RWPNG_SRGB;\n    }\n\n    /* transform image to sRGB colorspace */\n    if (hInProfile != NULL) {\n\n        cmsHPROFILE hOutProfile = cmsCreate_sRGBProfile();\n        cmsHTRANSFORM hTransform = cmsCreateTransform(hInProfile, TYPE_RGBA_8,\n                                                      hOutProfile, TYPE_RGBA_8,\n                                                      INTENT_PERCEPTUAL,\n                                                      omp_get_max_threads() > 1 ? cmsFLAGS_NOCACHE : 0);\n\n        #pragma omp parallel for \\\n            if (mainprog_ptr->height*mainprog_ptr->width > 8000) \\\n            schedule(static)\n        for (unsigned int i = 0; i < mainprog_ptr->height; i++) {\n            /* It is safe to use the same block for input and output,\n               when both are of the same TYPE. */\n            cmsDoTransform(hTransform, row_pointers[i],\n                                       row_pointers[i],\n                                       mainprog_ptr->width);\n        }\n\n        cmsDeleteTransform(hTransform);\n        cmsCloseProfile(hOutProfile);\n        cmsCloseProfile(hInProfile);\n\n        mainprog_ptr->gamma = 0.45455;\n    }\n#endif\n\n    png_destroy_read_struct(&png_ptr, &info_ptr, NULL);\n\n    mainprog_ptr->file_size = read_data.bytes_read;\n    mainprog_ptr->row_pointers = (unsigned char **)row_pointers;\n\n    return SUCCESS;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144543,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static pngquant_error rwpng_read_image24_libpng(FILE *infile, png24_image *mainprog_ptr, int verbose)\n{\n    png_structp  png_ptr = NULL;\n    png_infop    info_ptr = NULL;\n    png_size_t   rowbytes;\n    int          color_type, bit_depth;\n\n    png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, mainprog_ptr,\n      rwpng_error_handler, verbose ? rwpng_warning_stderr_handler : rwpng_warning_silent_handler);\n    if (!png_ptr) {\n        return PNG_OUT_OF_MEMORY_ERROR;   /* out of memory */\n    }\n\n    info_ptr = png_create_info_struct(png_ptr);\n    if (!info_ptr) {\n        png_destroy_read_struct(&png_ptr, NULL, NULL);\n        return PNG_OUT_OF_MEMORY_ERROR;   /* out of memory */\n    }\n\n    /* setjmp() must be called in every function that calls a non-trivial\n     * libpng function */\n\n    if (setjmp(mainprog_ptr->jmpbuf)) {\n        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);\n        return LIBPNG_FATAL_ERROR;   /* fatal libpng error (via longjmp()) */\n    }\n\n#if defined(PNG_SKIP_sRGB_CHECK_PROFILE) && defined(PNG_SET_OPTION_SUPPORTED)\n    png_set_option(png_ptr, PNG_SKIP_sRGB_CHECK_PROFILE, PNG_OPTION_ON);\n#endif\n\n#if PNG_LIBPNG_VER >= 10500 && defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)\n    /* copy standard chunks too */\n    png_set_keep_unknown_chunks(png_ptr, PNG_HANDLE_CHUNK_IF_SAFE, (png_const_bytep)\"pHYs\\0iTXt\\0tEXt\\0zTXt\", 4);\n#endif\n    png_set_read_user_chunk_fn(png_ptr, &mainprog_ptr->chunks, read_chunk_callback);\n\n    struct rwpng_read_data read_data = {infile, 0};\n    png_set_read_fn(png_ptr, &read_data, user_read_data);\n\n    png_read_info(png_ptr, info_ptr);  /* read all PNG info up to image data */\n\n    /* alternatively, could make separate calls to png_get_image_width(),\n     * etc., but want bit_depth and color_type for later [don't care about\n     * compression_type and filter_type => NULLs] */\n\n     png_get_IHDR(png_ptr, info_ptr, &mainprog_ptr->width, &mainprog_ptr->height,\n                  &bit_depth, &color_type, NULL, NULL, NULL);\n \n     /* expand palette images to RGB, low-bit-depth grayscale images to 8 bits,\n      * transparency chunks to full alpha channel; strip 16-bit-per-sample\n      * images to 8 bits per sample; and convert grayscale to RGB[A] */\n\n    /* GRR TO DO:  preserve all safe-to-copy ancillary PNG chunks */\n\n    if (!(color_type & PNG_COLOR_MASK_ALPHA)) {\n#ifdef PNG_READ_FILLER_SUPPORTED\n        png_set_expand(png_ptr);\n        png_set_filler(png_ptr, 65535L, PNG_FILLER_AFTER);\n#else\n        fprintf(stderr, \"pngquant readpng:  image is neither RGBA nor GA\\n\");\n        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);\n        mainprog_ptr->retval = WRONG_INPUT_COLOR_TYPE;\n        return mainprog_ptr->retval;\n#endif\n    }\n\n    if (bit_depth == 16) {\n        png_set_strip_16(png_ptr);\n    }\n\n    if (!(color_type & PNG_COLOR_MASK_COLOR)) {\n        png_set_gray_to_rgb(png_ptr);\n    }\n\n    /* get source gamma for gamma correction, or use sRGB default */\n    double gamma = 0.45455;\n    if (png_get_valid(png_ptr, info_ptr, PNG_INFO_sRGB)) {\n        mainprog_ptr->input_color = RWPNG_SRGB;\n        mainprog_ptr->output_color = RWPNG_SRGB;\n    } else {\n        png_get_gAMA(png_ptr, info_ptr, &gamma);\n        if (gamma > 0 && gamma <= 1.0) {\n            mainprog_ptr->input_color = RWPNG_GAMA_ONLY;\n            mainprog_ptr->output_color = RWPNG_GAMA_ONLY;\n        } else {\n            fprintf(stderr, \"pngquant readpng:  ignored out-of-range gamma %f\\n\", gamma);\n            mainprog_ptr->input_color = RWPNG_NONE;\n            mainprog_ptr->output_color = RWPNG_NONE;\n            gamma = 0.45455;\n        }\n    }\n    mainprog_ptr->gamma = gamma;\n\n    png_set_interlace_handling(png_ptr);\n\n    /* all transformations have been registered; now update info_ptr data,\n     * get rowbytes and channels, and allocate image memory */\n\n    png_read_update_info(png_ptr, info_ptr);\n \n     rowbytes = png_get_rowbytes(png_ptr, info_ptr);\n \n    // For overflow safety reject images that won't fit in 32-bit\n    if (rowbytes > INT_MAX/mainprog_ptr->height) {\n        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);\n        return PNG_OUT_OF_MEMORY_ERROR;\n    }\n\n     if ((mainprog_ptr->rgba_data = malloc(rowbytes * mainprog_ptr->height)) == NULL) {\n         fprintf(stderr, \"pngquant readpng:  unable to allocate image data\\n\");\n         png_destroy_read_struct(&png_ptr, &info_ptr, NULL);\n        return PNG_OUT_OF_MEMORY_ERROR;\n    }\n\n    png_bytepp row_pointers = rwpng_create_row_pointers(info_ptr, png_ptr, mainprog_ptr->rgba_data, mainprog_ptr->height, 0);\n\n    /* now we can go ahead and just read the whole image */\n\n    png_read_image(png_ptr, row_pointers);\n\n    /* and we're done!  (png_read_end() can be omitted if no processing of\n     * post-IDAT text/time/etc. is desired) */\n\n    png_read_end(png_ptr, NULL);\n\n#if USE_LCMS\n#if PNG_LIBPNG_VER < 10500\n    png_charp ProfileData;\n#else\n    png_bytep ProfileData;\n#endif\n    png_uint_32 ProfileLen;\n\n    cmsHPROFILE hInProfile = NULL;\n\n    /* color_type is read from the image before conversion to RGBA */\n    int COLOR_PNG = color_type & PNG_COLOR_MASK_COLOR;\n\n    /* embedded ICC profile */\n    if (png_get_iCCP(png_ptr, info_ptr, &(png_charp){0}, &(int){0}, &ProfileData, &ProfileLen)) {\n\n        hInProfile = cmsOpenProfileFromMem(ProfileData, ProfileLen);\n        cmsColorSpaceSignature colorspace = cmsGetColorSpace(hInProfile);\n\n        /* only RGB (and GRAY) valid for PNGs */\n        if (colorspace == cmsSigRgbData && COLOR_PNG) {\n            mainprog_ptr->input_color = RWPNG_ICCP;\n            mainprog_ptr->output_color = RWPNG_SRGB;\n        } else {\n            if (colorspace == cmsSigGrayData && !COLOR_PNG) {\n                mainprog_ptr->input_color = RWPNG_ICCP_WARN_GRAY;\n                mainprog_ptr->output_color = RWPNG_SRGB;\n            }\n            cmsCloseProfile(hInProfile);\n            hInProfile = NULL;\n        }\n    }\n\n    /* build RGB profile from cHRM and gAMA */\n    if (hInProfile == NULL && COLOR_PNG &&\n        !png_get_valid(png_ptr, info_ptr, PNG_INFO_sRGB) &&\n        png_get_valid(png_ptr, info_ptr, PNG_INFO_gAMA) &&\n        png_get_valid(png_ptr, info_ptr, PNG_INFO_cHRM)) {\n\n        cmsCIExyY WhitePoint;\n        cmsCIExyYTRIPLE Primaries;\n\n        png_get_cHRM(png_ptr, info_ptr, &WhitePoint.x, &WhitePoint.y,\n                     &Primaries.Red.x, &Primaries.Red.y,\n                     &Primaries.Green.x, &Primaries.Green.y,\n                     &Primaries.Blue.x, &Primaries.Blue.y);\n\n        WhitePoint.Y = Primaries.Red.Y = Primaries.Green.Y = Primaries.Blue.Y = 1.0;\n\n        cmsToneCurve *GammaTable[3];\n        GammaTable[0] = GammaTable[1] = GammaTable[2] = cmsBuildGamma(NULL, 1/gamma);\n\n        hInProfile = cmsCreateRGBProfile(&WhitePoint, &Primaries, GammaTable);\n\n        cmsFreeToneCurve(GammaTable[0]);\n\n        mainprog_ptr->input_color = RWPNG_GAMA_CHRM;\n        mainprog_ptr->output_color = RWPNG_SRGB;\n    }\n\n    /* transform image to sRGB colorspace */\n    if (hInProfile != NULL) {\n\n        cmsHPROFILE hOutProfile = cmsCreate_sRGBProfile();\n        cmsHTRANSFORM hTransform = cmsCreateTransform(hInProfile, TYPE_RGBA_8,\n                                                      hOutProfile, TYPE_RGBA_8,\n                                                      INTENT_PERCEPTUAL,\n                                                      omp_get_max_threads() > 1 ? cmsFLAGS_NOCACHE : 0);\n\n        #pragma omp parallel for \\\n            if (mainprog_ptr->height*mainprog_ptr->width > 8000) \\\n            schedule(static)\n        for (unsigned int i = 0; i < mainprog_ptr->height; i++) {\n            /* It is safe to use the same block for input and output,\n               when both are of the same TYPE. */\n            cmsDoTransform(hTransform, row_pointers[i],\n                                       row_pointers[i],\n                                       mainprog_ptr->width);\n        }\n\n        cmsDeleteTransform(hTransform);\n        cmsCloseProfile(hOutProfile);\n        cmsCloseProfile(hInProfile);\n\n        mainprog_ptr->gamma = 0.45455;\n    }\n#endif\n\n    png_destroy_read_struct(&png_ptr, &info_ptr, NULL);\n\n    mainprog_ptr->file_size = read_data.bytes_read;\n    mainprog_ptr->row_pointers = (unsigned char **)row_pointers;\n\n    return SUCCESS;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144544,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "void * CAPSTONE_API cs_winkernel_malloc(size_t size)\n{\n\t// Disallow zero length allocation because they waste pool header space and,\n\t// in many cases, indicate a potential validation issue in the calling code.\n\tNT_ASSERT(size);\n\n\t// FP; a use of NonPagedPool is required for Windows 7 support\n#pragma prefast(suppress : 30030)\t\t// Allocating executable POOL_TYPE memory\n\tCS_WINKERNEL_MEMBLOCK *block = (CS_WINKERNEL_MEMBLOCK *)ExAllocatePoolWithTag(\n\t\t\tNonPagedPool, size + sizeof(CS_WINKERNEL_MEMBLOCK), CS_WINKERNEL_POOL_TAG);\n\tif (!block) {\n\t\treturn NULL;\n\t}\n\tblock->size = size;\n\n\treturn block->data;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144583,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "void * CAPSTONE_API cs_winkernel_malloc(size_t size)\n{\n\tNT_ASSERT(size);\n \n #pragma prefast(suppress : 30030)\t\t// Allocating executable POOL_TYPE memory\n\tsize_t number_of_bytes = 0;\n\tCS_WINKERNEL_MEMBLOCK *block = NULL;\n\t// A specially crafted size value can trigger the overflow.\n\t// If the sum in a value that overflows or underflows the capacity of the type,\n\t// the function returns NULL.\n\tif (!NT_SUCCESS(RtlSizeTAdd(size, sizeof(CS_WINKERNEL_MEMBLOCK), &number_of_bytes))) {\n\t\treturn NULL;\n\t}\n\tblock = (CS_WINKERNEL_MEMBLOCK *)ExAllocatePoolWithTag(\n\t\t\tNonPagedPool, number_of_bytes, CS_WINKERNEL_POOL_TAG);\n \tif (!block) {\n \t\treturn NULL;\n \t}\n\tblock->size = size;\n\n\treturn block->data;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144584,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static MagickBooleanType ReadPSDChannelPixels(Image *image,const ssize_t row,\n  const PixelChannel channel,const unsigned char *pixels,\n  ExceptionInfo *exception)\n{\n  Quantum\n    pixel;\n\n  const unsigned char\n    *p;\n\n  Quantum\n    *q;\n\n  ssize_t\n    x;\n\n  size_t\n    packet_size;\n\n  p=pixels;\n  q=GetAuthenticPixels(image,0,row,image->columns,1,exception);\n  if (q == (Quantum *) NULL)\n    return MagickFalse;\n  packet_size=GetPSDPacketSize(image);\n  for (x=0; x < (ssize_t) image->columns; x++)\n  {\n    if (packet_size == 1)\n      pixel=ScaleCharToQuantum(*p++);\n    else\n      if (packet_size == 2)\n        {\n          unsigned short\n            nibble;\n\n          p=PushShortPixel(MSBEndian,p,&nibble);\n          pixel=ScaleShortToQuantum(nibble);\n        }\n      else\n        {\n          MagickFloatType\n            nibble;\n\n          p=PushFloatPixel(MSBEndian,p,&nibble);\n          pixel=ClampToQuantum(((MagickRealType) QuantumRange)*nibble);\n        }\n    if (image->depth > 1)\n      {\n        SetPSDPixel(image,channel,packet_size,pixel,q,exception);\n        q+=GetPixelChannels(image);\n      }\n    else\n      {\n        ssize_t\n          bit,\n          number_bits;\n\n        number_bits=(ssize_t) image->columns-x;\n        if (number_bits > 8)\n          number_bits=8;\n        for (bit = 0; bit < (ssize_t) number_bits; bit++)\n        {\n          SetPSDPixel(image,channel,packet_size,(((unsigned char) pixel)\n            & (0x01 << (7-bit))) != 0 ? 0 : QuantumRange,q,exception);\n          q+=GetPixelChannels(image);\n          x++;\n        }\n        if (x != (ssize_t) image->columns)\n          x--;\n        continue;\n      }\n  }\n  return(SyncAuthenticPixels(image,exception));\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144703,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static MagickBooleanType ReadPSDChannelPixels(Image *image,const ssize_t row,\n  const PixelChannel channel,const unsigned char *pixels,\n  ExceptionInfo *exception)\n{\n  Quantum\n    pixel;\n\n  const unsigned char\n    *p;\n\n  Quantum\n    *q;\n\n  ssize_t\n    x;\n\n  size_t\n    packet_size;\n\n  p=pixels;\n  q=GetAuthenticPixels(image,0,row,image->columns,1,exception);\n  if (q == (Quantum *) NULL)\n    return MagickFalse;\n  packet_size=GetPSDPacketSize(image);\n  for (x=0; x < (ssize_t) image->columns; x++)\n  {\n    if (packet_size == 1)\n      pixel=ScaleCharToQuantum(*p++);\n    else\n      if (packet_size == 2)\n        {\n          unsigned short\n            nibble;\n\n          p=PushShortPixel(MSBEndian,p,&nibble);\n          pixel=ScaleShortToQuantum(nibble);\n        }\n      else\n        {\n          MagickFloatType\n            nibble;\n\n          p=PushFloatPixel(MSBEndian,p,&nibble);\n          pixel=ClampToQuantum(((MagickRealType) QuantumRange)*nibble);\n        }\n    if (image->depth > 1)\n      {\n        SetPSDPixel(image,channel,packet_size,pixel,q,exception);\n        q+=GetPixelChannels(image);\n      }\n    else\n      {\n        ssize_t\n          bit,\n          number_bits;\n\n        number_bits=(ssize_t) image->columns-x;\n        if (number_bits > 8)\n          number_bits=8;\n        for (bit = 0; bit < (ssize_t) number_bits; bit++)\n        {\n          SetPSDPixel(image,channel,packet_size,(((unsigned char)((ssize_t)pixel))\n            & (0x01 << (7-bit))) != 0 ? 0 : QuantumRange,q,exception);\n          q+=GetPixelChannels(image);\n          x++;\n        }\n        if (x != (ssize_t) image->columns)\n          x--;\n        continue;\n      }\n  }\n  return(SyncAuthenticPixels(image,exception));\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144704,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& indices = context->input(0);\n    const Tensor& values = context->input(1);\n    const Tensor& shape = context->input(2);\n    const Tensor& weights = context->input(3);\n    bool use_weights = weights.NumElements() > 0;\n\n    OP_REQUIRES(context, TensorShapeUtils::IsMatrix(indices.shape()),\n                errors::InvalidArgument(\n                    \"Input indices must be a 2-dimensional tensor. Got: \",\n                    indices.shape().DebugString()));\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(values.shape()),\n                errors::InvalidArgument(\"Input values must be a vector. Got: \",\n                                        values.shape().DebugString()));\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(shape.shape()),\n                errors::InvalidArgument(\"Input shape must be a vector. Got: \",\n                                        shape.shape().DebugString()));\n    OP_REQUIRES(context,\n                values.shape().dim_size(0) == indices.shape().dim_size(0),\n                errors::InvalidArgument(\n                    \"Number of values must match first dimension of indices.\",\n                    \"Got \", values.shape().dim_size(0),\n                    \" values, indices shape: \", indices.shape().DebugString()));\n    OP_REQUIRES(\n        context, shape.shape().dim_size(0) == indices.shape().dim_size(1),\n        errors::InvalidArgument(\n            \"Number of dimensions must match second dimension of indices.\",\n            \"Got \", shape.shape().dim_size(0),\n            \" dimensions, indices shape: \", indices.shape().DebugString()));\n    OP_REQUIRES(context, shape.NumElements() > 0,\n                errors::InvalidArgument(\n                    \"The shape argument requires at least one element.\"));\n    // Validate indices: each index must be valid for the corresponding\n    // dimension. This could be possibly done better.\n    const auto indices_values = indices.matrix<int64_t>();\n    const auto shape_vector = shape.vec<int64_t>();\n    int num_values = values.NumElements();  // same as first dim of indices\n    int rank = indices.shape().dim_size(1);\n    for (int i = 0; i < num_values; ++i) {\n      for (int j = 0; j < rank; ++j) {\n        OP_REQUIRES(\n            context,\n            indices_values(i, j) >= 0 && indices_values(i, j) < shape_vector(j),\n            errors::InvalidArgument(\n                \"Invalid index value at \", i, \": dimension \", j, \" has value \",\n                indices_values(i, j), \" which is not in [0, \", shape_vector(j),\n                \") (as given by dense shape \", shape.DebugString()));\n      }\n    }\n\n    if (use_weights) {\n      OP_REQUIRES(\n          context, weights.shape() == values.shape(),\n          errors::InvalidArgument(\n              \"Weights and values must have the same shape. Weight shape: \",\n              weights.shape().DebugString(),\n              \"; values shape: \", values.shape().DebugString()));\n    }\n\n    bool is_1d = shape.NumElements() == 1;\n    int num_batches = is_1d ? 1 : shape_vector(0);\n\n    const auto values_values = values.flat<T>();\n    const auto weight_values = weights.flat<W>();\n\n    auto per_batch_counts = BatchedMap<W>(num_batches);\n\n    T max_value = 0;\n\n    for (int idx = 0; idx < num_values; ++idx) {\n      int batch = is_1d ? 0 : indices_values(idx, 0);\n      if (batch >= num_batches) {\n        OP_REQUIRES(context, batch < num_batches,\n                    errors::InvalidArgument(\n                        \"Indices value along the first dimension must be \",\n                        \"lower than the first index of the shape.\", \"Got \",\n                        batch, \" as batch and \", num_batches,\n                        \" as the first dimension of the shape.\"));\n      }\n      const auto& value = values_values(idx);\n      if (value >= 0 && (maxlength_ <= 0 || value < maxlength_)) {\n        if (binary_output_) {\n          per_batch_counts[batch][value] = 1;\n        } else if (use_weights) {\n          per_batch_counts[batch][value] += weight_values(idx);\n        } else {\n          per_batch_counts[batch][value]++;\n        }\n        if (value > max_value) {\n          max_value = value;\n        }\n      }\n    }\n\n    int num_output_values = GetOutputSize(max_value, maxlength_, minlength_);\n    OP_REQUIRES_OK(context, OutputSparse<W>(per_batch_counts, num_output_values,\n                                            is_1d, context));\n  }",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144723,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& indices = context->input(0);\n    const Tensor& values = context->input(1);\n    const Tensor& shape = context->input(2);\n    const Tensor& weights = context->input(3);\n    bool use_weights = weights.NumElements() > 0;\n\n    OP_REQUIRES(context, TensorShapeUtils::IsMatrix(indices.shape()),\n                errors::InvalidArgument(\n                    \"Input indices must be a 2-dimensional tensor. Got: \",\n                    indices.shape().DebugString()));\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(values.shape()),\n                errors::InvalidArgument(\"Input values must be a vector. Got: \",\n                                        values.shape().DebugString()));\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(shape.shape()),\n                errors::InvalidArgument(\"Input shape must be a vector. Got: \",\n                                        shape.shape().DebugString()));\n    OP_REQUIRES(context,\n                values.shape().dim_size(0) == indices.shape().dim_size(0),\n                errors::InvalidArgument(\n                    \"Number of values must match first dimension of indices.\",\n                    \"Got \", values.shape().dim_size(0),\n                    \" values, indices shape: \", indices.shape().DebugString()));\n    OP_REQUIRES(\n        context, shape.shape().dim_size(0) == indices.shape().dim_size(1),\n        errors::InvalidArgument(\n            \"Number of dimensions must match second dimension of indices.\",\n            \"Got \", shape.shape().dim_size(0),\n            \" dimensions, indices shape: \", indices.shape().DebugString()));\n    OP_REQUIRES(context, shape.NumElements() > 0,\n                errors::InvalidArgument(\n                    \"The shape argument requires at least one element.\"));\n    // Validate indices: each index must be valid for the corresponding\n    // dimension. This could be possibly done better.\n    const auto indices_values = indices.matrix<int64_t>();\n    const auto shape_vector = shape.vec<int64_t>();\n    int num_values = values.NumElements();  // same as first dim of indices\n    int rank = indices.shape().dim_size(1);\n    for (int i = 0; i < num_values; ++i) {\n      for (int j = 0; j < rank; ++j) {\n        OP_REQUIRES(\n            context,\n            indices_values(i, j) >= 0 && indices_values(i, j) < shape_vector(j),\n            errors::InvalidArgument(\n                \"Invalid index value at \", i, \": dimension \", j, \" has value \",\n                indices_values(i, j), \" which is not in [0, \", shape_vector(j),\n                \") (as given by dense shape \", shape.DebugString()));\n      }\n    }\n\n    if (use_weights) {\n      OP_REQUIRES(\n          context, weights.shape() == values.shape(),\n          errors::InvalidArgument(\n              \"Weights and values must have the same shape. Weight shape: \",\n              weights.shape().DebugString(),\n              \"; values shape: \", values.shape().DebugString()));\n    }\n\n    bool is_1d = shape.NumElements() == 1;\n    int num_batches = is_1d ? 1 : shape_vector(0);\n    OP_REQUIRES(\n        context, 0 < num_batches && num_batches < kMaxBatches,\n        errors::InvalidArgument(\"Cannot allocate \", num_batches,\n                                \" batches, is the dense shape too wide?\"));\n\n    const auto values_values = values.flat<T>();\n    const auto weight_values = weights.flat<W>();\n\n    auto per_batch_counts = BatchedMap<W>(num_batches);\n\n    T max_value = 0;\n\n    for (int idx = 0; idx < num_values; ++idx) {\n      int batch = is_1d ? 0 : indices_values(idx, 0);\n      if (batch >= num_batches) {\n        OP_REQUIRES(context, batch < num_batches,\n                    errors::InvalidArgument(\n                        \"Indices value along the first dimension must be \",\n                        \"lower than the first index of the shape.\", \"Got \",\n                        batch, \" as batch and \", num_batches,\n                        \" as the first dimension of the shape.\"));\n      }\n      const auto& value = values_values(idx);\n      if (value >= 0 && (maxlength_ <= 0 || value < maxlength_)) {\n        if (binary_output_) {\n          per_batch_counts[batch][value] = 1;\n        } else if (use_weights) {\n          per_batch_counts[batch][value] += weight_values(idx);\n        } else {\n          per_batch_counts[batch][value]++;\n        }\n        if (value > max_value) {\n          max_value = value;\n        }\n      }\n    }\n\n    int num_output_values = GetOutputSize(max_value, maxlength_, minlength_);\n    OP_REQUIRES_OK(context, OutputSparse<W>(per_batch_counts, num_output_values,\n                                            is_1d, context));\n  }",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144724,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteEmbeddingLookupSparseParams*>(node->builtin_data);\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));\n  const TfLiteTensor* ids;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &ids));\n  const TfLiteTensor* indices;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 1, &indices));\n  const TfLiteTensor* dense_shape;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 2, &dense_shape));\n  const TfLiteTensor* weights;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 3, &weights));\n  const TfLiteTensor* value;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 4, &value));\n\n  const int lookup_rank = SizeOfDimension(indices, 1);\n  const int embedding_rank = NumDimensions(value);\n  const int num_lookups = SizeOfDimension(ids, 0);\n  const int num_rows = SizeOfDimension(value, 0);\n\n  // The last dimension gets replaced by the embedding.\n  const int output_rank = (lookup_rank - 1) + (embedding_rank - 1);\n\n  // Make sure that the actual dense shape of the sparse tensor represented by\n  // (loopkup, indices, dense_shape) is consistent.\n  TF_LITE_ENSURE_EQ(context, SizeOfDimension(dense_shape, 0), lookup_rank);\n\n  // Resize output tensor.\n  TfLiteIntArray* output_shape = TfLiteIntArrayCreate(output_rank);\n  TF_LITE_ENSURE(context, output_shape != nullptr);\n  int k = 0;\n  size_t embedding_size = 1;\n  size_t lookup_size = 1;\n  for (int i = 0; i < lookup_rank - 1; i++, k++) {\n    const size_t dim = dense_shape->data.i32[i];\n    TF_LITE_ENSURE_MSG(\n        context,\n        MultiplyAndCheckOverflow(lookup_size, dim, &lookup_size) == kTfLiteOk,\n        \"Lookup size overflowed.\");\n    output_shape->data[k] = dim;\n  }\n  for (int i = 1; i < embedding_rank; i++, k++) {\n    const size_t dim = SizeOfDimension(value, i);\n    TF_LITE_ENSURE_MSG(context,\n                       MultiplyAndCheckOverflow(embedding_size, dim,\n                                                &embedding_size) == kTfLiteOk,\n                       \"Embedding size overflowed.\");\n    output_shape->data[k] = dim;\n  }\n  TF_LITE_ENSURE_STATUS(context->ResizeTensor(context, output, output_shape));\n  const size_t output_size = lookup_size * embedding_size;\n  TfLiteTensorRealloc(output_size * sizeof(float), output);\n\n  float* output_ptr = GetTensorData<float>(output);\n  const float* weights_ptr = GetTensorData<float>(weights);\n  const float* value_ptr = GetTensorData<float>(value);\n  // Makes sure reallocation was successful.\n  TF_LITE_ENSURE(context, output_ptr != nullptr);\n\n  std::fill_n(output_ptr, output_size, 0.0f);\n\n  // Keep track of the current bucket for aggregation/combination.\n  int current_output_offset = 0;\n  float current_total_weight = 0.0;\n  float current_squares_weight = 0.0;\n  int num_elements = 0;\n\n  for (int i = 0; i < num_lookups; i++) {\n    int idx = ids->data.i32[i];\n    if (idx >= num_rows || idx < 0) {\n      context->ReportError(context,\n                           \"Embedding Lookup Sparse: index out of bounds. \"\n                           \"Got %d, and bounds are [0, %d]\",\n                           idx, num_rows - 1);\n      return kTfLiteError;\n    }\n\n    // Check where we need to aggregate.\n    const int example_indices_offset = i * lookup_rank;\n    int output_bucket = 0;\n    int stride = 1;\n    for (int k = (lookup_rank - 1) - 1; k >= 0; k--) {\n      output_bucket += indices->data.i32[example_indices_offset + k] * stride;\n      stride *= dense_shape->data.i32[k];\n    }\n    const int output_offset = output_bucket * embedding_size;\n\n    // If we are in a new aggregation bucket and the combiner is not the sum,\n    // go back and finalize the result of the previous bucket.\n    if (output_offset != current_output_offset) {\n      FinalizeAggregation(params->combiner, num_elements, current_total_weight,\n                          current_squares_weight, embedding_size,\n                          &output_ptr[current_output_offset]);\n\n      // Track next bucket.\n      num_elements = 0;\n      current_total_weight = 0.0;\n      current_squares_weight = 0.0;\n      current_output_offset = output_offset;\n    }\n\n    // Add element to aggregation.\n    ++num_elements;\n    const int example_embedding_offset = idx * embedding_size;\n    const float w = weights_ptr[i];\n    current_squares_weight += w * w;\n    current_total_weight += w;\n    for (int k = 0; k < embedding_size; k++) {\n      output_ptr[current_output_offset + k] +=\n          value_ptr[example_embedding_offset + k] * w;\n    }\n  }\n\n  // Finalize last bucket.\n  FinalizeAggregation(params->combiner, num_elements, current_total_weight,\n                      current_squares_weight, embedding_size,\n                      &GetTensorData<float>(output)[current_output_offset]);\n\n  return kTfLiteOk;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144725,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteEmbeddingLookupSparseParams*>(node->builtin_data);\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));\n  const TfLiteTensor* ids;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &ids));\n  const TfLiteTensor* indices;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 1, &indices));\n  const TfLiteTensor* dense_shape;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 2, &dense_shape));\n  const TfLiteTensor* weights;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 3, &weights));\n  const TfLiteTensor* value;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 4, &value));\n  const size_t values_size = NumElements(value);\n\n  const int lookup_rank = SizeOfDimension(indices, 1);\n  const int embedding_rank = NumDimensions(value);\n  const int num_lookups = SizeOfDimension(ids, 0);\n  const int num_rows = SizeOfDimension(value, 0);\n\n  // The last dimension gets replaced by the embedding.\n  const int output_rank = (lookup_rank - 1) + (embedding_rank - 1);\n\n  // Make sure that the actual dense shape of the sparse tensor represented by\n  // (loopkup, indices, dense_shape) is consistent.\n  TF_LITE_ENSURE_EQ(context, SizeOfDimension(dense_shape, 0), lookup_rank);\n\n  // Resize output tensor.\n  TfLiteIntArray* output_shape = TfLiteIntArrayCreate(output_rank);\n  TF_LITE_ENSURE(context, output_shape != nullptr);\n  int k = 0;\n  size_t embedding_size = 1;\n  size_t lookup_size = 1;\n  for (int i = 0; i < lookup_rank - 1; i++, k++) {\n    const size_t dim = dense_shape->data.i32[i];\n    TF_LITE_ENSURE_MSG(\n        context,\n        MultiplyAndCheckOverflow(lookup_size, dim, &lookup_size) == kTfLiteOk,\n        \"Lookup size overflowed.\");\n    output_shape->data[k] = dim;\n  }\n  for (int i = 1; i < embedding_rank; i++, k++) {\n    const size_t dim = SizeOfDimension(value, i);\n    TF_LITE_ENSURE_MSG(context,\n                       MultiplyAndCheckOverflow(embedding_size, dim,\n                                                &embedding_size) == kTfLiteOk,\n                       \"Embedding size overflowed.\");\n    output_shape->data[k] = dim;\n  }\n  TF_LITE_ENSURE_STATUS(context->ResizeTensor(context, output, output_shape));\n  const size_t output_size = lookup_size * embedding_size;\n  TfLiteTensorRealloc(output_size * sizeof(float), output);\n\n  float* output_ptr = GetTensorData<float>(output);\n  const float* weights_ptr = GetTensorData<float>(weights);\n  const float* value_ptr = GetTensorData<float>(value);\n  // Makes sure reallocation was successful.\n  TF_LITE_ENSURE(context, output_ptr != nullptr);\n\n  std::fill_n(output_ptr, output_size, 0.0f);\n\n  // Keep track of the current bucket for aggregation/combination.\n  int current_output_offset = 0;\n  float current_total_weight = 0.0;\n  float current_squares_weight = 0.0;\n  int num_elements = 0;\n\n  for (int i = 0; i < num_lookups; i++) {\n    int idx = ids->data.i32[i];\n    if (idx >= num_rows || idx < 0) {\n      context->ReportError(context,\n                           \"Embedding Lookup Sparse: index out of bounds. \"\n                           \"Got %d, and bounds are [0, %d]\",\n                           idx, num_rows - 1);\n      return kTfLiteError;\n    }\n\n    // Check where we need to aggregate.\n    const int example_indices_offset = i * lookup_rank;\n    int output_bucket = 0;\n    int stride = 1;\n    for (int k = (lookup_rank - 1) - 1; k >= 0; k--) {\n      output_bucket += indices->data.i32[example_indices_offset + k] * stride;\n      stride *= dense_shape->data.i32[k];\n    }\n    const int output_offset = output_bucket * embedding_size;\n\n    // If we are in a new aggregation bucket and the combiner is not the sum,\n    // go back and finalize the result of the previous bucket.\n    if (output_offset != current_output_offset) {\n      FinalizeAggregation(params->combiner, num_elements, current_total_weight,\n                          current_squares_weight, embedding_size,\n                          &output_ptr[current_output_offset]);\n\n      // Track next bucket.\n      num_elements = 0;\n      current_total_weight = 0.0;\n      current_squares_weight = 0.0;\n      current_output_offset = output_offset;\n    }\n\n    // Add element to aggregation.\n    ++num_elements;\n    const int example_embedding_offset = idx * embedding_size;\n    const float w = weights_ptr[i];\n    current_squares_weight += w * w;\n    current_total_weight += w;\n    for (int k = 0; k < embedding_size; k++) {\n      // only index if indices are valid\n      if (current_output_offset + k < 0) continue;\n      if (current_output_offset + k >= output_size) continue;\n      if (example_embedding_offset + k < 0) continue;\n      if (example_embedding_offset + k >= values_size) continue;\n      output_ptr[current_output_offset + k] +=\n          value_ptr[example_embedding_offset + k] * w;\n    }\n  }\n\n  // Finalize last bucket.\n  FinalizeAggregation(params->combiner, num_elements, current_total_weight,\n                      current_squares_weight, embedding_size,\n                      &GetTensorData<float>(output)[current_output_offset]);\n\n  return kTfLiteOk;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144726,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "bool copyaudiodata (AFfilehandle infile, AFfilehandle outfile, int trackid)\n{\n\tint frameSize = afGetVirtualFrameSize(infile, trackid, 1);\n\n\tconst int kBufferFrameCount = 65536;\n\tvoid *buffer = malloc(kBufferFrameCount * frameSize);\n\n\tAFframecount totalFrames = afGetFrameCount(infile, AF_DEFAULT_TRACK);\n\tAFframecount totalFramesWritten = 0;\n\n\tbool success = true;\n\n\twhile (totalFramesWritten < totalFrames)\n\t{\n\t\tAFframecount framesToRead = totalFrames - totalFramesWritten;\n\t\tif (framesToRead > kBufferFrameCount)\n\t\t\tframesToRead = kBufferFrameCount;\n\n\t\tAFframecount framesRead = afReadFrames(infile, trackid, buffer,\n\t\t\tframesToRead);\n\n\t\tif (framesRead < framesToRead)\n\t\t{\n\t\t\tfprintf(stderr, \"Bad read of audio track data.\\n\");\n\t\t\tsuccess = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tAFframecount framesWritten = afWriteFrames(outfile, trackid, buffer,\n\t\t\tframesRead);\n\n\t\tif (framesWritten < framesRead)\n\t\t{\n\t\t\tfprintf(stderr, \"Bad write of audio track data.\\n\");\n\t\t\tsuccess = false;\n\t\t\tbreak;\n\t\t}\n\n\t\ttotalFramesWritten += framesWritten;\n\t}\n\n\tfree(buffer);\n\n\treturn success;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144735,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "bool copyaudiodata (AFfilehandle infile, AFfilehandle outfile, int trackid)\n{\n\tint frameSize = afGetVirtualFrameSize(infile, trackid, 1);\n\n\tint kBufferFrameCount = 65536;\n\tint bufferSize;\n\twhile (multiplyCheckOverflow(kBufferFrameCount, frameSize, &bufferSize))\n\t\tkBufferFrameCount /= 2;\n\tvoid *buffer = malloc(bufferSize);\n\n\tAFframecount totalFrames = afGetFrameCount(infile, AF_DEFAULT_TRACK);\n\tAFframecount totalFramesWritten = 0;\n\n\tbool success = true;\n\n\twhile (totalFramesWritten < totalFrames)\n\t{\n\t\tAFframecount framesToRead = totalFrames - totalFramesWritten;\n\t\tif (framesToRead > kBufferFrameCount)\n\t\t\tframesToRead = kBufferFrameCount;\n\n\t\tAFframecount framesRead = afReadFrames(infile, trackid, buffer,\n\t\t\tframesToRead);\n\n\t\tif (framesRead < framesToRead)\n\t\t{\n\t\t\tfprintf(stderr, \"Bad read of audio track data.\\n\");\n\t\t\tsuccess = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tAFframecount framesWritten = afWriteFrames(outfile, trackid, buffer,\n\t\t\tframesRead);\n\n\t\tif (framesWritten < framesRead)\n\t\t{\n\t\t\tfprintf(stderr, \"Bad write of audio track data.\\n\");\n\t\t\tsuccess = false;\n\t\t\tbreak;\n\t\t}\n\n\t\ttotalFramesWritten += framesWritten;\n\t}\n\n\tfree(buffer);\n\n\treturn success;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144736,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "String StringUtil::Implode(const Variant& items, const String& delim,\n                           const bool checkIsContainer /* = true */) {\n  if (checkIsContainer && !isContainer(items)) {\n    throw_param_is_not_container();\n  }\n  int size = getContainerSize(items);\n  if (size == 0) return empty_string();\n\n  req::vector<String> sitems;\n  sitems.reserve(size);\n  int len = 0;\n  int lenDelim = delim.size();\n  for (ArrayIter iter(items); iter; ++iter) {\n    sitems.emplace_back(iter.second().toString());\n    len += sitems.back().size() + lenDelim;\n  }\n  len -= lenDelim; // always one delimiter less than count of items\n  assert(sitems.size() == size);\n\n  String s = String(len, ReserveString);\n  char *buffer = s.mutableData();\n  const char *sdelim = delim.data();\n  char *p = buffer;\n  String &init_str = sitems[0];\n  int init_len = init_str.size();\n  memcpy(p, init_str.data(), init_len);\n  p += init_len;\n  for (int i = 1; i < size; i++) {\n    String &item = sitems[i];\n    memcpy(p, sdelim, lenDelim);\n    p += lenDelim;\n    int lenItem = item.size();\n    memcpy(p, item.data(), lenItem);\n    p += lenItem;\n  }\n  assert(p - buffer == len);\n  s.setSize(len);\n  return s;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144749,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "String StringUtil::Implode(const Variant& items, const String& delim,\n                           const bool checkIsContainer /* = true */) {\n  if (checkIsContainer && !isContainer(items)) {\n    throw_param_is_not_container();\n  }\n  int size = getContainerSize(items);\n  if (size == 0) return empty_string();\n\n  req::vector<String> sitems;\n  sitems.reserve(size);\n  size_t len = 0;\n  size_t lenDelim = delim.size();\n  for (ArrayIter iter(items); iter; ++iter) {\n    sitems.emplace_back(iter.second().toString());\n    len += sitems.back().size() + lenDelim;\n  }\n  len -= lenDelim; // always one delimiter less than count of items\n  assert(sitems.size() == size);\n\n  String s = String(len, ReserveString);\n  char *buffer = s.mutableData();\n  const char *sdelim = delim.data();\n  char *p = buffer;\n  String &init_str = sitems[0];\n  int init_len = init_str.size();\n  memcpy(p, init_str.data(), init_len);\n  p += init_len;\n  for (int i = 1; i < size; i++) {\n    String &item = sitems[i];\n    memcpy(p, sdelim, lenDelim);\n    p += lenDelim;\n    int lenItem = item.size();\n    memcpy(p, item.data(), lenItem);\n    p += lenItem;\n  }\n  assert(p - buffer == len);\n  s.setSize(len);\n  return s;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144750,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static inline struct htx_blk *htx_add_header(struct htx *htx, const struct ist name,\n\t\t\t\t\t     const struct ist value)\n{\n\tstruct htx_blk *blk;\n\n\t/* FIXME: check name.len (< 256B) and value.len (< 1MB) */\n\tblk = htx_add_blk(htx, HTX_BLK_HDR, name.len + value.len);\n\tif (!blk)\n\t\treturn NULL;\n\n\tblk->info += (value.len << 8) + name.len;\n\tist2bin_lc(htx_get_blk_ptr(htx, blk), name);\n\tmemcpy(htx_get_blk_ptr(htx, blk)  + name.len, value.ptr, value.len);\n\treturn blk;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144799,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static inline struct htx_blk *htx_add_header(struct htx *htx, const struct ist name,\n\t\t\t\t\t     const struct ist value)\n{\n\tstruct htx_blk *blk;\n\n\tif (name.len > 255 || value.len > 1048575)\n\t\treturn NULL;\n\n\tblk = htx_add_blk(htx, HTX_BLK_HDR, name.len + value.len);\n\tif (!blk)\n\t\treturn NULL;\n\n\tblk->info += (value.len << 8) + name.len;\n\tist2bin_lc(htx_get_blk_ptr(htx, blk), name);\n\tmemcpy(htx_get_blk_ptr(htx, blk)  + name.len, value.ptr, value.len);\n\treturn blk;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144800,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static u_int16_t concat_hash_string(struct ndpi_packet_struct *packet,\n\t\t\t\t   char *buf, u_int8_t client_hash) {\n  u_int16_t offset = 22, buf_out_len = 0;\n  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)\n    goto invalid_payload;\n  u_int32_t len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n  offset += 4;\n\n  /* -1 for ';' */\n  if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))\n    goto invalid_payload;\n\n  /* ssh.kex_algorithms [C/S] */\n  strncpy(buf, (const char *)&packet->payload[offset], buf_out_len = len);\n  buf[buf_out_len++] = ';';\n  offset += len;\n\n  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)\n    goto invalid_payload;\n  /* ssh.server_host_key_algorithms [None] */\n  len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n  offset += 4 + len;\n\n  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)\n    goto invalid_payload;\n  /* ssh.encryption_algorithms_client_to_server [C] */\n  len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n\n  if(client_hash) {\n    offset += 4;\n\n    if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))\n      goto invalid_payload;\n\n    strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);\n    buf_out_len += len;\n    buf[buf_out_len++] = ';';\n    offset += len;\n  } else\n    offset += 4 + len;\n\n  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)\n    goto invalid_payload;\n  /* ssh.encryption_algorithms_server_to_client [S] */\n  len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n\n  if(!client_hash) {\n    offset += 4;\n\n    if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))\n      goto invalid_payload;\n\n    strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);\n    buf_out_len += len;\n    buf[buf_out_len++] = ';';\n    offset += len;\n  } else\n    offset += 4 + len;\n\n  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)\n    goto invalid_payload;\n  /* ssh.mac_algorithms_client_to_server [C] */\n  len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n\n  if(client_hash) {\n    offset += 4;\n\n    if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))\n      goto invalid_payload;\n\n    strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);\n    buf_out_len += len;\n    buf[buf_out_len++] = ';';\n    offset += len;\n  } else\n    offset += 4 + len;\n\n  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)\n    goto invalid_payload;\n  /* ssh.mac_algorithms_server_to_client [S] */\n  len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n\n  if(!client_hash) {\n    offset += 4;\n\n    if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))\n      goto invalid_payload;\n\n    strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);\n    buf_out_len += len;\n    buf[buf_out_len++] = ';';\n    offset += len;\n  } else\n    offset += 4 + len;\n\n  /* ssh.compression_algorithms_client_to_server [C] */\n  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)\n    goto invalid_payload;\n  len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n\n  if(client_hash) {\n    offset += 4;\n\n    if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))\n      goto invalid_payload;\n\n    strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);\n    buf_out_len += len;\n    offset += len;\n  } else\n    offset += 4 + len;\n\n  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)\n    goto invalid_payload;\n  /* ssh.compression_algorithms_server_to_client [S] */\n  len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n\n  if(!client_hash) {\n    offset += 4;\n\n    if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))\n      goto invalid_payload;\n\n    strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);\n    buf_out_len += len;\n    offset += len;\n  } else\n    offset += 4 + len;\n\n  /* ssh.languages_client_to_server [None] */\n\n  /* ssh.languages_server_to_client [None] */\n\n#ifdef SSH_DEBUG\n  printf(\"[SSH] %s\\n\", buf);\n#endif\n\n  return(buf_out_len);\n\ninvalid_payload:\n\n#ifdef SSH_DEBUG\n  printf(\"[SSH] Invalid packet payload\\n\");\n#endif\n\n  return(0);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144990,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static u_int16_t concat_hash_string(struct ndpi_packet_struct *packet,\n\t\t\t\t   char *buf, u_int8_t client_hash) {\n  u_int32_t offset = 22, buf_out_len = 0;\n  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)\n    goto invalid_payload;\n  u_int32_t len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n  offset += 4;\n\n  /* -1 for ';' */\n  if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))\n    goto invalid_payload;\n\n  /* ssh.kex_algorithms [C/S] */\n  strncpy(buf, (const char *)&packet->payload[offset], buf_out_len = len);\n  buf[buf_out_len++] = ';';\n  offset += len;\n\n  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)\n    goto invalid_payload;\n  /* ssh.server_host_key_algorithms [None] */\n  len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n  if (len > UINT32_MAX - 4 - offset)\n    goto invalid_payload;\n  offset += 4 + len;\n\n  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)\n    goto invalid_payload;\n  /* ssh.encryption_algorithms_client_to_server [C] */\n  len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n\n  offset += 4;\n  if(client_hash) {\n    if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))\n      goto invalid_payload;\n\n    strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);\n    buf_out_len += len;\n    buf[buf_out_len++] = ';';\n  }\n  if (len > UINT32_MAX - offset)\n    goto invalid_payload;\n  offset += len;\n\n  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)\n    goto invalid_payload;\n  /* ssh.encryption_algorithms_server_to_client [S] */\n  len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n\n  offset += 4;\n  if(!client_hash) {\n    if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))\n      goto invalid_payload;\n\n    strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);\n    buf_out_len += len;\n    buf[buf_out_len++] = ';';\n  }\n  if (len > UINT32_MAX - offset)\n    goto invalid_payload;\n  offset += len;\n\n  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)\n    goto invalid_payload;\n  /* ssh.mac_algorithms_client_to_server [C] */\n  len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n\n  offset += 4;\n  if(client_hash) {\n    if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))\n      goto invalid_payload;\n\n    strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);\n    buf_out_len += len;\n    buf[buf_out_len++] = ';';\n  }\n  if (len > UINT32_MAX - offset)\n    goto invalid_payload;\n  offset += len;\n\n  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)\n    goto invalid_payload;\n  /* ssh.mac_algorithms_server_to_client [S] */\n  len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n\n  offset += 4;\n  if(!client_hash) {\n    if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))\n      goto invalid_payload;\n\n    strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);\n    buf_out_len += len;\n    buf[buf_out_len++] = ';';\n  }\n  if (len > UINT32_MAX - offset)\n    goto invalid_payload;\n  offset += len;\n\n  /* ssh.compression_algorithms_client_to_server [C] */\n  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)\n    goto invalid_payload;\n  len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n\n  offset += 4;\n  if(client_hash) {\n    if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))\n      goto invalid_payload;\n\n    strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);\n    buf_out_len += len;\n  }\n  if (len > UINT32_MAX - offset)\n    goto invalid_payload;\n  offset += len;\n\n  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)\n    goto invalid_payload;\n  /* ssh.compression_algorithms_server_to_client [S] */\n  len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n\n  offset += 4;\n  if(!client_hash) {\n    if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))\n      goto invalid_payload;\n\n    strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);\n    buf_out_len += len;\n  }\n  if (len > UINT32_MAX - offset)\n    goto invalid_payload;\n  offset += len;\n\n  /* ssh.languages_client_to_server [None] */\n\n  /* ssh.languages_server_to_client [None] */\n\n#ifdef SSH_DEBUG\n  printf(\"[SSH] %s\\n\", buf);\n#endif\n\n  return(buf_out_len);\n\ninvalid_payload:\n\n#ifdef SSH_DEBUG\n  printf(\"[SSH] Invalid packet payload\\n\");\n#endif\n\n  return(0);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144991,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "void MAPIPrint(MAPIProps *p) {\n  int j, i, index, h, x;\n  DDWORD *ddword_ptr;\n  DDWORD ddword_tmp;\n  dtr thedate;\n  MAPIProperty *mapi;\n  variableLength *mapidata;\n  variableLength vlTemp;\n  int found;\n\n  for (j = 0; j < p->count; j++) {\n    mapi = &(p->properties[j]);\n    printf(\"   #%i: Type: [\", j);\n    switch (PROP_TYPE(mapi->id)) {\n      case PT_UNSPECIFIED:\n        printf(\"  NONE   \"); break;\n      case PT_NULL:\n        printf(\"  NULL   \"); break;\n      case PT_I2:\n        printf(\"   I2    \"); break;\n      case PT_LONG:\n        printf(\"  LONG   \"); break;\n      case PT_R4:\n        printf(\"   R4    \"); break;\n      case PT_DOUBLE:\n        printf(\" DOUBLE  \"); break;\n      case PT_CURRENCY:\n        printf(\"CURRENCY \"); break;\n      case PT_APPTIME:\n        printf(\"APP TIME \"); break;\n      case PT_ERROR:\n        printf(\"  ERROR  \"); break;\n      case PT_BOOLEAN:\n        printf(\" BOOLEAN \"); break;\n      case PT_OBJECT:\n        printf(\" OBJECT  \"); break;\n      case PT_I8:\n        printf(\"   I8    \"); break;\n      case PT_STRING8:\n        printf(\" STRING8 \"); break;\n      case PT_UNICODE:\n        printf(\" UNICODE \"); break;\n      case PT_SYSTIME:\n        printf(\"SYS TIME \"); break;\n      case PT_CLSID:\n        printf(\"OLE GUID \"); break;\n      case PT_BINARY:\n        printf(\" BINARY  \"); break;\n      default:\n        printf(\"<%x>\", PROP_TYPE(mapi->id)); break;\n    }\n\n    printf(\"]  Code: [\");\n    if (mapi->custom == 1) {\n      printf(\"UD:x%04x\", PROP_ID(mapi->id));\n    } else {\n      found = 0;\n      for (index = 0; index < sizeof(MPList) / sizeof(MAPIPropertyTagList); index++) {\n        if ((MPList[index].id == PROP_ID(mapi->id)) && (found == 0)) {\n          printf(\"%s\", MPList[index].name);\n          found = 1;\n        }\n      }\n      if (found == 0) {\n        printf(\"0x%04x\", PROP_ID(mapi->id));\n      }\n    }\n    printf(\"]\\n\");\n    if (mapi->namedproperty > 0) {\n      for (i = 0; i < mapi->namedproperty; i++) {\n        printf(\"    Name: %s\\n\", mapi->propnames[i].data);\n      }\n    }\n    for (i = 0; i < mapi->count; i++) {\n      mapidata = &(mapi->data[i]);\n      if (mapi->count > 1) {\n        printf(\"    [%i/%u] \", i, mapi->count);\n      } else {\n        printf(\"    \");\n      }\n      printf(\"Size: %i\", mapidata->size);\n      switch (PROP_TYPE(mapi->id)) {\n        case PT_SYSTIME:\n          MAPISysTimetoDTR(mapidata->data, &thedate);\n          printf(\"    Value: \");\n          ddword_tmp = *((DDWORD *)mapidata->data);\n          TNEFPrintDate(thedate);\n          printf(\" [HEX: \");\n          for (x = 0; x < sizeof(ddword_tmp); x++) {\n            printf(\" %02x\", (BYTE)mapidata->data[x]);\n          }\n          printf(\"] (%llu)\\n\", ddword_tmp);\n          break;\n        case PT_LONG:\n          printf(\"    Value: %li\\n\", *((long*)mapidata->data));\n          break;\n        case PT_I2:\n          printf(\"    Value: %hi\\n\", *((short int*)mapidata->data));\n          break;\n        case PT_BOOLEAN:\n          if (mapi->data->data[0] != 0) {\n            printf(\"    Value: True\\n\");\n          } else {\n            printf(\"    Value: False\\n\");\n          }\n          break;\n        case PT_OBJECT:\n          printf(\"\\n\");\n          break;\n        case PT_BINARY:\n          if (IsCompressedRTF(mapidata) == 1) {\n            printf(\"    Detected Compressed RTF. \");\n            printf(\"Decompressed text follows\\n\");\n            printf(\"-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\\n\");\n            if ((vlTemp.data = (BYTE*)DecompressRTF(mapidata, &(vlTemp.size))) != NULL) {\n              printf(\"%s\\n\", vlTemp.data);\n              free(vlTemp.data);\n            }\n            printf(\"-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\\n\");\n          } else {\n            printf(\"    Value: [\");\n            for (h = 0; h < mapidata->size; h++) {\n              if (isprint(mapidata->data[h])) {\n                printf(\"%c\", mapidata->data[h]);\n              } else {\n                printf(\".\");\n              }\n\n            }\n            printf(\"]\\n\");\n          }\n          break;\n        case PT_STRING8:\n          printf(\"    Value: [%s]\\n\", mapidata->data);\n          if (strlen((char*)mapidata->data) != mapidata->size - 1) {\n            printf(\"Detected Hidden data: [\");\n            for (h = 0; h < mapidata->size; h++) {\n              if (isprint(mapidata->data[h])) {\n                printf(\"%c\", mapidata->data[h]);\n              } else {\n                printf(\".\");\n              }\n\n            }\n            printf(\"]\\n\");\n          }\n          break;\n        case PT_CLSID:\n          printf(\"    Value: \");\n          printf(\"[HEX: \");\n          for(x=0; x< 16; x++) {\n            printf(\" %02x\", (BYTE)mapidata->data[x]);\n          }\n          printf(\"]\\n\");\n          break;\n        default:\n          printf(\"    Value: [%s]\\n\", mapidata->data);\n      }\n    }\n  }\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145028,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "void MAPIPrint(MAPIProps *p) {\n  int j, i, index, h, x;\n  DDWORD *ddword_ptr;\n  DDWORD ddword_tmp;\n  dtr thedate;\n  MAPIProperty *mapi;\n  variableLength *mapidata;\n  variableLength vlTemp;\n  int found;\n\n  for (j = 0; j < p->count; j++) {\n    mapi = &(p->properties[j]);\n    printf(\"   #%i: Type: [\", j);\n    switch (PROP_TYPE(mapi->id)) {\n      case PT_UNSPECIFIED:\n        printf(\"  NONE   \"); break;\n      case PT_NULL:\n        printf(\"  NULL   \"); break;\n      case PT_I2:\n        printf(\"   I2    \"); break;\n      case PT_LONG:\n        printf(\"  LONG   \"); break;\n      case PT_R4:\n        printf(\"   R4    \"); break;\n      case PT_DOUBLE:\n        printf(\" DOUBLE  \"); break;\n      case PT_CURRENCY:\n        printf(\"CURRENCY \"); break;\n      case PT_APPTIME:\n        printf(\"APP TIME \"); break;\n      case PT_ERROR:\n        printf(\"  ERROR  \"); break;\n      case PT_BOOLEAN:\n        printf(\" BOOLEAN \"); break;\n      case PT_OBJECT:\n        printf(\" OBJECT  \"); break;\n      case PT_I8:\n        printf(\"   I8    \"); break;\n      case PT_STRING8:\n        printf(\" STRING8 \"); break;\n      case PT_UNICODE:\n        printf(\" UNICODE \"); break;\n      case PT_SYSTIME:\n        printf(\"SYS TIME \"); break;\n      case PT_CLSID:\n        printf(\"OLE GUID \"); break;\n      case PT_BINARY:\n        printf(\" BINARY  \"); break;\n      default:\n        printf(\"<%x>\", PROP_TYPE(mapi->id)); break;\n    }\n\n    printf(\"]  Code: [\");\n    if (mapi->custom == 1) {\n      printf(\"UD:x%04x\", PROP_ID(mapi->id));\n    } else {\n      found = 0;\n      for (index = 0; index < sizeof(MPList) / sizeof(MAPIPropertyTagList); index++) {\n        if ((MPList[index].id == PROP_ID(mapi->id)) && (found == 0)) {\n          printf(\"%s\", MPList[index].name);\n          found = 1;\n        }\n      }\n      if (found == 0) {\n        printf(\"0x%04x\", PROP_ID(mapi->id));\n      }\n    }\n    printf(\"]\\n\");\n    if (mapi->namedproperty > 0) {\n      for (i = 0; i < mapi->namedproperty; i++) {\n        printf(\"    Name: %s\\n\", mapi->propnames[i].data);\n      }\n    }\n    for (i = 0; i < mapi->count; i++) {\n      mapidata = &(mapi->data[i]);\n      if (mapi->count > 1) {\n        printf(\"    [%i/%u] \", i, mapi->count);\n      } else {\n        printf(\"    \");\n      }\n      printf(\"Size: %i\", mapidata->size);\n      switch (PROP_TYPE(mapi->id)) {\n        case PT_SYSTIME:\n          MAPISysTimetoDTR(mapidata->data, &thedate);\n          printf(\"    Value: \");\n          ddword_tmp = *((DDWORD *)mapidata->data);\n          TNEFPrintDate(thedate);\n          printf(\" [HEX: \");\n          for (x = 0; x < sizeof(ddword_tmp); x++) {\n            printf(\" %02x\", (BYTE)mapidata->data[x]);\n          }\n          printf(\"] (%llu)\\n\", ddword_tmp);\n          break;\n        case PT_LONG:\n          printf(\"    Value: %i\\n\", *((int*)mapidata->data));\n          break;\n        case PT_I2:\n          printf(\"    Value: %hi\\n\", *((short int*)mapidata->data));\n          break;\n        case PT_BOOLEAN:\n          if (mapi->data->data[0] != 0) {\n            printf(\"    Value: True\\n\");\n          } else {\n            printf(\"    Value: False\\n\");\n          }\n          break;\n        case PT_OBJECT:\n          printf(\"\\n\");\n          break;\n        case PT_BINARY:\n          if (IsCompressedRTF(mapidata) == 1) {\n            printf(\"    Detected Compressed RTF. \");\n            printf(\"Decompressed text follows\\n\");\n            printf(\"-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\\n\");\n            if ((vlTemp.data = (BYTE*)DecompressRTF(mapidata, &(vlTemp.size))) != NULL) {\n              printf(\"%s\\n\", vlTemp.data);\n              free(vlTemp.data);\n            }\n            printf(\"-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\\n\");\n          } else {\n            printf(\"    Value: [\");\n            for (h = 0; h < mapidata->size; h++) {\n              if (isprint(mapidata->data[h])) {\n                printf(\"%c\", mapidata->data[h]);\n              } else {\n                printf(\".\");\n              }\n\n            }\n            printf(\"]\\n\");\n          }\n          break;\n        case PT_STRING8:\n          printf(\"    Value: [%s]\\n\", mapidata->data);\n          if (strlen((char*)mapidata->data) != mapidata->size - 1) {\n            printf(\"Detected Hidden data: [\");\n            for (h = 0; h < mapidata->size; h++) {\n              if (isprint(mapidata->data[h])) {\n                printf(\"%c\", mapidata->data[h]);\n              } else {\n                printf(\".\");\n              }\n\n            }\n            printf(\"]\\n\");\n          }\n          break;\n        case PT_CLSID:\n          printf(\"    Value: \");\n          printf(\"[HEX: \");\n          for(x=0; x< 16; x++) {\n            printf(\" %02x\", (BYTE)mapidata->data[x]);\n          }\n          printf(\"]\\n\");\n          break;\n        default:\n          printf(\"    Value: [%s]\\n\", mapidata->data);\n      }\n    }\n  }\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145029,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "    long WebPImage::getHeaderOffset(byte *data, long data_size,\n                                    byte *header, long header_size) {\n        long pos = -1;\n        for (long i=0; i < data_size - header_size; i++) {\n            if (memcmp(header, &data[i], header_size) == 0) {\n                pos = i;\n                break;\n            }\n        }\n        return pos;\n    }",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145030,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "    long WebPImage::getHeaderOffset(byte* data, long data_size, byte* header, long header_size)\n    {\n        if (data_size < header_size) { return -1; }\n        long pos = -1;\n        for (long i=0; i < data_size - header_size; i++) {\n            if (memcmp(header, &data[i], header_size) == 0) {\n                pos = i;\n                break;\n            }\n        }\n        return pos;\n    }",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145031,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "ngx_gmtime(time_t t, ngx_tm_t *tp)\n{\n    ngx_int_t   yday;\n    ngx_uint_t  sec, min, hour, mday, mon, year, wday, days, leap;\n\n    /* the calculation is valid for positive time_t only */\n\n    if (t < 0) {\n        t = 0;\n    }\n\n    days = t / 86400;\n    sec = t % 86400;\n\n    /* January 1, 1970 was Thursday */\n\n    wday = (4 + days) % 7;\n\n    hour = sec / 3600;\n    sec %= 3600;\n    min = sec / 60;\n    sec %= 60;\n\n    /*\n     * the algorithm based on Gauss' formula,\n     * see src/core/ngx_parse_time.c\n     */\n\n    /* days since March 1, 1 BC */\n    days = days - (31 + 28) + 719527;\n\n    /*\n     * The \"days\" should be adjusted to 1 only, however, some March 1st's go\n     * to previous year, so we adjust them to 2.  This causes also shift of the\n     * last February days to next year, but we catch the case when \"yday\"\n     * becomes negative.\n     */\n\n    year = (days + 2) * 400 / (365 * 400 + 100 - 4 + 1);\n\n    yday = days - (365 * year + year / 4 - year / 100 + year / 400);\n\n    if (yday < 0) {\n        leap = (year % 4 == 0) && (year % 100 || (year % 400 == 0));\n        yday = 365 + leap + yday;\n        year--;\n    }\n\n    /*\n     * The empirical formula that maps \"yday\" to month.\n     * There are at least 10 variants, some of them are:\n     *     mon = (yday + 31) * 15 / 459\n     *     mon = (yday + 31) * 17 / 520\n     *     mon = (yday + 31) * 20 / 612\n     */\n\n    mon = (yday + 31) * 10 / 306;\n\n    /* the Gauss' formula that evaluates days before the month */\n\n    mday = yday - (367 * mon / 12 - 30) + 1;\n\n    if (yday >= 306) {\n\n        year++;\n        mon -= 10;\n\n        /*\n         * there is no \"yday\" in Win32 SYSTEMTIME\n         *\n         * yday -= 306;\n         */\n\n    } else {\n\n        mon += 2;\n\n        /*\n         * there is no \"yday\" in Win32 SYSTEMTIME\n         *\n         * yday += 31 + 28 + leap;\n         */\n    }\n\n    tp->ngx_tm_sec = (ngx_tm_sec_t) sec;\n    tp->ngx_tm_min = (ngx_tm_min_t) min;\n    tp->ngx_tm_hour = (ngx_tm_hour_t) hour;\n    tp->ngx_tm_mday = (ngx_tm_mday_t) mday;\n    tp->ngx_tm_mon = (ngx_tm_mon_t) mon;\n    tp->ngx_tm_year = (ngx_tm_year_t) year;\n    tp->ngx_tm_wday = (ngx_tm_wday_t) wday;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145038,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "ngx_gmtime(time_t t, ngx_tm_t *tp)\n{\n    ngx_int_t   yday;\n    ngx_uint_t  sec, min, hour, mday, mon, year, wday, days, leap;\n\n    /* the calculation is valid for positive time_t only */\n\n    if (t < 0) {\n        t = 0;\n    }\n\n    days = t / 86400;\n    sec = t % 86400;\n\n    /*\n     * no more than 4 year digits supported,\n     * truncate to December 31, 9999, 23:59:59\n     */\n\n    if (days > 2932896) {\n        days = 2932896;\n        sec = 86399;\n    }\n\n    /* January 1, 1970 was Thursday */\n\n    wday = (4 + days) % 7;\n\n    hour = sec / 3600;\n    sec %= 3600;\n    min = sec / 60;\n    sec %= 60;\n\n    /*\n     * the algorithm based on Gauss' formula,\n     * see src/core/ngx_parse_time.c\n     */\n\n    /* days since March 1, 1 BC */\n    days = days - (31 + 28) + 719527;\n\n    /*\n     * The \"days\" should be adjusted to 1 only, however, some March 1st's go\n     * to previous year, so we adjust them to 2.  This causes also shift of the\n     * last February days to next year, but we catch the case when \"yday\"\n     * becomes negative.\n     */\n\n    year = (days + 2) * 400 / (365 * 400 + 100 - 4 + 1);\n\n    yday = days - (365 * year + year / 4 - year / 100 + year / 400);\n\n    if (yday < 0) {\n        leap = (year % 4 == 0) && (year % 100 || (year % 400 == 0));\n        yday = 365 + leap + yday;\n        year--;\n    }\n\n    /*\n     * The empirical formula that maps \"yday\" to month.\n     * There are at least 10 variants, some of them are:\n     *     mon = (yday + 31) * 15 / 459\n     *     mon = (yday + 31) * 17 / 520\n     *     mon = (yday + 31) * 20 / 612\n     */\n\n    mon = (yday + 31) * 10 / 306;\n\n    /* the Gauss' formula that evaluates days before the month */\n\n    mday = yday - (367 * mon / 12 - 30) + 1;\n\n    if (yday >= 306) {\n\n        year++;\n        mon -= 10;\n\n        /*\n         * there is no \"yday\" in Win32 SYSTEMTIME\n         *\n         * yday -= 306;\n         */\n\n    } else {\n\n        mon += 2;\n\n        /*\n         * there is no \"yday\" in Win32 SYSTEMTIME\n         *\n         * yday += 31 + 28 + leap;\n         */\n    }\n\n    tp->ngx_tm_sec = (ngx_tm_sec_t) sec;\n    tp->ngx_tm_min = (ngx_tm_min_t) min;\n    tp->ngx_tm_hour = (ngx_tm_hour_t) hour;\n    tp->ngx_tm_mday = (ngx_tm_mday_t) mday;\n    tp->ngx_tm_mon = (ngx_tm_mon_t) mon;\n    tp->ngx_tm_year = (ngx_tm_year_t) year;\n    tp->ngx_tm_wday = (ngx_tm_wday_t) wday;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145039,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& diagonal = context->input(0);\n\n    // MatrixDiag and MatrixDiagV2 both use this OpKernel. MatrixDiag only has\n    // one input, so we have to check the number of inputs before reading\n    // additional parameters in MatrixDiagV2.\n    int32 lower_diag_index = 0;\n    int32 upper_diag_index = 0;\n    int32 num_rows = -1;\n    int32 num_cols = -1;\n    T padding_value(0);\n\n    // MatrixDiagOpV2-specific.\n    if (context->num_inputs() > kNumV1Inputs) {\n      auto& diag_index = context->input(1);\n      OP_REQUIRES(context,\n                  TensorShapeUtils::IsScalar(diag_index.shape()) ||\n                      TensorShapeUtils::IsVector(diag_index.shape()),\n                  errors::InvalidArgument(\n                      \"diag_index must be a scalar or vector, received shape: \",\n                      diag_index.shape().DebugString()));\n      lower_diag_index = diag_index.flat<int32>()(0);\n      upper_diag_index = lower_diag_index;\n      if (TensorShapeUtils::IsVector(diag_index.shape())) {\n        auto diag_index_size = diag_index.dim_size(0);\n        OP_REQUIRES(\n            context, 0 < diag_index_size && diag_index_size <= 2,\n            errors::InvalidArgument(\n                \"diag_index must have only one or two elements, received \",\n                diag_index_size, \" elements.\"));\n        if (diag_index_size > 1) {\n          upper_diag_index = diag_index.flat<int32>()(1);\n        }\n      }\n      num_rows = context->input(2).flat<int32>()(0);\n      num_cols = context->input(3).flat<int32>()(0);\n      padding_value = context->input(4).flat<T>()(0);\n    }\n\n    // Size validations.\n    const TensorShape& diagonal_shape = diagonal.shape();\n    const int diag_rank = diagonal_shape.dims();\n    const Eigen::Index num_diags = upper_diag_index - lower_diag_index + 1;\n    OP_REQUIRES(context, TensorShapeUtils::IsVectorOrHigher(diagonal_shape),\n                errors::InvalidArgument(\n                    \"diagonal must be at least 1-dim, received shape: \",\n                    diagonal.shape().DebugString()));\n    OP_REQUIRES(\n        context, lower_diag_index <= upper_diag_index,\n        errors::InvalidArgument(\n            \"lower_diag_index must not be larger than upper_diag_index: \",\n            lower_diag_index, \" > \", upper_diag_index));\n    OP_REQUIRES(context,\n                lower_diag_index == upper_diag_index ||\n                    diagonal_shape.dim_size(diag_rank - 2) == num_diags,\n                errors::InvalidArgument(\n                    \"The number of diagonals provided in the input does not \"\n                    \"match the lower_diag_index and upper_diag_index range.\"));\n\n    const Eigen::Index max_diag_len = diagonal_shape.dim_size(diag_rank - 1);\n    const int32 min_num_rows = max_diag_len - std::min(upper_diag_index, 0);\n    const int32 min_num_cols = max_diag_len + std::max(lower_diag_index, 0);\n    OP_REQUIRES(context, num_rows == -1 || num_rows >= min_num_rows,\n                errors::InvalidArgument(\"The number of rows is too small.\"));\n    OP_REQUIRES(context, num_cols == -1 || num_cols >= min_num_cols,\n                errors::InvalidArgument(\"The number of columns is too small.\"));\n\n    // If both num_rows and num_cols are unknown, assume that output is square.\n    // Otherwise, use smallest possible values.\n    if (num_rows == -1 && num_cols == -1) {\n      num_rows = std::max(min_num_rows, min_num_cols);\n      num_cols = num_rows;\n    } else if (num_rows == -1) {\n      num_rows = min_num_rows;\n    } else if (num_cols == -1) {\n      num_cols = min_num_cols;\n    }\n    OP_REQUIRES(context, num_rows == min_num_rows || num_cols == min_num_cols,\n                errors::InvalidArgument(\n                    \"The number of rows or columns is not consistent with \"\n                    \"the specified d_lower, d_upper, and diagonal.\"));\n\n    TensorShape output_shape = diagonal_shape;\n    if (num_diags == 1) {  // Output has rank `rank+1`.\n      output_shape.set_dim(diag_rank - 1, num_rows);\n      output_shape.AddDim(num_cols);\n    } else {  // Output has rank `rank`.\n      output_shape.set_dim(diag_rank - 2, num_rows);\n      output_shape.set_dim(diag_rank - 1, num_cols);\n    }\n\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(0, output_shape, &output));\n    auto output_reshaped = output->flat_inner_dims<T, 3>();\n    auto diag_reshaped = diagonal.flat<T>();\n    functor::MatrixDiag<Device, T>::Compute(\n        context, context->eigen_device<Device>(), diag_reshaped,\n        output_reshaped, lower_diag_index, upper_diag_index, max_diag_len,\n        padding_value, left_align_superdiagonal_, left_align_subdiagonal_);\n  }",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145056,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& diagonal = context->input(0);\n\n    // MatrixDiag and MatrixDiagV2 both use this OpKernel. MatrixDiag only has\n    // one input, so we have to check the number of inputs before reading\n    // additional parameters in MatrixDiagV2.\n    int32 lower_diag_index = 0;\n    int32 upper_diag_index = 0;\n    int32 num_rows = -1;\n    int32 num_cols = -1;\n    T padding_value(0);\n\n    // MatrixDiagOpV2-specific.\n    if (context->num_inputs() > kNumV1Inputs) {\n      auto& diag_index = context->input(1);\n      OP_REQUIRES(context,\n                  TensorShapeUtils::IsScalar(diag_index.shape()) ||\n                      TensorShapeUtils::IsVector(diag_index.shape()),\n                  errors::InvalidArgument(\n                      \"diag_index must be a scalar or vector, received shape: \",\n                      diag_index.shape().DebugString()));\n      lower_diag_index = diag_index.flat<int32>()(0);\n      upper_diag_index = lower_diag_index;\n      if (TensorShapeUtils::IsVector(diag_index.shape())) {\n        auto diag_index_size = diag_index.dim_size(0);\n        OP_REQUIRES(\n            context, 0 < diag_index_size && diag_index_size <= 2,\n            errors::InvalidArgument(\n                \"diag_index must have only one or two elements, received \",\n                diag_index_size, \" elements.\"));\n        if (diag_index_size > 1) {\n          upper_diag_index = diag_index.flat<int32>()(1);\n        }\n      }\n\n      auto& num_rows_tensor = context->input(2);\n      OP_REQUIRES(context, TensorShapeUtils::IsScalar(num_rows_tensor.shape()),\n                  errors::InvalidArgument(\"num_rows must be a scalar\"));\n      num_rows = num_rows_tensor.flat<int32>()(0);\n\n      auto& num_cols_tensor = context->input(3);\n      OP_REQUIRES(context, TensorShapeUtils::IsScalar(num_cols_tensor.shape()),\n                  errors::InvalidArgument(\"num_cols must be a scalar\"));\n      num_cols = num_cols_tensor.flat<int32>()(0);\n\n      auto& padding_value_tensor = context->input(4);\n      OP_REQUIRES(context,\n                  TensorShapeUtils::IsScalar(padding_value_tensor.shape()),\n                  errors::InvalidArgument(\"padding_value must be a scalar\"));\n      padding_value = padding_value_tensor.flat<T>()(0);\n    }\n\n    // Size validations.\n    const TensorShape& diagonal_shape = diagonal.shape();\n    const int diag_rank = diagonal_shape.dims();\n    const Eigen::Index num_diags = upper_diag_index - lower_diag_index + 1;\n    OP_REQUIRES(context, TensorShapeUtils::IsVectorOrHigher(diagonal_shape),\n                errors::InvalidArgument(\n                    \"diagonal must be at least 1-dim, received shape: \",\n                    diagonal.shape().DebugString()));\n    OP_REQUIRES(\n        context, lower_diag_index <= upper_diag_index,\n        errors::InvalidArgument(\n            \"lower_diag_index must not be larger than upper_diag_index: \",\n            lower_diag_index, \" > \", upper_diag_index));\n    OP_REQUIRES(context,\n                lower_diag_index == upper_diag_index ||\n                    diagonal_shape.dim_size(diag_rank - 2) == num_diags,\n                errors::InvalidArgument(\n                    \"The number of diagonals provided in the input does not \"\n                    \"match the lower_diag_index and upper_diag_index range.\"));\n\n    const Eigen::Index max_diag_len = diagonal_shape.dim_size(diag_rank - 1);\n    const int32 min_num_rows = max_diag_len - std::min(upper_diag_index, 0);\n    const int32 min_num_cols = max_diag_len + std::max(lower_diag_index, 0);\n    OP_REQUIRES(context, num_rows == -1 || num_rows >= min_num_rows,\n                errors::InvalidArgument(\"The number of rows is too small.\"));\n    OP_REQUIRES(context, num_cols == -1 || num_cols >= min_num_cols,\n                errors::InvalidArgument(\"The number of columns is too small.\"));\n\n    // If both num_rows and num_cols are unknown, assume that output is square.\n    // Otherwise, use smallest possible values.\n    if (num_rows == -1 && num_cols == -1) {\n      num_rows = std::max(min_num_rows, min_num_cols);\n      num_cols = num_rows;\n    } else if (num_rows == -1) {\n      num_rows = min_num_rows;\n    } else if (num_cols == -1) {\n      num_cols = min_num_cols;\n    }\n    OP_REQUIRES(context, num_rows == min_num_rows || num_cols == min_num_cols,\n                errors::InvalidArgument(\n                    \"The number of rows or columns is not consistent with \"\n                    \"the specified d_lower, d_upper, and diagonal.\"));\n\n    TensorShape output_shape = diagonal_shape;\n    if (num_diags == 1) {  // Output has rank `rank+1`.\n      output_shape.set_dim(diag_rank - 1, num_rows);\n      output_shape.AddDim(num_cols);\n    } else {  // Output has rank `rank`.\n      output_shape.set_dim(diag_rank - 2, num_rows);\n      output_shape.set_dim(diag_rank - 1, num_cols);\n    }\n\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(0, output_shape, &output));\n    auto output_reshaped = output->flat_inner_dims<T, 3>();\n    auto diag_reshaped = diagonal.flat<T>();\n    functor::MatrixDiag<Device, T>::Compute(\n        context, context->eigen_device<Device>(), diag_reshaped,\n        output_reshaped, lower_diag_index, upper_diag_index, max_diag_len,\n        padding_value, left_align_superdiagonal_, left_align_subdiagonal_);\n  }",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145057,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static Fixed lsr_translate_coords(GF_LASeRCodec *lsr, u32 val, u32 nb_bits)\n{\n#ifdef GPAC_FIXED_POINT\n\tif (val >> (nb_bits-1) ) {\n\t\ts32 neg = (s32) val - (1<<nb_bits);\n\t\tif (neg < -FIX_ONE / 2)\n\t\t\treturn 2 * gf_divfix(INT2FIX(neg/2), lsr->res_factor);\n\t\treturn gf_divfix(INT2FIX(neg), lsr->res_factor);\n\t} else {\n\t\tif (val > FIX_ONE / 2)\n\t\t\treturn 2 * gf_divfix(INT2FIX(val/2), lsr->res_factor);\n\t\treturn gf_divfix(INT2FIX(val), lsr->res_factor);\n\t}\n#else\n\tif (val >> (nb_bits-1) ) {\n\t\ts32 neg = (s32) val - (1<<nb_bits);\n\t\treturn gf_divfix(INT2FIX(neg), lsr->res_factor);\n\t} else {\n\t\treturn gf_divfix(INT2FIX(val), lsr->res_factor);\n\t}\n#endif\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145080,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static Fixed lsr_translate_coords(GF_LASeRCodec *lsr, u32 val, u32 nb_bits)\n{\n\tif (!nb_bits) return 0;\n\t\n#ifdef GPAC_FIXED_POINT\n\tif (val >> (nb_bits-1) ) {\n\t\ts32 neg = (s32) val - (1<<nb_bits);\n\t\tif (neg < -FIX_ONE / 2)\n\t\t\treturn 2 * gf_divfix(INT2FIX(neg/2), lsr->res_factor);\n\t\treturn gf_divfix(INT2FIX(neg), lsr->res_factor);\n\t} else {\n\t\tif (val > FIX_ONE / 2)\n\t\t\treturn 2 * gf_divfix(INT2FIX(val/2), lsr->res_factor);\n\t\treturn gf_divfix(INT2FIX(val), lsr->res_factor);\n\t}\n#else\n\tif (val >> (nb_bits-1) ) {\n\t\ts32 neg = (s32) val - (1<<nb_bits);\n\t\treturn gf_divfix(INT2FIX(neg), lsr->res_factor);\n\t} else {\n\t\treturn gf_divfix(INT2FIX(val), lsr->res_factor);\n\t}\n#endif\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145081,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "void CLASS parse_qt (int end)\n{\n  unsigned save, size;\n  char tag[4];\n\n  order = 0x4d4d;\n  while (ftell(ifp)+7 < end) {\n    save = ftell(ifp);\n    if ((size = get4()) < 8) return;\n    fread (tag, 4, 1, ifp);\n    if (!memcmp(tag,\"moov\",4) ||\n\t!memcmp(tag,\"udta\",4) ||\n\t!memcmp(tag,\"CNTH\",4))\n      parse_qt (save+size);\n    if (!memcmp(tag,\"CNDA\",4))\n      parse_jpeg (ftell(ifp));\n    fseek (ifp, save+size, SEEK_SET);\n  }\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145164,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "void CLASS parse_qt (int end)\n{\n  unsigned save, size;\n  char tag[4];\n\n  order = 0x4d4d;\n  while (ftell(ifp)+7 < end) {\n    save = ftell(ifp);\n    if ((size = get4()) < 8) return;\n    if ((int)size < 0) return; // 2+GB is too much\n    if (save + size < save) return; // 32bit overflow\n    fread (tag, 4, 1, ifp);\n    if (!memcmp(tag,\"moov\",4) ||\n\t!memcmp(tag,\"udta\",4) ||\n\t!memcmp(tag,\"CNTH\",4))\n      parse_qt (save+size);\n    if (!memcmp(tag,\"CNDA\",4))\n      parse_jpeg (ftell(ifp));\n    fseek (ifp, save+size, SEEK_SET);\n  }\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145165,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "PyObject *PyBytes_DecodeEscape(const char *s,\n                                Py_ssize_t len,\n                                const char *errors,\n                                Py_ssize_t unicode,\n                                const char *recode_encoding)\n{\n    int c;\n    char *p, *buf;\n    const char *end;\n    PyObject *v;\n    Py_ssize_t newlen = recode_encoding ? 4*len:len;\n    v = PyBytes_FromStringAndSize((char *)NULL, newlen);\n    if (v == NULL)\n        return NULL;\n    p = buf = PyBytes_AsString(v);\n    end = s + len;\n    while (s < end) {\n        if (*s != '\\\\') {\n          non_esc:\n            if (recode_encoding && (*s & 0x80)) {\n                PyObject *u, *w;\n                char *r;\n                const char* t;\n                Py_ssize_t rn;\n                t = s;\n                /* Decode non-ASCII bytes as UTF-8. */\n                while (t < end && (*t & 0x80)) t++;\n                u = PyUnicode_DecodeUTF8(s, t - s, errors);\n                if(!u) goto failed;\n\n                /* Recode them in target encoding. */\n                w = PyUnicode_AsEncodedString(\n                    u, recode_encoding, errors);\n                Py_DECREF(u);\n                if (!w)                 goto failed;\n\n                /* Append bytes to output buffer. */\n                assert(PyBytes_Check(w));\n                r = PyBytes_AS_STRING(w);\n                rn = PyBytes_GET_SIZE(w);\n                Py_MEMCPY(p, r, rn);\n                p += rn;\n                Py_DECREF(w);\n                s = t;\n            } else {\n                *p++ = *s++;\n            }\n            continue;\n        }\n        s++;\n        if (s==end) {\n            PyErr_SetString(PyExc_ValueError,\n                            \"Trailing \\\\ in string\");\n            goto failed;\n        }\n        switch (*s++) {\n        /* XXX This assumes ASCII! */\n        case '\\n': break;\n        case '\\\\': *p++ = '\\\\'; break;\n        case '\\'': *p++ = '\\''; break;\n        case '\\\"': *p++ = '\\\"'; break;\n        case 'b': *p++ = '\\b'; break;\n        case 'f': *p++ = '\\014'; break; /* FF */\n        case 't': *p++ = '\\t'; break;\n        case 'n': *p++ = '\\n'; break;\n        case 'r': *p++ = '\\r'; break;\n        case 'v': *p++ = '\\013'; break; /* VT */\n        case 'a': *p++ = '\\007'; break; /* BEL, not classic C */\n        case '0': case '1': case '2': case '3':\n        case '4': case '5': case '6': case '7':\n            c = s[-1] - '0';\n            if (s < end && '0' <= *s && *s <= '7') {\n                c = (c<<3) + *s++ - '0';\n                if (s < end && '0' <= *s && *s <= '7')\n                    c = (c<<3) + *s++ - '0';\n            }\n            *p++ = c;\n            break;\n        case 'x':\n            if (s+1 < end && Py_ISXDIGIT(s[0]) && Py_ISXDIGIT(s[1])) {\n                unsigned int x = 0;\n                c = Py_CHARMASK(*s);\n                s++;\n                if (Py_ISDIGIT(c))\n                    x = c - '0';\n                else if (Py_ISLOWER(c))\n                    x = 10 + c - 'a';\n                else\n                    x = 10 + c - 'A';\n                x = x << 4;\n                c = Py_CHARMASK(*s);\n                s++;\n                if (Py_ISDIGIT(c))\n                    x += c - '0';\n                else if (Py_ISLOWER(c))\n                    x += 10 + c - 'a';\n                else\n                    x += 10 + c - 'A';\n                *p++ = x;\n                break;\n            }\n            if (!errors || strcmp(errors, \"strict\") == 0) {\n                PyErr_Format(PyExc_ValueError,\n                             \"invalid \\\\x escape at position %d\",\n                             s - 2 - (end - len));\n                goto failed;\n            }\n            if (strcmp(errors, \"replace\") == 0) {\n                *p++ = '?';\n            } else if (strcmp(errors, \"ignore\") == 0)\n                /* do nothing */;\n            else {\n                PyErr_Format(PyExc_ValueError,\n                             \"decoding error; unknown \"\n                             \"error handling code: %.400s\",\n                             errors);\n                goto failed;\n            }\n            /* skip \\x */\n            if (s < end && Py_ISXDIGIT(s[0]))\n                s++; /* and a hexdigit */\n            break;\n        default:\n            *p++ = '\\\\';\n            s--;\n            goto non_esc; /* an arbitrary number of unescaped\n                             UTF-8 bytes may follow. */\n        }\n    }\n    if (p-buf < newlen)\n        _PyBytes_Resize(&v, p - buf);\n    return v;\n  failed:\n    Py_DECREF(v);\n    return NULL;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145220,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "PyObject *PyBytes_DecodeEscape(const char *s,\n                                Py_ssize_t len,\n                                const char *errors,\n                                Py_ssize_t unicode,\n                                const char *recode_encoding)\n{\n    int c;\n    char *p, *buf;\n    const char *end;\n    PyObject *v;\n    Py_ssize_t newlen;\n    /* Check for integer overflow */\n    if (recode_encoding && (len > PY_SSIZE_T_MAX / 4)) {\n        PyErr_SetString(PyExc_OverflowError, \"string is too large\");\n        return NULL;\n    }\n    newlen = recode_encoding ? 4*len:len;\n    v = PyBytes_FromStringAndSize((char *)NULL, newlen);\n    if (v == NULL)\n        return NULL;\n    p = buf = PyBytes_AsString(v);\n    end = s + len;\n    while (s < end) {\n        if (*s != '\\\\') {\n          non_esc:\n            if (recode_encoding && (*s & 0x80)) {\n                PyObject *u, *w;\n                char *r;\n                const char* t;\n                Py_ssize_t rn;\n                t = s;\n                /* Decode non-ASCII bytes as UTF-8. */\n                while (t < end && (*t & 0x80)) t++;\n                u = PyUnicode_DecodeUTF8(s, t - s, errors);\n                if(!u) goto failed;\n\n                /* Recode them in target encoding. */\n                w = PyUnicode_AsEncodedString(\n                    u, recode_encoding, errors);\n                Py_DECREF(u);\n                if (!w)                 goto failed;\n\n                /* Append bytes to output buffer. */\n                assert(PyBytes_Check(w));\n                r = PyBytes_AS_STRING(w);\n                rn = PyBytes_GET_SIZE(w);\n                Py_MEMCPY(p, r, rn);\n                p += rn;\n                Py_DECREF(w);\n                s = t;\n            } else {\n                *p++ = *s++;\n            }\n            continue;\n        }\n        s++;\n        if (s==end) {\n            PyErr_SetString(PyExc_ValueError,\n                            \"Trailing \\\\ in string\");\n            goto failed;\n        }\n        switch (*s++) {\n        /* XXX This assumes ASCII! */\n        case '\\n': break;\n        case '\\\\': *p++ = '\\\\'; break;\n        case '\\'': *p++ = '\\''; break;\n        case '\\\"': *p++ = '\\\"'; break;\n        case 'b': *p++ = '\\b'; break;\n        case 'f': *p++ = '\\014'; break; /* FF */\n        case 't': *p++ = '\\t'; break;\n        case 'n': *p++ = '\\n'; break;\n        case 'r': *p++ = '\\r'; break;\n        case 'v': *p++ = '\\013'; break; /* VT */\n        case 'a': *p++ = '\\007'; break; /* BEL, not classic C */\n        case '0': case '1': case '2': case '3':\n        case '4': case '5': case '6': case '7':\n            c = s[-1] - '0';\n            if (s < end && '0' <= *s && *s <= '7') {\n                c = (c<<3) + *s++ - '0';\n                if (s < end && '0' <= *s && *s <= '7')\n                    c = (c<<3) + *s++ - '0';\n            }\n            *p++ = c;\n            break;\n        case 'x':\n            if (s+1 < end && Py_ISXDIGIT(s[0]) && Py_ISXDIGIT(s[1])) {\n                unsigned int x = 0;\n                c = Py_CHARMASK(*s);\n                s++;\n                if (Py_ISDIGIT(c))\n                    x = c - '0';\n                else if (Py_ISLOWER(c))\n                    x = 10 + c - 'a';\n                else\n                    x = 10 + c - 'A';\n                x = x << 4;\n                c = Py_CHARMASK(*s);\n                s++;\n                if (Py_ISDIGIT(c))\n                    x += c - '0';\n                else if (Py_ISLOWER(c))\n                    x += 10 + c - 'a';\n                else\n                    x += 10 + c - 'A';\n                *p++ = x;\n                break;\n            }\n            if (!errors || strcmp(errors, \"strict\") == 0) {\n                PyErr_Format(PyExc_ValueError,\n                             \"invalid \\\\x escape at position %d\",\n                             s - 2 - (end - len));\n                goto failed;\n            }\n            if (strcmp(errors, \"replace\") == 0) {\n                *p++ = '?';\n            } else if (strcmp(errors, \"ignore\") == 0)\n                /* do nothing */;\n            else {\n                PyErr_Format(PyExc_ValueError,\n                             \"decoding error; unknown \"\n                             \"error handling code: %.400s\",\n                             errors);\n                goto failed;\n            }\n            /* skip \\x */\n            if (s < end && Py_ISXDIGIT(s[0]))\n                s++; /* and a hexdigit */\n            break;\n        default:\n            *p++ = '\\\\';\n            s--;\n            goto non_esc; /* an arbitrary number of unescaped\n                             UTF-8 bytes may follow. */\n        }\n    }\n    if (p-buf < newlen)\n        _PyBytes_Resize(&v, p - buf);\n    return v;\n  failed:\n    Py_DECREF(v);\n    return NULL;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145221,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "PyObject *PyString_DecodeEscape(const char *s,\n                                Py_ssize_t len,\n                                const char *errors,\n                                Py_ssize_t unicode,\n                                const char *recode_encoding)\n{\n    int c;\n    char *p, *buf;\n    const char *end;\n    PyObject *v;\n    Py_ssize_t newlen = recode_encoding ? 4*len:len;\n    v = PyString_FromStringAndSize((char *)NULL, newlen);\n    if (v == NULL)\n        return NULL;\n    p = buf = PyString_AsString(v);\n    end = s + len;\n    while (s < end) {\n        if (*s != '\\\\') {\n          non_esc:\n#ifdef Py_USING_UNICODE\n            if (recode_encoding && (*s & 0x80)) {\n                PyObject *u, *w;\n                char *r;\n                const char* t;\n                Py_ssize_t rn;\n                t = s;\n                /* Decode non-ASCII bytes as UTF-8. */\n                while (t < end && (*t & 0x80)) t++;\n                u = PyUnicode_DecodeUTF8(s, t - s, errors);\n                if(!u) goto failed;\n\n                /* Recode them in target encoding. */\n                w = PyUnicode_AsEncodedString(\n                    u, recode_encoding, errors);\n                Py_DECREF(u);\n                if (!w)                 goto failed;\n\n                /* Append bytes to output buffer. */\n                assert(PyString_Check(w));\n                r = PyString_AS_STRING(w);\n                rn = PyString_GET_SIZE(w);\n                Py_MEMCPY(p, r, rn);\n                p += rn;\n                Py_DECREF(w);\n                s = t;\n            } else {\n                *p++ = *s++;\n            }\n#else\n            *p++ = *s++;\n#endif\n            continue;\n        }\n        s++;\n        if (s==end) {\n            PyErr_SetString(PyExc_ValueError,\n                            \"Trailing \\\\ in string\");\n            goto failed;\n        }\n        switch (*s++) {\n        /* XXX This assumes ASCII! */\n        case '\\n': break;\n        case '\\\\': *p++ = '\\\\'; break;\n        case '\\'': *p++ = '\\''; break;\n        case '\\\"': *p++ = '\\\"'; break;\n        case 'b': *p++ = '\\b'; break;\n        case 'f': *p++ = '\\014'; break; /* FF */\n        case 't': *p++ = '\\t'; break;\n        case 'n': *p++ = '\\n'; break;\n        case 'r': *p++ = '\\r'; break;\n        case 'v': *p++ = '\\013'; break; /* VT */\n        case 'a': *p++ = '\\007'; break; /* BEL, not classic C */\n        case '0': case '1': case '2': case '3':\n        case '4': case '5': case '6': case '7':\n            c = s[-1] - '0';\n            if (s < end && '0' <= *s && *s <= '7') {\n                c = (c<<3) + *s++ - '0';\n                if (s < end && '0' <= *s && *s <= '7')\n                    c = (c<<3) + *s++ - '0';\n            }\n            *p++ = c;\n            break;\n        case 'x':\n            if (s+1 < end &&\n                isxdigit(Py_CHARMASK(s[0])) &&\n                isxdigit(Py_CHARMASK(s[1])))\n            {\n                unsigned int x = 0;\n                c = Py_CHARMASK(*s);\n                s++;\n                if (isdigit(c))\n                    x = c - '0';\n                else if (islower(c))\n                    x = 10 + c - 'a';\n                else\n                    x = 10 + c - 'A';\n                x = x << 4;\n                c = Py_CHARMASK(*s);\n                s++;\n                if (isdigit(c))\n                    x += c - '0';\n                else if (islower(c))\n                    x += 10 + c - 'a';\n                else\n                    x += 10 + c - 'A';\n                *p++ = x;\n                break;\n            }\n            if (!errors || strcmp(errors, \"strict\") == 0) {\n                PyErr_SetString(PyExc_ValueError,\n                                \"invalid \\\\x escape\");\n                goto failed;\n            }\n            if (strcmp(errors, \"replace\") == 0) {\n                *p++ = '?';\n            } else if (strcmp(errors, \"ignore\") == 0)\n                /* do nothing */;\n            else {\n                PyErr_Format(PyExc_ValueError,\n                             \"decoding error; \"\n                             \"unknown error handling code: %.400s\",\n                             errors);\n                goto failed;\n            }\n            /* skip \\x */\n            if (s < end && isxdigit(Py_CHARMASK(s[0])))\n                s++; /* and a hexdigit */\n            break;\n#ifndef Py_USING_UNICODE\n        case 'u':\n        case 'U':\n        case 'N':\n            if (unicode) {\n                PyErr_SetString(PyExc_ValueError,\n                          \"Unicode escapes not legal \"\n                          \"when Unicode disabled\");\n                goto failed;\n            }\n#endif\n        default:\n            *p++ = '\\\\';\n            s--;\n            goto non_esc; /* an arbitrary number of unescaped\n                             UTF-8 bytes may follow. */\n        }\n    }\n    if (p-buf < newlen)\n        _PyString_Resize(&v, p - buf); /* v is cleared on error */\n    return v;\n  failed:\n    Py_DECREF(v);\n    return NULL;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145262,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "PyObject *PyString_DecodeEscape(const char *s,\n                                Py_ssize_t len,\n                                const char *errors,\n                                Py_ssize_t unicode,\n                                const char *recode_encoding)\n{\n    int c;\n    char *p, *buf;\n    const char *end;\n    PyObject *v;\n    Py_ssize_t newlen;\n    /* Check for integer overflow */\n    if (recode_encoding && (len > PY_SSIZE_T_MAX / 4)) {\n        PyErr_SetString(PyExc_OverflowError, \"string is too large\");\n        return NULL;\n    }\n    newlen = recode_encoding ? 4*len:len;\n    v = PyString_FromStringAndSize((char *)NULL, newlen);\n    if (v == NULL)\n        return NULL;\n    p = buf = PyString_AsString(v);\n    end = s + len;\n    while (s < end) {\n        if (*s != '\\\\') {\n          non_esc:\n#ifdef Py_USING_UNICODE\n            if (recode_encoding && (*s & 0x80)) {\n                PyObject *u, *w;\n                char *r;\n                const char* t;\n                Py_ssize_t rn;\n                t = s;\n                /* Decode non-ASCII bytes as UTF-8. */\n                while (t < end && (*t & 0x80)) t++;\n                u = PyUnicode_DecodeUTF8(s, t - s, errors);\n                if(!u) goto failed;\n\n                /* Recode them in target encoding. */\n                w = PyUnicode_AsEncodedString(\n                    u, recode_encoding, errors);\n                Py_DECREF(u);\n                if (!w)                 goto failed;\n\n                /* Append bytes to output buffer. */\n                assert(PyString_Check(w));\n                r = PyString_AS_STRING(w);\n                rn = PyString_GET_SIZE(w);\n                Py_MEMCPY(p, r, rn);\n                p += rn;\n                Py_DECREF(w);\n                s = t;\n            } else {\n                *p++ = *s++;\n            }\n#else\n            *p++ = *s++;\n#endif\n            continue;\n        }\n        s++;\n        if (s==end) {\n            PyErr_SetString(PyExc_ValueError,\n                            \"Trailing \\\\ in string\");\n            goto failed;\n        }\n        switch (*s++) {\n        /* XXX This assumes ASCII! */\n        case '\\n': break;\n        case '\\\\': *p++ = '\\\\'; break;\n        case '\\'': *p++ = '\\''; break;\n        case '\\\"': *p++ = '\\\"'; break;\n        case 'b': *p++ = '\\b'; break;\n        case 'f': *p++ = '\\014'; break; /* FF */\n        case 't': *p++ = '\\t'; break;\n        case 'n': *p++ = '\\n'; break;\n        case 'r': *p++ = '\\r'; break;\n        case 'v': *p++ = '\\013'; break; /* VT */\n        case 'a': *p++ = '\\007'; break; /* BEL, not classic C */\n        case '0': case '1': case '2': case '3':\n        case '4': case '5': case '6': case '7':\n            c = s[-1] - '0';\n            if (s < end && '0' <= *s && *s <= '7') {\n                c = (c<<3) + *s++ - '0';\n                if (s < end && '0' <= *s && *s <= '7')\n                    c = (c<<3) + *s++ - '0';\n            }\n            *p++ = c;\n            break;\n        case 'x':\n            if (s+1 < end &&\n                isxdigit(Py_CHARMASK(s[0])) &&\n                isxdigit(Py_CHARMASK(s[1])))\n            {\n                unsigned int x = 0;\n                c = Py_CHARMASK(*s);\n                s++;\n                if (isdigit(c))\n                    x = c - '0';\n                else if (islower(c))\n                    x = 10 + c - 'a';\n                else\n                    x = 10 + c - 'A';\n                x = x << 4;\n                c = Py_CHARMASK(*s);\n                s++;\n                if (isdigit(c))\n                    x += c - '0';\n                else if (islower(c))\n                    x += 10 + c - 'a';\n                else\n                    x += 10 + c - 'A';\n                *p++ = x;\n                break;\n            }\n            if (!errors || strcmp(errors, \"strict\") == 0) {\n                PyErr_SetString(PyExc_ValueError,\n                                \"invalid \\\\x escape\");\n                goto failed;\n            }\n            if (strcmp(errors, \"replace\") == 0) {\n                *p++ = '?';\n            } else if (strcmp(errors, \"ignore\") == 0)\n                /* do nothing */;\n            else {\n                PyErr_Format(PyExc_ValueError,\n                             \"decoding error; \"\n                             \"unknown error handling code: %.400s\",\n                             errors);\n                goto failed;\n            }\n            /* skip \\x */\n            if (s < end && isxdigit(Py_CHARMASK(s[0])))\n                s++; /* and a hexdigit */\n            break;\n#ifndef Py_USING_UNICODE\n        case 'u':\n        case 'U':\n        case 'N':\n            if (unicode) {\n                PyErr_SetString(PyExc_ValueError,\n                          \"Unicode escapes not legal \"\n                          \"when Unicode disabled\");\n                goto failed;\n            }\n#endif\n        default:\n            *p++ = '\\\\';\n            s--;\n            goto non_esc; /* an arbitrary number of unescaped\n                             UTF-8 bytes may follow. */\n        }\n    }\n    if (p-buf < newlen)\n        _PyString_Resize(&v, p - buf); /* v is cleared on error */\n    return v;\n  failed:\n    Py_DECREF(v);\n    return NULL;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145263,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static MagickBooleanType WritePALMImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    currentOffset,\n    offset,\n    scene;\n\n  MagickSizeType\n    cc;\n\n  PixelInfo\n    transpix;\n\n  QuantizeInfo\n    *quantize_info;\n\n  register ssize_t\n    x;\n\n  register const Quantum\n    *p;\n\n  register Quantum\n    *q;\n\n  ssize_t\n    y;\n\n  size_t\n    count,\n    bits_per_pixel,\n    bytes_per_row,\n    imageListLength,\n    nextDepthOffset,\n    one;\n\n  unsigned char\n    bit,\n    byte,\n    color,\n    *last_row,\n    *one_row,\n    *ptr,\n    version;\n\n  unsigned int\n    transparentIndex;\n\n  unsigned short\n    color16,\n    flags;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  quantize_info=AcquireQuantizeInfo(image_info);\n  flags=0;\n  currentOffset=0;\n  transparentIndex=0;\n  transpix.red=0.0;\n  transpix.green=0.0;\n  transpix.blue=0.0;\n  transpix.alpha=0.0;\n  one=1;\n  version=0;\n  scene=0;\n  imageListLength=GetImageListLength(image);\n  do\n  {\n    (void) TransformImageColorspace(image,sRGBColorspace,exception);\n    count=GetNumberColors(image,NULL,exception);\n    for (bits_per_pixel=1; (one << bits_per_pixel) < count; bits_per_pixel*=2) ;\n    if (bits_per_pixel > 16)\n      bits_per_pixel=16;\n    else\n      if (bits_per_pixel < 16)\n        (void) TransformImageColorspace(image,image->colorspace,exception);\n    if (bits_per_pixel < 8)\n      {\n        (void) TransformImageColorspace(image,GRAYColorspace,exception);\n        (void) SetImageType(image,PaletteType,exception);\n        (void) SortColormapByIntensity(image,exception);\n      }\n    if ((image->storage_class == PseudoClass) && (image->colors > 256))\n      (void) SetImageStorageClass(image,DirectClass,exception);\n    if (image->storage_class == PseudoClass)\n      flags|=PALM_HAS_COLORMAP_FLAG;\n    else\n      flags|=PALM_IS_DIRECT_COLOR;\n    (void) WriteBlobMSBShort(image,(unsigned short) image->columns); /* width */\n    (void) WriteBlobMSBShort(image,(unsigned short) image->rows);  /* height */\n    bytes_per_row=((image->columns+(16/bits_per_pixel-1))/(16/\n      bits_per_pixel))*2;\n    (void) WriteBlobMSBShort(image,(unsigned short) bytes_per_row);\n    if ((image_info->compression == RLECompression) ||\n        (image_info->compression == FaxCompression))\n      flags|=PALM_IS_COMPRESSED_FLAG;\n    (void) WriteBlobMSBShort(image, flags);\n    (void) WriteBlobByte(image,(unsigned char) bits_per_pixel);\n    if (bits_per_pixel > 1)\n      version=1;\n    if ((image_info->compression == RLECompression) ||\n        (image_info->compression == FaxCompression))\n      version=2;\n    (void) WriteBlobByte(image,version);\n    (void) WriteBlobMSBShort(image,0);  /* nextDepthOffset */\n    (void) WriteBlobByte(image,(unsigned char) transparentIndex);\n    if (image_info->compression == RLECompression)\n      (void) WriteBlobByte(image,PALM_COMPRESSION_RLE);\n    else\n      if (image_info->compression == FaxCompression)\n        (void) WriteBlobByte(image,PALM_COMPRESSION_SCANLINE);\n      else\n        (void) WriteBlobByte(image,PALM_COMPRESSION_NONE);\n    (void) WriteBlobMSBShort(image,0);  /* reserved */\n    offset=16;\n    if (bits_per_pixel == 16)\n      {\n        (void) WriteBlobByte(image,5);  /* # of bits of red */\n        (void) WriteBlobByte(image,6);  /* # of bits of green */\n        (void) WriteBlobByte(image,5);  /* # of bits of blue */\n        (void) WriteBlobByte(image,0);  /* reserved by Palm */\n        (void) WriteBlobMSBLong(image,0);  /* no transparent color, YET */\n        offset+=8;\n      }\n    if (bits_per_pixel == 8)\n      {\n        if (flags & PALM_HAS_COLORMAP_FLAG)  /* Write out colormap */\n          {\n            quantize_info->dither_method=IdentifyPaletteImage(image,exception)\n              == MagickFalse ? RiemersmaDitherMethod : NoDitherMethod;\n            quantize_info->number_colors=image->colors;\n            (void) QuantizeImage(quantize_info,image,exception);\n            (void) WriteBlobMSBShort(image,(unsigned short) image->colors);\n            for (count = 0; count < image->colors; count++)\n            {\n              (void) WriteBlobByte(image,(unsigned char) count);\n              (void) WriteBlobByte(image,ScaleQuantumToChar(ClampToQuantum(\n                image->colormap[count].red)));\n              (void) WriteBlobByte(image,ScaleQuantumToChar(ClampToQuantum(\n                image->colormap[count].green)));\n              (void) WriteBlobByte(image,ScaleQuantumToChar(ClampToQuantum(\n                image->colormap[count].blue)));\n            }\n            offset+=2+count*4;\n          }\n      else  /* Map colors to Palm standard colormap */\n        {\n          Image\n            *affinity_image;\n\n          affinity_image=ConstituteImage(256,1,\"RGB\",CharPixel,&PalmPalette,\n            exception);\n          (void) TransformImageColorspace(affinity_image,\n            affinity_image->colorspace,exception);\n          (void) RemapImage(quantize_info,image,affinity_image,exception);\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelIndex(image,(Quantum) FindColor(&image->colormap[(ssize_t)\n                GetPixelIndex(image,q)]),q);\n              q+=GetPixelChannels(image);\n            }\n          }\n          affinity_image=DestroyImage(affinity_image);\n        }\n      }\n    if (flags & PALM_IS_COMPRESSED_FLAG)\n      (void) WriteBlobMSBShort(image,0);  /* fill in size later */\n    last_row=(unsigned char *) NULL;\n    if (image_info->compression == FaxCompression)\n      {\n        last_row=(unsigned char *) AcquireQuantumMemory(bytes_per_row+256,\n          sizeof(*last_row));\n        if (last_row == (unsigned char *) NULL)\n          {\n            quantize_info=DestroyQuantizeInfo(quantize_info);\n            ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n      }\n    one_row=(unsigned char *) AcquireQuantumMemory(bytes_per_row+256,\n      sizeof(*one_row));\n    if (one_row == (unsigned char *) NULL)\n      {\n        if (last_row != (unsigned char *) NULL) \n          last_row=(unsigned char *) RelinquishMagickMemory(last_row);\n        quantize_info=DestroyQuantizeInfo(quantize_info);\n        ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      ptr=one_row;\n      (void) memset(ptr,0,bytes_per_row);\n      p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n      if (p == (const Quantum *) NULL)\n        break;\n      if (bits_per_pixel == 16)\n        {\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            color16=(unsigned short) ((((31*(size_t) GetPixelRed(image,p))/\n              (size_t) QuantumRange) << 11) | (((63*(size_t)\n              GetPixelGreen(image,p))/(size_t) QuantumRange) << 5) |\n              ((31*(size_t) GetPixelBlue(image,p))/(size_t) QuantumRange));\n            if (GetPixelAlpha(image,p) == (Quantum) TransparentAlpha)\n              {\n                transpix.red=(MagickRealType) GetPixelRed(image,p);\n                transpix.green=(MagickRealType) GetPixelGreen(image,p);\n                transpix.blue=(MagickRealType) GetPixelBlue(image,p);\n                transpix.alpha=(MagickRealType) GetPixelAlpha(image,p);\n                flags|=PALM_HAS_TRANSPARENCY_FLAG;\n              }\n            *ptr++=(unsigned char) ((color16 >> 8) & 0xff);\n            *ptr++=(unsigned char) (color16 & 0xff);\n            p+=GetPixelChannels(image);\n          }\n        }\n      else\n        {\n          byte=0x00;\n          bit=(unsigned char) (8-bits_per_pixel);\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            if (bits_per_pixel >= 8)\n              color=(unsigned char) GetPixelIndex(image,p);\n            else\n              color=(unsigned char) (GetPixelIndex(image,p)*\n                ((one << bits_per_pixel)-1)/MagickMax(1*image->colors-1,1));\n            byte|=color << bit;\n            if (bit != 0)\n              bit-=(unsigned char) bits_per_pixel;\n            else\n              {\n                *ptr++=byte;\n                byte=0x00;\n                bit=(unsigned char) (8-bits_per_pixel);\n              }\n            p+=GetPixelChannels(image);\n          }\n          if ((image->columns % (8/bits_per_pixel)) != 0)\n            *ptr++=byte;\n        }\n      if (image_info->compression == RLECompression)\n        {\n          x=0;\n          while (x < (ssize_t) bytes_per_row)\n          {\n            byte=one_row[x];\n            count=1;\n            while ((one_row[++x] == byte) && (count < 255) &&\n                   (x < (ssize_t) bytes_per_row))\n              count++;\n            (void) WriteBlobByte(image,(unsigned char) count);\n            (void) WriteBlobByte(image,(unsigned char) byte);\n          }\n        }\n      else\n        if (image_info->compression == FaxCompression)\n          {\n            char\n              tmpbuf[8],\n              *tptr;\n  \n            for (x = 0;  x < (ssize_t) bytes_per_row;  x += 8)\n            {\n              tptr = tmpbuf;\n              for (bit=0, byte=0; bit < (unsigned char) MagickMin(8,(ssize_t) bytes_per_row-x); bit++)\n              {\n                if ((y == 0) || (last_row[x + bit] != one_row[x + bit]))\n                  {\n                    byte |= (1 << (7 - bit));\n                    *tptr++ = (char) one_row[x + bit];\n                  }\n              }\n              (void) WriteBlobByte(image, byte);\n              (void) WriteBlob(image,tptr-tmpbuf,(unsigned char *) tmpbuf);\n            }\n            (void) memcpy(last_row,one_row,bytes_per_row);\n          }\n        else\n          (void) WriteBlob(image,bytes_per_row,one_row);\n      }\n    if (flags & PALM_HAS_TRANSPARENCY_FLAG)\n      {\n        offset=SeekBlob(image,currentOffset+6,SEEK_SET);\n        (void) WriteBlobMSBShort(image,flags);\n        offset=SeekBlob(image,currentOffset+12,SEEK_SET);\n        (void) WriteBlobByte(image,(unsigned char) transparentIndex);  /* trans index */\n      }\n    if (bits_per_pixel == 16)\n      {\n        offset=SeekBlob(image,currentOffset+20,SEEK_SET);\n        (void) WriteBlobByte(image,0);  /* reserved by Palm */\n        (void) WriteBlobByte(image,(unsigned char) ((31*transpix.red)/\n          QuantumRange));\n        (void) WriteBlobByte(image,(unsigned char) ((63*transpix.green)/\n          QuantumRange));\n        (void) WriteBlobByte(image,(unsigned char) ((31*transpix.blue)/\n          QuantumRange));\n      }\n    if (flags & PALM_IS_COMPRESSED_FLAG)  /* fill in size now */\n      {\n        offset=SeekBlob(image,currentOffset+offset,SEEK_SET);\n        (void) WriteBlobMSBShort(image,(unsigned short) (GetBlobSize(image)-\n          currentOffset-offset));\n      }\n    if (one_row != (unsigned char *) NULL) \n      one_row=(unsigned char *) RelinquishMagickMemory(one_row);\n    if (last_row != (unsigned char *) NULL) \n      last_row=(unsigned char *) RelinquishMagickMemory(last_row);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    /* padding to 4 byte word */\n    for (cc=(GetBlobSize(image)) % 4; cc > 0; cc--)\n      (void) WriteBlobByte(image,0);\n    /* write nextDepthOffset and return to end of image */\n    offset=SeekBlob(image,currentOffset+10,SEEK_SET);\n    nextDepthOffset=(size_t) ((GetBlobSize(image)-currentOffset)/4);\n    (void) WriteBlobMSBShort(image,(unsigned short) nextDepthOffset);\n    currentOffset=(MagickOffsetType) GetBlobSize(image);\n    offset=SeekBlob(image,currentOffset,SEEK_SET);\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,imageListLength);\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  quantize_info=DestroyQuantizeInfo(quantize_info);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145266,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static MagickBooleanType WritePALMImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    currentOffset,\n    offset,\n    scene;\n\n  MagickSizeType\n    cc;\n\n  PixelInfo\n    transpix;\n\n  QuantizeInfo\n    *quantize_info;\n\n  register ssize_t\n    x;\n\n  register const Quantum\n    *p;\n\n  register Quantum\n    *q;\n\n  ssize_t\n    y;\n\n  size_t\n    count,\n    bits_per_pixel,\n    bytes_per_row,\n    imageListLength,\n    nextDepthOffset,\n    one;\n\n  unsigned char\n    bit,\n    byte,\n    color,\n    *last_row,\n    *one_row,\n    *ptr,\n    version;\n\n  unsigned int\n    transparentIndex;\n\n  unsigned short\n    color16,\n    flags;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  quantize_info=AcquireQuantizeInfo(image_info);\n  flags=0;\n  currentOffset=0;\n  transparentIndex=0;\n  transpix.red=0.0;\n  transpix.green=0.0;\n  transpix.blue=0.0;\n  transpix.alpha=0.0;\n  one=1;\n  version=0;\n  scene=0;\n  imageListLength=GetImageListLength(image);\n  do\n  {\n    (void) TransformImageColorspace(image,sRGBColorspace,exception);\n    count=GetNumberColors(image,NULL,exception);\n    for (bits_per_pixel=1; (one << bits_per_pixel) < count; bits_per_pixel*=2) ;\n    if (bits_per_pixel > 16)\n      bits_per_pixel=16;\n    else\n      if (bits_per_pixel < 16)\n        (void) TransformImageColorspace(image,image->colorspace,exception);\n    if (bits_per_pixel < 8)\n      {\n        (void) TransformImageColorspace(image,GRAYColorspace,exception);\n        (void) SetImageType(image,PaletteType,exception);\n        (void) SortColormapByIntensity(image,exception);\n      }\n    if ((image->storage_class == PseudoClass) && (image->colors > 256))\n      (void) SetImageStorageClass(image,DirectClass,exception);\n    if (image->storage_class == PseudoClass)\n      flags|=PALM_HAS_COLORMAP_FLAG;\n    else\n      flags|=PALM_IS_DIRECT_COLOR;\n    (void) WriteBlobMSBShort(image,(unsigned short) image->columns); /* width */\n    (void) WriteBlobMSBShort(image,(unsigned short) image->rows);  /* height */\n    bytes_per_row=((image->columns+(16/bits_per_pixel-1))/(16/\n      bits_per_pixel))*2;\n    (void) WriteBlobMSBShort(image,(unsigned short) bytes_per_row);\n    if ((image_info->compression == RLECompression) ||\n        (image_info->compression == FaxCompression))\n      flags|=PALM_IS_COMPRESSED_FLAG;\n    (void) WriteBlobMSBShort(image, flags);\n    (void) WriteBlobByte(image,(unsigned char) bits_per_pixel);\n    if (bits_per_pixel > 1)\n      version=1;\n    if ((image_info->compression == RLECompression) ||\n        (image_info->compression == FaxCompression))\n      version=2;\n    (void) WriteBlobByte(image,version);\n    (void) WriteBlobMSBShort(image,0);  /* nextDepthOffset */\n    (void) WriteBlobByte(image,(unsigned char) transparentIndex);\n    if (image_info->compression == RLECompression)\n      (void) WriteBlobByte(image,PALM_COMPRESSION_RLE);\n    else\n      if (image_info->compression == FaxCompression)\n        (void) WriteBlobByte(image,PALM_COMPRESSION_SCANLINE);\n      else\n        (void) WriteBlobByte(image,PALM_COMPRESSION_NONE);\n    (void) WriteBlobMSBShort(image,0);  /* reserved */\n    offset=16;\n    if (bits_per_pixel == 16)\n      {\n        (void) WriteBlobByte(image,5);  /* # of bits of red */\n        (void) WriteBlobByte(image,6);  /* # of bits of green */\n        (void) WriteBlobByte(image,5);  /* # of bits of blue */\n        (void) WriteBlobByte(image,0);  /* reserved by Palm */\n        (void) WriteBlobMSBLong(image,0);  /* no transparent color, YET */\n        offset+=8;\n      }\n    if (bits_per_pixel == 8)\n      {\n        if (flags & PALM_HAS_COLORMAP_FLAG)  /* Write out colormap */\n          {\n            quantize_info->dither_method=IdentifyPaletteImage(image,exception)\n              == MagickFalse ? RiemersmaDitherMethod : NoDitherMethod;\n            quantize_info->number_colors=image->colors;\n            (void) QuantizeImage(quantize_info,image,exception);\n            (void) WriteBlobMSBShort(image,(unsigned short) image->colors);\n            for (count = 0; count < image->colors; count++)\n            {\n              (void) WriteBlobByte(image,(unsigned char) count);\n              (void) WriteBlobByte(image,ScaleQuantumToChar(ClampToQuantum(\n                image->colormap[count].red)));\n              (void) WriteBlobByte(image,ScaleQuantumToChar(ClampToQuantum(\n                image->colormap[count].green)));\n              (void) WriteBlobByte(image,ScaleQuantumToChar(ClampToQuantum(\n                image->colormap[count].blue)));\n            }\n            offset+=2+count*4;\n          }\n      else  /* Map colors to Palm standard colormap */\n        {\n          Image\n            *affinity_image;\n\n          affinity_image=ConstituteImage(256,1,\"RGB\",CharPixel,&PalmPalette,\n            exception);\n          (void) TransformImageColorspace(affinity_image,\n            affinity_image->colorspace,exception);\n          (void) RemapImage(quantize_info,image,affinity_image,exception);\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelIndex(image,(Quantum) FindColor(&image->colormap[(ssize_t)\n                GetPixelIndex(image,q)]),q);\n              q+=GetPixelChannels(image);\n            }\n          }\n          affinity_image=DestroyImage(affinity_image);\n        }\n      }\n    if (flags & PALM_IS_COMPRESSED_FLAG)\n      (void) WriteBlobMSBShort(image,0);  /* fill in size later */\n    last_row=(unsigned char *) NULL;\n    if (image_info->compression == FaxCompression)\n      {\n        last_row=(unsigned char *) AcquireQuantumMemory(bytes_per_row+256,\n          sizeof(*last_row));\n        if (last_row == (unsigned char *) NULL)\n          {\n            quantize_info=DestroyQuantizeInfo(quantize_info);\n            ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n      }\n    one_row=(unsigned char *) AcquireQuantumMemory(bytes_per_row+256,\n      sizeof(*one_row));\n    if (one_row == (unsigned char *) NULL)\n      {\n        if (last_row != (unsigned char *) NULL) \n          last_row=(unsigned char *) RelinquishMagickMemory(last_row);\n        quantize_info=DestroyQuantizeInfo(quantize_info);\n        ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      ptr=one_row;\n      (void) memset(ptr,0,bytes_per_row);\n      p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n      if (p == (const Quantum *) NULL)\n        break;\n      if (bits_per_pixel == 16)\n        {\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            color16=(unsigned short) ((((31*(ssize_t) GetPixelRed(image,p))/\n              (ssize_t) QuantumRange) << 11) | (((63*(ssize_t)\n              GetPixelGreen(image,p))/(ssize_t) QuantumRange) << 5) |\n              ((31*(ssize_t) GetPixelBlue(image,p))/(ssize_t) QuantumRange));\n            if (GetPixelAlpha(image,p) == (Quantum) TransparentAlpha)\n              {\n                transpix.red=(MagickRealType) GetPixelRed(image,p);\n                transpix.green=(MagickRealType) GetPixelGreen(image,p);\n                transpix.blue=(MagickRealType) GetPixelBlue(image,p);\n                transpix.alpha=(MagickRealType) GetPixelAlpha(image,p);\n                flags|=PALM_HAS_TRANSPARENCY_FLAG;\n              }\n            *ptr++=(unsigned char) ((color16 >> 8) & 0xff);\n            *ptr++=(unsigned char) (color16 & 0xff);\n            p+=GetPixelChannels(image);\n          }\n        }\n      else\n        {\n          byte=0x00;\n          bit=(unsigned char) (8-bits_per_pixel);\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            if (bits_per_pixel >= 8)\n              color=(unsigned char) GetPixelIndex(image,p);\n            else\n              color=(unsigned char) (GetPixelIndex(image,p)*\n                ((one << bits_per_pixel)-1)/MagickMax(1*image->colors-1,1));\n            byte|=color << bit;\n            if (bit != 0)\n              bit-=(unsigned char) bits_per_pixel;\n            else\n              {\n                *ptr++=byte;\n                byte=0x00;\n                bit=(unsigned char) (8-bits_per_pixel);\n              }\n            p+=GetPixelChannels(image);\n          }\n          if ((image->columns % (8/bits_per_pixel)) != 0)\n            *ptr++=byte;\n        }\n      if (image_info->compression == RLECompression)\n        {\n          x=0;\n          while (x < (ssize_t) bytes_per_row)\n          {\n            byte=one_row[x];\n            count=1;\n            while ((one_row[++x] == byte) && (count < 255) &&\n                   (x < (ssize_t) bytes_per_row))\n              count++;\n            (void) WriteBlobByte(image,(unsigned char) count);\n            (void) WriteBlobByte(image,(unsigned char) byte);\n          }\n        }\n      else\n        if (image_info->compression == FaxCompression)\n          {\n            char\n              tmpbuf[8],\n              *tptr;\n  \n            for (x = 0;  x < (ssize_t) bytes_per_row;  x += 8)\n            {\n              tptr = tmpbuf;\n              for (bit=0, byte=0; bit < (unsigned char) MagickMin(8,(ssize_t) bytes_per_row-x); bit++)\n              {\n                if ((y == 0) || (last_row[x + bit] != one_row[x + bit]))\n                  {\n                    byte |= (1 << (7 - bit));\n                    *tptr++ = (char) one_row[x + bit];\n                  }\n              }\n              (void) WriteBlobByte(image, byte);\n              (void) WriteBlob(image,tptr-tmpbuf,(unsigned char *) tmpbuf);\n            }\n            (void) memcpy(last_row,one_row,bytes_per_row);\n          }\n        else\n          (void) WriteBlob(image,bytes_per_row,one_row);\n      }\n    if (flags & PALM_HAS_TRANSPARENCY_FLAG)\n      {\n        offset=SeekBlob(image,currentOffset+6,SEEK_SET);\n        (void) WriteBlobMSBShort(image,flags);\n        offset=SeekBlob(image,currentOffset+12,SEEK_SET);\n        (void) WriteBlobByte(image,(unsigned char) transparentIndex);  /* trans index */\n      }\n    if (bits_per_pixel == 16)\n      {\n        offset=SeekBlob(image,currentOffset+20,SEEK_SET);\n        (void) WriteBlobByte(image,0);  /* reserved by Palm */\n        (void) WriteBlobByte(image,(unsigned char) ((31*transpix.red)/\n          QuantumRange));\n        (void) WriteBlobByte(image,(unsigned char) ((63*transpix.green)/\n          QuantumRange));\n        (void) WriteBlobByte(image,(unsigned char) ((31*transpix.blue)/\n          QuantumRange));\n      }\n    if (flags & PALM_IS_COMPRESSED_FLAG)  /* fill in size now */\n      {\n        offset=SeekBlob(image,currentOffset+offset,SEEK_SET);\n        (void) WriteBlobMSBShort(image,(unsigned short) (GetBlobSize(image)-\n          currentOffset-offset));\n      }\n    if (one_row != (unsigned char *) NULL) \n      one_row=(unsigned char *) RelinquishMagickMemory(one_row);\n    if (last_row != (unsigned char *) NULL) \n      last_row=(unsigned char *) RelinquishMagickMemory(last_row);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    /* padding to 4 byte word */\n    for (cc=(GetBlobSize(image)) % 4; cc > 0; cc--)\n      (void) WriteBlobByte(image,0);\n    /* write nextDepthOffset and return to end of image */\n    offset=SeekBlob(image,currentOffset+10,SEEK_SET);\n    nextDepthOffset=(size_t) ((GetBlobSize(image)-currentOffset)/4);\n    (void) WriteBlobMSBShort(image,(unsigned short) nextDepthOffset);\n    currentOffset=(MagickOffsetType) GetBlobSize(image);\n    offset=SeekBlob(image,currentOffset,SEEK_SET);\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,imageListLength);\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  quantize_info=DestroyQuantizeInfo(quantize_info);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145267,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "    void PngImage::readMetadata()\n    {\n#ifdef DEBUG\n        std::cerr << \"Exiv2::PngImage::readMetadata: Reading PNG file \" << io_->path() << std::endl;\n#endif\n        if (io_->open() != 0)\n        {\n            throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        }\n        IoCloser closer(*io_);\n        if (!isPngType(*io_, true)) {\n            throw Error(kerNotAnImage, \"PNG\");\n        }\n        clearMetadata();\n\n        const long imgSize = (long) io_->size();\n        DataBuf cheaderBuf(8);       // Chunk header: 4 bytes (data size) + 4 bytes (chunk type).\n\n        while(!io_->eof())\n        {\n            std::memset(cheaderBuf.pData_, 0x0, cheaderBuf.size_);\n            readChunk(cheaderBuf, *io_); // Read chunk header.\n\n            // Decode chunk data length.\n            uint32_t chunkLength = Exiv2::getULong(cheaderBuf.pData_, Exiv2::bigEndian);\n            long pos = io_->tell();\n            if (pos == -1 ||\n                chunkLength > uint32_t(0x7FFFFFFF) ||\n                static_cast<long>(chunkLength) > imgSize - pos) {\n                throw Exiv2::Error(kerFailedToReadImageData);\n            }\n\n            std::string chunkType(reinterpret_cast<char *>(cheaderBuf.pData_) + 4, 4);\n#ifdef DEBUG\n            std::cout << \"Exiv2::PngImage::readMetadata: chunk type: \" << chunkType\n                      << \" length: \" << chunkLength << std::endl;\n#endif\n\n            /// \\todo analyse remaining chunks of the standard\n            // Perform a chunk triage for item that we need.\n            if (chunkType == \"IEND\" || chunkType == \"IHDR\" || chunkType == \"tEXt\" || chunkType == \"zTXt\" ||\n                chunkType == \"iTXt\" || chunkType == \"iCCP\") {\n                DataBuf chunkData(chunkLength);\n                readChunk(chunkData, *io_);  // Extract chunk data.\n\n                if (chunkType == \"IEND\") {\n                    return;  // Last chunk found: we stop parsing.\n                } else if (chunkType == \"IHDR\" && chunkData.size_ >= 8) {\n                    PngChunk::decodeIHDRChunk(chunkData, &pixelWidth_, &pixelHeight_);\n                } else if (chunkType == \"tEXt\") {\n                    PngChunk::decodeTXTChunk(this, chunkData, PngChunk::tEXt_Chunk);\n                } else if (chunkType == \"zTXt\") {\n                    PngChunk::decodeTXTChunk(this, chunkData, PngChunk::zTXt_Chunk);\n                } else if (chunkType == \"iTXt\") {\n                    PngChunk::decodeTXTChunk(this, chunkData, PngChunk::iTXt_Chunk);\n                } else if (chunkType == \"iCCP\") {\n                    // The ICC profile name can vary from 1-79 characters.\n                    uint32_t iccOffset = 0;\n                    while (iccOffset < 80 && iccOffset < chunkLength) {\n                         if (chunkData.pData_[iccOffset++] ==  0x00) {\n                            break;\n                         }\n                    }\n                    profileName_ = std::string(reinterpret_cast<char *>(chunkData.pData_), iccOffset-1);\n                    ++iccOffset; // +1 = 'compressed' flag\n                    enforce(iccOffset <= chunkLength, Exiv2::kerCorruptedMetadata);\n\n                    zlibToDataBuf(chunkData.pData_ + iccOffset, chunkLength - iccOffset, iccProfile_);\n#ifdef DEBUG\n                    std::cout << \"Exiv2::PngImage::readMetadata: profile name: \" << profileName_ << std::endl;\n                    std::cout << \"Exiv2::PngImage::readMetadata: iccProfile.size_ (uncompressed) : \"\n                              << iccProfile_.size_ << std::endl;\n#endif\n                }\n\n                // Set chunkLength to 0 in case we have read a supported chunk type. Otherwise, we need to seek the\n                // file to the next chunk position.\n                chunkLength = 0;\n            }\n\n\n            // Move to the next chunk: chunk data size + 4 CRC bytes.\n#ifdef DEBUG\n            std::cout << \"Exiv2::PngImage::readMetadata: Seek to offset: \" << chunkLength + 4 << std::endl;\n#endif\n            io_->seek(chunkLength + 4 , BasicIo::cur);\n            if (io_->error() || io_->eof()) {\n                throw Error(kerFailedToReadImageData);\n            }\n        }\n    } // PngImage::readMetadata",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145320,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "    void PngImage::readMetadata()\n    {\n#ifdef DEBUG\n        std::cerr << \"Exiv2::PngImage::readMetadata: Reading PNG file \" << io_->path() << std::endl;\n#endif\n        if (io_->open() != 0)\n        {\n            throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        }\n        IoCloser closer(*io_);\n        if (!isPngType(*io_, true)) {\n            throw Error(kerNotAnImage, \"PNG\");\n        }\n        clearMetadata();\n\n        const long imgSize = (long) io_->size();\n        DataBuf cheaderBuf(8);       // Chunk header: 4 bytes (data size) + 4 bytes (chunk type).\n\n        while(!io_->eof())\n        {\n            std::memset(cheaderBuf.pData_, 0x0, cheaderBuf.size_);\n            readChunk(cheaderBuf, *io_); // Read chunk header.\n\n            // Decode chunk data length.\n            uint32_t chunkLength = Exiv2::getULong(cheaderBuf.pData_, Exiv2::bigEndian);\n            long pos = io_->tell();\n            if (pos == -1 ||\n                chunkLength > uint32_t(0x7FFFFFFF) ||\n                static_cast<long>(chunkLength) > imgSize - pos) {\n                throw Exiv2::Error(kerFailedToReadImageData);\n            }\n\n            std::string chunkType(reinterpret_cast<char *>(cheaderBuf.pData_) + 4, 4);\n#ifdef DEBUG\n            std::cout << \"Exiv2::PngImage::readMetadata: chunk type: \" << chunkType\n                      << \" length: \" << chunkLength << std::endl;\n#endif\n\n            /// \\todo analyse remaining chunks of the standard\n            // Perform a chunk triage for item that we need.\n            if (chunkType == \"IEND\" || chunkType == \"IHDR\" || chunkType == \"tEXt\" || chunkType == \"zTXt\" ||\n                chunkType == \"iTXt\" || chunkType == \"iCCP\") {\n                DataBuf chunkData(chunkLength);\n                readChunk(chunkData, *io_);  // Extract chunk data.\n\n                if (chunkType == \"IEND\") {\n                    return;  // Last chunk found: we stop parsing.\n                } else if (chunkType == \"IHDR\" && chunkData.size_ >= 8) {\n                    PngChunk::decodeIHDRChunk(chunkData, &pixelWidth_, &pixelHeight_);\n                } else if (chunkType == \"tEXt\") {\n                    PngChunk::decodeTXTChunk(this, chunkData, PngChunk::tEXt_Chunk);\n                } else if (chunkType == \"zTXt\") {\n                    PngChunk::decodeTXTChunk(this, chunkData, PngChunk::zTXt_Chunk);\n                } else if (chunkType == \"iTXt\") {\n                    PngChunk::decodeTXTChunk(this, chunkData, PngChunk::iTXt_Chunk);\n                } else if (chunkType == \"iCCP\") {\n                    // The ICC profile name can vary from 1-79 characters.\n                    uint32_t iccOffset = 0;\n                    do {\n                      enforce(iccOffset < 80 && iccOffset < chunkLength,\n                              Exiv2::kerCorruptedMetadata);\n                    } while(chunkData.pData_[iccOffset++] != 0x00);\n\n                    profileName_ = std::string(reinterpret_cast<char *>(chunkData.pData_), iccOffset-1);\n                    ++iccOffset; // +1 = 'compressed' flag\n                    enforce(iccOffset <= chunkLength, Exiv2::kerCorruptedMetadata);\n\n                    zlibToDataBuf(chunkData.pData_ + iccOffset, chunkLength - iccOffset, iccProfile_);\n#ifdef DEBUG\n                    std::cout << \"Exiv2::PngImage::readMetadata: profile name: \" << profileName_ << std::endl;\n                    std::cout << \"Exiv2::PngImage::readMetadata: iccProfile.size_ (uncompressed) : \"\n                              << iccProfile_.size_ << std::endl;\n#endif\n                }\n\n                // Set chunkLength to 0 in case we have read a supported chunk type. Otherwise, we need to seek the\n                // file to the next chunk position.\n                chunkLength = 0;\n            }\n\n\n            // Move to the next chunk: chunk data size + 4 CRC bytes.\n#ifdef DEBUG\n            std::cout << \"Exiv2::PngImage::readMetadata: Seek to offset: \" << chunkLength + 4 << std::endl;\n#endif\n            io_->seek(chunkLength + 4 , BasicIo::cur);\n            if (io_->error() || io_->eof()) {\n                throw Error(kerFailedToReadImageData);\n            }\n        }\n    } // PngImage::readMetadata",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145321,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static pyc_object *get_long_object(RzBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tbool neg = false;\n\tut32 tmp = 0;\n\tsize_t size;\n\tsize_t i, j = 0, left = 0;\n\tut32 n;\n\tchar *hexstr;\n\tchar digist2hex[] = \"0123456789abcdef\";\n\n\tst32 ndigits = get_st32(buffer, &error);\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = RZ_NEW0(pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->type = TYPE_LONG;\n\tif (ndigits < 0) {\n\t\tndigits = -ndigits;\n\t\tneg = true;\n\t}\n\tif (ndigits == 0) {\n\t\tret->data = strdup(\"0x0\");\n\t} else {\n\t\tsize = ndigits * 15;\n\t\tsize = (size - 1) / 4 + 1;\n\t\tsize += 4 + (neg ? 1 : 0);\n\t\thexstr = malloc(size);\n\t\tif (!hexstr) {\n\t\t\tfree(ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tmemset(hexstr, 0x20, size);\n\t\tj = size - 1;\n\t\thexstr[j] = 0;\n\t\tfor (i = 0; i < ndigits; i++) {\n\t\t\tn = get_ut16(buffer, &error);\n\t\t\ttmp |= n << left;\n\t\t\tleft += 15;\n\n\t\t\twhile (left >= 4) {\n\t\t\t\thexstr[--j] = digist2hex[tmp & 0xf];\n\t\t\t\ttmp >>= 4;\n\t\t\t\tleft -= 4;\n\t\t\t}\n\t\t}\n\n\t\tif (tmp) {\n\t\t\thexstr[--j] = digist2hex[tmp & 0xf];\n\t\t}\n\n\t\thexstr[--j] = 'x';\n\t\thexstr[--j] = '0';\n\t\tif (neg) {\n\t\t\thexstr[--j] = '-';\n\t\t}\n\n\t\trz_str_trim(hexstr);\n\t\tret->data = hexstr;\n\t}\n\treturn ret;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145342,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static pyc_object *get_long_object(RzBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tbool neg = false;\n\tut32 tmp = 0;\n\tsize_t size;\n\tsize_t i, j = 0, left = 0;\n\tut32 n;\n\tchar *hexstr;\n\tchar digist2hex[] = \"0123456789abcdef\";\n\n\tst32 ndigits = get_st32(buffer, &error);\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = RZ_NEW0(pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->type = TYPE_LONG;\n\tif (ndigits < 0) {\n\t\tndigits = -ndigits;\n\t\tneg = true;\n\t}\n\tif (ndigits == 0) {\n\t\tret->data = strdup(\"0x0\");\n\t} else {\n\t\t// the explicit cast is safe since ndigits is positive\n\t\tsize = (size_t)ndigits * 15;\n\t\tsize = (size - 1) / 4 + 1;\n\t\tsize += 4 + (neg ? 1 : 0);\n\t\thexstr = malloc(size);\n\t\tif (!hexstr) {\n\t\t\tfree(ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tmemset(hexstr, 0x20, size);\n\t\tj = size - 1;\n\t\thexstr[j] = 0;\n\t\tfor (i = 0; i < ndigits; i++) {\n\t\t\tn = get_ut16(buffer, &error);\n\t\t\ttmp |= n << left;\n\t\t\tleft += 15;\n\n\t\t\twhile (left >= 4) {\n\t\t\t\thexstr[--j] = digist2hex[tmp & 0xf];\n\t\t\t\ttmp >>= 4;\n\t\t\t\tleft -= 4;\n\t\t\t}\n\t\t}\n\n\t\tif (tmp) {\n\t\t\thexstr[--j] = digist2hex[tmp & 0xf];\n\t\t}\n\n\t\thexstr[--j] = 'x';\n\t\thexstr[--j] = '0';\n\t\tif (neg) {\n\t\t\thexstr[--j] = '-';\n\t\t}\n\n\t\trz_str_trim(hexstr);\n\t\tret->data = hexstr;\n\t}\n\treturn ret;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145343,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static Image *ReadPNMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    format;\n\n  double\n    quantum_scale;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  QuantumAny\n    max_value;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  size_t\n    depth,\n    extent,\n    packet_size;\n\n  ssize_t\n    count,\n    row,\n    y;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read PNM image.\n  */\n  count=ReadBlob(image,1,(unsigned char *) &format);\n  do\n  {\n    /*\n      Initialize image structure.\n    */\n    if ((count != 1) || (format != 'P'))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    max_value=1;\n    quantum_type=RGBQuantum;\n    quantum_scale=1.0;\n    format=(char) ReadBlobByte(image);\n    if (format != '7')\n      {\n        /*\n          PBM, PGM, PPM, and PNM.\n        */\n        image->columns=(size_t) PNMInteger(image,10,exception);\n        image->rows=(size_t) PNMInteger(image,10,exception);\n        if ((format == 'f') || (format == 'F'))\n          {\n            char\n              scale[MagickPathExtent];\n\n            (void) ReadBlobString(image,scale);\n            quantum_scale=StringToDouble(scale,(char **) NULL);\n          }\n        else\n          {\n            if ((format == '1') || (format == '4'))\n              max_value=1;  /* bitmap */\n            else\n              max_value=(QuantumAny) PNMInteger(image,10,exception);\n          }\n      }\n    else\n      {\n        char\n          keyword[MagickPathExtent],\n          value[MagickPathExtent];\n\n        int\n          c;\n\n        register char\n          *p;\n\n        /*\n          PAM.\n        */\n        for (c=ReadBlobByte(image); c != EOF; c=ReadBlobByte(image))\n        {\n          while (isspace((int) ((unsigned char) c)) != 0)\n            c=ReadBlobByte(image);\n          if (c == '#')\n            {\n              /*\n                Comment.\n              */\n              c=PNMComment(image,exception);\n              c=ReadBlobByte(image);\n              while (isspace((int) ((unsigned char) c)) != 0)\n                c=ReadBlobByte(image);\n            }\n          p=keyword;\n          do\n          {\n            if ((size_t) (p-keyword) < (MagickPathExtent-1))\n              *p++=c;\n            c=ReadBlobByte(image);\n          } while (isalnum(c));\n          *p='\\0';\n          if (LocaleCompare(keyword,\"endhdr\") == 0)\n            break;\n          while (isspace((int) ((unsigned char) c)) != 0)\n            c=ReadBlobByte(image);\n          p=value;\n          while (isalnum(c) || (c == '_'))\n          {\n            if ((size_t) (p-value) < (MagickPathExtent-1))\n              *p++=c;\n            c=ReadBlobByte(image);\n          }\n          *p='\\0';\n          /*\n            Assign a value to the specified keyword.\n          */\n          if (LocaleCompare(keyword,\"depth\") == 0)\n            packet_size=StringToUnsignedLong(value);\n          (void) packet_size;\n          if (LocaleCompare(keyword,\"height\") == 0)\n            image->rows=StringToUnsignedLong(value);\n          if (LocaleCompare(keyword,\"maxval\") == 0)\n            max_value=StringToUnsignedLong(value);\n          if (LocaleCompare(keyword,\"TUPLTYPE\") == 0)\n            {\n              if (LocaleCompare(value,\"BLACKANDWHITE\") == 0)\n                {\n                  (void) SetImageColorspace(image,GRAYColorspace,exception);\n                  quantum_type=GrayQuantum;\n                }\n              if (LocaleCompare(value,\"BLACKANDWHITE_ALPHA\") == 0)\n                {\n                  (void) SetImageColorspace(image,GRAYColorspace,exception);\n                  image->alpha_trait=BlendPixelTrait;\n                  quantum_type=GrayAlphaQuantum;\n                }\n              if (LocaleCompare(value,\"GRAYSCALE\") == 0)\n                {\n                  quantum_type=GrayQuantum;\n                  (void) SetImageColorspace(image,GRAYColorspace,exception);\n                }\n              if (LocaleCompare(value,\"GRAYSCALE_ALPHA\") == 0)\n                {\n                  (void) SetImageColorspace(image,GRAYColorspace,exception);\n                  image->alpha_trait=BlendPixelTrait;\n                  quantum_type=GrayAlphaQuantum;\n                }\n              if (LocaleCompare(value,\"RGB_ALPHA\") == 0)\n                {\n                  image->alpha_trait=BlendPixelTrait;\n                  quantum_type=RGBAQuantum;\n                }\n              if (LocaleCompare(value,\"CMYK\") == 0)\n                {\n                  (void) SetImageColorspace(image,CMYKColorspace,exception);\n                  quantum_type=CMYKQuantum;\n                }\n              if (LocaleCompare(value,\"CMYK_ALPHA\") == 0)\n                {\n                  (void) SetImageColorspace(image,CMYKColorspace,exception);\n                  image->alpha_trait=BlendPixelTrait;\n                  quantum_type=CMYKAQuantum;\n                }\n            }\n          if (LocaleCompare(keyword,\"width\") == 0)\n            image->columns=StringToUnsignedLong(value);\n        }\n      }\n    if ((image->columns == 0) || (image->rows == 0))\n      ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\");\n    if ((max_value == 0) || (max_value > 4294967295))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    for (depth=1; GetQuantumRange(depth) < max_value; depth++) ;\n    image->depth=depth;\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    /*\n      Convert PNM pixels to runextent-encoded MIFF packets.\n    */\n    row=0;\n    switch (format)\n    {\n      case '1':\n      {\n        /*\n          Convert PBM image to pixel packets.\n        */\n        (void) SetImageColorspace(image,GRAYColorspace,exception);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register ssize_t\n            x;\n\n          register Quantum\n            *magick_restrict q;\n\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelGray(image,PNMInteger(image,2,exception) == 0 ?\n              QuantumRange : 0,q);\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        image->type=BilevelType;\n        break;\n      }\n      case '2':\n      {\n        Quantum\n          intensity;\n\n        /*\n          Convert PGM image to pixel packets.\n        */\n        (void) SetImageColorspace(image,GRAYColorspace,exception);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register ssize_t\n            x;\n\n          register Quantum\n            *magick_restrict q;\n\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            intensity=ScaleAnyToQuantum(PNMInteger(image,10,exception),\n              max_value);\n            SetPixelGray(image,intensity,q);\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        image->type=GrayscaleType;\n        break;\n      }\n      case '3':\n      {\n        /*\n          Convert PNM image to pixel packets.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register ssize_t\n            x;\n\n          register Quantum\n            *magick_restrict q;\n\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            Quantum\n              pixel;\n\n            pixel=ScaleAnyToQuantum(PNMInteger(image,10,exception),max_value);\n            SetPixelRed(image,pixel,q);\n            pixel=ScaleAnyToQuantum(PNMInteger(image,10,exception),max_value);\n            SetPixelGreen(image,pixel,q);\n            pixel=ScaleAnyToQuantum(PNMInteger(image,10,exception),max_value);\n            SetPixelBlue(image,pixel,q);\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case '4':\n      {\n        /*\n          Convert PBM raw image to pixel packets.\n        */\n        (void) SetImageColorspace(image,GRAYColorspace,exception);\n        quantum_type=GrayQuantum;\n        if (image->storage_class == PseudoClass)\n          quantum_type=IndexQuantum;\n        quantum_info=AcquireQuantumInfo(image_info,image);\n        if (quantum_info == (QuantumInfo *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        SetQuantumMinIsWhite(quantum_info,MagickTrue);\n        extent=GetQuantumExtent(image,quantum_info,quantum_type);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          const unsigned char\n            *pixels;\n\n          MagickBooleanType\n            sync;\n\n          register Quantum\n            *magick_restrict q;\n\n          ssize_t\n            count,\n            offset;\n\n          size_t\n            length;\n\n          if (status == MagickFalse)\n            continue;\n          pixels=(unsigned char *) ReadBlobStream(image,extent,\n            GetQuantumPixels(quantum_info),&count);\n          if (count != (ssize_t) extent)\n            status=MagickFalse;\n          if ((image->progress_monitor != (MagickProgressMonitor) NULL) &&\n              (image->previous == (Image *) NULL))\n            {\n              MagickBooleanType\n                proceed;\n\n              proceed=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                row,image->rows);\n              if (proceed == MagickFalse)\n                status=MagickFalse;\n            }\n          offset=row++;\n          q=QueueAuthenticPixels(image,0,offset,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            {\n              status=MagickFalse;\n              continue;\n            }\n          length=ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            quantum_type,pixels,exception);\n          if (length != extent)\n            status=MagickFalse;\n          sync=SyncAuthenticPixels(image,exception);\n          if (sync == MagickFalse)\n            status=MagickFalse;\n        }\n        quantum_info=DestroyQuantumInfo(quantum_info);\n        if (status == MagickFalse)\n          ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n        SetQuantumImageType(image,quantum_type);\n        break;\n      }\n      case '5':\n      {\n        /*\n          Convert PGM raw image to pixel packets.\n        */\n        (void) SetImageColorspace(image,GRAYColorspace,exception);\n        quantum_type=GrayQuantum;\n        if (image->depth <= 8)\n          extent=image->columns;\n        else\n          if (image->depth <= 16)\n            extent=2*image->columns;\n          else\n            extent=4*image->columns;\n        quantum_info=AcquireQuantumInfo(image_info,image);\n        if (quantum_info == (QuantumInfo *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          const unsigned char\n            *pixels;\n\n          MagickBooleanType\n            sync;\n\n          register const unsigned char\n            *magick_restrict p;\n\n          register ssize_t\n            x;\n\n          register Quantum\n            *magick_restrict q;\n\n          ssize_t\n            count,\n            offset;\n\n          if (status == MagickFalse)\n            continue;\n          pixels=(unsigned char *) ReadBlobStream(image,extent,\n            GetQuantumPixels(quantum_info),&count);\n          if (count != (ssize_t) extent)\n            status=MagickFalse;\n          if ((image->progress_monitor != (MagickProgressMonitor) NULL) &&\n              (image->previous == (Image *) NULL))\n            {\n              MagickBooleanType\n                proceed;\n\n              proceed=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                row,image->rows);\n              if (proceed == MagickFalse)\n                status=MagickFalse;\n            }\n          offset=row++;\n          q=QueueAuthenticPixels(image,0,offset,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            {\n              status=MagickFalse;\n              continue;\n            }\n          p=pixels;\n          switch (image->depth)\n          {\n            case 8:\n            case 16:\n            case 32:\n            {\n              (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                quantum_type,pixels,exception);\n              break;\n            }\n            default:\n            {\n              unsigned int\n                pixel;\n\n              if (image->depth <= 8)\n                {\n                  unsigned char\n                    pixel;\n\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    p=PushCharPixel(p,&pixel);\n                    SetPixelGray(image,ScaleAnyToQuantum(pixel,max_value),q);\n                    q+=GetPixelChannels(image);\n                  }\n                  break;\n                }\n              if (image->depth <= 16)\n                {\n                  unsigned short\n                    pixel;\n\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    p=PushShortPixel(MSBEndian,p,&pixel);\n                    SetPixelGray(image,ScaleAnyToQuantum(pixel,max_value),q);\n                    q+=GetPixelChannels(image);\n                  }\n                  break;\n                }\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                p=PushLongPixel(MSBEndian,p,&pixel);\n                SetPixelGray(image,ScaleAnyToQuantum(pixel,max_value),q);\n                q+=GetPixelChannels(image);\n              }\n              break;\n            }\n          }\n          sync=SyncAuthenticPixels(image,exception);\n          if (sync == MagickFalse)\n            status=MagickFalse;\n        }\n        quantum_info=DestroyQuantumInfo(quantum_info);\n        if (status == MagickFalse)\n          ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n        SetQuantumImageType(image,quantum_type);\n        break;\n      }\n      case '6':\n      {\n        /*\n          Convert PNM raster image to pixel packets.\n        */\n        quantum_type=RGBQuantum;\n        extent=3*(image->depth <= 8 ? 1 : 2)*image->columns;\n        quantum_info=AcquireQuantumInfo(image_info,image);\n        if (quantum_info == (QuantumInfo *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) SetQuantumEndian(image,quantum_info,MSBEndian);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          const unsigned char\n            *pixels;\n\n          MagickBooleanType\n            sync;\n\n          register const unsigned char\n            *magick_restrict p;\n\n          register ssize_t\n            x;\n\n          register Quantum\n            *magick_restrict q;\n\n          ssize_t\n            count,\n            offset;\n\n          if (status == MagickFalse)\n            continue;\n          pixels=(unsigned char *) ReadBlobStream(image,extent,\n            GetQuantumPixels(quantum_info),&count);\n          if (count != (ssize_t) extent)\n            status=MagickFalse;\n          if ((image->progress_monitor != (MagickProgressMonitor) NULL) &&\n              (image->previous == (Image *) NULL))\n            {\n              MagickBooleanType\n                proceed;\n\n              proceed=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                row,image->rows);\n              if (proceed == MagickFalse)\n                status=MagickFalse;\n            }\n          offset=row++;\n          q=QueueAuthenticPixels(image,0,offset,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            {\n              status=MagickFalse;\n              continue;\n            }\n          p=pixels;\n          switch (image->depth)\n          {\n            case 8:\n            {\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n                SetPixelGreen(image,ScaleCharToQuantum(*p++),q);\n                SetPixelBlue(image,ScaleCharToQuantum(*p++),q);\n                SetPixelAlpha(image,OpaqueAlpha,q);\n                q+=GetPixelChannels(image);\n              }\n              break;\n            }\n            case 16:\n            {\n              unsigned short\n                pixel;\n\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                p=PushShortPixel(MSBEndian,p,&pixel);\n                SetPixelRed(image,ScaleShortToQuantum(pixel),q);\n                p=PushShortPixel(MSBEndian,p,&pixel);\n                SetPixelGreen(image,ScaleShortToQuantum(pixel),q);\n                p=PushShortPixel(MSBEndian,p,&pixel);\n                SetPixelBlue(image,ScaleShortToQuantum(pixel),q);\n                SetPixelAlpha(image,OpaqueAlpha,q);\n                q+=GetPixelChannels(image);\n              }\n              break;\n            }\n            case 32:\n            {\n              unsigned int\n                pixel;\n\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                p=PushLongPixel(MSBEndian,p,&pixel);\n                SetPixelRed(image,ScaleLongToQuantum(pixel),q);\n                p=PushLongPixel(MSBEndian,p,&pixel);\n                SetPixelGreen(image,ScaleLongToQuantum(pixel),q);\n                p=PushLongPixel(MSBEndian,p,&pixel);\n                SetPixelBlue(image,ScaleLongToQuantum(pixel),q);\n                SetPixelAlpha(image,OpaqueAlpha,q);\n                q+=GetPixelChannels(image);\n              }\n              break;\n            }\n            default:\n            {\n              unsigned int\n                pixel;\n\n              if (image->depth <= 8)\n                {\n                  unsigned char\n                    pixel;\n\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    p=PushCharPixel(p,&pixel);\n                    SetPixelRed(image,ScaleAnyToQuantum(pixel,max_value),q);\n                    p=PushCharPixel(p,&pixel);\n                    SetPixelGreen(image,ScaleAnyToQuantum(pixel,max_value),q);\n                    p=PushCharPixel(p,&pixel);\n                    SetPixelBlue(image,ScaleAnyToQuantum(pixel,max_value),q);\n                    SetPixelAlpha(image,OpaqueAlpha,q);\n                    q+=GetPixelChannels(image);\n                  }\n                  break;\n                }\n              if (image->depth <= 16)\n                {\n                  unsigned short\n                    pixel;\n\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    p=PushShortPixel(MSBEndian,p,&pixel);\n                    SetPixelRed(image,ScaleAnyToQuantum(pixel,max_value),q);\n                    p=PushShortPixel(MSBEndian,p,&pixel);\n                    SetPixelGreen(image,ScaleAnyToQuantum(pixel,max_value),q);\n                    p=PushShortPixel(MSBEndian,p,&pixel);\n                    SetPixelBlue(image,ScaleAnyToQuantum(pixel,max_value),q);\n                    SetPixelAlpha(image,OpaqueAlpha,q);\n                    q+=GetPixelChannels(image);\n                  }\n                  break;\n                }\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                p=PushLongPixel(MSBEndian,p,&pixel);\n                SetPixelRed(image,ScaleAnyToQuantum(pixel,max_value),q);\n                p=PushLongPixel(MSBEndian,p,&pixel);\n                SetPixelGreen(image,ScaleAnyToQuantum(pixel,max_value),q);\n                p=PushLongPixel(MSBEndian,p,&pixel);\n                SetPixelBlue(image,ScaleAnyToQuantum(pixel,max_value),q);\n                SetPixelAlpha(image,OpaqueAlpha,q);\n                q+=GetPixelChannels(image);\n              }\n              break;\n            }\n          }\n          sync=SyncAuthenticPixels(image,exception);\n          if (sync == MagickFalse)\n            status=MagickFalse;\n        }\n        quantum_info=DestroyQuantumInfo(quantum_info);\n        if (status == MagickFalse)\n          ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n        break;\n      }\n      case '7':\n      {\n        size_t\n          channels;\n\n        /*\n          Convert PAM raster image to pixel packets.\n        */\n        switch (quantum_type)\n        {\n          case GrayQuantum:\n          case GrayAlphaQuantum:\n          {\n            channels=1;\n            break;\n          }\n          case CMYKQuantum:\n          case CMYKAQuantum:\n          {\n            channels=4;\n            break;\n          }\n          default:\n          {\n            channels=3;\n            break;\n          }\n        }\n        if (image->alpha_trait != UndefinedPixelTrait)\n          channels++;\n        if (image->depth <= 8)\n          extent=channels*image->columns;\n        else\n          if (image->depth <= 16)\n            extent=2*channels*image->columns;\n          else\n            extent=4*channels*image->columns;\n        quantum_info=AcquireQuantumInfo(image_info,image);\n        if (quantum_info == (QuantumInfo *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          const unsigned char\n            *pixels;\n\n          MagickBooleanType\n            sync;\n\n          register const unsigned char\n            *magick_restrict p;\n\n          register ssize_t\n            x;\n\n          register Quantum\n            *magick_restrict q;\n\n          ssize_t\n            count,\n            offset;\n\n          if (status == MagickFalse)\n            continue;\n          pixels=(unsigned char *) ReadBlobStream(image,extent,\n            GetQuantumPixels(quantum_info),&count);\n          if (count != (ssize_t) extent)\n            status=MagickFalse;\n          if ((image->progress_monitor != (MagickProgressMonitor) NULL) &&\n              (image->previous == (Image *) NULL))\n            {\n              MagickBooleanType\n                proceed;\n\n              proceed=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                row,image->rows);\n              if (proceed == MagickFalse)\n                status=MagickFalse;\n            }\n          offset=row++;\n          q=QueueAuthenticPixels(image,0,offset,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            {\n              status=MagickFalse;\n              continue;\n            }\n          p=pixels;\n          switch (image->depth)\n          {\n            case 8:\n            case 16:\n            case 32:\n            {\n              (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                quantum_type,pixels,exception);\n              break;\n            }\n            default:\n            {\n              switch (quantum_type)\n              {\n                case GrayQuantum:\n                case GrayAlphaQuantum:\n                {\n                  unsigned int\n                    pixel;\n\n                  if (image->depth <= 8)\n                    {\n                      unsigned char\n                        pixel;\n\n                      for (x=0; x < (ssize_t) image->columns; x++)\n                      {\n                        p=PushCharPixel(p,&pixel);\n                        SetPixelGray(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                        SetPixelAlpha(image,OpaqueAlpha,q);\n                        if (image->alpha_trait != UndefinedPixelTrait)\n                          {\n                            p=PushCharPixel(p,&pixel);\n                            if (image->depth != 1)\n                              SetPixelAlpha(image,ScaleAnyToQuantum(pixel,\n                                max_value),q);\n                            else\n                              SetPixelAlpha(image,QuantumRange-\n                                ScaleAnyToQuantum(pixel,max_value),q);\n                          }\n                        q+=GetPixelChannels(image);\n                      }\n                      break;\n                    }\n                  if (image->depth <= 16)\n                    {\n                      unsigned short\n                        pixel;\n\n                      for (x=0; x < (ssize_t) image->columns; x++)\n                      {\n                        p=PushShortPixel(MSBEndian,p,&pixel);\n                        SetPixelGray(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                        SetPixelAlpha(image,OpaqueAlpha,q);\n                        if (image->alpha_trait != UndefinedPixelTrait)\n                          {\n                            p=PushShortPixel(MSBEndian,p,&pixel);\n                            SetPixelAlpha(image,ScaleAnyToQuantum(pixel,\n                              max_value),q);\n                          }\n                        q+=GetPixelChannels(image);\n                      }\n                      break;\n                    }\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    p=PushLongPixel(MSBEndian,p,&pixel);\n                    SetPixelGray(image,ScaleAnyToQuantum(pixel,max_value),q);\n                    SetPixelAlpha(image,OpaqueAlpha,q);\n                    if (image->alpha_trait != UndefinedPixelTrait)\n                      {\n                        p=PushLongPixel(MSBEndian,p,&pixel);\n                        SetPixelAlpha(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                      }\n                    q+=GetPixelChannels(image);\n                  }\n                  break;\n                }\n                case CMYKQuantum:\n                case CMYKAQuantum:\n                {\n                  unsigned int\n                    pixel;\n\n                  if (image->depth <= 8)\n                    {\n                      unsigned char\n                        pixel;\n\n                      for (x=0; x < (ssize_t) image->columns; x++)\n                      {\n                        p=PushCharPixel(p,&pixel);\n                        SetPixelRed(image,ScaleAnyToQuantum(pixel,max_value),q);\n                        p=PushCharPixel(p,&pixel);\n                        SetPixelGreen(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                        p=PushCharPixel(p,&pixel);\n                        SetPixelBlue(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                        p=PushCharPixel(p,&pixel);\n                        SetPixelBlack(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                        SetPixelAlpha(image,OpaqueAlpha,q);\n                        if (image->alpha_trait != UndefinedPixelTrait)\n                          {\n                            p=PushCharPixel(p,&pixel);\n                            SetPixelAlpha(image,ScaleAnyToQuantum(pixel,\n                              max_value),q);\n                          }\n                        q+=GetPixelChannels(image);\n                      }\n                      break;\n                    }\n                  if (image->depth <= 16)\n                    {\n                      unsigned short\n                        pixel;\n\n                      for (x=0; x < (ssize_t) image->columns; x++)\n                      {\n                        p=PushShortPixel(MSBEndian,p,&pixel);\n                        SetPixelRed(image,ScaleAnyToQuantum(pixel,max_value),q);\n                        p=PushShortPixel(MSBEndian,p,&pixel);\n                        SetPixelGreen(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                        p=PushShortPixel(MSBEndian,p,&pixel);\n                        SetPixelBlue(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                        p=PushShortPixel(MSBEndian,p,&pixel);\n                        SetPixelBlack(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                        SetPixelAlpha(image,OpaqueAlpha,q);\n                        if (image->alpha_trait != UndefinedPixelTrait)\n                          {\n                            p=PushShortPixel(MSBEndian,p,&pixel);\n                            SetPixelAlpha(image,ScaleAnyToQuantum(pixel,\n                              max_value),q);\n                          }\n                        q+=GetPixelChannels(image);\n                      }\n                    }\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    p=PushLongPixel(MSBEndian,p,&pixel);\n                    SetPixelRed(image,ScaleAnyToQuantum(pixel,max_value),q);\n                    p=PushLongPixel(MSBEndian,p,&pixel);\n                    SetPixelGreen(image,ScaleAnyToQuantum(pixel,max_value),q);\n                    p=PushLongPixel(MSBEndian,p,&pixel);\n                    SetPixelBlue(image,ScaleAnyToQuantum(pixel,max_value),q);\n                    p=PushLongPixel(MSBEndian,p,&pixel);\n                    SetPixelBlack(image,ScaleAnyToQuantum(pixel,max_value),q);\n                    SetPixelAlpha(image,OpaqueAlpha,q);\n                    if (image->alpha_trait != UndefinedPixelTrait)\n                      {\n                        p=PushLongPixel(MSBEndian,p,&pixel);\n                        SetPixelAlpha(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                      }\n                    q+=GetPixelChannels(image);\n                  }\n                  break;\n                }\n                default:\n                {\n                  unsigned int\n                    pixel;\n\n                  if (image->depth <= 8)\n                    {\n                      unsigned char\n                        pixel;\n\n                      for (x=0; x < (ssize_t) image->columns; x++)\n                      {\n                        p=PushCharPixel(p,&pixel);\n                        SetPixelRed(image,ScaleAnyToQuantum(pixel,max_value),q);\n                        p=PushCharPixel(p,&pixel);\n                        SetPixelGreen(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                        p=PushCharPixel(p,&pixel);\n                        SetPixelBlue(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                        SetPixelAlpha(image,OpaqueAlpha,q);\n                        if (image->alpha_trait != UndefinedPixelTrait)\n                          {\n                            p=PushCharPixel(p,&pixel);\n                            SetPixelAlpha(image,ScaleAnyToQuantum(pixel,\n                              max_value),q);\n                          }\n                        q+=GetPixelChannels(image);\n                      }\n                      break;\n                    }\n                  if (image->depth <= 16)\n                    {\n                      unsigned short\n                        pixel;\n\n                      for (x=0; x < (ssize_t) image->columns; x++)\n                      {\n                        p=PushShortPixel(MSBEndian,p,&pixel);\n                        SetPixelRed(image,ScaleAnyToQuantum(pixel,max_value),q);\n                        p=PushShortPixel(MSBEndian,p,&pixel);\n                        SetPixelGreen(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                        p=PushShortPixel(MSBEndian,p,&pixel);\n                        SetPixelBlue(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                        SetPixelAlpha(image,OpaqueAlpha,q);\n                        if (image->alpha_trait != UndefinedPixelTrait)\n                          {\n                            p=PushShortPixel(MSBEndian,p,&pixel);\n                            SetPixelAlpha(image,ScaleAnyToQuantum(pixel,\n                              max_value),q);\n                          }\n                        q+=GetPixelChannels(image);\n                      }\n                      break;\n                    }\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    p=PushLongPixel(MSBEndian,p,&pixel);\n                    SetPixelRed(image,ScaleAnyToQuantum(pixel,max_value),q);\n                    p=PushLongPixel(MSBEndian,p,&pixel);\n                    SetPixelGreen(image,ScaleAnyToQuantum(pixel,max_value),q);\n                    p=PushLongPixel(MSBEndian,p,&pixel);\n                    SetPixelBlue(image,ScaleAnyToQuantum(pixel,max_value),q);\n                    SetPixelAlpha(image,OpaqueAlpha,q);\n                    if (image->alpha_trait != UndefinedPixelTrait)\n                      {\n                        p=PushLongPixel(MSBEndian,p,&pixel);\n                        SetPixelAlpha(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                      }\n                    q+=GetPixelChannels(image);\n                  }\n                  break;\n                }\n              }\n            }\n          }\n          sync=SyncAuthenticPixels(image,exception);\n          if (sync == MagickFalse)\n            status=MagickFalse;\n        }\n        quantum_info=DestroyQuantumInfo(quantum_info);\n        if (status == MagickFalse)\n          ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n        SetQuantumImageType(image,quantum_type);\n        break;\n      }\n      case 'F':\n      case 'f':\n      {\n        /*\n          Convert PFM raster image to pixel packets.\n        */\n        if (format == 'f')\n          (void) SetImageColorspace(image,GRAYColorspace,exception);\n        quantum_type=format == 'f' ? GrayQuantum : RGBQuantum;\n        image->endian=quantum_scale < 0.0 ? LSBEndian : MSBEndian;\n        image->depth=32;\n        quantum_info=AcquireQuantumInfo(image_info,image);\n        if (quantum_info == (QuantumInfo *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        status=SetQuantumDepth(image,quantum_info,32);\n        if (status == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);\n        if (status == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        SetQuantumScale(quantum_info,(double) QuantumRange*fabs(quantum_scale));\n        extent=GetQuantumExtent(image,quantum_info,quantum_type);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          const unsigned char\n            *pixels;\n\n          MagickBooleanType\n            sync;\n\n          register Quantum\n            *magick_restrict q;\n\n          ssize_t\n            count,\n            offset;\n\n          size_t\n            length;\n\n          if (status == MagickFalse)\n            continue;\n          pixels=(unsigned char *) ReadBlobStream(image,extent,\n            GetQuantumPixels(quantum_info),&count);\n          if ((size_t) count != extent)\n            status=MagickFalse;\n          if ((image->progress_monitor != (MagickProgressMonitor) NULL) &&\n              (image->previous == (Image *) NULL))\n            {\n              MagickBooleanType\n                proceed;\n\n              proceed=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                row,image->rows);\n              if (proceed == MagickFalse)\n                status=MagickFalse;\n            }\n          offset=row++;\n          q=QueueAuthenticPixels(image,0,(ssize_t) (image->rows-offset-1),\n            image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            {\n              status=MagickFalse;\n              continue;\n            }\n          length=ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            quantum_type,pixels,exception);\n          if (length != extent)\n            status=MagickFalse;\n          sync=SyncAuthenticPixels(image,exception);\n          if (sync == MagickFalse)\n            status=MagickFalse;\n        }\n        quantum_info=DestroyQuantumInfo(quantum_info);\n        if (status == MagickFalse)\n          ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n        SetQuantumImageType(image,quantum_type);\n        break;\n      }\n      default:\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n    if (EOFBlob(image) != MagickFalse)\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          CorruptImageError,\"UnexpectedEndOfFile\",\"`%s'\",image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if ((format == '1') || (format == '2') || (format == '3'))\n      do\n      {\n        /*\n          Skip to end of line.\n        */\n        count=ReadBlob(image,1,(unsigned char *) &format);\n        if (count != 1)\n          break;\n        if (format == 'P')\n          break;\n      } while (format != '\\n');\n    count=ReadBlob(image,1,(unsigned char *) &format);\n    if ((count == 1) && (format == 'P'))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while ((count == 1) && (format == 'P'));\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145366,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static Image *ReadPNMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    format;\n\n  double\n    quantum_scale;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  QuantumAny\n    max_value;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  size_t\n    depth,\n    extent,\n    packet_size;\n\n  ssize_t\n    count,\n    row,\n    y;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read PNM image.\n  */\n  count=ReadBlob(image,1,(unsigned char *) &format);\n  do\n  {\n    /*\n      Initialize image structure.\n    */\n    if ((count != 1) || (format != 'P'))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    max_value=1;\n    quantum_type=RGBQuantum;\n    quantum_scale=1.0;\n    format=(char) ReadBlobByte(image);\n    if (format != '7')\n      {\n        /*\n          PBM, PGM, PPM, and PNM.\n        */\n        image->columns=(size_t) PNMInteger(image,10,exception);\n        image->rows=(size_t) PNMInteger(image,10,exception);\n        if ((format == 'f') || (format == 'F'))\n          {\n            char\n              scale[MagickPathExtent];\n\n            (void) ReadBlobString(image,scale);\n            quantum_scale=StringToDouble(scale,(char **) NULL);\n          }\n        else\n          {\n            if ((format == '1') || (format == '4'))\n              max_value=1;  /* bitmap */\n            else\n              max_value=(QuantumAny) PNMInteger(image,10,exception);\n          }\n      }\n    else\n      {\n        char\n          keyword[MagickPathExtent],\n          value[MagickPathExtent];\n\n        int\n          c;\n\n        register char\n          *p;\n\n        /*\n          PAM.\n        */\n        for (c=ReadBlobByte(image); c != EOF; c=ReadBlobByte(image))\n        {\n          while (isspace((int) ((unsigned char) c)) != 0)\n            c=ReadBlobByte(image);\n          if (c == '#')\n            {\n              /*\n                Comment.\n              */\n              c=PNMComment(image,exception);\n              c=ReadBlobByte(image);\n              while (isspace((int) ((unsigned char) c)) != 0)\n                c=ReadBlobByte(image);\n            }\n          p=keyword;\n          do\n          {\n            if ((size_t) (p-keyword) < (MagickPathExtent-1))\n              *p++=c;\n            c=ReadBlobByte(image);\n          } while (isalnum(c));\n          *p='\\0';\n          if (LocaleCompare(keyword,\"endhdr\") == 0)\n            break;\n          while (isspace((int) ((unsigned char) c)) != 0)\n            c=ReadBlobByte(image);\n          p=value;\n          while (isalnum(c) || (c == '_'))\n          {\n            if ((size_t) (p-value) < (MagickPathExtent-1))\n              *p++=c;\n            c=ReadBlobByte(image);\n          }\n          *p='\\0';\n          /*\n            Assign a value to the specified keyword.\n          */\n          if (LocaleCompare(keyword,\"depth\") == 0)\n            packet_size=StringToUnsignedLong(value);\n          (void) packet_size;\n          if (LocaleCompare(keyword,\"height\") == 0)\n            image->rows=StringToUnsignedLong(value);\n          if (LocaleCompare(keyword,\"maxval\") == 0)\n            max_value=StringToUnsignedLong(value);\n          if (LocaleCompare(keyword,\"TUPLTYPE\") == 0)\n            {\n              if (LocaleCompare(value,\"BLACKANDWHITE\") == 0)\n                {\n                  (void) SetImageColorspace(image,GRAYColorspace,exception);\n                  quantum_type=GrayQuantum;\n                }\n              if (LocaleCompare(value,\"BLACKANDWHITE_ALPHA\") == 0)\n                {\n                  (void) SetImageColorspace(image,GRAYColorspace,exception);\n                  image->alpha_trait=BlendPixelTrait;\n                  quantum_type=GrayAlphaQuantum;\n                }\n              if (LocaleCompare(value,\"GRAYSCALE\") == 0)\n                {\n                  quantum_type=GrayQuantum;\n                  (void) SetImageColorspace(image,GRAYColorspace,exception);\n                }\n              if (LocaleCompare(value,\"GRAYSCALE_ALPHA\") == 0)\n                {\n                  (void) SetImageColorspace(image,GRAYColorspace,exception);\n                  image->alpha_trait=BlendPixelTrait;\n                  quantum_type=GrayAlphaQuantum;\n                }\n              if (LocaleCompare(value,\"RGB_ALPHA\") == 0)\n                {\n                  image->alpha_trait=BlendPixelTrait;\n                  quantum_type=RGBAQuantum;\n                }\n              if (LocaleCompare(value,\"CMYK\") == 0)\n                {\n                  (void) SetImageColorspace(image,CMYKColorspace,exception);\n                  quantum_type=CMYKQuantum;\n                }\n              if (LocaleCompare(value,\"CMYK_ALPHA\") == 0)\n                {\n                  (void) SetImageColorspace(image,CMYKColorspace,exception);\n                  image->alpha_trait=BlendPixelTrait;\n                  quantum_type=CMYKAQuantum;\n                }\n            }\n          if (LocaleCompare(keyword,\"width\") == 0)\n            image->columns=StringToUnsignedLong(value);\n        }\n      }\n    if ((image->columns == 0) || (image->rows == 0))\n      ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\");\n    if ((max_value == 0) || (max_value > 4294967295))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    for (depth=1; GetQuantumRange(depth) < max_value; depth++) ;\n    image->depth=depth;\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    /*\n      Convert PNM pixels to runextent-encoded MIFF packets.\n    */\n    row=0;\n    switch (format)\n    {\n      case '1':\n      {\n        /*\n          Convert PBM image to pixel packets.\n        */\n        (void) SetImageColorspace(image,GRAYColorspace,exception);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register ssize_t\n            x;\n\n          register Quantum\n            *magick_restrict q;\n\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelGray(image,PNMInteger(image,2,exception) == 0 ?\n              QuantumRange : 0,q);\n            if (EOFBlob(image) != MagickFalse)\n              break;\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n          if (EOFBlob(image) != MagickFalse)\n            break;\n        }\n        image->type=BilevelType;\n        break;\n      }\n      case '2':\n      {\n        Quantum\n          intensity;\n\n        /*\n          Convert PGM image to pixel packets.\n        */\n        (void) SetImageColorspace(image,GRAYColorspace,exception);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register ssize_t\n            x;\n\n          register Quantum\n            *magick_restrict q;\n\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            intensity=ScaleAnyToQuantum(PNMInteger(image,10,exception),\n              max_value);\n            if (EOFBlob(image) != MagickFalse)\n              break;\n            SetPixelGray(image,intensity,q);\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n          if (EOFBlob(image) != MagickFalse)\n            break;\n        }\n        image->type=GrayscaleType;\n        break;\n      }\n      case '3':\n      {\n        /*\n          Convert PNM image to pixel packets.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register ssize_t\n            x;\n\n          register Quantum\n            *magick_restrict q;\n\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            Quantum\n              pixel;\n\n            pixel=ScaleAnyToQuantum(PNMInteger(image,10,exception),max_value);\n            if (EOFBlob(image) != MagickFalse)\n              break;\n            SetPixelRed(image,pixel,q);\n            pixel=ScaleAnyToQuantum(PNMInteger(image,10,exception),max_value);\n            SetPixelGreen(image,pixel,q);\n            pixel=ScaleAnyToQuantum(PNMInteger(image,10,exception),max_value);\n            SetPixelBlue(image,pixel,q);\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n          if (EOFBlob(image) != MagickFalse)\n            break;\n        }\n        break;\n      }\n      case '4':\n      {\n        /*\n          Convert PBM raw image to pixel packets.\n        */\n        (void) SetImageColorspace(image,GRAYColorspace,exception);\n        quantum_type=GrayQuantum;\n        if (image->storage_class == PseudoClass)\n          quantum_type=IndexQuantum;\n        quantum_info=AcquireQuantumInfo(image_info,image);\n        if (quantum_info == (QuantumInfo *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        SetQuantumMinIsWhite(quantum_info,MagickTrue);\n        extent=GetQuantumExtent(image,quantum_info,quantum_type);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          const unsigned char\n            *pixels;\n\n          MagickBooleanType\n            sync;\n\n          register Quantum\n            *magick_restrict q;\n\n          ssize_t\n            count,\n            offset;\n\n          size_t\n            length;\n\n          if (status == MagickFalse)\n            continue;\n          pixels=(unsigned char *) ReadBlobStream(image,extent,\n            GetQuantumPixels(quantum_info),&count);\n          if (count != (ssize_t) extent)\n            status=MagickFalse;\n          if ((image->progress_monitor != (MagickProgressMonitor) NULL) &&\n              (image->previous == (Image *) NULL))\n            {\n              MagickBooleanType\n                proceed;\n\n              proceed=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                row,image->rows);\n              if (proceed == MagickFalse)\n                status=MagickFalse;\n            }\n          offset=row++;\n          q=QueueAuthenticPixels(image,0,offset,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            {\n              status=MagickFalse;\n              continue;\n            }\n          length=ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            quantum_type,pixels,exception);\n          if (length != extent)\n            status=MagickFalse;\n          sync=SyncAuthenticPixels(image,exception);\n          if (sync == MagickFalse)\n            status=MagickFalse;\n        }\n        quantum_info=DestroyQuantumInfo(quantum_info);\n        if (status == MagickFalse)\n          ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n        SetQuantumImageType(image,quantum_type);\n        break;\n      }\n      case '5':\n      {\n        /*\n          Convert PGM raw image to pixel packets.\n        */\n        (void) SetImageColorspace(image,GRAYColorspace,exception);\n        quantum_type=GrayQuantum;\n        if (image->depth <= 8)\n          extent=image->columns;\n        else\n          if (image->depth <= 16)\n            extent=2*image->columns;\n          else\n            extent=4*image->columns;\n        quantum_info=AcquireQuantumInfo(image_info,image);\n        if (quantum_info == (QuantumInfo *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          const unsigned char\n            *pixels;\n\n          MagickBooleanType\n            sync;\n\n          register const unsigned char\n            *magick_restrict p;\n\n          register ssize_t\n            x;\n\n          register Quantum\n            *magick_restrict q;\n\n          ssize_t\n            count,\n            offset;\n\n          if (status == MagickFalse)\n            continue;\n          pixels=(unsigned char *) ReadBlobStream(image,extent,\n            GetQuantumPixels(quantum_info),&count);\n          if (count != (ssize_t) extent)\n            status=MagickFalse;\n          if ((image->progress_monitor != (MagickProgressMonitor) NULL) &&\n              (image->previous == (Image *) NULL))\n            {\n              MagickBooleanType\n                proceed;\n\n              proceed=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                row,image->rows);\n              if (proceed == MagickFalse)\n                status=MagickFalse;\n            }\n          offset=row++;\n          q=QueueAuthenticPixels(image,0,offset,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            {\n              status=MagickFalse;\n              continue;\n            }\n          p=pixels;\n          switch (image->depth)\n          {\n            case 8:\n            case 16:\n            case 32:\n            {\n              (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                quantum_type,pixels,exception);\n              break;\n            }\n            default:\n            {\n              unsigned int\n                pixel;\n\n              if (image->depth <= 8)\n                {\n                  unsigned char\n                    pixel;\n\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    p=PushCharPixel(p,&pixel);\n                    SetPixelGray(image,ScaleAnyToQuantum(pixel,max_value),q);\n                    q+=GetPixelChannels(image);\n                  }\n                  break;\n                }\n              if (image->depth <= 16)\n                {\n                  unsigned short\n                    pixel;\n\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    p=PushShortPixel(MSBEndian,p,&pixel);\n                    SetPixelGray(image,ScaleAnyToQuantum(pixel,max_value),q);\n                    q+=GetPixelChannels(image);\n                  }\n                  break;\n                }\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                p=PushLongPixel(MSBEndian,p,&pixel);\n                SetPixelGray(image,ScaleAnyToQuantum(pixel,max_value),q);\n                q+=GetPixelChannels(image);\n              }\n              break;\n            }\n          }\n          sync=SyncAuthenticPixels(image,exception);\n          if (sync == MagickFalse)\n            status=MagickFalse;\n        }\n        quantum_info=DestroyQuantumInfo(quantum_info);\n        if (status == MagickFalse)\n          ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n        SetQuantumImageType(image,quantum_type);\n        break;\n      }\n      case '6':\n      {\n        /*\n          Convert PNM raster image to pixel packets.\n        */\n        quantum_type=RGBQuantum;\n        extent=3*(image->depth <= 8 ? 1 : 2)*image->columns;\n        quantum_info=AcquireQuantumInfo(image_info,image);\n        if (quantum_info == (QuantumInfo *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) SetQuantumEndian(image,quantum_info,MSBEndian);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          const unsigned char\n            *pixels;\n\n          MagickBooleanType\n            sync;\n\n          register const unsigned char\n            *magick_restrict p;\n\n          register ssize_t\n            x;\n\n          register Quantum\n            *magick_restrict q;\n\n          ssize_t\n            count,\n            offset;\n\n          if (status == MagickFalse)\n            continue;\n          pixels=(unsigned char *) ReadBlobStream(image,extent,\n            GetQuantumPixels(quantum_info),&count);\n          if (count != (ssize_t) extent)\n            status=MagickFalse;\n          if ((image->progress_monitor != (MagickProgressMonitor) NULL) &&\n              (image->previous == (Image *) NULL))\n            {\n              MagickBooleanType\n                proceed;\n\n              proceed=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                row,image->rows);\n              if (proceed == MagickFalse)\n                status=MagickFalse;\n            }\n          offset=row++;\n          q=QueueAuthenticPixels(image,0,offset,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            {\n              status=MagickFalse;\n              continue;\n            }\n          p=pixels;\n          switch (image->depth)\n          {\n            case 8:\n            {\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n                SetPixelGreen(image,ScaleCharToQuantum(*p++),q);\n                SetPixelBlue(image,ScaleCharToQuantum(*p++),q);\n                SetPixelAlpha(image,OpaqueAlpha,q);\n                q+=GetPixelChannels(image);\n              }\n              break;\n            }\n            case 16:\n            {\n              unsigned short\n                pixel;\n\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                p=PushShortPixel(MSBEndian,p,&pixel);\n                SetPixelRed(image,ScaleShortToQuantum(pixel),q);\n                p=PushShortPixel(MSBEndian,p,&pixel);\n                SetPixelGreen(image,ScaleShortToQuantum(pixel),q);\n                p=PushShortPixel(MSBEndian,p,&pixel);\n                SetPixelBlue(image,ScaleShortToQuantum(pixel),q);\n                SetPixelAlpha(image,OpaqueAlpha,q);\n                q+=GetPixelChannels(image);\n              }\n              break;\n            }\n            case 32:\n            {\n              unsigned int\n                pixel;\n\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                p=PushLongPixel(MSBEndian,p,&pixel);\n                SetPixelRed(image,ScaleLongToQuantum(pixel),q);\n                p=PushLongPixel(MSBEndian,p,&pixel);\n                SetPixelGreen(image,ScaleLongToQuantum(pixel),q);\n                p=PushLongPixel(MSBEndian,p,&pixel);\n                SetPixelBlue(image,ScaleLongToQuantum(pixel),q);\n                SetPixelAlpha(image,OpaqueAlpha,q);\n                q+=GetPixelChannels(image);\n              }\n              break;\n            }\n            default:\n            {\n              unsigned int\n                pixel;\n\n              if (image->depth <= 8)\n                {\n                  unsigned char\n                    pixel;\n\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    p=PushCharPixel(p,&pixel);\n                    SetPixelRed(image,ScaleAnyToQuantum(pixel,max_value),q);\n                    p=PushCharPixel(p,&pixel);\n                    SetPixelGreen(image,ScaleAnyToQuantum(pixel,max_value),q);\n                    p=PushCharPixel(p,&pixel);\n                    SetPixelBlue(image,ScaleAnyToQuantum(pixel,max_value),q);\n                    SetPixelAlpha(image,OpaqueAlpha,q);\n                    q+=GetPixelChannels(image);\n                  }\n                  break;\n                }\n              if (image->depth <= 16)\n                {\n                  unsigned short\n                    pixel;\n\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    p=PushShortPixel(MSBEndian,p,&pixel);\n                    SetPixelRed(image,ScaleAnyToQuantum(pixel,max_value),q);\n                    p=PushShortPixel(MSBEndian,p,&pixel);\n                    SetPixelGreen(image,ScaleAnyToQuantum(pixel,max_value),q);\n                    p=PushShortPixel(MSBEndian,p,&pixel);\n                    SetPixelBlue(image,ScaleAnyToQuantum(pixel,max_value),q);\n                    SetPixelAlpha(image,OpaqueAlpha,q);\n                    q+=GetPixelChannels(image);\n                  }\n                  break;\n                }\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                p=PushLongPixel(MSBEndian,p,&pixel);\n                SetPixelRed(image,ScaleAnyToQuantum(pixel,max_value),q);\n                p=PushLongPixel(MSBEndian,p,&pixel);\n                SetPixelGreen(image,ScaleAnyToQuantum(pixel,max_value),q);\n                p=PushLongPixel(MSBEndian,p,&pixel);\n                SetPixelBlue(image,ScaleAnyToQuantum(pixel,max_value),q);\n                SetPixelAlpha(image,OpaqueAlpha,q);\n                q+=GetPixelChannels(image);\n              }\n              break;\n            }\n          }\n          sync=SyncAuthenticPixels(image,exception);\n          if (sync == MagickFalse)\n            status=MagickFalse;\n        }\n        quantum_info=DestroyQuantumInfo(quantum_info);\n        if (status == MagickFalse)\n          ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n        break;\n      }\n      case '7':\n      {\n        size_t\n          channels;\n\n        /*\n          Convert PAM raster image to pixel packets.\n        */\n        switch (quantum_type)\n        {\n          case GrayQuantum:\n          case GrayAlphaQuantum:\n          {\n            channels=1;\n            break;\n          }\n          case CMYKQuantum:\n          case CMYKAQuantum:\n          {\n            channels=4;\n            break;\n          }\n          default:\n          {\n            channels=3;\n            break;\n          }\n        }\n        if (image->alpha_trait != UndefinedPixelTrait)\n          channels++;\n        if (image->depth <= 8)\n          extent=channels*image->columns;\n        else\n          if (image->depth <= 16)\n            extent=2*channels*image->columns;\n          else\n            extent=4*channels*image->columns;\n        quantum_info=AcquireQuantumInfo(image_info,image);\n        if (quantum_info == (QuantumInfo *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          const unsigned char\n            *pixels;\n\n          MagickBooleanType\n            sync;\n\n          register const unsigned char\n            *magick_restrict p;\n\n          register ssize_t\n            x;\n\n          register Quantum\n            *magick_restrict q;\n\n          ssize_t\n            count,\n            offset;\n\n          if (status == MagickFalse)\n            continue;\n          pixels=(unsigned char *) ReadBlobStream(image,extent,\n            GetQuantumPixels(quantum_info),&count);\n          if (count != (ssize_t) extent)\n            status=MagickFalse;\n          if ((image->progress_monitor != (MagickProgressMonitor) NULL) &&\n              (image->previous == (Image *) NULL))\n            {\n              MagickBooleanType\n                proceed;\n\n              proceed=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                row,image->rows);\n              if (proceed == MagickFalse)\n                status=MagickFalse;\n            }\n          offset=row++;\n          q=QueueAuthenticPixels(image,0,offset,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            {\n              status=MagickFalse;\n              continue;\n            }\n          p=pixels;\n          switch (image->depth)\n          {\n            case 8:\n            case 16:\n            case 32:\n            {\n              (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                quantum_type,pixels,exception);\n              break;\n            }\n            default:\n            {\n              switch (quantum_type)\n              {\n                case GrayQuantum:\n                case GrayAlphaQuantum:\n                {\n                  unsigned int\n                    pixel;\n\n                  if (image->depth <= 8)\n                    {\n                      unsigned char\n                        pixel;\n\n                      for (x=0; x < (ssize_t) image->columns; x++)\n                      {\n                        p=PushCharPixel(p,&pixel);\n                        SetPixelGray(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                        SetPixelAlpha(image,OpaqueAlpha,q);\n                        if (image->alpha_trait != UndefinedPixelTrait)\n                          {\n                            p=PushCharPixel(p,&pixel);\n                            if (image->depth != 1)\n                              SetPixelAlpha(image,ScaleAnyToQuantum(pixel,\n                                max_value),q);\n                            else\n                              SetPixelAlpha(image,QuantumRange-\n                                ScaleAnyToQuantum(pixel,max_value),q);\n                          }\n                        q+=GetPixelChannels(image);\n                      }\n                      break;\n                    }\n                  if (image->depth <= 16)\n                    {\n                      unsigned short\n                        pixel;\n\n                      for (x=0; x < (ssize_t) image->columns; x++)\n                      {\n                        p=PushShortPixel(MSBEndian,p,&pixel);\n                        SetPixelGray(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                        SetPixelAlpha(image,OpaqueAlpha,q);\n                        if (image->alpha_trait != UndefinedPixelTrait)\n                          {\n                            p=PushShortPixel(MSBEndian,p,&pixel);\n                            SetPixelAlpha(image,ScaleAnyToQuantum(pixel,\n                              max_value),q);\n                          }\n                        q+=GetPixelChannels(image);\n                      }\n                      break;\n                    }\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    p=PushLongPixel(MSBEndian,p,&pixel);\n                    SetPixelGray(image,ScaleAnyToQuantum(pixel,max_value),q);\n                    SetPixelAlpha(image,OpaqueAlpha,q);\n                    if (image->alpha_trait != UndefinedPixelTrait)\n                      {\n                        p=PushLongPixel(MSBEndian,p,&pixel);\n                        SetPixelAlpha(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                      }\n                    q+=GetPixelChannels(image);\n                  }\n                  break;\n                }\n                case CMYKQuantum:\n                case CMYKAQuantum:\n                {\n                  unsigned int\n                    pixel;\n\n                  if (image->depth <= 8)\n                    {\n                      unsigned char\n                        pixel;\n\n                      for (x=0; x < (ssize_t) image->columns; x++)\n                      {\n                        p=PushCharPixel(p,&pixel);\n                        SetPixelRed(image,ScaleAnyToQuantum(pixel,max_value),q);\n                        p=PushCharPixel(p,&pixel);\n                        SetPixelGreen(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                        p=PushCharPixel(p,&pixel);\n                        SetPixelBlue(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                        p=PushCharPixel(p,&pixel);\n                        SetPixelBlack(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                        SetPixelAlpha(image,OpaqueAlpha,q);\n                        if (image->alpha_trait != UndefinedPixelTrait)\n                          {\n                            p=PushCharPixel(p,&pixel);\n                            SetPixelAlpha(image,ScaleAnyToQuantum(pixel,\n                              max_value),q);\n                          }\n                        q+=GetPixelChannels(image);\n                      }\n                      break;\n                    }\n                  if (image->depth <= 16)\n                    {\n                      unsigned short\n                        pixel;\n\n                      for (x=0; x < (ssize_t) image->columns; x++)\n                      {\n                        p=PushShortPixel(MSBEndian,p,&pixel);\n                        SetPixelRed(image,ScaleAnyToQuantum(pixel,max_value),q);\n                        p=PushShortPixel(MSBEndian,p,&pixel);\n                        SetPixelGreen(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                        p=PushShortPixel(MSBEndian,p,&pixel);\n                        SetPixelBlue(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                        p=PushShortPixel(MSBEndian,p,&pixel);\n                        SetPixelBlack(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                        SetPixelAlpha(image,OpaqueAlpha,q);\n                        if (image->alpha_trait != UndefinedPixelTrait)\n                          {\n                            p=PushShortPixel(MSBEndian,p,&pixel);\n                            SetPixelAlpha(image,ScaleAnyToQuantum(pixel,\n                              max_value),q);\n                          }\n                        q+=GetPixelChannels(image);\n                      }\n                    }\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    p=PushLongPixel(MSBEndian,p,&pixel);\n                    SetPixelRed(image,ScaleAnyToQuantum(pixel,max_value),q);\n                    p=PushLongPixel(MSBEndian,p,&pixel);\n                    SetPixelGreen(image,ScaleAnyToQuantum(pixel,max_value),q);\n                    p=PushLongPixel(MSBEndian,p,&pixel);\n                    SetPixelBlue(image,ScaleAnyToQuantum(pixel,max_value),q);\n                    p=PushLongPixel(MSBEndian,p,&pixel);\n                    SetPixelBlack(image,ScaleAnyToQuantum(pixel,max_value),q);\n                    SetPixelAlpha(image,OpaqueAlpha,q);\n                    if (image->alpha_trait != UndefinedPixelTrait)\n                      {\n                        p=PushLongPixel(MSBEndian,p,&pixel);\n                        SetPixelAlpha(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                      }\n                    q+=GetPixelChannels(image);\n                  }\n                  break;\n                }\n                default:\n                {\n                  unsigned int\n                    pixel;\n\n                  if (image->depth <= 8)\n                    {\n                      unsigned char\n                        pixel;\n\n                      for (x=0; x < (ssize_t) image->columns; x++)\n                      {\n                        p=PushCharPixel(p,&pixel);\n                        SetPixelRed(image,ScaleAnyToQuantum(pixel,max_value),q);\n                        p=PushCharPixel(p,&pixel);\n                        SetPixelGreen(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                        p=PushCharPixel(p,&pixel);\n                        SetPixelBlue(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                        SetPixelAlpha(image,OpaqueAlpha,q);\n                        if (image->alpha_trait != UndefinedPixelTrait)\n                          {\n                            p=PushCharPixel(p,&pixel);\n                            SetPixelAlpha(image,ScaleAnyToQuantum(pixel,\n                              max_value),q);\n                          }\n                        q+=GetPixelChannels(image);\n                      }\n                      break;\n                    }\n                  if (image->depth <= 16)\n                    {\n                      unsigned short\n                        pixel;\n\n                      for (x=0; x < (ssize_t) image->columns; x++)\n                      {\n                        p=PushShortPixel(MSBEndian,p,&pixel);\n                        SetPixelRed(image,ScaleAnyToQuantum(pixel,max_value),q);\n                        p=PushShortPixel(MSBEndian,p,&pixel);\n                        SetPixelGreen(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                        p=PushShortPixel(MSBEndian,p,&pixel);\n                        SetPixelBlue(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                        SetPixelAlpha(image,OpaqueAlpha,q);\n                        if (image->alpha_trait != UndefinedPixelTrait)\n                          {\n                            p=PushShortPixel(MSBEndian,p,&pixel);\n                            SetPixelAlpha(image,ScaleAnyToQuantum(pixel,\n                              max_value),q);\n                          }\n                        q+=GetPixelChannels(image);\n                      }\n                      break;\n                    }\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    p=PushLongPixel(MSBEndian,p,&pixel);\n                    SetPixelRed(image,ScaleAnyToQuantum(pixel,max_value),q);\n                    p=PushLongPixel(MSBEndian,p,&pixel);\n                    SetPixelGreen(image,ScaleAnyToQuantum(pixel,max_value),q);\n                    p=PushLongPixel(MSBEndian,p,&pixel);\n                    SetPixelBlue(image,ScaleAnyToQuantum(pixel,max_value),q);\n                    SetPixelAlpha(image,OpaqueAlpha,q);\n                    if (image->alpha_trait != UndefinedPixelTrait)\n                      {\n                        p=PushLongPixel(MSBEndian,p,&pixel);\n                        SetPixelAlpha(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                      }\n                    q+=GetPixelChannels(image);\n                  }\n                  break;\n                }\n              }\n            }\n          }\n          sync=SyncAuthenticPixels(image,exception);\n          if (sync == MagickFalse)\n            status=MagickFalse;\n        }\n        quantum_info=DestroyQuantumInfo(quantum_info);\n        if (status == MagickFalse)\n          ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n        SetQuantumImageType(image,quantum_type);\n        break;\n      }\n      case 'F':\n      case 'f':\n      {\n        /*\n          Convert PFM raster image to pixel packets.\n        */\n        if (format == 'f')\n          (void) SetImageColorspace(image,GRAYColorspace,exception);\n        quantum_type=format == 'f' ? GrayQuantum : RGBQuantum;\n        image->endian=quantum_scale < 0.0 ? LSBEndian : MSBEndian;\n        image->depth=32;\n        quantum_info=AcquireQuantumInfo(image_info,image);\n        if (quantum_info == (QuantumInfo *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        status=SetQuantumDepth(image,quantum_info,32);\n        if (status == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);\n        if (status == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        SetQuantumScale(quantum_info,(double) QuantumRange*fabs(quantum_scale));\n        extent=GetQuantumExtent(image,quantum_info,quantum_type);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          const unsigned char\n            *pixels;\n\n          MagickBooleanType\n            sync;\n\n          register Quantum\n            *magick_restrict q;\n\n          ssize_t\n            count,\n            offset;\n\n          size_t\n            length;\n\n          if (status == MagickFalse)\n            continue;\n          pixels=(unsigned char *) ReadBlobStream(image,extent,\n            GetQuantumPixels(quantum_info),&count);\n          if ((size_t) count != extent)\n            status=MagickFalse;\n          if ((image->progress_monitor != (MagickProgressMonitor) NULL) &&\n              (image->previous == (Image *) NULL))\n            {\n              MagickBooleanType\n                proceed;\n\n              proceed=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                row,image->rows);\n              if (proceed == MagickFalse)\n                status=MagickFalse;\n            }\n          offset=row++;\n          q=QueueAuthenticPixels(image,0,(ssize_t) (image->rows-offset-1),\n            image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            {\n              status=MagickFalse;\n              continue;\n            }\n          length=ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            quantum_type,pixels,exception);\n          if (length != extent)\n            status=MagickFalse;\n          sync=SyncAuthenticPixels(image,exception);\n          if (sync == MagickFalse)\n            status=MagickFalse;\n        }\n        quantum_info=DestroyQuantumInfo(quantum_info);\n        if (status == MagickFalse)\n          ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n        SetQuantumImageType(image,quantum_type);\n        break;\n      }\n      default:\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n    if (EOFBlob(image) != MagickFalse)\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          CorruptImageError,\"UnexpectedEndOfFile\",\"`%s'\",image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if ((format == '1') || (format == '2') || (format == '3'))\n      do\n      {\n        /*\n          Skip to end of line.\n        */\n        count=ReadBlob(image,1,(unsigned char *) &format);\n        if (count != 1)\n          break;\n        if (format == 'P')\n          break;\n      } while (format != '\\n');\n    count=ReadBlob(image,1,(unsigned char *) &format);\n    if ((count == 1) && (format == 'P'))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while ((count == 1) && (format == 'P'));\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145367,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "BGD_DECLARE(gdImagePtr) gdImageCreate (int sx, int sy)\n{\n  int i;\n  gdImagePtr im;\n\n  if (overflow2(sizeof (unsigned char *), sy)) {\n\tgdFree(im);\n\treturn NULL;\n  }\n\n  im = (gdImage *) gdMalloc (sizeof (gdImage));\n\tif (!im) {\n\t\treturn NULL;\n\t}\n\n  memset (im, 0, sizeof (gdImage));\n  /* Row-major ever since gd 1.3 */\n  im->pixels = (unsigned char **) gdMalloc (sizeof (unsigned char *) * sy);\n\tif (!im->pixels) {\n\t\tgdFree(im);\n\t\treturn NULL;\n\t}\n\n  im->polyInts = 0;\n  im->polyAllocated = 0;\n  im->brush = 0;\n  im->tile = 0;\n  im->style = 0;\n  for (i = 0; (i < sy); i++)\n    {\n      /* Row-major ever since gd 1.3 */\n      im->pixels[i] = (unsigned char *) gdCalloc (sx, sizeof (unsigned char));\n\t\t\tif (!im->pixels[i]) \n\t\t\t{\n\t\t\t\tfor (--i ; i >= 0; i--)\n\t\t\t\t{\n\t\t\t\t\tgdFree(im->pixels[i]);\n\t\t\t\t}\n\t\t\t\tgdFree(im);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n    }\n  im->sx = sx;\n  im->sy = sy;\n  im->colorsTotal = 0;\n  im->transparent = (-1);\n  im->interlace = 0;\n  im->thick = 1;\n  im->AA = 0;\n  for (i = 0; (i < gdMaxColors); i++)\n    {\n      im->open[i] = 1;\n      im->red[i] = 0;\n      im->green[i] = 0;\n      im->blue[i] = 0;\n    };\n  im->trueColor = 0;\n  im->tpixels = 0;\n  im->cx1 = 0;\n  im->cy1 = 0;\n  im->cx2 = im->sx - 1;\n  im->cy2 = im->sy - 1;\n  return im;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145404,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "BGD_DECLARE(gdImagePtr) gdImageCreate (int sx, int sy)\n{\n  int i;\n  gdImagePtr im;\n\n  if (overflow2(sizeof (unsigned char *), sy)) {\n\t\treturn NULL;\n  }\n  if (overflow2(sizeof (unsigned char *), sx)) {\n\t\treturn NULL;\n  }\n\n  im = (gdImage *) gdMalloc (sizeof (gdImage));\n\tif (!im) {\n\t\treturn NULL;\n\t}\n\n  memset (im, 0, sizeof (gdImage));\n  /* Row-major ever since gd 1.3 */\n  im->pixels = (unsigned char **) gdMalloc (sizeof (unsigned char *) * sy);\n\tif (!im->pixels) {\n\t\tgdFree(im);\n\t\treturn NULL;\n\t}\n\n  im->polyInts = 0;\n  im->polyAllocated = 0;\n  im->brush = 0;\n  im->tile = 0;\n  im->style = 0;\n  for (i = 0; (i < sy); i++)\n    {\n      /* Row-major ever since gd 1.3 */\n      im->pixels[i] = (unsigned char *) gdCalloc (sx, sizeof (unsigned char));\n\t\t\tif (!im->pixels[i]) \n\t\t\t{\n\t\t\t\tfor (--i ; i >= 0; i--)\n\t\t\t\t{\n\t\t\t\t\tgdFree(im->pixels[i]);\n\t\t\t\t}\n\t\t\t\tgdFree(im->pixels);\n\t\t\t\tgdFree(im);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n    }\n  im->sx = sx;\n  im->sy = sy;\n  im->colorsTotal = 0;\n  im->transparent = (-1);\n  im->interlace = 0;\n  im->thick = 1;\n  im->AA = 0;\n  for (i = 0; (i < gdMaxColors); i++)\n    {\n      im->open[i] = 1;\n      im->red[i] = 0;\n      im->green[i] = 0;\n      im->blue[i] = 0;\n    };\n  im->trueColor = 0;\n  im->tpixels = 0;\n  im->cx1 = 0;\n  im->cy1 = 0;\n  im->cx2 = im->sx - 1;\n  im->cy2 = im->sy - 1;\n  return im;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145405,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static Image *ReadTXTImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    colorspace[MagickPathExtent],\n    text[MagickPathExtent];\n\n  double\n    max_value,\n    x_offset,\n    y_offset;\n\n  Image\n    *image;\n\n  PixelInfo\n    pixel;\n\n  MagickBooleanType\n    status;\n\n  QuantumAny\n    range;\n\n  register ssize_t\n    i,\n    x;\n\n  register Quantum\n    *q;\n\n  ssize_t\n    count,\n    type,\n    y;\n\n  unsigned long\n    depth,\n    height,\n    width;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) memset(text,0,sizeof(text));\n  (void) ReadBlobString(image,text);\n  if (LocaleNCompare((char *) text,MagickTXTID,strlen(MagickTXTID)) != 0)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  x_offset=(-1.0);\n  y_offset=(-1.0);\n  do\n  {\n    width=0;\n    height=0;\n    max_value=0.0;\n    *colorspace='\\0';\n    count=(ssize_t) sscanf(text+32,\"%lu,%lu,%lf,%32s\",&width,&height,&max_value,\n      colorspace);\n    if ((count != 4) || (width == 0) || (height == 0) || (max_value == 0.0))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    image->columns=width;\n    image->rows=height;\n    if ((max_value == 0.0) || (max_value > 18446744073709551615.0))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    for (depth=1; (GetQuantumRange(depth)+1.0) < max_value; depth++) ;\n    image->depth=depth;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status != MagickFalse)\n      status=ResetImagePixels(image,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    LocaleLower(colorspace);\n    i=(ssize_t) strlen(colorspace)-1;\n    image->alpha_trait=UndefinedPixelTrait;\n    if ((i > 0) && (colorspace[i] == 'a'))\n      {\n        colorspace[i]='\\0';\n        image->alpha_trait=BlendPixelTrait;\n      }\n    type=ParseCommandOption(MagickColorspaceOptions,MagickFalse,colorspace);\n    if (type < 0)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    (void) SetImageColorspace(image,(ColorspaceType) type,exception);\n    (void) SetImageBackgroundColor(image,exception);\n    GetPixelInfo(image,&pixel);\n    range=GetQuantumRange(image->depth);\n    status=MagickTrue;\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      double\n        alpha,\n        black,\n        blue,\n        green,\n        red;\n\n      if (status == MagickFalse)\n        break;\n      red=0.0;\n      green=0.0;\n      blue=0.0;\n      black=0.0;\n      alpha=0.0;\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        if (ReadBlobString(image,text) == (char *) NULL)\n          {\n            status=MagickFalse;\n            break;\n          }\n        switch (image->colorspace)\n        {\n          case LinearGRAYColorspace:\n          case GRAYColorspace:\n          {\n            if (image->alpha_trait != UndefinedPixelTrait)\n              {\n                count=(ssize_t) sscanf(text,\"%lf,%lf: (%lf%*[%,]%lf%*[%,]\",\n                  &x_offset,&y_offset,&red,&alpha);\n                green=red;\n                blue=red;\n                break;\n              }\n            count=(ssize_t) sscanf(text,\"%lf,%lf: (%lf%*[%,]\",&x_offset,\n              &y_offset,&red);\n            green=red;\n            blue=red;\n            break;\n          }\n          case CMYKColorspace:\n          {\n            if (image->alpha_trait != UndefinedPixelTrait)\n              {\n                count=(ssize_t) sscanf(text,\n                  \"%lf,%lf: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\",\n                  &x_offset,&y_offset,&red,&green,&blue,&black,&alpha);\n                break;\n              }\n            count=(ssize_t) sscanf(text,\n              \"%lf,%lf: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\",&x_offset,\n              &y_offset,&red,&green,&blue,&black);\n            break;\n          }\n          default:\n          {\n            if (image->alpha_trait != UndefinedPixelTrait)\n              {\n                count=(ssize_t) sscanf(text,\n                  \"%lf,%lf: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\",\n                  &x_offset,&y_offset,&red,&green,&blue,&alpha);\n                break;\n              }\n            count=(ssize_t) sscanf(text,\"%lf,%lf: (%lf%*[%,]%lf%*[%,]%lf%*[%,]\",\n              &x_offset,&y_offset,&red,&green,&blue);\n            break;\n          }\n        }\n        if (strchr(text,'%') != (char *) NULL)\n          {\n            red*=0.01*range;\n            green*=0.01*range;\n            blue*=0.01*range;\n            black*=0.01*range;\n            alpha*=0.01*range;\n          }\n        if (image->colorspace == LabColorspace)\n          {\n            green+=(range+1)/2.0;\n            blue+=(range+1)/2.0;\n          }\n        pixel.red=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (red+0.5),\n          range);\n        pixel.green=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (green+0.5),\n          range);\n        pixel.blue=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (blue+0.5),\n          range);\n        pixel.black=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (black+0.5),\n          range);\n        pixel.alpha=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (alpha+0.5),\n          range);\n        q=GetAuthenticPixels(image,(ssize_t) x_offset,(ssize_t) y_offset,1,1,\n          exception);\n        if (q == (Quantum *) NULL)\n          continue;\n        SetPixelViaPixelInfo(image,&pixel,q);\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          {\n            status=MagickFalse;\n            break;\n          }\n      }\n    }\n    if (status == MagickFalse)\n      break;\n    *text='\\0';\n    (void) ReadBlobString(image,text);\n    if (LocaleNCompare((char *) text,MagickTXTID,strlen(MagickTXTID)) == 0)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            status=MagickFalse;\n            break;\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (LocaleNCompare((char *) text,MagickTXTID,strlen(MagickTXTID)) == 0);\n  (void) CloseBlob(image);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  return(GetFirstImageInList(image));\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145414,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static Image *ReadTXTImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    colorspace[MagickPathExtent],\n    text[MagickPathExtent];\n\n  double\n    max_value,\n    x_offset,\n    y_offset;\n\n  Image\n    *image;\n\n  PixelInfo\n    pixel;\n\n  MagickBooleanType\n    status;\n\n  QuantumAny\n    range;\n\n  register ssize_t\n    i,\n    x;\n\n  register Quantum\n    *q;\n\n  ssize_t\n    count,\n    type,\n    y;\n\n  unsigned long\n    depth,\n    height,\n    width;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) memset(text,0,sizeof(text));\n  (void) ReadBlobString(image,text);\n  if (LocaleNCompare((char *) text,MagickTXTID,strlen(MagickTXTID)) != 0)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  x_offset=(-1.0);\n  y_offset=(-1.0);\n  do\n  {\n    width=0;\n    height=0;\n    max_value=0.0;\n    *colorspace='\\0';\n    count=(ssize_t) sscanf(text+32,\"%lu,%lu,%lf,%32s\",&width,&height,&max_value,\n      colorspace);\n    if ((count != 4) || (width == 0) || (height == 0) || (max_value == 0.0))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    image->columns=width;\n    image->rows=height;\n    if ((max_value == 0.0) || (max_value > 18446744073709551615.0))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    for (depth=1; (GetQuantumRange(depth)+1.0) < max_value; depth++) ;\n    image->depth=depth;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status != MagickFalse)\n      status=ResetImagePixels(image,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    LocaleLower(colorspace);\n    i=(ssize_t) strlen(colorspace)-1;\n    image->alpha_trait=UndefinedPixelTrait;\n    if ((i > 0) && (colorspace[i] == 'a'))\n      {\n        colorspace[i]='\\0';\n        image->alpha_trait=BlendPixelTrait;\n      }\n    type=ParseCommandOption(MagickColorspaceOptions,MagickFalse,colorspace);\n    if (type < 0)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    (void) SetImageColorspace(image,(ColorspaceType) type,exception);\n    (void) SetImageBackgroundColor(image,exception);\n    GetPixelInfo(image,&pixel);\n    range=GetQuantumRange(image->depth);\n    status=MagickTrue;\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      double\n        alpha,\n        black,\n        blue,\n        green,\n        red;\n\n      if (status == MagickFalse)\n        break;\n      red=0.0;\n      green=0.0;\n      blue=0.0;\n      black=0.0;\n      alpha=0.0;\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        if (ReadBlobString(image,text) == (char *) NULL)\n          {\n            status=MagickFalse;\n            break;\n          }\n        switch (image->colorspace)\n        {\n          case LinearGRAYColorspace:\n          case GRAYColorspace:\n          {\n            if (image->alpha_trait != UndefinedPixelTrait)\n              {\n                count=(ssize_t) sscanf(text,\"%lf,%lf: (%lf%*[%,]%lf%*[%,]\",\n                  &x_offset,&y_offset,&red,&alpha);\n                green=red;\n                blue=red;\n                break;\n              }\n            count=(ssize_t) sscanf(text,\"%lf,%lf: (%lf%*[%,]\",&x_offset,\n              &y_offset,&red);\n            green=red;\n            blue=red;\n            break;\n          }\n          case CMYKColorspace:\n          {\n            if (image->alpha_trait != UndefinedPixelTrait)\n              {\n                count=(ssize_t) sscanf(text,\n                  \"%lf,%lf: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\",\n                  &x_offset,&y_offset,&red,&green,&blue,&black,&alpha);\n                break;\n              }\n            count=(ssize_t) sscanf(text,\n              \"%lf,%lf: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\",&x_offset,\n              &y_offset,&red,&green,&blue,&black);\n            break;\n          }\n          default:\n          {\n            if (image->alpha_trait != UndefinedPixelTrait)\n              {\n                count=(ssize_t) sscanf(text,\n                  \"%lf,%lf: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\",\n                  &x_offset,&y_offset,&red,&green,&blue,&alpha);\n                break;\n              }\n            count=(ssize_t) sscanf(text,\"%lf,%lf: (%lf%*[%,]%lf%*[%,]%lf%*[%,]\",\n              &x_offset,&y_offset,&red,&green,&blue);\n            break;\n          }\n        }\n        if (strchr(text,'%') != (char *) NULL)\n          {\n            red*=0.01*range;\n            green*=0.01*range;\n            blue*=0.01*range;\n            black*=0.01*range;\n            alpha*=0.01*range;\n          }\n        if (image->colorspace == LabColorspace)\n          {\n            green+=(range+1)/2.0;\n            blue+=(range+1)/2.0;\n          }\n        pixel.red=(MagickRealType) ScaleAnyToQuantum((QuantumAny)\n          MagickMax(red+0.5,0.0),range);\n        pixel.green=(MagickRealType) ScaleAnyToQuantum((QuantumAny)\n          MagickMax(green+0.5,0.0),range);\n        pixel.blue=(MagickRealType) ScaleAnyToQuantum((QuantumAny)\n          MagickMax(blue+0.5,0.0),range);\n        pixel.black=(MagickRealType) ScaleAnyToQuantum((QuantumAny)\n          MagickMax(black+0.5,0.0),range);\n        pixel.alpha=(MagickRealType) ScaleAnyToQuantum((QuantumAny)\n          MagickMax(alpha+0.5,0.0),range);\n        q=GetAuthenticPixels(image,(ssize_t) x_offset,(ssize_t) y_offset,1,1,\n          exception);\n        if (q == (Quantum *) NULL)\n          continue;\n        SetPixelViaPixelInfo(image,&pixel,q);\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          {\n            status=MagickFalse;\n            break;\n          }\n      }\n    }\n    if (status == MagickFalse)\n      break;\n    *text='\\0';\n    (void) ReadBlobString(image,text);\n    if (LocaleNCompare((char *) text,MagickTXTID,strlen(MagickTXTID)) == 0)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            status=MagickFalse;\n            break;\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (LocaleNCompare((char *) text,MagickTXTID,strlen(MagickTXTID)) == 0);\n  (void) CloseBlob(image);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  return(GetFirstImageInList(image));\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145415,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static punycode_uint decode_digit(punycode_uint cp)\n{\n  return  cp - 48 < 10 ? cp - 22 :  cp - 65 < 26 ? cp - 65 :\n          cp - 97 < 26 ? cp - 97 :  base;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145438,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static unsigned decode_digit(int cp)\n{\n  return (unsigned) (cp - 48 < 10 ? cp - 22 :  cp - 65 < 26 ? cp - 65 :\n         cp - 97 < 26 ? cp - 97 :  base);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145439,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static void ExportIndexQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const Quantum *magick_restrict p,\n  unsigned char *magick_restrict q,ExceptionInfo *exception)\n{\n  ssize_t\n    x;\n\n  ssize_t\n    bit;\n\n  if (image->storage_class != PseudoClass)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"ColormappedImageRequired\",\"`%s'\",image->filename);\n      return;\n    }\n  switch (quantum_info->depth)\n  {\n    case 1:\n    {\n      unsigned char\n        pixel;\n\n      for (x=((ssize_t) number_pixels-7); x > 0; x-=8)\n      {\n        pixel=(unsigned char) GetPixelIndex(image,p);\n        *q=((pixel & 0x01) << 7);\n        p+=GetPixelChannels(image);\n        pixel=(unsigned char) GetPixelIndex(image,p);\n        *q|=((pixel & 0x01) << 6);\n        p+=GetPixelChannels(image);\n        pixel=(unsigned char) GetPixelIndex(image,p);\n        *q|=((pixel & 0x01) << 5);\n        p+=GetPixelChannels(image);\n        pixel=(unsigned char) GetPixelIndex(image,p);\n        *q|=((pixel & 0x01) << 4);\n        p+=GetPixelChannels(image);\n        pixel=(unsigned char) GetPixelIndex(image,p);\n        *q|=((pixel & 0x01) << 3);\n        p+=GetPixelChannels(image);\n        pixel=(unsigned char) GetPixelIndex(image,p);\n        *q|=((pixel & 0x01) << 2);\n        p+=GetPixelChannels(image);\n        pixel=(unsigned char) GetPixelIndex(image,p);\n        *q|=((pixel & 0x01) << 1);\n        p+=GetPixelChannels(image);\n        pixel=(unsigned char) GetPixelIndex(image,p);\n        *q|=((pixel & 0x01) << 0);\n        p+=GetPixelChannels(image);\n        q++;\n      }\n      if ((number_pixels % 8) != 0)\n        {\n          *q='\\0';\n          for (bit=7; bit >= (ssize_t) (8-(number_pixels % 8)); bit--)\n          {\n            pixel=(unsigned char) GetPixelIndex(image,p);\n            *q|=((pixel & 0x01) << (unsigned char) bit);\n            p+=GetPixelChannels(image);\n          }\n          q++;\n        }\n      break;\n    }\n    case 4:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) (number_pixels-1) ; x+=2)\n      {\n        pixel=(unsigned char) GetPixelIndex(image,p);\n        *q=((pixel & 0xf) << 4);\n        p+=GetPixelChannels(image);\n        pixel=(unsigned char) GetPixelIndex(image,p);\n        *q|=((pixel & 0xf) << 0);\n        p+=GetPixelChannels(image);\n        q++;\n      }\n      if ((number_pixels % 2) != 0)\n        {\n          pixel=(unsigned char) GetPixelIndex(image,p);\n          *q=((pixel & 0xf) << 4);\n          p+=GetPixelChannels(image);\n          q++;\n        }\n      break;\n    }\n    case 8:\n    {\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopCharPixel((unsigned char) GetPixelIndex(image,p),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 16:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopShortPixel(quantum_info->endian,SinglePrecisionToHalf(\n              QuantumScale*GetPixelIndex(image,p)),q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopShortPixel(quantum_info->endian,(unsigned short)\n          GetPixelIndex(image,p),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 32:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopFloatPixel(quantum_info,(float) GetPixelIndex(image,p),q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopLongPixel(quantum_info->endian,(unsigned int)\n          GetPixelIndex(image,p),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopDoublePixel(quantum_info,(double) GetPixelIndex(image,p),q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n    }\n    default:\n    {\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopQuantumPixel(quantum_info,GetPixelIndex(image,p),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n  }\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145506,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static void ExportIndexQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const Quantum *magick_restrict p,\n  unsigned char *magick_restrict q,ExceptionInfo *exception)\n{\n  ssize_t\n    x;\n\n  ssize_t\n    bit;\n\n  if (image->storage_class != PseudoClass)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"ColormappedImageRequired\",\"`%s'\",image->filename);\n      return;\n    }\n  switch (quantum_info->depth)\n  {\n    case 1:\n    {\n      unsigned char\n        pixel;\n\n      for (x=((ssize_t) number_pixels-7); x > 0; x-=8)\n      {\n        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));\n        *q=((pixel & 0x01) << 7);\n        p+=GetPixelChannels(image);\n        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));\n        *q|=((pixel & 0x01) << 6);\n        p+=GetPixelChannels(image);\n        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));\n        *q|=((pixel & 0x01) << 5);\n        p+=GetPixelChannels(image);\n        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));\n        *q|=((pixel & 0x01) << 4);\n        p+=GetPixelChannels(image);\n        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));\n        *q|=((pixel & 0x01) << 3);\n        p+=GetPixelChannels(image);\n        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));\n        *q|=((pixel & 0x01) << 2);\n        p+=GetPixelChannels(image);\n        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));\n        *q|=((pixel & 0x01) << 1);\n        p+=GetPixelChannels(image);\n        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));\n        *q|=((pixel & 0x01) << 0);\n        p+=GetPixelChannels(image);\n        q++;\n      }\n      if ((number_pixels % 8) != 0)\n        {\n          *q='\\0';\n          for (bit=7; bit >= (ssize_t) (8-(number_pixels % 8)); bit--)\n          {\n            pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));\n            *q|=((pixel & 0x01) << (unsigned char) bit);\n            p+=GetPixelChannels(image);\n          }\n          q++;\n        }\n      break;\n    }\n    case 4:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) (number_pixels-1) ; x+=2)\n      {\n        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));\n        *q=((pixel & 0xf) << 4);\n        p+=GetPixelChannels(image);\n        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));\n        *q|=((pixel & 0xf) << 0);\n        p+=GetPixelChannels(image);\n        q++;\n      }\n      if ((number_pixels % 2) != 0)\n        {\n          pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));\n          *q=((pixel & 0xf) << 4);\n          p+=GetPixelChannels(image);\n          q++;\n        }\n      break;\n    }\n    case 8:\n    {\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopCharPixel((unsigned char) ((ssize_t) GetPixelIndex(image,p)),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 16:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopShortPixel(quantum_info->endian,SinglePrecisionToHalf(\n              QuantumScale*GetPixelIndex(image,p)),q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopShortPixel(quantum_info->endian,(unsigned short)\n          GetPixelIndex(image,p),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 32:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopFloatPixel(quantum_info,(float) GetPixelIndex(image,p),q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopLongPixel(quantum_info->endian,(unsigned int)\n          GetPixelIndex(image,p),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopDoublePixel(quantum_info,(double) GetPixelIndex(image,p),q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n    }\n    default:\n    {\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopQuantumPixel(quantum_info,GetPixelIndex(image,p),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n  }\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145507,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static int alarm_timer_nsleep(const clockid_t which_clock, int flags,\n\t\t\t      const struct timespec64 *tsreq)\n{\n\tenum  alarmtimer_type type = clock2alarm(which_clock);\n\tstruct restart_block *restart = &current->restart_block;\n\tstruct alarm alarm;\n\tktime_t exp;\n\tint ret = 0;\n\n\tif (!alarmtimer_get_rtcdev())\n\t\treturn -ENOTSUPP;\n\n\tif (flags & ~TIMER_ABSTIME)\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_WAKE_ALARM))\n\t\treturn -EPERM;\n\n\talarm_init_on_stack(&alarm, type, alarmtimer_nsleep_wakeup);\n\n\texp = timespec64_to_ktime(*tsreq);\n\t/* Convert (if necessary) to absolute time */\n\tif (flags != TIMER_ABSTIME) {\n\t\tktime_t now = alarm_bases[type].gettime();\n\t\texp = ktime_add(now, exp);\n\t}\n\n\tret = alarmtimer_do_nsleep(&alarm, exp, type);\n\tif (ret != -ERESTART_RESTARTBLOCK)\n\t\treturn ret;\n\n\t/* abs timers don't set remaining time or restart */\n\tif (flags == TIMER_ABSTIME)\n\t\treturn -ERESTARTNOHAND;\n\n\trestart->fn = alarm_timer_nsleep_restart;\n\trestart->nanosleep.clockid = type;\n\trestart->nanosleep.expires = exp;\n\treturn ret;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145538,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static int alarm_timer_nsleep(const clockid_t which_clock, int flags,\n\t\t\t      const struct timespec64 *tsreq)\n{\n\tenum  alarmtimer_type type = clock2alarm(which_clock);\n\tstruct restart_block *restart = &current->restart_block;\n\tstruct alarm alarm;\n\tktime_t exp;\n\tint ret = 0;\n\n\tif (!alarmtimer_get_rtcdev())\n\t\treturn -ENOTSUPP;\n\n\tif (flags & ~TIMER_ABSTIME)\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_WAKE_ALARM))\n\t\treturn -EPERM;\n\n\talarm_init_on_stack(&alarm, type, alarmtimer_nsleep_wakeup);\n\n\texp = timespec64_to_ktime(*tsreq);\n\t/* Convert (if necessary) to absolute time */\n\tif (flags != TIMER_ABSTIME) {\n\t\tktime_t now = alarm_bases[type].gettime();\n\n\t\texp = ktime_add_safe(now, exp);\n\t}\n\n\tret = alarmtimer_do_nsleep(&alarm, exp, type);\n\tif (ret != -ERESTART_RESTARTBLOCK)\n\t\treturn ret;\n\n\t/* abs timers don't set remaining time or restart */\n\tif (flags == TIMER_ABSTIME)\n\t\treturn -ERESTARTNOHAND;\n\n\trestart->fn = alarm_timer_nsleep_restart;\n\trestart->nanosleep.clockid = type;\n\trestart->nanosleep.expires = exp;\n\treturn ret;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145539,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "void ati_2d_blt(ATIVGAState *s)\n{\n    /* FIXME it is probably more complex than this and may need to be */\n    /* rewritten but for now as a start just to get some output: */\n    DisplaySurface *ds = qemu_console_surface(s->vga.con);\n    DPRINTF(\"%p %u ds: %p %d %d rop: %x\\n\", s->vga.vram_ptr,\n            s->vga.vbe_start_addr, surface_data(ds), surface_stride(ds),\n            surface_bits_per_pixel(ds),\n            (s->regs.dp_mix & GMC_ROP3_MASK) >> 16);\n    int dst_x = (s->regs.dp_cntl & DST_X_LEFT_TO_RIGHT ?\n                 s->regs.dst_x : s->regs.dst_x + 1 - s->regs.dst_width);\n    int dst_y = (s->regs.dp_cntl & DST_Y_TOP_TO_BOTTOM ?\n                 s->regs.dst_y : s->regs.dst_y + 1 - s->regs.dst_height);\n    int bpp = ati_bpp_from_datatype(s);\n    int dst_stride = DEFAULT_CNTL ? s->regs.dst_pitch : s->regs.default_pitch;\n    uint8_t *dst_bits = s->vga.vram_ptr + (DEFAULT_CNTL ?\n                        s->regs.dst_offset : s->regs.default_offset);\n\n    if (s->dev_id == PCI_DEVICE_ID_ATI_RAGE128_PF) {\n        dst_bits += s->regs.crtc_offset & 0x07ffffff;\n        dst_stride *= bpp;\n    }\n    uint8_t *end = s->vga.vram_ptr + s->vga.vram_size;\n    if (dst_bits >= end || dst_bits + dst_x + (dst_y + s->regs.dst_height) *\n        dst_stride >= end) {\n        qemu_log_mask(LOG_UNIMP, \"blt outside vram not implemented\\n\");\n        return;\n    }\n    DPRINTF(\"%d %d %d, %d %d %d, (%d,%d) -> (%d,%d) %dx%d %c %c\\n\",\n            s->regs.src_offset, s->regs.dst_offset, s->regs.default_offset,\n            s->regs.src_pitch, s->regs.dst_pitch, s->regs.default_pitch,\n            s->regs.src_x, s->regs.src_y, s->regs.dst_x, s->regs.dst_y,\n            s->regs.dst_width, s->regs.dst_height,\n            (s->regs.dp_cntl & DST_X_LEFT_TO_RIGHT ? '>' : '<'),\n            (s->regs.dp_cntl & DST_Y_TOP_TO_BOTTOM ? 'v' : '^'));\n    switch (s->regs.dp_mix & GMC_ROP3_MASK) {\n    case ROP3_SRCCOPY:\n    {\n        int src_x = (s->regs.dp_cntl & DST_X_LEFT_TO_RIGHT ?\n                     s->regs.src_x : s->regs.src_x + 1 - s->regs.dst_width);\n        int src_y = (s->regs.dp_cntl & DST_Y_TOP_TO_BOTTOM ?\n                     s->regs.src_y : s->regs.src_y + 1 - s->regs.dst_height);\n        int src_stride = DEFAULT_CNTL ?\n                         s->regs.src_pitch : s->regs.default_pitch;\n        uint8_t *src_bits = s->vga.vram_ptr + (DEFAULT_CNTL ?\n                            s->regs.src_offset : s->regs.default_offset);\n\n        if (s->dev_id == PCI_DEVICE_ID_ATI_RAGE128_PF) {\n            src_bits += s->regs.crtc_offset & 0x07ffffff;\n            src_stride *= bpp;\n        }\n        if (src_bits >= end || src_bits + src_x +\n            (src_y + s->regs.dst_height) * src_stride >= end) {\n            qemu_log_mask(LOG_UNIMP, \"blt outside vram not implemented\\n\");\n            return;\n        }\n\n        src_stride /= sizeof(uint32_t);\n        dst_stride /= sizeof(uint32_t);\n        DPRINTF(\"pixman_blt(%p, %p, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d)\\n\",\n                src_bits, dst_bits, src_stride, dst_stride, bpp, bpp,\n                src_x, src_y, dst_x, dst_y,\n                s->regs.dst_width, s->regs.dst_height);\n        if (s->regs.dp_cntl & DST_X_LEFT_TO_RIGHT &&\n            s->regs.dp_cntl & DST_Y_TOP_TO_BOTTOM) {\n            pixman_blt((uint32_t *)src_bits, (uint32_t *)dst_bits,\n                       src_stride, dst_stride, bpp, bpp,\n                       src_x, src_y, dst_x, dst_y,\n                       s->regs.dst_width, s->regs.dst_height);\n        } else {\n            /* FIXME: We only really need a temporary if src and dst overlap */\n            int llb = s->regs.dst_width * (bpp / 8);\n            int tmp_stride = DIV_ROUND_UP(llb, sizeof(uint32_t));\n            uint32_t *tmp = g_malloc(tmp_stride * sizeof(uint32_t) *\n                                     s->regs.dst_height);\n            pixman_blt((uint32_t *)src_bits, tmp,\n                       src_stride, tmp_stride, bpp, bpp,\n                       src_x, src_y, 0, 0,\n                       s->regs.dst_width, s->regs.dst_height);\n            pixman_blt(tmp, (uint32_t *)dst_bits,\n                       tmp_stride, dst_stride, bpp, bpp,\n                       0, 0, dst_x, dst_y,\n                       s->regs.dst_width, s->regs.dst_height);\n            g_free(tmp);\n        }\n        if (dst_bits >= s->vga.vram_ptr + s->vga.vbe_start_addr &&\n            dst_bits < s->vga.vram_ptr + s->vga.vbe_start_addr +\n            s->vga.vbe_regs[VBE_DISPI_INDEX_YRES] * s->vga.vbe_line_offset) {\n            memory_region_set_dirty(&s->vga.vram, s->vga.vbe_start_addr +\n                                    s->regs.dst_offset +\n                                    dst_y * surface_stride(ds),\n                                    s->regs.dst_height * surface_stride(ds));\n        }\n        s->regs.dst_x += s->regs.dst_width;\n        s->regs.dst_y += s->regs.dst_height;\n        break;\n    }\n    case ROP3_PATCOPY:\n    case ROP3_BLACKNESS:\n    case ROP3_WHITENESS:\n    {\n        uint32_t filler = 0;\n\n        switch (s->regs.dp_mix & GMC_ROP3_MASK) {\n        case ROP3_PATCOPY:\n            filler = s->regs.dp_brush_frgd_clr;\n            break;\n        case ROP3_BLACKNESS:\n            filler = 0xffUL << 24 | rgb_to_pixel32(s->vga.palette[0],\n                     s->vga.palette[1], s->vga.palette[2]);\n            break;\n        case ROP3_WHITENESS:\n            filler = 0xffUL << 24 | rgb_to_pixel32(s->vga.palette[3],\n                     s->vga.palette[4], s->vga.palette[5]);\n            break;\n        }\n\n        dst_stride /= sizeof(uint32_t);\n        DPRINTF(\"pixman_fill(%p, %d, %d, %d, %d, %d, %d, %x)\\n\",\n                dst_bits, dst_stride, bpp,\n                s->regs.dst_x, s->regs.dst_y,\n                s->regs.dst_width, s->regs.dst_height,\n                filler);\n        pixman_fill((uint32_t *)dst_bits, dst_stride, bpp,\n                    s->regs.dst_x, s->regs.dst_y,\n                    s->regs.dst_width, s->regs.dst_height,\n                    filler);\n        if (dst_bits >= s->vga.vram_ptr + s->vga.vbe_start_addr &&\n            dst_bits < s->vga.vram_ptr + s->vga.vbe_start_addr +\n            s->vga.vbe_regs[VBE_DISPI_INDEX_YRES] * s->vga.vbe_line_offset) {\n            memory_region_set_dirty(&s->vga.vram, s->vga.vbe_start_addr +\n                                    s->regs.dst_offset +\n                                    dst_y * surface_stride(ds),\n                                    s->regs.dst_height * surface_stride(ds));\n        }\n        s->regs.dst_y += s->regs.dst_height;\n        break;\n    }\n    default:\n        qemu_log_mask(LOG_UNIMP, \"Unimplemented ati_2d blt op %x\\n\",\n                      (s->regs.dp_mix & GMC_ROP3_MASK) >> 16);\n    }\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145546,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "void ati_2d_blt(ATIVGAState *s)\n{\n    /* FIXME it is probably more complex than this and may need to be */\n    /* rewritten but for now as a start just to get some output: */\n    DisplaySurface *ds = qemu_console_surface(s->vga.con);\n    DPRINTF(\"%p %u ds: %p %d %d rop: %x\\n\", s->vga.vram_ptr,\n            s->vga.vbe_start_addr, surface_data(ds), surface_stride(ds),\n            surface_bits_per_pixel(ds),\n            (s->regs.dp_mix & GMC_ROP3_MASK) >> 16);\n    unsigned dst_x = (s->regs.dp_cntl & DST_X_LEFT_TO_RIGHT ?\n                      s->regs.dst_x : s->regs.dst_x + 1 - s->regs.dst_width);\n    unsigned dst_y = (s->regs.dp_cntl & DST_Y_TOP_TO_BOTTOM ?\n                      s->regs.dst_y : s->regs.dst_y + 1 - s->regs.dst_height);\n    int bpp = ati_bpp_from_datatype(s);\n    if (!bpp) {\n        qemu_log_mask(LOG_GUEST_ERROR, \"Invalid bpp\\n\");\n        return;\n    }\n    int dst_stride = DEFAULT_CNTL ? s->regs.dst_pitch : s->regs.default_pitch;\n    if (!dst_stride) {\n        qemu_log_mask(LOG_GUEST_ERROR, \"Zero dest pitch\\n\");\n        return;\n    }\n    uint8_t *dst_bits = s->vga.vram_ptr + (DEFAULT_CNTL ?\n                        s->regs.dst_offset : s->regs.default_offset);\n\n    if (s->dev_id == PCI_DEVICE_ID_ATI_RAGE128_PF) {\n        dst_bits += s->regs.crtc_offset & 0x07ffffff;\n        dst_stride *= bpp;\n    }\n    uint8_t *end = s->vga.vram_ptr + s->vga.vram_size;\n    if (dst_bits >= end || dst_bits + dst_x + (dst_y + s->regs.dst_height) *\n        dst_stride >= end) {\n        qemu_log_mask(LOG_UNIMP, \"blt outside vram not implemented\\n\");\n        return;\n    }\n    DPRINTF(\"%d %d %d, %d %d %d, (%d,%d) -> (%d,%d) %dx%d %c %c\\n\",\n            s->regs.src_offset, s->regs.dst_offset, s->regs.default_offset,\n            s->regs.src_pitch, s->regs.dst_pitch, s->regs.default_pitch,\n            s->regs.src_x, s->regs.src_y, s->regs.dst_x, s->regs.dst_y,\n            s->regs.dst_width, s->regs.dst_height,\n            (s->regs.dp_cntl & DST_X_LEFT_TO_RIGHT ? '>' : '<'),\n            (s->regs.dp_cntl & DST_Y_TOP_TO_BOTTOM ? 'v' : '^'));\n    switch (s->regs.dp_mix & GMC_ROP3_MASK) {\n    case ROP3_SRCCOPY:\n    {\n        unsigned src_x = (s->regs.dp_cntl & DST_X_LEFT_TO_RIGHT ?\n                       s->regs.src_x : s->regs.src_x + 1 - s->regs.dst_width);\n        unsigned src_y = (s->regs.dp_cntl & DST_Y_TOP_TO_BOTTOM ?\n                       s->regs.src_y : s->regs.src_y + 1 - s->regs.dst_height);\n        int src_stride = DEFAULT_CNTL ?\n                         s->regs.src_pitch : s->regs.default_pitch;\n        if (!src_stride) {\n            qemu_log_mask(LOG_GUEST_ERROR, \"Zero source pitch\\n\");\n            return;\n        }\n        uint8_t *src_bits = s->vga.vram_ptr + (DEFAULT_CNTL ?\n                            s->regs.src_offset : s->regs.default_offset);\n\n        if (s->dev_id == PCI_DEVICE_ID_ATI_RAGE128_PF) {\n            src_bits += s->regs.crtc_offset & 0x07ffffff;\n            src_stride *= bpp;\n        }\n        if (src_bits >= end || src_bits + src_x +\n            (src_y + s->regs.dst_height) * src_stride >= end) {\n            qemu_log_mask(LOG_UNIMP, \"blt outside vram not implemented\\n\");\n            return;\n        }\n\n        src_stride /= sizeof(uint32_t);\n        dst_stride /= sizeof(uint32_t);\n        DPRINTF(\"pixman_blt(%p, %p, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d)\\n\",\n                src_bits, dst_bits, src_stride, dst_stride, bpp, bpp,\n                src_x, src_y, dst_x, dst_y,\n                s->regs.dst_width, s->regs.dst_height);\n        if (s->regs.dp_cntl & DST_X_LEFT_TO_RIGHT &&\n            s->regs.dp_cntl & DST_Y_TOP_TO_BOTTOM) {\n            pixman_blt((uint32_t *)src_bits, (uint32_t *)dst_bits,\n                       src_stride, dst_stride, bpp, bpp,\n                       src_x, src_y, dst_x, dst_y,\n                       s->regs.dst_width, s->regs.dst_height);\n        } else {\n            /* FIXME: We only really need a temporary if src and dst overlap */\n            int llb = s->regs.dst_width * (bpp / 8);\n            int tmp_stride = DIV_ROUND_UP(llb, sizeof(uint32_t));\n            uint32_t *tmp = g_malloc(tmp_stride * sizeof(uint32_t) *\n                                     s->regs.dst_height);\n            pixman_blt((uint32_t *)src_bits, tmp,\n                       src_stride, tmp_stride, bpp, bpp,\n                       src_x, src_y, 0, 0,\n                       s->regs.dst_width, s->regs.dst_height);\n            pixman_blt(tmp, (uint32_t *)dst_bits,\n                       tmp_stride, dst_stride, bpp, bpp,\n                       0, 0, dst_x, dst_y,\n                       s->regs.dst_width, s->regs.dst_height);\n            g_free(tmp);\n        }\n        if (dst_bits >= s->vga.vram_ptr + s->vga.vbe_start_addr &&\n            dst_bits < s->vga.vram_ptr + s->vga.vbe_start_addr +\n            s->vga.vbe_regs[VBE_DISPI_INDEX_YRES] * s->vga.vbe_line_offset) {\n            memory_region_set_dirty(&s->vga.vram, s->vga.vbe_start_addr +\n                                    s->regs.dst_offset +\n                                    dst_y * surface_stride(ds),\n                                    s->regs.dst_height * surface_stride(ds));\n        }\n        s->regs.dst_x = (s->regs.dp_cntl & DST_X_LEFT_TO_RIGHT ?\n                         dst_x + s->regs.dst_width : dst_x);\n        s->regs.dst_y = (s->regs.dp_cntl & DST_Y_TOP_TO_BOTTOM ?\n                         dst_y + s->regs.dst_height : dst_y);\n        break;\n    }\n    case ROP3_PATCOPY:\n    case ROP3_BLACKNESS:\n    case ROP3_WHITENESS:\n    {\n        uint32_t filler = 0;\n\n        switch (s->regs.dp_mix & GMC_ROP3_MASK) {\n        case ROP3_PATCOPY:\n            filler = s->regs.dp_brush_frgd_clr;\n            break;\n        case ROP3_BLACKNESS:\n            filler = 0xffUL << 24 | rgb_to_pixel32(s->vga.palette[0],\n                     s->vga.palette[1], s->vga.palette[2]);\n            break;\n        case ROP3_WHITENESS:\n            filler = 0xffUL << 24 | rgb_to_pixel32(s->vga.palette[3],\n                     s->vga.palette[4], s->vga.palette[5]);\n            break;\n        }\n\n        dst_stride /= sizeof(uint32_t);\n        DPRINTF(\"pixman_fill(%p, %d, %d, %d, %d, %d, %d, %x)\\n\",\n                dst_bits, dst_stride, bpp,\n                s->regs.dst_x, s->regs.dst_y,\n                s->regs.dst_width, s->regs.dst_height,\n                filler);\n        pixman_fill((uint32_t *)dst_bits, dst_stride, bpp,\n                    s->regs.dst_x, s->regs.dst_y,\n                    s->regs.dst_width, s->regs.dst_height,\n                    filler);\n        if (dst_bits >= s->vga.vram_ptr + s->vga.vbe_start_addr &&\n            dst_bits < s->vga.vram_ptr + s->vga.vbe_start_addr +\n            s->vga.vbe_regs[VBE_DISPI_INDEX_YRES] * s->vga.vbe_line_offset) {\n            memory_region_set_dirty(&s->vga.vram, s->vga.vbe_start_addr +\n                                    s->regs.dst_offset +\n                                    dst_y * surface_stride(ds),\n                                    s->regs.dst_height * surface_stride(ds));\n        }\n        s->regs.dst_y = (s->regs.dp_cntl & DST_Y_TOP_TO_BOTTOM ?\n                         dst_y + s->regs.dst_height : dst_y);\n        break;\n    }\n    default:\n        qemu_log_mask(LOG_UNIMP, \"Unimplemented ati_2d blt op %x\\n\",\n                      (s->regs.dp_mix & GMC_ROP3_MASK) >> 16);\n    }\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145547,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "MagickExport MagickBooleanType SubstituteString(char **string,\n  const char *search,const char *replace)\n{\n  MagickBooleanType\n    status;\n\n  register char\n    *p;\n\n  size_t\n    extent,\n    replace_extent,\n    search_extent;\n\n  ssize_t\n    offset;\n\n  status=MagickFalse;\n  search_extent=0,\n  replace_extent=0;\n  for (p=strchr(*string,*search); p != (char *) NULL; p=strchr(p+1,*search))\n  {\n    if (search_extent == 0)\n      search_extent=strlen(search);\n    if (strncmp(p,search,search_extent) != 0)\n      continue;\n    /*\n      We found a match.\n    */\n    status=MagickTrue;\n    if (replace_extent == 0)\n      replace_extent=strlen(replace);\n    if (replace_extent > search_extent)\n      {\n        /*\n          Make room for the replacement string.\n        */\n        offset=(ssize_t) (p-(*string));\n        extent=strlen(*string)+replace_extent-search_extent+1;\n        *string=(char *) ResizeQuantumMemory(*string,extent+MagickPathExtent,\n          sizeof(*p));\n        if (*string == (char *) NULL)\n          ThrowFatalException(ResourceLimitFatalError,\"UnableToAcquireString\");\n        p=(*string)+offset;\n      }\n    /*\n      Replace string.\n    */\n    if (search_extent != replace_extent)\n      (void) memmove(p+replace_extent,p+search_extent,\n        strlen(p+search_extent)+1);\n    (void) memcpy(p,replace,replace_extent);\n    p+=replace_extent-1;\n  }\n  return(status);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145612,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "MagickExport MagickBooleanType SubstituteString(char **string,\n  const char *search,const char *replace)\n{\n  MagickBooleanType\n    status;\n\n  register char\n    *p;\n\n  size_t\n    extent,\n    replace_extent,\n    search_extent;\n\n  ssize_t\n    offset;\n\n  status=MagickFalse;\n  search_extent=0,\n  replace_extent=0;\n  for (p=strchr(*string,*search); p != (char *) NULL; p=strchr(p+1,*search))\n  {\n    if (search_extent == 0)\n      search_extent=strlen(search);\n    if ((*p == *search) && (strncmp(p,search,search_extent) != 0))\n      continue;\n    /*\n      We found a match.\n    */\n    status=MagickTrue;\n    if (replace_extent == 0)\n      replace_extent=strlen(replace);\n    if (replace_extent > search_extent)\n      {\n        /*\n          Make room for the replacement string.\n        */\n        offset=(ssize_t) (p-(*string));\n        extent=strlen(*string)+replace_extent-search_extent+1;\n        *string=(char *) ResizeQuantumMemory(*string,extent+MagickPathExtent,\n          sizeof(*p));\n        if (*string == (char *) NULL)\n          ThrowFatalException(ResourceLimitFatalError,\"UnableToAcquireString\");\n        p=(*string)+offset;\n      }\n    /*\n      Replace string.\n    */\n    if (search_extent != replace_extent)\n      (void) memmove(p+replace_extent,p+search_extent,\n        strlen(p+search_extent)+1);\n    (void) memcpy(p,replace,replace_extent);\n    p+=replace_extent;\n    if (replace_extent != 0)\n      p--;\n  }\n  return(status);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145613,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "MagickExport MagickBooleanType SetImageProfile(Image *image,const char *name,\n  const StringInfo *profile,ExceptionInfo *exception)\n{\n  char\n    key[MaxTextExtent],\n    property[MaxTextExtent];\n\n  MagickBooleanType\n    status;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->profiles == (SplayTreeInfo *) NULL)\n    image->profiles=NewSplayTree(CompareSplayTreeString,RelinquishMagickMemory,\n      DestroyProfile);\n  (void) CopyMagickString(key,name,MaxTextExtent);\n  status=AddValueToSplayTree((SplayTreeInfo *) image->profiles,\n    ConstantString(key),CloneStringInfo(profile));\n  if ((status != MagickFalse) &&\n      ((LocaleCompare(name,\"iptc\") == 0) || (LocaleCompare(name,\"8bim\") == 0)))\n    (void) GetProfilesFromResourceBlock(image,profile,exception);\n  /*\n    Inject profile into image properties.\n  */\n  (void) FormatLocaleString(property,MaxTextExtent,\"%s:sans\",name);\n  (void) GetImageProperty(image,property,exception);\n  return(status);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145720,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "MagickExport MagickBooleanType SetImageProfile(Image *image,const char *name,\n  const StringInfo *profile,ExceptionInfo *exception)\n{\n  char\n    key[MaxTextExtent],\n    property[MaxTextExtent];\n\n  MagickBooleanType\n    status;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->profiles == (SplayTreeInfo *) NULL)\n    image->profiles=NewSplayTree(CompareSplayTreeString,RelinquishMagickMemory,\n      DestroyProfile);\n  (void) CopyMagickString(key,name,MaxTextExtent);\n  status=AddValueToSplayTree((SplayTreeInfo *) image->profiles,\n    ConstantString(key),CloneStringInfo(profile));\n  if ((status != MagickFalse) &&\n      ((LocaleCompare(name,\"iptc\") == 0) || (LocaleCompare(name,\"8bim\") == 0)))\n    (void) GetProfilesFromResourceBlock(image,profile,exception);\n  /*\n    Inject profile into image properties.\n  */\n  (void) FormatLocaleString(property,MaxTextExtent,\"%s:*\",name);\n  (void) GetImageProperty(image,property,exception);\n  return(status);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145721,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "PHP_XML_API zend_string *xml_utf8_encode(const char *s, size_t len, const XML_Char *encoding)\n{\n\tsize_t pos = len;\n\tzend_string *str;\n\tunsigned int c;\n\tunsigned short (*encoder)(unsigned char) = NULL;\n\txml_encoding *enc = xml_get_encoding(encoding);\n\n\tif (enc) {\n\t\tencoder = enc->encoding_function;\n\t} else {\n\t\t/* If the target encoding was unknown, fail */\n\t\treturn NULL;\n\t}\n\tif (encoder == NULL) {\n\t\t/* If no encoder function was specified, return the data as-is.\n\t\t */\n\t\tstr = zend_string_init(s, len, 0);\n\t\treturn str;\n\t}\n\t/* This is the theoretical max (will never get beyond len * 2 as long\n\t * as we are converting from single-byte characters, though) */\n\tstr = zend_string_alloc(len * 4, 0);\n\tZSTR_LEN(str) = 0;\n\twhile (pos > 0) {\n\t\tc = encoder ? encoder((unsigned char)(*s)) : (unsigned short)(*s);\n\t\tif (c < 0x80) {\n\t\t\tZSTR_VAL(str)[ZSTR_LEN(str)++] = (char) c;\n\t\t} else if (c < 0x800) {\n\t\t\tZSTR_VAL(str)[ZSTR_LEN(str)++] = (0xc0 | (c >> 6));\n\t\t\tZSTR_VAL(str)[ZSTR_LEN(str)++] = (0x80 | (c & 0x3f));\n\t\t} else if (c < 0x10000) {\n\t\t\tZSTR_VAL(str)[ZSTR_LEN(str)++] = (0xe0 | (c >> 12));\n\t\t\tZSTR_VAL(str)[ZSTR_LEN(str)++] = (0xc0 | ((c >> 6) & 0x3f));\n\t\t\tZSTR_VAL(str)[ZSTR_LEN(str)++] = (0x80 | (c & 0x3f));\n\t\t} else if (c < 0x200000) {\n\t\t\tZSTR_VAL(str)[ZSTR_LEN(str)++] = (0xf0 | (c >> 18));\n\t\t\tZSTR_VAL(str)[ZSTR_LEN(str)++] = (0xe0 | ((c >> 12) & 0x3f));\n\t\t\tZSTR_VAL(str)[ZSTR_LEN(str)++] = (0xc0 | ((c >> 6) & 0x3f));\n\t\t\tZSTR_VAL(str)[ZSTR_LEN(str)++] = (0x80 | (c & 0x3f));\n\t\t}\n\t\tpos--;\n\t\ts++;\n\t}\n\tZSTR_VAL(str)[ZSTR_LEN(str)] = '\\0';\n\tstr = zend_string_truncate(str, ZSTR_LEN(str), 0);\n\treturn str;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145742,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "PHP_XML_API zend_string *xml_utf8_encode(const char *s, size_t len, const XML_Char *encoding)\n{\n\tsize_t pos = len;\n\tzend_string *str;\n\tunsigned int c;\n\tunsigned short (*encoder)(unsigned char) = NULL;\n\txml_encoding *enc = xml_get_encoding(encoding);\n\n\tif (enc) {\n\t\tencoder = enc->encoding_function;\n\t} else {\n\t\t/* If the target encoding was unknown, fail */\n\t\treturn NULL;\n\t}\n\tif (encoder == NULL) {\n\t\t/* If no encoder function was specified, return the data as-is.\n\t\t */\n\t\tstr = zend_string_init(s, len, 0);\n\t\treturn str;\n\t}\n\t/* This is the theoretical max (will never get beyond len * 2 as long\n\t * as we are converting from single-byte characters, though) */\n\tstr = zend_string_safe_alloc(len, 4, 0, 0);\n\tZSTR_LEN(str) = 0;\n\twhile (pos > 0) {\n\t\tc = encoder ? encoder((unsigned char)(*s)) : (unsigned short)(*s);\n\t\tif (c < 0x80) {\n\t\t\tZSTR_VAL(str)[ZSTR_LEN(str)++] = (char) c;\n\t\t} else if (c < 0x800) {\n\t\t\tZSTR_VAL(str)[ZSTR_LEN(str)++] = (0xc0 | (c >> 6));\n\t\t\tZSTR_VAL(str)[ZSTR_LEN(str)++] = (0x80 | (c & 0x3f));\n\t\t} else if (c < 0x10000) {\n\t\t\tZSTR_VAL(str)[ZSTR_LEN(str)++] = (0xe0 | (c >> 12));\n\t\t\tZSTR_VAL(str)[ZSTR_LEN(str)++] = (0xc0 | ((c >> 6) & 0x3f));\n\t\t\tZSTR_VAL(str)[ZSTR_LEN(str)++] = (0x80 | (c & 0x3f));\n\t\t} else if (c < 0x200000) {\n\t\t\tZSTR_VAL(str)[ZSTR_LEN(str)++] = (0xf0 | (c >> 18));\n\t\t\tZSTR_VAL(str)[ZSTR_LEN(str)++] = (0xe0 | ((c >> 12) & 0x3f));\n\t\t\tZSTR_VAL(str)[ZSTR_LEN(str)++] = (0xc0 | ((c >> 6) & 0x3f));\n\t\t\tZSTR_VAL(str)[ZSTR_LEN(str)++] = (0x80 | (c & 0x3f));\n\t\t}\n\t\tpos--;\n\t\ts++;\n\t}\n\tZSTR_VAL(str)[ZSTR_LEN(str)] = '\\0';\n\tstr = zend_string_truncate(str, ZSTR_LEN(str), 0);\n\treturn str;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145743,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "PHP_MINIT_FUNCTION(filter)\n{\n\tZEND_INIT_MODULE_GLOBALS(filter, php_filter_init_globals, NULL);\n\n\tREGISTER_INI_ENTRIES();\n\n\tREGISTER_LONG_CONSTANT(\"INPUT_POST\",\tPARSE_POST, \tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"INPUT_GET\",\t\tPARSE_GET,\t\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"INPUT_COOKIE\",\tPARSE_COOKIE, \tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"INPUT_ENV\",\t\tPARSE_ENV,\t\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"INPUT_SERVER\",\tPARSE_SERVER, \tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"INPUT_SESSION\", PARSE_SESSION, \tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"INPUT_REQUEST\", PARSE_REQUEST, \tCONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_NONE\", FILTER_FLAG_NONE, CONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"FILTER_REQUIRE_SCALAR\", FILTER_REQUIRE_SCALAR, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_REQUIRE_ARRAY\", FILTER_REQUIRE_ARRAY, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_FORCE_ARRAY\", FILTER_FORCE_ARRAY, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_NULL_ON_FAILURE\", FILTER_NULL_ON_FAILURE, CONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"FILTER_VALIDATE_INT\", FILTER_VALIDATE_INT, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_VALIDATE_BOOLEAN\", FILTER_VALIDATE_BOOLEAN, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_VALIDATE_FLOAT\", FILTER_VALIDATE_FLOAT, CONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"FILTER_VALIDATE_REGEXP\", FILTER_VALIDATE_REGEXP, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_VALIDATE_URL\", FILTER_VALIDATE_URL, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_VALIDATE_EMAIL\", FILTER_VALIDATE_EMAIL, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_VALIDATE_IP\", FILTER_VALIDATE_IP, CONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"FILTER_DEFAULT\", FILTER_DEFAULT, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_UNSAFE_RAW\", FILTER_UNSAFE_RAW, CONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"FILTER_SANITIZE_STRING\", FILTER_SANITIZE_STRING, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_SANITIZE_STRIPPED\", FILTER_SANITIZE_STRING, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_SANITIZE_ENCODED\", FILTER_SANITIZE_ENCODED, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_SANITIZE_SPECIAL_CHARS\", FILTER_SANITIZE_SPECIAL_CHARS, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_SANITIZE_EMAIL\", FILTER_SANITIZE_EMAIL, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_SANITIZE_URL\", FILTER_SANITIZE_URL, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_SANITIZE_NUMBER_INT\", FILTER_SANITIZE_NUMBER_INT, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_SANITIZE_NUMBER_FLOAT\", FILTER_SANITIZE_NUMBER_FLOAT, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_SANITIZE_MAGIC_QUOTES\", FILTER_SANITIZE_MAGIC_QUOTES, CONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"FILTER_CALLBACK\", FILTER_CALLBACK, CONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_ALLOW_OCTAL\", FILTER_FLAG_ALLOW_OCTAL, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_ALLOW_HEX\", FILTER_FLAG_ALLOW_HEX, CONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_STRIP_LOW\", FILTER_FLAG_STRIP_LOW, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_STRIP_HIGH\", FILTER_FLAG_STRIP_HIGH, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_STRIP_BACKTICK\", FILTER_FLAG_STRIP_BACKTICK, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_ENCODE_LOW\", FILTER_FLAG_ENCODE_LOW, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_ENCODE_HIGH\", FILTER_FLAG_ENCODE_HIGH, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_ENCODE_AMP\", FILTER_FLAG_ENCODE_AMP, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_NO_ENCODE_QUOTES\", FILTER_FLAG_NO_ENCODE_QUOTES, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_EMPTY_STRING_NULL\", FILTER_FLAG_EMPTY_STRING_NULL, CONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_ALLOW_FRACTION\", FILTER_FLAG_ALLOW_FRACTION, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_ALLOW_THOUSAND\", FILTER_FLAG_ALLOW_THOUSAND, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_ALLOW_SCIENTIFIC\", FILTER_FLAG_ALLOW_SCIENTIFIC, CONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_SCHEME_REQUIRED\", FILTER_FLAG_SCHEME_REQUIRED, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_HOST_REQUIRED\", FILTER_FLAG_HOST_REQUIRED, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_PATH_REQUIRED\", FILTER_FLAG_PATH_REQUIRED, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_QUERY_REQUIRED\", FILTER_FLAG_QUERY_REQUIRED, CONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_IPV4\", FILTER_FLAG_IPV4, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_IPV6\", FILTER_FLAG_IPV6, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_NO_RES_RANGE\", FILTER_FLAG_NO_RES_RANGE, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_NO_PRIV_RANGE\", FILTER_FLAG_NO_PRIV_RANGE, CONST_CS | CONST_PERSISTENT);\n\n\tsapi_register_input_filter(php_sapi_filter, php_sapi_filter_init);\n\n\treturn SUCCESS;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145842,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "PHP_MINIT_FUNCTION(filter)\n{\n\tZEND_INIT_MODULE_GLOBALS(filter, php_filter_init_globals, NULL);\n\n\tREGISTER_INI_ENTRIES();\n\n\tREGISTER_LONG_CONSTANT(\"INPUT_POST\",\tPARSE_POST, \tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"INPUT_GET\",\t\tPARSE_GET,\t\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"INPUT_COOKIE\",\tPARSE_COOKIE, \tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"INPUT_ENV\",\t\tPARSE_ENV,\t\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"INPUT_SERVER\",\tPARSE_SERVER, \tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"INPUT_SESSION\", PARSE_SESSION, \tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"INPUT_REQUEST\", PARSE_REQUEST, \tCONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_NONE\", FILTER_FLAG_NONE, CONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"FILTER_REQUIRE_SCALAR\", FILTER_REQUIRE_SCALAR, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_REQUIRE_ARRAY\", FILTER_REQUIRE_ARRAY, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_FORCE_ARRAY\", FILTER_FORCE_ARRAY, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_NULL_ON_FAILURE\", FILTER_NULL_ON_FAILURE, CONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"FILTER_VALIDATE_INT\", FILTER_VALIDATE_INT, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_VALIDATE_BOOLEAN\", FILTER_VALIDATE_BOOLEAN, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_VALIDATE_FLOAT\", FILTER_VALIDATE_FLOAT, CONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"FILTER_VALIDATE_REGEXP\", FILTER_VALIDATE_REGEXP, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_VALIDATE_URL\", FILTER_VALIDATE_URL, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_VALIDATE_EMAIL\", FILTER_VALIDATE_EMAIL, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_VALIDATE_IP\", FILTER_VALIDATE_IP, CONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"FILTER_DEFAULT\", FILTER_DEFAULT, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_UNSAFE_RAW\", FILTER_UNSAFE_RAW, CONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"FILTER_SANITIZE_STRING\", FILTER_SANITIZE_STRING, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_SANITIZE_STRIPPED\", FILTER_SANITIZE_STRING, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_SANITIZE_ENCODED\", FILTER_SANITIZE_ENCODED, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_SANITIZE_SPECIAL_CHARS\", FILTER_SANITIZE_SPECIAL_CHARS, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_SANITIZE_FULL_SPECIAL_CHARS\", FILTER_SANITIZE_SPECIAL_CHARS, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_SANITIZE_EMAIL\", FILTER_SANITIZE_EMAIL, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_SANITIZE_URL\", FILTER_SANITIZE_URL, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_SANITIZE_NUMBER_INT\", FILTER_SANITIZE_NUMBER_INT, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_SANITIZE_NUMBER_FLOAT\", FILTER_SANITIZE_NUMBER_FLOAT, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_SANITIZE_MAGIC_QUOTES\", FILTER_SANITIZE_MAGIC_QUOTES, CONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"FILTER_CALLBACK\", FILTER_CALLBACK, CONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_ALLOW_OCTAL\", FILTER_FLAG_ALLOW_OCTAL, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_ALLOW_HEX\", FILTER_FLAG_ALLOW_HEX, CONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_STRIP_LOW\", FILTER_FLAG_STRIP_LOW, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_STRIP_HIGH\", FILTER_FLAG_STRIP_HIGH, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_STRIP_BACKTICK\", FILTER_FLAG_STRIP_BACKTICK, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_ENCODE_LOW\", FILTER_FLAG_ENCODE_LOW, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_ENCODE_HIGH\", FILTER_FLAG_ENCODE_HIGH, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_ENCODE_AMP\", FILTER_FLAG_ENCODE_AMP, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_NO_ENCODE_QUOTES\", FILTER_FLAG_NO_ENCODE_QUOTES, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_EMPTY_STRING_NULL\", FILTER_FLAG_EMPTY_STRING_NULL, CONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_ALLOW_FRACTION\", FILTER_FLAG_ALLOW_FRACTION, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_ALLOW_THOUSAND\", FILTER_FLAG_ALLOW_THOUSAND, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_ALLOW_SCIENTIFIC\", FILTER_FLAG_ALLOW_SCIENTIFIC, CONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_SCHEME_REQUIRED\", FILTER_FLAG_SCHEME_REQUIRED, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_HOST_REQUIRED\", FILTER_FLAG_HOST_REQUIRED, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_PATH_REQUIRED\", FILTER_FLAG_PATH_REQUIRED, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_QUERY_REQUIRED\", FILTER_FLAG_QUERY_REQUIRED, CONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_IPV4\", FILTER_FLAG_IPV4, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_IPV6\", FILTER_FLAG_IPV6, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_NO_RES_RANGE\", FILTER_FLAG_NO_RES_RANGE, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_NO_PRIV_RANGE\", FILTER_FLAG_NO_PRIV_RANGE, CONST_CS | CONST_PERSISTENT);\n\n\tsapi_register_input_filter(php_sapi_filter, php_sapi_filter_init);\n\n\treturn SUCCESS;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145843,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "get_futex_key(u32 __user *uaddr, int fshared, union futex_key *key, int rw)\n{\n\tunsigned long address = (unsigned long)uaddr;\n\tstruct mm_struct *mm = current->mm;\n\tstruct page *page, *tail;\n\tstruct address_space *mapping;\n\tint err, ro = 0;\n\n\t/*\n\t * The futex address must be \"naturally\" aligned.\n\t */\n\tkey->both.offset = address % PAGE_SIZE;\n\tif (unlikely((address % sizeof(u32)) != 0))\n\t\treturn -EINVAL;\n\taddress -= key->both.offset;\n\n\tif (unlikely(!access_ok(rw, uaddr, sizeof(u32))))\n\t\treturn -EFAULT;\n\n\tif (unlikely(should_fail_futex(fshared)))\n\t\treturn -EFAULT;\n\n\t/*\n\t * PROCESS_PRIVATE futexes are fast.\n\t * As the mm cannot disappear under us and the 'key' only needs\n\t * virtual address, we dont even have to find the underlying vma.\n\t * Note : We do have to check 'uaddr' is a valid user address,\n\t *        but access_ok() should be faster than find_vma()\n\t */\n\tif (!fshared) {\n\t\tkey->private.mm = mm;\n\t\tkey->private.address = address;\n\t\tget_futex_key_refs(key);  /* implies smp_mb(); (B) */\n\t\treturn 0;\n\t}\n\nagain:\n\t/* Ignore any VERIFY_READ mapping (futex common case) */\n\tif (unlikely(should_fail_futex(fshared)))\n\t\treturn -EFAULT;\n\n\terr = get_user_pages_fast(address, 1, 1, &page);\n\t/*\n\t * If write access is not required (eg. FUTEX_WAIT), try\n\t * and get read-only access.\n\t */\n\tif (err == -EFAULT && rw == VERIFY_READ) {\n\t\terr = get_user_pages_fast(address, 1, 0, &page);\n\t\tro = 1;\n\t}\n\tif (err < 0)\n\t\treturn err;\n\telse\n\t\terr = 0;\n\n\t/*\n\t * The treatment of mapping from this point on is critical. The page\n\t * lock protects many things but in this context the page lock\n\t * stabilizes mapping, prevents inode freeing in the shared\n\t * file-backed region case and guards against movement to swap cache.\n\t *\n\t * Strictly speaking the page lock is not needed in all cases being\n\t * considered here and page lock forces unnecessarily serialization\n\t * From this point on, mapping will be re-verified if necessary and\n\t * page lock will be acquired only if it is unavoidable\n\t *\n\t * Mapping checks require the head page for any compound page so the\n\t * head page and mapping is looked up now. For anonymous pages, it\n\t * does not matter if the page splits in the future as the key is\n\t * based on the address. For filesystem-backed pages, the tail is\n\t * required as the index of the page determines the key. For\n\t * base pages, there is no tail page and tail == page.\n\t */\n\ttail = page;\n\tpage = compound_head(page);\n\tmapping = READ_ONCE(page->mapping);\n\n\t/*\n\t * If page->mapping is NULL, then it cannot be a PageAnon\n\t * page; but it might be the ZERO_PAGE or in the gate area or\n\t * in a special mapping (all cases which we are happy to fail);\n\t * or it may have been a good file page when get_user_pages_fast\n\t * found it, but truncated or holepunched or subjected to\n\t * invalidate_complete_page2 before we got the page lock (also\n\t * cases which we are happy to fail).  And we hold a reference,\n\t * so refcount care in invalidate_complete_page's remove_mapping\n\t * prevents drop_caches from setting mapping to NULL beneath us.\n\t *\n\t * The case we do have to guard against is when memory pressure made\n\t * shmem_writepage move it from filecache to swapcache beneath us:\n\t * an unlikely race, but we do need to retry for page->mapping.\n\t */\n\tif (unlikely(!mapping)) {\n\t\tint shmem_swizzled;\n\n\t\t/*\n\t\t * Page lock is required to identify which special case above\n\t\t * applies. If this is really a shmem page then the page lock\n\t\t * will prevent unexpected transitions.\n\t\t */\n\t\tlock_page(page);\n\t\tshmem_swizzled = PageSwapCache(page) || page->mapping;\n\t\tunlock_page(page);\n\t\tput_page(page);\n\n\t\tif (shmem_swizzled)\n\t\t\tgoto again;\n\n\t\treturn -EFAULT;\n\t}\n\n\t/*\n\t * Private mappings are handled in a simple way.\n\t *\n\t * If the futex key is stored on an anonymous page, then the associated\n\t * object is the mm which is implicitly pinned by the calling process.\n\t *\n\t * NOTE: When userspace waits on a MAP_SHARED mapping, even if\n\t * it's a read-only handle, it's expected that futexes attach to\n\t * the object not the particular process.\n\t */\n\tif (PageAnon(page)) {\n\t\t/*\n\t\t * A RO anonymous page will never change and thus doesn't make\n\t\t * sense for futex operations.\n\t\t */\n\t\tif (unlikely(should_fail_futex(fshared)) || ro) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tkey->both.offset |= FUT_OFF_MMSHARED; /* ref taken on mm */\n\t\tkey->private.mm = mm;\n\t\tkey->private.address = address;\n\n\t\tget_futex_key_refs(key); /* implies smp_mb(); (B) */\n\n\t} else {\n\t\tstruct inode *inode;\n\n\t\t/*\n\t\t * The associated futex object in this case is the inode and\n\t\t * the page->mapping must be traversed. Ordinarily this should\n\t\t * be stabilised under page lock but it's not strictly\n\t\t * necessary in this case as we just want to pin the inode, not\n\t\t * update the radix tree or anything like that.\n\t\t *\n\t\t * The RCU read lock is taken as the inode is finally freed\n\t\t * under RCU. If the mapping still matches expectations then the\n\t\t * mapping->host can be safely accessed as being a valid inode.\n\t\t */\n\t\trcu_read_lock();\n\n\t\tif (READ_ONCE(page->mapping) != mapping) {\n\t\t\trcu_read_unlock();\n\t\t\tput_page(page);\n\n\t\t\tgoto again;\n\t\t}\n\n\t\tinode = READ_ONCE(mapping->host);\n\t\tif (!inode) {\n\t\t\trcu_read_unlock();\n\t\t\tput_page(page);\n\n\t\t\tgoto again;\n\t\t}\n\n\t\t/*\n\t\t * Take a reference unless it is about to be freed. Previously\n\t\t * this reference was taken by ihold under the page lock\n\t\t * pinning the inode in place so i_lock was unnecessary. The\n\t\t * only way for this check to fail is if the inode was\n\t\t * truncated in parallel which is almost certainly an\n\t\t * application bug. In such a case, just retry.\n\t\t *\n\t\t * We are not calling into get_futex_key_refs() in file-backed\n\t\t * cases, therefore a successful atomic_inc return below will\n\t\t * guarantee that get_futex_key() will still imply smp_mb(); (B).\n\t\t */\n\t\tif (!atomic_inc_not_zero(&inode->i_count)) {\n\t\t\trcu_read_unlock();\n\t\t\tput_page(page);\n\n\t\t\tgoto again;\n\t\t}\n\n\t\t/* Should be impossible but lets be paranoid for now */\n\t\tif (WARN_ON_ONCE(inode->i_mapping != mapping)) {\n\t\t\terr = -EFAULT;\n\t\t\trcu_read_unlock();\n\t\t\tiput(inode);\n\n\t\t\tgoto out;\n\t\t}\n\n\t\tkey->both.offset |= FUT_OFF_INODE; /* inode-based key */\n\t\tkey->shared.inode = inode;\n\t\tkey->shared.pgoff = basepage_index(tail);\n\t\trcu_read_unlock();\n\t}\n\nout:\n\tput_page(page);\n\treturn err;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145867,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "    void WebPImage::decodeChunks(uint64_t filesize)\n    {\n        DataBuf   chunkId(5);\n        byte      size_buff[WEBP_TAG_SIZE];\n        bool      has_canvas_data = false;\n\n#ifdef DEBUG\n        std::cout << \"Reading metadata\" << std::endl;\n#endif\n\n        chunkId.pData_[4] = '\\0' ;\n        while ( !io_->eof() && (uint64_t) io_->tell() < filesize) {\n            io_->read(chunkId.pData_, WEBP_TAG_SIZE);\n            io_->read(size_buff, WEBP_TAG_SIZE);\n            const uint32_t size = Exiv2::getULong(size_buff, littleEndian);\n            enforce(size <= (filesize - io_->tell()), Exiv2::kerCorruptedMetadata);\n\n            DataBuf payload(size);\n\n            if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8X) && !has_canvas_data) {\n                enforce(size >= 10, Exiv2::kerCorruptedMetadata);\n\n                has_canvas_data = true;\n                byte size_buf[WEBP_TAG_SIZE];\n\n                io_->read(payload.pData_, payload.size_);\n\n                // Fetch width\n                memcpy(&size_buf, &payload.pData_[4], 3);\n                size_buf[3] = 0;\n                pixelWidth_ = Exiv2::getULong(size_buf, littleEndian) + 1;\n\n                // Fetch height\n                memcpy(&size_buf, &payload.pData_[7], 3);\n                size_buf[3] = 0;\n                pixelHeight_ = Exiv2::getULong(size_buf, littleEndian) + 1;\n            } else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8) && !has_canvas_data) {\n                enforce(size >= 10, Exiv2::kerCorruptedMetadata);\n\n                has_canvas_data = true;\n                io_->read(payload.pData_, payload.size_);\n                byte size_buf[WEBP_TAG_SIZE];\n\n                // Fetch width\"\"\n                memcpy(&size_buf, &payload.pData_[6], 2);\n                size_buf[2] = 0;\n                size_buf[3] = 0;\n                pixelWidth_ = Exiv2::getULong(size_buf, littleEndian) & 0x3fff;\n\n                // Fetch height\n                memcpy(&size_buf, &payload.pData_[8], 2);\n                size_buf[2] = 0;\n                size_buf[3] = 0;\n                pixelHeight_ = Exiv2::getULong(size_buf, littleEndian) & 0x3fff;\n            } else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8L) && !has_canvas_data) {\n                enforce(size >= 5, Exiv2::kerCorruptedMetadata);\n\n                has_canvas_data = true;\n                byte size_buf_w[2];\n                byte size_buf_h[3];\n\n                io_->read(payload.pData_, payload.size_);\n\n                // Fetch width\n                memcpy(&size_buf_w, &payload.pData_[1], 2);\n                size_buf_w[1] &= 0x3F;\n                pixelWidth_ = Exiv2::getUShort(size_buf_w, littleEndian) + 1;\n\n                // Fetch height\n                memcpy(&size_buf_h, &payload.pData_[2], 3);\n                size_buf_h[0] = ((size_buf_h[0] >> 6) & 0x3) | ((size_buf_h[1]  & 0x3F) << 0x2);\n                size_buf_h[1] = ((size_buf_h[1] >> 6) & 0x3) | ((size_buf_h[2] & 0xF) << 0x2);\n                pixelHeight_ = Exiv2::getUShort(size_buf_h, littleEndian) + 1;\n            } else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_ANMF) && !has_canvas_data) {\n                enforce(size >= 12, Exiv2::kerCorruptedMetadata);\n\n                has_canvas_data = true;\n                byte size_buf[WEBP_TAG_SIZE];\n\n                io_->read(payload.pData_, payload.size_);\n\n                // Fetch width\n                memcpy(&size_buf, &payload.pData_[6], 3);\n                size_buf[3] = 0;\n                pixelWidth_ = Exiv2::getULong(size_buf, littleEndian) + 1;\n\n                // Fetch height\n                memcpy(&size_buf, &payload.pData_[9], 3);\n                size_buf[3] = 0;\n                pixelHeight_ = Exiv2::getULong(size_buf, littleEndian) + 1;\n            } else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_ICCP)) {\n                io_->read(payload.pData_, payload.size_);\n                this->setIccProfile(payload);\n            } else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_EXIF)) {\n                io_->read(payload.pData_, payload.size_);\n\n                // 4 meaningful bytes + 2 padding bytes\n                byte  exifLongHeader[]   = { 0xFF, 0x01, 0xFF, 0xE1, 0x00, 0x00 };\n                byte  exifShortHeader[]  = { 0x45, 0x78, 0x69, 0x66, 0x00, 0x00 };\n                byte  exifTiffLEHeader[] = { 0x49, 0x49, 0x2A };       // \"MM*\"\n                byte  exifTiffBEHeader[] = { 0x4D, 0x4D, 0x00, 0x2A }; // \"II\\0*\"\n                byte* rawExifData = nullptr;\n                long  offset = 0;\n                bool  s_header = false;\n                bool  le_header = false;\n                bool  be_header = false;\n                long  pos = getHeaderOffset (payload.pData_, payload.size_, (byte*)&exifLongHeader, 4);\n\n                if (pos == -1) {\n                    pos = getHeaderOffset (payload.pData_, payload.size_, (byte*)&exifLongHeader, 6);\n                    if (pos != -1) {\n                        s_header = true;\n                    }\n                }\n                if (pos == -1) {\n                    pos = getHeaderOffset (payload.pData_, payload.size_, (byte*)&exifTiffLEHeader, 3);\n                    if (pos != -1) {\n                        le_header = true;\n                    }\n                }\n                if (pos == -1) {\n                    pos = getHeaderOffset (payload.pData_, payload.size_, (byte*)&exifTiffBEHeader, 4);\n                    if (pos != -1) {\n                        be_header = true;\n                    }\n                }\n\n                if (s_header) {\n                    offset += 6;\n                }\n                if (be_header || le_header) {\n                    offset += 12;\n                }\n\n                const long sizePayload = payload.size_ + offset;\n                rawExifData = (byte*)malloc(sizePayload);\n\n                byte  sizeBuff[2];\n                if (s_header) {\n                    us2Data(sizeBuff, (uint16_t) (sizePayload - 6), bigEndian);\n                    memcpy(rawExifData, (char*)&exifLongHeader, 4);\n                    memcpy(rawExifData + 4, (char*)&sizeBuff, 2);\n                }\n\n                if (be_header || le_header) {\n                    us2Data(sizeBuff, (uint16_t) (sizePayload - 6), bigEndian);\n                    memcpy(rawExifData, (char*)&exifLongHeader, 4);\n                    memcpy(rawExifData + 4, (char*)&sizeBuff, 2);\n                    memcpy(rawExifData + 6, (char*)&exifShortHeader, 6);\n                }\n\n                memcpy(rawExifData + offset, payload.pData_, payload.size_);\n\n#ifdef DEBUG\n                std::cout << \"Display Hex Dump [size:\" << (unsigned long)sizePayload << \"]\" << std::endl;\n                std::cout << Internal::binaryToHex(rawExifData, sizePayload);\n#endif\n\n                if (pos != -1) {\n                    XmpData  xmpData;\n                    ByteOrder bo = ExifParser::decode(exifData_,\n                                                      payload.pData_ + pos,\n                                                      payload.size_ - pos);\n                    setByteOrder(bo);\n                }\n                else\n                {\n#ifndef SUPPRESS_WARNINGS\n                    EXV_WARNING << \"Failed to decode Exif metadata.\" << std::endl;\n#endif\n                    exifData_.clear();\n                }\n\n                if (rawExifData)\n                    free(rawExifData);\n            } else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_XMP)) {\n                io_->read(payload.pData_, payload.size_);\n                xmpPacket_.assign(reinterpret_cast<char*>(payload.pData_), payload.size_);\n                if (xmpPacket_.size() > 0 && XmpParser::decode(xmpData_, xmpPacket_)) {\n#ifndef SUPPRESS_WARNINGS\n                    EXV_WARNING << \"Failed to decode XMP metadata.\" << std::endl;\n#endif\n                } else {\n#ifdef DEBUG\n                    std::cout << \"Display Hex Dump [size:\" << (unsigned long)payload.size_ << \"]\" << std::endl;\n                    std::cout << Internal::binaryToHex(payload.pData_, payload.size_);\n#endif\n                }\n            } else {\n                io_->seek(size, BasicIo::cur);\n            }\n\n            if ( io_->tell() % 2 ) io_->seek(+1, BasicIo::cur);\n        }\n    }",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146014,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "    void WebPImage::decodeChunks(uint32_t filesize)\n    {\n        DataBuf   chunkId(5);\n        byte      size_buff[WEBP_TAG_SIZE];\n        bool      has_canvas_data = false;\n\n#ifdef DEBUG\n        std::cout << \"Reading metadata\" << std::endl;\n#endif\n\n        chunkId.pData_[4] = '\\0' ;\n        while ( !io_->eof() && (uint64_t) io_->tell() < filesize) {\n            io_->readOrThrow(chunkId.pData_, WEBP_TAG_SIZE, Exiv2::kerCorruptedMetadata);\n            io_->readOrThrow(size_buff, WEBP_TAG_SIZE, Exiv2::kerCorruptedMetadata);\n            const uint32_t size = Exiv2::getULong(size_buff, littleEndian);\n            enforce(io_->tell() <= filesize, Exiv2::kerCorruptedMetadata);\n            enforce(size <= (filesize - io_->tell()), Exiv2::kerCorruptedMetadata);\n\n            DataBuf payload(size);\n\n            if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8X) && !has_canvas_data) {\n                enforce(size >= 10, Exiv2::kerCorruptedMetadata);\n\n                has_canvas_data = true;\n                byte size_buf[WEBP_TAG_SIZE];\n\n                io_->readOrThrow(payload.pData_, payload.size_, Exiv2::kerCorruptedMetadata);\n\n                // Fetch width\n                memcpy(&size_buf, &payload.pData_[4], 3);\n                size_buf[3] = 0;\n                pixelWidth_ = Exiv2::getULong(size_buf, littleEndian) + 1;\n\n                // Fetch height\n                memcpy(&size_buf, &payload.pData_[7], 3);\n                size_buf[3] = 0;\n                pixelHeight_ = Exiv2::getULong(size_buf, littleEndian) + 1;\n            } else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8) && !has_canvas_data) {\n                enforce(size >= 10, Exiv2::kerCorruptedMetadata);\n\n                has_canvas_data = true;\n                io_->readOrThrow(payload.pData_, payload.size_, Exiv2::kerCorruptedMetadata);\n                byte size_buf[WEBP_TAG_SIZE];\n\n                // Fetch width\"\"\n                memcpy(&size_buf, &payload.pData_[6], 2);\n                size_buf[2] = 0;\n                size_buf[3] = 0;\n                pixelWidth_ = Exiv2::getULong(size_buf, littleEndian) & 0x3fff;\n\n                // Fetch height\n                memcpy(&size_buf, &payload.pData_[8], 2);\n                size_buf[2] = 0;\n                size_buf[3] = 0;\n                pixelHeight_ = Exiv2::getULong(size_buf, littleEndian) & 0x3fff;\n            } else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8L) && !has_canvas_data) {\n                enforce(size >= 5, Exiv2::kerCorruptedMetadata);\n\n                has_canvas_data = true;\n                byte size_buf_w[2];\n                byte size_buf_h[3];\n\n                io_->readOrThrow(payload.pData_, payload.size_, Exiv2::kerCorruptedMetadata);\n\n                // Fetch width\n                memcpy(&size_buf_w, &payload.pData_[1], 2);\n                size_buf_w[1] &= 0x3F;\n                pixelWidth_ = Exiv2::getUShort(size_buf_w, littleEndian) + 1;\n\n                // Fetch height\n                memcpy(&size_buf_h, &payload.pData_[2], 3);\n                size_buf_h[0] = ((size_buf_h[0] >> 6) & 0x3) | ((size_buf_h[1]  & 0x3F) << 0x2);\n                size_buf_h[1] = ((size_buf_h[1] >> 6) & 0x3) | ((size_buf_h[2] & 0xF) << 0x2);\n                pixelHeight_ = Exiv2::getUShort(size_buf_h, littleEndian) + 1;\n            } else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_ANMF) && !has_canvas_data) {\n                enforce(size >= 12, Exiv2::kerCorruptedMetadata);\n\n                has_canvas_data = true;\n                byte size_buf[WEBP_TAG_SIZE];\n\n                io_->readOrThrow(payload.pData_, payload.size_, Exiv2::kerCorruptedMetadata);\n\n                // Fetch width\n                memcpy(&size_buf, &payload.pData_[6], 3);\n                size_buf[3] = 0;\n                pixelWidth_ = Exiv2::getULong(size_buf, littleEndian) + 1;\n\n                // Fetch height\n                memcpy(&size_buf, &payload.pData_[9], 3);\n                size_buf[3] = 0;\n                pixelHeight_ = Exiv2::getULong(size_buf, littleEndian) + 1;\n            } else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_ICCP)) {\n                io_->readOrThrow(payload.pData_, payload.size_, Exiv2::kerCorruptedMetadata);\n                this->setIccProfile(payload);\n            } else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_EXIF)) {\n                io_->readOrThrow(payload.pData_, payload.size_, Exiv2::kerCorruptedMetadata);\n\n                // 4 meaningful bytes + 2 padding bytes\n                byte  exifLongHeader[]   = { 0xFF, 0x01, 0xFF, 0xE1, 0x00, 0x00 };\n                byte  exifShortHeader[]  = { 0x45, 0x78, 0x69, 0x66, 0x00, 0x00 };\n                byte  exifTiffLEHeader[] = { 0x49, 0x49, 0x2A };       // \"MM*\"\n                byte  exifTiffBEHeader[] = { 0x4D, 0x4D, 0x00, 0x2A }; // \"II\\0*\"\n                byte* rawExifData = nullptr;\n                long  offset = 0;\n                bool  s_header = false;\n                bool  le_header = false;\n                bool  be_header = false;\n                long  pos = getHeaderOffset (payload.pData_, payload.size_, (byte*)&exifLongHeader, 4);\n\n                if (pos == -1) {\n                    pos = getHeaderOffset (payload.pData_, payload.size_, (byte*)&exifLongHeader, 6);\n                    if (pos != -1) {\n                        s_header = true;\n                    }\n                }\n                if (pos == -1) {\n                    pos = getHeaderOffset (payload.pData_, payload.size_, (byte*)&exifTiffLEHeader, 3);\n                    if (pos != -1) {\n                        le_header = true;\n                    }\n                }\n                if (pos == -1) {\n                    pos = getHeaderOffset (payload.pData_, payload.size_, (byte*)&exifTiffBEHeader, 4);\n                    if (pos != -1) {\n                        be_header = true;\n                    }\n                }\n\n                if (s_header) {\n                    offset += 6;\n                }\n                if (be_header || le_header) {\n                    offset += 12;\n                }\n\n                const long sizePayload = payload.size_ + offset;\n                rawExifData = (byte*)malloc(sizePayload);\n\n                byte  sizeBuff[2];\n                if (s_header) {\n                    us2Data(sizeBuff, (uint16_t) (sizePayload - 6), bigEndian);\n                    memcpy(rawExifData, (char*)&exifLongHeader, 4);\n                    memcpy(rawExifData + 4, (char*)&sizeBuff, 2);\n                }\n\n                if (be_header || le_header) {\n                    us2Data(sizeBuff, (uint16_t) (sizePayload - 6), bigEndian);\n                    memcpy(rawExifData, (char*)&exifLongHeader, 4);\n                    memcpy(rawExifData + 4, (char*)&sizeBuff, 2);\n                    memcpy(rawExifData + 6, (char*)&exifShortHeader, 6);\n                }\n\n                memcpy(rawExifData + offset, payload.pData_, payload.size_);\n\n#ifdef DEBUG\n                std::cout << \"Display Hex Dump [size:\" << (unsigned long)sizePayload << \"]\" << std::endl;\n                std::cout << Internal::binaryToHex(rawExifData, sizePayload);\n#endif\n\n                if (pos != -1) {\n                    XmpData  xmpData;\n                    ByteOrder bo = ExifParser::decode(exifData_,\n                                                      payload.pData_ + pos,\n                                                      payload.size_ - pos);\n                    setByteOrder(bo);\n                }\n                else\n                {\n#ifndef SUPPRESS_WARNINGS\n                    EXV_WARNING << \"Failed to decode Exif metadata.\" << std::endl;\n#endif\n                    exifData_.clear();\n                }\n\n                if (rawExifData)\n                    free(rawExifData);\n            } else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_XMP)) {\n                io_->readOrThrow(payload.pData_, payload.size_, Exiv2::kerCorruptedMetadata);\n                xmpPacket_.assign(reinterpret_cast<char*>(payload.pData_), payload.size_);\n                if (xmpPacket_.size() > 0 && XmpParser::decode(xmpData_, xmpPacket_)) {\n#ifndef SUPPRESS_WARNINGS\n                    EXV_WARNING << \"Failed to decode XMP metadata.\" << std::endl;\n#endif\n                } else {\n#ifdef DEBUG\n                    std::cout << \"Display Hex Dump [size:\" << (unsigned long)payload.size_ << \"]\" << std::endl;\n                    std::cout << Internal::binaryToHex(payload.pData_, payload.size_);\n#endif\n                }\n            } else {\n                io_->seek(size, BasicIo::cur);\n            }\n\n            if ( io_->tell() % 2 ) io_->seek(+1, BasicIo::cur);\n        }\n    }",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146015,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "my_regcomp(preg, pattern, cflags, charset)\nmy_regex_t *preg;\nconst char *pattern;\nint cflags;\nCHARSET_INFO *charset;\n{\n\tstruct parse pa;\n\tregister struct re_guts *g;\n\tregister struct parse *p = &pa;\n\tregister int i;\n\tregister size_t len;\n#ifdef REDEBUG\n#\tdefine\tGOODFLAGS(f)\t(f)\n#else\n#\tdefine\tGOODFLAGS(f)\t((f)&~REG_DUMP)\n#endif\n\n\tmy_regex_init(charset, NULL);\t/* Init cclass if neaded */\n\tpreg->charset=charset;\n\tcflags = GOODFLAGS(cflags);\n\tif ((cflags&REG_EXTENDED) && (cflags&REG_NOSPEC))\n\t\treturn(REG_INVARG);\n\n\tif (cflags&REG_PEND) {\n\t\tif (preg->re_endp < pattern)\n\t\t\treturn(REG_INVARG);\n\t\tlen = preg->re_endp - pattern;\n\t} else\n\t\tlen = strlen((char *)pattern);\n\n\t/* do the mallocs early so failure handling is easy */\n\tg = (struct re_guts *)malloc(sizeof(struct re_guts) +\n\t\t\t\t\t\t\t(NC-1)*sizeof(cat_t));\n\tif (g == NULL)\n\t\treturn(REG_ESPACE);\n\tp->ssize = (long) (len/(size_t)2*(size_t)3 + (size_t)1); /* ugh */\n\tp->strip = (sop *)malloc(p->ssize * sizeof(sop));\n\tp->slen = 0;\n\tif (p->strip == NULL) {\n\t\tfree((char *)g);\n\t\treturn(REG_ESPACE);\n\t}\n\n\t/* set things up */\n\tp->g = g;\n\tp->next = (char *)pattern;\t/* convenience; we do not modify it */\n\tp->end = p->next + len;\n\tp->error = 0;\n\tp->ncsalloc = 0;\n\tp->charset = preg->charset;\n\tfor (i = 0; i < NPAREN; i++) {\n\t\tp->pbegin[i] = 0;\n\t\tp->pend[i] = 0;\n\t}\n\tg->csetsize = NC;\n\tg->sets = NULL;\n\tg->setbits = NULL;\n\tg->ncsets = 0;\n\tg->cflags = cflags;\n\tg->iflags = 0;\n\tg->nbol = 0;\n\tg->neol = 0;\n\tg->must = NULL;\n\tg->mlen = 0;\n\tg->nsub = 0;\n\tg->ncategories = 1;\t/* category 0 is \"everything else\" */\n\tg->categories = &g->catspace[-(CHAR_MIN)];\n\t(void) memset((char *)g->catspace, 0, NC*sizeof(cat_t));\n\tg->backrefs = 0;\n\n\t/* do it */\n\tEMIT(OEND, 0);\n\tg->firststate = THERE();\n\tif (cflags&REG_EXTENDED)\n\t\tp_ere(p, OUT);\n\telse if (cflags&REG_NOSPEC)\n\t\tp_str(p);\n\telse\n\t\tp_bre(p, OUT, OUT);\n\tEMIT(OEND, 0);\n\tg->laststate = THERE();\n\n\t/* tidy up loose ends and fill things in */\n\tcategorize(p, g);\n\tstripsnug(p, g);\n\tfindmust(p, g);\n\tg->nplus = pluscount(p, g);\n\tg->magic = MAGIC2;\n\tpreg->re_nsub = g->nsub;\n\tpreg->re_g = g;\n\tpreg->re_magic = MAGIC1;\n#ifndef REDEBUG\n\t/* not debugging, so can't rely on the assert() in regexec() */\n\tif (g->iflags&BAD)\n\t\tSETERROR(REG_ASSERT);\n#endif\n\n\t/* win or lose, we're done */\n\tif (p->error != 0)\t/* lose */\n\t\tmy_regfree(preg);\n\treturn(p->error);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146036,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "my_regcomp(preg, pattern, cflags, charset)\nmy_regex_t *preg;\nconst char *pattern;\nint cflags;\nCHARSET_INFO *charset;\n{\n\tstruct parse pa;\n\tregister struct re_guts *g;\n\tregister struct parse *p = &pa;\n\tregister int i;\n\tregister size_t len;\n#ifdef REDEBUG\n#\tdefine\tGOODFLAGS(f)\t(f)\n#else\n#\tdefine\tGOODFLAGS(f)\t((f)&~REG_DUMP)\n#endif\n\n\tmy_regex_init(charset, NULL);\t/* Init cclass if neaded */\n\tpreg->charset=charset;\n\tcflags = GOODFLAGS(cflags);\n\tif ((cflags&REG_EXTENDED) && (cflags&REG_NOSPEC))\n\t\treturn(REG_INVARG);\n\n\tif (cflags&REG_PEND) {\n\t\tif (preg->re_endp < pattern)\n\t\t\treturn(REG_INVARG);\n\t\tlen = preg->re_endp - pattern;\n\t} else\n\t\tlen = strlen((char *)pattern);\n\n\t/*\n\t Find the maximum len we can safely process\n\t without a rollover and a mis-malloc.\n\t p->ssize is a sopno is a long (32+ bit signed);\n\t size_t is 16+ bit unsigned.\n\t*/\n\t{\n\t  size_t new_ssize = len / (size_t)2 * (size_t)3 + (size_t)1; /* ugh */\n\t  if ((new_ssize < len) ||\t/* size_t rolled over */\n\t      ((SIZE_T_MAX / sizeof(sop)) < new_ssize) ||\t/* malloc arg */\n\t      (new_ssize > LONG_MAX))\t/* won't fit in ssize */\n\t\treturn(REG_ESPACE);\t/* MY_REG_ESPACE or MY_REG_INVARG */\n\t  p->ssize = new_ssize;\n\t}\n\n\t/* do the mallocs early so failure handling is easy */\n\tg = (struct re_guts *)malloc(sizeof(struct re_guts) +\n\t\t\t\t\t\t\t(NC-1)*sizeof(cat_t));\n\tif (g == NULL)\n\t\treturn(REG_ESPACE);\n\tp->strip = (sop *)malloc(p->ssize * sizeof(sop));\n\tp->slen = 0;\n\tif (p->strip == NULL) {\n\t\tfree((char *)g);\n\t\treturn(REG_ESPACE);\n\t}\n\n\t/* set things up */\n\tp->g = g;\n\tp->next = (char *)pattern;\t/* convenience; we do not modify it */\n\tp->end = p->next + len;\n\tp->error = 0;\n\tp->ncsalloc = 0;\n\tp->charset = preg->charset;\n\tfor (i = 0; i < NPAREN; i++) {\n\t\tp->pbegin[i] = 0;\n\t\tp->pend[i] = 0;\n\t}\n\tg->csetsize = NC;\n\tg->sets = NULL;\n\tg->setbits = NULL;\n\tg->ncsets = 0;\n\tg->cflags = cflags;\n\tg->iflags = 0;\n\tg->nbol = 0;\n\tg->neol = 0;\n\tg->must = NULL;\n\tg->mlen = 0;\n\tg->nsub = 0;\n\tg->ncategories = 1;\t/* category 0 is \"everything else\" */\n\tg->categories = &g->catspace[-(CHAR_MIN)];\n\t(void) memset((char *)g->catspace, 0, NC*sizeof(cat_t));\n\tg->backrefs = 0;\n\n\t/* do it */\n\tEMIT(OEND, 0);\n\tg->firststate = THERE();\n\tif (cflags&REG_EXTENDED)\n\t\tp_ere(p, OUT);\n\telse if (cflags&REG_NOSPEC)\n\t\tp_str(p);\n\telse\n\t\tp_bre(p, OUT, OUT);\n\tEMIT(OEND, 0);\n\tg->laststate = THERE();\n\n\t/* tidy up loose ends and fill things in */\n\tcategorize(p, g);\n\tstripsnug(p, g);\n\tfindmust(p, g);\n\tg->nplus = pluscount(p, g);\n\tg->magic = MAGIC2;\n\tpreg->re_nsub = g->nsub;\n\tpreg->re_g = g;\n\tpreg->re_magic = MAGIC1;\n#ifndef REDEBUG\n\t/* not debugging, so can't rely on the assert() in regexec() */\n\tif (g->iflags&BAD)\n\t\tSETERROR(REG_ASSERT);\n#endif\n\n\t/* win or lose, we're done */\n\tif (p->error != 0)\t/* lose */\n\t\tmy_regfree(preg);\n\treturn(p->error);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146037,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "vhost_user_get_inflight_fd(struct virtio_net **pdev,\n\t\t\t   VhostUserMsg *msg,\n\t\t\t   int main_fd __rte_unused)\n{\n\tstruct rte_vhost_inflight_info_packed *inflight_packed;\n\tuint64_t pervq_inflight_size, mmap_size;\n\tuint16_t num_queues, queue_size;\n\tstruct virtio_net *dev = *pdev;\n\tint fd, i, j;\n\tvoid *addr;\n\n\tif (msg->size != sizeof(msg->payload.inflight)) {\n\t\tVHOST_LOG_CONFIG(ERR,\n\t\t\t\"invalid get_inflight_fd message size is %d\\n\",\n\t\t\tmsg->size);\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\t}\n\n\tif (dev->inflight_info == NULL) {\n\t\tdev->inflight_info = calloc(1,\n\t\t\t\t\t    sizeof(struct inflight_mem_info));\n\t\tif (!dev->inflight_info) {\n\t\t\tVHOST_LOG_CONFIG(ERR,\n\t\t\t\t\"failed to alloc dev inflight area\\n\");\n\t\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\t\t}\n\t}\n\n\tnum_queues = msg->payload.inflight.num_queues;\n\tqueue_size = msg->payload.inflight.queue_size;\n\n\tVHOST_LOG_CONFIG(INFO, \"get_inflight_fd num_queues: %u\\n\",\n\t\tmsg->payload.inflight.num_queues);\n\tVHOST_LOG_CONFIG(INFO, \"get_inflight_fd queue_size: %u\\n\",\n\t\tmsg->payload.inflight.queue_size);\n\n\tif (vq_is_packed(dev))\n\t\tpervq_inflight_size = get_pervq_shm_size_packed(queue_size);\n\telse\n\t\tpervq_inflight_size = get_pervq_shm_size_split(queue_size);\n\n\tmmap_size = num_queues * pervq_inflight_size;\n\taddr = inflight_mem_alloc(\"vhost-inflight\", mmap_size, &fd);\n\tif (!addr) {\n\t\tVHOST_LOG_CONFIG(ERR,\n\t\t\t\"failed to alloc vhost inflight area\\n\");\n\t\t\tmsg->payload.inflight.mmap_size = 0;\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\t}\n\tmemset(addr, 0, mmap_size);\n\n\tif (dev->inflight_info->addr) {\n\t\tmunmap(dev->inflight_info->addr, dev->inflight_info->size);\n\t\tdev->inflight_info->addr = NULL;\n\t}\n\n\tdev->inflight_info->addr = addr;\n\tdev->inflight_info->size = msg->payload.inflight.mmap_size = mmap_size;\n\tdev->inflight_info->fd = msg->fds[0] = fd;\n\tmsg->payload.inflight.mmap_offset = 0;\n\tmsg->fd_num = 1;\n\n\tif (vq_is_packed(dev)) {\n\t\tfor (i = 0; i < num_queues; i++) {\n\t\t\tinflight_packed =\n\t\t\t\t(struct rte_vhost_inflight_info_packed *)addr;\n\t\t\tinflight_packed->used_wrap_counter = 1;\n\t\t\tinflight_packed->old_used_wrap_counter = 1;\n\t\t\tfor (j = 0; j < queue_size; j++)\n\t\t\t\tinflight_packed->desc[j].next = j + 1;\n\t\t\taddr = (void *)((char *)addr + pervq_inflight_size);\n\t\t}\n\t}\n\n\tVHOST_LOG_CONFIG(INFO,\n\t\t\"send inflight mmap_size: %\"PRIu64\"\\n\",\n\t\tmsg->payload.inflight.mmap_size);\n\tVHOST_LOG_CONFIG(INFO,\n\t\t\"send inflight mmap_offset: %\"PRIu64\"\\n\",\n\t\tmsg->payload.inflight.mmap_offset);\n\tVHOST_LOG_CONFIG(INFO,\n\t\t\"send inflight fd: %d\\n\", msg->fds[0]);\n\n\treturn RTE_VHOST_MSG_RESULT_REPLY;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146052,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "vhost_user_get_inflight_fd(struct virtio_net **pdev,\n\t\t\t   VhostUserMsg *msg,\n\t\t\t   int main_fd __rte_unused)\n{\n\tstruct rte_vhost_inflight_info_packed *inflight_packed;\n\tuint64_t pervq_inflight_size, mmap_size;\n\tuint16_t num_queues, queue_size;\n\tstruct virtio_net *dev = *pdev;\n\tint fd, i, j;\n\tvoid *addr;\n\n\tif (msg->size != sizeof(msg->payload.inflight)) {\n\t\tVHOST_LOG_CONFIG(ERR,\n\t\t\t\"invalid get_inflight_fd message size is %d\\n\",\n\t\t\tmsg->size);\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\t}\n\n\tif (dev->inflight_info == NULL) {\n\t\tdev->inflight_info = calloc(1,\n\t\t\t\t\t    sizeof(struct inflight_mem_info));\n\t\tif (!dev->inflight_info) {\n\t\t\tVHOST_LOG_CONFIG(ERR,\n\t\t\t\t\"failed to alloc dev inflight area\\n\");\n\t\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\t\t}\n\t\tdev->inflight_info->fd = -1;\n\t}\n\n\tnum_queues = msg->payload.inflight.num_queues;\n\tqueue_size = msg->payload.inflight.queue_size;\n\n\tVHOST_LOG_CONFIG(INFO, \"get_inflight_fd num_queues: %u\\n\",\n\t\tmsg->payload.inflight.num_queues);\n\tVHOST_LOG_CONFIG(INFO, \"get_inflight_fd queue_size: %u\\n\",\n\t\tmsg->payload.inflight.queue_size);\n\n\tif (vq_is_packed(dev))\n\t\tpervq_inflight_size = get_pervq_shm_size_packed(queue_size);\n\telse\n\t\tpervq_inflight_size = get_pervq_shm_size_split(queue_size);\n\n\tmmap_size = num_queues * pervq_inflight_size;\n\taddr = inflight_mem_alloc(\"vhost-inflight\", mmap_size, &fd);\n\tif (!addr) {\n\t\tVHOST_LOG_CONFIG(ERR,\n\t\t\t\"failed to alloc vhost inflight area\\n\");\n\t\t\tmsg->payload.inflight.mmap_size = 0;\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\t}\n\tmemset(addr, 0, mmap_size);\n\n\tif (dev->inflight_info->addr) {\n\t\tmunmap(dev->inflight_info->addr, dev->inflight_info->size);\n\t\tdev->inflight_info->addr = NULL;\n\t}\n\n\tif (dev->inflight_info->fd >= 0) {\n\t\tclose(dev->inflight_info->fd);\n\t\tdev->inflight_info->fd = -1;\n\t}\n\n\tdev->inflight_info->addr = addr;\n\tdev->inflight_info->size = msg->payload.inflight.mmap_size = mmap_size;\n\tdev->inflight_info->fd = msg->fds[0] = fd;\n\tmsg->payload.inflight.mmap_offset = 0;\n\tmsg->fd_num = 1;\n\n\tif (vq_is_packed(dev)) {\n\t\tfor (i = 0; i < num_queues; i++) {\n\t\t\tinflight_packed =\n\t\t\t\t(struct rte_vhost_inflight_info_packed *)addr;\n\t\t\tinflight_packed->used_wrap_counter = 1;\n\t\t\tinflight_packed->old_used_wrap_counter = 1;\n\t\t\tfor (j = 0; j < queue_size; j++)\n\t\t\t\tinflight_packed->desc[j].next = j + 1;\n\t\t\taddr = (void *)((char *)addr + pervq_inflight_size);\n\t\t}\n\t}\n\n\tVHOST_LOG_CONFIG(INFO,\n\t\t\"send inflight mmap_size: %\"PRIu64\"\\n\",\n\t\tmsg->payload.inflight.mmap_size);\n\tVHOST_LOG_CONFIG(INFO,\n\t\t\"send inflight mmap_offset: %\"PRIu64\"\\n\",\n\t\tmsg->payload.inflight.mmap_offset);\n\tVHOST_LOG_CONFIG(INFO,\n\t\t\"send inflight fd: %d\\n\", msg->fds[0]);\n\n\treturn RTE_VHOST_MSG_RESULT_REPLY;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146053,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static MagickBooleanType WritePDFImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n#define CFormat  \"/Filter [ /%s ]\\n\"\n#define ObjectsPerImage  14\n#define ThrowPDFException(exception,message) \\\n{ \\\n  if (xref != (MagickOffsetType *) NULL) \\\n    xref=(MagickOffsetType *) RelinquishMagickMemory(xref); \\\n  ThrowWriterException((exception),(message)); \\\n}\n\nDisableMSCWarning(4310)\n  static const char\n    XMPProfile[]=\n    {\n      \"<?xpacket begin=\\\"%s\\\" id=\\\"W5M0MpCehiHzreSzNTczkc9d\\\"?>\\n\"\n      \"<x:xmpmeta xmlns:x=\\\"adobe:ns:meta/\\\" x:xmptk=\\\"Adobe XMP Core 4.0-c316 44.253921, Sun Oct 01 2006 17:08:23\\\">\\n\"\n      \"   <rdf:RDF xmlns:rdf=\\\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\\\">\\n\"\n      \"      <rdf:Description rdf:about=\\\"\\\"\\n\"\n      \"            xmlns:xap=\\\"http://ns.adobe.com/xap/1.0/\\\">\\n\"\n      \"         <xap:ModifyDate>%s</xap:ModifyDate>\\n\"\n      \"         <xap:CreateDate>%s</xap:CreateDate>\\n\"\n      \"         <xap:MetadataDate>%s</xap:MetadataDate>\\n\"\n      \"         <xap:CreatorTool>%s</xap:CreatorTool>\\n\"\n      \"      </rdf:Description>\\n\"\n      \"      <rdf:Description rdf:about=\\\"\\\"\\n\"\n      \"            xmlns:dc=\\\"http://purl.org/dc/elements/1.1/\\\">\\n\"\n      \"         <dc:format>application/pdf</dc:format>\\n\"\n      \"         <dc:title>\\n\"\n      \"           <rdf:Alt>\\n\"\n      \"              <rdf:li xml:lang=\\\"x-default\\\">%s</rdf:li>\\n\"\n      \"           </rdf:Alt>\\n\"\n      \"         </dc:title>\\n\"\n      \"      </rdf:Description>\\n\"\n      \"      <rdf:Description rdf:about=\\\"\\\"\\n\"\n      \"            xmlns:xapMM=\\\"http://ns.adobe.com/xap/1.0/mm/\\\">\\n\"\n      \"         <xapMM:DocumentID>uuid:6ec119d7-7982-4f56-808d-dfe64f5b35cf</xapMM:DocumentID>\\n\"\n      \"         <xapMM:InstanceID>uuid:a79b99b4-6235-447f-9f6c-ec18ef7555cb</xapMM:InstanceID>\\n\"\n      \"      </rdf:Description>\\n\"\n      \"      <rdf:Description rdf:about=\\\"\\\"\\n\"\n      \"            xmlns:pdf=\\\"http://ns.adobe.com/pdf/1.3/\\\">\\n\"\n      \"         <pdf:Producer>%s</pdf:Producer>\\n\"\n      \"      </rdf:Description>\\n\"\n      \"      <rdf:Description rdf:about=\\\"\\\"\\n\"\n      \"            xmlns:pdfaid=\\\"http://www.aiim.org/pdfa/ns/id/\\\">\\n\"\n      \"         <pdfaid:part>3</pdfaid:part>\\n\"\n      \"         <pdfaid:conformance>B</pdfaid:conformance>\\n\"\n      \"      </rdf:Description>\\n\"\n      \"   </rdf:RDF>\\n\"\n      \"</x:xmpmeta>\\n\"\n      \"<?xpacket end=\\\"w\\\"?>\\n\"\n    },\n    XMPProfileMagick[4]= { (char) 0xef, (char) 0xbb, (char) 0xbf, (char) 0x00 };\nRestoreMSCWarning\n\n  char\n    basename[MagickPathExtent],\n    buffer[MagickPathExtent],\n    *escape,\n    date[MagickPathExtent],\n    **labels,\n    page_geometry[MagickPathExtent],\n    *url;\n\n  CompressionType\n    compression;\n\n  const char\n    *device,\n    *option,\n    *value;\n\n  const StringInfo\n    *profile;\n\n  double\n    pointsize;\n\n  GeometryInfo\n    geometry_info;\n\n  Image\n    *next,\n    *tile_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset,\n    scene,\n    *xref;\n\n  MagickSizeType\n    number_pixels;\n\n  MagickStatusType\n    flags;\n\n  PointInfo\n    delta,\n    resolution,\n    scale;\n\n  RectangleInfo\n    geometry,\n    media_info,\n    page_info;\n\n  register const Quantum\n    *p;\n\n  register unsigned char\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  size_t\n    channels,\n    imageListLength,\n    info_id,\n    length,\n    object,\n    pages_id,\n    root_id,\n    text_size,\n    version;\n\n  ssize_t\n    count,\n    page_count,\n    y;\n\n  struct tm\n    utc_time;\n\n  time_t\n    seconds;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  /*\n    Allocate X ref memory.\n  */\n  xref=(MagickOffsetType *) AcquireQuantumMemory(2048UL,sizeof(*xref));\n  if (xref == (MagickOffsetType *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  (void) memset(xref,0,2048UL*sizeof(*xref));\n  /*\n    Write Info object.\n  */\n  object=0;\n  version=3;\n  if (image_info->compression == JPEG2000Compression)\n    version=(size_t) MagickMax(version,5);\n  for (next=image; next != (Image *) NULL; next=GetNextImageInList(next))\n    if (next->alpha_trait != UndefinedPixelTrait)\n      version=(size_t) MagickMax(version,4);\n  if (LocaleCompare(image_info->magick,\"PDFA\") == 0)\n    version=(size_t) MagickMax(version,6);\n  profile=GetImageProfile(image,\"icc\");\n  if (profile != (StringInfo *) NULL)\n    version=(size_t) MagickMax(version,7);\n  (void) FormatLocaleString(buffer,MagickPathExtent,\"%%PDF-1.%.20g \\n\",(double)\n    version);\n  (void) WriteBlobString(image,buffer);\n  if (LocaleCompare(image_info->magick,\"PDFA\") == 0)\n    {\n      (void) WriteBlobByte(image,'%');\n      (void) WriteBlobByte(image,0xe2);\n      (void) WriteBlobByte(image,0xe3);\n      (void) WriteBlobByte(image,0xcf);\n      (void) WriteBlobByte(image,0xd3);\n      (void) WriteBlobByte(image,'\\n');\n    }\n  /*\n    Write Catalog object.\n  */\n  xref[object++]=TellBlob(image);\n  root_id=object;\n  (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n    object);\n  (void) WriteBlobString(image,buffer);\n  (void) WriteBlobString(image,\"<<\\n\");\n  if (LocaleCompare(image_info->magick,\"PDFA\") != 0)\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/Pages %.20g 0 R\\n\",\n      (double) object+1);\n  else\n    {\n      (void) FormatLocaleString(buffer,MagickPathExtent,\"/Metadata %.20g 0 R\\n\",\n        (double) object+1);\n      (void) WriteBlobString(image,buffer);\n      (void) FormatLocaleString(buffer,MagickPathExtent,\"/Pages %.20g 0 R\\n\",\n        (double) object+2);\n    }\n  (void) WriteBlobString(image,buffer);\n  (void) WriteBlobString(image,\"/Type /Catalog\");\n  option=GetImageOption(image_info,\"pdf:page-direction\");\n  if ((option != (const char *) NULL) &&\n      (LocaleCompare(option,\"right-to-left\") == 0))\n    (void) WriteBlobString(image,\"/ViewerPreferences<</PageDirection/R2L>>\\n\");\n  (void) WriteBlobString(image,\"\\n\");\n  (void) WriteBlobString(image,\">>\\n\");\n  (void) WriteBlobString(image,\"endobj\\n\");\n  GetPathComponent(image->filename,BasePath,basename);\n  if (LocaleCompare(image_info->magick,\"PDFA\") == 0)\n    {\n      char\n        create_date[MagickPathExtent],\n        modify_date[MagickPathExtent],\n        timestamp[MagickPathExtent],\n        xmp_profile[MagickPathExtent];\n\n      /*\n        Write XMP object.\n      */\n      xref[object++]=TellBlob(image);\n      (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n        object);\n      (void) WriteBlobString(image,buffer);\n      (void) WriteBlobString(image,\"<<\\n\");\n      (void) WriteBlobString(image,\"/Subtype /XML\\n\");\n      *modify_date='\\0';\n      value=GetImageProperty(image,\"date:modify\",exception);\n      if (value != (const char *) NULL)\n        (void) CopyMagickString(modify_date,value,MagickPathExtent);\n      *create_date='\\0';\n      value=GetImageProperty(image,\"date:create\",exception);\n      if (value != (const char *) NULL)\n        (void) CopyMagickString(create_date,value,MagickPathExtent);\n      (void) FormatMagickTime(GetMagickTime(),MagickPathExtent,timestamp);\n      url=(char *) MagickAuthoritativeURL;\n      escape=EscapeParenthesis(basename);\n      i=FormatLocaleString(xmp_profile,MagickPathExtent,XMPProfile,\n        XMPProfileMagick,modify_date,create_date,timestamp,url,escape,url);\n      escape=DestroyString(escape);\n      (void) FormatLocaleString(buffer,MagickPathExtent,\"/Length %.20g\\n\",\n        (double) i);\n      (void) WriteBlobString(image,buffer);\n      (void) WriteBlobString(image,\"/Type /Metadata\\n\");\n      (void) WriteBlobString(image,\">>\\nstream\\n\");\n      (void) WriteBlobString(image,xmp_profile);\n      (void) WriteBlobString(image,\"\\nendstream\\n\");\n      (void) WriteBlobString(image,\"endobj\\n\");\n    }\n  /*\n    Write Pages object.\n  */\n  xref[object++]=TellBlob(image);\n  pages_id=object;\n  (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n    object);\n  (void) WriteBlobString(image,buffer);\n  (void) WriteBlobString(image,\"<<\\n\");\n  (void) WriteBlobString(image,\"/Type /Pages\\n\");\n  (void) FormatLocaleString(buffer,MagickPathExtent,\"/Kids [ %.20g 0 R \",\n    (double) object+1);\n  (void) WriteBlobString(image,buffer);\n  count=(ssize_t) (pages_id+ObjectsPerImage+1);\n  page_count=1;\n  if (image_info->adjoin != MagickFalse)\n    {\n      Image\n        *kid_image;\n\n      /*\n        Predict page object id's.\n      */\n      kid_image=image;\n      for ( ; GetNextImageInList(kid_image) != (Image *) NULL; count+=ObjectsPerImage)\n      {\n        page_count++;\n        profile=GetImageProfile(kid_image,\"icc\");\n        if (profile != (StringInfo *) NULL)\n          count+=2;\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 R \",(double)\n          count);\n        (void) WriteBlobString(image,buffer);\n        kid_image=GetNextImageInList(kid_image);\n      }\n      xref=(MagickOffsetType *) ResizeQuantumMemory(xref,(size_t) count+2048UL,\n        sizeof(*xref));\n      if (xref == (MagickOffsetType *) NULL)\n        ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  (void) WriteBlobString(image,\"]\\n\");\n  (void) FormatLocaleString(buffer,MagickPathExtent,\"/Count %.20g\\n\",(double)\n    page_count);\n  (void) WriteBlobString(image,buffer);\n  (void) WriteBlobString(image,\">>\\n\");\n  (void) WriteBlobString(image,\"endobj\\n\");\n  scene=0;\n  imageListLength=GetImageListLength(image);\n  do\n  {\n    MagickBooleanType\n      has_icc_profile;\n\n    profile=GetImageProfile(image,\"icc\");\n    has_icc_profile=(profile != (StringInfo *) NULL) ? MagickTrue : MagickFalse;\n    compression=image->compression;\n    if (image_info->compression != UndefinedCompression)\n      compression=image_info->compression;\n    switch (compression)\n    {\n      case FaxCompression:\n      case Group4Compression:\n      {\n        if ((SetImageMonochrome(image,exception) == MagickFalse) ||\n            (image->alpha_trait != UndefinedPixelTrait))\n          compression=RLECompression;\n        break;\n      }\n#if !defined(MAGICKCORE_JPEG_DELEGATE)\n      case JPEGCompression:\n      {\n        compression=RLECompression;\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          MissingDelegateError,\"DelegateLibrarySupportNotBuiltIn\",\"`%s' (JPEG)\",\n          image->filename);\n        break;\n      }\n#endif\n#if !defined(MAGICKCORE_LIBOPENJP2_DELEGATE)\n      case JPEG2000Compression:\n      {\n        compression=RLECompression;\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          MissingDelegateError,\"DelegateLibrarySupportNotBuiltIn\",\"`%s' (JP2)\",\n          image->filename);\n        break;\n      }\n#endif\n#if !defined(MAGICKCORE_ZLIB_DELEGATE)\n      case ZipCompression:\n      {\n        compression=RLECompression;\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          MissingDelegateError,\"DelegateLibrarySupportNotBuiltIn\",\"`%s' (ZLIB)\",\n          image->filename);\n        break;\n      }\n#endif\n      case LZWCompression:\n      {\n        if (LocaleCompare(image_info->magick,\"PDFA\") == 0)\n          compression=RLECompression;  /* LZW compression is forbidden */\n        break;\n      }\n      case NoCompression:\n      {\n        if (LocaleCompare(image_info->magick,\"PDFA\") == 0)\n          compression=RLECompression; /* ASCII 85 compression is forbidden */\n        break;\n      }\n      default:\n        break;\n    }\n    if (compression == JPEG2000Compression)\n      (void) TransformImageColorspace(image,sRGBColorspace,exception);\n    /*\n      Scale relative to dots-per-inch.\n    */\n    delta.x=DefaultResolution;\n    delta.y=DefaultResolution;\n    resolution.x=image->resolution.x;\n    resolution.y=image->resolution.y;\n    if ((resolution.x == 0.0) || (resolution.y == 0.0))\n      {\n        flags=ParseGeometry(PSDensityGeometry,&geometry_info);\n        resolution.x=geometry_info.rho;\n        resolution.y=geometry_info.sigma;\n        if ((flags & SigmaValue) == 0)\n          resolution.y=resolution.x;\n      }\n    if (image_info->density != (char *) NULL)\n      {\n        flags=ParseGeometry(image_info->density,&geometry_info);\n        resolution.x=geometry_info.rho;\n        resolution.y=geometry_info.sigma;\n        if ((flags & SigmaValue) == 0)\n          resolution.y=resolution.x;\n      }\n    if (image->units == PixelsPerCentimeterResolution)\n      {\n        resolution.x=(double) ((size_t) (100.0*2.54*resolution.x+0.5)/100.0);\n        resolution.y=(double) ((size_t) (100.0*2.54*resolution.y+0.5)/100.0);\n      }\n    SetGeometry(image,&geometry);\n    (void) FormatLocaleString(page_geometry,MagickPathExtent,\"%.20gx%.20g\",\n      (double) image->columns,(double) image->rows);\n    if (image_info->page != (char *) NULL)\n      (void) CopyMagickString(page_geometry,image_info->page,MagickPathExtent);\n    else\n      if ((image->page.width != 0) && (image->page.height != 0))\n        (void) FormatLocaleString(page_geometry,MagickPathExtent,\n          \"%.20gx%.20g%+.20g%+.20g\",(double) image->page.width,(double)\n          image->page.height,(double) image->page.x,(double) image->page.y);\n      else\n        if ((image->gravity != UndefinedGravity) &&\n            (LocaleCompare(image_info->magick,\"PDF\") == 0))\n          (void) CopyMagickString(page_geometry,PSPageGeometry,\n            MagickPathExtent);\n    (void) ConcatenateMagickString(page_geometry,\">\",MagickPathExtent);\n    (void) ParseMetaGeometry(page_geometry,&geometry.x,&geometry.y,\n      &geometry.width,&geometry.height);\n    scale.x=(double) (geometry.width*delta.x)/resolution.x;\n    geometry.width=(size_t) floor(scale.x+0.5);\n    scale.y=(double) (geometry.height*delta.y)/resolution.y;\n    geometry.height=(size_t) floor(scale.y+0.5);\n    (void) ParseAbsoluteGeometry(page_geometry,&media_info);\n    (void) ParseGravityGeometry(image,page_geometry,&page_info,exception);\n    if (image->gravity != UndefinedGravity)\n      {\n        geometry.x=(-page_info.x);\n        geometry.y=(ssize_t) (media_info.height+page_info.y-image->rows);\n      }\n    pointsize=12.0;\n    if (image_info->pointsize != 0.0)\n      pointsize=image_info->pointsize;\n    text_size=0;\n    value=GetImageProperty(image,\"label\",exception);\n    if (value != (const char *) NULL)\n      text_size=(size_t) (MultilineCensus(value)*pointsize+12);\n    (void) text_size;\n    /*\n      Write Page object.\n    */\n    xref[object++]=TellBlob(image);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n      object);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\"<<\\n\");\n    (void) WriteBlobString(image,\"/Type /Page\\n\");\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/Parent %.20g 0 R\\n\",\n      (double) pages_id);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\"/Resources <<\\n\");\n    labels=(char **) NULL;\n    value=GetImageProperty(image,\"label\",exception);\n    if (value != (const char *) NULL)\n      labels=StringToList(value);\n    if (labels != (char **) NULL)\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"/Font << /F%.20g %.20g 0 R >>\\n\",(double) image->scene,(double)\n          object+4);\n        (void) WriteBlobString(image,buffer);\n      }\n    (void) FormatLocaleString(buffer,MagickPathExtent,\n      \"/XObject << /Im%.20g %.20g 0 R >>\\n\",(double) image->scene,(double)\n      object+5);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/ProcSet %.20g 0 R >>\\n\",\n      (double) object+3);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\n      \"/MediaBox [0 0 %g %g]\\n\",72.0*media_info.width/resolution.x,\n      72.0*media_info.height/resolution.y);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\n      \"/CropBox [0 0 %g %g]\\n\",72.0*media_info.width/resolution.x,\n      72.0*media_info.height/resolution.y);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/Contents %.20g 0 R\\n\",\n      (double) object+1);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/Thumb %.20g 0 R\\n\",\n      (double) object+(has_icc_profile != MagickFalse ? 10 : 8));\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\">>\\n\");\n    (void) WriteBlobString(image,\"endobj\\n\");\n    /*\n      Write Contents object.\n    */\n    xref[object++]=TellBlob(image);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n      object);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\"<<\\n\");\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/Length %.20g 0 R\\n\",\n      (double) object+1);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\">>\\n\");\n    (void) WriteBlobString(image,\"stream\\n\");\n    offset=TellBlob(image);\n    (void) WriteBlobString(image,\"q\\n\");\n    if (labels != (char **) NULL)\n      for (i=0; labels[i] != (char *) NULL; i++)\n      {\n        (void) WriteBlobString(image,\"BT\\n\");\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"/F%.20g %g Tf\\n\",\n          (double) image->scene,pointsize);\n        (void) WriteBlobString(image,buffer);\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g %.20g Td\\n\",\n          (double) geometry.x,(double) (geometry.y+geometry.height+i*pointsize+\n          12));\n        (void) WriteBlobString(image,buffer);\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"(%s) Tj\\n\",\n           labels[i]);\n        (void) WriteBlobString(image,buffer);\n        (void) WriteBlobString(image,\"ET\\n\");\n        labels[i]=DestroyString(labels[i]);\n      }\n    (void) FormatLocaleString(buffer,MagickPathExtent,\n      \"%g 0 0 %g %.20g %.20g cm\\n\",scale.x,scale.y,(double) geometry.x,\n      (double) geometry.y);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/Im%.20g Do\\n\",(double)\n      image->scene);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\"Q\\n\");\n    offset=TellBlob(image)-offset;\n    (void) WriteBlobString(image,\"\\nendstream\\n\");\n    (void) WriteBlobString(image,\"endobj\\n\");\n    /*\n      Write Length object.\n    */\n    xref[object++]=TellBlob(image);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n      object);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g\\n\",(double)\n      offset);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\"endobj\\n\");\n    /*\n      Write Procset object.\n    */\n    xref[object++]=TellBlob(image);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n      object);\n    (void) WriteBlobString(image,buffer);\n    if ((image->storage_class == DirectClass) || (image->colors > 256))\n      (void) CopyMagickString(buffer,\"[ /PDF /Text /ImageC\",MagickPathExtent);\n    else\n      if ((compression == FaxCompression) || (compression == Group4Compression))\n        (void) CopyMagickString(buffer,\"[ /PDF /Text /ImageB\",MagickPathExtent);\n      else\n        (void) CopyMagickString(buffer,\"[ /PDF /Text /ImageI\",MagickPathExtent);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\" ]\\n\");\n    (void) WriteBlobString(image,\"endobj\\n\");\n    /*\n      Write Font object.\n    */\n    xref[object++]=TellBlob(image);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n      object);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\"<<\\n\");\n    if (labels != (char **) NULL)\n      {\n        (void) WriteBlobString(image,\"/Type /Font\\n\");\n        (void) WriteBlobString(image,\"/Subtype /Type1\\n\");\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"/Name /F%.20g\\n\",\n          (double) image->scene);\n        (void) WriteBlobString(image,buffer);\n        (void) WriteBlobString(image,\"/BaseFont /Helvetica\\n\");\n        (void) WriteBlobString(image,\"/Encoding /MacRomanEncoding\\n\");\n        labels=(char **) RelinquishMagickMemory(labels);\n      }\n    (void) WriteBlobString(image,\">>\\n\");\n    (void) WriteBlobString(image,\"endobj\\n\");\n    /*\n      Write XObject object.\n    */\n    xref[object++]=TellBlob(image);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n      object);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\"<<\\n\");\n    (void) WriteBlobString(image,\"/Type /XObject\\n\");\n    (void) WriteBlobString(image,\"/Subtype /Image\\n\");\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/Name /Im%.20g\\n\",\n      (double) image->scene);\n    (void) WriteBlobString(image,buffer);\n    switch (compression)\n    {\n      case NoCompression:\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,CFormat,\n          \"ASCII85Decode\");\n        break;\n      }\n      case JPEGCompression:\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,CFormat,\"DCTDecode\");\n        if (image->colorspace != CMYKColorspace)\n          break;\n        (void) WriteBlobString(image,buffer);\n        (void) CopyMagickString(buffer,\"/Decode [1 0 1 0 1 0 1 0]\\n\",\n          MagickPathExtent);\n        break;\n      }\n      case JPEG2000Compression:\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,CFormat,\"JPXDecode\");\n        if (image->colorspace != CMYKColorspace)\n          break;\n        (void) WriteBlobString(image,buffer);\n        (void) CopyMagickString(buffer,\"/Decode [1 0 1 0 1 0 1 0]\\n\",\n          MagickPathExtent);\n        break;\n      }\n      case LZWCompression:\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,CFormat,\"LZWDecode\");\n        break;\n      }\n      case ZipCompression:\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,CFormat,\n          \"FlateDecode\");\n        break;\n      }\n      case FaxCompression:\n      case Group4Compression:\n      {\n        (void) CopyMagickString(buffer,\"/Filter [ /CCITTFaxDecode ]\\n\",\n          MagickPathExtent);\n        (void) WriteBlobString(image,buffer);\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"/DecodeParms [ << \"\n          \"/K %s /BlackIs1 false /Columns %.20g /Rows %.20g >> ]\\n\",CCITTParam,\n          (double) image->columns,(double) image->rows);\n        break;\n      }\n      default:\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,CFormat,\n          \"RunLengthDecode\");\n        break;\n      }\n    }\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/Width %.20g\\n\",(double)\n      image->columns);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/Height %.20g\\n\",(double)\n      image->rows);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/ColorSpace %.20g 0 R\\n\",\n      (double) object+2);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/BitsPerComponent %d\\n\",\n      (compression == FaxCompression) || (compression == Group4Compression) ?\n      1 : 8);\n    (void) WriteBlobString(image,buffer);\n    if (image->alpha_trait != UndefinedPixelTrait)\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"/SMask %.20g 0 R\\n\",\n          (double) object+(has_icc_profile != MagickFalse ? 9 : 7));\n        (void) WriteBlobString(image,buffer);\n      }\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/Length %.20g 0 R\\n\",\n      (double) object+1);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\">>\\n\");\n    (void) WriteBlobString(image,\"stream\\n\");\n    offset=TellBlob(image);\n    number_pixels=(MagickSizeType) image->columns*image->rows;\n    if ((4*number_pixels) != (MagickSizeType) ((size_t) (4*number_pixels)))\n      ThrowPDFException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if ((compression == FaxCompression) || (compression == Group4Compression) ||\n        ((image_info->type != TrueColorType) &&\n         (SetImageGray(image,exception) != MagickFalse)))\n      {\n        switch (compression)\n        {\n          case FaxCompression:\n          case Group4Compression:\n          {\n            if (LocaleCompare(CCITTParam,\"0\") == 0)\n              {\n                (void) HuffmanEncodeImage(image_info,image,image,exception);\n                break;\n              }\n            (void) Huffman2DEncodeImage(image_info,image,image,exception);\n            break;\n          }\n          case JPEGCompression:\n          {\n            status=InjectImageBlob(image_info,image,image,\"jpeg\",exception);\n            if (status == MagickFalse)\n              {\n                xref=(MagickOffsetType *) RelinquishMagickMemory(xref);\n                (void) CloseBlob(image);\n                return(MagickFalse);\n              }\n            break;\n          }\n          case JPEG2000Compression:\n          {\n            status=InjectImageBlob(image_info,image,image,\"jp2\",exception);\n            if (status == MagickFalse)\n              {\n                xref=(MagickOffsetType *) RelinquishMagickMemory(xref);\n                (void) CloseBlob(image);\n                return(MagickFalse);\n              }\n            break;\n          }\n          case RLECompression:\n          default:\n          {\n            MemoryInfo\n              *pixel_info;\n\n            /*\n              Allocate pixel array.\n            */\n            length=(size_t) number_pixels;\n            pixel_info=AcquireVirtualMemory(length,sizeof(*pixels));\n            if (pixel_info == (MemoryInfo *) NULL)\n              ThrowPDFException(ResourceLimitError,\"MemoryAllocationFailed\");\n            pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n            /*\n              Dump Runlength encoded pixels.\n            */\n            q=pixels;\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                *q++=ScaleQuantumToChar(ClampToQuantum(GetPixelLuma(image,p)));\n                p+=GetPixelChannels(image);\n              }\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n            if (compression == ZipCompression)\n              status=ZLIBEncodeImage(image,length,pixels,exception);\n            else\n#endif\n              if (compression == LZWCompression)\n                status=LZWEncodeImage(image,length,pixels,exception);\n              else\n                status=PackbitsEncodeImage(image,length,pixels,exception);\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            if (status == MagickFalse)\n              {\n                xref=(MagickOffsetType *) RelinquishMagickMemory(xref);\n                (void) CloseBlob(image);\n                return(MagickFalse);\n              }\n            break;\n          }\n          case NoCompression:\n          {\n            /*\n              Dump uncompressed PseudoColor packets.\n            */\n            Ascii85Initialize(image);\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                Ascii85Encode(image,ScaleQuantumToChar(ClampToQuantum(\n                  GetPixelLuma(image,p))));\n                p+=GetPixelChannels(image);\n              }\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            Ascii85Flush(image);\n            break;\n          }\n        }\n      }\n    else\n      if ((image->storage_class == DirectClass) || (image->colors > 256) ||\n          (compression == JPEGCompression) ||\n          (compression == JPEG2000Compression))\n        switch (compression)\n        {\n          case JPEGCompression:\n          {\n            status=InjectImageBlob(image_info,image,image,\"jpeg\",exception);\n            if (status == MagickFalse)\n              {\n                xref=(MagickOffsetType *) RelinquishMagickMemory(xref);\n                (void) CloseBlob(image);\n                return(MagickFalse);\n              }\n            break;\n          }\n          case JPEG2000Compression:\n          {\n            status=InjectImageBlob(image_info,image,image,\"jp2\",exception);\n            if (status == MagickFalse)\n              {\n                xref=(MagickOffsetType *) RelinquishMagickMemory(xref);\n                (void) CloseBlob(image);\n                return(MagickFalse);\n              }\n            break;\n          }\n          case RLECompression:\n          default:\n          {\n            MemoryInfo\n              *pixel_info;\n\n            /*\n              Allocate pixel array.\n            */\n            length=(size_t) number_pixels;\n            length*=image->colorspace == CMYKColorspace ? 4UL : 3UL;\n            pixel_info=AcquireVirtualMemory(length,sizeof(*pixels));\n            if (pixel_info == (MemoryInfo *) NULL)\n              ThrowPDFException(ResourceLimitError,\"MemoryAllocationFailed\");\n            pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n            /*\n              Dump runoffset encoded pixels.\n            */\n            q=pixels;\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                *q++=ScaleQuantumToChar(GetPixelRed(image,p));\n                *q++=ScaleQuantumToChar(GetPixelGreen(image,p));\n                *q++=ScaleQuantumToChar(GetPixelBlue(image,p));\n                if (image->colorspace == CMYKColorspace)\n                  *q++=ScaleQuantumToChar(GetPixelBlack(image,p));\n                p+=GetPixelChannels(image);\n              }\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n            if (compression == ZipCompression)\n              status=ZLIBEncodeImage(image,length,pixels,exception);\n            else\n#endif\n              if (compression == LZWCompression)\n                status=LZWEncodeImage(image,length,pixels,exception);\n              else\n                status=PackbitsEncodeImage(image,length,pixels,exception);\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            if (status == MagickFalse)\n              {\n                xref=(MagickOffsetType *) RelinquishMagickMemory(xref);\n                (void) CloseBlob(image);\n                return(MagickFalse);\n              }\n            break;\n          }\n          case NoCompression:\n          {\n            /*\n              Dump uncompressed DirectColor packets.\n            */\n            Ascii85Initialize(image);\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                Ascii85Encode(image,ScaleQuantumToChar(GetPixelRed(image,p)));\n                Ascii85Encode(image,ScaleQuantumToChar(GetPixelGreen(image,p)));\n                Ascii85Encode(image,ScaleQuantumToChar(GetPixelBlue(image,p)));\n                if (image->colorspace == CMYKColorspace)\n                  Ascii85Encode(image,ScaleQuantumToChar(\n                    GetPixelBlack(image,p)));\n                p+=GetPixelChannels(image);\n              }\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            Ascii85Flush(image);\n            break;\n          }\n        }\n      else\n        {\n          /*\n            Dump number of colors and colormap.\n          */\n          switch (compression)\n          {\n            case RLECompression:\n            default:\n            {\n              MemoryInfo\n                *pixel_info;\n\n              /*\n                Allocate pixel array.\n              */\n              length=(size_t) number_pixels;\n              pixel_info=AcquireVirtualMemory(length,sizeof(*pixels));\n              if (pixel_info == (MemoryInfo *) NULL)\n                ThrowPDFException(ResourceLimitError,\"MemoryAllocationFailed\");\n              pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n              /*\n                Dump Runlength encoded pixels.\n              */\n              q=pixels;\n              for (y=0; y < (ssize_t) image->rows; y++)\n              {\n                p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n                if (p == (const Quantum *) NULL)\n                  break;\n                for (x=0; x < (ssize_t) image->columns; x++)\n                {\n                  *q++=(unsigned char) GetPixelIndex(image,p);\n                  p+=GetPixelChannels(image);\n                }\n                if (image->previous == (Image *) NULL)\n                  {\n                    status=SetImageProgress(image,SaveImageTag,\n                      (MagickOffsetType) y,image->rows);\n                    if (status == MagickFalse)\n                      break;\n                  }\n              }\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n              if (compression == ZipCompression)\n                status=ZLIBEncodeImage(image,length,pixels,exception);\n              else\n#endif\n                if (compression == LZWCompression)\n                  status=LZWEncodeImage(image,length,pixels,exception);\n                else\n                  status=PackbitsEncodeImage(image,length,pixels,exception);\n              pixel_info=RelinquishVirtualMemory(pixel_info);\n              if (status == MagickFalse)\n                {\n                  xref=(MagickOffsetType *) RelinquishMagickMemory(xref);\n                  (void) CloseBlob(image);\n                  return(MagickFalse);\n                }\n              break;\n            }\n            case NoCompression:\n            {\n              /*\n                Dump uncompressed PseudoColor packets.\n              */\n              Ascii85Initialize(image);\n              for (y=0; y < (ssize_t) image->rows; y++)\n              {\n                p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n                if (p == (const Quantum *) NULL)\n                  break;\n                for (x=0; x < (ssize_t) image->columns; x++)\n                {\n                  Ascii85Encode(image,(unsigned char) GetPixelIndex(image,p));\n                  p+=GetPixelChannels(image);\n                }\n                if (image->previous == (Image *) NULL)\n                  {\n                    status=SetImageProgress(image,SaveImageTag,\n                      (MagickOffsetType) y,image->rows);\n                    if (status == MagickFalse)\n                      break;\n                  }\n              }\n              Ascii85Flush(image);\n              break;\n            }\n          }\n        }\n    offset=TellBlob(image)-offset;\n    (void) WriteBlobString(image,\"\\nendstream\\n\");\n    (void) WriteBlobString(image,\"endobj\\n\");\n    /*\n      Write Length object.\n    */\n    xref[object++]=TellBlob(image);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n      object);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g\\n\",(double)\n      offset);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\"endobj\\n\");\n    /*\n      Write Colorspace object.\n    */\n    xref[object++]=TellBlob(image);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n      object);\n    (void) WriteBlobString(image,buffer);\n    device=\"DeviceRGB\";\n    channels=0;\n    if (image->colorspace == CMYKColorspace)\n      {\n        device=\"DeviceCMYK\";\n        channels=4;\n      }\n    else\n      if ((compression == FaxCompression) ||\n          (compression == Group4Compression) ||\n          ((image_info->type != TrueColorType) &&\n           (SetImageGray(image,exception) != MagickFalse)))\n        {\n          device=\"DeviceGray\";\n          channels=1;\n        }\n      else\n        if ((image->storage_class == DirectClass) ||\n            (image->colors > 256) || (compression == JPEGCompression) ||\n            (compression == JPEG2000Compression))\n          {\n            device=\"DeviceRGB\";\n            channels=3;\n          }\n    profile=GetImageProfile(image,\"icc\");\n    if ((profile == (StringInfo *) NULL) || (channels == 0))\n      {\n        if (channels != 0)\n          (void) FormatLocaleString(buffer,MagickPathExtent,\"/%s\\n\",device);\n        else\n          (void) FormatLocaleString(buffer,MagickPathExtent,\n            \"[ /Indexed /%s %.20g %.20g 0 R ]\\n\",device,(double) image->colors-\n            1,(double) object+3);\n        (void) WriteBlobString(image,buffer);\n      }\n    else\n      {\n        const unsigned char\n          *p;\n\n        /*\n          Write ICC profile. \n        */\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"[/ICCBased %.20g 0 R]\\n\",(double) object+1);\n        (void) WriteBlobString(image,buffer);\n        (void) WriteBlobString(image,\"endobj\\n\");\n        xref[object++]=TellBlob(image);\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",\n          (double) object);\n        (void) WriteBlobString(image,buffer);\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"<<\\n/N %.20g\\n\"\n          \"/Filter /ASCII85Decode\\n/Length %.20g 0 R\\n/Alternate /%s\\n>>\\n\"\n          \"stream\\n\",(double) channels,(double) object+1,device);\n        (void) WriteBlobString(image,buffer);\n        offset=TellBlob(image);\n        Ascii85Initialize(image);\n        p=GetStringInfoDatum(profile);\n        for (i=0; i < (ssize_t) GetStringInfoLength(profile); i++)\n          Ascii85Encode(image,(unsigned char) *p++);\n        Ascii85Flush(image);\n        offset=TellBlob(image)-offset;\n        (void) WriteBlobString(image,\"endstream\\n\");\n        (void) WriteBlobString(image,\"endobj\\n\");\n        /*\n          Write Length object.\n        */\n        xref[object++]=TellBlob(image);\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",\n          (double) object);\n        (void) WriteBlobString(image,buffer);\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g\\n\",(double)\n          offset);\n        (void) WriteBlobString(image,buffer);\n      }\n    (void) WriteBlobString(image,\"endobj\\n\");\n    /*\n      Write Thumb object.\n    */\n    SetGeometry(image,&geometry);\n    (void) ParseMetaGeometry(\"106x106+0+0>\",&geometry.x,&geometry.y,\n      &geometry.width,&geometry.height);\n    tile_image=ThumbnailImage(image,geometry.width,geometry.height,exception);\n    if (tile_image == (Image *) NULL)\n      return(MagickFalse);\n    xref[object++]=TellBlob(image);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n      object);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\"<<\\n\");\n    switch (compression)\n    {\n      case NoCompression:\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,CFormat,\n          \"ASCII85Decode\");\n        break;\n      }\n      case JPEGCompression:\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,CFormat,\"DCTDecode\");\n        if (image->colorspace != CMYKColorspace)\n          break;\n        (void) WriteBlobString(image,buffer);\n        (void) CopyMagickString(buffer,\"/Decode [1 0 1 0 1 0 1 0]\\n\",\n          MagickPathExtent);\n        break;\n      }\n      case JPEG2000Compression:\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,CFormat,\"JPXDecode\");\n        if (image->colorspace != CMYKColorspace)\n          break;\n        (void) WriteBlobString(image,buffer);\n        (void) CopyMagickString(buffer,\"/Decode [1 0 1 0 1 0 1 0]\\n\",\n          MagickPathExtent);\n        break;\n      }\n      case LZWCompression:\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,CFormat,\"LZWDecode\");\n        break;\n      }\n      case ZipCompression:\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,CFormat,\n          \"FlateDecode\");\n        break;\n      }\n      case FaxCompression:\n      case Group4Compression:\n      {\n        (void) CopyMagickString(buffer,\"/Filter [ /CCITTFaxDecode ]\\n\",\n          MagickPathExtent);\n        (void) WriteBlobString(image,buffer);\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"/DecodeParms [ << \"\n          \"/K %s /BlackIs1 false /Columns %.20g /Rows %.20g >> ]\\n\",CCITTParam,\n          (double) tile_image->columns,(double) tile_image->rows);\n        break;\n      }\n      default:\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,CFormat,\n          \"RunLengthDecode\");\n        break;\n      }\n    }\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/Width %.20g\\n\",(double)\n      tile_image->columns);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/Height %.20g\\n\",(double)\n      tile_image->rows);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/ColorSpace %.20g 0 R\\n\",\n      (double) object-(has_icc_profile != MagickFalse ? 3 : 1));\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/BitsPerComponent %d\\n\",\n      (compression == FaxCompression) || (compression == Group4Compression) ?\n      1 : 8);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/Length %.20g 0 R\\n\",\n      (double) object+1);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\">>\\n\");\n    (void) WriteBlobString(image,\"stream\\n\");\n    offset=TellBlob(image);\n    number_pixels=(MagickSizeType) tile_image->columns*tile_image->rows;\n    if ((compression == FaxCompression) ||\n        (compression == Group4Compression) ||\n        ((image_info->type != TrueColorType) &&\n         (SetImageGray(tile_image,exception) != MagickFalse)))\n      {\n        switch (compression)\n        {\n          case FaxCompression:\n          case Group4Compression:\n          {\n            if (LocaleCompare(CCITTParam,\"0\") == 0)\n              {\n                (void) HuffmanEncodeImage(image_info,image,tile_image,\n                  exception);\n                break;\n              }\n            (void) Huffman2DEncodeImage(image_info,image,tile_image,exception);\n            break;\n          }\n          case JPEGCompression:\n          {\n            status=InjectImageBlob(image_info,image,tile_image,\"jpeg\",\n              exception);\n            if (status == MagickFalse)\n              {\n                xref=(MagickOffsetType *) RelinquishMagickMemory(xref);\n                (void) CloseBlob(image);\n                return(MagickFalse);\n              }\n            break;\n          }\n          case JPEG2000Compression:\n          {\n            status=InjectImageBlob(image_info,image,tile_image,\"jp2\",exception);\n            if (status == MagickFalse)\n              {\n                xref=(MagickOffsetType *) RelinquishMagickMemory(xref);\n                (void) CloseBlob(image);\n                return(MagickFalse);\n              }\n            break;\n          }\n          case RLECompression:\n          default:\n          {\n            MemoryInfo\n              *pixel_info;\n\n            /*\n              Allocate pixel array.\n            */\n            length=(size_t) number_pixels;\n            pixel_info=AcquireVirtualMemory(length,sizeof(*pixels));\n            if (pixel_info == (MemoryInfo *) NULL)\n              {\n                tile_image=DestroyImage(tile_image);\n                ThrowPDFException(ResourceLimitError,\"MemoryAllocationFailed\");\n              }\n            pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n            /*\n              Dump runlength encoded pixels.\n            */\n            q=pixels;\n            for (y=0; y < (ssize_t) tile_image->rows; y++)\n            {\n              p=GetVirtualPixels(tile_image,0,y,tile_image->columns,1,\n                exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) tile_image->columns; x++)\n              {\n                *q++=ScaleQuantumToChar(ClampToQuantum(GetPixelLuma(\n                  tile_image,p)));\n                p+=GetPixelChannels(tile_image);\n              }\n            }\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n            if (compression == ZipCompression)\n              status=ZLIBEncodeImage(image,length,pixels,exception);\n            else\n#endif\n              if (compression == LZWCompression)\n                status=LZWEncodeImage(image,length,pixels,exception);\n              else\n                status=PackbitsEncodeImage(image,length,pixels,exception);\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            if (status == MagickFalse)\n              {\n                xref=(MagickOffsetType *) RelinquishMagickMemory(xref);\n                (void) CloseBlob(image);\n                return(MagickFalse);\n              }\n            break;\n          }\n          case NoCompression:\n          {\n            /*\n              Dump uncompressed PseudoColor packets.\n            */\n            Ascii85Initialize(image);\n            for (y=0; y < (ssize_t) tile_image->rows; y++)\n            {\n              p=GetVirtualPixels(tile_image,0,y,tile_image->columns,1,\n                exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) tile_image->columns; x++)\n              {\n                Ascii85Encode(image,ScaleQuantumToChar(ClampToQuantum(\n                  GetPixelLuma(tile_image,p))));\n                p+=GetPixelChannels(tile_image);\n              }\n            }\n            Ascii85Flush(image);\n            break;\n          }\n        }\n      }\n    else\n      if ((tile_image->storage_class == DirectClass) ||\n          (tile_image->colors > 256) || (compression == JPEGCompression) ||\n          (compression == JPEG2000Compression))\n        switch (compression)\n        {\n          case JPEGCompression:\n          {\n            status=InjectImageBlob(image_info,image,tile_image,\"jpeg\",\n              exception);\n            if (status == MagickFalse)\n              {\n                xref=(MagickOffsetType *) RelinquishMagickMemory(xref);\n                (void) CloseBlob(image);\n                return(MagickFalse);\n              }\n            break;\n          }\n          case JPEG2000Compression:\n          {\n            status=InjectImageBlob(image_info,image,tile_image,\"jp2\",exception);\n            if (status == MagickFalse)\n              {\n                xref=(MagickOffsetType *) RelinquishMagickMemory(xref);\n                (void) CloseBlob(image);\n                return(MagickFalse);\n              }\n            break;\n          }\n          case RLECompression:\n          default:\n          {\n            MemoryInfo\n              *pixel_info;\n\n            /*\n              Allocate pixel array.\n            */\n            length=(size_t) number_pixels;\n            length*=tile_image->colorspace == CMYKColorspace ? 4UL : 3UL;\n            pixel_info=AcquireVirtualMemory(length,4*sizeof(*pixels));\n            if (pixel_info == (MemoryInfo *) NULL)\n              {\n                tile_image=DestroyImage(tile_image);\n                ThrowPDFException(ResourceLimitError,\"MemoryAllocationFailed\");\n              }\n            pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n            /*\n              Dump runlength encoded pixels.\n            */\n            q=pixels;\n            for (y=0; y < (ssize_t) tile_image->rows; y++)\n            {\n              p=GetVirtualPixels(tile_image,0,y,tile_image->columns,1,\n                exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) tile_image->columns; x++)\n              {\n                *q++=ScaleQuantumToChar(GetPixelRed(tile_image,p));\n                *q++=ScaleQuantumToChar(GetPixelGreen(tile_image,p));\n                *q++=ScaleQuantumToChar(GetPixelBlue(tile_image,p));\n                if (tile_image->colorspace == CMYKColorspace)\n                  *q++=ScaleQuantumToChar(GetPixelBlack(tile_image,p));\n                p+=GetPixelChannels(tile_image);\n              }\n            }\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n            if (compression == ZipCompression)\n              status=ZLIBEncodeImage(image,length,pixels,exception);\n            else\n#endif\n              if (compression == LZWCompression)\n                status=LZWEncodeImage(image,length,pixels,exception);\n              else\n                status=PackbitsEncodeImage(image,length,pixels,exception);\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            if (status == MagickFalse)\n              {\n                xref=(MagickOffsetType *) RelinquishMagickMemory(xref);\n                (void) CloseBlob(image);\n                return(MagickFalse);\n              }\n            break;\n          }\n          case NoCompression:\n          {\n            /*\n              Dump uncompressed DirectColor packets.\n            */\n            Ascii85Initialize(image);\n            for (y=0; y < (ssize_t) tile_image->rows; y++)\n            {\n              p=GetVirtualPixels(tile_image,0,y,tile_image->columns,1,\n                exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) tile_image->columns; x++)\n              {\n                Ascii85Encode(image,ScaleQuantumToChar(\n                  GetPixelRed(tile_image,p)));\n                Ascii85Encode(image,ScaleQuantumToChar(\n                  GetPixelGreen(tile_image,p)));\n                Ascii85Encode(image,ScaleQuantumToChar(\n                  GetPixelBlue(tile_image,p)));\n                if (image->colorspace == CMYKColorspace)\n                  Ascii85Encode(image,ScaleQuantumToChar(\n                    GetPixelBlack(tile_image,p)));\n                p+=GetPixelChannels(tile_image);\n              }\n            }\n            Ascii85Flush(image);\n            break;\n          }\n        }\n      else\n        {\n          /*\n            Dump number of colors and colormap.\n          */\n          switch (compression)\n          {\n            case RLECompression:\n            default:\n            {\n              MemoryInfo\n                *pixel_info;\n\n              /*\n                Allocate pixel array.\n              */\n              length=(size_t) number_pixels;\n              pixel_info=AcquireVirtualMemory(length,sizeof(*pixels));\n              if (pixel_info == (MemoryInfo *) NULL)\n                {\n                  tile_image=DestroyImage(tile_image);\n                  ThrowPDFException(ResourceLimitError,\n                    \"MemoryAllocationFailed\");\n                }\n              pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n              /*\n                Dump runlength encoded pixels.\n              */\n              q=pixels;\n              for (y=0; y < (ssize_t) tile_image->rows; y++)\n              {\n                p=GetVirtualPixels(tile_image,0,y,tile_image->columns,1,\n                  exception);\n                if (p == (const Quantum *) NULL)\n                  break;\n                for (x=0; x < (ssize_t) tile_image->columns; x++)\n                {\n                  *q++=(unsigned char) GetPixelIndex(tile_image,p);\n                  p+=GetPixelChannels(tile_image);\n                }\n              }\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n              if (compression == ZipCompression)\n                status=ZLIBEncodeImage(image,length,pixels,exception);\n              else\n#endif\n                if (compression == LZWCompression)\n                  status=LZWEncodeImage(image,length,pixels,exception);\n                else\n                  status=PackbitsEncodeImage(image,length,pixels,exception);\n              pixel_info=RelinquishVirtualMemory(pixel_info);\n              if (status == MagickFalse)\n                {\n                  xref=(MagickOffsetType *) RelinquishMagickMemory(xref);\n                  (void) CloseBlob(image);\n                  return(MagickFalse);\n                }\n              break;\n            }\n            case NoCompression:\n            {\n              /*\n                Dump uncompressed PseudoColor packets.\n              */\n              Ascii85Initialize(image);\n              for (y=0; y < (ssize_t) tile_image->rows; y++)\n              {\n                p=GetVirtualPixels(tile_image,0,y,tile_image->columns,1,\n                  exception);\n                if (p == (const Quantum *) NULL)\n                  break;\n                for (x=0; x < (ssize_t) tile_image->columns; x++)\n                {\n                  Ascii85Encode(image,(unsigned char)\n                    ((ssize_t) GetPixelIndex(tile_image,p)));\n                  p+=GetPixelChannels(image);\n                }\n              }\n              Ascii85Flush(image);\n              break;\n            }\n          }\n        }\n    tile_image=DestroyImage(tile_image);\n    offset=TellBlob(image)-offset;\n    (void) WriteBlobString(image,\"\\nendstream\\n\");\n    (void) WriteBlobString(image,\"endobj\\n\");\n    /*\n      Write Length object.\n    */\n    xref[object++]=TellBlob(image);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n      object);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g\\n\",(double)\n      offset);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\"endobj\\n\");\n    xref[object++]=TellBlob(image);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n      object);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\"<<\\n\");\n    if ((image->storage_class == DirectClass) || (image->colors > 256) ||\n        (compression == FaxCompression) || (compression == Group4Compression))\n      (void) WriteBlobString(image,\">>\\n\");\n    else\n      {\n        /*\n          Write Colormap object.\n        */\n        if (compression == NoCompression)\n          (void) WriteBlobString(image,\"/Filter [ /ASCII85Decode ]\\n\");\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"/Length %.20g 0 R\\n\",\n          (double) object+1);\n        (void) WriteBlobString(image,buffer);\n        (void) WriteBlobString(image,\">>\\n\");\n        (void) WriteBlobString(image,\"stream\\n\");\n        offset=TellBlob(image);\n        if (compression == NoCompression)\n          Ascii85Initialize(image);\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          if (compression == NoCompression)\n            {\n              Ascii85Encode(image,ScaleQuantumToChar(ClampToQuantum(\n                image->colormap[i].red)));\n              Ascii85Encode(image,ScaleQuantumToChar(ClampToQuantum(\n                image->colormap[i].green)));\n              Ascii85Encode(image,ScaleQuantumToChar(ClampToQuantum(\n                image->colormap[i].blue)));\n              continue;\n            }\n          (void) WriteBlobByte(image,ScaleQuantumToChar(\n             ClampToQuantum(image->colormap[i].red)));\n          (void) WriteBlobByte(image,ScaleQuantumToChar(\n             ClampToQuantum(image->colormap[i].green)));\n          (void) WriteBlobByte(image,ScaleQuantumToChar(\n             ClampToQuantum(image->colormap[i].blue)));\n        }\n        if (compression == NoCompression)\n          Ascii85Flush(image);\n       offset=TellBlob(image)-offset;\n       (void) WriteBlobString(image,\"\\nendstream\\n\");\n      }\n    (void) WriteBlobString(image,\"endobj\\n\");\n    /*\n      Write Length object.\n    */\n    xref[object++]=TellBlob(image);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n      object);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g\\n\",(double)\n      offset);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\"endobj\\n\");\n    /*\n      Write softmask object.\n    */\n    xref[object++]=TellBlob(image);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n      object);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\"<<\\n\");\n    if (image->alpha_trait == UndefinedPixelTrait)\n      (void) WriteBlobString(image,\">>\\n\");\n    else\n      {\n        (void) WriteBlobString(image,\"/Type /XObject\\n\");\n        (void) WriteBlobString(image,\"/Subtype /Image\\n\");\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"/Name /Ma%.20g\\n\",\n          (double) image->scene);\n        (void) WriteBlobString(image,buffer);\n        switch (compression)\n        {\n          case NoCompression:\n          {\n            (void) FormatLocaleString(buffer,MagickPathExtent,CFormat,\n              \"ASCII85Decode\");\n            break;\n          }\n          case LZWCompression:\n          {\n            (void) FormatLocaleString(buffer,MagickPathExtent,CFormat,\n              \"LZWDecode\");\n            break;\n          }\n          case ZipCompression:\n          {\n            (void) FormatLocaleString(buffer,MagickPathExtent,CFormat,\n              \"FlateDecode\");\n            break;\n          }\n          default:\n          {\n            (void) FormatLocaleString(buffer,MagickPathExtent,CFormat,\n              \"RunLengthDecode\");\n            break;\n          }\n        }\n        (void) WriteBlobString(image,buffer);\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"/Width %.20g\\n\",\n          (double) image->columns);\n        (void) WriteBlobString(image,buffer);\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"/Height %.20g\\n\",\n          (double) image->rows);\n        (void) WriteBlobString(image,buffer);\n        (void) WriteBlobString(image,\"/ColorSpace /DeviceGray\\n\");\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"/BitsPerComponent %d\\n\",(compression == FaxCompression) ||\n          (compression == Group4Compression) ? 1 : 8);\n        (void) WriteBlobString(image,buffer);\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"/Length %.20g 0 R\\n\",\n          (double) object+1);\n        (void) WriteBlobString(image,buffer);\n        (void) WriteBlobString(image,\">>\\n\");\n        (void) WriteBlobString(image,\"stream\\n\");\n        offset=TellBlob(image);\n        number_pixels=(MagickSizeType) image->columns*image->rows;\n        switch (compression)\n        {\n          case RLECompression:\n          default:\n          {\n            MemoryInfo\n              *pixel_info;\n\n            /*\n              Allocate pixel array.\n            */\n            length=(size_t) number_pixels;\n            pixel_info=AcquireVirtualMemory(length,4*sizeof(*pixels));\n            if (pixel_info == (MemoryInfo *) NULL)\n              {\n                image=DestroyImage(image);\n                ThrowPDFException(ResourceLimitError,\"MemoryAllocationFailed\");\n              }\n            pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n            /*\n              Dump Runlength encoded pixels.\n            */\n            q=pixels;\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                *q++=ScaleQuantumToChar(GetPixelAlpha(image,p));\n                p+=GetPixelChannels(image);\n              }\n            }\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n            if (compression == ZipCompression)\n              status=ZLIBEncodeImage(image,length,pixels,exception);\n            else\n#endif\n              if (compression == LZWCompression)\n                status=LZWEncodeImage(image,length,pixels,exception);\n              else\n                status=PackbitsEncodeImage(image,length,pixels,exception);\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            if (status == MagickFalse)\n              {\n                xref=(MagickOffsetType *) RelinquishMagickMemory(xref);\n                (void) CloseBlob(image);\n                return(MagickFalse);\n              }\n            break;\n          }\n          case NoCompression:\n          {\n            /*\n              Dump uncompressed PseudoColor packets.\n            */\n            Ascii85Initialize(image);\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                Ascii85Encode(image,ScaleQuantumToChar(GetPixelAlpha(image,p)));\n                p+=GetPixelChannels(image);\n              }\n            }\n            Ascii85Flush(image);\n            break;\n          }\n        }\n        offset=TellBlob(image)-offset;\n        (void) WriteBlobString(image,\"\\nendstream\\n\");\n      }\n    (void) WriteBlobString(image,\"endobj\\n\");\n    /*\n      Write Length object.\n    */\n    xref[object++]=TellBlob(image);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n      object);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g\\n\",(double)\n      offset);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\"endobj\\n\");\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,imageListLength);\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  /*\n    Write Metadata object.\n  */\n  xref[object++]=TellBlob(image);\n  info_id=object;\n  (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n    object);\n  (void) WriteBlobString(image,buffer);\n  (void) WriteBlobString(image,\"<<\\n\");\n  if (LocaleCompare(image_info->magick,\"PDFA\") == 0)\n    {\n      escape=EscapeParenthesis(basename);\n      (void) FormatLocaleString(buffer,MagickPathExtent,\"/Title (%s)\\n\",\n        escape);\n      escape=DestroyString(escape);\n    }\n  else\n    {\n      wchar_t\n        *utf16;\n\n      utf16=ConvertUTF8ToUTF16((unsigned char *) basename,&length);\n      if (utf16 != (wchar_t *) NULL)\n        {\n          unsigned char\n            hex_digits[16];\n\n          hex_digits[0]='0';\n          hex_digits[1]='1';\n          hex_digits[2]='2';\n          hex_digits[3]='3';\n          hex_digits[4]='4';\n          hex_digits[5]='5';\n          hex_digits[6]='6';\n          hex_digits[7]='7';\n          hex_digits[8]='8';\n          hex_digits[9]='9';\n          hex_digits[10]='A';\n          hex_digits[11]='B';\n          hex_digits[12]='C';\n          hex_digits[13]='D';\n          hex_digits[14]='E';\n          hex_digits[15]='F';\n          (void) FormatLocaleString(buffer,MagickPathExtent,\"/Title <FEFF\");\n          (void) WriteBlobString(image,buffer);\n          for (i=0; i < (ssize_t) length; i++)\n          {\n            (void) WriteBlobByte(image,'0');\n            (void) WriteBlobByte(image,'0');\n            (void) WriteBlobByte(image,hex_digits[(utf16[i] >> 4) & 0x0f]);\n            (void) WriteBlobByte(image,hex_digits[utf16[i] & 0x0f]);\n          }\n          (void) FormatLocaleString(buffer,MagickPathExtent,\">\\n\");\n          utf16=(wchar_t *) RelinquishMagickMemory(utf16);\n        }\n    }\n  (void) WriteBlobString(image,buffer);\n  seconds=GetMagickTime();\n  GetMagickUTCtime(&seconds,&utc_time);\n  (void) FormatLocaleString(date,MagickPathExtent,\"D:%04d%02d%02d%02d%02d%02d\",\n    utc_time.tm_year+1900,utc_time.tm_mon+1,utc_time.tm_mday,\n    utc_time.tm_hour,utc_time.tm_min,utc_time.tm_sec);\n  (void) FormatLocaleString(buffer,MagickPathExtent,\"/CreationDate (%s)\\n\",\n    date);\n  (void) WriteBlobString(image,buffer);\n  (void) FormatLocaleString(buffer,MagickPathExtent,\"/ModDate (%s)\\n\",date);\n  (void) WriteBlobString(image,buffer);\n  url=(char *) MagickAuthoritativeURL;\n  escape=EscapeParenthesis(url);\n  (void) FormatLocaleString(buffer,MagickPathExtent,\"/Producer (%s)\\n\",escape);\n  escape=DestroyString(escape);\n  (void) WriteBlobString(image,buffer);\n  (void) WriteBlobString(image,\">>\\n\");\n  (void) WriteBlobString(image,\"endobj\\n\");\n  /*\n    Write Xref object.\n  */\n  offset=TellBlob(image)-xref[0]+\n   (LocaleCompare(image_info->magick,\"PDFA\") == 0 ? 6 : 0)+10;\n  (void) WriteBlobString(image,\"xref\\n\");\n  (void) FormatLocaleString(buffer,MagickPathExtent,\"0 %.20g\\n\",(double)\n    object+1);\n  (void) WriteBlobString(image,buffer);\n  (void) WriteBlobString(image,\"0000000000 65535 f \\n\");\n  for (i=0; i < (ssize_t) object; i++)\n  {\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%010lu 00000 n \\n\",\n      (unsigned long) xref[i]);\n    (void) WriteBlobString(image,buffer);\n  }\n  (void) WriteBlobString(image,\"trailer\\n\");\n  (void) WriteBlobString(image,\"<<\\n\");\n  (void) FormatLocaleString(buffer,MagickPathExtent,\"/Size %.20g\\n\",(double)\n    object+1);\n  (void) WriteBlobString(image,buffer);\n  (void) FormatLocaleString(buffer,MagickPathExtent,\"/Info %.20g 0 R\\n\",(double)\n    info_id);\n  (void) WriteBlobString(image,buffer);\n  (void) FormatLocaleString(buffer,MagickPathExtent,\"/Root %.20g 0 R\\n\",(double)\n    root_id);\n  (void) WriteBlobString(image,buffer);\n  (void) SignatureImage(image,exception);\n  (void) FormatLocaleString(buffer,MagickPathExtent,\"/ID [<%s> <%s>]\\n\",\n    GetImageProperty(image,\"signature\",exception),\n    GetImageProperty(image,\"signature\",exception));\n  (void) WriteBlobString(image,buffer);\n  (void) WriteBlobString(image,\">>\\n\");\n  (void) WriteBlobString(image,\"startxref\\n\");\n  (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g\\n\",(double) offset);\n  (void) WriteBlobString(image,buffer);\n  (void) WriteBlobString(image,\"%%EOF\\n\");\n  xref=(MagickOffsetType *) RelinquishMagickMemory(xref);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146098,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static MagickBooleanType WritePDFImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n#define CFormat  \"/Filter [ /%s ]\\n\"\n#define ObjectsPerImage  14\n#define ThrowPDFException(exception,message) \\\n{ \\\n  if (xref != (MagickOffsetType *) NULL) \\\n    xref=(MagickOffsetType *) RelinquishMagickMemory(xref); \\\n  ThrowWriterException((exception),(message)); \\\n}\n\nDisableMSCWarning(4310)\n  static const char\n    XMPProfile[]=\n    {\n      \"<?xpacket begin=\\\"%s\\\" id=\\\"W5M0MpCehiHzreSzNTczkc9d\\\"?>\\n\"\n      \"<x:xmpmeta xmlns:x=\\\"adobe:ns:meta/\\\" x:xmptk=\\\"Adobe XMP Core 4.0-c316 44.253921, Sun Oct 01 2006 17:08:23\\\">\\n\"\n      \"   <rdf:RDF xmlns:rdf=\\\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\\\">\\n\"\n      \"      <rdf:Description rdf:about=\\\"\\\"\\n\"\n      \"            xmlns:xap=\\\"http://ns.adobe.com/xap/1.0/\\\">\\n\"\n      \"         <xap:ModifyDate>%s</xap:ModifyDate>\\n\"\n      \"         <xap:CreateDate>%s</xap:CreateDate>\\n\"\n      \"         <xap:MetadataDate>%s</xap:MetadataDate>\\n\"\n      \"         <xap:CreatorTool>%s</xap:CreatorTool>\\n\"\n      \"      </rdf:Description>\\n\"\n      \"      <rdf:Description rdf:about=\\\"\\\"\\n\"\n      \"            xmlns:dc=\\\"http://purl.org/dc/elements/1.1/\\\">\\n\"\n      \"         <dc:format>application/pdf</dc:format>\\n\"\n      \"         <dc:title>\\n\"\n      \"           <rdf:Alt>\\n\"\n      \"              <rdf:li xml:lang=\\\"x-default\\\">%s</rdf:li>\\n\"\n      \"           </rdf:Alt>\\n\"\n      \"         </dc:title>\\n\"\n      \"      </rdf:Description>\\n\"\n      \"      <rdf:Description rdf:about=\\\"\\\"\\n\"\n      \"            xmlns:xapMM=\\\"http://ns.adobe.com/xap/1.0/mm/\\\">\\n\"\n      \"         <xapMM:DocumentID>uuid:6ec119d7-7982-4f56-808d-dfe64f5b35cf</xapMM:DocumentID>\\n\"\n      \"         <xapMM:InstanceID>uuid:a79b99b4-6235-447f-9f6c-ec18ef7555cb</xapMM:InstanceID>\\n\"\n      \"      </rdf:Description>\\n\"\n      \"      <rdf:Description rdf:about=\\\"\\\"\\n\"\n      \"            xmlns:pdf=\\\"http://ns.adobe.com/pdf/1.3/\\\">\\n\"\n      \"         <pdf:Producer>%s</pdf:Producer>\\n\"\n      \"      </rdf:Description>\\n\"\n      \"      <rdf:Description rdf:about=\\\"\\\"\\n\"\n      \"            xmlns:pdfaid=\\\"http://www.aiim.org/pdfa/ns/id/\\\">\\n\"\n      \"         <pdfaid:part>3</pdfaid:part>\\n\"\n      \"         <pdfaid:conformance>B</pdfaid:conformance>\\n\"\n      \"      </rdf:Description>\\n\"\n      \"   </rdf:RDF>\\n\"\n      \"</x:xmpmeta>\\n\"\n      \"<?xpacket end=\\\"w\\\"?>\\n\"\n    },\n    XMPProfileMagick[4]= { (char) 0xef, (char) 0xbb, (char) 0xbf, (char) 0x00 };\nRestoreMSCWarning\n\n  char\n    basename[MagickPathExtent],\n    buffer[MagickPathExtent],\n    *escape,\n    date[MagickPathExtent],\n    **labels,\n    page_geometry[MagickPathExtent],\n    *url;\n\n  CompressionType\n    compression;\n\n  const char\n    *device,\n    *option,\n    *value;\n\n  const StringInfo\n    *profile;\n\n  double\n    pointsize;\n\n  GeometryInfo\n    geometry_info;\n\n  Image\n    *next,\n    *tile_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset,\n    scene,\n    *xref;\n\n  MagickSizeType\n    number_pixels;\n\n  MagickStatusType\n    flags;\n\n  PointInfo\n    delta,\n    resolution,\n    scale;\n\n  RectangleInfo\n    geometry,\n    media_info,\n    page_info;\n\n  register const Quantum\n    *p;\n\n  register unsigned char\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  size_t\n    channels,\n    imageListLength,\n    info_id,\n    length,\n    object,\n    pages_id,\n    root_id,\n    text_size,\n    version;\n\n  ssize_t\n    count,\n    page_count,\n    y;\n\n  struct tm\n    utc_time;\n\n  time_t\n    seconds;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  /*\n    Allocate X ref memory.\n  */\n  xref=(MagickOffsetType *) AcquireQuantumMemory(2048UL,sizeof(*xref));\n  if (xref == (MagickOffsetType *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  (void) memset(xref,0,2048UL*sizeof(*xref));\n  /*\n    Write Info object.\n  */\n  object=0;\n  version=3;\n  if (image_info->compression == JPEG2000Compression)\n    version=(size_t) MagickMax(version,5);\n  for (next=image; next != (Image *) NULL; next=GetNextImageInList(next))\n    if (next->alpha_trait != UndefinedPixelTrait)\n      version=(size_t) MagickMax(version,4);\n  if (LocaleCompare(image_info->magick,\"PDFA\") == 0)\n    version=(size_t) MagickMax(version,6);\n  profile=GetImageProfile(image,\"icc\");\n  if (profile != (StringInfo *) NULL)\n    version=(size_t) MagickMax(version,7);\n  (void) FormatLocaleString(buffer,MagickPathExtent,\"%%PDF-1.%.20g \\n\",(double)\n    version);\n  (void) WriteBlobString(image,buffer);\n  if (LocaleCompare(image_info->magick,\"PDFA\") == 0)\n    {\n      (void) WriteBlobByte(image,'%');\n      (void) WriteBlobByte(image,0xe2);\n      (void) WriteBlobByte(image,0xe3);\n      (void) WriteBlobByte(image,0xcf);\n      (void) WriteBlobByte(image,0xd3);\n      (void) WriteBlobByte(image,'\\n');\n    }\n  /*\n    Write Catalog object.\n  */\n  xref[object++]=TellBlob(image);\n  root_id=object;\n  (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n    object);\n  (void) WriteBlobString(image,buffer);\n  (void) WriteBlobString(image,\"<<\\n\");\n  if (LocaleCompare(image_info->magick,\"PDFA\") != 0)\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/Pages %.20g 0 R\\n\",\n      (double) object+1);\n  else\n    {\n      (void) FormatLocaleString(buffer,MagickPathExtent,\"/Metadata %.20g 0 R\\n\",\n        (double) object+1);\n      (void) WriteBlobString(image,buffer);\n      (void) FormatLocaleString(buffer,MagickPathExtent,\"/Pages %.20g 0 R\\n\",\n        (double) object+2);\n    }\n  (void) WriteBlobString(image,buffer);\n  (void) WriteBlobString(image,\"/Type /Catalog\");\n  option=GetImageOption(image_info,\"pdf:page-direction\");\n  if ((option != (const char *) NULL) &&\n      (LocaleCompare(option,\"right-to-left\") == 0))\n    (void) WriteBlobString(image,\"/ViewerPreferences<</PageDirection/R2L>>\\n\");\n  (void) WriteBlobString(image,\"\\n\");\n  (void) WriteBlobString(image,\">>\\n\");\n  (void) WriteBlobString(image,\"endobj\\n\");\n  GetPathComponent(image->filename,BasePath,basename);\n  if (LocaleCompare(image_info->magick,\"PDFA\") == 0)\n    {\n      char\n        create_date[MagickPathExtent],\n        modify_date[MagickPathExtent],\n        timestamp[MagickPathExtent],\n        xmp_profile[MagickPathExtent];\n\n      /*\n        Write XMP object.\n      */\n      xref[object++]=TellBlob(image);\n      (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n        object);\n      (void) WriteBlobString(image,buffer);\n      (void) WriteBlobString(image,\"<<\\n\");\n      (void) WriteBlobString(image,\"/Subtype /XML\\n\");\n      *modify_date='\\0';\n      value=GetImageProperty(image,\"date:modify\",exception);\n      if (value != (const char *) NULL)\n        (void) CopyMagickString(modify_date,value,MagickPathExtent);\n      *create_date='\\0';\n      value=GetImageProperty(image,\"date:create\",exception);\n      if (value != (const char *) NULL)\n        (void) CopyMagickString(create_date,value,MagickPathExtent);\n      (void) FormatMagickTime(GetMagickTime(),MagickPathExtent,timestamp);\n      url=(char *) MagickAuthoritativeURL;\n      escape=EscapeParenthesis(basename);\n      i=FormatLocaleString(xmp_profile,MagickPathExtent,XMPProfile,\n        XMPProfileMagick,modify_date,create_date,timestamp,url,escape,url);\n      escape=DestroyString(escape);\n      (void) FormatLocaleString(buffer,MagickPathExtent,\"/Length %.20g\\n\",\n        (double) i);\n      (void) WriteBlobString(image,buffer);\n      (void) WriteBlobString(image,\"/Type /Metadata\\n\");\n      (void) WriteBlobString(image,\">>\\nstream\\n\");\n      (void) WriteBlobString(image,xmp_profile);\n      (void) WriteBlobString(image,\"\\nendstream\\n\");\n      (void) WriteBlobString(image,\"endobj\\n\");\n    }\n  /*\n    Write Pages object.\n  */\n  xref[object++]=TellBlob(image);\n  pages_id=object;\n  (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n    object);\n  (void) WriteBlobString(image,buffer);\n  (void) WriteBlobString(image,\"<<\\n\");\n  (void) WriteBlobString(image,\"/Type /Pages\\n\");\n  (void) FormatLocaleString(buffer,MagickPathExtent,\"/Kids [ %.20g 0 R \",\n    (double) object+1);\n  (void) WriteBlobString(image,buffer);\n  count=(ssize_t) (pages_id+ObjectsPerImage+1);\n  page_count=1;\n  if (image_info->adjoin != MagickFalse)\n    {\n      Image\n        *kid_image;\n\n      /*\n        Predict page object id's.\n      */\n      kid_image=image;\n      for ( ; GetNextImageInList(kid_image) != (Image *) NULL; count+=ObjectsPerImage)\n      {\n        page_count++;\n        profile=GetImageProfile(kid_image,\"icc\");\n        if (profile != (StringInfo *) NULL)\n          count+=2;\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 R \",(double)\n          count);\n        (void) WriteBlobString(image,buffer);\n        kid_image=GetNextImageInList(kid_image);\n      }\n      xref=(MagickOffsetType *) ResizeQuantumMemory(xref,(size_t) count+2048UL,\n        sizeof(*xref));\n      if (xref == (MagickOffsetType *) NULL)\n        ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  (void) WriteBlobString(image,\"]\\n\");\n  (void) FormatLocaleString(buffer,MagickPathExtent,\"/Count %.20g\\n\",(double)\n    page_count);\n  (void) WriteBlobString(image,buffer);\n  (void) WriteBlobString(image,\">>\\n\");\n  (void) WriteBlobString(image,\"endobj\\n\");\n  scene=0;\n  imageListLength=GetImageListLength(image);\n  do\n  {\n    MagickBooleanType\n      has_icc_profile;\n\n    profile=GetImageProfile(image,\"icc\");\n    has_icc_profile=(profile != (StringInfo *) NULL) ? MagickTrue : MagickFalse;\n    compression=image->compression;\n    if (image_info->compression != UndefinedCompression)\n      compression=image_info->compression;\n    switch (compression)\n    {\n      case FaxCompression:\n      case Group4Compression:\n      {\n        if ((SetImageMonochrome(image,exception) == MagickFalse) ||\n            (image->alpha_trait != UndefinedPixelTrait))\n          compression=RLECompression;\n        break;\n      }\n#if !defined(MAGICKCORE_JPEG_DELEGATE)\n      case JPEGCompression:\n      {\n        compression=RLECompression;\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          MissingDelegateError,\"DelegateLibrarySupportNotBuiltIn\",\"`%s' (JPEG)\",\n          image->filename);\n        break;\n      }\n#endif\n#if !defined(MAGICKCORE_LIBOPENJP2_DELEGATE)\n      case JPEG2000Compression:\n      {\n        compression=RLECompression;\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          MissingDelegateError,\"DelegateLibrarySupportNotBuiltIn\",\"`%s' (JP2)\",\n          image->filename);\n        break;\n      }\n#endif\n#if !defined(MAGICKCORE_ZLIB_DELEGATE)\n      case ZipCompression:\n      {\n        compression=RLECompression;\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          MissingDelegateError,\"DelegateLibrarySupportNotBuiltIn\",\"`%s' (ZLIB)\",\n          image->filename);\n        break;\n      }\n#endif\n      case LZWCompression:\n      {\n        if (LocaleCompare(image_info->magick,\"PDFA\") == 0)\n          compression=RLECompression;  /* LZW compression is forbidden */\n        break;\n      }\n      case NoCompression:\n      {\n        if (LocaleCompare(image_info->magick,\"PDFA\") == 0)\n          compression=RLECompression; /* ASCII 85 compression is forbidden */\n        break;\n      }\n      default:\n        break;\n    }\n    if (compression == JPEG2000Compression)\n      (void) TransformImageColorspace(image,sRGBColorspace,exception);\n    /*\n      Scale relative to dots-per-inch.\n    */\n    delta.x=DefaultResolution;\n    delta.y=DefaultResolution;\n    resolution.x=image->resolution.x;\n    resolution.y=image->resolution.y;\n    if ((resolution.x == 0.0) || (resolution.y == 0.0))\n      {\n        flags=ParseGeometry(PSDensityGeometry,&geometry_info);\n        resolution.x=geometry_info.rho;\n        resolution.y=geometry_info.sigma;\n        if ((flags & SigmaValue) == 0)\n          resolution.y=resolution.x;\n      }\n    if (image_info->density != (char *) NULL)\n      {\n        flags=ParseGeometry(image_info->density,&geometry_info);\n        resolution.x=geometry_info.rho;\n        resolution.y=geometry_info.sigma;\n        if ((flags & SigmaValue) == 0)\n          resolution.y=resolution.x;\n      }\n    if (image->units == PixelsPerCentimeterResolution)\n      {\n        resolution.x=(double) ((size_t) (100.0*2.54*resolution.x+0.5)/100.0);\n        resolution.y=(double) ((size_t) (100.0*2.54*resolution.y+0.5)/100.0);\n      }\n    SetGeometry(image,&geometry);\n    (void) FormatLocaleString(page_geometry,MagickPathExtent,\"%.20gx%.20g\",\n      (double) image->columns,(double) image->rows);\n    if (image_info->page != (char *) NULL)\n      (void) CopyMagickString(page_geometry,image_info->page,MagickPathExtent);\n    else\n      if ((image->page.width != 0) && (image->page.height != 0))\n        (void) FormatLocaleString(page_geometry,MagickPathExtent,\n          \"%.20gx%.20g%+.20g%+.20g\",(double) image->page.width,(double)\n          image->page.height,(double) image->page.x,(double) image->page.y);\n      else\n        if ((image->gravity != UndefinedGravity) &&\n            (LocaleCompare(image_info->magick,\"PDF\") == 0))\n          (void) CopyMagickString(page_geometry,PSPageGeometry,\n            MagickPathExtent);\n    (void) ConcatenateMagickString(page_geometry,\">\",MagickPathExtent);\n    (void) ParseMetaGeometry(page_geometry,&geometry.x,&geometry.y,\n      &geometry.width,&geometry.height);\n    scale.x=(double) (geometry.width*delta.x)/resolution.x;\n    geometry.width=(size_t) floor(scale.x+0.5);\n    scale.y=(double) (geometry.height*delta.y)/resolution.y;\n    geometry.height=(size_t) floor(scale.y+0.5);\n    (void) ParseAbsoluteGeometry(page_geometry,&media_info);\n    (void) ParseGravityGeometry(image,page_geometry,&page_info,exception);\n    if (image->gravity != UndefinedGravity)\n      {\n        geometry.x=(-page_info.x);\n        geometry.y=(ssize_t) (media_info.height+page_info.y-image->rows);\n      }\n    pointsize=12.0;\n    if (image_info->pointsize != 0.0)\n      pointsize=image_info->pointsize;\n    text_size=0;\n    value=GetImageProperty(image,\"label\",exception);\n    if (value != (const char *) NULL)\n      text_size=(size_t) (MultilineCensus(value)*pointsize+12);\n    (void) text_size;\n    /*\n      Write Page object.\n    */\n    xref[object++]=TellBlob(image);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n      object);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\"<<\\n\");\n    (void) WriteBlobString(image,\"/Type /Page\\n\");\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/Parent %.20g 0 R\\n\",\n      (double) pages_id);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\"/Resources <<\\n\");\n    labels=(char **) NULL;\n    value=GetImageProperty(image,\"label\",exception);\n    if (value != (const char *) NULL)\n      labels=StringToList(value);\n    if (labels != (char **) NULL)\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"/Font << /F%.20g %.20g 0 R >>\\n\",(double) image->scene,(double)\n          object+4);\n        (void) WriteBlobString(image,buffer);\n      }\n    (void) FormatLocaleString(buffer,MagickPathExtent,\n      \"/XObject << /Im%.20g %.20g 0 R >>\\n\",(double) image->scene,(double)\n      object+5);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/ProcSet %.20g 0 R >>\\n\",\n      (double) object+3);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\n      \"/MediaBox [0 0 %g %g]\\n\",72.0*media_info.width/resolution.x,\n      72.0*media_info.height/resolution.y);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\n      \"/CropBox [0 0 %g %g]\\n\",72.0*media_info.width/resolution.x,\n      72.0*media_info.height/resolution.y);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/Contents %.20g 0 R\\n\",\n      (double) object+1);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/Thumb %.20g 0 R\\n\",\n      (double) object+(has_icc_profile != MagickFalse ? 10 : 8));\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\">>\\n\");\n    (void) WriteBlobString(image,\"endobj\\n\");\n    /*\n      Write Contents object.\n    */\n    xref[object++]=TellBlob(image);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n      object);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\"<<\\n\");\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/Length %.20g 0 R\\n\",\n      (double) object+1);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\">>\\n\");\n    (void) WriteBlobString(image,\"stream\\n\");\n    offset=TellBlob(image);\n    (void) WriteBlobString(image,\"q\\n\");\n    if (labels != (char **) NULL)\n      for (i=0; labels[i] != (char *) NULL; i++)\n      {\n        (void) WriteBlobString(image,\"BT\\n\");\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"/F%.20g %g Tf\\n\",\n          (double) image->scene,pointsize);\n        (void) WriteBlobString(image,buffer);\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g %.20g Td\\n\",\n          (double) geometry.x,(double) (geometry.y+geometry.height+i*pointsize+\n          12));\n        (void) WriteBlobString(image,buffer);\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"(%s) Tj\\n\",\n           labels[i]);\n        (void) WriteBlobString(image,buffer);\n        (void) WriteBlobString(image,\"ET\\n\");\n        labels[i]=DestroyString(labels[i]);\n      }\n    (void) FormatLocaleString(buffer,MagickPathExtent,\n      \"%g 0 0 %g %.20g %.20g cm\\n\",scale.x,scale.y,(double) geometry.x,\n      (double) geometry.y);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/Im%.20g Do\\n\",(double)\n      image->scene);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\"Q\\n\");\n    offset=TellBlob(image)-offset;\n    (void) WriteBlobString(image,\"\\nendstream\\n\");\n    (void) WriteBlobString(image,\"endobj\\n\");\n    /*\n      Write Length object.\n    */\n    xref[object++]=TellBlob(image);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n      object);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g\\n\",(double)\n      offset);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\"endobj\\n\");\n    /*\n      Write Procset object.\n    */\n    xref[object++]=TellBlob(image);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n      object);\n    (void) WriteBlobString(image,buffer);\n    if ((image->storage_class == DirectClass) || (image->colors > 256))\n      (void) CopyMagickString(buffer,\"[ /PDF /Text /ImageC\",MagickPathExtent);\n    else\n      if ((compression == FaxCompression) || (compression == Group4Compression))\n        (void) CopyMagickString(buffer,\"[ /PDF /Text /ImageB\",MagickPathExtent);\n      else\n        (void) CopyMagickString(buffer,\"[ /PDF /Text /ImageI\",MagickPathExtent);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\" ]\\n\");\n    (void) WriteBlobString(image,\"endobj\\n\");\n    /*\n      Write Font object.\n    */\n    xref[object++]=TellBlob(image);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n      object);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\"<<\\n\");\n    if (labels != (char **) NULL)\n      {\n        (void) WriteBlobString(image,\"/Type /Font\\n\");\n        (void) WriteBlobString(image,\"/Subtype /Type1\\n\");\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"/Name /F%.20g\\n\",\n          (double) image->scene);\n        (void) WriteBlobString(image,buffer);\n        (void) WriteBlobString(image,\"/BaseFont /Helvetica\\n\");\n        (void) WriteBlobString(image,\"/Encoding /MacRomanEncoding\\n\");\n        labels=(char **) RelinquishMagickMemory(labels);\n      }\n    (void) WriteBlobString(image,\">>\\n\");\n    (void) WriteBlobString(image,\"endobj\\n\");\n    /*\n      Write XObject object.\n    */\n    xref[object++]=TellBlob(image);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n      object);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\"<<\\n\");\n    (void) WriteBlobString(image,\"/Type /XObject\\n\");\n    (void) WriteBlobString(image,\"/Subtype /Image\\n\");\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/Name /Im%.20g\\n\",\n      (double) image->scene);\n    (void) WriteBlobString(image,buffer);\n    switch (compression)\n    {\n      case NoCompression:\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,CFormat,\n          \"ASCII85Decode\");\n        break;\n      }\n      case JPEGCompression:\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,CFormat,\"DCTDecode\");\n        if (image->colorspace != CMYKColorspace)\n          break;\n        (void) WriteBlobString(image,buffer);\n        (void) CopyMagickString(buffer,\"/Decode [1 0 1 0 1 0 1 0]\\n\",\n          MagickPathExtent);\n        break;\n      }\n      case JPEG2000Compression:\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,CFormat,\"JPXDecode\");\n        if (image->colorspace != CMYKColorspace)\n          break;\n        (void) WriteBlobString(image,buffer);\n        (void) CopyMagickString(buffer,\"/Decode [1 0 1 0 1 0 1 0]\\n\",\n          MagickPathExtent);\n        break;\n      }\n      case LZWCompression:\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,CFormat,\"LZWDecode\");\n        break;\n      }\n      case ZipCompression:\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,CFormat,\n          \"FlateDecode\");\n        break;\n      }\n      case FaxCompression:\n      case Group4Compression:\n      {\n        (void) CopyMagickString(buffer,\"/Filter [ /CCITTFaxDecode ]\\n\",\n          MagickPathExtent);\n        (void) WriteBlobString(image,buffer);\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"/DecodeParms [ << \"\n          \"/K %s /BlackIs1 false /Columns %.20g /Rows %.20g >> ]\\n\",CCITTParam,\n          (double) image->columns,(double) image->rows);\n        break;\n      }\n      default:\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,CFormat,\n          \"RunLengthDecode\");\n        break;\n      }\n    }\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/Width %.20g\\n\",(double)\n      image->columns);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/Height %.20g\\n\",(double)\n      image->rows);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/ColorSpace %.20g 0 R\\n\",\n      (double) object+2);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/BitsPerComponent %d\\n\",\n      (compression == FaxCompression) || (compression == Group4Compression) ?\n      1 : 8);\n    (void) WriteBlobString(image,buffer);\n    if (image->alpha_trait != UndefinedPixelTrait)\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"/SMask %.20g 0 R\\n\",\n          (double) object+(has_icc_profile != MagickFalse ? 9 : 7));\n        (void) WriteBlobString(image,buffer);\n      }\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/Length %.20g 0 R\\n\",\n      (double) object+1);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\">>\\n\");\n    (void) WriteBlobString(image,\"stream\\n\");\n    offset=TellBlob(image);\n    number_pixels=(MagickSizeType) image->columns*image->rows;\n    if ((4*number_pixels) != (MagickSizeType) ((size_t) (4*number_pixels)))\n      ThrowPDFException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if ((compression == FaxCompression) || (compression == Group4Compression) ||\n        ((image_info->type != TrueColorType) &&\n         (SetImageGray(image,exception) != MagickFalse)))\n      {\n        switch (compression)\n        {\n          case FaxCompression:\n          case Group4Compression:\n          {\n            if (LocaleCompare(CCITTParam,\"0\") == 0)\n              {\n                (void) HuffmanEncodeImage(image_info,image,image,exception);\n                break;\n              }\n            (void) Huffman2DEncodeImage(image_info,image,image,exception);\n            break;\n          }\n          case JPEGCompression:\n          {\n            status=InjectImageBlob(image_info,image,image,\"jpeg\",exception);\n            if (status == MagickFalse)\n              {\n                xref=(MagickOffsetType *) RelinquishMagickMemory(xref);\n                (void) CloseBlob(image);\n                return(MagickFalse);\n              }\n            break;\n          }\n          case JPEG2000Compression:\n          {\n            status=InjectImageBlob(image_info,image,image,\"jp2\",exception);\n            if (status == MagickFalse)\n              {\n                xref=(MagickOffsetType *) RelinquishMagickMemory(xref);\n                (void) CloseBlob(image);\n                return(MagickFalse);\n              }\n            break;\n          }\n          case RLECompression:\n          default:\n          {\n            MemoryInfo\n              *pixel_info;\n\n            /*\n              Allocate pixel array.\n            */\n            length=(size_t) number_pixels;\n            pixel_info=AcquireVirtualMemory(length,sizeof(*pixels));\n            if (pixel_info == (MemoryInfo *) NULL)\n              ThrowPDFException(ResourceLimitError,\"MemoryAllocationFailed\");\n            pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n            /*\n              Dump Runlength encoded pixels.\n            */\n            q=pixels;\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                *q++=ScaleQuantumToChar(ClampToQuantum(GetPixelLuma(image,p)));\n                p+=GetPixelChannels(image);\n              }\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n            if (compression == ZipCompression)\n              status=ZLIBEncodeImage(image,length,pixels,exception);\n            else\n#endif\n              if (compression == LZWCompression)\n                status=LZWEncodeImage(image,length,pixels,exception);\n              else\n                status=PackbitsEncodeImage(image,length,pixels,exception);\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            if (status == MagickFalse)\n              {\n                xref=(MagickOffsetType *) RelinquishMagickMemory(xref);\n                (void) CloseBlob(image);\n                return(MagickFalse);\n              }\n            break;\n          }\n          case NoCompression:\n          {\n            /*\n              Dump uncompressed PseudoColor packets.\n            */\n            Ascii85Initialize(image);\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                Ascii85Encode(image,ScaleQuantumToChar(ClampToQuantum(\n                  GetPixelLuma(image,p))));\n                p+=GetPixelChannels(image);\n              }\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            Ascii85Flush(image);\n            break;\n          }\n        }\n      }\n    else\n      if ((image->storage_class == DirectClass) || (image->colors > 256) ||\n          (compression == JPEGCompression) ||\n          (compression == JPEG2000Compression))\n        switch (compression)\n        {\n          case JPEGCompression:\n          {\n            status=InjectImageBlob(image_info,image,image,\"jpeg\",exception);\n            if (status == MagickFalse)\n              {\n                xref=(MagickOffsetType *) RelinquishMagickMemory(xref);\n                (void) CloseBlob(image);\n                return(MagickFalse);\n              }\n            break;\n          }\n          case JPEG2000Compression:\n          {\n            status=InjectImageBlob(image_info,image,image,\"jp2\",exception);\n            if (status == MagickFalse)\n              {\n                xref=(MagickOffsetType *) RelinquishMagickMemory(xref);\n                (void) CloseBlob(image);\n                return(MagickFalse);\n              }\n            break;\n          }\n          case RLECompression:\n          default:\n          {\n            MemoryInfo\n              *pixel_info;\n\n            /*\n              Allocate pixel array.\n            */\n            length=(size_t) number_pixels;\n            length*=image->colorspace == CMYKColorspace ? 4UL : 3UL;\n            pixel_info=AcquireVirtualMemory(length,sizeof(*pixels));\n            if (pixel_info == (MemoryInfo *) NULL)\n              ThrowPDFException(ResourceLimitError,\"MemoryAllocationFailed\");\n            pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n            /*\n              Dump runoffset encoded pixels.\n            */\n            q=pixels;\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                *q++=ScaleQuantumToChar(GetPixelRed(image,p));\n                *q++=ScaleQuantumToChar(GetPixelGreen(image,p));\n                *q++=ScaleQuantumToChar(GetPixelBlue(image,p));\n                if (image->colorspace == CMYKColorspace)\n                  *q++=ScaleQuantumToChar(GetPixelBlack(image,p));\n                p+=GetPixelChannels(image);\n              }\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n            if (compression == ZipCompression)\n              status=ZLIBEncodeImage(image,length,pixels,exception);\n            else\n#endif\n              if (compression == LZWCompression)\n                status=LZWEncodeImage(image,length,pixels,exception);\n              else\n                status=PackbitsEncodeImage(image,length,pixels,exception);\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            if (status == MagickFalse)\n              {\n                xref=(MagickOffsetType *) RelinquishMagickMemory(xref);\n                (void) CloseBlob(image);\n                return(MagickFalse);\n              }\n            break;\n          }\n          case NoCompression:\n          {\n            /*\n              Dump uncompressed DirectColor packets.\n            */\n            Ascii85Initialize(image);\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                Ascii85Encode(image,ScaleQuantumToChar(GetPixelRed(image,p)));\n                Ascii85Encode(image,ScaleQuantumToChar(GetPixelGreen(image,p)));\n                Ascii85Encode(image,ScaleQuantumToChar(GetPixelBlue(image,p)));\n                if (image->colorspace == CMYKColorspace)\n                  Ascii85Encode(image,ScaleQuantumToChar(\n                    GetPixelBlack(image,p)));\n                p+=GetPixelChannels(image);\n              }\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            Ascii85Flush(image);\n            break;\n          }\n        }\n      else\n        {\n          /*\n            Dump number of colors and colormap.\n          */\n          switch (compression)\n          {\n            case RLECompression:\n            default:\n            {\n              MemoryInfo\n                *pixel_info;\n\n              /*\n                Allocate pixel array.\n              */\n              length=(size_t) number_pixels;\n              pixel_info=AcquireVirtualMemory(length,sizeof(*pixels));\n              if (pixel_info == (MemoryInfo *) NULL)\n                ThrowPDFException(ResourceLimitError,\"MemoryAllocationFailed\");\n              pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n              /*\n                Dump Runlength encoded pixels.\n              */\n              q=pixels;\n              for (y=0; y < (ssize_t) image->rows; y++)\n              {\n                p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n                if (p == (const Quantum *) NULL)\n                  break;\n                for (x=0; x < (ssize_t) image->columns; x++)\n                {\n                  *q++=(unsigned char) ((ssize_t) GetPixelIndex(image,p));\n                  p+=GetPixelChannels(image);\n                }\n                if (image->previous == (Image *) NULL)\n                  {\n                    status=SetImageProgress(image,SaveImageTag,\n                      (MagickOffsetType) y,image->rows);\n                    if (status == MagickFalse)\n                      break;\n                  }\n              }\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n              if (compression == ZipCompression)\n                status=ZLIBEncodeImage(image,length,pixels,exception);\n              else\n#endif\n                if (compression == LZWCompression)\n                  status=LZWEncodeImage(image,length,pixels,exception);\n                else\n                  status=PackbitsEncodeImage(image,length,pixels,exception);\n              pixel_info=RelinquishVirtualMemory(pixel_info);\n              if (status == MagickFalse)\n                {\n                  xref=(MagickOffsetType *) RelinquishMagickMemory(xref);\n                  (void) CloseBlob(image);\n                  return(MagickFalse);\n                }\n              break;\n            }\n            case NoCompression:\n            {\n              /*\n                Dump uncompressed PseudoColor packets.\n              */\n              Ascii85Initialize(image);\n              for (y=0; y < (ssize_t) image->rows; y++)\n              {\n                p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n                if (p == (const Quantum *) NULL)\n                  break;\n                for (x=0; x < (ssize_t) image->columns; x++)\n                {\n                  Ascii85Encode(image,(unsigned char) ((ssize_t)\n                    GetPixelIndex(image,p)));\n                  p+=GetPixelChannels(image);\n                }\n                if (image->previous == (Image *) NULL)\n                  {\n                    status=SetImageProgress(image,SaveImageTag,\n                      (MagickOffsetType) y,image->rows);\n                    if (status == MagickFalse)\n                      break;\n                  }\n              }\n              Ascii85Flush(image);\n              break;\n            }\n          }\n        }\n    offset=TellBlob(image)-offset;\n    (void) WriteBlobString(image,\"\\nendstream\\n\");\n    (void) WriteBlobString(image,\"endobj\\n\");\n    /*\n      Write Length object.\n    */\n    xref[object++]=TellBlob(image);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n      object);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g\\n\",(double)\n      offset);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\"endobj\\n\");\n    /*\n      Write Colorspace object.\n    */\n    xref[object++]=TellBlob(image);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n      object);\n    (void) WriteBlobString(image,buffer);\n    device=\"DeviceRGB\";\n    channels=0;\n    if (image->colorspace == CMYKColorspace)\n      {\n        device=\"DeviceCMYK\";\n        channels=4;\n      }\n    else\n      if ((compression == FaxCompression) ||\n          (compression == Group4Compression) ||\n          ((image_info->type != TrueColorType) &&\n           (SetImageGray(image,exception) != MagickFalse)))\n        {\n          device=\"DeviceGray\";\n          channels=1;\n        }\n      else\n        if ((image->storage_class == DirectClass) ||\n            (image->colors > 256) || (compression == JPEGCompression) ||\n            (compression == JPEG2000Compression))\n          {\n            device=\"DeviceRGB\";\n            channels=3;\n          }\n    profile=GetImageProfile(image,\"icc\");\n    if ((profile == (StringInfo *) NULL) || (channels == 0))\n      {\n        if (channels != 0)\n          (void) FormatLocaleString(buffer,MagickPathExtent,\"/%s\\n\",device);\n        else\n          (void) FormatLocaleString(buffer,MagickPathExtent,\n            \"[ /Indexed /%s %.20g %.20g 0 R ]\\n\",device,(double) image->colors-\n            1,(double) object+3);\n        (void) WriteBlobString(image,buffer);\n      }\n    else\n      {\n        const unsigned char\n          *p;\n\n        /*\n          Write ICC profile. \n        */\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"[/ICCBased %.20g 0 R]\\n\",(double) object+1);\n        (void) WriteBlobString(image,buffer);\n        (void) WriteBlobString(image,\"endobj\\n\");\n        xref[object++]=TellBlob(image);\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",\n          (double) object);\n        (void) WriteBlobString(image,buffer);\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"<<\\n/N %.20g\\n\"\n          \"/Filter /ASCII85Decode\\n/Length %.20g 0 R\\n/Alternate /%s\\n>>\\n\"\n          \"stream\\n\",(double) channels,(double) object+1,device);\n        (void) WriteBlobString(image,buffer);\n        offset=TellBlob(image);\n        Ascii85Initialize(image);\n        p=GetStringInfoDatum(profile);\n        for (i=0; i < (ssize_t) GetStringInfoLength(profile); i++)\n          Ascii85Encode(image,(unsigned char) *p++);\n        Ascii85Flush(image);\n        offset=TellBlob(image)-offset;\n        (void) WriteBlobString(image,\"endstream\\n\");\n        (void) WriteBlobString(image,\"endobj\\n\");\n        /*\n          Write Length object.\n        */\n        xref[object++]=TellBlob(image);\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",\n          (double) object);\n        (void) WriteBlobString(image,buffer);\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g\\n\",(double)\n          offset);\n        (void) WriteBlobString(image,buffer);\n      }\n    (void) WriteBlobString(image,\"endobj\\n\");\n    /*\n      Write Thumb object.\n    */\n    SetGeometry(image,&geometry);\n    (void) ParseMetaGeometry(\"106x106+0+0>\",&geometry.x,&geometry.y,\n      &geometry.width,&geometry.height);\n    tile_image=ThumbnailImage(image,geometry.width,geometry.height,exception);\n    if (tile_image == (Image *) NULL)\n      return(MagickFalse);\n    xref[object++]=TellBlob(image);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n      object);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\"<<\\n\");\n    switch (compression)\n    {\n      case NoCompression:\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,CFormat,\n          \"ASCII85Decode\");\n        break;\n      }\n      case JPEGCompression:\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,CFormat,\"DCTDecode\");\n        if (image->colorspace != CMYKColorspace)\n          break;\n        (void) WriteBlobString(image,buffer);\n        (void) CopyMagickString(buffer,\"/Decode [1 0 1 0 1 0 1 0]\\n\",\n          MagickPathExtent);\n        break;\n      }\n      case JPEG2000Compression:\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,CFormat,\"JPXDecode\");\n        if (image->colorspace != CMYKColorspace)\n          break;\n        (void) WriteBlobString(image,buffer);\n        (void) CopyMagickString(buffer,\"/Decode [1 0 1 0 1 0 1 0]\\n\",\n          MagickPathExtent);\n        break;\n      }\n      case LZWCompression:\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,CFormat,\"LZWDecode\");\n        break;\n      }\n      case ZipCompression:\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,CFormat,\n          \"FlateDecode\");\n        break;\n      }\n      case FaxCompression:\n      case Group4Compression:\n      {\n        (void) CopyMagickString(buffer,\"/Filter [ /CCITTFaxDecode ]\\n\",\n          MagickPathExtent);\n        (void) WriteBlobString(image,buffer);\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"/DecodeParms [ << \"\n          \"/K %s /BlackIs1 false /Columns %.20g /Rows %.20g >> ]\\n\",CCITTParam,\n          (double) tile_image->columns,(double) tile_image->rows);\n        break;\n      }\n      default:\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,CFormat,\n          \"RunLengthDecode\");\n        break;\n      }\n    }\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/Width %.20g\\n\",(double)\n      tile_image->columns);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/Height %.20g\\n\",(double)\n      tile_image->rows);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/ColorSpace %.20g 0 R\\n\",\n      (double) object-(has_icc_profile != MagickFalse ? 3 : 1));\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/BitsPerComponent %d\\n\",\n      (compression == FaxCompression) || (compression == Group4Compression) ?\n      1 : 8);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/Length %.20g 0 R\\n\",\n      (double) object+1);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\">>\\n\");\n    (void) WriteBlobString(image,\"stream\\n\");\n    offset=TellBlob(image);\n    number_pixels=(MagickSizeType) tile_image->columns*tile_image->rows;\n    if ((compression == FaxCompression) ||\n        (compression == Group4Compression) ||\n        ((image_info->type != TrueColorType) &&\n         (SetImageGray(tile_image,exception) != MagickFalse)))\n      {\n        switch (compression)\n        {\n          case FaxCompression:\n          case Group4Compression:\n          {\n            if (LocaleCompare(CCITTParam,\"0\") == 0)\n              {\n                (void) HuffmanEncodeImage(image_info,image,tile_image,\n                  exception);\n                break;\n              }\n            (void) Huffman2DEncodeImage(image_info,image,tile_image,exception);\n            break;\n          }\n          case JPEGCompression:\n          {\n            status=InjectImageBlob(image_info,image,tile_image,\"jpeg\",\n              exception);\n            if (status == MagickFalse)\n              {\n                xref=(MagickOffsetType *) RelinquishMagickMemory(xref);\n                (void) CloseBlob(image);\n                return(MagickFalse);\n              }\n            break;\n          }\n          case JPEG2000Compression:\n          {\n            status=InjectImageBlob(image_info,image,tile_image,\"jp2\",exception);\n            if (status == MagickFalse)\n              {\n                xref=(MagickOffsetType *) RelinquishMagickMemory(xref);\n                (void) CloseBlob(image);\n                return(MagickFalse);\n              }\n            break;\n          }\n          case RLECompression:\n          default:\n          {\n            MemoryInfo\n              *pixel_info;\n\n            /*\n              Allocate pixel array.\n            */\n            length=(size_t) number_pixels;\n            pixel_info=AcquireVirtualMemory(length,sizeof(*pixels));\n            if (pixel_info == (MemoryInfo *) NULL)\n              {\n                tile_image=DestroyImage(tile_image);\n                ThrowPDFException(ResourceLimitError,\"MemoryAllocationFailed\");\n              }\n            pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n            /*\n              Dump runlength encoded pixels.\n            */\n            q=pixels;\n            for (y=0; y < (ssize_t) tile_image->rows; y++)\n            {\n              p=GetVirtualPixels(tile_image,0,y,tile_image->columns,1,\n                exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) tile_image->columns; x++)\n              {\n                *q++=ScaleQuantumToChar(ClampToQuantum(GetPixelLuma(\n                  tile_image,p)));\n                p+=GetPixelChannels(tile_image);\n              }\n            }\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n            if (compression == ZipCompression)\n              status=ZLIBEncodeImage(image,length,pixels,exception);\n            else\n#endif\n              if (compression == LZWCompression)\n                status=LZWEncodeImage(image,length,pixels,exception);\n              else\n                status=PackbitsEncodeImage(image,length,pixels,exception);\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            if (status == MagickFalse)\n              {\n                xref=(MagickOffsetType *) RelinquishMagickMemory(xref);\n                (void) CloseBlob(image);\n                return(MagickFalse);\n              }\n            break;\n          }\n          case NoCompression:\n          {\n            /*\n              Dump uncompressed PseudoColor packets.\n            */\n            Ascii85Initialize(image);\n            for (y=0; y < (ssize_t) tile_image->rows; y++)\n            {\n              p=GetVirtualPixels(tile_image,0,y,tile_image->columns,1,\n                exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) tile_image->columns; x++)\n              {\n                Ascii85Encode(image,ScaleQuantumToChar(ClampToQuantum(\n                  GetPixelLuma(tile_image,p))));\n                p+=GetPixelChannels(tile_image);\n              }\n            }\n            Ascii85Flush(image);\n            break;\n          }\n        }\n      }\n    else\n      if ((tile_image->storage_class == DirectClass) ||\n          (tile_image->colors > 256) || (compression == JPEGCompression) ||\n          (compression == JPEG2000Compression))\n        switch (compression)\n        {\n          case JPEGCompression:\n          {\n            status=InjectImageBlob(image_info,image,tile_image,\"jpeg\",\n              exception);\n            if (status == MagickFalse)\n              {\n                xref=(MagickOffsetType *) RelinquishMagickMemory(xref);\n                (void) CloseBlob(image);\n                return(MagickFalse);\n              }\n            break;\n          }\n          case JPEG2000Compression:\n          {\n            status=InjectImageBlob(image_info,image,tile_image,\"jp2\",exception);\n            if (status == MagickFalse)\n              {\n                xref=(MagickOffsetType *) RelinquishMagickMemory(xref);\n                (void) CloseBlob(image);\n                return(MagickFalse);\n              }\n            break;\n          }\n          case RLECompression:\n          default:\n          {\n            MemoryInfo\n              *pixel_info;\n\n            /*\n              Allocate pixel array.\n            */\n            length=(size_t) number_pixels;\n            length*=tile_image->colorspace == CMYKColorspace ? 4UL : 3UL;\n            pixel_info=AcquireVirtualMemory(length,4*sizeof(*pixels));\n            if (pixel_info == (MemoryInfo *) NULL)\n              {\n                tile_image=DestroyImage(tile_image);\n                ThrowPDFException(ResourceLimitError,\"MemoryAllocationFailed\");\n              }\n            pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n            /*\n              Dump runlength encoded pixels.\n            */\n            q=pixels;\n            for (y=0; y < (ssize_t) tile_image->rows; y++)\n            {\n              p=GetVirtualPixels(tile_image,0,y,tile_image->columns,1,\n                exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) tile_image->columns; x++)\n              {\n                *q++=ScaleQuantumToChar(GetPixelRed(tile_image,p));\n                *q++=ScaleQuantumToChar(GetPixelGreen(tile_image,p));\n                *q++=ScaleQuantumToChar(GetPixelBlue(tile_image,p));\n                if (tile_image->colorspace == CMYKColorspace)\n                  *q++=ScaleQuantumToChar(GetPixelBlack(tile_image,p));\n                p+=GetPixelChannels(tile_image);\n              }\n            }\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n            if (compression == ZipCompression)\n              status=ZLIBEncodeImage(image,length,pixels,exception);\n            else\n#endif\n              if (compression == LZWCompression)\n                status=LZWEncodeImage(image,length,pixels,exception);\n              else\n                status=PackbitsEncodeImage(image,length,pixels,exception);\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            if (status == MagickFalse)\n              {\n                xref=(MagickOffsetType *) RelinquishMagickMemory(xref);\n                (void) CloseBlob(image);\n                return(MagickFalse);\n              }\n            break;\n          }\n          case NoCompression:\n          {\n            /*\n              Dump uncompressed DirectColor packets.\n            */\n            Ascii85Initialize(image);\n            for (y=0; y < (ssize_t) tile_image->rows; y++)\n            {\n              p=GetVirtualPixels(tile_image,0,y,tile_image->columns,1,\n                exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) tile_image->columns; x++)\n              {\n                Ascii85Encode(image,ScaleQuantumToChar(\n                  GetPixelRed(tile_image,p)));\n                Ascii85Encode(image,ScaleQuantumToChar(\n                  GetPixelGreen(tile_image,p)));\n                Ascii85Encode(image,ScaleQuantumToChar(\n                  GetPixelBlue(tile_image,p)));\n                if (image->colorspace == CMYKColorspace)\n                  Ascii85Encode(image,ScaleQuantumToChar(\n                    GetPixelBlack(tile_image,p)));\n                p+=GetPixelChannels(tile_image);\n              }\n            }\n            Ascii85Flush(image);\n            break;\n          }\n        }\n      else\n        {\n          /*\n            Dump number of colors and colormap.\n          */\n          switch (compression)\n          {\n            case RLECompression:\n            default:\n            {\n              MemoryInfo\n                *pixel_info;\n\n              /*\n                Allocate pixel array.\n              */\n              length=(size_t) number_pixels;\n              pixel_info=AcquireVirtualMemory(length,sizeof(*pixels));\n              if (pixel_info == (MemoryInfo *) NULL)\n                {\n                  tile_image=DestroyImage(tile_image);\n                  ThrowPDFException(ResourceLimitError,\n                    \"MemoryAllocationFailed\");\n                }\n              pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n              /*\n                Dump runlength encoded pixels.\n              */\n              q=pixels;\n              for (y=0; y < (ssize_t) tile_image->rows; y++)\n              {\n                p=GetVirtualPixels(tile_image,0,y,tile_image->columns,1,\n                  exception);\n                if (p == (const Quantum *) NULL)\n                  break;\n                for (x=0; x < (ssize_t) tile_image->columns; x++)\n                {\n                  *q++=(unsigned char) ((ssize_t) GetPixelIndex(tile_image,p));\n                  p+=GetPixelChannels(tile_image);\n                }\n              }\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n              if (compression == ZipCompression)\n                status=ZLIBEncodeImage(image,length,pixels,exception);\n              else\n#endif\n                if (compression == LZWCompression)\n                  status=LZWEncodeImage(image,length,pixels,exception);\n                else\n                  status=PackbitsEncodeImage(image,length,pixels,exception);\n              pixel_info=RelinquishVirtualMemory(pixel_info);\n              if (status == MagickFalse)\n                {\n                  xref=(MagickOffsetType *) RelinquishMagickMemory(xref);\n                  (void) CloseBlob(image);\n                  return(MagickFalse);\n                }\n              break;\n            }\n            case NoCompression:\n            {\n              /*\n                Dump uncompressed PseudoColor packets.\n              */\n              Ascii85Initialize(image);\n              for (y=0; y < (ssize_t) tile_image->rows; y++)\n              {\n                p=GetVirtualPixels(tile_image,0,y,tile_image->columns,1,\n                  exception);\n                if (p == (const Quantum *) NULL)\n                  break;\n                for (x=0; x < (ssize_t) tile_image->columns; x++)\n                {\n                  Ascii85Encode(image,(unsigned char)\n                    ((ssize_t) GetPixelIndex(tile_image,p)));\n                  p+=GetPixelChannels(image);\n                }\n              }\n              Ascii85Flush(image);\n              break;\n            }\n          }\n        }\n    tile_image=DestroyImage(tile_image);\n    offset=TellBlob(image)-offset;\n    (void) WriteBlobString(image,\"\\nendstream\\n\");\n    (void) WriteBlobString(image,\"endobj\\n\");\n    /*\n      Write Length object.\n    */\n    xref[object++]=TellBlob(image);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n      object);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g\\n\",(double)\n      offset);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\"endobj\\n\");\n    xref[object++]=TellBlob(image);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n      object);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\"<<\\n\");\n    if ((image->storage_class == DirectClass) || (image->colors > 256) ||\n        (compression == FaxCompression) || (compression == Group4Compression))\n      (void) WriteBlobString(image,\">>\\n\");\n    else\n      {\n        /*\n          Write Colormap object.\n        */\n        if (compression == NoCompression)\n          (void) WriteBlobString(image,\"/Filter [ /ASCII85Decode ]\\n\");\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"/Length %.20g 0 R\\n\",\n          (double) object+1);\n        (void) WriteBlobString(image,buffer);\n        (void) WriteBlobString(image,\">>\\n\");\n        (void) WriteBlobString(image,\"stream\\n\");\n        offset=TellBlob(image);\n        if (compression == NoCompression)\n          Ascii85Initialize(image);\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          if (compression == NoCompression)\n            {\n              Ascii85Encode(image,ScaleQuantumToChar(ClampToQuantum(\n                image->colormap[i].red)));\n              Ascii85Encode(image,ScaleQuantumToChar(ClampToQuantum(\n                image->colormap[i].green)));\n              Ascii85Encode(image,ScaleQuantumToChar(ClampToQuantum(\n                image->colormap[i].blue)));\n              continue;\n            }\n          (void) WriteBlobByte(image,ScaleQuantumToChar(\n             ClampToQuantum(image->colormap[i].red)));\n          (void) WriteBlobByte(image,ScaleQuantumToChar(\n             ClampToQuantum(image->colormap[i].green)));\n          (void) WriteBlobByte(image,ScaleQuantumToChar(\n             ClampToQuantum(image->colormap[i].blue)));\n        }\n        if (compression == NoCompression)\n          Ascii85Flush(image);\n       offset=TellBlob(image)-offset;\n       (void) WriteBlobString(image,\"\\nendstream\\n\");\n      }\n    (void) WriteBlobString(image,\"endobj\\n\");\n    /*\n      Write Length object.\n    */\n    xref[object++]=TellBlob(image);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n      object);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g\\n\",(double)\n      offset);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\"endobj\\n\");\n    /*\n      Write softmask object.\n    */\n    xref[object++]=TellBlob(image);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n      object);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\"<<\\n\");\n    if (image->alpha_trait == UndefinedPixelTrait)\n      (void) WriteBlobString(image,\">>\\n\");\n    else\n      {\n        (void) WriteBlobString(image,\"/Type /XObject\\n\");\n        (void) WriteBlobString(image,\"/Subtype /Image\\n\");\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"/Name /Ma%.20g\\n\",\n          (double) image->scene);\n        (void) WriteBlobString(image,buffer);\n        switch (compression)\n        {\n          case NoCompression:\n          {\n            (void) FormatLocaleString(buffer,MagickPathExtent,CFormat,\n              \"ASCII85Decode\");\n            break;\n          }\n          case LZWCompression:\n          {\n            (void) FormatLocaleString(buffer,MagickPathExtent,CFormat,\n              \"LZWDecode\");\n            break;\n          }\n          case ZipCompression:\n          {\n            (void) FormatLocaleString(buffer,MagickPathExtent,CFormat,\n              \"FlateDecode\");\n            break;\n          }\n          default:\n          {\n            (void) FormatLocaleString(buffer,MagickPathExtent,CFormat,\n              \"RunLengthDecode\");\n            break;\n          }\n        }\n        (void) WriteBlobString(image,buffer);\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"/Width %.20g\\n\",\n          (double) image->columns);\n        (void) WriteBlobString(image,buffer);\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"/Height %.20g\\n\",\n          (double) image->rows);\n        (void) WriteBlobString(image,buffer);\n        (void) WriteBlobString(image,\"/ColorSpace /DeviceGray\\n\");\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"/BitsPerComponent %d\\n\",(compression == FaxCompression) ||\n          (compression == Group4Compression) ? 1 : 8);\n        (void) WriteBlobString(image,buffer);\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"/Length %.20g 0 R\\n\",\n          (double) object+1);\n        (void) WriteBlobString(image,buffer);\n        (void) WriteBlobString(image,\">>\\n\");\n        (void) WriteBlobString(image,\"stream\\n\");\n        offset=TellBlob(image);\n        number_pixels=(MagickSizeType) image->columns*image->rows;\n        switch (compression)\n        {\n          case RLECompression:\n          default:\n          {\n            MemoryInfo\n              *pixel_info;\n\n            /*\n              Allocate pixel array.\n            */\n            length=(size_t) number_pixels;\n            pixel_info=AcquireVirtualMemory(length,4*sizeof(*pixels));\n            if (pixel_info == (MemoryInfo *) NULL)\n              {\n                image=DestroyImage(image);\n                ThrowPDFException(ResourceLimitError,\"MemoryAllocationFailed\");\n              }\n            pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n            /*\n              Dump Runlength encoded pixels.\n            */\n            q=pixels;\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                *q++=ScaleQuantumToChar(GetPixelAlpha(image,p));\n                p+=GetPixelChannels(image);\n              }\n            }\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n            if (compression == ZipCompression)\n              status=ZLIBEncodeImage(image,length,pixels,exception);\n            else\n#endif\n              if (compression == LZWCompression)\n                status=LZWEncodeImage(image,length,pixels,exception);\n              else\n                status=PackbitsEncodeImage(image,length,pixels,exception);\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            if (status == MagickFalse)\n              {\n                xref=(MagickOffsetType *) RelinquishMagickMemory(xref);\n                (void) CloseBlob(image);\n                return(MagickFalse);\n              }\n            break;\n          }\n          case NoCompression:\n          {\n            /*\n              Dump uncompressed PseudoColor packets.\n            */\n            Ascii85Initialize(image);\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                Ascii85Encode(image,ScaleQuantumToChar(GetPixelAlpha(image,p)));\n                p+=GetPixelChannels(image);\n              }\n            }\n            Ascii85Flush(image);\n            break;\n          }\n        }\n        offset=TellBlob(image)-offset;\n        (void) WriteBlobString(image,\"\\nendstream\\n\");\n      }\n    (void) WriteBlobString(image,\"endobj\\n\");\n    /*\n      Write Length object.\n    */\n    xref[object++]=TellBlob(image);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n      object);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g\\n\",(double)\n      offset);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\"endobj\\n\");\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,imageListLength);\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  /*\n    Write Metadata object.\n  */\n  xref[object++]=TellBlob(image);\n  info_id=object;\n  (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n    object);\n  (void) WriteBlobString(image,buffer);\n  (void) WriteBlobString(image,\"<<\\n\");\n  if (LocaleCompare(image_info->magick,\"PDFA\") == 0)\n    {\n      escape=EscapeParenthesis(basename);\n      (void) FormatLocaleString(buffer,MagickPathExtent,\"/Title (%s)\\n\",\n        escape);\n      escape=DestroyString(escape);\n    }\n  else\n    {\n      wchar_t\n        *utf16;\n\n      utf16=ConvertUTF8ToUTF16((unsigned char *) basename,&length);\n      if (utf16 != (wchar_t *) NULL)\n        {\n          unsigned char\n            hex_digits[16];\n\n          hex_digits[0]='0';\n          hex_digits[1]='1';\n          hex_digits[2]='2';\n          hex_digits[3]='3';\n          hex_digits[4]='4';\n          hex_digits[5]='5';\n          hex_digits[6]='6';\n          hex_digits[7]='7';\n          hex_digits[8]='8';\n          hex_digits[9]='9';\n          hex_digits[10]='A';\n          hex_digits[11]='B';\n          hex_digits[12]='C';\n          hex_digits[13]='D';\n          hex_digits[14]='E';\n          hex_digits[15]='F';\n          (void) FormatLocaleString(buffer,MagickPathExtent,\"/Title <FEFF\");\n          (void) WriteBlobString(image,buffer);\n          for (i=0; i < (ssize_t) length; i++)\n          {\n            (void) WriteBlobByte(image,'0');\n            (void) WriteBlobByte(image,'0');\n            (void) WriteBlobByte(image,hex_digits[(utf16[i] >> 4) & 0x0f]);\n            (void) WriteBlobByte(image,hex_digits[utf16[i] & 0x0f]);\n          }\n          (void) FormatLocaleString(buffer,MagickPathExtent,\">\\n\");\n          utf16=(wchar_t *) RelinquishMagickMemory(utf16);\n        }\n    }\n  (void) WriteBlobString(image,buffer);\n  seconds=GetMagickTime();\n  GetMagickUTCtime(&seconds,&utc_time);\n  (void) FormatLocaleString(date,MagickPathExtent,\"D:%04d%02d%02d%02d%02d%02d\",\n    utc_time.tm_year+1900,utc_time.tm_mon+1,utc_time.tm_mday,\n    utc_time.tm_hour,utc_time.tm_min,utc_time.tm_sec);\n  (void) FormatLocaleString(buffer,MagickPathExtent,\"/CreationDate (%s)\\n\",\n    date);\n  (void) WriteBlobString(image,buffer);\n  (void) FormatLocaleString(buffer,MagickPathExtent,\"/ModDate (%s)\\n\",date);\n  (void) WriteBlobString(image,buffer);\n  url=(char *) MagickAuthoritativeURL;\n  escape=EscapeParenthesis(url);\n  (void) FormatLocaleString(buffer,MagickPathExtent,\"/Producer (%s)\\n\",escape);\n  escape=DestroyString(escape);\n  (void) WriteBlobString(image,buffer);\n  (void) WriteBlobString(image,\">>\\n\");\n  (void) WriteBlobString(image,\"endobj\\n\");\n  /*\n    Write Xref object.\n  */\n  offset=TellBlob(image)-xref[0]+\n   (LocaleCompare(image_info->magick,\"PDFA\") == 0 ? 6 : 0)+10;\n  (void) WriteBlobString(image,\"xref\\n\");\n  (void) FormatLocaleString(buffer,MagickPathExtent,\"0 %.20g\\n\",(double)\n    object+1);\n  (void) WriteBlobString(image,buffer);\n  (void) WriteBlobString(image,\"0000000000 65535 f \\n\");\n  for (i=0; i < (ssize_t) object; i++)\n  {\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%010lu 00000 n \\n\",\n      (unsigned long) xref[i]);\n    (void) WriteBlobString(image,buffer);\n  }\n  (void) WriteBlobString(image,\"trailer\\n\");\n  (void) WriteBlobString(image,\"<<\\n\");\n  (void) FormatLocaleString(buffer,MagickPathExtent,\"/Size %.20g\\n\",(double)\n    object+1);\n  (void) WriteBlobString(image,buffer);\n  (void) FormatLocaleString(buffer,MagickPathExtent,\"/Info %.20g 0 R\\n\",(double)\n    info_id);\n  (void) WriteBlobString(image,buffer);\n  (void) FormatLocaleString(buffer,MagickPathExtent,\"/Root %.20g 0 R\\n\",(double)\n    root_id);\n  (void) WriteBlobString(image,buffer);\n  (void) SignatureImage(image,exception);\n  (void) FormatLocaleString(buffer,MagickPathExtent,\"/ID [<%s> <%s>]\\n\",\n    GetImageProperty(image,\"signature\",exception),\n    GetImageProperty(image,\"signature\",exception));\n  (void) WriteBlobString(image,buffer);\n  (void) WriteBlobString(image,\">>\\n\");\n  (void) WriteBlobString(image,\"startxref\\n\");\n  (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g\\n\",(double) offset);\n  (void) WriteBlobString(image,buffer);\n  (void) WriteBlobString(image,\"%%EOF\\n\");\n  xref=(MagickOffsetType *) RelinquishMagickMemory(xref);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146099,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "sds _sdsMakeRoomFor(sds s, size_t addlen, int greedy) {\n    void *sh, *newsh;\n    size_t avail = sdsavail(s);\n    size_t len, newlen;\n    char type, oldtype = s[-1] & SDS_TYPE_MASK;\n    int hdrlen;\n    size_t usable;\n\n    /* Return ASAP if there is enough space left. */\n    if (avail >= addlen) return s;\n\n    len = sdslen(s);\n    sh = (char*)s-sdsHdrSize(oldtype);\n    newlen = (len+addlen);\n    assert(newlen > len);   /* Catch size_t overflow */\n    if (greedy == 1) {\n        if (newlen < SDS_MAX_PREALLOC)\n            newlen *= 2;\n        else\n            newlen += SDS_MAX_PREALLOC;\n    }\n\n    type = sdsReqType(newlen);\n\n    /* Don't use type 5: the user is appending to the string and type 5 is\n     * not able to remember empty space, so sdsMakeRoomFor() must be called\n     * at every appending operation. */\n    if (type == SDS_TYPE_5) type = SDS_TYPE_8;\n\n    hdrlen = sdsHdrSize(type);\n    assert(hdrlen + newlen + 1 > len);  /* Catch size_t overflow */\n    if (oldtype==type) {\n        newsh = s_realloc_usable(sh, hdrlen+newlen+1, &usable);\n        if (newsh == NULL) return NULL;\n        s = (char*)newsh+hdrlen;\n    } else {\n        /* Since the header size changes, need to move the string forward,\n         * and can't use realloc */\n        newsh = s_malloc_usable(hdrlen+newlen+1, &usable);\n        if (newsh == NULL) return NULL;\n        memcpy((char*)newsh+hdrlen, s, len+1);\n        s_free(sh);\n        s = (char*)newsh+hdrlen;\n        s[-1] = type;\n        sdssetlen(s, len);\n    }\n    usable = usable-hdrlen-1;\n    if (usable > sdsTypeMaxSize(type))\n        usable = sdsTypeMaxSize(type);\n    sdssetalloc(s, usable);\n    return s;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146128,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "sds _sdsMakeRoomFor(sds s, size_t addlen, int greedy) {\n    void *sh, *newsh;\n    size_t avail = sdsavail(s);\n    size_t len, newlen, reqlen;\n    char type, oldtype = s[-1] & SDS_TYPE_MASK;\n    int hdrlen;\n    size_t usable;\n\n    /* Return ASAP if there is enough space left. */\n    if (avail >= addlen) return s;\n\n    len = sdslen(s);\n    sh = (char*)s-sdsHdrSize(oldtype);\n    reqlen = newlen = (len+addlen);\n    assert(newlen > len);   /* Catch size_t overflow */\n    if (greedy == 1) {\n        if (newlen < SDS_MAX_PREALLOC)\n            newlen *= 2;\n        else\n            newlen += SDS_MAX_PREALLOC;\n    }\n\n    type = sdsReqType(newlen);\n\n    /* Don't use type 5: the user is appending to the string and type 5 is\n     * not able to remember empty space, so sdsMakeRoomFor() must be called\n     * at every appending operation. */\n    if (type == SDS_TYPE_5) type = SDS_TYPE_8;\n\n    hdrlen = sdsHdrSize(type);\n    assert(hdrlen + newlen + 1 > reqlen);  /* Catch size_t overflow */\n    if (oldtype==type) {\n        newsh = s_realloc_usable(sh, hdrlen+newlen+1, &usable);\n        if (newsh == NULL) return NULL;\n        s = (char*)newsh+hdrlen;\n    } else {\n        /* Since the header size changes, need to move the string forward,\n         * and can't use realloc */\n        newsh = s_malloc_usable(hdrlen+newlen+1, &usable);\n        if (newsh == NULL) return NULL;\n        memcpy((char*)newsh+hdrlen, s, len+1);\n        s_free(sh);\n        s = (char*)newsh+hdrlen;\n        s[-1] = type;\n        sdssetlen(s, len);\n    }\n    usable = usable-hdrlen-1;\n    if (usable > sdsTypeMaxSize(type))\n        usable = sdsTypeMaxSize(type);\n    sdssetalloc(s, usable);\n    return s;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146129,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "load_image (const gchar  *filename,\n            GError      **error)\n{\n  FILE         *fd;\n  GimpDrawable *drawable;\n  GimpPixelRgn  pixel_rgn;\n  guint16       offset_x, offset_y, bytesperline;\n  gint32        width, height;\n  gint32        image, layer;\n  guchar       *dest, cmap[768];\n  guint8        header_buf[128];\n\n  fd = g_fopen (filename, \"rb\");\n\n  if (! fd)\n    {\n      g_set_error (error, G_FILE_ERROR, g_file_error_from_errno (errno),\n                   _(\"Could not open '%s' for reading: %s\"),\n                   gimp_filename_to_utf8 (filename), g_strerror (errno));\n      return -1;\n    }\n\n  gimp_progress_init_printf (_(\"Opening '%s'\"),\n                             gimp_filename_to_utf8 (filename));\n\n  if (fread (header_buf, 128, 1, fd) == 0)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"Could not read header from '%s'\"),\n                   gimp_filename_to_utf8 (filename));\n      return -1;\n    }\n\n  pcx_header_from_buffer (header_buf);\n\n  if (pcx_header.manufacturer != 10)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"'%s' is not a PCX file\"),\n                   gimp_filename_to_utf8 (filename));\n      return -1;\n    }\n\n  offset_x     = GUINT16_FROM_LE (pcx_header.x1);\n  offset_y     = GUINT16_FROM_LE (pcx_header.y1);\n  width        = GUINT16_FROM_LE (pcx_header.x2) - offset_x + 1;\n  height       = GUINT16_FROM_LE (pcx_header.y2) - offset_y + 1;\n  bytesperline = GUINT16_FROM_LE (pcx_header.bytesperline);\n\n  if ((width < 0) || (width > GIMP_MAX_IMAGE_SIZE))\n    {\n      g_message (_(\"Unsupported or invalid image width: %d\"), width);\n      return -1;\n    }\n  if ((height < 0) || (height > GIMP_MAX_IMAGE_SIZE))\n    {\n      g_message (_(\"Unsupported or invalid image height: %d\"), height);\n      return -1;\n    }\n  if (bytesperline < (width * pcx_header.bpp) / 8)\n    {\n      g_message (_(\"Invalid number of bytes per line in PCX header\"));\n      return -1;\n    }\n\n  /* Shield against potential buffer overflows in load_*() functions. */\n  if (G_MAXSIZE / width / height < 3)\n    {\n      g_message (_(\"Image dimensions too large: width %d x height %d\"), width, height);\n      return -1;\n    }\n\n  if (pcx_header.planes == 3 && pcx_header.bpp == 8)\n    {\n      image= gimp_image_new (width, height, GIMP_RGB);\n      layer= gimp_layer_new (image, _(\"Background\"), width, height,\n                             GIMP_RGB_IMAGE, 100, GIMP_NORMAL_MODE);\n    }\n  else\n    {\n      image= gimp_image_new (width, height, GIMP_INDEXED);\n      layer= gimp_layer_new (image, _(\"Background\"), width, height,\n                             GIMP_INDEXED_IMAGE, 100, GIMP_NORMAL_MODE);\n    }\n  gimp_image_set_filename (image, filename);\n  gimp_image_add_layer (image, layer, 0);\n  gimp_layer_set_offsets (layer, offset_x, offset_y);\n  drawable = gimp_drawable_get (layer);\n\n  if (pcx_header.planes == 1 && pcx_header.bpp == 1)\n    {\n      dest = g_new (guchar, width * height);\n      load_1 (fd, width, height, dest, bytesperline);\n      gimp_image_set_colormap (image, mono, 2);\n    }\n  else if (pcx_header.planes == 4 && pcx_header.bpp == 1)\n    {\n      dest = g_new (guchar, width * height);\n      load_4 (fd, width, height, dest, bytesperline);\n      gimp_image_set_colormap (image, pcx_header.colormap, 16);\n    }\n  else if (pcx_header.planes == 1 && pcx_header.bpp == 8)\n    {\n      dest = g_new (guchar, width * height);\n      load_8 (fd, width, height, dest, bytesperline);\n      fseek (fd, -768L, SEEK_END);\n      fread (cmap, 768, 1, fd);\n      gimp_image_set_colormap (image, cmap, 256);\n    }\n  else if (pcx_header.planes == 3 && pcx_header.bpp == 8)\n    {\n      dest = g_new (guchar, width * height * 3);\n      load_24 (fd, width, height, dest, bytesperline);\n    }\n  else\n    {\n      g_message (_(\"Unusual PCX flavour, giving up\"));\n      return -1;\n    }\n\n  gimp_pixel_rgn_init (&pixel_rgn, drawable, 0, 0, width, height, TRUE, FALSE);\n  gimp_pixel_rgn_set_rect (&pixel_rgn, dest, 0, 0, width, height);\n\n  g_free (dest);\n\n  gimp_drawable_flush (drawable);\n  gimp_drawable_detach (drawable);\n\n  return image;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146146,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "load_image (const gchar  *filename,\n            GError      **error)\n{\n  FILE         *fd;\n  GimpDrawable *drawable;\n  GimpPixelRgn  pixel_rgn;\n  guint16       offset_x, offset_y, bytesperline;\n  gint32        width, height;\n  gint32        image, layer;\n  guchar       *dest, cmap[768];\n  guint8        header_buf[128];\n\n  fd = g_fopen (filename, \"rb\");\n\n  if (! fd)\n    {\n      g_set_error (error, G_FILE_ERROR, g_file_error_from_errno (errno),\n                   _(\"Could not open '%s' for reading: %s\"),\n                   gimp_filename_to_utf8 (filename), g_strerror (errno));\n      return -1;\n    }\n\n  gimp_progress_init_printf (_(\"Opening '%s'\"),\n                             gimp_filename_to_utf8 (filename));\n\n  if (fread (header_buf, 128, 1, fd) == 0)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"Could not read header from '%s'\"),\n                   gimp_filename_to_utf8 (filename));\n      return -1;\n    }\n\n  pcx_header_from_buffer (header_buf);\n\n  if (pcx_header.manufacturer != 10)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"'%s' is not a PCX file\"),\n                   gimp_filename_to_utf8 (filename));\n      return -1;\n    }\n\n  offset_x     = GUINT16_FROM_LE (pcx_header.x1);\n  offset_y     = GUINT16_FROM_LE (pcx_header.y1);\n  width        = GUINT16_FROM_LE (pcx_header.x2) - offset_x + 1;\n  height       = GUINT16_FROM_LE (pcx_header.y2) - offset_y + 1;\n  bytesperline = GUINT16_FROM_LE (pcx_header.bytesperline);\n\n  if ((width < 0) || (width > GIMP_MAX_IMAGE_SIZE))\n    {\n      g_message (_(\"Unsupported or invalid image width: %d\"), width);\n      return -1;\n    }\n  if ((height < 0) || (height > GIMP_MAX_IMAGE_SIZE))\n    {\n      g_message (_(\"Unsupported or invalid image height: %d\"), height);\n      return -1;\n    }\n  if (bytesperline < (width * pcx_header.bpp) / 8)\n    {\n      g_message (_(\"Invalid number of bytes per line in PCX header\"));\n      return -1;\n    }\n\n  /* Shield against potential buffer overflows in load_*() functions. */\n  if (G_MAXSIZE / width / height < 3)\n    {\n      g_message (_(\"Image dimensions too large: width %d x height %d\"), width, height);\n      return -1;\n    }\n\n  if (pcx_header.planes == 3 && pcx_header.bpp == 8)\n    {\n      image= gimp_image_new (width, height, GIMP_RGB);\n      layer= gimp_layer_new (image, _(\"Background\"), width, height,\n                             GIMP_RGB_IMAGE, 100, GIMP_NORMAL_MODE);\n    }\n  else\n    {\n      image= gimp_image_new (width, height, GIMP_INDEXED);\n      layer= gimp_layer_new (image, _(\"Background\"), width, height,\n                             GIMP_INDEXED_IMAGE, 100, GIMP_NORMAL_MODE);\n    }\n  gimp_image_set_filename (image, filename);\n  gimp_image_add_layer (image, layer, 0);\n  gimp_layer_set_offsets (layer, offset_x, offset_y);\n  drawable = gimp_drawable_get (layer);\n\n  if (pcx_header.planes == 1 && pcx_header.bpp == 1)\n    {\n      dest = g_new (guchar, ((gsize) width) * height);\n      load_1 (fd, width, height, dest, bytesperline);\n      gimp_image_set_colormap (image, mono, 2);\n    }\n  else if (pcx_header.planes == 4 && pcx_header.bpp == 1)\n    {\n      dest = g_new (guchar, ((gsize) width) * height);\n      load_4 (fd, width, height, dest, bytesperline);\n      gimp_image_set_colormap (image, pcx_header.colormap, 16);\n    }\n  else if (pcx_header.planes == 1 && pcx_header.bpp == 8)\n    {\n      dest = g_new (guchar, ((gsize) width) * height);\n      load_8 (fd, width, height, dest, bytesperline);\n      fseek (fd, -768L, SEEK_END);\n      fread (cmap, 768, 1, fd);\n      gimp_image_set_colormap (image, cmap, 256);\n    }\n  else if (pcx_header.planes == 3 && pcx_header.bpp == 8)\n    {\n      dest = g_new (guchar, ((gsize) width) * height * 3);\n      load_24 (fd, width, height, dest, bytesperline);\n    }\n  else\n    {\n      g_message (_(\"Unusual PCX flavour, giving up\"));\n      return -1;\n    }\n\n  gimp_pixel_rgn_init (&pixel_rgn, drawable, 0, 0, width, height, TRUE, FALSE);\n  gimp_pixel_rgn_set_rect (&pixel_rgn, dest, 0, 0, width, height);\n\n  g_free (dest);\n\n  gimp_drawable_flush (drawable);\n  gimp_drawable_detach (drawable);\n\n  return image;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146147,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static int HistogramCompare(const void *x,const void *y)\n{\n  const PixelInfo\n    *color_1,\n    *color_2;\n\n  color_1=(const PixelInfo *) x;\n  color_2=(const PixelInfo *) y;\n  if (color_2->red != color_1->red)\n    return((int) color_1->red-(int) color_2->red);\n  if (color_2->green != color_1->green)\n    return((int) color_1->green-(int) color_2->green);\n  if (color_2->blue != color_1->blue)\n    return((int) color_1->blue-(int) color_2->blue);\n  return((int) color_2->count-(int) color_1->count);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146182,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static int HistogramCompare(const void *x,const void *y)\n{\n  const PixelInfo\n    *color_1,\n    *color_2;\n\n  color_1=(const PixelInfo *) x;\n  color_2=(const PixelInfo *) y;\n  if (color_2->red != color_1->red)\n    return((int) ((ssize_t) color_1->red-(ssize_t) color_2->red));\n  if (color_2->green != color_1->green)\n    return((int) ((ssize_t) color_1->green-(ssize_t) color_2->green));\n  if (color_2->blue != color_1->blue)\n    return((int) ((ssize_t) color_1->blue-(ssize_t) color_2->blue));\n  return((int) ((ssize_t) color_2->count-(ssize_t) color_1->count));\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146183,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static void k_ascii(struct vc_data *vc, unsigned char value, char up_flag)\n{\n\tint base;\n\n\tif (up_flag)\n\t\treturn;\n\n\tif (value < 10) {\n\t\t/* decimal input of code, while Alt depressed */\n\t\tbase = 10;\n\t} else {\n\t\t/* hexadecimal input of code, while AltGr depressed */\n\t\tvalue -= 10;\n\t\tbase = 16;\n\t}\n\n\tif (npadch == -1)\n\t\tnpadch = value;\n\telse\n\t\tnpadch = npadch * base + value;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146258,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static void k_ascii(struct vc_data *vc, unsigned char value, char up_flag)\n{\n\tunsigned int base;\n\n\tif (up_flag)\n\t\treturn;\n\n\tif (value < 10) {\n\t\t/* decimal input of code, while Alt depressed */\n\t\tbase = 10;\n\t} else {\n\t\t/* hexadecimal input of code, while AltGr depressed */\n\t\tvalue -= 10;\n\t\tbase = 16;\n\t}\n\n\tif (!npadch_active) {\n\t\tnpadch_value = 0;\n\t\tnpadch_active = true;\n\t}\n\n\tnpadch_value = npadch_value * base + value;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146259,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "js_strtod(const char *string, char **endPtr)\n{\n\tint sign, expSign = FALSE;\n\tdouble fraction, dblExp, *d;\n\tregister const char *p;\n\tregister int c;\n\n\t/* Exponent read from \"EX\" field. */\n\tint exp = 0;\n\n\t/* Exponent that derives from the fractional part. Under normal\n\t * circumstances, it is the negative of the number of digits in F.\n\t * However, if I is very long, the last digits of I get dropped\n\t * (otherwise a long I with a large negative exponent could cause an\n\t * unnecessary overflow on I alone). In this case, fracExp is\n\t * incremented one for each dropped digit.\n\t */\n\tint fracExp = 0;\n\n\t/* Number of digits in mantissa. */\n\tint mantSize;\n\n\t/* Number of mantissa digits BEFORE decimal point. */\n\tint decPt;\n\n\t/* Temporarily holds location of exponent in string. */\n\tconst char *pExp;\n\n\t/*\n\t * Strip off leading blanks and check for a sign.\n\t */\n\n\tp = string;\n\twhile (*p == ' ' || *p == '\\t' || *p == '\\n' || *p == '\\r') {\n\t\tp += 1;\n\t}\n\tif (*p == '-') {\n\t\tsign = TRUE;\n\t\tp += 1;\n\t} else {\n\t\tif (*p == '+') {\n\t\t\tp += 1;\n\t\t}\n\t\tsign = FALSE;\n\t}\n\n\t/*\n\t * Count the number of digits in the mantissa (including the decimal\n\t * point), and also locate the decimal point.\n\t */\n\n\tdecPt = -1;\n\tfor (mantSize = 0; ; mantSize += 1)\n\t{\n\t\tc = *p;\n\t\tif (!(c>='0'&&c<='9')) {\n\t\t\tif ((c != '.') || (decPt >= 0)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdecPt = mantSize;\n\t\t}\n\t\tp += 1;\n\t}\n\n\t/*\n\t * Now suck up the digits in the mantissa. Use two integers to\n\t * collect 9 digits each (this is faster than using floating-point).\n\t * If the mantissa has more than 18 digits, ignore the extras, since\n\t * they can't affect the value anyway.\n\t */\n\n\tpExp = p;\n\tp -= mantSize;\n\tif (decPt < 0) {\n\t\tdecPt = mantSize;\n\t} else {\n\t\tmantSize -= 1;\t\t\t/* One of the digits was the point. */\n\t}\n\tif (mantSize > 18) {\n\t\tfracExp = decPt - 18;\n\t\tmantSize = 18;\n\t} else {\n\t\tfracExp = decPt - mantSize;\n\t}\n\tif (mantSize == 0) {\n\t\tfraction = 0.0;\n\t\tp = string;\n\t\tgoto done;\n\t} else {\n\t\tint frac1, frac2;\n\t\tfrac1 = 0;\n\t\tfor ( ; mantSize > 9; mantSize -= 1)\n\t\t{\n\t\t\tc = *p;\n\t\t\tp += 1;\n\t\t\tif (c == '.') {\n\t\t\t\tc = *p;\n\t\t\t\tp += 1;\n\t\t\t}\n\t\t\tfrac1 = 10*frac1 + (c - '0');\n\t\t}\n\t\tfrac2 = 0;\n\t\tfor (; mantSize > 0; mantSize -= 1)\n\t\t{\n\t\t\tc = *p;\n\t\t\tp += 1;\n\t\t\tif (c == '.') {\n\t\t\t\tc = *p;\n\t\t\t\tp += 1;\n\t\t\t}\n\t\t\tfrac2 = 10*frac2 + (c - '0');\n\t\t}\n\t\tfraction = (1.0e9 * frac1) + frac2;\n\t}\n\n\t/*\n\t * Skim off the exponent.\n\t */\n\n\tp = pExp;\n\tif ((*p == 'E') || (*p == 'e')) {\n\t\tp += 1;\n\t\tif (*p == '-') {\n\t\t\texpSign = TRUE;\n\t\t\tp += 1;\n\t\t} else {\n\t\t\tif (*p == '+') {\n\t\t\t\tp += 1;\n\t\t\t}\n\t\t\texpSign = FALSE;\n\t\t}\n\t\twhile ((*p >= '0') && (*p <= '9')) {\n\t\t\texp = exp * 10 + (*p - '0');\n\t\t\tp += 1;\n\t\t}\n\t}\n\tif (expSign) {\n\t\texp = fracExp - exp;\n\t} else {\n\t\texp = fracExp + exp;\n\t}\n\n\t/*\n\t * Generate a floating-point number that represents the exponent.\n\t * Do this by processing the exponent one bit at a time to combine\n\t * many powers of 2 of 10. Then combine the exponent with the\n\t * fraction.\n\t */\n\n\tif (exp < 0) {\n\t\texpSign = TRUE;\n\t\texp = -exp;\n\t} else {\n\t\texpSign = FALSE;\n\t}\n\tif (exp > maxExponent) {\n\t\texp = maxExponent;\n\t\terrno = ERANGE;\n\t}\n\tdblExp = 1.0;\n\tfor (d = powersOf10; exp != 0; exp >>= 1, d += 1) {\n\t\tif (exp & 01) {\n\t\t\tdblExp *= *d;\n\t\t}\n\t}\n\tif (expSign) {\n\t\tfraction /= dblExp;\n\t} else {\n\t\tfraction *= dblExp;\n\t}\n\ndone:\n\tif (endPtr != NULL) {\n\t\t*endPtr = (char *) p;\n\t}\n\n\tif (sign) {\n\t\treturn -fraction;\n\t}\n\treturn fraction;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146276,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "js_strtod(const char *string, char **endPtr)\n{\n\tint sign, expSign = FALSE;\n\tdouble fraction, dblExp, *d;\n\tregister const char *p;\n\tregister int c;\n\n\t/* Exponent read from \"EX\" field. */\n\tint exp = 0;\n\n\t/* Exponent that derives from the fractional part. Under normal\n\t * circumstances, it is the negative of the number of digits in F.\n\t * However, if I is very long, the last digits of I get dropped\n\t * (otherwise a long I with a large negative exponent could cause an\n\t * unnecessary overflow on I alone). In this case, fracExp is\n\t * incremented one for each dropped digit.\n\t */\n\tint fracExp = 0;\n\n\t/* Number of digits in mantissa. */\n\tint mantSize;\n\n\t/* Number of mantissa digits BEFORE decimal point. */\n\tint decPt;\n\n\t/* Temporarily holds location of exponent in string. */\n\tconst char *pExp;\n\n\t/*\n\t * Strip off leading blanks and check for a sign.\n\t */\n\n\tp = string;\n\twhile (*p == ' ' || *p == '\\t' || *p == '\\n' || *p == '\\r') {\n\t\tp += 1;\n\t}\n\tif (*p == '-') {\n\t\tsign = TRUE;\n\t\tp += 1;\n\t} else {\n\t\tif (*p == '+') {\n\t\t\tp += 1;\n\t\t}\n\t\tsign = FALSE;\n\t}\n\n\t/*\n\t * Count the number of digits in the mantissa (including the decimal\n\t * point), and also locate the decimal point.\n\t */\n\n\tdecPt = -1;\n\tfor (mantSize = 0; ; mantSize += 1)\n\t{\n\t\tc = *p;\n\t\tif (!(c>='0'&&c<='9')) {\n\t\t\tif ((c != '.') || (decPt >= 0)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdecPt = mantSize;\n\t\t}\n\t\tp += 1;\n\t}\n\n\t/*\n\t * Now suck up the digits in the mantissa. Use two integers to\n\t * collect 9 digits each (this is faster than using floating-point).\n\t * If the mantissa has more than 18 digits, ignore the extras, since\n\t * they can't affect the value anyway.\n\t */\n\n\tpExp = p;\n\tp -= mantSize;\n\tif (decPt < 0) {\n\t\tdecPt = mantSize;\n\t} else {\n\t\tmantSize -= 1;\t\t\t/* One of the digits was the point. */\n\t}\n\tif (mantSize > 18) {\n\t\tfracExp = decPt - 18;\n\t\tmantSize = 18;\n\t} else {\n\t\tfracExp = decPt - mantSize;\n\t}\n\tif (mantSize == 0) {\n\t\tfraction = 0.0;\n\t\tp = string;\n\t\tgoto done;\n\t} else {\n\t\tint frac1, frac2;\n\t\tfrac1 = 0;\n\t\tfor ( ; mantSize > 9; mantSize -= 1)\n\t\t{\n\t\t\tc = *p;\n\t\t\tp += 1;\n\t\t\tif (c == '.') {\n\t\t\t\tc = *p;\n\t\t\t\tp += 1;\n\t\t\t}\n\t\t\tfrac1 = 10*frac1 + (c - '0');\n\t\t}\n\t\tfrac2 = 0;\n\t\tfor (; mantSize > 0; mantSize -= 1)\n\t\t{\n\t\t\tc = *p;\n\t\t\tp += 1;\n\t\t\tif (c == '.') {\n\t\t\t\tc = *p;\n\t\t\t\tp += 1;\n\t\t\t}\n\t\t\tfrac2 = 10*frac2 + (c - '0');\n\t\t}\n\t\tfraction = (1.0e9 * frac1) + frac2;\n\t}\n\n\t/*\n\t * Skim off the exponent.\n\t */\n\n\tp = pExp;\n\tif ((*p == 'E') || (*p == 'e')) {\n\t\tp += 1;\n\t\tif (*p == '-') {\n\t\t\texpSign = TRUE;\n\t\t\tp += 1;\n\t\t} else {\n\t\t\tif (*p == '+') {\n\t\t\t\tp += 1;\n\t\t\t}\n\t\t\texpSign = FALSE;\n\t\t}\n\t\twhile ((*p >= '0') && (*p <= '9')) {\n\t\t\texp = exp * 10 + (*p - '0');\n\t\t\tp += 1;\n\t\t}\n\t}\n\tif (expSign) {\n\t\texp = fracExp - exp;\n\t} else {\n\t\texp = fracExp + exp;\n\t}\n\n\t/*\n\t * Generate a floating-point number that represents the exponent.\n\t * Do this by processing the exponent one bit at a time to combine\n\t * many powers of 2 of 10. Then combine the exponent with the\n\t * fraction.\n\t */\n\n\tif (exp < -maxExponent) {\n\t\texp = maxExponent;\n\t\texpSign = TRUE;\n\t\terrno = ERANGE;\n\t} else if (exp > maxExponent) {\n\t\texp = maxExponent;\n\t\texpSign = FALSE;\n\t\terrno = ERANGE;\n\t} else if (exp < 0) {\n\t\texpSign = TRUE;\n\t\texp = -exp;\n\t} else {\n\t\texpSign = FALSE;\n\t}\n\tdblExp = 1.0;\n\tfor (d = powersOf10; exp != 0; exp >>= 1, d += 1) {\n\t\tif (exp & 01) {\n\t\t\tdblExp *= *d;\n\t\t}\n\t}\n\tif (expSign) {\n\t\tfraction /= dblExp;\n\t} else {\n\t\tfraction *= dblExp;\n\t}\n\ndone:\n\tif (endPtr != NULL) {\n\t\t*endPtr = (char *) p;\n\t}\n\n\tif (sign) {\n\t\treturn -fraction;\n\t}\n\treturn fraction;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146277,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "int bson_ensure_space( bson *b, const int bytesNeeded ) {\n    int pos = b->cur - b->data;\n    char *orig = b->data;\n    int new_size;\n\n    if ( pos + bytesNeeded <= b->dataSize )\n        return BSON_OK;\n\n    new_size = 1.5 * ( b->dataSize + bytesNeeded );\n\n    if( new_size < b->dataSize ) {\n        if( ( b->dataSize + bytesNeeded ) < INT_MAX )\n            new_size = INT_MAX;\n        else {\n            b->err = BSON_SIZE_OVERFLOW;\n            return BSON_ERROR;\n        }\n    }\n\n    b->data = bson_realloc( b->data, new_size );\n    if ( !b->data )\n        bson_fatal_msg( !!b->data, \"realloc() failed\" );\n\n    b->dataSize = new_size;\n    b->cur += b->data - orig;\n\n    return BSON_OK;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146346,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "int bson_ensure_space( bson *b, const size_t bytesNeeded ) {\n    int pos = b->cur - b->data;\n    char *orig = b->data;\n    int new_size;\n\n    if ( pos + bytesNeeded <= b->dataSize )\n        return BSON_OK;\n\n    new_size = 1.5 * ( b->dataSize + bytesNeeded );\n\n    if( new_size < b->dataSize ) {\n        if( ( b->dataSize + bytesNeeded ) < INT_MAX )\n            new_size = INT_MAX;\n        else {\n            b->err = BSON_SIZE_OVERFLOW;\n            return BSON_ERROR;\n        }\n    }\n\n    b->data = bson_realloc( b->data, new_size );\n    if ( !b->data )\n        bson_fatal_msg( !!b->data, \"realloc() failed\" );\n\n    b->dataSize = new_size;\n    b->cur += b->data - orig;\n\n    return BSON_OK;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146347,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "PHP_MINIT_FUNCTION(filter)\n{\n\tZEND_INIT_MODULE_GLOBALS(filter, php_filter_init_globals, NULL);\n\n\tREGISTER_INI_ENTRIES();\n\n\tREGISTER_LONG_CONSTANT(\"INPUT_POST\",\tPARSE_POST, \tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"INPUT_GET\",\t\tPARSE_GET,\t\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"INPUT_COOKIE\",\tPARSE_COOKIE, \tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"INPUT_ENV\",\t\tPARSE_ENV,\t\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"INPUT_SERVER\",\tPARSE_SERVER, \tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"INPUT_SESSION\", PARSE_SESSION, \tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"INPUT_REQUEST\", PARSE_REQUEST, \tCONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_NONE\", FILTER_FLAG_NONE, CONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"FILTER_REQUIRE_SCALAR\", FILTER_REQUIRE_SCALAR, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_REQUIRE_ARRAY\", FILTER_REQUIRE_ARRAY, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_FORCE_ARRAY\", FILTER_FORCE_ARRAY, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_NULL_ON_FAILURE\", FILTER_NULL_ON_FAILURE, CONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"FILTER_VALIDATE_INT\", FILTER_VALIDATE_INT, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_VALIDATE_BOOLEAN\", FILTER_VALIDATE_BOOLEAN, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_VALIDATE_FLOAT\", FILTER_VALIDATE_FLOAT, CONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"FILTER_VALIDATE_REGEXP\", FILTER_VALIDATE_REGEXP, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_VALIDATE_URL\", FILTER_VALIDATE_URL, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_VALIDATE_EMAIL\", FILTER_VALIDATE_EMAIL, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_VALIDATE_IP\", FILTER_VALIDATE_IP, CONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"FILTER_DEFAULT\", FILTER_DEFAULT, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_UNSAFE_RAW\", FILTER_UNSAFE_RAW, CONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"FILTER_SANITIZE_STRING\", FILTER_SANITIZE_STRING, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_SANITIZE_STRIPPED\", FILTER_SANITIZE_STRING, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_SANITIZE_ENCODED\", FILTER_SANITIZE_ENCODED, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_SANITIZE_SPECIAL_CHARS\", FILTER_SANITIZE_SPECIAL_CHARS, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_SANITIZE_FULL_SPECIAL_CHARS\", FILTER_SANITIZE_SPECIAL_CHARS, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_SANITIZE_EMAIL\", FILTER_SANITIZE_EMAIL, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_SANITIZE_URL\", FILTER_SANITIZE_URL, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_SANITIZE_NUMBER_INT\", FILTER_SANITIZE_NUMBER_INT, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_SANITIZE_NUMBER_FLOAT\", FILTER_SANITIZE_NUMBER_FLOAT, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_SANITIZE_MAGIC_QUOTES\", FILTER_SANITIZE_MAGIC_QUOTES, CONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"FILTER_CALLBACK\", FILTER_CALLBACK, CONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_ALLOW_OCTAL\", FILTER_FLAG_ALLOW_OCTAL, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_ALLOW_HEX\", FILTER_FLAG_ALLOW_HEX, CONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_STRIP_LOW\", FILTER_FLAG_STRIP_LOW, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_STRIP_HIGH\", FILTER_FLAG_STRIP_HIGH, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_STRIP_BACKTICK\", FILTER_FLAG_STRIP_BACKTICK, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_ENCODE_LOW\", FILTER_FLAG_ENCODE_LOW, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_ENCODE_HIGH\", FILTER_FLAG_ENCODE_HIGH, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_ENCODE_AMP\", FILTER_FLAG_ENCODE_AMP, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_NO_ENCODE_QUOTES\", FILTER_FLAG_NO_ENCODE_QUOTES, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_EMPTY_STRING_NULL\", FILTER_FLAG_EMPTY_STRING_NULL, CONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_ALLOW_FRACTION\", FILTER_FLAG_ALLOW_FRACTION, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_ALLOW_THOUSAND\", FILTER_FLAG_ALLOW_THOUSAND, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_ALLOW_SCIENTIFIC\", FILTER_FLAG_ALLOW_SCIENTIFIC, CONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_SCHEME_REQUIRED\", FILTER_FLAG_SCHEME_REQUIRED, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_HOST_REQUIRED\", FILTER_FLAG_HOST_REQUIRED, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_PATH_REQUIRED\", FILTER_FLAG_PATH_REQUIRED, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_QUERY_REQUIRED\", FILTER_FLAG_QUERY_REQUIRED, CONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_IPV4\", FILTER_FLAG_IPV4, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_IPV6\", FILTER_FLAG_IPV6, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_NO_RES_RANGE\", FILTER_FLAG_NO_RES_RANGE, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_NO_PRIV_RANGE\", FILTER_FLAG_NO_PRIV_RANGE, CONST_CS | CONST_PERSISTENT);\n\n\tsapi_register_input_filter(php_sapi_filter, php_sapi_filter_init TSRMLS_CC);\n\n\treturn SUCCESS;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146354,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "PHP_MINIT_FUNCTION(filter)\n{\n\tZEND_INIT_MODULE_GLOBALS(filter, php_filter_init_globals, NULL);\n\n\tREGISTER_INI_ENTRIES();\n\n\tREGISTER_LONG_CONSTANT(\"INPUT_POST\",\tPARSE_POST, \tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"INPUT_GET\",\t\tPARSE_GET,\t\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"INPUT_COOKIE\",\tPARSE_COOKIE, \tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"INPUT_ENV\",\t\tPARSE_ENV,\t\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"INPUT_SERVER\",\tPARSE_SERVER, \tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"INPUT_SESSION\", PARSE_SESSION, \tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"INPUT_REQUEST\", PARSE_REQUEST, \tCONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_NONE\", FILTER_FLAG_NONE, CONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"FILTER_REQUIRE_SCALAR\", FILTER_REQUIRE_SCALAR, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_REQUIRE_ARRAY\", FILTER_REQUIRE_ARRAY, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_FORCE_ARRAY\", FILTER_FORCE_ARRAY, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_NULL_ON_FAILURE\", FILTER_NULL_ON_FAILURE, CONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"FILTER_VALIDATE_INT\", FILTER_VALIDATE_INT, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_VALIDATE_BOOLEAN\", FILTER_VALIDATE_BOOLEAN, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_VALIDATE_FLOAT\", FILTER_VALIDATE_FLOAT, CONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"FILTER_VALIDATE_REGEXP\", FILTER_VALIDATE_REGEXP, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_VALIDATE_URL\", FILTER_VALIDATE_URL, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_VALIDATE_EMAIL\", FILTER_VALIDATE_EMAIL, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_VALIDATE_IP\", FILTER_VALIDATE_IP, CONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"FILTER_DEFAULT\", FILTER_DEFAULT, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_UNSAFE_RAW\", FILTER_UNSAFE_RAW, CONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"FILTER_SANITIZE_STRING\", FILTER_SANITIZE_STRING, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_SANITIZE_STRIPPED\", FILTER_SANITIZE_STRING, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_SANITIZE_ENCODED\", FILTER_SANITIZE_ENCODED, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_SANITIZE_SPECIAL_CHARS\", FILTER_SANITIZE_SPECIAL_CHARS, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_SANITIZE_FULL_SPECIAL_CHARS\", FILTER_SANITIZE_FULL_SPECIAL_CHARS, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_SANITIZE_EMAIL\", FILTER_SANITIZE_EMAIL, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_SANITIZE_URL\", FILTER_SANITIZE_URL, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_SANITIZE_NUMBER_INT\", FILTER_SANITIZE_NUMBER_INT, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_SANITIZE_NUMBER_FLOAT\", FILTER_SANITIZE_NUMBER_FLOAT, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_SANITIZE_MAGIC_QUOTES\", FILTER_SANITIZE_MAGIC_QUOTES, CONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"FILTER_CALLBACK\", FILTER_CALLBACK, CONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_ALLOW_OCTAL\", FILTER_FLAG_ALLOW_OCTAL, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_ALLOW_HEX\", FILTER_FLAG_ALLOW_HEX, CONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_STRIP_LOW\", FILTER_FLAG_STRIP_LOW, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_STRIP_HIGH\", FILTER_FLAG_STRIP_HIGH, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_STRIP_BACKTICK\", FILTER_FLAG_STRIP_BACKTICK, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_ENCODE_LOW\", FILTER_FLAG_ENCODE_LOW, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_ENCODE_HIGH\", FILTER_FLAG_ENCODE_HIGH, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_ENCODE_AMP\", FILTER_FLAG_ENCODE_AMP, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_NO_ENCODE_QUOTES\", FILTER_FLAG_NO_ENCODE_QUOTES, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_EMPTY_STRING_NULL\", FILTER_FLAG_EMPTY_STRING_NULL, CONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_ALLOW_FRACTION\", FILTER_FLAG_ALLOW_FRACTION, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_ALLOW_THOUSAND\", FILTER_FLAG_ALLOW_THOUSAND, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_ALLOW_SCIENTIFIC\", FILTER_FLAG_ALLOW_SCIENTIFIC, CONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_SCHEME_REQUIRED\", FILTER_FLAG_SCHEME_REQUIRED, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_HOST_REQUIRED\", FILTER_FLAG_HOST_REQUIRED, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_PATH_REQUIRED\", FILTER_FLAG_PATH_REQUIRED, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_QUERY_REQUIRED\", FILTER_FLAG_QUERY_REQUIRED, CONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_IPV4\", FILTER_FLAG_IPV4, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_IPV6\", FILTER_FLAG_IPV6, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_NO_RES_RANGE\", FILTER_FLAG_NO_RES_RANGE, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILTER_FLAG_NO_PRIV_RANGE\", FILTER_FLAG_NO_PRIV_RANGE, CONST_CS | CONST_PERSISTENT);\n\n\tsapi_register_input_filter(php_sapi_filter, php_sapi_filter_init TSRMLS_CC);\n\n\treturn SUCCESS;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146355,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "    void WebPImage::decodeChunks(uint64_t filesize)\n    {\n        DataBuf   chunkId(5);\n        byte      size_buff[WEBP_TAG_SIZE];\n        bool      has_canvas_data = false;\n\n#ifdef DEBUG\n        std::cout << \"Reading metadata\" << std::endl;\n#endif\n\n        chunkId.pData_[4] = '\\0' ;\n        while ( !io_->eof() && (uint64_t) io_->tell() < filesize) {\n            io_->read(chunkId.pData_, WEBP_TAG_SIZE);\n            io_->read(size_buff, WEBP_TAG_SIZE);\n            const uint32_t size = Exiv2::getULong(size_buff, littleEndian);\n            enforce(size <= (filesize - io_->tell()), Exiv2::kerCorruptedMetadata);\n\n            DataBuf payload(size);\n\n            if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8X) && !has_canvas_data) {\n                enforce(size >= 10, Exiv2::kerCorruptedMetadata);\n\n                has_canvas_data = true;\n                byte size_buf[WEBP_TAG_SIZE];\n\n                io_->read(payload.pData_, payload.size_);\n\n                // Fetch width\n                memcpy(&size_buf, &payload.pData_[4], 3);\n                size_buf[3] = 0;\n                pixelWidth_ = Exiv2::getULong(size_buf, littleEndian) + 1;\n\n                // Fetch height\n                memcpy(&size_buf, &payload.pData_[7], 3);\n                size_buf[3] = 0;\n                pixelHeight_ = Exiv2::getULong(size_buf, littleEndian) + 1;\n            } else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8) && !has_canvas_data) {\n                enforce(size >= 10, Exiv2::kerCorruptedMetadata);\n\n                has_canvas_data = true;\n                io_->read(payload.pData_, payload.size_);\n                byte size_buf[WEBP_TAG_SIZE];\n\n                // Fetch width\"\"\n                memcpy(&size_buf, &payload.pData_[6], 2);\n                size_buf[2] = 0;\n                size_buf[3] = 0;\n                pixelWidth_ = Exiv2::getULong(size_buf, littleEndian) & 0x3fff;\n\n                // Fetch height\n                memcpy(&size_buf, &payload.pData_[8], 2);\n                size_buf[2] = 0;\n                size_buf[3] = 0;\n                pixelHeight_ = Exiv2::getULong(size_buf, littleEndian) & 0x3fff;\n            } else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8L) && !has_canvas_data) {\n                enforce(size >= 5, Exiv2::kerCorruptedMetadata);\n\n                has_canvas_data = true;\n                byte size_buf_w[2];\n                byte size_buf_h[3];\n\n                io_->read(payload.pData_, payload.size_);\n\n                // Fetch width\n                memcpy(&size_buf_w, &payload.pData_[1], 2);\n                size_buf_w[1] &= 0x3F;\n                pixelWidth_ = Exiv2::getUShort(size_buf_w, littleEndian) + 1;\n\n                // Fetch height\n                memcpy(&size_buf_h, &payload.pData_[2], 3);\n                size_buf_h[0] = ((size_buf_h[0] >> 6) & 0x3) | ((size_buf_h[1]  & 0x3F) << 0x2);\n                size_buf_h[1] = ((size_buf_h[1] >> 6) & 0x3) | ((size_buf_h[2] & 0xF) << 0x2);\n                pixelHeight_ = Exiv2::getUShort(size_buf_h, littleEndian) + 1;\n            } else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_ANMF) && !has_canvas_data) {\n                enforce(size >= 12, Exiv2::kerCorruptedMetadata);\n\n                has_canvas_data = true;\n                byte size_buf[WEBP_TAG_SIZE];\n\n                io_->read(payload.pData_, payload.size_);\n\n                // Fetch width\n                memcpy(&size_buf, &payload.pData_[6], 3);\n                size_buf[3] = 0;\n                pixelWidth_ = Exiv2::getULong(size_buf, littleEndian) + 1;\n\n                // Fetch height\n                memcpy(&size_buf, &payload.pData_[9], 3);\n                size_buf[3] = 0;\n                pixelHeight_ = Exiv2::getULong(size_buf, littleEndian) + 1;\n            } else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_ICCP)) {\n                io_->read(payload.pData_, payload.size_);\n                this->setIccProfile(payload);\n            } else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_EXIF)) {\n                io_->read(payload.pData_, payload.size_);\n\n                byte  size_buff[2];\n                // 4 meaningful bytes + 2 padding bytes\n                byte  exifLongHeader[]   = { 0xFF, 0x01, 0xFF, 0xE1, 0x00, 0x00 };\n                byte  exifShortHeader[]  = { 0x45, 0x78, 0x69, 0x66, 0x00, 0x00 };\n                byte  exifTiffLEHeader[] = { 0x49, 0x49, 0x2A };       // \"MM*\"\n                byte  exifTiffBEHeader[] = { 0x4D, 0x4D, 0x00, 0x2A }; // \"II\\0*\"\n                byte* rawExifData = NULL;\n                long  offset = 0;\n                bool  s_header = false;\n                bool  le_header = false;\n                bool  be_header = false;\n                long  pos = getHeaderOffset (payload.pData_, payload.size_, (byte*)&exifLongHeader, 4);\n\n                if (pos == -1) {\n                    pos = getHeaderOffset (payload.pData_, payload.size_, (byte*)&exifLongHeader, 6);\n                    if (pos != -1) {\n                        s_header = true;\n                    }\n                }\n                if (pos == -1) {\n                    pos = getHeaderOffset (payload.pData_, payload.size_, (byte*)&exifTiffLEHeader, 3);\n                    if (pos != -1) {\n                        le_header = true;\n                    }\n                }\n                if (pos == -1) {\n                    pos = getHeaderOffset (payload.pData_, payload.size_, (byte*)&exifTiffBEHeader, 4);\n                    if (pos != -1) {\n                        be_header = true;\n                    }\n                }\n\n                if (s_header) {\n                    offset += 6;\n                }\n                if (be_header || le_header) {\n                    offset += 12;\n                }\n\n                const long size = payload.size_ + offset;\n                rawExifData = (byte*)malloc(size);\n\n                if (s_header) {\n                    us2Data(size_buff, (uint16_t) (size - 6), bigEndian);\n                    memcpy(rawExifData, (char*)&exifLongHeader, 4);\n                    memcpy(rawExifData + 4, (char*)&size_buff, 2);\n                }\n\n                if (be_header || le_header) {\n                    us2Data(size_buff, (uint16_t) (size - 6), bigEndian);\n                    memcpy(rawExifData, (char*)&exifLongHeader, 4);\n                    memcpy(rawExifData + 4, (char*)&size_buff, 2);\n                    memcpy(rawExifData + 6, (char*)&exifShortHeader, 6);\n                }\n\n                memcpy(rawExifData + offset, payload.pData_, payload.size_);\n\n#ifdef DEBUG\n                std::cout << \"Display Hex Dump [size:\" << (unsigned long)size << \"]\" << std::endl;\n                std::cout << Internal::binaryToHex(rawExifData, size);\n#endif\n\n                if (pos != -1) {\n                    XmpData  xmpData;\n                    ByteOrder bo = ExifParser::decode(exifData_,\n                                                      payload.pData_ + pos,\n                                                      payload.size_ - pos);\n                    setByteOrder(bo);\n                }\n                else\n                {\n#ifndef SUPPRESS_WARNINGS\n                    EXV_WARNING << \"Failed to decode Exif metadata.\" << std::endl;\n#endif\n                    exifData_.clear();\n                }\n\n                if (rawExifData) free(rawExifData);\n            } else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_XMP)) {\n                io_->read(payload.pData_, payload.size_);\n                xmpPacket_.assign(reinterpret_cast<char*>(payload.pData_), payload.size_);\n                if (xmpPacket_.size() > 0 && XmpParser::decode(xmpData_, xmpPacket_)) {\n#ifndef SUPPRESS_WARNINGS\n                    EXV_WARNING << \"Failed to decode XMP metadata.\" << std::endl;\n#endif\n                } else {\n#ifdef DEBUG\n                    std::cout << \"Display Hex Dump [size:\" << (unsigned long)payload.size_ << \"]\" << std::endl;\n                    std::cout << Internal::binaryToHex(payload.pData_, payload.size_);\n#endif\n                }\n            } else {\n                io_->seek(size, BasicIo::cur);\n            }\n\n            if ( io_->tell() % 2 ) io_->seek(+1, BasicIo::cur);\n        }\n    }",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146366,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "    void WebPImage::decodeChunks(uint32_t filesize)\n    {\n        DataBuf   chunkId(5);\n        byte      size_buff[WEBP_TAG_SIZE];\n        bool      has_canvas_data = false;\n\n#ifdef DEBUG\n        std::cout << \"Reading metadata\" << std::endl;\n#endif\n\n        chunkId.pData_[4] = '\\0' ;\n        while ( !io_->eof() && (uint64_t) io_->tell() < filesize) {\n            readOrThrow(*io_, chunkId.pData_, WEBP_TAG_SIZE, Exiv2::kerCorruptedMetadata);\n            readOrThrow(*io_, size_buff, WEBP_TAG_SIZE, Exiv2::kerCorruptedMetadata);\n            const uint32_t size = Exiv2::getULong(size_buff, littleEndian);\n            enforce(io_->tell() <= filesize, Exiv2::kerCorruptedMetadata);\n            enforce(size <= (filesize - io_->tell()), Exiv2::kerCorruptedMetadata);\n\n            DataBuf payload(size);\n\n            if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8X) && !has_canvas_data) {\n                enforce(size >= 10, Exiv2::kerCorruptedMetadata);\n\n                has_canvas_data = true;\n                byte size_buf[WEBP_TAG_SIZE];\n\n                readOrThrow(*io_, payload.pData_, payload.size_, Exiv2::kerCorruptedMetadata);\n\n                // Fetch width\n                memcpy(&size_buf, &payload.pData_[4], 3);\n                size_buf[3] = 0;\n                pixelWidth_ = Exiv2::getULong(size_buf, littleEndian) + 1;\n\n                // Fetch height\n                memcpy(&size_buf, &payload.pData_[7], 3);\n                size_buf[3] = 0;\n                pixelHeight_ = Exiv2::getULong(size_buf, littleEndian) + 1;\n            } else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8) && !has_canvas_data) {\n                enforce(size >= 10, Exiv2::kerCorruptedMetadata);\n\n                has_canvas_data = true;\n                readOrThrow(*io_, payload.pData_, payload.size_, Exiv2::kerCorruptedMetadata);\n                byte size_buf[WEBP_TAG_SIZE];\n\n                // Fetch width\"\"\n                memcpy(&size_buf, &payload.pData_[6], 2);\n                size_buf[2] = 0;\n                size_buf[3] = 0;\n                pixelWidth_ = Exiv2::getULong(size_buf, littleEndian) & 0x3fff;\n\n                // Fetch height\n                memcpy(&size_buf, &payload.pData_[8], 2);\n                size_buf[2] = 0;\n                size_buf[3] = 0;\n                pixelHeight_ = Exiv2::getULong(size_buf, littleEndian) & 0x3fff;\n            } else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8L) && !has_canvas_data) {\n                enforce(size >= 5, Exiv2::kerCorruptedMetadata);\n\n                has_canvas_data = true;\n                byte size_buf_w[2];\n                byte size_buf_h[3];\n\n                readOrThrow(*io_, payload.pData_, payload.size_, Exiv2::kerCorruptedMetadata);\n\n                // Fetch width\n                memcpy(&size_buf_w, &payload.pData_[1], 2);\n                size_buf_w[1] &= 0x3F;\n                pixelWidth_ = Exiv2::getUShort(size_buf_w, littleEndian) + 1;\n\n                // Fetch height\n                memcpy(&size_buf_h, &payload.pData_[2], 3);\n                size_buf_h[0] = ((size_buf_h[0] >> 6) & 0x3) | ((size_buf_h[1]  & 0x3F) << 0x2);\n                size_buf_h[1] = ((size_buf_h[1] >> 6) & 0x3) | ((size_buf_h[2] & 0xF) << 0x2);\n                pixelHeight_ = Exiv2::getUShort(size_buf_h, littleEndian) + 1;\n            } else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_ANMF) && !has_canvas_data) {\n                enforce(size >= 12, Exiv2::kerCorruptedMetadata);\n\n                has_canvas_data = true;\n                byte size_buf[WEBP_TAG_SIZE];\n\n                readOrThrow(*io_, payload.pData_, payload.size_, Exiv2::kerCorruptedMetadata);\n\n                // Fetch width\n                memcpy(&size_buf, &payload.pData_[6], 3);\n                size_buf[3] = 0;\n                pixelWidth_ = Exiv2::getULong(size_buf, littleEndian) + 1;\n\n                // Fetch height\n                memcpy(&size_buf, &payload.pData_[9], 3);\n                size_buf[3] = 0;\n                pixelHeight_ = Exiv2::getULong(size_buf, littleEndian) + 1;\n            } else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_ICCP)) {\n                readOrThrow(*io_, payload.pData_, payload.size_, Exiv2::kerCorruptedMetadata);\n                this->setIccProfile(payload);\n            } else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_EXIF)) {\n                readOrThrow(*io_, payload.pData_, payload.size_, Exiv2::kerCorruptedMetadata);\n\n                byte  size_buff[2];\n                // 4 meaningful bytes + 2 padding bytes\n                byte  exifLongHeader[]   = { 0xFF, 0x01, 0xFF, 0xE1, 0x00, 0x00 };\n                byte  exifShortHeader[]  = { 0x45, 0x78, 0x69, 0x66, 0x00, 0x00 };\n                byte  exifTiffLEHeader[] = { 0x49, 0x49, 0x2A };       // \"MM*\"\n                byte  exifTiffBEHeader[] = { 0x4D, 0x4D, 0x00, 0x2A }; // \"II\\0*\"\n                byte* rawExifData = NULL;\n                long  offset = 0;\n                bool  s_header = false;\n                bool  le_header = false;\n                bool  be_header = false;\n                long  pos = getHeaderOffset (payload.pData_, payload.size_, (byte*)&exifLongHeader, 4);\n\n                if (pos == -1) {\n                    pos = getHeaderOffset (payload.pData_, payload.size_, (byte*)&exifLongHeader, 6);\n                    if (pos != -1) {\n                        s_header = true;\n                    }\n                }\n                if (pos == -1) {\n                    pos = getHeaderOffset (payload.pData_, payload.size_, (byte*)&exifTiffLEHeader, 3);\n                    if (pos != -1) {\n                        le_header = true;\n                    }\n                }\n                if (pos == -1) {\n                    pos = getHeaderOffset (payload.pData_, payload.size_, (byte*)&exifTiffBEHeader, 4);\n                    if (pos != -1) {\n                        be_header = true;\n                    }\n                }\n\n                if (s_header) {\n                    offset += 6;\n                }\n                if (be_header || le_header) {\n                    offset += 12;\n                }\n\n                const long size = payload.size_ + offset;\n                rawExifData = (byte*)malloc(size);\n\n                if (s_header) {\n                    us2Data(size_buff, (uint16_t) (size - 6), bigEndian);\n                    memcpy(rawExifData, (char*)&exifLongHeader, 4);\n                    memcpy(rawExifData + 4, (char*)&size_buff, 2);\n                }\n\n                if (be_header || le_header) {\n                    us2Data(size_buff, (uint16_t) (size - 6), bigEndian);\n                    memcpy(rawExifData, (char*)&exifLongHeader, 4);\n                    memcpy(rawExifData + 4, (char*)&size_buff, 2);\n                    memcpy(rawExifData + 6, (char*)&exifShortHeader, 6);\n                }\n\n                memcpy(rawExifData + offset, payload.pData_, payload.size_);\n\n#ifdef DEBUG\n                std::cout << \"Display Hex Dump [size:\" << (unsigned long)size << \"]\" << std::endl;\n                std::cout << Internal::binaryToHex(rawExifData, size);\n#endif\n\n                if (pos != -1) {\n                    XmpData  xmpData;\n                    ByteOrder bo = ExifParser::decode(exifData_,\n                                                      payload.pData_ + pos,\n                                                      payload.size_ - pos);\n                    setByteOrder(bo);\n                }\n                else\n                {\n#ifndef SUPPRESS_WARNINGS\n                    EXV_WARNING << \"Failed to decode Exif metadata.\" << std::endl;\n#endif\n                    exifData_.clear();\n                }\n\n                if (rawExifData) free(rawExifData);\n            } else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_XMP)) {\n                readOrThrow(*io_, payload.pData_, payload.size_, Exiv2::kerCorruptedMetadata);\n                xmpPacket_.assign(reinterpret_cast<char*>(payload.pData_), payload.size_);\n                if (xmpPacket_.size() > 0 && XmpParser::decode(xmpData_, xmpPacket_)) {\n#ifndef SUPPRESS_WARNINGS\n                    EXV_WARNING << \"Failed to decode XMP metadata.\" << std::endl;\n#endif\n                } else {\n#ifdef DEBUG\n                    std::cout << \"Display Hex Dump [size:\" << (unsigned long)payload.size_ << \"]\" << std::endl;\n                    std::cout << Internal::binaryToHex(payload.pData_, payload.size_);\n#endif\n                }\n            } else {\n                io_->seek(size, BasicIo::cur);\n            }\n\n            if ( io_->tell() % 2 ) io_->seek(+1, BasicIo::cur);\n        }\n    }",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146367,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "read_channel_data (PSDchannel     *channel,\n                   const guint16   bps,\n                   const guint16   compression,\n                   const guint16  *rle_pack_len,\n                   FILE           *f,\n                   GError        **error)\n{\n  gchar    *raw_data;\n  gchar    *src;\n  gchar    *dst;\n  guint32   readline_len;\n  gint      i;\n\n  if (bps == 1)\n    readline_len = ((channel->columns + 7) >> 3);\n  else\n    readline_len = (channel->columns * bps >> 3);\n\n  IFDBG(3) g_debug (\"raw data size %d x %d = %d\", readline_len,\n                    channel->rows, readline_len * channel->rows);\n  raw_data = g_malloc (readline_len * channel->rows);\n  switch (compression)\n    {\n      case PSD_COMP_RAW:\n        if (fread (raw_data, readline_len, channel->rows, f) < 1)\n          {\n            psd_set_error (feof (f), errno, error);\n            return -1;\n          }\n        break;\n\n      case PSD_COMP_RLE:\n        for (i = 0; i < channel->rows; ++i)\n          {\n            src = g_malloc (rle_pack_len[i]);\n            dst = g_malloc (readline_len);\n/*      FIXME check for over-run\n            if (ftell (f) + rle_pack_len[i] > block_end)\n              {\n                psd_set_error (TRUE, errno, error);\n                return -1;\n              }\n*/\n            if (fread (src, rle_pack_len[i], 1, f) < 1)\n              {\n                psd_set_error (feof (f), errno, error);\n                return -1;\n              }\n            /* FIXME check for errors returned from decode packbits */\n            decode_packbits (src, dst, rle_pack_len[i], readline_len);\n            g_free (src);\n            memcpy (raw_data + i * readline_len, dst, readline_len);\n            g_free (dst);\n          }\n        break;\n    }\n\n  /* Convert channel data to GIMP format */\n  switch (bps)\n    {\n      case 16:\n        channel->data = (gchar *) g_malloc (channel->rows * channel->columns);\n        convert_16_bit (raw_data, channel->data, (channel->rows * channel->columns) << 1);\n        break;\n\n      case 8:\n        channel->data = (gchar *) g_malloc (channel->rows * channel->columns);\n        memcpy (channel->data, raw_data, (channel->rows * channel->columns));\n        break;\n\n      case 1:\n        channel->data = (gchar *) g_malloc (channel->rows * channel->columns);\n        convert_1_bit (raw_data, channel->data, channel->rows, channel->columns);\n        break;\n    }\n\n  g_free (raw_data);\n\n  return 1;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146398,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "read_channel_data (PSDchannel     *channel,\n                   const guint16   bps,\n                   const guint16   compression,\n                   const guint16  *rle_pack_len,\n                   FILE           *f,\n                   GError        **error)\n{\n  gchar    *raw_data;\n  gchar    *src;\n  gchar    *dst;\n  guint32   readline_len;\n  gint      i;\n\n  if (bps == 1)\n    readline_len = ((channel->columns + 7) >> 3);\n  else\n    readline_len = (channel->columns * bps >> 3);\n\n  IFDBG(3) g_debug (\"raw data size %d x %d = %d\", readline_len,\n                    channel->rows, readline_len * channel->rows);\n\n  /* sanity check, int overflow check (avoid divisions by zero) */\n  if ((channel->rows == 0) || (channel->columns == 0) ||\n      (channel->rows > G_MAXINT32 / channel->columns / MAX (bps >> 3, 1)))\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"Unsupported or invalid channel size\"));\n      return -1;\n    }\n\n  raw_data = g_malloc (readline_len * channel->rows);\n  switch (compression)\n    {\n      case PSD_COMP_RAW:\n        if (fread (raw_data, readline_len, channel->rows, f) < 1)\n          {\n            psd_set_error (feof (f), errno, error);\n            return -1;\n          }\n        break;\n\n      case PSD_COMP_RLE:\n        for (i = 0; i < channel->rows; ++i)\n          {\n            src = g_malloc (rle_pack_len[i]);\n            dst = g_malloc (readline_len);\n/*      FIXME check for over-run\n            if (ftell (f) + rle_pack_len[i] > block_end)\n              {\n                psd_set_error (TRUE, errno, error);\n                return -1;\n              }\n*/\n            if (fread (src, rle_pack_len[i], 1, f) < 1)\n              {\n                psd_set_error (feof (f), errno, error);\n                return -1;\n              }\n            /* FIXME check for errors returned from decode packbits */\n            decode_packbits (src, dst, rle_pack_len[i], readline_len);\n            g_free (src);\n            memcpy (raw_data + i * readline_len, dst, readline_len);\n            g_free (dst);\n          }\n        break;\n    }\n\n  /* Convert channel data to GIMP format */\n  switch (bps)\n    {\n      case 16:\n        channel->data = (gchar *) g_malloc (channel->rows * channel->columns);\n        convert_16_bit (raw_data, channel->data, (channel->rows * channel->columns) << 1);\n        break;\n\n      case 8:\n        channel->data = (gchar *) g_malloc (channel->rows * channel->columns);\n        memcpy (channel->data, raw_data, (channel->rows * channel->columns));\n        break;\n\n      case 1:\n        channel->data = (gchar *) g_malloc (channel->rows * channel->columns);\n        convert_1_bit (raw_data, channel->data, channel->rows, channel->columns);\n        break;\n    }\n\n  g_free (raw_data);\n\n  return 1;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146399,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "    void PngImage::readMetadata()\n    {\n#ifdef DEBUG\n        std::cerr << \"Exiv2::PngImage::readMetadata: Reading PNG file \" << io_->path() << std::endl;\n#endif\n        if (io_->open() != 0) {\n            throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        }\n        IoCloser closer(*io_);\n        if (!isPngType(*io_, true)) {\n            throw Error(kerNotAnImage, \"PNG\");\n        }\n        clearMetadata();\n\n        const long imgSize = (long)io_->size();\n        DataBuf cheaderBuf(8);  // Chunk header: 4 bytes (data size) + 4 bytes (chunk type).\n\n        while (!io_->eof()) {\n            std::memset(cheaderBuf.pData_, 0x0, cheaderBuf.size_);\n            readChunk(cheaderBuf, *io_);  // Read chunk header.\n\n            // Decode chunk data length.\n            uint32_t chunkLength = Exiv2::getULong(cheaderBuf.pData_, Exiv2::bigEndian);\n            long pos = io_->tell();\n            if (pos == -1 || chunkLength > uint32_t(0x7FFFFFFF) || static_cast<long>(chunkLength) > imgSize - pos) {\n                throw Exiv2::Error(kerFailedToReadImageData);\n            }\n\n            std::string chunkType(reinterpret_cast<char*>(cheaderBuf.pData_) + 4, 4);\n#ifdef DEBUG\n            std::cout << \"Exiv2::PngImage::readMetadata: chunk type: \" << chunkType << \" length: \" << chunkLength\n                      << std::endl;\n#endif\n\n            /// \\todo analyse remaining chunks of the standard\n            // Perform a chunk triage for item that we need.\n            if (chunkType == \"IEND\" || chunkType == \"IHDR\" || chunkType == \"tEXt\" || chunkType == \"zTXt\" ||\n                chunkType == \"iTXt\" || chunkType == \"iCCP\") {\n                DataBuf chunkData(chunkLength);\n                readChunk(chunkData, *io_);  // Extract chunk data.\n\n                if (chunkType == \"IEND\") {\n                    return;  // Last chunk found: we stop parsing.\n                } else if (chunkType == \"IHDR\" && chunkData.size_ >= 8) {\n                    Internal::PngImageHeader header;\n                    PngChunk::decodeIHDRChunk(chunkData, header);\n                    pixelWidth_ = header.width;\n                    pixelHeight_ = header.height;\n                    /// \\todo handle rest of data\n                } else if (chunkType == \"tEXt\") {\n                    PngChunk::decodeTXTChunk(this, chunkData, PngChunk::tEXt_Chunk);\n                } else if (chunkType == \"zTXt\") {\n                    PngChunk::decodeTXTChunk(this, chunkData, PngChunk::zTXt_Chunk);\n                } else if (chunkType == \"iTXt\") {\n                    PngChunk::decodeTXTChunk(this, chunkData, PngChunk::iTXt_Chunk);\n                } else if (chunkType == \"iCCP\") {\n                    // The ICC profile name can vary from 1-79 characters.\n                    uint32_t iccOffset = 0;\n                    while (iccOffset < 80 && iccOffset < chunkLength) {\n                        if (chunkData.pData_[iccOffset++] == 0x00) {\n                            break;\n                        }\n                    }\n                    profileName_ = std::string(reinterpret_cast<char*>(chunkData.pData_), iccOffset - 1);\n                    ++iccOffset;  // +1 = 'compressed' flag\n\n                    zlibToDataBuf(chunkData.pData_ + iccOffset, chunkLength - iccOffset, iccProfile_);\n#ifdef DEBUG\n                    std::cout << \"Exiv2::PngImage::readMetadata: profile name: \" << profileName_ << std::endl;\n                    std::cout << \"Exiv2::PngImage::readMetadata: iccProfile.size_ (uncompressed) : \"\n                              << iccProfile_.size_ << std::endl;\n#endif\n                }\n\n                // Set chunkLength to 0 in case we have read a supported chunk type. Otherwise, we need to seek the\n                // file to the next chunk position.\n                chunkLength = 0;\n            }\n\n            // Move to the next chunk: chunk data size + 4 CRC bytes.\n#ifdef DEBUG\n            std::cout << \"Exiv2::PngImage::readMetadata: Seek to offset: \" << chunkLength + 4 << std::endl;\n#endif\n            io_->seek(chunkLength + 4, BasicIo::cur);\n            if (io_->error() || io_->eof()) {\n                throw Error(kerFailedToReadImageData);\n            }\n        }\n    }  // PngImage::readMetadata",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146406,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "    void PngImage::readMetadata()\n    {\n#ifdef DEBUG\n        std::cerr << \"Exiv2::PngImage::readMetadata: Reading PNG file \" << io_->path() << std::endl;\n#endif\n        if (io_->open() != 0) {\n            throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        }\n        IoCloser closer(*io_);\n        if (!isPngType(*io_, true)) {\n            throw Error(kerNotAnImage, \"PNG\");\n        }\n        clearMetadata();\n\n        const long imgSize = (long)io_->size();\n        DataBuf cheaderBuf(8);  // Chunk header: 4 bytes (data size) + 4 bytes (chunk type).\n\n        while (!io_->eof()) {\n            std::memset(cheaderBuf.pData_, 0x0, cheaderBuf.size_);\n            readChunk(cheaderBuf, *io_);  // Read chunk header.\n\n            // Decode chunk data length.\n            uint32_t chunkLength = Exiv2::getULong(cheaderBuf.pData_, Exiv2::bigEndian);\n            long pos = io_->tell();\n            if (pos == -1 || chunkLength > uint32_t(0x7FFFFFFF) || static_cast<long>(chunkLength) > imgSize - pos) {\n                throw Exiv2::Error(kerFailedToReadImageData);\n            }\n\n            std::string chunkType(reinterpret_cast<char*>(cheaderBuf.pData_) + 4, 4);\n#ifdef DEBUG\n            std::cout << \"Exiv2::PngImage::readMetadata: chunk type: \" << chunkType << \" length: \" << chunkLength\n                      << std::endl;\n#endif\n\n            /// \\todo analyse remaining chunks of the standard\n            // Perform a chunk triage for item that we need.\n            if (chunkType == \"IEND\" || chunkType == \"IHDR\" || chunkType == \"tEXt\" || chunkType == \"zTXt\" ||\n                chunkType == \"iTXt\" || chunkType == \"iCCP\") {\n                DataBuf chunkData(chunkLength);\n                readChunk(chunkData, *io_);  // Extract chunk data.\n\n                if (chunkType == \"IEND\") {\n                    return;  // Last chunk found: we stop parsing.\n                } else if (chunkType == \"IHDR\" && chunkData.size_ >= 8) {\n                    Internal::PngImageHeader header;\n                    PngChunk::decodeIHDRChunk(chunkData, header);\n                    pixelWidth_ = header.width;\n                    pixelHeight_ = header.height;\n                    /// \\todo handle rest of data\n                } else if (chunkType == \"tEXt\") {\n                    PngChunk::decodeTXTChunk(this, chunkData, PngChunk::tEXt_Chunk);\n                } else if (chunkType == \"zTXt\") {\n                    PngChunk::decodeTXTChunk(this, chunkData, PngChunk::zTXt_Chunk);\n                } else if (chunkType == \"iTXt\") {\n                    PngChunk::decodeTXTChunk(this, chunkData, PngChunk::iTXt_Chunk);\n                } else if (chunkType == \"iCCP\") {\n                    // The ICC profile name can vary from 1-79 characters.\n                    uint32_t iccOffset = 0;\n                    while (iccOffset < 80 && iccOffset < chunkLength) {\n                        if (chunkData.pData_[iccOffset++] == 0x00) {\n                            break;\n                        }\n                    }\n                    profileName_ = std::string(reinterpret_cast<char*>(chunkData.pData_), iccOffset - 1);\n                    ++iccOffset;  // +1 = 'compressed' flag\n                    enforce(iccOffset <= chunkLength, Exiv2::kerCorruptedMetadata);\n\n                    zlibToDataBuf(chunkData.pData_ + iccOffset, chunkLength - iccOffset, iccProfile_);\n#ifdef DEBUG\n                    std::cout << \"Exiv2::PngImage::readMetadata: profile name: \" << profileName_ << std::endl;\n                    std::cout << \"Exiv2::PngImage::readMetadata: iccProfile.size_ (uncompressed) : \"\n                              << iccProfile_.size_ << std::endl;\n#endif\n                }\n\n                // Set chunkLength to 0 in case we have read a supported chunk type. Otherwise, we need to seek the\n                // file to the next chunk position.\n                chunkLength = 0;\n            }\n\n            // Move to the next chunk: chunk data size + 4 CRC bytes.\n#ifdef DEBUG\n            std::cout << \"Exiv2::PngImage::readMetadata: Seek to offset: \" << chunkLength + 4 << std::endl;\n#endif\n            io_->seek(chunkLength + 4, BasicIo::cur);\n            if (io_->error() || io_->eof()) {\n                throw Error(kerFailedToReadImageData);\n            }\n        }\n    }  // PngImage::readMetadata",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146407,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "ReadBMP (const gchar  *name,\n         GError      **error)\n{\n  FILE     *fd;\n  guchar    buffer[64];\n  gint      ColormapSize, rowbytes, Maps;\n  gboolean  Grey = FALSE;\n  guchar    ColorMap[256][3];\n  gint32    image_ID;\n  gchar     magick[2];\n  Bitmap_Channel masks[4];\n\n  filename = name;\n  fd = g_fopen (filename, \"rb\");\n\n  if (!fd)\n    {\n      g_set_error (error, G_FILE_ERROR, g_file_error_from_errno (errno),\n                   _(\"Could not open '%s' for reading: %s\"),\n                   gimp_filename_to_utf8 (filename), g_strerror (errno));\n      return -1;\n    }\n\n  gimp_progress_init_printf (_(\"Opening '%s'\"),\n                             gimp_filename_to_utf8 (name));\n\n  /* It is a File. Now is it a Bitmap? Read the shortest possible header */\n\n  if (!ReadOK (fd, magick, 2) || !(!strncmp (magick, \"BA\", 2) ||\n     !strncmp (magick, \"BM\", 2) || !strncmp (magick, \"IC\", 2) ||\n     !strncmp (magick, \"PI\", 2) || !strncmp (magick, \"CI\", 2) ||\n     !strncmp (magick, \"CP\", 2)))\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"'%s' is not a valid BMP file\"),\n                   gimp_filename_to_utf8 (filename));\n      return -1;\n    }\n\n  while (!strncmp (magick, \"BA\", 2))\n    {\n      if (!ReadOK (fd, buffer, 12))\n        {\n          g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                       _(\"'%s' is not a valid BMP file\"),\n                       gimp_filename_to_utf8 (filename));\n          return -1;\n        }\n      if (!ReadOK (fd, magick, 2))\n        {\n          g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                       _(\"'%s' is not a valid BMP file\"),\n                       gimp_filename_to_utf8 (filename));\n          return -1;\n        }\n    }\n\n  if (!ReadOK (fd, buffer, 12))\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"'%s' is not a valid BMP file\"),\n                   gimp_filename_to_utf8 (filename));\n      return -1;\n    }\n\n  /* bring them to the right byteorder. Not too nice, but it should work */\n\n  Bitmap_File_Head.bfSize    = ToL (&buffer[0x00]);\n  Bitmap_File_Head.zzHotX    = ToS (&buffer[0x04]);\n  Bitmap_File_Head.zzHotY    = ToS (&buffer[0x06]);\n  Bitmap_File_Head.bfOffs    = ToL (&buffer[0x08]);\n\n  if (!ReadOK (fd, buffer, 4))\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"'%s' is not a valid BMP file\"),\n                   gimp_filename_to_utf8 (filename));\n      return -1;\n    }\n\n  Bitmap_File_Head.biSize    = ToL (&buffer[0x00]);\n\n  /* What kind of bitmap is it? */\n\n  if (Bitmap_File_Head.biSize == 12) /* OS/2 1.x ? */\n    {\n      if (!ReadOK (fd, buffer, 8))\n        {\n          g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                       _(\"Error reading BMP file header from '%s'\"),\n                       gimp_filename_to_utf8 (filename));\n          return -1;\n        }\n\n      Bitmap_Head.biWidth   = ToS (&buffer[0x00]);       /* 12 */\n      Bitmap_Head.biHeight  = ToS (&buffer[0x02]);       /* 14 */\n      Bitmap_Head.biPlanes  = ToS (&buffer[0x04]);       /* 16 */\n      Bitmap_Head.biBitCnt  = ToS (&buffer[0x06]);       /* 18 */\n      Bitmap_Head.biCompr   = 0;\n      Bitmap_Head.biSizeIm  = 0;\n      Bitmap_Head.biXPels   = Bitmap_Head.biYPels = 0;\n      Bitmap_Head.biClrUsed = 0;\n      Bitmap_Head.biClrImp  = 0;\n      Bitmap_Head.masks[0]  = 0;\n      Bitmap_Head.masks[1]  = 0;\n      Bitmap_Head.masks[2]  = 0;\n      Bitmap_Head.masks[3]  = 0;\n\n      memset(masks, 0, sizeof(masks));\n      Maps = 3;\n    }\n  else if (Bitmap_File_Head.biSize == 40) /* Windows 3.x */\n    {\n      if (!ReadOK (fd, buffer, 36))\n        {\n          g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                       _(\"Error reading BMP file header from '%s'\"),\n                       gimp_filename_to_utf8 (filename));\n          return -1;\n        }\n\n      Bitmap_Head.biWidth   = ToL (&buffer[0x00]);      /* 12 */\n      Bitmap_Head.biHeight  = ToL (&buffer[0x04]);      /* 16 */\n      Bitmap_Head.biPlanes  = ToS (&buffer[0x08]);       /* 1A */\n      Bitmap_Head.biBitCnt  = ToS (&buffer[0x0A]);      /* 1C */\n      Bitmap_Head.biCompr   = ToL (&buffer[0x0C]);      /* 1E */\n      Bitmap_Head.biSizeIm  = ToL (&buffer[0x10]);      /* 22 */\n      Bitmap_Head.biXPels   = ToL (&buffer[0x14]);      /* 26 */\n      Bitmap_Head.biYPels   = ToL (&buffer[0x18]);      /* 2A */\n      Bitmap_Head.biClrUsed = ToL (&buffer[0x1C]);      /* 2E */\n      Bitmap_Head.biClrImp  = ToL (&buffer[0x20]);      /* 32 */\n      Bitmap_Head.masks[0]  = 0;\n      Bitmap_Head.masks[1]  = 0;\n      Bitmap_Head.masks[2]  = 0;\n      Bitmap_Head.masks[3]  = 0;\n\n      Maps = 4;\n      memset(masks, 0, sizeof(masks));\n\n      if (Bitmap_Head.biCompr == BI_BITFIELDS)\n        {\n          if (!ReadOK (fd, buffer, 3 * sizeof (guint32)))\n            {\n              g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                           _(\"Error reading BMP file header from '%s'\"),\n                           gimp_filename_to_utf8 (filename));\n              return -1;\n            }\n\n          Bitmap_Head.masks[0] = ToL(&buffer[0x00]);\n          Bitmap_Head.masks[1] = ToL(&buffer[0x04]);\n          Bitmap_Head.masks[2] = ToL(&buffer[0x08]);\n         ReadChannelMasks (&Bitmap_Head.masks[0], masks, 3);\n        }\n      else\n        switch (Bitmap_Head.biBitCnt)\n          {\n          case 32:\n            masks[0].mask     = 0x00ff0000;\n            masks[0].shiftin  = 16;\n            masks[0].max_value= (gfloat)255.0;\n            masks[1].mask     = 0x0000ff00;\n            masks[1].shiftin  = 8;\n            masks[1].max_value= (gfloat)255.0;\n            masks[2].mask     = 0x000000ff;\n            masks[2].shiftin  = 0;\n            masks[2].max_value= (gfloat)255.0;\n            masks[3].mask     = 0xff000000;\n            masks[3].shiftin  = 24;\n            masks[3].max_value= (gfloat)255.0;\n            break;\n         case 24:\n            masks[0].mask     = 0xff0000;\n            masks[0].shiftin  = 16;\n            masks[0].max_value= (gfloat)255.0;\n            masks[1].mask     = 0x00ff00;\n            masks[1].shiftin  = 8;\n            masks[1].max_value= (gfloat)255.0;\n            masks[2].mask     = 0x0000ff;\n            masks[2].shiftin  = 0;\n            masks[2].max_value= (gfloat)255.0;\n            masks[3].mask     = 0x0;\n            masks[3].shiftin  = 0;\n            masks[3].max_value= (gfloat)0.0;\n            break;\n         case 16:\n            masks[0].mask     = 0x7c00;\n            masks[0].shiftin  = 10;\n            masks[0].max_value= (gfloat)31.0;\n            masks[1].mask     = 0x03e0;\n            masks[1].shiftin  = 5;\n            masks[1].max_value= (gfloat)31.0;\n            masks[2].mask     = 0x001f;\n            masks[2].shiftin  = 0;\n            masks[2].max_value= (gfloat)31.0;\n            masks[3].mask     = 0x0;\n            masks[3].shiftin  = 0;\n            masks[3].max_value= (gfloat)0.0;\n            break;\n         default:\n            break;\n         }\n    }\n  else if (Bitmap_File_Head.biSize >= 56 && Bitmap_File_Head.biSize <= 64)\n    /* enhanced Windows format with bit masks */\n    {\n      if (!ReadOK (fd, buffer, Bitmap_File_Head.biSize - 4))\n        {\n          g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                       _(\"Error reading BMP file header from '%s'\"),\n                       gimp_filename_to_utf8 (filename));\n          return -1;\n        }\n\n      Bitmap_Head.biWidth   =ToL (&buffer[0x00]);       /* 12 */\n      Bitmap_Head.biHeight  =ToL (&buffer[0x04]);       /* 16 */\n      Bitmap_Head.biPlanes  =ToS (&buffer[0x08]);       /* 1A */\n      Bitmap_Head.biBitCnt  =ToS (&buffer[0x0A]);       /* 1C */\n      Bitmap_Head.biCompr   =ToL (&buffer[0x0C]);       /* 1E */\n      Bitmap_Head.biSizeIm  =ToL (&buffer[0x10]);       /* 22 */\n      Bitmap_Head.biXPels   =ToL (&buffer[0x14]);       /* 26 */\n      Bitmap_Head.biYPels   =ToL (&buffer[0x18]);       /* 2A */\n      Bitmap_Head.biClrUsed =ToL (&buffer[0x1C]);       /* 2E */\n      Bitmap_Head.biClrImp  =ToL (&buffer[0x20]);       /* 32 */\n      Bitmap_Head.masks[0]  =ToL (&buffer[0x24]);       /* 36 */\n      Bitmap_Head.masks[1]  =ToL (&buffer[0x28]);       /* 3A */\n      Bitmap_Head.masks[2]  =ToL (&buffer[0x2C]);       /* 3E */\n      Bitmap_Head.masks[3]  =ToL (&buffer[0x30]);       /* 42 */\n\n      Maps = 4;\n      ReadChannelMasks (&Bitmap_Head.masks[0], masks, 4);\n    }\n  else\n    {\n      GdkPixbuf* pixbuf = gdk_pixbuf_new_from_file(filename, NULL);\n\n      if (pixbuf)\n        {\n          gint32 layer_ID;\n\n          image_ID = gimp_image_new (gdk_pixbuf_get_width (pixbuf),\n                                     gdk_pixbuf_get_height (pixbuf),\n                                     GIMP_RGB);\n\n          layer_ID = gimp_layer_new_from_pixbuf (image_ID, _(\"Background\"),\n                                                 pixbuf,\n                                                 100.,\n                                                 GIMP_NORMAL_MODE, 0, 0);\n          g_object_unref (pixbuf);\n\n          gimp_image_set_filename (image_ID, filename);\n          gimp_image_add_layer (image_ID, layer_ID, -1);\n\n          return image_ID;\n        }\n      else\n        {\n\n          g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                       _(\"Error reading BMP file header from '%s'\"),\n                       gimp_filename_to_utf8 (filename));\n          return -1;\n        }\n    }\n\n  /* Valid bitpdepthis 1, 4, 8, 16, 24, 32 */\n  /* 16 is awful, we should probably shoot whoever invented it */\n\n  /* There should be some colors used! */\n\n  ColormapSize =\n    (Bitmap_File_Head.bfOffs - Bitmap_File_Head.biSize - 14) / Maps;\n\n  if ((Bitmap_Head.biClrUsed == 0) && (Bitmap_Head.biBitCnt <= 8))\n    ColormapSize = Bitmap_Head.biClrUsed = 1 << Bitmap_Head.biBitCnt;\n\n  if (ColormapSize > 256)\n    ColormapSize = 256;\n\n  /* Sanity checks */\n\n  if (Bitmap_Head.biHeight == 0 || Bitmap_Head.biWidth == 0)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"'%s' is not a valid BMP file\"),\n                   gimp_filename_to_utf8 (filename));\n      return -1;\n    }\n\n  if (Bitmap_Head.biWidth < 0)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"'%s' is not a valid BMP file\"),\n                   gimp_filename_to_utf8 (filename));\n      return -1;\n    }\n\n  if (Bitmap_Head.biPlanes != 1)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"'%s' is not a valid BMP file\"),\n                   gimp_filename_to_utf8 (filename));\n      return -1;\n    }\n\n  if (Bitmap_Head.biClrUsed > 256)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"'%s' is not a valid BMP file\"),\n                   gimp_filename_to_utf8 (filename));\n      return -1;\n    }\n\n  /* Windows and OS/2 declare filler so that rows are a multiple of\n   * word length (32 bits == 4 bytes)\n   */\n\n  rowbytes= ((Bitmap_Head.biWidth * Bitmap_Head.biBitCnt - 1) / 32) * 4 + 4;\n\n#ifdef DEBUG\n  printf (\"\\nSize: %u, Colors: %u, Bits: %u, Width: %u, Height: %u, \"\n          \"Comp: %u, Zeile: %u\\n\",\n          Bitmap_File_Head.bfSize,\n          Bitmap_Head.biClrUsed,\n          Bitmap_Head.biBitCnt,\n          Bitmap_Head.biWidth,\n          Bitmap_Head.biHeight,\n          Bitmap_Head.biCompr,\n          rowbytes);\n#endif\n\n  if (Bitmap_Head.biBitCnt <= 8)\n    {\n#ifdef DEBUG\n      printf (\"Colormap read\\n\");\n#endif\n      /* Get the Colormap */\n      if (!ReadColorMap (fd, ColorMap, ColormapSize, Maps, &Grey))\n        return -1;\n    }\n\n  fseek (fd, Bitmap_File_Head.bfOffs, SEEK_SET);\n\n  /* Get the Image and return the ID or -1 on error*/\n  image_ID = ReadImage (fd,\n                        Bitmap_Head.biWidth,\n                        ABS (Bitmap_Head.biHeight),\n                        ColorMap,\n                        Bitmap_Head.biClrUsed,\n                        Bitmap_Head.biBitCnt,\n                        Bitmap_Head.biCompr,\n                        rowbytes,\n                        Grey,\n                        masks,\n                        error);\n\n  if (image_ID < 0)\n    return -1;\n\n  if (Bitmap_Head.biXPels > 0 && Bitmap_Head.biYPels > 0)\n    {\n      /* Fixed up from scott@asofyet's changes last year, njl195 */\n      gdouble xresolution;\n      gdouble yresolution;\n\n      /* I don't agree with scott's feeling that Gimp should be\n       * trying to \"fix\" metric resolution translations, in the\n       * long term Gimp should be SI (metric) anyway, but we\n       * haven't told the Americans that yet  */\n\n      xresolution = Bitmap_Head.biXPels * 0.0254;\n      yresolution = Bitmap_Head.biYPels * 0.0254;\n\n      gimp_image_set_resolution (image_ID, xresolution, yresolution);\n    }\n\n  if (Bitmap_Head.biHeight < 0)\n    gimp_image_flip (image_ID, GIMP_ORIENTATION_VERTICAL);\n\n  return image_ID;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146488,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "ReadBMP (const gchar  *name,\n         GError      **error)\n{\n  FILE     *fd;\n  guchar    buffer[64];\n  gint      ColormapSize, rowbytes, Maps;\n  gboolean  Grey = FALSE;\n  guchar    ColorMap[256][3];\n  gint32    image_ID;\n  gchar     magick[2];\n  Bitmap_Channel masks[4];\n\n  filename = name;\n  fd = g_fopen (filename, \"rb\");\n\n  if (!fd)\n    {\n      g_set_error (error, G_FILE_ERROR, g_file_error_from_errno (errno),\n                   _(\"Could not open '%s' for reading: %s\"),\n                   gimp_filename_to_utf8 (filename), g_strerror (errno));\n      return -1;\n    }\n\n  gimp_progress_init_printf (_(\"Opening '%s'\"),\n                             gimp_filename_to_utf8 (name));\n\n  /* It is a File. Now is it a Bitmap? Read the shortest possible header */\n\n  if (!ReadOK (fd, magick, 2) || !(!strncmp (magick, \"BA\", 2) ||\n     !strncmp (magick, \"BM\", 2) || !strncmp (magick, \"IC\", 2) ||\n     !strncmp (magick, \"PI\", 2) || !strncmp (magick, \"CI\", 2) ||\n     !strncmp (magick, \"CP\", 2)))\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"'%s' is not a valid BMP file\"),\n                   gimp_filename_to_utf8 (filename));\n      return -1;\n    }\n\n  while (!strncmp (magick, \"BA\", 2))\n    {\n      if (!ReadOK (fd, buffer, 12))\n        {\n          g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                       _(\"'%s' is not a valid BMP file\"),\n                       gimp_filename_to_utf8 (filename));\n          return -1;\n        }\n      if (!ReadOK (fd, magick, 2))\n        {\n          g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                       _(\"'%s' is not a valid BMP file\"),\n                       gimp_filename_to_utf8 (filename));\n          return -1;\n        }\n    }\n\n  if (!ReadOK (fd, buffer, 12))\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"'%s' is not a valid BMP file\"),\n                   gimp_filename_to_utf8 (filename));\n      return -1;\n    }\n\n  /* bring them to the right byteorder. Not too nice, but it should work */\n\n  Bitmap_File_Head.bfSize    = ToL (&buffer[0x00]);\n  Bitmap_File_Head.zzHotX    = ToS (&buffer[0x04]);\n  Bitmap_File_Head.zzHotY    = ToS (&buffer[0x06]);\n  Bitmap_File_Head.bfOffs    = ToL (&buffer[0x08]);\n\n  if (!ReadOK (fd, buffer, 4))\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"'%s' is not a valid BMP file\"),\n                   gimp_filename_to_utf8 (filename));\n      return -1;\n    }\n\n  Bitmap_File_Head.biSize    = ToL (&buffer[0x00]);\n\n  /* What kind of bitmap is it? */\n\n  if (Bitmap_File_Head.biSize == 12) /* OS/2 1.x ? */\n    {\n      if (!ReadOK (fd, buffer, 8))\n        {\n          g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                       _(\"Error reading BMP file header from '%s'\"),\n                       gimp_filename_to_utf8 (filename));\n          return -1;\n        }\n\n      Bitmap_Head.biWidth   = ToS (&buffer[0x00]);       /* 12 */\n      Bitmap_Head.biHeight  = ToS (&buffer[0x02]);       /* 14 */\n      Bitmap_Head.biPlanes  = ToS (&buffer[0x04]);       /* 16 */\n      Bitmap_Head.biBitCnt  = ToS (&buffer[0x06]);       /* 18 */\n      Bitmap_Head.biCompr   = 0;\n      Bitmap_Head.biSizeIm  = 0;\n      Bitmap_Head.biXPels   = Bitmap_Head.biYPels = 0;\n      Bitmap_Head.biClrUsed = 0;\n      Bitmap_Head.biClrImp  = 0;\n      Bitmap_Head.masks[0]  = 0;\n      Bitmap_Head.masks[1]  = 0;\n      Bitmap_Head.masks[2]  = 0;\n      Bitmap_Head.masks[3]  = 0;\n\n      memset(masks, 0, sizeof(masks));\n      Maps = 3;\n    }\n  else if (Bitmap_File_Head.biSize == 40) /* Windows 3.x */\n    {\n      if (!ReadOK (fd, buffer, 36))\n        {\n          g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                       _(\"Error reading BMP file header from '%s'\"),\n                       gimp_filename_to_utf8 (filename));\n          return -1;\n        }\n\n      Bitmap_Head.biWidth   = ToL (&buffer[0x00]);      /* 12 */\n      Bitmap_Head.biHeight  = ToL (&buffer[0x04]);      /* 16 */\n      Bitmap_Head.biPlanes  = ToS (&buffer[0x08]);       /* 1A */\n      Bitmap_Head.biBitCnt  = ToS (&buffer[0x0A]);      /* 1C */\n      Bitmap_Head.biCompr   = ToL (&buffer[0x0C]);      /* 1E */\n      Bitmap_Head.biSizeIm  = ToL (&buffer[0x10]);      /* 22 */\n      Bitmap_Head.biXPels   = ToL (&buffer[0x14]);      /* 26 */\n      Bitmap_Head.biYPels   = ToL (&buffer[0x18]);      /* 2A */\n      Bitmap_Head.biClrUsed = ToL (&buffer[0x1C]);      /* 2E */\n      Bitmap_Head.biClrImp  = ToL (&buffer[0x20]);      /* 32 */\n      Bitmap_Head.masks[0]  = 0;\n      Bitmap_Head.masks[1]  = 0;\n      Bitmap_Head.masks[2]  = 0;\n      Bitmap_Head.masks[3]  = 0;\n\n      Maps = 4;\n      memset(masks, 0, sizeof(masks));\n\n      if (Bitmap_Head.biCompr == BI_BITFIELDS)\n        {\n          if (!ReadOK (fd, buffer, 3 * sizeof (guint32)))\n            {\n              g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                           _(\"Error reading BMP file header from '%s'\"),\n                           gimp_filename_to_utf8 (filename));\n              return -1;\n            }\n\n          Bitmap_Head.masks[0] = ToL(&buffer[0x00]);\n          Bitmap_Head.masks[1] = ToL(&buffer[0x04]);\n          Bitmap_Head.masks[2] = ToL(&buffer[0x08]);\n         ReadChannelMasks (&Bitmap_Head.masks[0], masks, 3);\n        }\n      else\n        switch (Bitmap_Head.biBitCnt)\n          {\n          case 32:\n            masks[0].mask     = 0x00ff0000;\n            masks[0].shiftin  = 16;\n            masks[0].max_value= (gfloat)255.0;\n            masks[1].mask     = 0x0000ff00;\n            masks[1].shiftin  = 8;\n            masks[1].max_value= (gfloat)255.0;\n            masks[2].mask     = 0x000000ff;\n            masks[2].shiftin  = 0;\n            masks[2].max_value= (gfloat)255.0;\n            masks[3].mask     = 0xff000000;\n            masks[3].shiftin  = 24;\n            masks[3].max_value= (gfloat)255.0;\n            break;\n         case 24:\n            masks[0].mask     = 0xff0000;\n            masks[0].shiftin  = 16;\n            masks[0].max_value= (gfloat)255.0;\n            masks[1].mask     = 0x00ff00;\n            masks[1].shiftin  = 8;\n            masks[1].max_value= (gfloat)255.0;\n            masks[2].mask     = 0x0000ff;\n            masks[2].shiftin  = 0;\n            masks[2].max_value= (gfloat)255.0;\n            masks[3].mask     = 0x0;\n            masks[3].shiftin  = 0;\n            masks[3].max_value= (gfloat)0.0;\n            break;\n         case 16:\n            masks[0].mask     = 0x7c00;\n            masks[0].shiftin  = 10;\n            masks[0].max_value= (gfloat)31.0;\n            masks[1].mask     = 0x03e0;\n            masks[1].shiftin  = 5;\n            masks[1].max_value= (gfloat)31.0;\n            masks[2].mask     = 0x001f;\n            masks[2].shiftin  = 0;\n            masks[2].max_value= (gfloat)31.0;\n            masks[3].mask     = 0x0;\n            masks[3].shiftin  = 0;\n            masks[3].max_value= (gfloat)0.0;\n            break;\n         default:\n            break;\n         }\n    }\n  else if (Bitmap_File_Head.biSize >= 56 && Bitmap_File_Head.biSize <= 64)\n    /* enhanced Windows format with bit masks */\n    {\n      if (!ReadOK (fd, buffer, Bitmap_File_Head.biSize - 4))\n        {\n          g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                       _(\"Error reading BMP file header from '%s'\"),\n                       gimp_filename_to_utf8 (filename));\n          return -1;\n        }\n\n      Bitmap_Head.biWidth   =ToL (&buffer[0x00]);       /* 12 */\n      Bitmap_Head.biHeight  =ToL (&buffer[0x04]);       /* 16 */\n      Bitmap_Head.biPlanes  =ToS (&buffer[0x08]);       /* 1A */\n      Bitmap_Head.biBitCnt  =ToS (&buffer[0x0A]);       /* 1C */\n      Bitmap_Head.biCompr   =ToL (&buffer[0x0C]);       /* 1E */\n      Bitmap_Head.biSizeIm  =ToL (&buffer[0x10]);       /* 22 */\n      Bitmap_Head.biXPels   =ToL (&buffer[0x14]);       /* 26 */\n      Bitmap_Head.biYPels   =ToL (&buffer[0x18]);       /* 2A */\n      Bitmap_Head.biClrUsed =ToL (&buffer[0x1C]);       /* 2E */\n      Bitmap_Head.biClrImp  =ToL (&buffer[0x20]);       /* 32 */\n      Bitmap_Head.masks[0]  =ToL (&buffer[0x24]);       /* 36 */\n      Bitmap_Head.masks[1]  =ToL (&buffer[0x28]);       /* 3A */\n      Bitmap_Head.masks[2]  =ToL (&buffer[0x2C]);       /* 3E */\n      Bitmap_Head.masks[3]  =ToL (&buffer[0x30]);       /* 42 */\n\n      Maps = 4;\n      ReadChannelMasks (&Bitmap_Head.masks[0], masks, 4);\n    }\n  else\n    {\n      GdkPixbuf* pixbuf = gdk_pixbuf_new_from_file(filename, NULL);\n\n      if (pixbuf)\n        {\n          gint32 layer_ID;\n\n          image_ID = gimp_image_new (gdk_pixbuf_get_width (pixbuf),\n                                     gdk_pixbuf_get_height (pixbuf),\n                                     GIMP_RGB);\n\n          layer_ID = gimp_layer_new_from_pixbuf (image_ID, _(\"Background\"),\n                                                 pixbuf,\n                                                 100.,\n                                                 GIMP_NORMAL_MODE, 0, 0);\n          g_object_unref (pixbuf);\n\n          gimp_image_set_filename (image_ID, filename);\n          gimp_image_add_layer (image_ID, layer_ID, -1);\n\n          return image_ID;\n        }\n      else\n        {\n\n          g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                       _(\"Error reading BMP file header from '%s'\"),\n                       gimp_filename_to_utf8 (filename));\n          return -1;\n        }\n    }\n\n  /* Valid bitpdepthis 1, 4, 8, 16, 24, 32 */\n  /* 16 is awful, we should probably shoot whoever invented it */\n\n  /* There should be some colors used! */\n\n  ColormapSize =\n    (Bitmap_File_Head.bfOffs - Bitmap_File_Head.biSize - 14) / Maps;\n\n  if ((Bitmap_Head.biClrUsed == 0) && (Bitmap_Head.biBitCnt <= 8))\n    ColormapSize = Bitmap_Head.biClrUsed = 1 << Bitmap_Head.biBitCnt;\n\n  if (ColormapSize > 256)\n    ColormapSize = 256;\n\n  /* Sanity checks */\n\n  if (Bitmap_Head.biHeight == 0 || Bitmap_Head.biWidth == 0)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"'%s' is not a valid BMP file\"),\n                   gimp_filename_to_utf8 (filename));\n      return -1;\n    }\n\n  if (Bitmap_Head.biWidth < 0 ||\n      ABS (Bitmap_Head.biHeight) < 0)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"'%s' is not a valid BMP file\"),\n                   gimp_filename_to_utf8 (filename));\n      return -1;\n    }\n\n  if (Bitmap_Head.biPlanes != 1)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"'%s' is not a valid BMP file\"),\n                   gimp_filename_to_utf8 (filename));\n      return -1;\n    }\n\n  if (Bitmap_Head.biClrUsed > 256)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"'%s' is not a valid BMP file\"),\n                   gimp_filename_to_utf8 (filename));\n      return -1;\n    }\n\n  /* protect against integer overflows caused by malicious BMPs */\n\n  if (((guint64) Bitmap_Head.biWidth) * Bitmap_Head.biBitCnt > G_MAXINT32 ||\n      ((guint64) Bitmap_Head.biWidth) * ABS (Bitmap_Head.biHeight) > G_MAXINT32 ||\n      ((guint64) Bitmap_Head.biWidth) * ABS (Bitmap_Head.biHeight) * 4 > G_MAXINT32)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"'%s' is not a valid BMP file\"),\n                   gimp_filename_to_utf8 (filename));\n      return -1;\n    }\n\n  /* Windows and OS/2 declare filler so that rows are a multiple of\n   * word length (32 bits == 4 bytes)\n   */\n\n  rowbytes= ((Bitmap_Head.biWidth * Bitmap_Head.biBitCnt - 1) / 32) * 4 + 4;\n\n#ifdef DEBUG\n  printf (\"\\nSize: %u, Colors: %u, Bits: %u, Width: %u, Height: %u, \"\n          \"Comp: %u, Zeile: %u\\n\",\n          Bitmap_File_Head.bfSize,\n          Bitmap_Head.biClrUsed,\n          Bitmap_Head.biBitCnt,\n          Bitmap_Head.biWidth,\n          Bitmap_Head.biHeight,\n          Bitmap_Head.biCompr,\n          rowbytes);\n#endif\n\n  if (Bitmap_Head.biBitCnt <= 8)\n    {\n#ifdef DEBUG\n      printf (\"Colormap read\\n\");\n#endif\n      /* Get the Colormap */\n      if (!ReadColorMap (fd, ColorMap, ColormapSize, Maps, &Grey))\n        return -1;\n    }\n\n  fseek (fd, Bitmap_File_Head.bfOffs, SEEK_SET);\n\n  /* Get the Image and return the ID or -1 on error*/\n  image_ID = ReadImage (fd,\n                        Bitmap_Head.biWidth,\n                        ABS (Bitmap_Head.biHeight),\n                        ColorMap,\n                        Bitmap_Head.biClrUsed,\n                        Bitmap_Head.biBitCnt,\n                        Bitmap_Head.biCompr,\n                        rowbytes,\n                        Grey,\n                        masks,\n                        error);\n\n  if (image_ID < 0)\n    return -1;\n\n  if (Bitmap_Head.biXPels > 0 && Bitmap_Head.biYPels > 0)\n    {\n      /* Fixed up from scott@asofyet's changes last year, njl195 */\n      gdouble xresolution;\n      gdouble yresolution;\n\n      /* I don't agree with scott's feeling that Gimp should be\n       * trying to \"fix\" metric resolution translations, in the\n       * long term Gimp should be SI (metric) anyway, but we\n       * haven't told the Americans that yet  */\n\n      xresolution = Bitmap_Head.biXPels * 0.0254;\n      yresolution = Bitmap_Head.biYPels * 0.0254;\n\n      gimp_image_set_resolution (image_ID, xresolution, yresolution);\n    }\n\n  if (Bitmap_Head.biHeight < 0)\n    gimp_image_flip (image_ID, GIMP_ORIENTATION_VERTICAL);\n\n  return image_ID;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146489,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "PLIST_API void plist_from_bin(const char *plist_bin, uint32_t length, plist_t * plist)\n{\n    bplist_trailer_t *trailer = NULL;\n    uint8_t offset_size = 0;\n    uint8_t ref_size = 0;\n    uint64_t num_objects = 0;\n    uint64_t root_object = 0;\n    const char *offset_table = NULL;\n    const char *start_data = NULL;\n    const char *end_data = NULL;\n\n    //first check we have enough data\n    if (!(length >= BPLIST_MAGIC_SIZE + BPLIST_VERSION_SIZE + sizeof(bplist_trailer_t))) {\n        PLIST_BIN_ERR(\"plist data is to small to hold a binary plist\\n\");\n        return;\n    }\n    //check that plist_bin in actually a plist\n    if (memcmp(plist_bin, BPLIST_MAGIC, BPLIST_MAGIC_SIZE) != 0) {\n        PLIST_BIN_ERR(\"bplist magic mismatch\\n\");\n        return;\n    }\n    //check for known version\n    if (memcmp(plist_bin + BPLIST_MAGIC_SIZE, BPLIST_VERSION, BPLIST_VERSION_SIZE) != 0) {\n        PLIST_BIN_ERR(\"unsupported binary plist version '%.2s\\n\", plist_bin+BPLIST_MAGIC_SIZE);\n        return;\n    }\n\n    start_data = plist_bin + BPLIST_MAGIC_SIZE + BPLIST_VERSION_SIZE;\n    end_data = plist_bin + length - sizeof(bplist_trailer_t);\n\n    //now parse trailer\n    trailer = (bplist_trailer_t*)end_data;\n\n    offset_size = trailer->offset_size;\n    ref_size = trailer->ref_size;\n    num_objects = be64toh(trailer->num_objects);\n    root_object = be64toh(trailer->root_object_index);\n    offset_table = (char *)(plist_bin + be64toh(trailer->offset_table_offset));\n\n    if (num_objects == 0) {\n        PLIST_BIN_ERR(\"number of objects must be larger than 0\\n\");\n        return;\n    }\n\n    if (offset_size == 0) {\n        PLIST_BIN_ERR(\"offset size in trailer must be larger than 0\\n\");\n        return;\n    }\n\n    if (ref_size == 0) {\n        PLIST_BIN_ERR(\"object reference size in trailer must be larger than 0\\n\");\n        return;\n    }\n\n    if (root_object >= num_objects) {\n        PLIST_BIN_ERR(\"root object index (%\" PRIu64 \") must be smaller than number of objects (%\" PRIu64 \")\\n\", root_object, num_objects);\n        return;\n    }\n\n    if (offset_table < start_data || offset_table >= end_data) {\n        PLIST_BIN_ERR(\"offset table offset points outside of valid range\\n\");\n        return;\n    }\n\n    if (num_objects * offset_size < num_objects) {\n        PLIST_BIN_ERR(\"integer overflow when calculating offset table size (too many objects)\\n\");\n        return;\n    }\n\n    if ((uint64_t)offset_table + num_objects * offset_size > (uint64_t)end_data) {\n        PLIST_BIN_ERR(\"offset table points outside of valid range\\n\");\n        return;\n    }\n\n    struct bplist_data bplist;\n    bplist.data = plist_bin;\n    bplist.size = length;\n    bplist.num_objects = num_objects;\n    bplist.ref_size = ref_size;\n    bplist.offset_size = offset_size;\n    bplist.offset_table = offset_table;\n    bplist.level = 0;\n    bplist.used_indexes = plist_new_array();\n\n    if (!bplist.used_indexes) {\n        PLIST_BIN_ERR(\"failed to create array to hold used node indexes. Out of memory?\\n\");\n        return;\n    }\n\n    *plist = parse_bin_node_at_index(&bplist, root_object);\n\n    plist_free(bplist.used_indexes);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146522,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "PLIST_API void plist_from_bin(const char *plist_bin, uint32_t length, plist_t * plist)\n{\n    bplist_trailer_t *trailer = NULL;\n    uint8_t offset_size = 0;\n    uint8_t ref_size = 0;\n    uint64_t num_objects = 0;\n    uint64_t root_object = 0;\n    const char *offset_table = NULL;\n    uint64_t offset_table_size = 0;\n    const char *start_data = NULL;\n    const char *end_data = NULL;\n\n    //first check we have enough data\n    if (!(length >= BPLIST_MAGIC_SIZE + BPLIST_VERSION_SIZE + sizeof(bplist_trailer_t))) {\n        PLIST_BIN_ERR(\"plist data is to small to hold a binary plist\\n\");\n        return;\n    }\n    //check that plist_bin in actually a plist\n    if (memcmp(plist_bin, BPLIST_MAGIC, BPLIST_MAGIC_SIZE) != 0) {\n        PLIST_BIN_ERR(\"bplist magic mismatch\\n\");\n        return;\n    }\n    //check for known version\n    if (memcmp(plist_bin + BPLIST_MAGIC_SIZE, BPLIST_VERSION, BPLIST_VERSION_SIZE) != 0) {\n        PLIST_BIN_ERR(\"unsupported binary plist version '%.2s\\n\", plist_bin+BPLIST_MAGIC_SIZE);\n        return;\n    }\n\n    start_data = plist_bin + BPLIST_MAGIC_SIZE + BPLIST_VERSION_SIZE;\n    end_data = plist_bin + length - sizeof(bplist_trailer_t);\n\n    //now parse trailer\n    trailer = (bplist_trailer_t*)end_data;\n\n    offset_size = trailer->offset_size;\n    ref_size = trailer->ref_size;\n    num_objects = be64toh(trailer->num_objects);\n    root_object = be64toh(trailer->root_object_index);\n    offset_table = (char *)(plist_bin + be64toh(trailer->offset_table_offset));\n\n    if (num_objects == 0) {\n        PLIST_BIN_ERR(\"number of objects must be larger than 0\\n\");\n        return;\n    }\n\n    if (offset_size == 0) {\n        PLIST_BIN_ERR(\"offset size in trailer must be larger than 0\\n\");\n        return;\n    }\n\n    if (ref_size == 0) {\n        PLIST_BIN_ERR(\"object reference size in trailer must be larger than 0\\n\");\n        return;\n    }\n\n    if (root_object >= num_objects) {\n        PLIST_BIN_ERR(\"root object index (%\" PRIu64 \") must be smaller than number of objects (%\" PRIu64 \")\\n\", root_object, num_objects);\n        return;\n    }\n\n    if (offset_table < start_data || offset_table >= end_data) {\n        PLIST_BIN_ERR(\"offset table offset points outside of valid range\\n\");\n        return;\n    }\n\n    if (uint64_mul_overflow(num_objects, offset_size, &offset_table_size)) {\n        PLIST_BIN_ERR(\"integer overflow when calculating offset table size\\n\");\n        return;\n    }\n\n    if ((offset_table + offset_table_size < offset_table) || (offset_table + offset_table_size > end_data)) {\n        PLIST_BIN_ERR(\"offset table points outside of valid range\\n\");\n        return;\n    }\n\n    struct bplist_data bplist;\n    bplist.data = plist_bin;\n    bplist.size = length;\n    bplist.num_objects = num_objects;\n    bplist.ref_size = ref_size;\n    bplist.offset_size = offset_size;\n    bplist.offset_table = offset_table;\n    bplist.level = 0;\n    bplist.used_indexes = plist_new_array();\n\n    if (!bplist.used_indexes) {\n        PLIST_BIN_ERR(\"failed to create array to hold used node indexes. Out of memory?\\n\");\n        return;\n    }\n\n    *plist = parse_bin_node_at_index(&bplist, root_object);\n\n    plist_free(bplist.used_indexes);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146523,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "PyImaging_MapBuffer(PyObject* self, PyObject* args)\n{\n    Py_ssize_t y, size;\n    Imaging im;\n\n    PyObject* target;\n    Py_buffer view;\n    char* mode;\n    char* codec;\n    PyObject* bbox;\n    Py_ssize_t offset;\n    int xsize, ysize;\n    int stride;\n    int ystep;\n\n    if (!PyArg_ParseTuple(args, \"O(ii)sOn(sii)\", &target, &xsize, &ysize,\n                          &codec, &bbox, &offset, &mode, &stride, &ystep))\n        return NULL;\n\n    if (!PyImaging_CheckBuffer(target)) {\n        PyErr_SetString(PyExc_TypeError, \"expected string or buffer\");\n        return NULL;\n    }\n\n    if (stride <= 0) {\n        if (!strcmp(mode, \"L\") || !strcmp(mode, \"P\"))\n            stride = xsize;\n        else if (!strncmp(mode, \"I;16\", 4))\n            stride = xsize * 2;\n        else\n            stride = xsize * 4;\n    }\n\n    size = (Py_ssize_t) ysize * stride;\n\n    /* check buffer size */\n    if (PyImaging_GetBuffer(target, &view) < 0)\n        return NULL;\n\n    if (view.len < 0) {\n        PyErr_SetString(PyExc_ValueError, \"buffer has negative size\");\n        return NULL;\n    }\n    if (offset + size > view.len) {\n        PyErr_SetString(PyExc_ValueError, \"buffer is not large enough\");\n        return NULL;\n    }\n\n    im = ImagingNewPrologueSubtype(\n        mode, xsize, ysize, sizeof(ImagingBufferInstance)\n        );\n    if (!im)\n        return NULL;\n\n    /* setup file pointers */\n    if (ystep > 0)\n        for (y = 0; y < ysize; y++)\n            im->image[y] = (char*)view.buf + offset + y * stride;\n    else\n        for (y = 0; y < ysize; y++)\n            im->image[ysize-y-1] = (char*)view.buf + offset + y * stride;\n\n    im->destroy = mapping_destroy_buffer;\n\n    Py_INCREF(target);\n    ((ImagingBufferInstance*) im)->target = target;\n    ((ImagingBufferInstance*) im)->view = view;\n\n    if (!ImagingNewEpilogue(im))\n        return NULL;\n\n    return PyImagingNew(im);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146612,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "PyImaging_MapBuffer(PyObject* self, PyObject* args)\n{\n    Py_ssize_t y, size;\n    Imaging im;\n\n    PyObject* target;\n    Py_buffer view;\n    char* mode;\n    char* codec;\n    PyObject* bbox;\n    Py_ssize_t offset;\n    int xsize, ysize;\n    int stride;\n    int ystep;\n\n    if (!PyArg_ParseTuple(args, \"O(ii)sOn(sii)\", &target, &xsize, &ysize,\n                          &codec, &bbox, &offset, &mode, &stride, &ystep))\n        return NULL;\n\n    if (!PyImaging_CheckBuffer(target)) {\n        PyErr_SetString(PyExc_TypeError, \"expected string or buffer\");\n        return NULL;\n    }\n\n    if (stride <= 0) {\n        if (!strcmp(mode, \"L\") || !strcmp(mode, \"P\"))\n            stride = xsize;\n        else if (!strncmp(mode, \"I;16\", 4))\n            stride = xsize * 2;\n        else\n            stride = xsize * 4;\n    }\n\n    if (ysize > INT_MAX / stride) {\n        PyErr_SetString(PyExc_MemoryError, \"Integer overflow in ysize\");\n        return NULL;\n    }\n\n    size = (Py_ssize_t) ysize * stride;\n\n    if (offset > SIZE_MAX - size) {\n        PyErr_SetString(PyExc_MemoryError, \"Integer overflow in offset\");\n        return NULL;\n    }        \n\n    /* check buffer size */\n    if (PyImaging_GetBuffer(target, &view) < 0)\n        return NULL;\n\n    if (view.len < 0) {\n        PyErr_SetString(PyExc_ValueError, \"buffer has negative size\");\n        return NULL;\n    }\n    if (offset + size > view.len) {\n        PyErr_SetString(PyExc_ValueError, \"buffer is not large enough\");\n        return NULL;\n    }\n\n    im = ImagingNewPrologueSubtype(\n        mode, xsize, ysize, sizeof(ImagingBufferInstance)\n        );\n    if (!im)\n        return NULL;\n\n    /* setup file pointers */\n    if (ystep > 0)\n        for (y = 0; y < ysize; y++)\n            im->image[y] = (char*)view.buf + offset + y * stride;\n    else\n        for (y = 0; y < ysize; y++)\n            im->image[ysize-y-1] = (char*)view.buf + offset + y * stride;\n\n    im->destroy = mapping_destroy_buffer;\n\n    Py_INCREF(target);\n    ((ImagingBufferInstance*) im)->target = target;\n    ((ImagingBufferInstance*) im)->view = view;\n\n    if (!ImagingNewEpilogue(im))\n        return NULL;\n\n    return PyImagingNew(im);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146613,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static MagickBooleanType WriteHDRImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  char\n    header[MagickPathExtent];\n\n  const char\n    *property;\n\n  MagickBooleanType\n    status;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  size_t\n    length;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    pixel[4],\n    *pixels;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  if (IsRGBColorspace(image->colorspace) == MagickFalse)\n    (void) TransformImageColorspace(image,RGBColorspace,exception);\n  /*\n    Write header.\n  */\n  (void) memset(header,' ',MagickPathExtent);\n  length=CopyMagickString(header,\"#?RADIANCE\\n\",MagickPathExtent);\n  (void) WriteBlob(image,length,(unsigned char *) header);\n  property=GetImageProperty(image,\"comment\",exception);\n  if ((property != (const char *) NULL) &&\n      (strchr(property,'\\n') == (char *) NULL))\n    {\n      count=FormatLocaleString(header,MagickPathExtent,\"#%.*s\\n\",\n        MagickPathExtent-3,property);\n      (void) WriteBlob(image,(size_t) count,(unsigned char *) header);\n    }\n  property=GetImageProperty(image,\"hdr:exposure\",exception);\n  if (property != (const char *) NULL)\n    {\n      count=FormatLocaleString(header,MagickPathExtent,\"EXPOSURE=%g\\n\",\n        strtod(property,(char **) NULL));\n      (void) WriteBlob(image,(size_t) count,(unsigned char *) header);\n    }\n  if (image->gamma != 0.0)\n    {\n      count=FormatLocaleString(header,MagickPathExtent,\"GAMMA=%g\\n\",\n        image->gamma);\n      (void) WriteBlob(image,(size_t) count,(unsigned char *) header);\n    }\n  count=FormatLocaleString(header,MagickPathExtent,\n    \"PRIMARIES=%g %g %g %g %g %g %g %g\\n\",\n    image->chromaticity.red_primary.x,image->chromaticity.red_primary.y,\n    image->chromaticity.green_primary.x,image->chromaticity.green_primary.y,\n    image->chromaticity.blue_primary.x,image->chromaticity.blue_primary.y,\n    image->chromaticity.white_point.x,image->chromaticity.white_point.y);\n  (void) WriteBlob(image,(size_t) count,(unsigned char *) header);\n  length=CopyMagickString(header,\"FORMAT=32-bit_rle_rgbe\\n\\n\",MagickPathExtent);\n  (void) WriteBlob(image,length,(unsigned char *) header);\n  count=FormatLocaleString(header,MagickPathExtent,\"-Y %.20g +X %.20g\\n\",\n    (double) image->rows,(double) image->columns);\n  (void) WriteBlob(image,(size_t) count,(unsigned char *) header);\n  /*\n    Write HDR pixels.\n  */\n  pixels=(unsigned char *) AcquireQuantumMemory(image->columns+128,4*\n    sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  (void) memset(pixels,0,4*(image->columns+128)*sizeof(*pixels));\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    if ((image->columns >= 8) && (image->columns <= 0x7ffff))\n      {\n        pixel[0]=2;\n        pixel[1]=2;\n        pixel[2]=(unsigned char) (image->columns >> 8);\n        pixel[3]=(unsigned char) (image->columns & 0xff);\n        count=WriteBlob(image,4*sizeof(*pixel),pixel);\n        if (count != (ssize_t) (4*sizeof(*pixel)))\n          break;\n      }\n    i=0;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        gamma;\n\n      pixel[0]=0;\n      pixel[1]=0;\n      pixel[2]=0;\n      pixel[3]=0;\n      gamma=QuantumScale*GetPixelRed(image,p);\n      if ((QuantumScale*GetPixelGreen(image,p)) > gamma)\n        gamma=QuantumScale*GetPixelGreen(image,p);\n      if ((QuantumScale*GetPixelBlue(image,p)) > gamma)\n        gamma=QuantumScale*GetPixelBlue(image,p);\n      if (gamma > MagickEpsilon)\n        {\n          int\n            exponent;\n\n          gamma=frexp(gamma,&exponent)*256.0/gamma;\n          pixel[0]=(unsigned char) (gamma*QuantumScale*GetPixelRed(image,p));\n          pixel[1]=(unsigned char) (gamma*QuantumScale*GetPixelGreen(image,p));\n          pixel[2]=(unsigned char) (gamma*QuantumScale*GetPixelBlue(image,p));\n          pixel[3]=(unsigned char) (exponent+128);\n        }\n      if ((image->columns >= 8) && (image->columns <= 0x7ffff))\n        {\n          pixels[x]=pixel[0];\n          pixels[x+image->columns]=pixel[1];\n          pixels[x+2*image->columns]=pixel[2];\n          pixels[x+3*image->columns]=pixel[3];\n        }\n      else\n        {\n          pixels[i++]=pixel[0];\n          pixels[i++]=pixel[1];\n          pixels[i++]=pixel[2];\n          pixels[i++]=pixel[3];\n        }\n      p+=GetPixelChannels(image);\n    }\n    if ((image->columns >= 8) && (image->columns <= 0x7ffff))\n      {\n        for (i=0; i < 4; i++)\n          length=HDRWriteRunlengthPixels(image,&pixels[i*image->columns]);\n      }\n    else\n      {\n        count=WriteBlob(image,4*image->columns*sizeof(*pixels),pixels);\n        if (count != (ssize_t) (4*image->columns*sizeof(*pixels)))\n          break;\n      }\n    status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146684,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static MagickBooleanType WriteHDRImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  char\n    header[MagickPathExtent];\n\n  const char\n    *property;\n\n  MagickBooleanType\n    status;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  size_t\n    length;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    pixel[4],\n    *pixels;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  if (IsRGBColorspace(image->colorspace) == MagickFalse)\n    (void) TransformImageColorspace(image,RGBColorspace,exception);\n  /*\n    Write header.\n  */\n  (void) memset(header,' ',MagickPathExtent);\n  length=CopyMagickString(header,\"#?RADIANCE\\n\",MagickPathExtent);\n  (void) WriteBlob(image,length,(unsigned char *) header);\n  property=GetImageProperty(image,\"comment\",exception);\n  if ((property != (const char *) NULL) &&\n      (strchr(property,'\\n') == (char *) NULL))\n    {\n      count=FormatLocaleString(header,MagickPathExtent,\"#%.*s\\n\",\n        MagickPathExtent-3,property);\n      (void) WriteBlob(image,(size_t) count,(unsigned char *) header);\n    }\n  property=GetImageProperty(image,\"hdr:exposure\",exception);\n  if (property != (const char *) NULL)\n    {\n      count=FormatLocaleString(header,MagickPathExtent,\"EXPOSURE=%g\\n\",\n        strtod(property,(char **) NULL));\n      (void) WriteBlob(image,(size_t) count,(unsigned char *) header);\n    }\n  if (image->gamma != 0.0)\n    {\n      count=FormatLocaleString(header,MagickPathExtent,\"GAMMA=%g\\n\",\n        image->gamma);\n      (void) WriteBlob(image,(size_t) count,(unsigned char *) header);\n    }\n  count=FormatLocaleString(header,MagickPathExtent,\n    \"PRIMARIES=%g %g %g %g %g %g %g %g\\n\",\n    image->chromaticity.red_primary.x,image->chromaticity.red_primary.y,\n    image->chromaticity.green_primary.x,image->chromaticity.green_primary.y,\n    image->chromaticity.blue_primary.x,image->chromaticity.blue_primary.y,\n    image->chromaticity.white_point.x,image->chromaticity.white_point.y);\n  (void) WriteBlob(image,(size_t) count,(unsigned char *) header);\n  length=CopyMagickString(header,\"FORMAT=32-bit_rle_rgbe\\n\\n\",MagickPathExtent);\n  (void) WriteBlob(image,length,(unsigned char *) header);\n  count=FormatLocaleString(header,MagickPathExtent,\"-Y %.20g +X %.20g\\n\",\n    (double) image->rows,(double) image->columns);\n  (void) WriteBlob(image,(size_t) count,(unsigned char *) header);\n  /*\n    Write HDR pixels.\n  */\n  pixels=(unsigned char *) AcquireQuantumMemory(image->columns+128,4*\n    sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  (void) memset(pixels,0,4*(image->columns+128)*sizeof(*pixels));\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    if ((image->columns >= 8) && (image->columns <= 0x7ffff))\n      {\n        pixel[0]=2;\n        pixel[1]=2;\n        pixel[2]=(unsigned char) (image->columns >> 8);\n        pixel[3]=(unsigned char) (image->columns & 0xff);\n        count=WriteBlob(image,4*sizeof(*pixel),pixel);\n        if (count != (ssize_t) (4*sizeof(*pixel)))\n          break;\n      }\n    i=0;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        gamma;\n\n      pixel[0]=0;\n      pixel[1]=0;\n      pixel[2]=0;\n      pixel[3]=0;\n      gamma=QuantumScale*GetPixelRed(image,p);\n      if ((QuantumScale*GetPixelGreen(image,p)) > gamma)\n        gamma=QuantumScale*GetPixelGreen(image,p);\n      if ((QuantumScale*GetPixelBlue(image,p)) > gamma)\n        gamma=QuantumScale*GetPixelBlue(image,p);\n      if (gamma > MagickEpsilon)\n        {\n          int\n            exponent;\n\n          gamma=frexp(gamma,&exponent)*256.0/gamma;\n          if (GetPixelRed(image,p) > 0)\n            pixel[0]=(unsigned char) (gamma*QuantumScale*GetPixelRed(image,p));\n          if (GetPixelGreen(image,p) > 0)\n            pixel[1]=(unsigned char) (gamma*QuantumScale*\n              GetPixelGreen(image,p));\n          if (GetPixelBlue(image,p) > 0)\n            pixel[2]=(unsigned char) (gamma*QuantumScale*GetPixelBlue(image,p));\n          pixel[3]=(unsigned char) (exponent+128);\n        }\n      if ((image->columns >= 8) && (image->columns <= 0x7ffff))\n        {\n          pixels[x]=pixel[0];\n          pixels[x+image->columns]=pixel[1];\n          pixels[x+2*image->columns]=pixel[2];\n          pixels[x+3*image->columns]=pixel[3];\n        }\n      else\n        {\n          pixels[i++]=pixel[0];\n          pixels[i++]=pixel[1];\n          pixels[i++]=pixel[2];\n          pixels[i++]=pixel[3];\n        }\n      p+=GetPixelChannels(image);\n    }\n    if ((image->columns >= 8) && (image->columns <= 0x7ffff))\n      {\n        for (i=0; i < 4; i++)\n          length=HDRWriteRunlengthPixels(image,&pixels[i*image->columns]);\n      }\n    else\n      {\n        count=WriteBlob(image,4*image->columns*sizeof(*pixels),pixels);\n        if (count != (ssize_t) (4*image->columns*sizeof(*pixels)))\n          break;\n      }\n    status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146685,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "mnote_pentax_entry_get_value (MnotePentaxEntry *entry,\n\t\t\t      char *val, unsigned int maxlen)\n{\n\tExifLong vl;\n\tExifShort vs, vs2;\n\tint i = 0, j = 0;\n\n\tif (!entry) return (NULL);\n\n\tmemset (val, 0, maxlen);\n\tmaxlen--;\n\n\tswitch (entry->tag) {\n\t  case MNOTE_PENTAX_TAG_MODE:\n\t  case MNOTE_PENTAX_TAG_QUALITY:\n\t  case MNOTE_PENTAX_TAG_FOCUS:\n\t  case MNOTE_PENTAX_TAG_FLASH:\n\t  case MNOTE_PENTAX_TAG_WHITE_BALANCE:\n\t  case MNOTE_PENTAX_TAG_SHARPNESS:\n\t  case MNOTE_PENTAX_TAG_CONTRAST:\n\t  case MNOTE_PENTAX_TAG_SATURATION:\n\t  case MNOTE_PENTAX_TAG_ISO_SPEED:\n\t  case MNOTE_PENTAX_TAG_COLOR:\n\t  case MNOTE_PENTAX2_TAG_MODE:\n\t  case MNOTE_PENTAX2_TAG_QUALITY:\n\t  case MNOTE_PENTAX2_TAG_FLASH_MODE:\n\t  case MNOTE_PENTAX2_TAG_FOCUS_MODE:\n\t  case MNOTE_PENTAX2_TAG_AFPOINT_SELECTED:\n\t  case MNOTE_PENTAX2_TAG_AUTO_AFPOINT:\n\t  case MNOTE_PENTAX2_TAG_WHITE_BALANCE:\n\t  case MNOTE_PENTAX2_TAG_PICTURE_MODE:\n\t  case MNOTE_PENTAX2_TAG_IMAGE_SIZE:\n\t  case MNOTE_CASIO2_TAG_BESTSHOT_MODE:\n\t\tCF (entry->format, EXIF_FORMAT_SHORT, val, maxlen);\n\t\tCC2 (entry->components, 1, 2, val, maxlen);\n\t\tif (entry->components == 1) {\n\t\t\tvs = exif_get_short (entry->data, entry->order);\n\n\t\t\t/* search the tag */\n\t\t\tfor (i = 0; (items[i].tag && items[i].tag != entry->tag); i++);\n\t\t\tif (!items[i].tag) {\n\t\t\t\tsnprintf (val, maxlen,\n\t\t\t\t\t  _(\"Internal error (unknown value %i)\"), vs);\n\t\t\t  \tbreak;\n\t\t\t}\n\n\t\t\t/* find the value */\n\t\t\tfor (j = 0; items[i].elem[j].string &&\n\t\t\t    (items[i].elem[j].index < vs); j++);\n\t\t\tif (items[i].elem[j].index != vs) {\n\t\t\t\tsnprintf (val, maxlen,\n\t\t\t\t\t  _(\"Internal error (unknown value %i)\"), vs);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstrncpy (val, _(items[i].elem[j].string), maxlen);\n\t\t} else {\n\t\t\t/* Two-component values */\n\t\t\tCF (entry->format, EXIF_FORMAT_SHORT, val, maxlen);\n\t\t\tCC2 (entry->components, 1, 2, val, maxlen);\n\t\t\tvs = exif_get_short (entry->data, entry->order);\n\t\t\tvs2 = exif_get_short (entry->data+2, entry->order) << 16;\n\n\t\t\t/* search the tag */\n\t\t\tfor (i = 0; (items2[i].tag && items2[i].tag != entry->tag); i++);\n\t\t\tif (!items2[i].tag) {\n\t\t\t\tsnprintf (val, maxlen,\n\t\t\t\t\t  _(\"Internal error (unknown value %i %i)\"), vs, vs2);\n\t\t\t  \tbreak;\n\t\t\t}\n\n\t\t\t/* find the value */\n\t\t\tfor (j = 0; items2[i].elem[j].string && ((items2[i].elem[j].index2 < vs2)\n\t\t\t\t|| ((items2[i].elem[j].index2 == vs2) && (items2[i].elem[j].index1 < vs))); j++);\n\t\t\tif ((items2[i].elem[j].index1 != vs) || (items2[i].elem[j].index2 != vs2)) {\n\t\t\t\tsnprintf (val, maxlen,\n\t\t\t\t\t  _(\"Internal error (unknown value %i %i)\"), vs, vs2);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstrncpy (val, _(items2[i].elem[j].string), maxlen);\n\t\t}\n\t\tbreak;\n\n\tcase MNOTE_PENTAX_TAG_ZOOM:\n\t\tCF (entry->format, EXIF_FORMAT_LONG, val, maxlen);\n\t\tCC (entry->components, 1, val, maxlen);\n\t\tvl = exif_get_long (entry->data, entry->order);\n\t\tsnprintf (val, maxlen, \"%li\", (long int) vl);\n\t\tbreak;\n\tcase MNOTE_PENTAX_TAG_PRINTIM:\n\t\tCF (entry->format, EXIF_FORMAT_UNDEFINED, val, maxlen);\n\t\tCC (entry->components, 124, val, maxlen);\n\t\tsnprintf (val, maxlen, _(\"%i bytes unknown data\"),\n\t\t\tentry->size);\n\t\tbreak;\n\tcase MNOTE_PENTAX_TAG_TZ_CITY:\n\tcase MNOTE_PENTAX_TAG_TZ_DST:\n\t\tCF (entry->format, EXIF_FORMAT_UNDEFINED, val, maxlen);\n\t\tCC (entry->components, 4, val, maxlen);\n\t\tstrncpy (val, (char*)entry->data, MIN(maxlen, entry->size));\n\t\tbreak;\n\tcase MNOTE_PENTAX2_TAG_DATE:\n\t\tCF (entry->format, EXIF_FORMAT_UNDEFINED, val, maxlen);\n\t\tCC (entry->components, 4, val, maxlen);\n\t\t/* Note: format is UNDEFINED, not SHORT -> order is fixed: MOTOROLA */\n\t\tvs = exif_get_short (entry->data, EXIF_BYTE_ORDER_MOTOROLA);\n\t\tsnprintf (val, maxlen, \"%i:%02i:%02i\", vs, entry->data[2], entry->data[3]);\n\t\tbreak;\n\tcase MNOTE_PENTAX2_TAG_TIME:\n\t\tCF (entry->format, EXIF_FORMAT_UNDEFINED, val, maxlen);\n\t\tCC2 (entry->components, 3, 4, val, maxlen);\n\t\tsnprintf (val, maxlen, \"%02i:%02i:%02i\", entry->data[0], entry->data[1], entry->data[2]);\n\t\tbreak;\n\tdefault:\n\t\tswitch (entry->format) {\n\t\tcase EXIF_FORMAT_ASCII:\n\t\t  strncpy (val, (char *)entry->data, MIN(maxlen, entry->size));\n\t\t  break;\n\t\tcase EXIF_FORMAT_SHORT:\n\t\t  {\n\t\t\tconst unsigned char *data = entry->data;\n\t\t  \tsize_t k, len = strlen(val);\n\t\t  \tfor(k=0; k<entry->components; k++) {\n\t\t\t\tvs = exif_get_short (data, entry->order);\n\t\t\t\tsnprintf (val+len, maxlen-len, \"%i \", vs);\n\t\t\t\tlen = strlen(val);\n\t\t\t\tdata += 2;\n\t\t\t}\n\t\t  }\n\t\t  break;\n\t\tcase EXIF_FORMAT_LONG:\n\t\t  {\n\t\t\tconst unsigned char *data = entry->data;\n\t\t  \tsize_t k, len = strlen(val);\n\t\t  \tfor(k=0; k<entry->components; k++) {\n\t\t\t\tvl = exif_get_long (data, entry->order);\n\t\t\t\tsnprintf (val+len, maxlen-len, \"%li\", (long int) vl);\n\t\t\t\tlen = strlen(val);\n\t\t\t\tdata += 4;\n\t\t\t}\n\t\t  }\n\t\t  break;\n\t\tcase EXIF_FORMAT_UNDEFINED:\n\t\tdefault:\n\t\t  snprintf (val, maxlen, _(\"%i bytes unknown data\"),\n\t\t\t  entry->size);\n\t\t  break;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn (val);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146738,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "mnote_pentax_entry_get_value (MnotePentaxEntry *entry,\n\t\t\t      char *val, unsigned int maxlen)\n{\n\tExifLong vl;\n\tExifShort vs, vs2;\n\tint i = 0, j = 0;\n\n\tif (!entry) return (NULL);\n\n\tmemset (val, 0, maxlen);\n\tmaxlen--;\n\n\tswitch (entry->tag) {\n\t  case MNOTE_PENTAX_TAG_MODE:\n\t  case MNOTE_PENTAX_TAG_QUALITY:\n\t  case MNOTE_PENTAX_TAG_FOCUS:\n\t  case MNOTE_PENTAX_TAG_FLASH:\n\t  case MNOTE_PENTAX_TAG_WHITE_BALANCE:\n\t  case MNOTE_PENTAX_TAG_SHARPNESS:\n\t  case MNOTE_PENTAX_TAG_CONTRAST:\n\t  case MNOTE_PENTAX_TAG_SATURATION:\n\t  case MNOTE_PENTAX_TAG_ISO_SPEED:\n\t  case MNOTE_PENTAX_TAG_COLOR:\n\t  case MNOTE_PENTAX2_TAG_MODE:\n\t  case MNOTE_PENTAX2_TAG_QUALITY:\n\t  case MNOTE_PENTAX2_TAG_FLASH_MODE:\n\t  case MNOTE_PENTAX2_TAG_FOCUS_MODE:\n\t  case MNOTE_PENTAX2_TAG_AFPOINT_SELECTED:\n\t  case MNOTE_PENTAX2_TAG_AUTO_AFPOINT:\n\t  case MNOTE_PENTAX2_TAG_WHITE_BALANCE:\n\t  case MNOTE_PENTAX2_TAG_PICTURE_MODE:\n\t  case MNOTE_PENTAX2_TAG_IMAGE_SIZE:\n\t  case MNOTE_CASIO2_TAG_BESTSHOT_MODE:\n\t\tCF (entry->format, EXIF_FORMAT_SHORT, val, maxlen);\n\t\tCC2 (entry->components, 1, 2, val, maxlen);\n\t\tif (entry->components == 1) {\n\t\t\tvs = exif_get_short (entry->data, entry->order);\n\n\t\t\t/* search the tag */\n\t\t\tfor (i = 0; (items[i].tag && items[i].tag != entry->tag); i++);\n\t\t\tif (!items[i].tag) {\n\t\t\t\tsnprintf (val, maxlen,\n\t\t\t\t\t  _(\"Internal error (unknown value %i)\"), vs);\n\t\t\t  \tbreak;\n\t\t\t}\n\n\t\t\t/* find the value */\n\t\t\tfor (j = 0; items[i].elem[j].string &&\n\t\t\t    (items[i].elem[j].index < vs); j++);\n\t\t\tif (items[i].elem[j].index != vs) {\n\t\t\t\tsnprintf (val, maxlen,\n\t\t\t\t\t  _(\"Internal error (unknown value %i)\"), vs);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstrncpy (val, _(items[i].elem[j].string), maxlen);\n\t\t} else {\n\t\t\t/* Two-component values */\n\t\t\tCF (entry->format, EXIF_FORMAT_SHORT, val, maxlen);\n\t\t\tCC2 (entry->components, 1, 2, val, maxlen);\n\t\t\tvs = exif_get_short (entry->data, entry->order);\n\t\t\tvs2 = exif_get_short (entry->data+2, entry->order) << 16;\n\n\t\t\t/* search the tag */\n\t\t\tfor (i = 0; (items2[i].tag && items2[i].tag != entry->tag); i++);\n\t\t\tif (!items2[i].tag) {\n\t\t\t\tsnprintf (val, maxlen,\n\t\t\t\t\t  _(\"Internal error (unknown value %i %i)\"), vs, vs2);\n\t\t\t  \tbreak;\n\t\t\t}\n\n\t\t\t/* find the value */\n\t\t\tfor (j = 0; items2[i].elem[j].string && ((items2[i].elem[j].index2 < vs2)\n\t\t\t\t|| ((items2[i].elem[j].index2 == vs2) && (items2[i].elem[j].index1 < vs))); j++);\n\t\t\tif ((items2[i].elem[j].index1 != vs) || (items2[i].elem[j].index2 != vs2)) {\n\t\t\t\tsnprintf (val, maxlen,\n\t\t\t\t\t  _(\"Internal error (unknown value %i %i)\"), vs, vs2);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstrncpy (val, _(items2[i].elem[j].string), maxlen);\n\t\t}\n\t\tbreak;\n\n\tcase MNOTE_PENTAX_TAG_ZOOM:\n\t\tCF (entry->format, EXIF_FORMAT_LONG, val, maxlen);\n\t\tCC (entry->components, 1, val, maxlen);\n\t\tvl = exif_get_long (entry->data, entry->order);\n\t\tsnprintf (val, maxlen, \"%li\", (long int) vl);\n\t\tbreak;\n\tcase MNOTE_PENTAX_TAG_PRINTIM:\n\t\tCF (entry->format, EXIF_FORMAT_UNDEFINED, val, maxlen);\n\t\tCC (entry->components, 124, val, maxlen);\n\t\tsnprintf (val, maxlen, _(\"%i bytes unknown data\"),\n\t\t\tentry->size);\n\t\tbreak;\n\tcase MNOTE_PENTAX_TAG_TZ_CITY:\n\tcase MNOTE_PENTAX_TAG_TZ_DST:\n\t\tCF (entry->format, EXIF_FORMAT_UNDEFINED, val, maxlen);\n\t\tCC (entry->components, 4, val, maxlen);\n\t\tstrncpy (val, (char*)entry->data, MIN(maxlen, entry->size));\n\t\tbreak;\n\tcase MNOTE_PENTAX2_TAG_DATE:\n\t\tCF (entry->format, EXIF_FORMAT_UNDEFINED, val, maxlen);\n\t\tCC (entry->components, 4, val, maxlen);\n\t\t/* Note: format is UNDEFINED, not SHORT -> order is fixed: MOTOROLA */\n\t\tvs = exif_get_short (entry->data, EXIF_BYTE_ORDER_MOTOROLA);\n\t\tsnprintf (val, maxlen, \"%i:%02i:%02i\", vs, entry->data[2], entry->data[3]);\n\t\tbreak;\n\tcase MNOTE_PENTAX2_TAG_TIME:\n\t\tCF (entry->format, EXIF_FORMAT_UNDEFINED, val, maxlen);\n\t\tCC2 (entry->components, 3, 4, val, maxlen);\n\t\tsnprintf (val, maxlen, \"%02i:%02i:%02i\", entry->data[0], entry->data[1], entry->data[2]);\n\t\tbreak;\n\tdefault:\n\t\tswitch (entry->format) {\n\t\tcase EXIF_FORMAT_ASCII:\n\t\t  strncpy (val, (char *)entry->data, MIN(maxlen, entry->size));\n\t\t  break;\n\t\tcase EXIF_FORMAT_SHORT:\n\t\t  {\n\t\t\tconst unsigned char *data = entry->data;\n\t\t  \tsize_t k, len = strlen(val), sizeleft;\n\n\t\t\tsizeleft = entry->size;\n\t\t  \tfor(k=0; k<entry->components; k++) {\n\t\t\t\tif (sizeleft < 2)\n\t\t\t\t\tbreak;\n\t\t\t\tvs = exif_get_short (data, entry->order);\n\t\t\t\tsnprintf (val+len, maxlen-len, \"%i \", vs);\n\t\t\t\tlen = strlen(val);\n\t\t\t\tdata += 2;\n\t\t\t\tsizeleft -= 2;\n\t\t\t}\n\t\t  }\n\t\t  break;\n\t\tcase EXIF_FORMAT_LONG:\n\t\t  {\n\t\t\tconst unsigned char *data = entry->data;\n\t\t  \tsize_t k, len = strlen(val), sizeleft;\n\n\t\t\tsizeleft = entry->size;\n\t\t  \tfor(k=0; k<entry->components; k++) {\n\t\t\t\tif (sizeleft < 4)\n\t\t\t\t\tbreak;\n\t\t\t\tvl = exif_get_long (data, entry->order);\n\t\t\t\tsnprintf (val+len, maxlen-len, \"%li\", (long int) vl);\n\t\t\t\tlen = strlen(val);\n\t\t\t\tdata += 4;\n\t\t\t\tsizeleft -= 4;\n\t\t\t}\n\t\t  }\n\t\t  break;\n\t\tcase EXIF_FORMAT_UNDEFINED:\n\t\tdefault:\n\t\t  snprintf (val, maxlen, _(\"%i bytes unknown data\"),\n\t\t\t  entry->size);\n\t\t  break;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn val;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146739,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "MagickExport MagickBooleanType InterpolatePixelChannels(\n  const Image *magick_restrict source,const CacheView_ *source_view,\n  const Image *magick_restrict destination,const PixelInterpolateMethod method,\n  const double x,const double y,Quantum *pixel,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  double\n    alpha[16],\n    gamma,\n    pixels[16];\n\n  register const Quantum\n    *magick_restrict p;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    x_offset,\n    y_offset;\n\n  PixelInterpolateMethod\n    interpolate;\n\n  assert(source != (Image *) NULL);\n  assert(source->signature == MagickCoreSignature);\n  assert(source_view != (CacheView *) NULL);\n  status=MagickTrue;\n  x_offset=(ssize_t) floor(x);\n  y_offset=(ssize_t) floor(y);\n  interpolate=method;\n  if (interpolate == UndefinedInterpolatePixel)\n    interpolate=source->interpolate;\n  switch (interpolate)\n  {\n    case AverageInterpolatePixel:  /* nearest 4 neighbours */\n    case Average9InterpolatePixel:  /* nearest 9 neighbours */\n    case Average16InterpolatePixel:  /* nearest 16 neighbours */\n    {\n      ssize_t\n        count;\n\n      count=2;  /* size of the area to average - default nearest 4 */\n      if (interpolate == Average9InterpolatePixel)\n        {\n          count=3;\n          x_offset=(ssize_t) (floor(x+0.5)-1);\n          y_offset=(ssize_t) (floor(y+0.5)-1);\n        }\n      else\n        if (interpolate == Average16InterpolatePixel)\n          {\n            count=4;\n            x_offset--;\n            y_offset--;\n          }\n      p=GetCacheViewVirtualPixels(source_view,x_offset,y_offset,(size_t) count,\n        (size_t) count,exception);\n      if (p == (const Quantum *) NULL)\n        {\n          status=MagickFalse;\n          break;\n        }\n      count*=count;  /* Number of pixels to average */\n      for (i=0; i < (ssize_t) GetPixelChannels(source); i++)\n      {\n        double\n          sum;\n\n        register ssize_t\n          j;\n\n        PixelChannel channel = GetPixelChannelChannel(source,i);\n        PixelTrait traits = GetPixelChannelTraits(source,channel);\n        PixelTrait destination_traits=GetPixelChannelTraits(destination,\n          channel);\n        if ((traits == UndefinedPixelTrait) ||\n            (destination_traits == UndefinedPixelTrait))\n          continue;\n        for (j=0; j < (ssize_t) count; j++)\n          pixels[j]=(double) p[j*GetPixelChannels(source)+i];\n        sum=0.0;\n        if ((traits & BlendPixelTrait) == 0)\n          {\n            for (j=0; j < (ssize_t) count; j++)\n              sum+=pixels[j];\n            sum/=count;\n            SetPixelChannel(destination,channel,ClampToQuantum(sum),pixel);\n            continue;\n          }\n        for (j=0; j < (ssize_t) count; j++)\n        {\n          alpha[j]=QuantumScale*GetPixelAlpha(source,p+j*\n            GetPixelChannels(source));\n          pixels[j]*=alpha[j];\n          gamma=PerceptibleReciprocal(alpha[j]);\n          sum+=gamma*pixels[j];\n        }\n        sum/=count;\n        SetPixelChannel(destination,channel,ClampToQuantum(sum),pixel);\n      }\n      break;\n    }\n    case BilinearInterpolatePixel:\n    default:\n    {\n      p=GetCacheViewVirtualPixels(source_view,x_offset,y_offset,2,2,exception);\n      if (p == (const Quantum *) NULL)\n        {\n          status=MagickFalse;\n          break;\n        }\n      for (i=0; i < (ssize_t) GetPixelChannels(source); i++)\n      {\n        PointInfo\n          delta,\n          epsilon;\n\n        PixelChannel channel = GetPixelChannelChannel(source,i);\n        PixelTrait traits = GetPixelChannelTraits(source,channel);\n        PixelTrait destination_traits=GetPixelChannelTraits(destination,\n          channel);\n        if ((traits == UndefinedPixelTrait) ||\n            (destination_traits == UndefinedPixelTrait))\n          continue;\n        delta.x=x-x_offset;\n        delta.y=y-y_offset;\n        epsilon.x=1.0-delta.x;\n        epsilon.y=1.0-delta.y;\n        pixels[0]=(double) p[i];\n        pixels[1]=(double) p[GetPixelChannels(source)+i];\n        pixels[2]=(double) p[2*GetPixelChannels(source)+i];\n        pixels[3]=(double) p[3*GetPixelChannels(source)+i];\n        if ((traits & BlendPixelTrait) == 0)\n          {\n            gamma=((epsilon.y*(epsilon.x+delta.x)+delta.y*(epsilon.x+delta.x)));\n            gamma=PerceptibleReciprocal(gamma);\n            SetPixelChannel(destination,channel,ClampToQuantum(gamma*(epsilon.y*\n              (epsilon.x*pixels[0]+delta.x*pixels[1])+delta.y*(epsilon.x*\n              pixels[2]+delta.x*pixels[3]))),pixel);\n            continue;\n          }\n        alpha[0]=QuantumScale*GetPixelAlpha(source,p);\n        alpha[1]=QuantumScale*GetPixelAlpha(source,p+GetPixelChannels(source));\n        alpha[2]=QuantumScale*GetPixelAlpha(source,p+2*\n          GetPixelChannels(source));\n        alpha[3]=QuantumScale*GetPixelAlpha(source,p+3*\n          GetPixelChannels(source));\n        pixels[0]*=alpha[0];\n        pixels[1]*=alpha[1];\n        pixels[2]*=alpha[2];\n        pixels[3]*=alpha[3];\n        gamma=((epsilon.y*(epsilon.x*alpha[0]+delta.x*alpha[1])+delta.y*\n          (epsilon.x*alpha[2]+delta.x*alpha[3])));\n        gamma=PerceptibleReciprocal(gamma);\n        SetPixelChannel(destination,channel,ClampToQuantum(gamma*(epsilon.y*\n          (epsilon.x*pixels[0]+delta.x*pixels[1])+delta.y*(epsilon.x*pixels[2]+\n          delta.x*pixels[3]))),pixel);\n      }\n      break;\n    }\n    case BlendInterpolatePixel:\n    {\n      p=GetCacheViewVirtualPixels(source_view,x_offset,y_offset,2,2,exception);\n      if (p == (const Quantum *) NULL)\n        {\n          status=MagickFalse;\n          break;\n        }\n      for (i=0; i < (ssize_t) GetPixelChannels(source); i++)\n      {\n        register ssize_t\n          j;\n\n        PixelChannel channel = GetPixelChannelChannel(source,i);\n        PixelTrait traits = GetPixelChannelTraits(source,channel);\n        PixelTrait destination_traits=GetPixelChannelTraits(destination,\n          channel);\n        if ((traits == UndefinedPixelTrait) ||\n            (destination_traits == UndefinedPixelTrait))\n          continue;\n        if (source->alpha_trait != BlendPixelTrait)\n          for (j=0; j < 4; j++)\n          {\n            alpha[j]=1.0;\n            pixels[j]=(double) p[j*GetPixelChannels(source)+i];\n          }\n        else\n          for (j=0; j < 4; j++)\n          {\n            alpha[j]=QuantumScale*GetPixelAlpha(source,p+j*\n              GetPixelChannels(source));\n            pixels[j]=(double) p[j*GetPixelChannels(source)+i];\n            if (channel != AlphaPixelChannel)\n              pixels[j]*=alpha[j];\n          }\n        gamma=1.0;  /* number of pixels blended together (its variable) */\n        for (j=0; j <= 1L; j++)\n        {\n          if ((y-y_offset) >= 0.75)\n            {\n              alpha[j]=alpha[j+2];  /* take right pixels */\n              pixels[j]=pixels[j+2];\n            }\n          else\n            if ((y-y_offset) > 0.25)\n              {\n                gamma=2.0;  /* blend both pixels in row */\n                alpha[j]+=alpha[j+2];  /* add up alpha weights */\n                pixels[j]+=pixels[j+2];\n              }\n        }\n        if ((x-x_offset) >= 0.75)\n          {\n            alpha[0]=alpha[1];  /* take bottom row blend */\n            pixels[0]=pixels[1];\n          }\n        else\n           if ((x-x_offset) > 0.25)\n             {\n               gamma*=2.0;  /* blend both rows */\n               alpha[0]+=alpha[1];  /* add up alpha weights */\n               pixels[0]+=pixels[1];\n             }\n        if (channel != AlphaPixelChannel)\n          gamma=PerceptibleReciprocal(alpha[0]);  /* (color) 1/alpha_weights */\n        else\n          gamma=PerceptibleReciprocal(gamma);  /* (alpha) 1/number_of_pixels */\n        SetPixelChannel(destination,channel,ClampToQuantum(gamma*pixels[0]),\n          pixel);\n      }\n      break;\n    }\n    case CatromInterpolatePixel:\n    {\n      double\n        cx[4],\n        cy[4];\n\n      p=GetCacheViewVirtualPixels(source_view,x_offset-1,y_offset-1,4,4,\n        exception);\n      if (p == (const Quantum *) NULL)\n        {\n          status=MagickFalse;\n          break;\n        }\n      for (i=0; i < (ssize_t) GetPixelChannels(source); i++)\n      {\n        register ssize_t\n          j;\n\n        PixelChannel channel = GetPixelChannelChannel(source,i);\n        PixelTrait traits = GetPixelChannelTraits(source,channel);\n        PixelTrait destination_traits=GetPixelChannelTraits(destination,\n          channel);\n        if ((traits == UndefinedPixelTrait) ||\n            (destination_traits == UndefinedPixelTrait))\n          continue;\n        if ((traits & BlendPixelTrait) == 0)\n          for (j=0; j < 16; j++)\n          {\n            alpha[j]=1.0;\n            pixels[j]=(double) p[j*GetPixelChannels(source)+i];\n          }\n        else\n          for (j=0; j < 16; j++)\n          {\n            alpha[j]=QuantumScale*GetPixelAlpha(source,p+j*\n              GetPixelChannels(source));\n            pixels[j]=alpha[j]*p[j*GetPixelChannels(source)+i];\n          }\n        CatromWeights((double) (x-x_offset),&cx);\n        CatromWeights((double) (y-y_offset),&cy);\n        gamma=((traits & BlendPixelTrait) ? (double) (1.0) :\n          PerceptibleReciprocal(cy[0]*(cx[0]*alpha[0]+cx[1]*alpha[1]+cx[2]*\n          alpha[2]+cx[3]*alpha[3])+cy[1]*(cx[0]*alpha[4]+cx[1]*alpha[5]+cx[2]*\n          alpha[6]+cx[3]*alpha[7])+cy[2]*(cx[0]*alpha[8]+cx[1]*alpha[9]+cx[2]*\n          alpha[10]+cx[3]*alpha[11])+cy[3]*(cx[0]*alpha[12]+cx[1]*alpha[13]+\n          cx[2]*alpha[14]+cx[3]*alpha[15])));\n        SetPixelChannel(destination,channel,ClampToQuantum(gamma*(cy[0]*(cx[0]*\n          pixels[0]+cx[1]*pixels[1]+cx[2]*pixels[2]+cx[3]*pixels[3])+cy[1]*\n          (cx[0]*pixels[4]+cx[1]*pixels[5]+cx[2]*pixels[6]+cx[3]*pixels[7])+\n          cy[2]*(cx[0]*pixels[8]+cx[1]*pixels[9]+cx[2]*pixels[10]+cx[3]*\n          pixels[11])+cy[3]*(cx[0]*pixels[12]+cx[1]*pixels[13]+cx[2]*\n          pixels[14]+cx[3]*pixels[15]))),pixel);\n      }\n      break;\n    }\n    case IntegerInterpolatePixel:\n    {\n      p=GetCacheViewVirtualPixels(source_view,x_offset,y_offset,1,1,exception);\n      if (p == (const Quantum *) NULL)\n        {\n          status=MagickFalse;\n          break;\n        }\n      for (i=0; i < (ssize_t) GetPixelChannels(source); i++)\n      {\n        PixelChannel channel = GetPixelChannelChannel(source,i);\n        PixelTrait traits = GetPixelChannelTraits(source,channel);\n        PixelTrait destination_traits=GetPixelChannelTraits(destination,\n          channel);\n        if ((traits == UndefinedPixelTrait) ||\n            (destination_traits == UndefinedPixelTrait))\n          continue;\n        SetPixelChannel(destination,channel,p[i],pixel);\n      }\n      break;\n    }\n    case NearestInterpolatePixel:\n    {\n      x_offset=(ssize_t) floor(x+0.5);\n      y_offset=(ssize_t) floor(y+0.5);\n      p=GetCacheViewVirtualPixels(source_view,x_offset,y_offset,1,1,exception);\n      if (p == (const Quantum *) NULL)\n        {\n          status=MagickFalse;\n          break;\n        }\n      for (i=0; i < (ssize_t) GetPixelChannels(source); i++)\n      {\n        PixelChannel channel = GetPixelChannelChannel(source,i);\n        PixelTrait traits = GetPixelChannelTraits(source,channel);\n        PixelTrait destination_traits=GetPixelChannelTraits(destination,\n          channel);\n        if ((traits == UndefinedPixelTrait) ||\n            (destination_traits == UndefinedPixelTrait))\n          continue;\n        SetPixelChannel(destination,channel,p[i],pixel);\n      }\n      break;\n    }\n    case MeshInterpolatePixel:\n    {\n      p=GetCacheViewVirtualPixels(source_view,x_offset,y_offset,2,2,exception);\n      if (p == (const Quantum *) NULL)\n        {\n          status=MagickFalse;\n          break;\n        }\n      for (i=0; i < (ssize_t) GetPixelChannels(source); i++)\n      {\n        PointInfo\n          delta,\n          luminance;\n\n        PixelChannel channel = GetPixelChannelChannel(source,i);\n        PixelTrait traits = GetPixelChannelTraits(source,channel);\n        PixelTrait destination_traits=GetPixelChannelTraits(destination,\n          channel);\n        if ((traits == UndefinedPixelTrait) ||\n            (destination_traits == UndefinedPixelTrait))\n          continue;\n        pixels[0]=(double) p[i];\n        pixels[1]=(double) p[GetPixelChannels(source)+i];\n        pixels[2]=(double) p[2*GetPixelChannels(source)+i];\n        pixels[3]=(double) p[3*GetPixelChannels(source)+i];\n        if ((traits & BlendPixelTrait) == 0)\n          {\n            alpha[0]=1.0;\n            alpha[1]=1.0;\n            alpha[2]=1.0;\n            alpha[3]=1.0;\n          }\n        else\n          {\n            alpha[0]=QuantumScale*GetPixelAlpha(source,p);\n            alpha[1]=QuantumScale*GetPixelAlpha(source,p+\n              GetPixelChannels(source));\n            alpha[2]=QuantumScale*GetPixelAlpha(source,p+2*\n              GetPixelChannels(source));\n            alpha[3]=QuantumScale*GetPixelAlpha(source,p+3*\n              GetPixelChannels(source));\n          }\n        delta.x=x-x_offset;\n        delta.y=y-y_offset;\n        luminance.x=fabs((double) (GetPixelLuma(source,p)-\n          GetPixelLuma(source,p+3*GetPixelChannels(source))));\n        luminance.y=fabs((double) (GetPixelLuma(source,p+\n          GetPixelChannels(source))-GetPixelLuma(source,p+2*\n          GetPixelChannels(source))));\n        if (luminance.x < luminance.y)\n          {\n            /*\n              Diagonal 0-3 NW-SE.\n            */\n            if (delta.x <= delta.y)\n              {\n                /*\n                  Bottom-left triangle (pixel: 2, diagonal: 0-3).\n                */\n                delta.y=1.0-delta.y;\n                gamma=MeshInterpolate(&delta,alpha[2],alpha[3],alpha[0]);\n                gamma=PerceptibleReciprocal(gamma);\n                SetPixelChannel(destination,channel,ClampToQuantum(gamma*\n                  MeshInterpolate(&delta,pixels[2],pixels[3],pixels[0])),pixel);\n              }\n            else\n              {\n                /*\n                  Top-right triangle (pixel: 1, diagonal: 0-3).\n                */\n                delta.x=1.0-delta.x;\n                gamma=MeshInterpolate(&delta,alpha[1],alpha[0],alpha[3]);\n                gamma=PerceptibleReciprocal(gamma);\n                SetPixelChannel(destination,channel,ClampToQuantum(gamma*\n                  MeshInterpolate(&delta,pixels[1],pixels[0],pixels[3])),pixel);\n              }\n          }\n        else\n          {\n            /*\n              Diagonal 1-2 NE-SW.\n            */\n            if (delta.x <= (1.0-delta.y))\n              {\n                /*\n                  Top-left triangle (pixel: 0, diagonal: 1-2).\n                */\n                gamma=MeshInterpolate(&delta,alpha[0],alpha[1],alpha[2]);\n                gamma=PerceptibleReciprocal(gamma);\n                SetPixelChannel(destination,channel,ClampToQuantum(gamma*\n                  MeshInterpolate(&delta,pixels[0],pixels[1],pixels[2])),pixel);\n              }\n            else\n              {\n                /*\n                  Bottom-right triangle (pixel: 3, diagonal: 1-2).\n                */\n                delta.x=1.0-delta.x;\n                delta.y=1.0-delta.y;\n                gamma=MeshInterpolate(&delta,alpha[3],alpha[2],alpha[1]);\n                gamma=PerceptibleReciprocal(gamma);\n                SetPixelChannel(destination,channel,ClampToQuantum(gamma*\n                  MeshInterpolate(&delta,pixels[3],pixels[2],pixels[1])),pixel);\n              }\n          }\n      }\n      break;\n    }\n    case SplineInterpolatePixel:\n    {\n      double\n        cx[4],\n        cy[4];\n\n      p=GetCacheViewVirtualPixels(source_view,x_offset-1,y_offset-1,4,4,\n        exception);\n      if (p == (const Quantum *) NULL)\n        {\n          status=MagickFalse;\n          break;\n        }\n      for (i=0; i < (ssize_t) GetPixelChannels(source); i++)\n      {\n        register ssize_t\n          j;\n\n        PixelChannel channel = GetPixelChannelChannel(source,i);\n        PixelTrait traits = GetPixelChannelTraits(source,channel);\n        PixelTrait destination_traits=GetPixelChannelTraits(destination,\n          channel);\n        if ((traits == UndefinedPixelTrait) ||\n            (destination_traits == UndefinedPixelTrait))\n          continue;\n        if ((traits & BlendPixelTrait) == 0)\n          for (j=0; j < 16; j++)\n          {\n            alpha[j]=1.0;\n            pixels[j]=(double) p[j*GetPixelChannels(source)+i];\n          }\n        else\n          for (j=0; j < 16; j++)\n          {\n            alpha[j]=QuantumScale*GetPixelAlpha(source,p+j*\n              GetPixelChannels(source));\n            pixels[j]=alpha[j]*p[j*GetPixelChannels(source)+i];\n          }\n        SplineWeights((double) (x-x_offset),&cx);\n        SplineWeights((double) (y-y_offset),&cy);\n        gamma=((traits & BlendPixelTrait) ? (double) (1.0) :\n          PerceptibleReciprocal(cy[0]*(cx[0]*alpha[0]+cx[1]*alpha[1]+cx[2]*\n          alpha[2]+cx[3]*alpha[3])+cy[1]*(cx[0]*alpha[4]+cx[1]*alpha[5]+cx[2]*\n          alpha[6]+cx[3]*alpha[7])+cy[2]*(cx[0]*alpha[8]+cx[1]*alpha[9]+cx[2]*\n          alpha[10]+cx[3]*alpha[11])+cy[3]*(cx[0]*alpha[12]+cx[1]*alpha[13]+\n          cx[2]*alpha[14]+cx[3]*alpha[15])));\n        SetPixelChannel(destination,channel,ClampToQuantum(gamma*(cy[0]*(cx[0]*\n          pixels[0]+cx[1]*pixels[1]+cx[2]*pixels[2]+cx[3]*pixels[3])+cy[1]*\n          (cx[0]*pixels[4]+cx[1]*pixels[5]+cx[2]*pixels[6]+cx[3]*pixels[7])+\n          cy[2]*(cx[0]*pixels[8]+cx[1]*pixels[9]+cx[2]*pixels[10]+cx[3]*\n          pixels[11])+cy[3]*(cx[0]*pixels[12]+cx[1]*pixels[13]+cx[2]*\n          pixels[14]+cx[3]*pixels[15]))),pixel);\n      }\n      break;\n    }\n  }\n  return(status);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146754,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "MagickExport MagickBooleanType InterpolatePixelChannels(\n  const Image *magick_restrict source,const CacheView_ *source_view,\n  const Image *magick_restrict destination,const PixelInterpolateMethod method,\n  const double x,const double y,Quantum *pixel,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  double\n    alpha[16],\n    gamma,\n    pixels[16];\n\n  register const Quantum\n    *magick_restrict p;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    x_offset,\n    y_offset;\n\n  PixelInterpolateMethod\n    interpolate;\n\n  assert(source != (Image *) NULL);\n  assert(source->signature == MagickCoreSignature);\n  assert(source_view != (CacheView *) NULL);\n  status=MagickTrue;\n  x_offset=(ssize_t) floor(ConstrainPixelOffset(x));\n  y_offset=(ssize_t) floor(ConstrainPixelOffset(y));\n  interpolate=method;\n  if (interpolate == UndefinedInterpolatePixel)\n    interpolate=source->interpolate;\n  switch (interpolate)\n  {\n    case AverageInterpolatePixel:  /* nearest 4 neighbours */\n    case Average9InterpolatePixel:  /* nearest 9 neighbours */\n    case Average16InterpolatePixel:  /* nearest 16 neighbours */\n    {\n      ssize_t\n        count;\n\n      count=2;  /* size of the area to average - default nearest 4 */\n      if (interpolate == Average9InterpolatePixel)\n        {\n          count=3;\n          x_offset=(ssize_t) (floor(ConstrainPixelOffset(x)+0.5)-1);\n          y_offset=(ssize_t) (floor(ConstrainPixelOffset(y)+0.5)-1);\n        }\n      else\n        if (interpolate == Average16InterpolatePixel)\n          {\n            count=4;\n            x_offset--;\n            y_offset--;\n          }\n      p=GetCacheViewVirtualPixels(source_view,x_offset,y_offset,(size_t) count,\n        (size_t) count,exception);\n      if (p == (const Quantum *) NULL)\n        {\n          status=MagickFalse;\n          break;\n        }\n      count*=count;  /* Number of pixels to average */\n      for (i=0; i < (ssize_t) GetPixelChannels(source); i++)\n      {\n        double\n          sum;\n\n        register ssize_t\n          j;\n\n        PixelChannel channel = GetPixelChannelChannel(source,i);\n        PixelTrait traits = GetPixelChannelTraits(source,channel);\n        PixelTrait destination_traits=GetPixelChannelTraits(destination,\n          channel);\n        if ((traits == UndefinedPixelTrait) ||\n            (destination_traits == UndefinedPixelTrait))\n          continue;\n        for (j=0; j < (ssize_t) count; j++)\n          pixels[j]=(double) p[j*GetPixelChannels(source)+i];\n        sum=0.0;\n        if ((traits & BlendPixelTrait) == 0)\n          {\n            for (j=0; j < (ssize_t) count; j++)\n              sum+=pixels[j];\n            sum/=count;\n            SetPixelChannel(destination,channel,ClampToQuantum(sum),pixel);\n            continue;\n          }\n        for (j=0; j < (ssize_t) count; j++)\n        {\n          alpha[j]=QuantumScale*GetPixelAlpha(source,p+j*\n            GetPixelChannels(source));\n          pixels[j]*=alpha[j];\n          gamma=PerceptibleReciprocal(alpha[j]);\n          sum+=gamma*pixels[j];\n        }\n        sum/=count;\n        SetPixelChannel(destination,channel,ClampToQuantum(sum),pixel);\n      }\n      break;\n    }\n    case BilinearInterpolatePixel:\n    default:\n    {\n      p=GetCacheViewVirtualPixels(source_view,x_offset,y_offset,2,2,exception);\n      if (p == (const Quantum *) NULL)\n        {\n          status=MagickFalse;\n          break;\n        }\n      for (i=0; i < (ssize_t) GetPixelChannels(source); i++)\n      {\n        PointInfo\n          delta,\n          epsilon;\n\n        PixelChannel channel = GetPixelChannelChannel(source,i);\n        PixelTrait traits = GetPixelChannelTraits(source,channel);\n        PixelTrait destination_traits=GetPixelChannelTraits(destination,\n          channel);\n        if ((traits == UndefinedPixelTrait) ||\n            (destination_traits == UndefinedPixelTrait))\n          continue;\n        delta.x=x-x_offset;\n        delta.y=y-y_offset;\n        epsilon.x=1.0-delta.x;\n        epsilon.y=1.0-delta.y;\n        pixels[0]=(double) p[i];\n        pixels[1]=(double) p[GetPixelChannels(source)+i];\n        pixels[2]=(double) p[2*GetPixelChannels(source)+i];\n        pixels[3]=(double) p[3*GetPixelChannels(source)+i];\n        if ((traits & BlendPixelTrait) == 0)\n          {\n            gamma=((epsilon.y*(epsilon.x+delta.x)+delta.y*(epsilon.x+delta.x)));\n            gamma=PerceptibleReciprocal(gamma);\n            SetPixelChannel(destination,channel,ClampToQuantum(gamma*(epsilon.y*\n              (epsilon.x*pixels[0]+delta.x*pixels[1])+delta.y*(epsilon.x*\n              pixels[2]+delta.x*pixels[3]))),pixel);\n            continue;\n          }\n        alpha[0]=QuantumScale*GetPixelAlpha(source,p);\n        alpha[1]=QuantumScale*GetPixelAlpha(source,p+GetPixelChannels(source));\n        alpha[2]=QuantumScale*GetPixelAlpha(source,p+2*\n          GetPixelChannels(source));\n        alpha[3]=QuantumScale*GetPixelAlpha(source,p+3*\n          GetPixelChannels(source));\n        pixels[0]*=alpha[0];\n        pixels[1]*=alpha[1];\n        pixels[2]*=alpha[2];\n        pixels[3]*=alpha[3];\n        gamma=((epsilon.y*(epsilon.x*alpha[0]+delta.x*alpha[1])+delta.y*\n          (epsilon.x*alpha[2]+delta.x*alpha[3])));\n        gamma=PerceptibleReciprocal(gamma);\n        SetPixelChannel(destination,channel,ClampToQuantum(gamma*(epsilon.y*\n          (epsilon.x*pixels[0]+delta.x*pixels[1])+delta.y*(epsilon.x*pixels[2]+\n          delta.x*pixels[3]))),pixel);\n      }\n      break;\n    }\n    case BlendInterpolatePixel:\n    {\n      p=GetCacheViewVirtualPixels(source_view,x_offset,y_offset,2,2,exception);\n      if (p == (const Quantum *) NULL)\n        {\n          status=MagickFalse;\n          break;\n        }\n      for (i=0; i < (ssize_t) GetPixelChannels(source); i++)\n      {\n        register ssize_t\n          j;\n\n        PixelChannel channel = GetPixelChannelChannel(source,i);\n        PixelTrait traits = GetPixelChannelTraits(source,channel);\n        PixelTrait destination_traits=GetPixelChannelTraits(destination,\n          channel);\n        if ((traits == UndefinedPixelTrait) ||\n            (destination_traits == UndefinedPixelTrait))\n          continue;\n        if (source->alpha_trait != BlendPixelTrait)\n          for (j=0; j < 4; j++)\n          {\n            alpha[j]=1.0;\n            pixels[j]=(double) p[j*GetPixelChannels(source)+i];\n          }\n        else\n          for (j=0; j < 4; j++)\n          {\n            alpha[j]=QuantumScale*GetPixelAlpha(source,p+j*\n              GetPixelChannels(source));\n            pixels[j]=(double) p[j*GetPixelChannels(source)+i];\n            if (channel != AlphaPixelChannel)\n              pixels[j]*=alpha[j];\n          }\n        gamma=1.0;  /* number of pixels blended together (its variable) */\n        for (j=0; j <= 1L; j++)\n        {\n          if ((y-y_offset) >= 0.75)\n            {\n              alpha[j]=alpha[j+2];  /* take right pixels */\n              pixels[j]=pixels[j+2];\n            }\n          else\n            if ((y-y_offset) > 0.25)\n              {\n                gamma=2.0;  /* blend both pixels in row */\n                alpha[j]+=alpha[j+2];  /* add up alpha weights */\n                pixels[j]+=pixels[j+2];\n              }\n        }\n        if ((x-x_offset) >= 0.75)\n          {\n            alpha[0]=alpha[1];  /* take bottom row blend */\n            pixels[0]=pixels[1];\n          }\n        else\n           if ((x-x_offset) > 0.25)\n             {\n               gamma*=2.0;  /* blend both rows */\n               alpha[0]+=alpha[1];  /* add up alpha weights */\n               pixels[0]+=pixels[1];\n             }\n        if (channel != AlphaPixelChannel)\n          gamma=PerceptibleReciprocal(alpha[0]);  /* (color) 1/alpha_weights */\n        else\n          gamma=PerceptibleReciprocal(gamma);  /* (alpha) 1/number_of_pixels */\n        SetPixelChannel(destination,channel,ClampToQuantum(gamma*pixels[0]),\n          pixel);\n      }\n      break;\n    }\n    case CatromInterpolatePixel:\n    {\n      double\n        cx[4],\n        cy[4];\n\n      p=GetCacheViewVirtualPixels(source_view,x_offset-1,y_offset-1,4,4,\n        exception);\n      if (p == (const Quantum *) NULL)\n        {\n          status=MagickFalse;\n          break;\n        }\n      for (i=0; i < (ssize_t) GetPixelChannels(source); i++)\n      {\n        register ssize_t\n          j;\n\n        PixelChannel channel = GetPixelChannelChannel(source,i);\n        PixelTrait traits = GetPixelChannelTraits(source,channel);\n        PixelTrait destination_traits=GetPixelChannelTraits(destination,\n          channel);\n        if ((traits == UndefinedPixelTrait) ||\n            (destination_traits == UndefinedPixelTrait))\n          continue;\n        if ((traits & BlendPixelTrait) == 0)\n          for (j=0; j < 16; j++)\n          {\n            alpha[j]=1.0;\n            pixels[j]=(double) p[j*GetPixelChannels(source)+i];\n          }\n        else\n          for (j=0; j < 16; j++)\n          {\n            alpha[j]=QuantumScale*GetPixelAlpha(source,p+j*\n              GetPixelChannels(source));\n            pixels[j]=alpha[j]*p[j*GetPixelChannels(source)+i];\n          }\n        CatromWeights((double) (x-x_offset),&cx);\n        CatromWeights((double) (y-y_offset),&cy);\n        gamma=((traits & BlendPixelTrait) ? (double) (1.0) :\n          PerceptibleReciprocal(cy[0]*(cx[0]*alpha[0]+cx[1]*alpha[1]+cx[2]*\n          alpha[2]+cx[3]*alpha[3])+cy[1]*(cx[0]*alpha[4]+cx[1]*alpha[5]+cx[2]*\n          alpha[6]+cx[3]*alpha[7])+cy[2]*(cx[0]*alpha[8]+cx[1]*alpha[9]+cx[2]*\n          alpha[10]+cx[3]*alpha[11])+cy[3]*(cx[0]*alpha[12]+cx[1]*alpha[13]+\n          cx[2]*alpha[14]+cx[3]*alpha[15])));\n        SetPixelChannel(destination,channel,ClampToQuantum(gamma*(cy[0]*(cx[0]*\n          pixels[0]+cx[1]*pixels[1]+cx[2]*pixels[2]+cx[3]*pixels[3])+cy[1]*\n          (cx[0]*pixels[4]+cx[1]*pixels[5]+cx[2]*pixels[6]+cx[3]*pixels[7])+\n          cy[2]*(cx[0]*pixels[8]+cx[1]*pixels[9]+cx[2]*pixels[10]+cx[3]*\n          pixels[11])+cy[3]*(cx[0]*pixels[12]+cx[1]*pixels[13]+cx[2]*\n          pixels[14]+cx[3]*pixels[15]))),pixel);\n      }\n      break;\n    }\n    case IntegerInterpolatePixel:\n    {\n      p=GetCacheViewVirtualPixels(source_view,x_offset,y_offset,1,1,exception);\n      if (p == (const Quantum *) NULL)\n        {\n          status=MagickFalse;\n          break;\n        }\n      for (i=0; i < (ssize_t) GetPixelChannels(source); i++)\n      {\n        PixelChannel channel = GetPixelChannelChannel(source,i);\n        PixelTrait traits = GetPixelChannelTraits(source,channel);\n        PixelTrait destination_traits=GetPixelChannelTraits(destination,\n          channel);\n        if ((traits == UndefinedPixelTrait) ||\n            (destination_traits == UndefinedPixelTrait))\n          continue;\n        SetPixelChannel(destination,channel,p[i],pixel);\n      }\n      break;\n    }\n    case NearestInterpolatePixel:\n    {\n      x_offset=(ssize_t) floor(ConstrainPixelOffset(x)+0.5);\n      y_offset=(ssize_t) floor(ConstrainPixelOffset(y)+0.5);\n      p=GetCacheViewVirtualPixels(source_view,x_offset,y_offset,1,1,exception);\n      if (p == (const Quantum *) NULL)\n        {\n          status=MagickFalse;\n          break;\n        }\n      for (i=0; i < (ssize_t) GetPixelChannels(source); i++)\n      {\n        PixelChannel channel = GetPixelChannelChannel(source,i);\n        PixelTrait traits = GetPixelChannelTraits(source,channel);\n        PixelTrait destination_traits=GetPixelChannelTraits(destination,\n          channel);\n        if ((traits == UndefinedPixelTrait) ||\n            (destination_traits == UndefinedPixelTrait))\n          continue;\n        SetPixelChannel(destination,channel,p[i],pixel);\n      }\n      break;\n    }\n    case MeshInterpolatePixel:\n    {\n      p=GetCacheViewVirtualPixels(source_view,x_offset,y_offset,2,2,exception);\n      if (p == (const Quantum *) NULL)\n        {\n          status=MagickFalse;\n          break;\n        }\n      for (i=0; i < (ssize_t) GetPixelChannels(source); i++)\n      {\n        PointInfo\n          delta,\n          luminance;\n\n        PixelChannel channel = GetPixelChannelChannel(source,i);\n        PixelTrait traits = GetPixelChannelTraits(source,channel);\n        PixelTrait destination_traits=GetPixelChannelTraits(destination,\n          channel);\n        if ((traits == UndefinedPixelTrait) ||\n            (destination_traits == UndefinedPixelTrait))\n          continue;\n        pixels[0]=(double) p[i];\n        pixels[1]=(double) p[GetPixelChannels(source)+i];\n        pixels[2]=(double) p[2*GetPixelChannels(source)+i];\n        pixels[3]=(double) p[3*GetPixelChannels(source)+i];\n        if ((traits & BlendPixelTrait) == 0)\n          {\n            alpha[0]=1.0;\n            alpha[1]=1.0;\n            alpha[2]=1.0;\n            alpha[3]=1.0;\n          }\n        else\n          {\n            alpha[0]=QuantumScale*GetPixelAlpha(source,p);\n            alpha[1]=QuantumScale*GetPixelAlpha(source,p+\n              GetPixelChannels(source));\n            alpha[2]=QuantumScale*GetPixelAlpha(source,p+2*\n              GetPixelChannels(source));\n            alpha[3]=QuantumScale*GetPixelAlpha(source,p+3*\n              GetPixelChannels(source));\n          }\n        delta.x=x-x_offset;\n        delta.y=y-y_offset;\n        luminance.x=fabs((double) (GetPixelLuma(source,p)-\n          GetPixelLuma(source,p+3*GetPixelChannels(source))));\n        luminance.y=fabs((double) (GetPixelLuma(source,p+\n          GetPixelChannels(source))-GetPixelLuma(source,p+2*\n          GetPixelChannels(source))));\n        if (luminance.x < luminance.y)\n          {\n            /*\n              Diagonal 0-3 NW-SE.\n            */\n            if (delta.x <= delta.y)\n              {\n                /*\n                  Bottom-left triangle (pixel: 2, diagonal: 0-3).\n                */\n                delta.y=1.0-delta.y;\n                gamma=MeshInterpolate(&delta,alpha[2],alpha[3],alpha[0]);\n                gamma=PerceptibleReciprocal(gamma);\n                SetPixelChannel(destination,channel,ClampToQuantum(gamma*\n                  MeshInterpolate(&delta,pixels[2],pixels[3],pixels[0])),pixel);\n              }\n            else\n              {\n                /*\n                  Top-right triangle (pixel: 1, diagonal: 0-3).\n                */\n                delta.x=1.0-delta.x;\n                gamma=MeshInterpolate(&delta,alpha[1],alpha[0],alpha[3]);\n                gamma=PerceptibleReciprocal(gamma);\n                SetPixelChannel(destination,channel,ClampToQuantum(gamma*\n                  MeshInterpolate(&delta,pixels[1],pixels[0],pixels[3])),pixel);\n              }\n          }\n        else\n          {\n            /*\n              Diagonal 1-2 NE-SW.\n            */\n            if (delta.x <= (1.0-delta.y))\n              {\n                /*\n                  Top-left triangle (pixel: 0, diagonal: 1-2).\n                */\n                gamma=MeshInterpolate(&delta,alpha[0],alpha[1],alpha[2]);\n                gamma=PerceptibleReciprocal(gamma);\n                SetPixelChannel(destination,channel,ClampToQuantum(gamma*\n                  MeshInterpolate(&delta,pixels[0],pixels[1],pixels[2])),pixel);\n              }\n            else\n              {\n                /*\n                  Bottom-right triangle (pixel: 3, diagonal: 1-2).\n                */\n                delta.x=1.0-delta.x;\n                delta.y=1.0-delta.y;\n                gamma=MeshInterpolate(&delta,alpha[3],alpha[2],alpha[1]);\n                gamma=PerceptibleReciprocal(gamma);\n                SetPixelChannel(destination,channel,ClampToQuantum(gamma*\n                  MeshInterpolate(&delta,pixels[3],pixels[2],pixels[1])),pixel);\n              }\n          }\n      }\n      break;\n    }\n    case SplineInterpolatePixel:\n    {\n      double\n        cx[4],\n        cy[4];\n\n      p=GetCacheViewVirtualPixels(source_view,x_offset-1,y_offset-1,4,4,\n        exception);\n      if (p == (const Quantum *) NULL)\n        {\n          status=MagickFalse;\n          break;\n        }\n      for (i=0; i < (ssize_t) GetPixelChannels(source); i++)\n      {\n        register ssize_t\n          j;\n\n        PixelChannel channel = GetPixelChannelChannel(source,i);\n        PixelTrait traits = GetPixelChannelTraits(source,channel);\n        PixelTrait destination_traits=GetPixelChannelTraits(destination,\n          channel);\n        if ((traits == UndefinedPixelTrait) ||\n            (destination_traits == UndefinedPixelTrait))\n          continue;\n        if ((traits & BlendPixelTrait) == 0)\n          for (j=0; j < 16; j++)\n          {\n            alpha[j]=1.0;\n            pixels[j]=(double) p[j*GetPixelChannels(source)+i];\n          }\n        else\n          for (j=0; j < 16; j++)\n          {\n            alpha[j]=QuantumScale*GetPixelAlpha(source,p+j*\n              GetPixelChannels(source));\n            pixels[j]=alpha[j]*p[j*GetPixelChannels(source)+i];\n          }\n        SplineWeights((double) (x-x_offset),&cx);\n        SplineWeights((double) (y-y_offset),&cy);\n        gamma=((traits & BlendPixelTrait) ? (double) (1.0) :\n          PerceptibleReciprocal(cy[0]*(cx[0]*alpha[0]+cx[1]*alpha[1]+cx[2]*\n          alpha[2]+cx[3]*alpha[3])+cy[1]*(cx[0]*alpha[4]+cx[1]*alpha[5]+cx[2]*\n          alpha[6]+cx[3]*alpha[7])+cy[2]*(cx[0]*alpha[8]+cx[1]*alpha[9]+cx[2]*\n          alpha[10]+cx[3]*alpha[11])+cy[3]*(cx[0]*alpha[12]+cx[1]*alpha[13]+\n          cx[2]*alpha[14]+cx[3]*alpha[15])));\n        SetPixelChannel(destination,channel,ClampToQuantum(gamma*(cy[0]*(cx[0]*\n          pixels[0]+cx[1]*pixels[1]+cx[2]*pixels[2]+cx[3]*pixels[3])+cy[1]*\n          (cx[0]*pixels[4]+cx[1]*pixels[5]+cx[2]*pixels[6]+cx[3]*pixels[7])+\n          cy[2]*(cx[0]*pixels[8]+cx[1]*pixels[9]+cx[2]*pixels[10]+cx[3]*\n          pixels[11])+cy[3]*(cx[0]*pixels[12]+cx[1]*pixels[13]+cx[2]*\n          pixels[14]+cx[3]*pixels[15]))),pixel);\n      }\n      break;\n    }\n  }\n  return(status);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146755,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "MagickExport MagickBooleanType InterpolatePixelInfo(const Image *image,\n  const CacheView_ *image_view,const PixelInterpolateMethod method,\n  const double x,const double y,PixelInfo *pixel,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  double\n    alpha[16],\n    gamma;\n\n  PixelInfo\n    pixels[16];\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    x_offset,\n    y_offset;\n\n  PixelInterpolateMethod\n    interpolate;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image_view != (CacheView *) NULL);\n  status=MagickTrue;\n  x_offset=(ssize_t) floor(x);\n  y_offset=(ssize_t) floor(y);\n  interpolate=method;\n  if (interpolate == UndefinedInterpolatePixel)\n    interpolate=image->interpolate;\n  GetPixelInfoPixel(image,(const Quantum *) NULL,pixel);\n  (void) memset(&pixels,0,sizeof(pixels));\n  switch (interpolate)\n  {\n    case AverageInterpolatePixel:  /* nearest 4 neighbours */\n    case Average9InterpolatePixel:  /* nearest 9 neighbours */\n    case Average16InterpolatePixel:  /* nearest 16 neighbours */\n    {\n      ssize_t\n        count;\n\n      count=2;  /* size of the area to average - default nearest 4 */\n      if (interpolate == Average9InterpolatePixel)\n        {\n          count=3;\n          x_offset=(ssize_t) (floor(x+0.5)-1);\n          y_offset=(ssize_t) (floor(y+0.5)-1);\n        }\n      else if (interpolate == Average16InterpolatePixel)\n        {\n          count=4;\n          x_offset--;\n          y_offset--;\n        }\n      p=GetCacheViewVirtualPixels(image_view,x_offset,y_offset,(size_t) count,\n        (size_t) count,exception);\n      if (p == (const Quantum *) NULL)\n        {\n          status=MagickFalse;\n          break;\n        }\n      count*=count;  /* number of pixels - square of size */\n      for (i=0; i < (ssize_t) count; i++)\n      {\n        AlphaBlendPixelInfo(image,p,pixels,alpha);\n        gamma=PerceptibleReciprocal(alpha[0]);\n        pixel->red+=gamma*pixels[0].red;\n        pixel->green+=gamma*pixels[0].green;\n        pixel->blue+=gamma*pixels[0].blue;\n        pixel->black+=gamma*pixels[0].black;\n        pixel->alpha+=pixels[0].alpha;\n        p += GetPixelChannels(image);\n      }\n      gamma=1.0/count;   /* average weighting of each pixel in area */\n      pixel->red*=gamma;\n      pixel->green*=gamma;\n      pixel->blue*=gamma;\n      pixel->black*=gamma;\n      pixel->alpha*=gamma;\n      break;\n    }\n    case BackgroundInterpolatePixel:\n    {\n      *pixel=image->background_color;  /* Copy PixelInfo Structure  */\n      break;\n    }\n    case BilinearInterpolatePixel:\n    default:\n    {\n      PointInfo\n        delta,\n        epsilon;\n\n      p=GetCacheViewVirtualPixels(image_view,x_offset,y_offset,2,2,exception);\n      if (p == (const Quantum *) NULL)\n        {\n          status=MagickFalse;\n          break;\n        }\n      for (i=0; i < 4L; i++)\n        AlphaBlendPixelInfo(image,p+i*GetPixelChannels(image),pixels+i,alpha+i);\n      delta.x=x-x_offset;\n      delta.y=y-y_offset;\n      epsilon.x=1.0-delta.x;\n      epsilon.y=1.0-delta.y;\n      gamma=((epsilon.y*(epsilon.x*alpha[0]+delta.x*alpha[1])+delta.y*\n        (epsilon.x*alpha[2]+delta.x*alpha[3])));\n      gamma=PerceptibleReciprocal(gamma);\n      pixel->red=gamma*(epsilon.y*(epsilon.x*pixels[0].red+delta.x*\n        pixels[1].red)+delta.y*(epsilon.x*pixels[2].red+delta.x*pixels[3].red));\n      pixel->green=gamma*(epsilon.y*(epsilon.x*pixels[0].green+delta.x*\n        pixels[1].green)+delta.y*(epsilon.x*pixels[2].green+delta.x*\n        pixels[3].green));\n      pixel->blue=gamma*(epsilon.y*(epsilon.x*pixels[0].blue+delta.x*\n        pixels[1].blue)+delta.y*(epsilon.x*pixels[2].blue+delta.x*\n        pixels[3].blue));\n      if (image->colorspace == CMYKColorspace)\n        pixel->black=gamma*(epsilon.y*(epsilon.x*pixels[0].black+delta.x*\n          pixels[1].black)+delta.y*(epsilon.x*pixels[2].black+delta.x*\n          pixels[3].black));\n      gamma=((epsilon.y*(epsilon.x+delta.x)+delta.y*(epsilon.x+delta.x)));\n      gamma=PerceptibleReciprocal(gamma);\n      pixel->alpha=gamma*(epsilon.y*(epsilon.x*pixels[0].alpha+delta.x*\n        pixels[1].alpha)+delta.y*(epsilon.x*pixels[2].alpha+delta.x*\n        pixels[3].alpha));\n      break;\n    }\n    case BlendInterpolatePixel:\n    {\n      p=GetCacheViewVirtualPixels(image_view,x_offset,y_offset,2,2,exception);\n      if (p == (const Quantum *) NULL)\n        {\n          status=MagickFalse;\n          break;\n        }\n      for (i=0; i < 4L; i++)\n      {\n        GetPixelInfoPixel(image,p+i*GetPixelChannels(image),pixels+i);\n        AlphaBlendPixelInfo(image,p+i*GetPixelChannels(image),pixels+i,alpha+i);\n      }\n      gamma=1.0;  /* number of pixels blended together (its variable) */\n      for (i=0; i <= 1L; i++)\n      {\n        if ((y-y_offset) >= 0.75)\n          {\n            alpha[i]=alpha[i+2];  /* take right pixels */\n            pixels[i]=pixels[i+2];\n          }\n        else\n          if ((y-y_offset) > 0.25)\n            {\n              gamma=2.0;  /* blend both pixels in row */\n              alpha[i]+=alpha[i+2];  /* add up alpha weights */\n              pixels[i].red+=pixels[i+2].red;\n              pixels[i].green+=pixels[i+2].green;\n              pixels[i].blue+=pixels[i+2].blue;\n              pixels[i].black+=pixels[i+2].black;\n              pixels[i].alpha+=pixels[i+2].alpha;\n            }\n      }\n      if ((x-x_offset) >= 0.75)\n        {\n          alpha[0]=alpha[1];\n          pixels[0]=pixels[1];\n        }\n      else\n        if ((x-x_offset) > 0.25)\n          {\n            gamma*=2.0;  /* blend both rows */\n            alpha[0]+= alpha[1];  /* add up alpha weights */\n            pixels[0].red+=pixels[1].red;\n            pixels[0].green+=pixels[1].green;\n            pixels[0].blue+=pixels[1].blue;\n            pixels[0].black+=pixels[1].black;\n            pixels[0].alpha+=pixels[1].alpha;\n          }\n      gamma=1.0/gamma;\n      alpha[0]=PerceptibleReciprocal(alpha[0]);\n      pixel->red=alpha[0]*pixels[0].red;\n      pixel->green=alpha[0]*pixels[0].green;  /* divide by sum of alpha */\n      pixel->blue=alpha[0]*pixels[0].blue;\n      pixel->black=alpha[0]*pixels[0].black;\n      pixel->alpha=gamma*pixels[0].alpha;   /* divide by number of pixels */\n      break;\n    }\n    case CatromInterpolatePixel:\n    {\n      double\n        cx[4],\n        cy[4];\n\n      p=GetCacheViewVirtualPixels(image_view,x_offset-1,y_offset-1,4,4,\n        exception);\n      if (p == (const Quantum *) NULL)\n        {\n          status=MagickFalse;\n          break;\n        }\n      for (i=0; i < 16L; i++)\n        AlphaBlendPixelInfo(image,p+i*GetPixelChannels(image),pixels+i,alpha+i);\n      CatromWeights((double) (x-x_offset),&cx);\n      CatromWeights((double) (y-y_offset),&cy);\n      pixel->red=(cy[0]*(cx[0]*pixels[0].red+cx[1]*pixels[1].red+cx[2]*\n        pixels[2].red+cx[3]*pixels[3].red)+cy[1]*(cx[0]*pixels[4].red+cx[1]*\n        pixels[5].red+cx[2]*pixels[6].red+cx[3]*pixels[7].red)+cy[2]*(cx[0]*\n        pixels[8].red+cx[1]*pixels[9].red+cx[2]*pixels[10].red+cx[3]*\n        pixels[11].red)+cy[3]*(cx[0]*pixels[12].red+cx[1]*pixels[13].red+cx[2]*\n        pixels[14].red+cx[3]*pixels[15].red));\n      pixel->green=(cy[0]*(cx[0]*pixels[0].green+cx[1]*pixels[1].green+cx[2]*\n        pixels[2].green+cx[3]*pixels[3].green)+cy[1]*(cx[0]*pixels[4].green+\n        cx[1]*pixels[5].green+cx[2]*pixels[6].green+cx[3]*pixels[7].green)+\n        cy[2]*(cx[0]*pixels[8].green+cx[1]*pixels[9].green+cx[2]*\n        pixels[10].green+cx[3]*pixels[11].green)+cy[3]*(cx[0]*\n        pixels[12].green+cx[1]*pixels[13].green+cx[2]*pixels[14].green+cx[3]*\n        pixels[15].green));\n      pixel->blue=(cy[0]*(cx[0]*pixels[0].blue+cx[1]*pixels[1].blue+cx[2]*\n        pixels[2].blue+cx[3]*pixels[3].blue)+cy[1]*(cx[0]*pixels[4].blue+cx[1]*\n        pixels[5].blue+cx[2]*pixels[6].blue+cx[3]*pixels[7].blue)+cy[2]*(cx[0]*\n        pixels[8].blue+cx[1]*pixels[9].blue+cx[2]*pixels[10].blue+cx[3]*\n        pixels[11].blue)+cy[3]*(cx[0]*pixels[12].blue+cx[1]*pixels[13].blue+\n        cx[2]*pixels[14].blue+cx[3]*pixels[15].blue));\n      if (image->colorspace == CMYKColorspace)\n        pixel->black=(cy[0]*(cx[0]*pixels[0].black+cx[1]*pixels[1].black+cx[2]*\n          pixels[2].black+cx[3]*pixels[3].black)+cy[1]*(cx[0]*pixels[4].black+\n          cx[1]*pixels[5].black+cx[2]*pixels[6].black+cx[3]*pixels[7].black)+\n          cy[2]*(cx[0]*pixels[8].black+cx[1]*pixels[9].black+cx[2]*\n          pixels[10].black+cx[3]*pixels[11].black)+cy[3]*(cx[0]*\n          pixels[12].black+cx[1]*pixels[13].black+cx[2]*pixels[14].black+cx[3]*\n          pixels[15].black));\n      pixel->alpha=(cy[0]*(cx[0]*pixels[0].alpha+cx[1]*pixels[1].alpha+cx[2]*\n        pixels[2].alpha+cx[3]*pixels[3].alpha)+cy[1]*(cx[0]*pixels[4].alpha+\n        cx[1]*pixels[5].alpha+cx[2]*pixels[6].alpha+cx[3]*pixels[7].alpha)+\n        cy[2]*(cx[0]*pixels[8].alpha+cx[1]*pixels[9].alpha+cx[2]*\n        pixels[10].alpha+cx[3]*pixels[11].alpha)+cy[3]*(cx[0]*pixels[12].alpha+\n        cx[1]*pixels[13].alpha+cx[2]*pixels[14].alpha+cx[3]*pixels[15].alpha));\n      break;\n    }\n    case IntegerInterpolatePixel:\n    {\n      p=GetCacheViewVirtualPixels(image_view,x_offset,y_offset,1,1,exception);\n      if (p == (const Quantum *) NULL)\n        {\n          status=MagickFalse;\n          break;\n        }\n      GetPixelInfoPixel(image,p,pixel);\n      break;\n    }\n    case MeshInterpolatePixel:\n    {\n      PointInfo\n        delta,\n        luminance;\n\n      p=GetCacheViewVirtualPixels(image_view,x_offset,y_offset,2,2,exception);\n      if (p == (const Quantum *) NULL)\n        {\n          status=MagickFalse;\n          break;\n        }\n      delta.x=x-x_offset;\n      delta.y=y-y_offset;\n      luminance.x=GetPixelLuma(image,p)-(double)\n        GetPixelLuma(image,p+3*GetPixelChannels(image));\n      luminance.y=GetPixelLuma(image,p+GetPixelChannels(image))-(double)\n        GetPixelLuma(image,p+2*GetPixelChannels(image));\n      AlphaBlendPixelInfo(image,p,pixels+0,alpha+0);\n      AlphaBlendPixelInfo(image,p+GetPixelChannels(image),pixels+1,alpha+1);\n      AlphaBlendPixelInfo(image,p+2*GetPixelChannels(image),pixels+2,alpha+2);\n      AlphaBlendPixelInfo(image,p+3*GetPixelChannels(image),pixels+3,alpha+3);\n      if (fabs(luminance.x) < fabs(luminance.y))\n        {\n          /*\n            Diagonal 0-3 NW-SE.\n          */\n          if (delta.x <= delta.y)\n            {\n              /*\n                Bottom-left triangle (pixel: 2, diagonal: 0-3).\n              */\n              delta.y=1.0-delta.y;\n              gamma=MeshInterpolate(&delta,alpha[2],alpha[3],alpha[0]);\n              gamma=PerceptibleReciprocal(gamma);\n              pixel->red=gamma*MeshInterpolate(&delta,pixels[2].red,\n                pixels[3].red,pixels[0].red);\n              pixel->green=gamma*MeshInterpolate(&delta,pixels[2].green,\n                pixels[3].green,pixels[0].green);\n              pixel->blue=gamma*MeshInterpolate(&delta,pixels[2].blue,\n                pixels[3].blue,pixels[0].blue);\n              if (image->colorspace == CMYKColorspace)\n                pixel->black=gamma*MeshInterpolate(&delta,pixels[2].black,\n                  pixels[3].black,pixels[0].black);\n              gamma=MeshInterpolate(&delta,1.0,1.0,1.0);\n              pixel->alpha=gamma*MeshInterpolate(&delta,pixels[2].alpha,\n                pixels[3].alpha,pixels[0].alpha);\n            }\n          else\n            {\n              /*\n                Top-right triangle (pixel:1 , diagonal: 0-3).\n              */\n              delta.x=1.0-delta.x;\n              gamma=MeshInterpolate(&delta,alpha[1],alpha[0],alpha[3]);\n              gamma=PerceptibleReciprocal(gamma);\n              pixel->red=gamma*MeshInterpolate(&delta,pixels[1].red,\n                pixels[0].red,pixels[3].red);\n              pixel->green=gamma*MeshInterpolate(&delta,pixels[1].green,\n                pixels[0].green,pixels[3].green);\n              pixel->blue=gamma*MeshInterpolate(&delta,pixels[1].blue,\n                pixels[0].blue,pixels[3].blue);\n              if (image->colorspace == CMYKColorspace)\n                pixel->black=gamma*MeshInterpolate(&delta,pixels[1].black,\n                  pixels[0].black,pixels[3].black);\n              gamma=MeshInterpolate(&delta,1.0,1.0,1.0);\n              pixel->alpha=gamma*MeshInterpolate(&delta,pixels[1].alpha,\n                pixels[0].alpha,pixels[3].alpha);\n            }\n        }\n      else\n        {\n          /*\n            Diagonal 1-2 NE-SW.\n          */\n          if (delta.x <= (1.0-delta.y))\n            {\n              /*\n                Top-left triangle (pixel: 0, diagonal: 1-2).\n              */\n              gamma=MeshInterpolate(&delta,alpha[0],alpha[1],alpha[2]);\n              gamma=PerceptibleReciprocal(gamma);\n              pixel->red=gamma*MeshInterpolate(&delta,pixels[0].red,\n                pixels[1].red,pixels[2].red);\n              pixel->green=gamma*MeshInterpolate(&delta,pixels[0].green,\n                pixels[1].green,pixels[2].green);\n              pixel->blue=gamma*MeshInterpolate(&delta,pixels[0].blue,\n                pixels[1].blue,pixels[2].blue);\n              if (image->colorspace == CMYKColorspace)\n                pixel->black=gamma*MeshInterpolate(&delta,pixels[0].black,\n                  pixels[1].black,pixels[2].black);\n              gamma=MeshInterpolate(&delta,1.0,1.0,1.0);\n              pixel->alpha=gamma*MeshInterpolate(&delta,pixels[0].alpha,\n                pixels[1].alpha,pixels[2].alpha);\n            }\n          else\n            {\n              /*\n                Bottom-right triangle (pixel: 3, diagonal: 1-2).\n              */\n              delta.x=1.0-delta.x;\n              delta.y=1.0-delta.y;\n              gamma=MeshInterpolate(&delta,alpha[3],alpha[2],alpha[1]);\n              gamma=PerceptibleReciprocal(gamma);\n              pixel->red=gamma*MeshInterpolate(&delta,pixels[3].red,\n                pixels[2].red,pixels[1].red);\n              pixel->green=gamma*MeshInterpolate(&delta,pixels[3].green,\n                pixels[2].green,pixels[1].green);\n              pixel->blue=gamma*MeshInterpolate(&delta,pixels[3].blue,\n                pixels[2].blue,pixels[1].blue);\n              if (image->colorspace == CMYKColorspace)\n                pixel->black=gamma*MeshInterpolate(&delta,pixels[3].black,\n                  pixels[2].black,pixels[1].black);\n              gamma=MeshInterpolate(&delta,1.0,1.0,1.0);\n              pixel->alpha=gamma*MeshInterpolate(&delta,pixels[3].alpha,\n                pixels[2].alpha,pixels[1].alpha);\n            }\n        }\n      break;\n    }\n    case NearestInterpolatePixel:\n    {\n      x_offset=(ssize_t) floor(x+0.5);\n      y_offset=(ssize_t) floor(y+0.5);\n      p=GetCacheViewVirtualPixels(image_view,x_offset,y_offset,1,1,exception);\n      if (p == (const Quantum *) NULL)\n        {\n          status=MagickFalse;\n          break;\n        }\n      GetPixelInfoPixel(image,p,pixel);\n      break;\n    }\n    case SplineInterpolatePixel:\n    {\n      double\n        cx[4],\n        cy[4];\n\n      p=GetCacheViewVirtualPixels(image_view,x_offset-1,y_offset-1,4,4,\n        exception);\n      if (p == (const Quantum *) NULL)\n        {\n          status=MagickFalse;\n          break;\n        }\n      for (i=0; i < 16L; i++)\n        AlphaBlendPixelInfo(image,p+i*GetPixelChannels(image),pixels+i,alpha+i);\n      SplineWeights((double) (x-x_offset),&cx);\n      SplineWeights((double) (y-y_offset),&cy);\n      pixel->red=(cy[0]*(cx[0]*pixels[0].red+cx[1]*pixels[1].red+cx[2]*\n        pixels[2].red+cx[3]*pixels[3].red)+cy[1]*(cx[0]*pixels[4].red+cx[1]*\n        pixels[5].red+cx[2]*pixels[6].red+cx[3]*pixels[7].red)+cy[2]*(cx[0]*\n        pixels[8].red+cx[1]*pixels[9].red+cx[2]*pixels[10].red+cx[3]*\n        pixels[11].red)+cy[3]*(cx[0]*pixels[12].red+cx[1]*pixels[13].red+cx[2]*\n        pixels[14].red+cx[3]*pixels[15].red));\n      pixel->green=(cy[0]*(cx[0]*pixels[0].green+cx[1]*pixels[1].green+cx[2]*\n        pixels[2].green+cx[3]*pixels[3].green)+cy[1]*(cx[0]*pixels[4].green+\n        cx[1]*pixels[5].green+cx[2]*pixels[6].green+cx[3]*pixels[7].green)+\n        cy[2]*(cx[0]*pixels[8].green+cx[1]*pixels[9].green+cx[2]*\n        pixels[10].green+cx[3]*pixels[11].green)+cy[3]*(cx[0]*pixels[12].green+\n        cx[1]*pixels[13].green+cx[2]*pixels[14].green+cx[3]*pixels[15].green));\n      pixel->blue=(cy[0]*(cx[0]*pixels[0].blue+cx[1]*pixels[1].blue+cx[2]*\n        pixels[2].blue+cx[3]*pixels[3].blue)+cy[1]*(cx[0]*pixels[4].blue+cx[1]*\n        pixels[5].blue+cx[2]*pixels[6].blue+cx[3]*pixels[7].blue)+cy[2]*(cx[0]*\n        pixels[8].blue+cx[1]*pixels[9].blue+cx[2]*pixels[10].blue+cx[3]*\n        pixels[11].blue)+cy[3]*(cx[0]*pixels[12].blue+cx[1]*pixels[13].blue+\n        cx[2]*pixels[14].blue+cx[3]*pixels[15].blue));\n      if (image->colorspace == CMYKColorspace)\n        pixel->black=(cy[0]*(cx[0]*pixels[0].black+cx[1]*pixels[1].black+cx[2]*\n          pixels[2].black+cx[3]*pixels[3].black)+cy[1]*(cx[0]*pixels[4].black+\n          cx[1]*pixels[5].black+cx[2]*pixels[6].black+cx[3]*pixels[7].black)+\n          cy[2]*(cx[0]*pixels[8].black+cx[1]*pixels[9].black+cx[2]*\n          pixels[10].black+cx[3]*pixels[11].black)+cy[3]*(cx[0]*\n          pixels[12].black+cx[1]*pixels[13].black+cx[2]*pixels[14].black+cx[3]*\n          pixels[15].black));\n      pixel->alpha=(cy[0]*(cx[0]*pixels[0].alpha+cx[1]*pixels[1].alpha+cx[2]*\n        pixels[2].alpha+cx[3]*pixels[3].alpha)+cy[1]*(cx[0]*pixels[4].alpha+\n        cx[1]*pixels[5].alpha+cx[2]*pixels[6].alpha+cx[3]*pixels[7].alpha)+\n        cy[2]*(cx[0]*pixels[8].alpha+cx[1]*pixels[9].alpha+cx[2]*\n        pixels[10].alpha+cx[3]*pixels[11].alpha)+cy[3]*(cx[0]*pixels[12].alpha+\n        cx[1]*pixels[13].alpha+cx[2]*pixels[14].alpha+cx[3]*pixels[15].alpha));\n      break;\n    }\n  }\n  return(status);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146756,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "MagickExport MagickBooleanType InterpolatePixelInfo(const Image *image,\n  const CacheView_ *image_view,const PixelInterpolateMethod method,\n  const double x,const double y,PixelInfo *pixel,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  double\n    alpha[16],\n    gamma;\n\n  PixelInfo\n    pixels[16];\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    x_offset,\n    y_offset;\n\n  PixelInterpolateMethod\n    interpolate;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image_view != (CacheView *) NULL);\n  status=MagickTrue;\n  x_offset=(ssize_t) floor(ConstrainPixelOffset(x));\n  y_offset=(ssize_t) floor(ConstrainPixelOffset(y));\n  interpolate=method;\n  if (interpolate == UndefinedInterpolatePixel)\n    interpolate=image->interpolate;\n  GetPixelInfoPixel(image,(const Quantum *) NULL,pixel);\n  (void) memset(&pixels,0,sizeof(pixels));\n  switch (interpolate)\n  {\n    case AverageInterpolatePixel:  /* nearest 4 neighbours */\n    case Average9InterpolatePixel:  /* nearest 9 neighbours */\n    case Average16InterpolatePixel:  /* nearest 16 neighbours */\n    {\n      ssize_t\n        count;\n\n      count=2;  /* size of the area to average - default nearest 4 */\n      if (interpolate == Average9InterpolatePixel)\n        {\n          count=3;\n          x_offset=(ssize_t) (floor(ConstrainPixelOffset(x)+0.5)-1);\n          y_offset=(ssize_t) (floor(ConstrainPixelOffset(y)+0.5)-1);\n        }\n      else if (interpolate == Average16InterpolatePixel)\n        {\n          count=4;\n          x_offset--;\n          y_offset--;\n        }\n      p=GetCacheViewVirtualPixels(image_view,x_offset,y_offset,(size_t) count,\n        (size_t) count,exception);\n      if (p == (const Quantum *) NULL)\n        {\n          status=MagickFalse;\n          break;\n        }\n      count*=count;  /* number of pixels - square of size */\n      for (i=0; i < (ssize_t) count; i++)\n      {\n        AlphaBlendPixelInfo(image,p,pixels,alpha);\n        gamma=PerceptibleReciprocal(alpha[0]);\n        pixel->red+=gamma*pixels[0].red;\n        pixel->green+=gamma*pixels[0].green;\n        pixel->blue+=gamma*pixels[0].blue;\n        pixel->black+=gamma*pixels[0].black;\n        pixel->alpha+=pixels[0].alpha;\n        p += GetPixelChannels(image);\n      }\n      gamma=1.0/count;   /* average weighting of each pixel in area */\n      pixel->red*=gamma;\n      pixel->green*=gamma;\n      pixel->blue*=gamma;\n      pixel->black*=gamma;\n      pixel->alpha*=gamma;\n      break;\n    }\n    case BackgroundInterpolatePixel:\n    {\n      *pixel=image->background_color;  /* Copy PixelInfo Structure  */\n      break;\n    }\n    case BilinearInterpolatePixel:\n    default:\n    {\n      PointInfo\n        delta,\n        epsilon;\n\n      p=GetCacheViewVirtualPixels(image_view,x_offset,y_offset,2,2,exception);\n      if (p == (const Quantum *) NULL)\n        {\n          status=MagickFalse;\n          break;\n        }\n      for (i=0; i < 4L; i++)\n        AlphaBlendPixelInfo(image,p+i*GetPixelChannels(image),pixels+i,alpha+i);\n      delta.x=x-x_offset;\n      delta.y=y-y_offset;\n      epsilon.x=1.0-delta.x;\n      epsilon.y=1.0-delta.y;\n      gamma=((epsilon.y*(epsilon.x*alpha[0]+delta.x*alpha[1])+delta.y*\n        (epsilon.x*alpha[2]+delta.x*alpha[3])));\n      gamma=PerceptibleReciprocal(gamma);\n      pixel->red=gamma*(epsilon.y*(epsilon.x*pixels[0].red+delta.x*\n        pixels[1].red)+delta.y*(epsilon.x*pixels[2].red+delta.x*pixels[3].red));\n      pixel->green=gamma*(epsilon.y*(epsilon.x*pixels[0].green+delta.x*\n        pixels[1].green)+delta.y*(epsilon.x*pixels[2].green+delta.x*\n        pixels[3].green));\n      pixel->blue=gamma*(epsilon.y*(epsilon.x*pixels[0].blue+delta.x*\n        pixels[1].blue)+delta.y*(epsilon.x*pixels[2].blue+delta.x*\n        pixels[3].blue));\n      if (image->colorspace == CMYKColorspace)\n        pixel->black=gamma*(epsilon.y*(epsilon.x*pixels[0].black+delta.x*\n          pixels[1].black)+delta.y*(epsilon.x*pixels[2].black+delta.x*\n          pixels[3].black));\n      gamma=((epsilon.y*(epsilon.x+delta.x)+delta.y*(epsilon.x+delta.x)));\n      gamma=PerceptibleReciprocal(gamma);\n      pixel->alpha=gamma*(epsilon.y*(epsilon.x*pixels[0].alpha+delta.x*\n        pixels[1].alpha)+delta.y*(epsilon.x*pixels[2].alpha+delta.x*\n        pixels[3].alpha));\n      break;\n    }\n    case BlendInterpolatePixel:\n    {\n      p=GetCacheViewVirtualPixels(image_view,x_offset,y_offset,2,2,exception);\n      if (p == (const Quantum *) NULL)\n        {\n          status=MagickFalse;\n          break;\n        }\n      for (i=0; i < 4L; i++)\n      {\n        GetPixelInfoPixel(image,p+i*GetPixelChannels(image),pixels+i);\n        AlphaBlendPixelInfo(image,p+i*GetPixelChannels(image),pixels+i,alpha+i);\n      }\n      gamma=1.0;  /* number of pixels blended together (its variable) */\n      for (i=0; i <= 1L; i++)\n      {\n        if ((y-y_offset) >= 0.75)\n          {\n            alpha[i]=alpha[i+2];  /* take right pixels */\n            pixels[i]=pixels[i+2];\n          }\n        else\n          if ((y-y_offset) > 0.25)\n            {\n              gamma=2.0;  /* blend both pixels in row */\n              alpha[i]+=alpha[i+2];  /* add up alpha weights */\n              pixels[i].red+=pixels[i+2].red;\n              pixels[i].green+=pixels[i+2].green;\n              pixels[i].blue+=pixels[i+2].blue;\n              pixels[i].black+=pixels[i+2].black;\n              pixels[i].alpha+=pixels[i+2].alpha;\n            }\n      }\n      if ((x-x_offset) >= 0.75)\n        {\n          alpha[0]=alpha[1];\n          pixels[0]=pixels[1];\n        }\n      else\n        if ((x-x_offset) > 0.25)\n          {\n            gamma*=2.0;  /* blend both rows */\n            alpha[0]+= alpha[1];  /* add up alpha weights */\n            pixels[0].red+=pixels[1].red;\n            pixels[0].green+=pixels[1].green;\n            pixels[0].blue+=pixels[1].blue;\n            pixels[0].black+=pixels[1].black;\n            pixels[0].alpha+=pixels[1].alpha;\n          }\n      gamma=1.0/gamma;\n      alpha[0]=PerceptibleReciprocal(alpha[0]);\n      pixel->red=alpha[0]*pixels[0].red;\n      pixel->green=alpha[0]*pixels[0].green;  /* divide by sum of alpha */\n      pixel->blue=alpha[0]*pixels[0].blue;\n      pixel->black=alpha[0]*pixels[0].black;\n      pixel->alpha=gamma*pixels[0].alpha;   /* divide by number of pixels */\n      break;\n    }\n    case CatromInterpolatePixel:\n    {\n      double\n        cx[4],\n        cy[4];\n\n      p=GetCacheViewVirtualPixels(image_view,x_offset-1,y_offset-1,4,4,\n        exception);\n      if (p == (const Quantum *) NULL)\n        {\n          status=MagickFalse;\n          break;\n        }\n      for (i=0; i < 16L; i++)\n        AlphaBlendPixelInfo(image,p+i*GetPixelChannels(image),pixels+i,alpha+i);\n      CatromWeights((double) (x-x_offset),&cx);\n      CatromWeights((double) (y-y_offset),&cy);\n      pixel->red=(cy[0]*(cx[0]*pixels[0].red+cx[1]*pixels[1].red+cx[2]*\n        pixels[2].red+cx[3]*pixels[3].red)+cy[1]*(cx[0]*pixels[4].red+cx[1]*\n        pixels[5].red+cx[2]*pixels[6].red+cx[3]*pixels[7].red)+cy[2]*(cx[0]*\n        pixels[8].red+cx[1]*pixels[9].red+cx[2]*pixels[10].red+cx[3]*\n        pixels[11].red)+cy[3]*(cx[0]*pixels[12].red+cx[1]*pixels[13].red+cx[2]*\n        pixels[14].red+cx[3]*pixels[15].red));\n      pixel->green=(cy[0]*(cx[0]*pixels[0].green+cx[1]*pixels[1].green+cx[2]*\n        pixels[2].green+cx[3]*pixels[3].green)+cy[1]*(cx[0]*pixels[4].green+\n        cx[1]*pixels[5].green+cx[2]*pixels[6].green+cx[3]*pixels[7].green)+\n        cy[2]*(cx[0]*pixels[8].green+cx[1]*pixels[9].green+cx[2]*\n        pixels[10].green+cx[3]*pixels[11].green)+cy[3]*(cx[0]*\n        pixels[12].green+cx[1]*pixels[13].green+cx[2]*pixels[14].green+cx[3]*\n        pixels[15].green));\n      pixel->blue=(cy[0]*(cx[0]*pixels[0].blue+cx[1]*pixels[1].blue+cx[2]*\n        pixels[2].blue+cx[3]*pixels[3].blue)+cy[1]*(cx[0]*pixels[4].blue+cx[1]*\n        pixels[5].blue+cx[2]*pixels[6].blue+cx[3]*pixels[7].blue)+cy[2]*(cx[0]*\n        pixels[8].blue+cx[1]*pixels[9].blue+cx[2]*pixels[10].blue+cx[3]*\n        pixels[11].blue)+cy[3]*(cx[0]*pixels[12].blue+cx[1]*pixels[13].blue+\n        cx[2]*pixels[14].blue+cx[3]*pixels[15].blue));\n      if (image->colorspace == CMYKColorspace)\n        pixel->black=(cy[0]*(cx[0]*pixels[0].black+cx[1]*pixels[1].black+cx[2]*\n          pixels[2].black+cx[3]*pixels[3].black)+cy[1]*(cx[0]*pixels[4].black+\n          cx[1]*pixels[5].black+cx[2]*pixels[6].black+cx[3]*pixels[7].black)+\n          cy[2]*(cx[0]*pixels[8].black+cx[1]*pixels[9].black+cx[2]*\n          pixels[10].black+cx[3]*pixels[11].black)+cy[3]*(cx[0]*\n          pixels[12].black+cx[1]*pixels[13].black+cx[2]*pixels[14].black+cx[3]*\n          pixels[15].black));\n      pixel->alpha=(cy[0]*(cx[0]*pixels[0].alpha+cx[1]*pixels[1].alpha+cx[2]*\n        pixels[2].alpha+cx[3]*pixels[3].alpha)+cy[1]*(cx[0]*pixels[4].alpha+\n        cx[1]*pixels[5].alpha+cx[2]*pixels[6].alpha+cx[3]*pixels[7].alpha)+\n        cy[2]*(cx[0]*pixels[8].alpha+cx[1]*pixels[9].alpha+cx[2]*\n        pixels[10].alpha+cx[3]*pixels[11].alpha)+cy[3]*(cx[0]*pixels[12].alpha+\n        cx[1]*pixels[13].alpha+cx[2]*pixels[14].alpha+cx[3]*pixels[15].alpha));\n      break;\n    }\n    case IntegerInterpolatePixel:\n    {\n      p=GetCacheViewVirtualPixels(image_view,x_offset,y_offset,1,1,exception);\n      if (p == (const Quantum *) NULL)\n        {\n          status=MagickFalse;\n          break;\n        }\n      GetPixelInfoPixel(image,p,pixel);\n      break;\n    }\n    case MeshInterpolatePixel:\n    {\n      PointInfo\n        delta,\n        luminance;\n\n      p=GetCacheViewVirtualPixels(image_view,x_offset,y_offset,2,2,exception);\n      if (p == (const Quantum *) NULL)\n        {\n          status=MagickFalse;\n          break;\n        }\n      delta.x=x-x_offset;\n      delta.y=y-y_offset;\n      luminance.x=GetPixelLuma(image,p)-(double)\n        GetPixelLuma(image,p+3*GetPixelChannels(image));\n      luminance.y=GetPixelLuma(image,p+GetPixelChannels(image))-(double)\n        GetPixelLuma(image,p+2*GetPixelChannels(image));\n      AlphaBlendPixelInfo(image,p,pixels+0,alpha+0);\n      AlphaBlendPixelInfo(image,p+GetPixelChannels(image),pixels+1,alpha+1);\n      AlphaBlendPixelInfo(image,p+2*GetPixelChannels(image),pixels+2,alpha+2);\n      AlphaBlendPixelInfo(image,p+3*GetPixelChannels(image),pixels+3,alpha+3);\n      if (fabs(luminance.x) < fabs(luminance.y))\n        {\n          /*\n            Diagonal 0-3 NW-SE.\n          */\n          if (delta.x <= delta.y)\n            {\n              /*\n                Bottom-left triangle (pixel: 2, diagonal: 0-3).\n              */\n              delta.y=1.0-delta.y;\n              gamma=MeshInterpolate(&delta,alpha[2],alpha[3],alpha[0]);\n              gamma=PerceptibleReciprocal(gamma);\n              pixel->red=gamma*MeshInterpolate(&delta,pixels[2].red,\n                pixels[3].red,pixels[0].red);\n              pixel->green=gamma*MeshInterpolate(&delta,pixels[2].green,\n                pixels[3].green,pixels[0].green);\n              pixel->blue=gamma*MeshInterpolate(&delta,pixels[2].blue,\n                pixels[3].blue,pixels[0].blue);\n              if (image->colorspace == CMYKColorspace)\n                pixel->black=gamma*MeshInterpolate(&delta,pixels[2].black,\n                  pixels[3].black,pixels[0].black);\n              gamma=MeshInterpolate(&delta,1.0,1.0,1.0);\n              pixel->alpha=gamma*MeshInterpolate(&delta,pixels[2].alpha,\n                pixels[3].alpha,pixels[0].alpha);\n            }\n          else\n            {\n              /*\n                Top-right triangle (pixel:1 , diagonal: 0-3).\n              */\n              delta.x=1.0-delta.x;\n              gamma=MeshInterpolate(&delta,alpha[1],alpha[0],alpha[3]);\n              gamma=PerceptibleReciprocal(gamma);\n              pixel->red=gamma*MeshInterpolate(&delta,pixels[1].red,\n                pixels[0].red,pixels[3].red);\n              pixel->green=gamma*MeshInterpolate(&delta,pixels[1].green,\n                pixels[0].green,pixels[3].green);\n              pixel->blue=gamma*MeshInterpolate(&delta,pixels[1].blue,\n                pixels[0].blue,pixels[3].blue);\n              if (image->colorspace == CMYKColorspace)\n                pixel->black=gamma*MeshInterpolate(&delta,pixels[1].black,\n                  pixels[0].black,pixels[3].black);\n              gamma=MeshInterpolate(&delta,1.0,1.0,1.0);\n              pixel->alpha=gamma*MeshInterpolate(&delta,pixels[1].alpha,\n                pixels[0].alpha,pixels[3].alpha);\n            }\n        }\n      else\n        {\n          /*\n            Diagonal 1-2 NE-SW.\n          */\n          if (delta.x <= (1.0-delta.y))\n            {\n              /*\n                Top-left triangle (pixel: 0, diagonal: 1-2).\n              */\n              gamma=MeshInterpolate(&delta,alpha[0],alpha[1],alpha[2]);\n              gamma=PerceptibleReciprocal(gamma);\n              pixel->red=gamma*MeshInterpolate(&delta,pixels[0].red,\n                pixels[1].red,pixels[2].red);\n              pixel->green=gamma*MeshInterpolate(&delta,pixels[0].green,\n                pixels[1].green,pixels[2].green);\n              pixel->blue=gamma*MeshInterpolate(&delta,pixels[0].blue,\n                pixels[1].blue,pixels[2].blue);\n              if (image->colorspace == CMYKColorspace)\n                pixel->black=gamma*MeshInterpolate(&delta,pixels[0].black,\n                  pixels[1].black,pixels[2].black);\n              gamma=MeshInterpolate(&delta,1.0,1.0,1.0);\n              pixel->alpha=gamma*MeshInterpolate(&delta,pixels[0].alpha,\n                pixels[1].alpha,pixels[2].alpha);\n            }\n          else\n            {\n              /*\n                Bottom-right triangle (pixel: 3, diagonal: 1-2).\n              */\n              delta.x=1.0-delta.x;\n              delta.y=1.0-delta.y;\n              gamma=MeshInterpolate(&delta,alpha[3],alpha[2],alpha[1]);\n              gamma=PerceptibleReciprocal(gamma);\n              pixel->red=gamma*MeshInterpolate(&delta,pixels[3].red,\n                pixels[2].red,pixels[1].red);\n              pixel->green=gamma*MeshInterpolate(&delta,pixels[3].green,\n                pixels[2].green,pixels[1].green);\n              pixel->blue=gamma*MeshInterpolate(&delta,pixels[3].blue,\n                pixels[2].blue,pixels[1].blue);\n              if (image->colorspace == CMYKColorspace)\n                pixel->black=gamma*MeshInterpolate(&delta,pixels[3].black,\n                  pixels[2].black,pixels[1].black);\n              gamma=MeshInterpolate(&delta,1.0,1.0,1.0);\n              pixel->alpha=gamma*MeshInterpolate(&delta,pixels[3].alpha,\n                pixels[2].alpha,pixels[1].alpha);\n            }\n        }\n      break;\n    }\n    case NearestInterpolatePixel:\n    {\n      x_offset=(ssize_t) floor(ConstrainPixelOffset(x)+0.5);\n      y_offset=(ssize_t) floor(ConstrainPixelOffset(y)+0.5);\n      p=GetCacheViewVirtualPixels(image_view,x_offset,y_offset,1,1,exception);\n      if (p == (const Quantum *) NULL)\n        {\n          status=MagickFalse;\n          break;\n        }\n      GetPixelInfoPixel(image,p,pixel);\n      break;\n    }\n    case SplineInterpolatePixel:\n    {\n      double\n        cx[4],\n        cy[4];\n\n      p=GetCacheViewVirtualPixels(image_view,x_offset-1,y_offset-1,4,4,\n        exception);\n      if (p == (const Quantum *) NULL)\n        {\n          status=MagickFalse;\n          break;\n        }\n      for (i=0; i < 16L; i++)\n        AlphaBlendPixelInfo(image,p+i*GetPixelChannels(image),pixels+i,alpha+i);\n      SplineWeights((double) (x-x_offset),&cx);\n      SplineWeights((double) (y-y_offset),&cy);\n      pixel->red=(cy[0]*(cx[0]*pixels[0].red+cx[1]*pixels[1].red+cx[2]*\n        pixels[2].red+cx[3]*pixels[3].red)+cy[1]*(cx[0]*pixels[4].red+cx[1]*\n        pixels[5].red+cx[2]*pixels[6].red+cx[3]*pixels[7].red)+cy[2]*(cx[0]*\n        pixels[8].red+cx[1]*pixels[9].red+cx[2]*pixels[10].red+cx[3]*\n        pixels[11].red)+cy[3]*(cx[0]*pixels[12].red+cx[1]*pixels[13].red+cx[2]*\n        pixels[14].red+cx[3]*pixels[15].red));\n      pixel->green=(cy[0]*(cx[0]*pixels[0].green+cx[1]*pixels[1].green+cx[2]*\n        pixels[2].green+cx[3]*pixels[3].green)+cy[1]*(cx[0]*pixels[4].green+\n        cx[1]*pixels[5].green+cx[2]*pixels[6].green+cx[3]*pixels[7].green)+\n        cy[2]*(cx[0]*pixels[8].green+cx[1]*pixels[9].green+cx[2]*\n        pixels[10].green+cx[3]*pixels[11].green)+cy[3]*(cx[0]*pixels[12].green+\n        cx[1]*pixels[13].green+cx[2]*pixels[14].green+cx[3]*pixels[15].green));\n      pixel->blue=(cy[0]*(cx[0]*pixels[0].blue+cx[1]*pixels[1].blue+cx[2]*\n        pixels[2].blue+cx[3]*pixels[3].blue)+cy[1]*(cx[0]*pixels[4].blue+cx[1]*\n        pixels[5].blue+cx[2]*pixels[6].blue+cx[3]*pixels[7].blue)+cy[2]*(cx[0]*\n        pixels[8].blue+cx[1]*pixels[9].blue+cx[2]*pixels[10].blue+cx[3]*\n        pixels[11].blue)+cy[3]*(cx[0]*pixels[12].blue+cx[1]*pixels[13].blue+\n        cx[2]*pixels[14].blue+cx[3]*pixels[15].blue));\n      if (image->colorspace == CMYKColorspace)\n        pixel->black=(cy[0]*(cx[0]*pixels[0].black+cx[1]*pixels[1].black+cx[2]*\n          pixels[2].black+cx[3]*pixels[3].black)+cy[1]*(cx[0]*pixels[4].black+\n          cx[1]*pixels[5].black+cx[2]*pixels[6].black+cx[3]*pixels[7].black)+\n          cy[2]*(cx[0]*pixels[8].black+cx[1]*pixels[9].black+cx[2]*\n          pixels[10].black+cx[3]*pixels[11].black)+cy[3]*(cx[0]*\n          pixels[12].black+cx[1]*pixels[13].black+cx[2]*pixels[14].black+cx[3]*\n          pixels[15].black));\n      pixel->alpha=(cy[0]*(cx[0]*pixels[0].alpha+cx[1]*pixels[1].alpha+cx[2]*\n        pixels[2].alpha+cx[3]*pixels[3].alpha)+cy[1]*(cx[0]*pixels[4].alpha+\n        cx[1]*pixels[5].alpha+cx[2]*pixels[6].alpha+cx[3]*pixels[7].alpha)+\n        cy[2]*(cx[0]*pixels[8].alpha+cx[1]*pixels[9].alpha+cx[2]*\n        pixels[10].alpha+cx[3]*pixels[11].alpha)+cy[3]*(cx[0]*pixels[12].alpha+\n        cx[1]*pixels[13].alpha+cx[2]*pixels[14].alpha+cx[3]*pixels[15].alpha));\n      break;\n    }\n  }\n  return(status);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146757,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "MagickExport MagickBooleanType InterpolatePixelChannel(\n  const Image *magick_restrict image,const CacheView_ *image_view,\n  const PixelChannel channel,const PixelInterpolateMethod method,\n  const double x,const double y,double *pixel,ExceptionInfo *exception)\n{\n  double\n    alpha[16],\n    gamma,\n    pixels[16];\n\n  MagickBooleanType\n    status;\n\n  PixelInterpolateMethod\n    interpolate;\n\n  PixelTrait\n    traits;\n\n  register const Quantum\n    *magick_restrict p;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    x_offset,\n    y_offset;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image_view != (CacheView *) NULL);\n  status=MagickTrue;\n  *pixel=0.0;\n  traits=GetPixelChannelTraits(image,channel);\n  x_offset=(ssize_t) floor(x);\n  y_offset=(ssize_t) floor(y);\n  interpolate=method;\n  if (interpolate == UndefinedInterpolatePixel)\n    interpolate=image->interpolate;\n  switch (interpolate)\n  {\n    case AverageInterpolatePixel:  /* nearest 4 neighbours */\n    case Average9InterpolatePixel:  /* nearest 9 neighbours */\n    case Average16InterpolatePixel:  /* nearest 16 neighbours */\n    {\n      ssize_t\n        count;\n\n      count=2;  /* size of the area to average - default nearest 4 */\n      if (interpolate == Average9InterpolatePixel)\n        {\n          count=3;\n          x_offset=(ssize_t) (floor(x+0.5)-1);\n          y_offset=(ssize_t) (floor(y+0.5)-1);\n        }\n      else\n        if (interpolate == Average16InterpolatePixel)\n          {\n            count=4;\n            x_offset--;\n            y_offset--;\n          }\n      p=GetCacheViewVirtualPixels(image_view,x_offset,y_offset,(size_t) count,\n        (size_t) count,exception);\n      if (p == (const Quantum *) NULL)\n        {\n          status=MagickFalse;\n          break;\n        }\n      count*=count;  /* Number of pixels to average */\n      if ((traits & BlendPixelTrait) == 0)\n        for (i=0; i < (ssize_t) count; i++)\n        {\n          alpha[i]=1.0;\n          pixels[i]=(double) p[i*GetPixelChannels(image)+channel];\n        }\n      else\n        for (i=0; i < (ssize_t) count; i++)\n        {\n          alpha[i]=QuantumScale*GetPixelAlpha(image,p+i*\n            GetPixelChannels(image));\n          pixels[i]=alpha[i]*p[i*GetPixelChannels(image)+channel];\n        }\n      for (i=0; i < (ssize_t) count; i++)\n      {\n        gamma=PerceptibleReciprocal(alpha[i])/count;\n        *pixel+=gamma*pixels[i];\n      }\n      break;\n    }\n    case BilinearInterpolatePixel:\n    default:\n    {\n      PointInfo\n        delta,\n        epsilon;\n\n      p=GetCacheViewVirtualPixels(image_view,x_offset,y_offset,2,2,exception);\n      if (p == (const Quantum *) NULL)\n        {\n          status=MagickFalse;\n          break;\n        }\n      if ((traits & BlendPixelTrait) == 0)\n        for (i=0; i < 4; i++)\n        {\n          alpha[i]=1.0;\n          pixels[i]=(double) p[i*GetPixelChannels(image)+channel];\n        }\n      else\n        for (i=0; i < 4; i++)\n        {\n          alpha[i]=QuantumScale*GetPixelAlpha(image,p+i*\n            GetPixelChannels(image));\n          pixels[i]=alpha[i]*p[i*GetPixelChannels(image)+channel];\n        }\n      delta.x=x-x_offset;\n      delta.y=y-y_offset;\n      epsilon.x=1.0-delta.x;\n      epsilon.y=1.0-delta.y;\n      gamma=((epsilon.y*(epsilon.x*alpha[0]+delta.x*alpha[1])+delta.y*\n        (epsilon.x*alpha[2]+delta.x*alpha[3])));\n      gamma=PerceptibleReciprocal(gamma);\n      *pixel=gamma*(epsilon.y*(epsilon.x*pixels[0]+delta.x*pixels[1])+delta.y*\n        (epsilon.x*pixels[2]+delta.x*pixels[3]));\n      break;\n    }\n    case BlendInterpolatePixel:\n    {\n      p=GetCacheViewVirtualPixels(image_view,x_offset,y_offset,2,2,exception);\n      if (p == (const Quantum *) NULL)\n        {\n          status=MagickFalse;\n          break;\n        }\n      if ((traits & BlendPixelTrait) == 0)\n        for (i=0; i < 4; i++)\n        {\n          alpha[i]=1.0;\n          pixels[i]=(MagickRealType) p[i*GetPixelChannels(image)+channel];\n        }\n      else\n        for (i=0; i < 4; i++)\n        {\n          alpha[i]=QuantumScale*GetPixelAlpha(image,p+i*\n            GetPixelChannels(image));\n          pixels[i]=alpha[i]*p[i*GetPixelChannels(image)+channel];\n        }\n      gamma=1.0;  /* number of pixels blended together (its variable) */\n      for (i=0; i <= 1L; i++) {\n        if ((y-y_offset) >= 0.75)\n          {\n            alpha[i]=alpha[i+2];  /* take right pixels */\n            pixels[i]=pixels[i+2];\n          }\n        else\n          if ((y-y_offset) > 0.25)\n            {\n              gamma=2.0;  /* blend both pixels in row */\n              alpha[i]+=alpha[i+2];  /* add up alpha weights */\n              pixels[i]+=pixels[i+2];\n            }\n      }\n      if ((x-x_offset) >= 0.75)\n        {\n          alpha[0]=alpha[1];  /* take bottom row blend */\n          pixels[0]=pixels[1];\n        }\n      else\n        if ((x-x_offset) > 0.25)\n          {\n            gamma*=2.0;  /* blend both rows */\n            alpha[0]+=alpha[1];  /* add up alpha weights */\n            pixels[0]+=pixels[1];\n          }\n      if (channel != AlphaPixelChannel)\n        gamma=PerceptibleReciprocal(alpha[0]);  /* (color) 1/alpha_weights */\n      else\n        gamma=PerceptibleReciprocal(gamma);  /* (alpha) 1/number_of_pixels */\n      *pixel=gamma*pixels[0];\n      break;\n    }\n    case CatromInterpolatePixel:\n    {\n      double\n        cx[4],\n        cy[4];\n\n      p=GetCacheViewVirtualPixels(image_view,x_offset-1,y_offset-1,4,4,\n        exception);\n      if (p == (const Quantum *) NULL)\n        {\n          status=MagickFalse;\n          break;\n        }\n      if ((traits & BlendPixelTrait) == 0)\n        for (i=0; i < 16; i++)\n        {\n          alpha[i]=1.0;\n          pixels[i]=(double) p[i*GetPixelChannels(image)+channel];\n        }\n      else\n        for (i=0; i < 16; i++)\n        {\n          alpha[i]=QuantumScale*GetPixelAlpha(image,p+i*\n            GetPixelChannels(image));\n          pixels[i]=alpha[i]*p[i*GetPixelChannels(image)+channel];\n        }\n      CatromWeights((double) (x-x_offset),&cx);\n      CatromWeights((double) (y-y_offset),&cy);\n      gamma=(channel == AlphaPixelChannel ? (double) 1.0 :\n        PerceptibleReciprocal(cy[0]*(cx[0]*alpha[0]+cx[1]*alpha[1]+cx[2]*\n        alpha[2]+cx[3]*alpha[3])+cy[1]*(cx[0]*alpha[4]+cx[1]*alpha[5]+cx[2]*\n        alpha[6]+cx[3]*alpha[7])+cy[2]*(cx[0]*alpha[8]+cx[1]*alpha[9]+cx[2]*\n        alpha[10]+cx[3]*alpha[11])+cy[3]*(cx[0]*alpha[12]+cx[1]*alpha[13]+\n        cx[2]*alpha[14]+cx[3]*alpha[15])));\n      *pixel=gamma*(cy[0]*(cx[0]*pixels[0]+cx[1]*pixels[1]+cx[2]*pixels[2]+\n        cx[3]*pixels[3])+cy[1]*(cx[0]*pixels[4]+cx[1]*pixels[5]+cx[2]*\n        pixels[6]+cx[3]*pixels[7])+cy[2]*(cx[0]*pixels[8]+cx[1]*pixels[9]+\n        cx[2]*pixels[10]+cx[3]*pixels[11])+cy[3]*(cx[0]*pixels[12]+cx[1]*\n        pixels[13]+cx[2]*pixels[14]+cx[3]*pixels[15]));\n      break;\n    }\n    case IntegerInterpolatePixel:\n    {\n      p=GetCacheViewVirtualPixels(image_view,x_offset,y_offset,1,1,exception);\n      if (p == (const Quantum *) NULL)\n        {\n          status=MagickFalse;\n          break;\n        }\n      *pixel=(double) GetPixelChannel(image,channel,p);\n      break;\n    }\n    case NearestInterpolatePixel:\n    {\n      x_offset=(ssize_t) floor(x+0.5);\n      y_offset=(ssize_t) floor(y+0.5);\n      p=GetCacheViewVirtualPixels(image_view,x_offset,y_offset,1,1,exception);\n      if (p == (const Quantum *) NULL)\n        {\n          status=MagickFalse;\n          break;\n        }\n      *pixel=(double) GetPixelChannel(image,channel,p);\n      break;\n    }\n    case MeshInterpolatePixel:\n    {\n      PointInfo\n        delta,\n        luminance;\n\n      p=GetCacheViewVirtualPixels(image_view,x_offset,y_offset,2,2,exception);\n      if (p == (const Quantum *) NULL)\n        {\n          status=MagickFalse;\n          break;\n        }\n      if ((traits & BlendPixelTrait) == 0)\n        for (i=0; i < 4; i++)\n        {\n          alpha[i]=1.0;\n          pixels[i]=(double) p[i*GetPixelChannels(image)+channel];\n        }\n      else\n        for (i=0; i < 4; i++)\n        {\n          alpha[i]=QuantumScale*GetPixelAlpha(image,p+i*\n            GetPixelChannels(image));\n          pixels[i]=alpha[i]*p[i*GetPixelChannels(image)+channel];\n        }\n      delta.x=x-x_offset;\n      delta.y=y-y_offset;\n      luminance.x=GetPixelLuma(image,p)-(double)\n        GetPixelLuma(image,p+3*GetPixelChannels(image));\n      luminance.y=GetPixelLuma(image,p+GetPixelChannels(image))-(double)\n        GetPixelLuma(image,p+2*GetPixelChannels(image));\n      if (fabs(luminance.x) < fabs(luminance.y))\n        {\n          /*\n            Diagonal 0-3 NW-SE.\n          */\n          if (delta.x <= delta.y)\n            {\n              /*\n                Bottom-left triangle (pixel: 2, diagonal: 0-3).\n              */\n              delta.y=1.0-delta.y;\n              gamma=MeshInterpolate(&delta,alpha[2],alpha[3],alpha[0]);\n              gamma=PerceptibleReciprocal(gamma);\n              *pixel=gamma*MeshInterpolate(&delta,pixels[2],pixels[3],\n                pixels[0]);\n            }\n          else\n            {\n              /*\n                Top-right triangle (pixel: 1, diagonal: 0-3).\n              */\n              delta.x=1.0-delta.x;\n              gamma=MeshInterpolate(&delta,alpha[1],alpha[0],alpha[3]);\n              gamma=PerceptibleReciprocal(gamma);\n              *pixel=gamma*MeshInterpolate(&delta,pixels[1],pixels[0],\n                pixels[3]);\n            }\n        }\n      else\n        {\n          /*\n            Diagonal 1-2 NE-SW.\n          */\n          if (delta.x <= (1.0-delta.y))\n            {\n              /*\n                Top-left triangle (pixel: 0, diagonal: 1-2).\n              */\n              gamma=MeshInterpolate(&delta,alpha[0],alpha[1],alpha[2]);\n              gamma=PerceptibleReciprocal(gamma);\n              *pixel=gamma*MeshInterpolate(&delta,pixels[0],pixels[1],\n                pixels[2]);\n            }\n          else\n            {\n              /*\n                Bottom-right triangle (pixel: 3, diagonal: 1-2).\n              */\n              delta.x=1.0-delta.x;\n              delta.y=1.0-delta.y;\n              gamma=MeshInterpolate(&delta,alpha[3],alpha[2],alpha[1]);\n              gamma=PerceptibleReciprocal(gamma);\n              *pixel=gamma*MeshInterpolate(&delta,pixels[3],pixels[2],\n                pixels[1]);\n            }\n        }\n      break;\n    }\n    case SplineInterpolatePixel:\n    {\n      double\n        cx[4],\n        cy[4];\n\n      p=GetCacheViewVirtualPixels(image_view,x_offset-1,y_offset-1,4,4,\n        exception);\n      if (p == (const Quantum *) NULL)\n        {\n          status=MagickFalse;\n          break;\n        }\n      if ((traits & BlendPixelTrait) == 0)\n        for (i=0; i < 16; i++)\n        {\n          alpha[i]=1.0;\n          pixels[i]=(double) p[i*GetPixelChannels(image)+channel];\n        }\n      else\n        for (i=0; i < 16; i++)\n        {\n          alpha[i]=QuantumScale*GetPixelAlpha(image,p+i*\n            GetPixelChannels(image));\n          pixels[i]=alpha[i]*p[i*GetPixelChannels(image)+channel];\n        }\n      SplineWeights((double) (x-x_offset),&cx);\n      SplineWeights((double) (y-y_offset),&cy);\n      gamma=(channel == AlphaPixelChannel ? (double) 1.0 :\n        PerceptibleReciprocal(cy[0]*(cx[0]*alpha[0]+cx[1]*alpha[1]+cx[2]*\n        alpha[2]+cx[3]*alpha[3])+cy[1]*(cx[0]*alpha[4]+cx[1]*alpha[5]+cx[2]*\n        alpha[6]+cx[3]*alpha[7])+cy[2]*(cx[0]*alpha[8]+cx[1]*alpha[9]+cx[2]*\n        alpha[10]+cx[3]*alpha[11])+cy[3]*(cx[0]*alpha[12]+cx[1]*alpha[13]+\n        cx[2]*alpha[14]+cx[3]*alpha[15])));\n      *pixel=gamma*(cy[0]*(cx[0]*pixels[0]+cx[1]*pixels[1]+cx[2]*pixels[2]+\n        cx[3]*pixels[3])+cy[1]*(cx[0]*pixels[4]+cx[1]*pixels[5]+cx[2]*\n        pixels[6]+cx[3]*pixels[7])+cy[2]*(cx[0]*pixels[8]+cx[1]*pixels[9]+\n        cx[2]*pixels[10]+cx[3]*pixels[11])+cy[3]*(cx[0]*pixels[12]+cx[1]*\n        pixels[13]+cx[2]*pixels[14]+cx[3]*pixels[15]));\n      break;\n    }\n  }\n  return(status);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146758,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "MagickExport MagickBooleanType InterpolatePixelChannel(\n  const Image *magick_restrict image,const CacheView_ *image_view,\n  const PixelChannel channel,const PixelInterpolateMethod method,\n  const double x,const double y,double *pixel,ExceptionInfo *exception)\n{\n  double\n    alpha[16],\n    gamma,\n    pixels[16];\n\n  MagickBooleanType\n    status;\n\n  PixelInterpolateMethod\n    interpolate;\n\n  PixelTrait\n    traits;\n\n  register const Quantum\n    *magick_restrict p;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    x_offset,\n    y_offset;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image_view != (CacheView *) NULL);\n  status=MagickTrue;\n  *pixel=0.0;\n  traits=GetPixelChannelTraits(image,channel);\n  x_offset=(ssize_t) floor(ConstrainPixelOffset(x));\n  y_offset=(ssize_t) floor(ConstrainPixelOffset(y));\n  interpolate=method;\n  if (interpolate == UndefinedInterpolatePixel)\n    interpolate=image->interpolate;\n  switch (interpolate)\n  {\n    case AverageInterpolatePixel:  /* nearest 4 neighbours */\n    case Average9InterpolatePixel:  /* nearest 9 neighbours */\n    case Average16InterpolatePixel:  /* nearest 16 neighbours */\n    {\n      ssize_t\n        count;\n\n      count=2;  /* size of the area to average - default nearest 4 */\n      if (interpolate == Average9InterpolatePixel)\n        {\n          count=3;\n          x_offset=(ssize_t) (floor(ConstrainPixelOffset(x)+0.5)-1);\n          y_offset=(ssize_t) (floor(ConstrainPixelOffset(y)+0.5)-1);\n        }\n      else\n        if (interpolate == Average16InterpolatePixel)\n          {\n            count=4;\n            x_offset--;\n            y_offset--;\n          }\n      p=GetCacheViewVirtualPixels(image_view,x_offset,y_offset,(size_t) count,\n        (size_t) count,exception);\n      if (p == (const Quantum *) NULL)\n        {\n          status=MagickFalse;\n          break;\n        }\n      count*=count;  /* Number of pixels to average */\n      if ((traits & BlendPixelTrait) == 0)\n        for (i=0; i < (ssize_t) count; i++)\n        {\n          alpha[i]=1.0;\n          pixels[i]=(double) p[i*GetPixelChannels(image)+channel];\n        }\n      else\n        for (i=0; i < (ssize_t) count; i++)\n        {\n          alpha[i]=QuantumScale*GetPixelAlpha(image,p+i*\n            GetPixelChannels(image));\n          pixels[i]=alpha[i]*p[i*GetPixelChannels(image)+channel];\n        }\n      for (i=0; i < (ssize_t) count; i++)\n      {\n        gamma=PerceptibleReciprocal(alpha[i])/count;\n        *pixel+=gamma*pixels[i];\n      }\n      break;\n    }\n    case BilinearInterpolatePixel:\n    default:\n    {\n      PointInfo\n        delta,\n        epsilon;\n\n      p=GetCacheViewVirtualPixels(image_view,x_offset,y_offset,2,2,exception);\n      if (p == (const Quantum *) NULL)\n        {\n          status=MagickFalse;\n          break;\n        }\n      if ((traits & BlendPixelTrait) == 0)\n        for (i=0; i < 4; i++)\n        {\n          alpha[i]=1.0;\n          pixels[i]=(double) p[i*GetPixelChannels(image)+channel];\n        }\n      else\n        for (i=0; i < 4; i++)\n        {\n          alpha[i]=QuantumScale*GetPixelAlpha(image,p+i*\n            GetPixelChannels(image));\n          pixels[i]=alpha[i]*p[i*GetPixelChannels(image)+channel];\n        }\n      delta.x=x-x_offset;\n      delta.y=y-y_offset;\n      epsilon.x=1.0-delta.x;\n      epsilon.y=1.0-delta.y;\n      gamma=((epsilon.y*(epsilon.x*alpha[0]+delta.x*alpha[1])+delta.y*\n        (epsilon.x*alpha[2]+delta.x*alpha[3])));\n      gamma=PerceptibleReciprocal(gamma);\n      *pixel=gamma*(epsilon.y*(epsilon.x*pixels[0]+delta.x*pixels[1])+delta.y*\n        (epsilon.x*pixels[2]+delta.x*pixels[3]));\n      break;\n    }\n    case BlendInterpolatePixel:\n    {\n      p=GetCacheViewVirtualPixels(image_view,x_offset,y_offset,2,2,exception);\n      if (p == (const Quantum *) NULL)\n        {\n          status=MagickFalse;\n          break;\n        }\n      if ((traits & BlendPixelTrait) == 0)\n        for (i=0; i < 4; i++)\n        {\n          alpha[i]=1.0;\n          pixels[i]=(MagickRealType) p[i*GetPixelChannels(image)+channel];\n        }\n      else\n        for (i=0; i < 4; i++)\n        {\n          alpha[i]=QuantumScale*GetPixelAlpha(image,p+i*\n            GetPixelChannels(image));\n          pixels[i]=alpha[i]*p[i*GetPixelChannels(image)+channel];\n        }\n      gamma=1.0;  /* number of pixels blended together (its variable) */\n      for (i=0; i <= 1L; i++) {\n        if ((y-y_offset) >= 0.75)\n          {\n            alpha[i]=alpha[i+2];  /* take right pixels */\n            pixels[i]=pixels[i+2];\n          }\n        else\n          if ((y-y_offset) > 0.25)\n            {\n              gamma=2.0;  /* blend both pixels in row */\n              alpha[i]+=alpha[i+2];  /* add up alpha weights */\n              pixels[i]+=pixels[i+2];\n            }\n      }\n      if ((x-x_offset) >= 0.75)\n        {\n          alpha[0]=alpha[1];  /* take bottom row blend */\n          pixels[0]=pixels[1];\n        }\n      else\n        if ((x-x_offset) > 0.25)\n          {\n            gamma*=2.0;  /* blend both rows */\n            alpha[0]+=alpha[1];  /* add up alpha weights */\n            pixels[0]+=pixels[1];\n          }\n      if (channel != AlphaPixelChannel)\n        gamma=PerceptibleReciprocal(alpha[0]);  /* (color) 1/alpha_weights */\n      else\n        gamma=PerceptibleReciprocal(gamma);  /* (alpha) 1/number_of_pixels */\n      *pixel=gamma*pixels[0];\n      break;\n    }\n    case CatromInterpolatePixel:\n    {\n      double\n        cx[4],\n        cy[4];\n\n      p=GetCacheViewVirtualPixels(image_view,x_offset-1,y_offset-1,4,4,\n        exception);\n      if (p == (const Quantum *) NULL)\n        {\n          status=MagickFalse;\n          break;\n        }\n      if ((traits & BlendPixelTrait) == 0)\n        for (i=0; i < 16; i++)\n        {\n          alpha[i]=1.0;\n          pixels[i]=(double) p[i*GetPixelChannels(image)+channel];\n        }\n      else\n        for (i=0; i < 16; i++)\n        {\n          alpha[i]=QuantumScale*GetPixelAlpha(image,p+i*\n            GetPixelChannels(image));\n          pixels[i]=alpha[i]*p[i*GetPixelChannels(image)+channel];\n        }\n      CatromWeights((double) (x-x_offset),&cx);\n      CatromWeights((double) (y-y_offset),&cy);\n      gamma=(channel == AlphaPixelChannel ? (double) 1.0 :\n        PerceptibleReciprocal(cy[0]*(cx[0]*alpha[0]+cx[1]*alpha[1]+cx[2]*\n        alpha[2]+cx[3]*alpha[3])+cy[1]*(cx[0]*alpha[4]+cx[1]*alpha[5]+cx[2]*\n        alpha[6]+cx[3]*alpha[7])+cy[2]*(cx[0]*alpha[8]+cx[1]*alpha[9]+cx[2]*\n        alpha[10]+cx[3]*alpha[11])+cy[3]*(cx[0]*alpha[12]+cx[1]*alpha[13]+\n        cx[2]*alpha[14]+cx[3]*alpha[15])));\n      *pixel=gamma*(cy[0]*(cx[0]*pixels[0]+cx[1]*pixels[1]+cx[2]*pixels[2]+\n        cx[3]*pixels[3])+cy[1]*(cx[0]*pixels[4]+cx[1]*pixels[5]+cx[2]*\n        pixels[6]+cx[3]*pixels[7])+cy[2]*(cx[0]*pixels[8]+cx[1]*pixels[9]+\n        cx[2]*pixels[10]+cx[3]*pixels[11])+cy[3]*(cx[0]*pixels[12]+cx[1]*\n        pixels[13]+cx[2]*pixels[14]+cx[3]*pixels[15]));\n      break;\n    }\n    case IntegerInterpolatePixel:\n    {\n      p=GetCacheViewVirtualPixels(image_view,x_offset,y_offset,1,1,exception);\n      if (p == (const Quantum *) NULL)\n        {\n          status=MagickFalse;\n          break;\n        }\n      *pixel=(double) GetPixelChannel(image,channel,p);\n      break;\n    }\n    case NearestInterpolatePixel:\n    {\n      x_offset=(ssize_t) floor(ConstrainPixelOffset(x)+0.5);\n      y_offset=(ssize_t) floor(ConstrainPixelOffset(y)+0.5);\n      p=GetCacheViewVirtualPixels(image_view,x_offset,y_offset,1,1,exception);\n      if (p == (const Quantum *) NULL)\n        {\n          status=MagickFalse;\n          break;\n        }\n      *pixel=(double) GetPixelChannel(image,channel,p);\n      break;\n    }\n    case MeshInterpolatePixel:\n    {\n      PointInfo\n        delta,\n        luminance;\n\n      p=GetCacheViewVirtualPixels(image_view,x_offset,y_offset,2,2,exception);\n      if (p == (const Quantum *) NULL)\n        {\n          status=MagickFalse;\n          break;\n        }\n      if ((traits & BlendPixelTrait) == 0)\n        for (i=0; i < 4; i++)\n        {\n          alpha[i]=1.0;\n          pixels[i]=(double) p[i*GetPixelChannels(image)+channel];\n        }\n      else\n        for (i=0; i < 4; i++)\n        {\n          alpha[i]=QuantumScale*GetPixelAlpha(image,p+i*\n            GetPixelChannels(image));\n          pixels[i]=alpha[i]*p[i*GetPixelChannels(image)+channel];\n        }\n      delta.x=x-x_offset;\n      delta.y=y-y_offset;\n      luminance.x=GetPixelLuma(image,p)-(double)\n        GetPixelLuma(image,p+3*GetPixelChannels(image));\n      luminance.y=GetPixelLuma(image,p+GetPixelChannels(image))-(double)\n        GetPixelLuma(image,p+2*GetPixelChannels(image));\n      if (fabs(luminance.x) < fabs(luminance.y))\n        {\n          /*\n            Diagonal 0-3 NW-SE.\n          */\n          if (delta.x <= delta.y)\n            {\n              /*\n                Bottom-left triangle (pixel: 2, diagonal: 0-3).\n              */\n              delta.y=1.0-delta.y;\n              gamma=MeshInterpolate(&delta,alpha[2],alpha[3],alpha[0]);\n              gamma=PerceptibleReciprocal(gamma);\n              *pixel=gamma*MeshInterpolate(&delta,pixels[2],pixels[3],\n                pixels[0]);\n            }\n          else\n            {\n              /*\n                Top-right triangle (pixel: 1, diagonal: 0-3).\n              */\n              delta.x=1.0-delta.x;\n              gamma=MeshInterpolate(&delta,alpha[1],alpha[0],alpha[3]);\n              gamma=PerceptibleReciprocal(gamma);\n              *pixel=gamma*MeshInterpolate(&delta,pixels[1],pixels[0],\n                pixels[3]);\n            }\n        }\n      else\n        {\n          /*\n            Diagonal 1-2 NE-SW.\n          */\n          if (delta.x <= (1.0-delta.y))\n            {\n              /*\n                Top-left triangle (pixel: 0, diagonal: 1-2).\n              */\n              gamma=MeshInterpolate(&delta,alpha[0],alpha[1],alpha[2]);\n              gamma=PerceptibleReciprocal(gamma);\n              *pixel=gamma*MeshInterpolate(&delta,pixels[0],pixels[1],\n                pixels[2]);\n            }\n          else\n            {\n              /*\n                Bottom-right triangle (pixel: 3, diagonal: 1-2).\n              */\n              delta.x=1.0-delta.x;\n              delta.y=1.0-delta.y;\n              gamma=MeshInterpolate(&delta,alpha[3],alpha[2],alpha[1]);\n              gamma=PerceptibleReciprocal(gamma);\n              *pixel=gamma*MeshInterpolate(&delta,pixels[3],pixels[2],\n                pixels[1]);\n            }\n        }\n      break;\n    }\n    case SplineInterpolatePixel:\n    {\n      double\n        cx[4],\n        cy[4];\n\n      p=GetCacheViewVirtualPixels(image_view,x_offset-1,y_offset-1,4,4,\n        exception);\n      if (p == (const Quantum *) NULL)\n        {\n          status=MagickFalse;\n          break;\n        }\n      if ((traits & BlendPixelTrait) == 0)\n        for (i=0; i < 16; i++)\n        {\n          alpha[i]=1.0;\n          pixels[i]=(double) p[i*GetPixelChannels(image)+channel];\n        }\n      else\n        for (i=0; i < 16; i++)\n        {\n          alpha[i]=QuantumScale*GetPixelAlpha(image,p+i*\n            GetPixelChannels(image));\n          pixels[i]=alpha[i]*p[i*GetPixelChannels(image)+channel];\n        }\n      SplineWeights((double) (x-x_offset),&cx);\n      SplineWeights((double) (y-y_offset),&cy);\n      gamma=(channel == AlphaPixelChannel ? (double) 1.0 :\n        PerceptibleReciprocal(cy[0]*(cx[0]*alpha[0]+cx[1]*alpha[1]+cx[2]*\n        alpha[2]+cx[3]*alpha[3])+cy[1]*(cx[0]*alpha[4]+cx[1]*alpha[5]+cx[2]*\n        alpha[6]+cx[3]*alpha[7])+cy[2]*(cx[0]*alpha[8]+cx[1]*alpha[9]+cx[2]*\n        alpha[10]+cx[3]*alpha[11])+cy[3]*(cx[0]*alpha[12]+cx[1]*alpha[13]+\n        cx[2]*alpha[14]+cx[3]*alpha[15])));\n      *pixel=gamma*(cy[0]*(cx[0]*pixels[0]+cx[1]*pixels[1]+cx[2]*pixels[2]+\n        cx[3]*pixels[3])+cy[1]*(cx[0]*pixels[4]+cx[1]*pixels[5]+cx[2]*\n        pixels[6]+cx[3]*pixels[7])+cy[2]*(cx[0]*pixels[8]+cx[1]*pixels[9]+\n        cx[2]*pixels[10]+cx[3]*pixels[11])+cy[3]*(cx[0]*pixels[12]+cx[1]*\n        pixels[13]+cx[2]*pixels[14]+cx[3]*pixels[15]));\n      break;\n    }\n  }\n  return(status);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146759,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static void get_sem_elements(struct sem_data *p)\n{\n\tsize_t i;\n\n\tif (!p || !p->sem_nsems || p->sem_perm.id < 0)\n\t\treturn;\n\n\tp->elements = xcalloc(p->sem_nsems, sizeof(struct sem_elem));\n\n\tfor (i = 0; i < p->sem_nsems; i++) {\n\t\tstruct sem_elem *e = &p->elements[i];\n\t\tunion semun arg = { .val = 0 };\n\n\t\te->semval = semctl(p->sem_perm.id, i, GETVAL, arg);\n\t\tif (e->semval < 0)\n\t\t\terr(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETVAL)\");\n\n\t\te->ncount = semctl(p->sem_perm.id, i, GETNCNT, arg);\n\t\tif (e->ncount < 0)\n\t\t\terr(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETNCNT)\");\n\n\t\te->zcount = semctl(p->sem_perm.id, i, GETZCNT, arg);\n\t\tif (e->zcount < 0)\n\t\t\terr(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETZCNT)\");\n\n\t\te->pid = semctl(p->sem_perm.id, i, GETPID, arg);\n\t\tif (e->pid < 0)\n\t\t\terr(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETPID)\");\n\t}\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146788,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static void get_sem_elements(struct sem_data *p)\n{\n\tsize_t i;\n\n\tif (!p || !p->sem_nsems || p->sem_nsems > SIZE_MAX || p->sem_perm.id < 0)\n\t\treturn;\n\n\tp->elements = xcalloc(p->sem_nsems, sizeof(struct sem_elem));\n\n\tfor (i = 0; i < p->sem_nsems; i++) {\n\t\tstruct sem_elem *e = &p->elements[i];\n\t\tunion semun arg = { .val = 0 };\n\n\t\te->semval = semctl(p->sem_perm.id, i, GETVAL, arg);\n\t\tif (e->semval < 0)\n\t\t\terr(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETVAL)\");\n\n\t\te->ncount = semctl(p->sem_perm.id, i, GETNCNT, arg);\n\t\tif (e->ncount < 0)\n\t\t\terr(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETNCNT)\");\n\n\t\te->zcount = semctl(p->sem_perm.id, i, GETZCNT, arg);\n\t\tif (e->zcount < 0)\n\t\t\terr(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETZCNT)\");\n\n\t\te->pid = semctl(p->sem_perm.id, i, GETPID, arg);\n\t\tif (e->pid < 0)\n\t\t\terr(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETPID)\");\n\t}\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146789,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "bool Inflator::DecodeBody()\r\n{\r\n\tbool blockEnd = false;\r\n\tswitch (m_blockType)\r\n\t{\r\n\tcase 0:\t// stored\r\n\t\tCRYPTOPP_ASSERT(m_reader.BitsBuffered() == 0);\r\n\t\twhile (!m_inQueue.IsEmpty() && !blockEnd)\r\n\t\t{\r\n\t\t\tsize_t size;\r\n\t\t\tconst byte *block = m_inQueue.Spy(size);\r\n\t\t\tsize = UnsignedMin(m_storedLen, size);\r\n\t\t\tCRYPTOPP_ASSERT(size <= 0xffff);\r\n\r\n\t\t\tOutputString(block, size);\r\n\t\t\tm_inQueue.Skip(size);\r\n\t\t\tm_storedLen = m_storedLen - (word16)size;\r\n\t\t\tif (m_storedLen == 0)\r\n\t\t\t\tblockEnd = true;\r\n\t\t}\r\n\t\tbreak;\r\n\tcase 1:\t// fixed codes\r\n\tcase 2:\t// dynamic codes\r\n\t\tstatic const unsigned int lengthStarts[] = {\r\n\t\t\t3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\r\n\t\t\t35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258};\r\n\t\tstatic const unsigned int lengthExtraBits[] = {\r\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,\r\n\t\t\t3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0};\r\n\t\tstatic const unsigned int distanceStarts[] = {\r\n\t\t\t1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\r\n\t\t\t257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\r\n\t\t\t8193, 12289, 16385, 24577};\r\n\t\tstatic const unsigned int distanceExtraBits[] = {\r\n\t\t\t0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,\r\n\t\t\t7, 7, 8, 8, 9, 9, 10, 10, 11, 11,\r\n\t\t\t12, 12, 13, 13};\r\n\r\n\t\tconst HuffmanDecoder& literalDecoder = GetLiteralDecoder();\r\n\t\tconst HuffmanDecoder& distanceDecoder = GetDistanceDecoder();\r\n\r\n\t\tswitch (m_nextDecode)\r\n\t\t{\r\n\t\tcase LITERAL:\r\n\t\t\twhile (true)\r\n\t\t\t{\r\n\t\t\t\tif (!literalDecoder.Decode(m_reader, m_literal))\r\n\t\t\t\t{\r\n\t\t\t\t\tm_nextDecode = LITERAL;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tif (m_literal < 256)\r\n\t\t\t\t\tOutputByte((byte)m_literal);\r\n\t\t\t\telse if (m_literal == 256)\t// end of block\r\n\t\t\t\t{\r\n\t\t\t\t\tblockEnd = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tif (m_literal > 285)\r\n\t\t\t\t\t\tthrow BadBlockErr();\r\n\t\t\t\t\tunsigned int bits;\r\n\t\tcase LENGTH_BITS:\r\n\t\t\t\t\tbits = lengthExtraBits[m_literal-257];\r\n\t\t\t\t\tif (!m_reader.FillBuffer(bits))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tm_nextDecode = LENGTH_BITS;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tm_literal = m_reader.GetBits(bits) + lengthStarts[m_literal-257];\r\n\t\tcase DISTANCE:\r\n\t\t\t\t\tif (!distanceDecoder.Decode(m_reader, m_distance))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tm_nextDecode = DISTANCE;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\tcase DISTANCE_BITS:\r\n\t\t\t\t\t// TODO: this surfaced during fuzzing. What do we do???\r\n\t\t\t\t\tCRYPTOPP_ASSERT(m_distance < COUNTOF(distanceExtraBits));\r\n\t\t\t\t\tbits = (m_distance >= COUNTOF(distanceExtraBits)) ? distanceExtraBits[29] : distanceExtraBits[m_distance];\r\n\t\t\t\t\tif (!m_reader.FillBuffer(bits))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tm_nextDecode = DISTANCE_BITS;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tm_distance = m_reader.GetBits(bits) + distanceStarts[m_distance];\r\n\t\t\t\t\tOutputPast(m_literal, m_distance);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\tCRYPTOPP_ASSERT(0);\r\n\t\t}\r\n\t}\r\n\tif (blockEnd)\r\n\t{\r\n\t\tif (m_eof)\r\n\t\t{\r\n\t\t\tFlushOutput();\r\n\t\t\tm_reader.SkipBits(m_reader.BitsBuffered()%8);\r\n\t\t\tif (m_reader.BitsBuffered())\r\n\t\t\t{\r\n\t\t\t\t// undo too much lookahead\r\n\t\t\t\tSecBlockWithHint<byte, 4> buffer(m_reader.BitsBuffered() / 8);\r\n\t\t\t\tfor (unsigned int i=0; i<buffer.size(); i++)\r\n\t\t\t\t\tbuffer[i] = (byte)m_reader.GetBits(8);\r\n\t\t\t\tm_inQueue.Unget(buffer, buffer.size());\r\n\t\t\t}\r\n\t\t\tm_state = POST_STREAM;\r\n\t\t}\r\n\t\telse\r\n\t\t\tm_state = WAIT_HEADER;\r\n\t}\r\n\treturn blockEnd;\r\n}\r",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146796,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "bool Inflator::DecodeBody()\r\n{\r\n\tbool blockEnd = false;\r\n\tswitch (m_blockType)\r\n\t{\r\n\tcase 0:\t// stored\r\n\t\tCRYPTOPP_ASSERT(m_reader.BitsBuffered() == 0);\r\n\t\twhile (!m_inQueue.IsEmpty() && !blockEnd)\r\n\t\t{\r\n\t\t\tsize_t size;\r\n\t\t\tconst byte *block = m_inQueue.Spy(size);\r\n\t\t\tsize = UnsignedMin(m_storedLen, size);\r\n\t\t\tCRYPTOPP_ASSERT(size <= 0xffff);\r\n\r\n\t\t\tOutputString(block, size);\r\n\t\t\tm_inQueue.Skip(size);\r\n\t\t\tm_storedLen = m_storedLen - (word16)size;\r\n\t\t\tif (m_storedLen == 0)\r\n\t\t\t\tblockEnd = true;\r\n\t\t}\r\n\t\tbreak;\r\n\tcase 1:\t// fixed codes\r\n\tcase 2:\t// dynamic codes\r\n\t\tstatic const unsigned int lengthStarts[] = {\r\n\t\t\t3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\r\n\t\t\t35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258};\r\n\t\tstatic const unsigned int lengthExtraBits[] = {\r\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,\r\n\t\t\t3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0};\r\n\t\tstatic const unsigned int distanceStarts[] = {\r\n\t\t\t1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\r\n\t\t\t257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\r\n\t\t\t8193, 12289, 16385, 24577};\r\n\t\tstatic const unsigned int distanceExtraBits[] = {\r\n\t\t\t0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,\r\n\t\t\t7, 7, 8, 8, 9, 9, 10, 10, 11, 11,\r\n\t\t\t12, 12, 13, 13};\r\n\r\n\t\tconst HuffmanDecoder& literalDecoder = GetLiteralDecoder();\r\n\t\tconst HuffmanDecoder& distanceDecoder = GetDistanceDecoder();\r\n\r\n\t\tswitch (m_nextDecode)\r\n\t\t{\r\n\t\tcase LITERAL:\r\n\t\t\twhile (true)\r\n\t\t\t{\r\n\t\t\t\tif (!literalDecoder.Decode(m_reader, m_literal))\r\n\t\t\t\t{\r\n\t\t\t\t\tm_nextDecode = LITERAL;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tif (m_literal < 256)\r\n\t\t\t\t\tOutputByte((byte)m_literal);\r\n\t\t\t\telse if (m_literal == 256)\t// end of block\r\n\t\t\t\t{\r\n\t\t\t\t\tblockEnd = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tif (m_literal > 285)\r\n\t\t\t\t\t\tthrow BadBlockErr();\r\n\t\t\t\t\tunsigned int bits;\r\n\t\tcase LENGTH_BITS:\r\n\t\t\t\t\tbits = lengthExtraBits[m_literal-257];\r\n\t\t\t\t\tif (!m_reader.FillBuffer(bits))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tm_nextDecode = LENGTH_BITS;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tm_literal = m_reader.GetBits(bits) + lengthStarts[m_literal-257];\r\n\t\tcase DISTANCE:\r\n\t\t\t\t\tif (!distanceDecoder.Decode(m_reader, m_distance))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tm_nextDecode = DISTANCE;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\tcase DISTANCE_BITS:\r\n\t\t\t\t\t// TODO: this surfaced during fuzzing. What do we do???\r\n\t\t\t\t\tCRYPTOPP_ASSERT(m_distance < COUNTOF(distanceExtraBits));\r\n\t\t\t\t\tif (m_distance >= COUNTOF(distanceExtraBits))\r\n\t\t\t\t\t\tthrow BadDistanceErr();\r\n\t\t\t\t\tbits = distanceExtraBits[m_distance];\r\n\t\t\t\t\tif (!m_reader.FillBuffer(bits))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tm_nextDecode = DISTANCE_BITS;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// TODO: this surfaced during fuzzing. What do we do???\r\n\t\t\t\t\tCRYPTOPP_ASSERT(m_distance < COUNTOF(distanceStarts));\r\n\t\t\t\t\tif (m_distance >= COUNTOF(distanceStarts))\r\n\t\t\t\t\t\tthrow BadDistanceErr();\r\n\t\t\t\t\tm_distance = m_reader.GetBits(bits) + distanceStarts[m_distance];\r\n\t\t\t\t\tOutputPast(m_literal, m_distance);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\tCRYPTOPP_ASSERT(0);\r\n\t\t}\r\n\t}\r\n\tif (blockEnd)\r\n\t{\r\n\t\tif (m_eof)\r\n\t\t{\r\n\t\t\tFlushOutput();\r\n\t\t\tm_reader.SkipBits(m_reader.BitsBuffered()%8);\r\n\t\t\tif (m_reader.BitsBuffered())\r\n\t\t\t{\r\n\t\t\t\t// undo too much lookahead\r\n\t\t\t\tSecBlockWithHint<byte, 4> buffer(m_reader.BitsBuffered() / 8);\r\n\t\t\t\tfor (unsigned int i=0; i<buffer.size(); i++)\r\n\t\t\t\t\tbuffer[i] = (byte)m_reader.GetBits(8);\r\n\t\t\t\tm_inQueue.Unget(buffer, buffer.size());\r\n\t\t\t}\r\n\t\t\tm_state = POST_STREAM;\r\n\t\t}\r\n\t\telse\r\n\t\t\tm_state = WAIT_HEADER;\r\n\t}\r\n\treturn blockEnd;\r\n}\r",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146797,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "CURLcode Curl_ntlm_core_mk_nt_hash(struct Curl_easy *data,\n                                   const char *password,\n                                   unsigned char *ntbuffer /* 21 bytes */)\n{\n  size_t len = strlen(password);\n  unsigned char *pw = len ? malloc(len * 2) : strdup(\"\");\n  CURLcode result;\n  if(!pw)\n    return CURLE_OUT_OF_MEMORY;\n\n  ascii_to_unicode_le(pw, password, len);\n\n  /*\n   * The NT hashed password needs to be created using the password in the\n   * network encoding not the host encoding.\n   */\n  result = Curl_convert_to_network(data, (char *)pw, len * 2);\n  if(result)\n    return result;\n\n  {\n    /* Create NT hashed password. */\n#ifdef USE_OPENSSL\n    MD4_CTX MD4pw;\n    MD4_Init(&MD4pw);\n    MD4_Update(&MD4pw, pw, 2 * len);\n    MD4_Final(ntbuffer, &MD4pw);\n#elif defined(USE_GNUTLS_NETTLE)\n    struct md4_ctx MD4pw;\n    md4_init(&MD4pw);\n    md4_update(&MD4pw, (unsigned int)(2 * len), pw);\n    md4_digest(&MD4pw, MD4_DIGEST_SIZE, ntbuffer);\n#elif defined(USE_GNUTLS)\n    gcry_md_hd_t MD4pw;\n    gcry_md_open(&MD4pw, GCRY_MD_MD4, 0);\n    gcry_md_write(MD4pw, pw, 2 * len);\n    memcpy(ntbuffer, gcry_md_read(MD4pw, 0), MD4_DIGEST_LENGTH);\n    gcry_md_close(MD4pw);\n#elif defined(USE_NSS)\n    Curl_md4it(ntbuffer, pw, 2 * len);\n#elif defined(USE_MBEDTLS)\n#if defined(MBEDTLS_MD4_C)\n    mbedtls_md4(pw, 2 * len, ntbuffer);\n#else\n    Curl_md4it(ntbuffer, pw, 2 * len);\n#endif\n#elif defined(USE_DARWINSSL)\n    (void)CC_MD4(pw, (CC_LONG)(2 * len), ntbuffer);\n#elif defined(USE_OS400CRYPTO)\n    Curl_md4it(ntbuffer, pw, 2 * len);\n#elif defined(USE_WIN32_CRYPTO)\n    HCRYPTPROV hprov;\n    if(CryptAcquireContext(&hprov, NULL, NULL, PROV_RSA_FULL,\n                           CRYPT_VERIFYCONTEXT)) {\n      HCRYPTHASH hhash;\n      if(CryptCreateHash(hprov, CALG_MD4, 0, 0, &hhash)) {\n        DWORD length = 16;\n        CryptHashData(hhash, pw, (unsigned int)len * 2, 0);\n        CryptGetHashParam(hhash, HP_HASHVAL, ntbuffer, &length, 0);\n        CryptDestroyHash(hhash);\n      }\n      CryptReleaseContext(hprov, 0);\n    }\n#endif\n\n    memset(ntbuffer + 16, 0, 21 - 16);\n  }\n\n  free(pw);\n\n  return CURLE_OK;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146806,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "CURLcode Curl_ntlm_core_mk_nt_hash(struct Curl_easy *data,\n                                   const char *password,\n                                   unsigned char *ntbuffer /* 21 bytes */)\n{\n  size_t len = strlen(password);\n  unsigned char *pw;\n  CURLcode result;\n  if(len > SIZE_T_MAX/2) /* avoid integer overflow */\n    return CURLE_OUT_OF_MEMORY;\n  pw = len ? malloc(len * 2) : strdup(\"\");\n  if(!pw)\n    return CURLE_OUT_OF_MEMORY;\n\n  ascii_to_unicode_le(pw, password, len);\n\n  /*\n   * The NT hashed password needs to be created using the password in the\n   * network encoding not the host encoding.\n   */\n  result = Curl_convert_to_network(data, (char *)pw, len * 2);\n  if(result)\n    return result;\n\n  {\n    /* Create NT hashed password. */\n#ifdef USE_OPENSSL\n    MD4_CTX MD4pw;\n    MD4_Init(&MD4pw);\n    MD4_Update(&MD4pw, pw, 2 * len);\n    MD4_Final(ntbuffer, &MD4pw);\n#elif defined(USE_GNUTLS_NETTLE)\n    struct md4_ctx MD4pw;\n    md4_init(&MD4pw);\n    md4_update(&MD4pw, (unsigned int)(2 * len), pw);\n    md4_digest(&MD4pw, MD4_DIGEST_SIZE, ntbuffer);\n#elif defined(USE_GNUTLS)\n    gcry_md_hd_t MD4pw;\n    gcry_md_open(&MD4pw, GCRY_MD_MD4, 0);\n    gcry_md_write(MD4pw, pw, 2 * len);\n    memcpy(ntbuffer, gcry_md_read(MD4pw, 0), MD4_DIGEST_LENGTH);\n    gcry_md_close(MD4pw);\n#elif defined(USE_NSS)\n    Curl_md4it(ntbuffer, pw, 2 * len);\n#elif defined(USE_MBEDTLS)\n#if defined(MBEDTLS_MD4_C)\n    mbedtls_md4(pw, 2 * len, ntbuffer);\n#else\n    Curl_md4it(ntbuffer, pw, 2 * len);\n#endif\n#elif defined(USE_DARWINSSL)\n    (void)CC_MD4(pw, (CC_LONG)(2 * len), ntbuffer);\n#elif defined(USE_OS400CRYPTO)\n    Curl_md4it(ntbuffer, pw, 2 * len);\n#elif defined(USE_WIN32_CRYPTO)\n    HCRYPTPROV hprov;\n    if(CryptAcquireContext(&hprov, NULL, NULL, PROV_RSA_FULL,\n                           CRYPT_VERIFYCONTEXT)) {\n      HCRYPTHASH hhash;\n      if(CryptCreateHash(hprov, CALG_MD4, 0, 0, &hhash)) {\n        DWORD length = 16;\n        CryptHashData(hhash, pw, (unsigned int)len * 2, 0);\n        CryptGetHashParam(hhash, HP_HASHVAL, ntbuffer, &length, 0);\n        CryptDestroyHash(hhash);\n      }\n      CryptReleaseContext(hprov, 0);\n    }\n#endif\n\n    memset(ntbuffer + 16, 0, 21 - 16);\n  }\n\n  free(pw);\n\n  return CURLE_OK;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146807,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static void ExportIndexQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const PixelPacket *magick_restrict p,\n  const IndexPacket *magick_restrict indexes,unsigned char *magick_restrict q,\n  ExceptionInfo *exception)\n{\n  ssize_t\n    x;\n\n  ssize_t\n    bit;\n\n  if (image->storage_class != PseudoClass)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"ColormappedImageRequired\",\"`%s'\",image->filename);\n      return;\n    }\n  switch (quantum_info->depth)\n  {\n    case 1:\n    {\n      unsigned char\n        pixel;\n\n      for (x=((ssize_t) number_pixels-7); x > 0; x-=8)\n      {\n        pixel=(unsigned char) *indexes++;\n        *q=((pixel & 0x01) << 7);\n        pixel=(unsigned char) *indexes++;\n        *q|=((pixel & 0x01) << 6);\n        pixel=(unsigned char) *indexes++;\n        *q|=((pixel & 0x01) << 5);\n        pixel=(unsigned char) *indexes++;\n        *q|=((pixel & 0x01) << 4);\n        pixel=(unsigned char) *indexes++;\n        *q|=((pixel & 0x01) << 3);\n        pixel=(unsigned char) *indexes++;\n        *q|=((pixel & 0x01) << 2);\n        pixel=(unsigned char) *indexes++;\n        *q|=((pixel & 0x01) << 1);\n        pixel=(unsigned char) *indexes++;\n        *q|=((pixel & 0x01) << 0);\n        q++;\n      }\n      if ((number_pixels % 8) != 0)\n        {\n          *q='\\0';\n          for (bit=7; bit >= (ssize_t) (8-(number_pixels % 8)); bit--)\n          {\n            pixel=(unsigned char) *indexes++;\n            *q|=((pixel & 0x01) << (unsigned char) bit);\n          }\n          q++;\n        }\n      break;\n    }\n    case 4:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) (number_pixels-1) ; x+=2)\n      {\n        pixel=(unsigned char) *indexes++;\n        *q=((pixel & 0xf) << 4);\n        pixel=(unsigned char) *indexes++;\n        *q|=((pixel & 0xf) << 0);\n        q++;\n      }\n      if ((number_pixels % 2) != 0)\n        {\n          pixel=(unsigned char) *indexes++;\n          *q=((pixel & 0xf) << 4);\n          q++;\n        }\n      break;\n    }\n    case 8:\n    {\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopCharPixel((unsigned char) GetPixelIndex(indexes+x),q);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 16:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopShortPixel(quantum_info->endian,SinglePrecisionToHalf(QuantumScale*\n              GetPixelIndex(indexes+x)),q);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopShortPixel(quantum_info->endian,(unsigned short) GetPixelIndex(indexes+x),q);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 32:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopFloatPixel(quantum_info,(float) GetPixelIndex(indexes+x),q);\n            p++;\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopLongPixel(quantum_info->endian,(unsigned int) GetPixelIndex(indexes+x),q);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopDoublePixel(quantum_info,(double) GetPixelIndex(indexes+x),\n              q);\n            p++;\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n    }\n    default:\n    {\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopQuantumPixel(quantum_info,\n          GetPixelIndex(indexes+x),q);\n        p++;\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n  }\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146832,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static void ExportIndexQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const PixelPacket *magick_restrict p,\n  const IndexPacket *magick_restrict indexes,unsigned char *magick_restrict q,\n  ExceptionInfo *exception)\n{\n  ssize_t\n    x;\n\n  ssize_t\n    bit;\n\n  if (image->storage_class != PseudoClass)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"ColormappedImageRequired\",\"`%s'\",image->filename);\n      return;\n    }\n  switch (quantum_info->depth)\n  {\n    case 1:\n    {\n      unsigned char\n        pixel;\n\n      for (x=((ssize_t) number_pixels-7); x > 0; x-=8)\n      {\n        pixel=(unsigned char) ((ssize_t) *indexes++);\n        *q=((pixel & 0x01) << 7);\n        pixel=(unsigned char) ((ssize_t) *indexes++);\n        *q|=((pixel & 0x01) << 6);\n        pixel=(unsigned char) ((ssize_t) *indexes++);\n        *q|=((pixel & 0x01) << 5);\n        pixel=(unsigned char) ((ssize_t) *indexes++);\n        *q|=((pixel & 0x01) << 4);\n        pixel=(unsigned char) ((ssize_t) *indexes++);\n        *q|=((pixel & 0x01) << 3);\n        pixel=(unsigned char) ((ssize_t) *indexes++);\n        *q|=((pixel & 0x01) << 2);\n        pixel=(unsigned char) ((ssize_t) *indexes++);\n        *q|=((pixel & 0x01) << 1);\n        pixel=(unsigned char) ((ssize_t) *indexes++);\n        *q|=((pixel & 0x01) << 0);\n        q++;\n      }\n      if ((number_pixels % 8) != 0)\n        {\n          *q='\\0';\n          for (bit=7; bit >= (ssize_t) (8-(number_pixels % 8)); bit--)\n          {\n            pixel=(unsigned char) ((ssize_t) *indexes++);\n            *q|=((pixel & 0x01) << (unsigned char) bit);\n          }\n          q++;\n        }\n      break;\n    }\n    case 4:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) (number_pixels-1) ; x+=2)\n      {\n        pixel=(unsigned char) ((ssize_t) *indexes++);\n        *q=((pixel & 0xf) << 4);\n        pixel=(unsigned char) ((ssize_t) *indexes++);\n        *q|=((pixel & 0xf) << 0);\n        q++;\n      }\n      if ((number_pixels % 2) != 0)\n        {\n          pixel=(unsigned char) ((ssize_t) *indexes++);\n          *q=((pixel & 0xf) << 4);\n          q++;\n        }\n      break;\n    }\n    case 8:\n    {\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopCharPixel((unsigned char) GetPixelIndex(indexes+x),q);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 16:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopShortPixel(quantum_info->endian,SinglePrecisionToHalf(QuantumScale*\n              GetPixelIndex(indexes+x)),q);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopShortPixel(quantum_info->endian,(unsigned short) GetPixelIndex(indexes+x),q);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 32:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopFloatPixel(quantum_info,(float) GetPixelIndex(indexes+x),q);\n            p++;\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopLongPixel(quantum_info->endian,(unsigned int) GetPixelIndex(indexes+x),q);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopDoublePixel(quantum_info,(double) GetPixelIndex(indexes+x),\n              q);\n            p++;\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n    }\n    default:\n    {\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopQuantumPixel(quantum_info,\n          GetPixelIndex(indexes+x),q);\n        p++;\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n  }\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146833,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "CWD_API int virtual_file_ex(cwd_state *state, const char *path, verify_path_func verify_path, int use_realpath TSRMLS_DC) /* {{{ */\n{\n\tint path_length = strlen(path);\n\tchar resolved_path[MAXPATHLEN];\n\tint start = 1;\n\tint ll = 0;\n\ttime_t t;\n\tint ret;\n\tint add_slash;\n\tvoid *tmp;\n\n\tif (path_length == 0 || path_length >= MAXPATHLEN-1) {\n#ifdef TSRM_WIN32\n# if _MSC_VER < 1300\n\t\terrno = EINVAL;\n# else\n\t\t_set_errno(EINVAL);\n# endif\n#else\n\t\terrno = EINVAL;\n#endif\n\t\treturn 1;\n\t}\n\n#if VIRTUAL_CWD_DEBUG\n\tfprintf(stderr,\"cwd = %s path = %s\\n\", state->cwd, path);\n#endif\n\n\t/* cwd_length can be 0 when getcwd() fails.\n\t * This can happen under solaris when a dir does not have read permissions\n\t * but *does* have execute permissions */\n\tif (!IS_ABSOLUTE_PATH(path, path_length)) {\n\t\tif (state->cwd_length == 0) {\n\t\t\t/* resolve relative path */\n\t\t\tstart = 0;\n\t\t\tmemcpy(resolved_path , path, path_length + 1);\n\t\t} else {\n\t\t\tint state_cwd_length = state->cwd_length;\n\n#ifdef TSRM_WIN32\n\t\t\tif (IS_SLASH(path[0])) {\n\t\t\t\tif (state->cwd[1] == ':') {\n\t\t\t\t\t/* Copy only the drive name */\n\t\t\t\t\tstate_cwd_length = 2;\n\t\t\t\t} else if (IS_UNC_PATH(state->cwd, state->cwd_length)) {\n\t\t\t\t\t/* Copy only the share name */\n\t\t\t\t\tstate_cwd_length = 2;\n\t\t\t\t\twhile (IS_SLASH(state->cwd[state_cwd_length])) {\n\t\t\t\t\t\tstate_cwd_length++;\n\t\t\t\t\t}\n\t\t\t\t\twhile (state->cwd[state_cwd_length] &&\n\t\t\t\t\t\t\t!IS_SLASH(state->cwd[state_cwd_length])) {\n\t\t\t\t\t\tstate_cwd_length++;\n\t\t\t\t\t}\n\t\t\t\t\twhile (IS_SLASH(state->cwd[state_cwd_length])) {\n\t\t\t\t\t\tstate_cwd_length++;\n\t\t\t\t\t}\n\t\t\t\t\twhile (state->cwd[state_cwd_length] &&\n\t\t\t\t\t\t\t!IS_SLASH(state->cwd[state_cwd_length])) {\n\t\t\t\t\t\tstate_cwd_length++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t\tif (path_length + state_cwd_length + 1 >= MAXPATHLEN-1) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tmemcpy(resolved_path, state->cwd, state_cwd_length);\n\t\t\tif (resolved_path[state_cwd_length-1] == DEFAULT_SLASH) {\n\t\t\t\tmemcpy(resolved_path + state_cwd_length, path, path_length + 1);\n\t\t\t\tpath_length += state_cwd_length;\n\t\t\t} else {\n\t\t\t\tresolved_path[state_cwd_length] = DEFAULT_SLASH;\n\t\t\t\tmemcpy(resolved_path + state_cwd_length + 1, path, path_length + 1);\n\t\t\t\tpath_length += state_cwd_length + 1;\n\t\t\t}\n\t\t}\n\t} else {\n#ifdef TSRM_WIN32\n\t\tif (path_length > 2 && path[1] == ':' && !IS_SLASH(path[2])) {\n\t\t\tresolved_path[0] = path[0];\n\t\t\tresolved_path[1] = ':';\n\t\t\tresolved_path[2] = DEFAULT_SLASH;\n\t\t\tmemcpy(resolved_path + 3, path + 2, path_length - 1);\n\t\t\tpath_length++;\n\t\t} else\n#endif\n\t\tmemcpy(resolved_path, path, path_length + 1);\n\t}\n\n#ifdef TSRM_WIN32\n\tif (memchr(resolved_path, '*', path_length) ||\n\t\tmemchr(resolved_path, '?', path_length)) {\n\t\treturn 1;\n\t}\n#endif\n\n#ifdef TSRM_WIN32\n\tif (IS_UNC_PATH(resolved_path, path_length)) {\n\t\t/* skip UNC name */\n\t\tresolved_path[0] = DEFAULT_SLASH;\n\t\tresolved_path[1] = DEFAULT_SLASH;\n\t\tstart = 2;\n\t\twhile (!IS_SLASH(resolved_path[start])) {\n\t\t\tif (resolved_path[start] == 0) {\n\t\t\t\tgoto verify;\n\t\t\t}\n\t\t\tresolved_path[start] = toupper(resolved_path[start]);\n\t\t\tstart++;\n\t\t}\n\t\tresolved_path[start++] = DEFAULT_SLASH;\n\t\twhile (!IS_SLASH(resolved_path[start])) {\n\t\t\tif (resolved_path[start] == 0) {\n\t\t\t\tgoto verify;\n\t\t\t}\n\t\t\tresolved_path[start] = toupper(resolved_path[start]);\n\t\t\tstart++;\n\t\t}\n\t\tresolved_path[start++] = DEFAULT_SLASH;\n\t} else if (IS_ABSOLUTE_PATH(resolved_path, path_length)) {\n\t\t/* skip DRIVE name */\n\t\tresolved_path[0] = toupper(resolved_path[0]);\n\t\tresolved_path[2] = DEFAULT_SLASH;\n\t\tstart = 3;\n\t}\n#elif defined(NETWARE)\n\tif (IS_ABSOLUTE_PATH(resolved_path, path_length)) {\n\t\t/* skip VOLUME name */\n\t\tstart = 0;\n\t\twhile (start != ':') {\n\t\t\tif (resolved_path[start] == 0) return -1;\n\t\t\tstart++;\n\t\t}\n\t\tstart++;\n\t\tif (!IS_SLASH(resolved_path[start])) return -1;\n\t\tresolved_path[start++] = DEFAULT_SLASH;\n\t}\n#endif\n\n\tadd_slash = (use_realpath != CWD_REALPATH) && path_length > 0 && IS_SLASH(resolved_path[path_length-1]);\n\tt = CWDG(realpath_cache_ttl) ? 0 : -1;\n\tpath_length = tsrm_realpath_r(resolved_path, start, path_length, &ll, &t, use_realpath, 0, NULL TSRMLS_CC);\n\n\tif (path_length < 0) {\n\t\terrno = ENOENT;\n\t\treturn 1;\n\t}\n\n\tif (!start && !path_length) {\n\t\tresolved_path[path_length++] = '.';\n\t}\n\tif (add_slash && path_length && !IS_SLASH(resolved_path[path_length-1])) {\n\t\tif (path_length >= MAXPATHLEN-1) {\n\t\t\treturn -1;\n\t\t}\n\t\tresolved_path[path_length++] = DEFAULT_SLASH;\n\t}\n\tresolved_path[path_length] = 0;\n\n#ifdef TSRM_WIN32\nverify:\n#endif\n\tif (verify_path) {\n\t\tcwd_state old_state;\n\n\t\tCWD_STATE_COPY(&old_state, state);\n\t\tstate->cwd_length = path_length;\n\n\t\ttmp = realloc(state->cwd, state->cwd_length+1);\n\t\tif (tmp == NULL) {\n#if VIRTUAL_CWD_DEBUG\n\t\t\tfprintf (stderr, \"Out of memory\\n\");\n#endif\n\t\t\treturn 1;\n\t\t}\n\t\tstate->cwd = (char *) tmp;\n\n\t\tmemcpy(state->cwd, resolved_path, state->cwd_length+1);\n\t\tif (verify_path(state)) {\n\t\t\tCWD_STATE_FREE(state);\n\t\t\t*state = old_state;\n\t\t\tret = 1;\n\t\t} else {\n\t\t\tCWD_STATE_FREE(&old_state);\n\t\t\tret = 0;\n\t\t}\n\t} else {\n\t\tstate->cwd_length = path_length;\n\t\ttmp = realloc(state->cwd, state->cwd_length+1);\n\t\tif (tmp == NULL) {\n#if VIRTUAL_CWD_DEBUG\n\t\t\tfprintf (stderr, \"Out of memory\\n\");\n#endif\n\t\t\treturn 1;\n\t\t}\n\t\tstate->cwd = (char *) tmp;\n\n\t\tmemcpy(state->cwd, resolved_path, state->cwd_length+1);\n\t\tret = 0;\n\t}\n\n#if VIRTUAL_CWD_DEBUG\n\tfprintf (stderr, \"virtual_file_ex() = %s\\n\",state->cwd);\n#endif\n\treturn (ret);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146836,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "CWD_API int virtual_file_ex(cwd_state *state, const char *path, verify_path_func verify_path, int use_realpath TSRMLS_DC) /* {{{ */\n{\n\tint path_length = strlen(path);\n\tchar resolved_path[MAXPATHLEN];\n\tint start = 1;\n\tint ll = 0;\n\ttime_t t;\n\tint ret;\n\tint add_slash;\n\tvoid *tmp;\n\n\tif (path_length <= 0 || path_length >= MAXPATHLEN-1) {\n#ifdef TSRM_WIN32\n# if _MSC_VER < 1300\n\t\terrno = EINVAL;\n# else\n\t\t_set_errno(EINVAL);\n# endif\n#else\n\t\terrno = EINVAL;\n#endif\n\t\treturn 1;\n\t}\n\n#if VIRTUAL_CWD_DEBUG\n\tfprintf(stderr,\"cwd = %s path = %s\\n\", state->cwd, path);\n#endif\n\n\t/* cwd_length can be 0 when getcwd() fails.\n\t * This can happen under solaris when a dir does not have read permissions\n\t * but *does* have execute permissions */\n\tif (!IS_ABSOLUTE_PATH(path, path_length)) {\n\t\tif (state->cwd_length == 0) {\n\t\t\t/* resolve relative path */\n\t\t\tstart = 0;\n\t\t\tmemcpy(resolved_path , path, path_length + 1);\n\t\t} else {\n\t\t\tint state_cwd_length = state->cwd_length;\n\n#ifdef TSRM_WIN32\n\t\t\tif (IS_SLASH(path[0])) {\n\t\t\t\tif (state->cwd[1] == ':') {\n\t\t\t\t\t/* Copy only the drive name */\n\t\t\t\t\tstate_cwd_length = 2;\n\t\t\t\t} else if (IS_UNC_PATH(state->cwd, state->cwd_length)) {\n\t\t\t\t\t/* Copy only the share name */\n\t\t\t\t\tstate_cwd_length = 2;\n\t\t\t\t\twhile (IS_SLASH(state->cwd[state_cwd_length])) {\n\t\t\t\t\t\tstate_cwd_length++;\n\t\t\t\t\t}\n\t\t\t\t\twhile (state->cwd[state_cwd_length] &&\n\t\t\t\t\t\t\t!IS_SLASH(state->cwd[state_cwd_length])) {\n\t\t\t\t\t\tstate_cwd_length++;\n\t\t\t\t\t}\n\t\t\t\t\twhile (IS_SLASH(state->cwd[state_cwd_length])) {\n\t\t\t\t\t\tstate_cwd_length++;\n\t\t\t\t\t}\n\t\t\t\t\twhile (state->cwd[state_cwd_length] &&\n\t\t\t\t\t\t\t!IS_SLASH(state->cwd[state_cwd_length])) {\n\t\t\t\t\t\tstate_cwd_length++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t\tif (path_length + state_cwd_length + 1 >= MAXPATHLEN-1) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tmemcpy(resolved_path, state->cwd, state_cwd_length);\n\t\t\tif (resolved_path[state_cwd_length-1] == DEFAULT_SLASH) {\n\t\t\t\tmemcpy(resolved_path + state_cwd_length, path, path_length + 1);\n\t\t\t\tpath_length += state_cwd_length;\n\t\t\t} else {\n\t\t\t\tresolved_path[state_cwd_length] = DEFAULT_SLASH;\n\t\t\t\tmemcpy(resolved_path + state_cwd_length + 1, path, path_length + 1);\n\t\t\t\tpath_length += state_cwd_length + 1;\n\t\t\t}\n\t\t}\n\t} else {\n#ifdef TSRM_WIN32\n\t\tif (path_length > 2 && path[1] == ':' && !IS_SLASH(path[2])) {\n\t\t\tresolved_path[0] = path[0];\n\t\t\tresolved_path[1] = ':';\n\t\t\tresolved_path[2] = DEFAULT_SLASH;\n\t\t\tmemcpy(resolved_path + 3, path + 2, path_length - 1);\n\t\t\tpath_length++;\n\t\t} else\n#endif\n\t\tmemcpy(resolved_path, path, path_length + 1);\n\t}\n\n#ifdef TSRM_WIN32\n\tif (memchr(resolved_path, '*', path_length) ||\n\t\tmemchr(resolved_path, '?', path_length)) {\n\t\treturn 1;\n\t}\n#endif\n\n#ifdef TSRM_WIN32\n\tif (IS_UNC_PATH(resolved_path, path_length)) {\n\t\t/* skip UNC name */\n\t\tresolved_path[0] = DEFAULT_SLASH;\n\t\tresolved_path[1] = DEFAULT_SLASH;\n\t\tstart = 2;\n\t\twhile (!IS_SLASH(resolved_path[start])) {\n\t\t\tif (resolved_path[start] == 0) {\n\t\t\t\tgoto verify;\n\t\t\t}\n\t\t\tresolved_path[start] = toupper(resolved_path[start]);\n\t\t\tstart++;\n\t\t}\n\t\tresolved_path[start++] = DEFAULT_SLASH;\n\t\twhile (!IS_SLASH(resolved_path[start])) {\n\t\t\tif (resolved_path[start] == 0) {\n\t\t\t\tgoto verify;\n\t\t\t}\n\t\t\tresolved_path[start] = toupper(resolved_path[start]);\n\t\t\tstart++;\n\t\t}\n\t\tresolved_path[start++] = DEFAULT_SLASH;\n\t} else if (IS_ABSOLUTE_PATH(resolved_path, path_length)) {\n\t\t/* skip DRIVE name */\n\t\tresolved_path[0] = toupper(resolved_path[0]);\n\t\tresolved_path[2] = DEFAULT_SLASH;\n\t\tstart = 3;\n\t}\n#elif defined(NETWARE)\n\tif (IS_ABSOLUTE_PATH(resolved_path, path_length)) {\n\t\t/* skip VOLUME name */\n\t\tstart = 0;\n\t\twhile (start != ':') {\n\t\t\tif (resolved_path[start] == 0) return -1;\n\t\t\tstart++;\n\t\t}\n\t\tstart++;\n\t\tif (!IS_SLASH(resolved_path[start])) return -1;\n\t\tresolved_path[start++] = DEFAULT_SLASH;\n\t}\n#endif\n\n\tadd_slash = (use_realpath != CWD_REALPATH) && path_length > 0 && IS_SLASH(resolved_path[path_length-1]);\n\tt = CWDG(realpath_cache_ttl) ? 0 : -1;\n\tpath_length = tsrm_realpath_r(resolved_path, start, path_length, &ll, &t, use_realpath, 0, NULL TSRMLS_CC);\n\n\tif (path_length < 0) {\n\t\terrno = ENOENT;\n\t\treturn 1;\n\t}\n\n\tif (!start && !path_length) {\n\t\tresolved_path[path_length++] = '.';\n\t}\n\tif (add_slash && path_length && !IS_SLASH(resolved_path[path_length-1])) {\n\t\tif (path_length >= MAXPATHLEN-1) {\n\t\t\treturn -1;\n\t\t}\n\t\tresolved_path[path_length++] = DEFAULT_SLASH;\n\t}\n\tresolved_path[path_length] = 0;\n\n#ifdef TSRM_WIN32\nverify:\n#endif\n\tif (verify_path) {\n\t\tcwd_state old_state;\n\n\t\tCWD_STATE_COPY(&old_state, state);\n\t\tstate->cwd_length = path_length;\n\n\t\ttmp = realloc(state->cwd, state->cwd_length+1);\n\t\tif (tmp == NULL) {\n#if VIRTUAL_CWD_DEBUG\n\t\t\tfprintf (stderr, \"Out of memory\\n\");\n#endif\n\t\t\treturn 1;\n\t\t}\n\t\tstate->cwd = (char *) tmp;\n\n\t\tmemcpy(state->cwd, resolved_path, state->cwd_length+1);\n\t\tif (verify_path(state)) {\n\t\t\tCWD_STATE_FREE(state);\n\t\t\t*state = old_state;\n\t\t\tret = 1;\n\t\t} else {\n\t\t\tCWD_STATE_FREE(&old_state);\n\t\t\tret = 0;\n\t\t}\n\t} else {\n\t\tstate->cwd_length = path_length;\n\t\ttmp = realloc(state->cwd, state->cwd_length+1);\n\t\tif (tmp == NULL) {\n#if VIRTUAL_CWD_DEBUG\n\t\t\tfprintf (stderr, \"Out of memory\\n\");\n#endif\n\t\t\treturn 1;\n\t\t}\n\t\tstate->cwd = (char *) tmp;\n\n\t\tmemcpy(state->cwd, resolved_path, state->cwd_length+1);\n\t\tret = 0;\n\t}\n\n#if VIRTUAL_CWD_DEBUG\n\tfprintf (stderr, \"virtual_file_ex() = %s\\n\",state->cwd);\n#endif\n\treturn (ret);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146837,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "ptp_unpack_OPL (PTPParams *params, unsigned char* data, MTPProperties **pprops, unsigned int len)\n{ \n\tuint32_t prop_count = dtoh32a(data);\n\tMTPProperties *props = NULL;\n\tunsigned int offset = 0, i;\n\n\t*pprops = NULL;\n\tif (prop_count == 0)\n\t\treturn 0;\n\tif (prop_count >= INT_MAX/sizeof(MTPProperties)) {\n\t\tptp_debug (params ,\"prop_count %d is too large\", prop_count);\n\t\treturn 0;\n\t}\n\tptp_debug (params ,\"Unpacking MTP OPL, size %d (prop_count %d)\", len, prop_count);\n\tdata += sizeof(uint32_t);\n\tlen -= sizeof(uint32_t);\n\tprops = malloc(prop_count * sizeof(MTPProperties));\n\tif (!props) return 0;\n\tfor (i = 0; i < prop_count; i++) {\n\t\tif (len <= 0) {\n\t\t\tptp_debug (params ,\"short MTP Object Property List at property %d (of %d)\", i, prop_count);\n\t\t\tptp_debug (params ,\"device probably needs DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST_ALL\");\n\t\t\tptp_debug (params ,\"or even DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST\", i);\n\t\t\tqsort (props, i, sizeof(MTPProperties),_compare_func);\n\t\t\t*pprops = props;\n\t\t\treturn i;\n\t\t}\n\t\tprops[i].ObjectHandle = dtoh32a(data);\n\t\tdata += sizeof(uint32_t);\n\t\tlen -= sizeof(uint32_t);\n\n\t\tprops[i].property = dtoh16a(data);\n\t\tdata += sizeof(uint16_t);\n\t\tlen -= sizeof(uint16_t);\n\n\t\tprops[i].datatype = dtoh16a(data);\n\t\tdata += sizeof(uint16_t);\n\t\tlen -= sizeof(uint16_t);\n\n\t\toffset = 0;\n\t\tif (!ptp_unpack_DPV(params, data, &offset, len, &props[i].propval, props[i].datatype)) {\n\t\t\tptp_debug (params ,\"unpacking DPV of property %d encountered insufficient buffer. attack?\", i);\n\t\t\tqsort (props, i, sizeof(MTPProperties),_compare_func);\n\t\t\t*pprops = props;\n\t\t\treturn i;\n\t\t}\n\t\tdata += offset;\n\t\tlen -= offset;\n\t}\n\tqsort (props, prop_count, sizeof(MTPProperties),_compare_func);\n\t*pprops = props;\n\treturn prop_count;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146864,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "ptp_unpack_OPL (PTPParams *params, unsigned char* data, MTPProperties **pprops, unsigned int len)\n{ \n\tuint32_t prop_count;\n\tMTPProperties *props = NULL;\n\tunsigned int offset = 0, i;\n\n\tif (len < sizeof(uint32_t)) {\n\t\tptp_debug (params ,\"must have at least 4 bytes data, not %d\", len);\n\t\treturn 0;\n\t}\n\n\tprop_count = dtoh32a(data);\n\t*pprops = NULL;\n\tif (prop_count == 0)\n\t\treturn 0;\n\n\tif (prop_count >= INT_MAX/sizeof(MTPProperties)) {\n\t\tptp_debug (params ,\"prop_count %d is too large\", prop_count);\n\t\treturn 0;\n\t}\n\tptp_debug (params ,\"Unpacking MTP OPL, size %d (prop_count %d)\", len, prop_count);\n\n\tdata += sizeof(uint32_t);\n\tlen -= sizeof(uint32_t);\n\tprops = malloc(prop_count * sizeof(MTPProperties));\n\tif (!props) return 0;\n\tfor (i = 0; i < prop_count; i++) {\n\t\tif (len <= (sizeof(uint32_t) + sizeof(uint16_t) + sizeof(uint16_t))) {\n\t\t\tptp_debug (params ,\"short MTP Object Property List at property %d (of %d)\", i, prop_count);\n\t\t\tptp_debug (params ,\"device probably needs DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST_ALL\");\n\t\t\tptp_debug (params ,\"or even DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST\", i);\n\t\t\tqsort (props, i, sizeof(MTPProperties),_compare_func);\n\t\t\t*pprops = props;\n\t\t\treturn i;\n\t\t}\n\n\n\t\tprops[i].ObjectHandle = dtoh32a(data);\n\t\tdata += sizeof(uint32_t);\n\t\tlen -= sizeof(uint32_t);\n\n\t\tprops[i].property = dtoh16a(data);\n\t\tdata += sizeof(uint16_t);\n\t\tlen -= sizeof(uint16_t);\n\n\t\tprops[i].datatype = dtoh16a(data);\n\t\tdata += sizeof(uint16_t);\n\t\tlen -= sizeof(uint16_t);\n\n\t\toffset = 0;\n\t\tif (!ptp_unpack_DPV(params, data, &offset, len, &props[i].propval, props[i].datatype)) {\n\t\t\tptp_debug (params ,\"unpacking DPV of property %d encountered insufficient buffer. attack?\", i);\n\t\t\tqsort (props, i, sizeof(MTPProperties),_compare_func);\n\t\t\t*pprops = props;\n\t\t\treturn i;\n\t\t}\n\t\tdata += offset;\n\t\tlen -= offset;\n\t}\n\tqsort (props, prop_count, sizeof(MTPProperties),_compare_func);\n\t*pprops = props;\n\treturn prop_count;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146865,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "Stream *Parser::makeStream(Object &&dict, Guchar *fileKey,\n\t\t\t   CryptAlgorithm encAlgorithm, int keyLength,\n\t\t\t   int objNum, int objGen, int recursion,\n                           GBool strict) {\n  BaseStream *baseStr;\n  Stream *str;\n  Goffset length;\n  Goffset pos, endPos;\n\n  // get stream start position\n  lexer->skipToNextLine();\n  if (!(str = lexer->getStream())) {\n    return nullptr;\n  }\n  pos = str->getPos();\n\n  // get length\n  Object obj = dict.dictLookup(\"Length\", recursion);\n  if (obj.isInt()) {\n    length = obj.getInt();\n  } else if (obj.isInt64()) {\n    length = obj.getInt64();\n  } else {\n    error(errSyntaxError, getPos(), \"Bad 'Length' attribute in stream\");\n    if (strict) return nullptr;\n    length = 0;\n  }\n\n  // check for length in damaged file\n  if (xref && xref->getStreamEnd(pos, &endPos)) {\n    length = endPos - pos;\n  }\n\n  // in badly damaged PDF files, we can run off the end of the input\n  // stream immediately after the \"stream\" token\n  if (!lexer->getStream()) {\n    return nullptr;\n  }\n  baseStr = lexer->getStream()->getBaseStream();\n\n  // skip over stream data\n  if (Lexer::LOOK_VALUE_NOT_CACHED != lexer->lookCharLastValueCached) {\n      // take into account the fact that we've cached one value\n      pos = pos - 1;\n      lexer->lookCharLastValueCached = Lexer::LOOK_VALUE_NOT_CACHED;\n  }\n  lexer->setPos(pos + length);\n\n  // refill token buffers and check for 'endstream'\n  shift();  // kill '>>'\n  shift(\"endstream\", objNum);  // kill 'stream'\n  if (buf1.isCmd(\"endstream\")) {\n    shift();\n  } else {\n    error(errSyntaxError, getPos(), \"Missing 'endstream' or incorrect stream length\");\n    if (strict) return nullptr;\n    if (xref && lexer->getStream()) {\n      // shift until we find the proper endstream or we change to another object or reach eof\n      length = lexer->getPos() - pos;\n      if (buf1.isCmd(\"endstream\")) {\n        dict.dictSet(\"Length\", Object(length));\n      }\n    } else {\n      // When building the xref we can't use it so use this\n      // kludge for broken PDF files: just add 5k to the length, and\n      // hope its enough\n      length += 5000;\n    }\n  }\n\n  // make base stream\n  str = baseStr->makeSubStream(pos, gTrue, length, std::move(dict));\n\n  // handle decryption\n  if (fileKey) {\n    str = new DecryptStream(str, fileKey, encAlgorithm, keyLength,\n\t\t\t    objNum, objGen);\n  }\n\n  // get filters\n  str = str->addFilters(str->getDict(), recursion);\n\n  return str;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146890,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "Stream *Parser::makeStream(Object &&dict, Guchar *fileKey,\n\t\t\t   CryptAlgorithm encAlgorithm, int keyLength,\n\t\t\t   int objNum, int objGen, int recursion,\n                           GBool strict) {\n  BaseStream *baseStr;\n  Stream *str;\n  Goffset length;\n  Goffset pos, endPos;\n\n  // get stream start position\n  lexer->skipToNextLine();\n  if (!(str = lexer->getStream())) {\n    return nullptr;\n  }\n  pos = str->getPos();\n\n  // get length\n  Object obj = dict.dictLookup(\"Length\", recursion);\n  if (obj.isInt()) {\n    length = obj.getInt();\n  } else if (obj.isInt64()) {\n    length = obj.getInt64();\n  } else {\n    error(errSyntaxError, getPos(), \"Bad 'Length' attribute in stream\");\n    if (strict) return nullptr;\n    length = 0;\n  }\n\n  // check for length in damaged file\n  if (xref && xref->getStreamEnd(pos, &endPos)) {\n    length = endPos - pos;\n  }\n\n  // in badly damaged PDF files, we can run off the end of the input\n  // stream immediately after the \"stream\" token\n  if (!lexer->getStream()) {\n    return nullptr;\n  }\n  baseStr = lexer->getStream()->getBaseStream();\n\n  // skip over stream data\n  if (Lexer::LOOK_VALUE_NOT_CACHED != lexer->lookCharLastValueCached) {\n      // take into account the fact that we've cached one value\n      pos = pos - 1;\n      lexer->lookCharLastValueCached = Lexer::LOOK_VALUE_NOT_CACHED;\n  }\n  if (unlikely(pos > LONG_LONG_MAX - length)) {\n      return nullptr;\n  }\n  lexer->setPos(pos + length);\n\n  // refill token buffers and check for 'endstream'\n  shift();  // kill '>>'\n  shift(\"endstream\", objNum);  // kill 'stream'\n  if (buf1.isCmd(\"endstream\")) {\n    shift();\n  } else {\n    error(errSyntaxError, getPos(), \"Missing 'endstream' or incorrect stream length\");\n    if (strict) return nullptr;\n    if (xref && lexer->getStream()) {\n      // shift until we find the proper endstream or we change to another object or reach eof\n      length = lexer->getPos() - pos;\n      if (buf1.isCmd(\"endstream\")) {\n        dict.dictSet(\"Length\", Object(length));\n      }\n    } else {\n      // When building the xref we can't use it so use this\n      // kludge for broken PDF files: just add 5k to the length, and\n      // hope its enough\n      length += 5000;\n    }\n  }\n\n  // make base stream\n  str = baseStr->makeSubStream(pos, gTrue, length, std::move(dict));\n\n  // handle decryption\n  if (fileKey) {\n    str = new DecryptStream(str, fileKey, encAlgorithm, keyLength,\n\t\t\t    objNum, objGen);\n  }\n\n  // get filters\n  str = str->addFilters(str->getDict(), recursion);\n\n  return str;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146891,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "_isBidi (const uint32_t *label, size_t llen)\n{\n  while (llen-- > 0) {\n    int bc = uc_bidi_category (*label++);\n\n    if (bc == UC_BIDI_R || bc == UC_BIDI_AL || bc == UC_BIDI_AN)\n      return 1;\n  }\n\n  return 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146916,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "_isBidi (const uint32_t *label, size_t llen)\n{\n  for (; (ssize_t) llen > 0; llen--) {\n    int bc = uc_bidi_category (*label++);\n\n    if (bc == UC_BIDI_R || bc == UC_BIDI_AL || bc == UC_BIDI_AN)\n      return 1;\n  }\n\n  return 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146917,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "int ImagingLibTiffDecode(Imaging im, ImagingCodecState state, UINT8* buffer, int bytes) {\n\tTIFFSTATE *clientstate = (TIFFSTATE *)state->context;\n\tchar *filename = \"tempfile.tif\";\n\tchar *mode = \"r\";\n\tTIFF *tiff;\n\ttsize_t size;\n\n\n\t/* buffer is the encoded file, bytes is the length of the encoded file */\n\t/* \tit all ends up in state->buffer, which is a uint8* from Imaging.h */\n\n    TRACE((\"in decoder: bytes %d\\n\", bytes));\n\tTRACE((\"State: count %d, state %d, x %d, y %d, ystep %d\\n\", state->count, state->state,\n\t\t   state->x, state->y, state->ystep));\n\tTRACE((\"State: xsize %d, ysize %d, xoff %d, yoff %d \\n\", state->xsize, state->ysize,\n\t\t   state->xoff, state->yoff));\n\tTRACE((\"State: bits %d, bytes %d \\n\", state->bits, state->bytes));\n\tTRACE((\"Buffer: %p: %c%c%c%c\\n\", buffer, (char)buffer[0], (char)buffer[1],(char)buffer[2], (char)buffer[3]));\n\tTRACE((\"State->Buffer: %c%c%c%c\\n\", (char)state->buffer[0], (char)state->buffer[1],(char)state->buffer[2], (char)state->buffer[3]));\n\tTRACE((\"Image: mode %s, type %d, bands: %d, xsize %d, ysize %d \\n\",\n\t\t   im->mode, im->type, im->bands, im->xsize, im->ysize));\n\tTRACE((\"Image: image8 %p, image32 %p, image %p, block %p \\n\",\n\t\t   im->image8, im->image32, im->image, im->block));\n\tTRACE((\"Image: pixelsize: %d, linesize %d \\n\",\n\t\t   im->pixelsize, im->linesize));\n\n\tdump_state(clientstate);\n\tclientstate->size = bytes;\n\tclientstate->eof = clientstate->size;\n\tclientstate->loc = 0;\n\tclientstate->data = (tdata_t)buffer;\n\tclientstate->flrealloc = 0;\n\tdump_state(clientstate);\n\n    TIFFSetWarningHandler(NULL);\n    TIFFSetWarningHandlerExt(NULL);\n\n\tif (clientstate->fp) {\n\t\tTRACE((\"Opening using fd: %d\\n\",clientstate->fp));\n\t\tlseek(clientstate->fp,0,SEEK_SET); // Sometimes, I get it set to the end.\n\t\ttiff = TIFFFdOpen(clientstate->fp, filename, mode);\n\t} else {\n\t\tTRACE((\"Opening from string\\n\"));\n\t\ttiff = TIFFClientOpen(filename, mode,\n\t\t\t\t\t\t\t  (thandle_t) clientstate,\n\t\t\t\t\t\t\t  _tiffReadProc, _tiffWriteProc,\n\t\t\t\t\t\t\t  _tiffSeekProc, _tiffCloseProc, _tiffSizeProc,\n\t\t\t\t\t\t\t  _tiffMapProc, _tiffUnmapProc);\n\t}\n\n\tif (!tiff){\n\t\tTRACE((\"Error, didn't get the tiff\\n\"));\n\t\tstate->errcode = IMAGING_CODEC_BROKEN;\n\t\treturn -1;\n\t}\n\n    if (clientstate->ifd){\n\t\tint rv;\n\t\tuint32 ifdoffset = clientstate->ifd;\n\t\tTRACE((\"reading tiff ifd %u\\n\", ifdoffset));\n\t\trv = TIFFSetSubDirectory(tiff, ifdoffset);\n\t\tif (!rv){\n\t\t\tTRACE((\"error in TIFFSetSubDirectory\"));\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tsize = TIFFScanlineSize(tiff);\n\tTRACE((\"ScanlineSize: %d \\n\", size));\n\tif (size > state->bytes) {\n\t\tTRACE((\"Error, scanline size > buffer size\\n\"));\n\t\tstate->errcode = IMAGING_CODEC_BROKEN;\n\t\tTIFFClose(tiff);\n\t\treturn -1;\n\t}\n\n\t// Have to do this row by row and shove stuff into the buffer that way,\n\t// with shuffle.  (or, just alloc a buffer myself, then figure out how to get it\n\t// back in. Can't use read encoded stripe.\n\n\t// This thing pretty much requires that I have the whole image in one shot.\n\t// Perhaps a stub version would work better???\n\twhile(state->y < state->ysize){\n\t\tif (TIFFReadScanline(tiff, (tdata_t)state->buffer, (uint32)state->y, 0) == -1) {\n\t\t\tTRACE((\"Decode Error, row %d\\n\", state->y));\n\t\t\tstate->errcode = IMAGING_CODEC_BROKEN;\n\t\t\tTIFFClose(tiff);\n\t\t\treturn -1;\n\t\t}\n\t\t/* TRACE((\"Decoded row %d \\n\", state->y)); */\n\t\tstate->shuffle((UINT8*) im->image[state->y + state->yoff] +\n\t\t\t\t\t       state->xoff * im->pixelsize,\n\t\t\t\t\t   state->buffer,\n\t\t\t\t\t   state->xsize);\n\n\t\tstate->y++;\n\t}\n\n\tTIFFClose(tiff);\n\tTRACE((\"Done Decoding, Returning \\n\"));\n\t// Returning -1 here to force ImageFile.load to break, rather than\n\t// even think about looping back around.\n\treturn -1;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146962,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "int ImagingLibTiffDecode(Imaging im, ImagingCodecState state, UINT8* buffer, int bytes) {\n\tTIFFSTATE *clientstate = (TIFFSTATE *)state->context;\n\tchar *filename = \"tempfile.tif\";\n\tchar *mode = \"r\";\n\tTIFF *tiff;\n\n\n\t/* buffer is the encoded file, bytes is the length of the encoded file */\n\t/* \tit all ends up in state->buffer, which is a uint8* from Imaging.h */\n\n    TRACE((\"in decoder: bytes %d\\n\", bytes));\n\tTRACE((\"State: count %d, state %d, x %d, y %d, ystep %d\\n\", state->count, state->state,\n\t\t   state->x, state->y, state->ystep));\n\tTRACE((\"State: xsize %d, ysize %d, xoff %d, yoff %d \\n\", state->xsize, state->ysize,\n\t\t   state->xoff, state->yoff));\n\tTRACE((\"State: bits %d, bytes %d \\n\", state->bits, state->bytes));\n\tTRACE((\"Buffer: %p: %c%c%c%c\\n\", buffer, (char)buffer[0], (char)buffer[1],(char)buffer[2], (char)buffer[3]));\n\tTRACE((\"State->Buffer: %c%c%c%c\\n\", (char)state->buffer[0], (char)state->buffer[1],(char)state->buffer[2], (char)state->buffer[3]));\n\tTRACE((\"Image: mode %s, type %d, bands: %d, xsize %d, ysize %d \\n\",\n\t\t   im->mode, im->type, im->bands, im->xsize, im->ysize));\n\tTRACE((\"Image: image8 %p, image32 %p, image %p, block %p \\n\",\n\t\t   im->image8, im->image32, im->image, im->block));\n\tTRACE((\"Image: pixelsize: %d, linesize %d \\n\",\n\t\t   im->pixelsize, im->linesize));\n\n\tdump_state(clientstate);\n\tclientstate->size = bytes;\n\tclientstate->eof = clientstate->size;\n\tclientstate->loc = 0;\n\tclientstate->data = (tdata_t)buffer;\n\tclientstate->flrealloc = 0;\n\tdump_state(clientstate);\n\n    TIFFSetWarningHandler(NULL);\n    TIFFSetWarningHandlerExt(NULL);\n\n\tif (clientstate->fp) {\n\t\tTRACE((\"Opening using fd: %d\\n\",clientstate->fp));\n\t\tlseek(clientstate->fp,0,SEEK_SET); // Sometimes, I get it set to the end.\n\t\ttiff = TIFFFdOpen(clientstate->fp, filename, mode);\n\t} else {\n\t\tTRACE((\"Opening from string\\n\"));\n\t\ttiff = TIFFClientOpen(filename, mode,\n\t\t\t\t\t\t\t  (thandle_t) clientstate,\n\t\t\t\t\t\t\t  _tiffReadProc, _tiffWriteProc,\n\t\t\t\t\t\t\t  _tiffSeekProc, _tiffCloseProc, _tiffSizeProc,\n\t\t\t\t\t\t\t  _tiffMapProc, _tiffUnmapProc);\n\t}\n\n\tif (!tiff){\n\t\tTRACE((\"Error, didn't get the tiff\\n\"));\n\t\tstate->errcode = IMAGING_CODEC_BROKEN;\n\t\treturn -1;\n\t}\n\n    if (clientstate->ifd){\n\t\tint rv;\n\t\tuint32 ifdoffset = clientstate->ifd;\n\t\tTRACE((\"reading tiff ifd %u\\n\", ifdoffset));\n\t\trv = TIFFSetSubDirectory(tiff, ifdoffset);\n\t\tif (!rv){\n\t\t\tTRACE((\"error in TIFFSetSubDirectory\"));\n\t\t\treturn -1;\n\t\t}\n\t}\n\n    TIFFSetField(tiff, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n\n\tif (TIFFIsTiled(tiff)) {\n\t    state->bytes = TIFFTileSize(tiff);\n\n\t    /* overflow check for malloc */\n        if (state->bytes > INT_MAX - 1) {\n            state->errcode = IMAGING_CODEC_MEMORY;\n            TIFFClose(tiff);\n            return -1;\n        }\n\n        /* realloc to fit whole tile */\n        UINT8 *new = realloc (state->buffer, state->bytes);\n        if (!new) {\n            state->errcode = IMAGING_CODEC_MEMORY;\n            TIFFClose(tiff);\n            return -1;\n        }\n\n        state->buffer = new;\n\n        TRACE((\"TIFFTileSize: %d\\n\", state->bytes));\n\n        uint32 x, y, tile_y;\n        uint32 tileWidth, tileLength;\n\n        TIFFGetField(tiff, TIFFTAG_TILEWIDTH, &tileWidth);\n        TIFFGetField(tiff, TIFFTAG_TILELENGTH, &tileLength);\n\n        for (y = state->yoff; y < state->ysize; y += tileLength) {\n            for (x = state->xoff; x < state->xsize; x += tileWidth) {\n                if (TIFFReadTile(tiff, (tdata_t)state->buffer, x, y, 0, 0) == -1) {\n                    TRACE((\"Decode Error, Tile at %dx%d\\n\", x, y));\n                    state->errcode = IMAGING_CODEC_BROKEN;\n                    TIFFClose(tiff);\n                    return -1;\n                }\n\n                TRACE((\"Read tile at %dx%d; \\n\\n\", x, y));\n\n                // iterate over each line in the tile and stuff data into image\n                for (tile_y = 0; tile_y < min(tileLength, state->ysize - y); tile_y++) {\n\n                    TRACE((\"Writing tile data at %dx%d using tilwWidth: %d; \\n\", tile_y + y, x, min(tileWidth, state->xsize - x)));\n\n                    // UINT8 * bbb = state->buffer + tile_y * (state->bytes / tileLength);\n                    // TRACE((\"chars: %x%x%x%x\\n\", ((UINT8 *)bbb)[0], ((UINT8 *)bbb)[1], ((UINT8 *)bbb)[2], ((UINT8 *)bbb)[3]));\n\n                    state->shuffle((UINT8*) im->image[tile_y + y] + x * im->pixelsize,\n\t\t\t\t\t   state->buffer + tile_y * (state->bytes / tileLength),\n\t\t\t\t\t   min(tileWidth, state->xsize - x)\n                    );\n                }\n            }\n        }\n    } else {\n        tsize_t size;\n\n        size = TIFFScanlineSize(tiff);\n        TRACE((\"ScanlineSize: %lu \\n\", size));\n        if (size > state->bytes) {\n            TRACE((\"Error, scanline size > buffer size\\n\"));\n            state->errcode = IMAGING_CODEC_BROKEN;\n            TIFFClose(tiff);\n            return -1;\n        }\n\n        // Have to do this row by row and shove stuff into the buffer that way,\n        // with shuffle.  (or, just alloc a buffer myself, then figure out how to get it\n        // back in. Can't use read encoded stripe.\n\n        // This thing pretty much requires that I have the whole image in one shot.\n        // Perhaps a stub version would work better???\n        while(state->y < state->ysize){\n            if (TIFFReadScanline(tiff, (tdata_t)state->buffer, (uint32)state->y, 0) == -1) {\n                TRACE((\"Decode Error, row %d\\n\", state->y));\n                state->errcode = IMAGING_CODEC_BROKEN;\n                TIFFClose(tiff);\n                return -1;\n            }\n            /* TRACE((\"Decoded row %d \\n\", state->y)); */\n            state->shuffle((UINT8*) im->image[state->y + state->yoff] +\n                               state->xoff * im->pixelsize,\n                           state->buffer,\n                           state->xsize);\n\n            state->y++;\n        }\n    }\n\n\tTIFFClose(tiff);\n\tTRACE((\"Done Decoding, Returning \\n\"));\n\t// Returning -1 here to force ImageFile.load to break, rather than\n\t// even think about looping back around.\n\treturn -1;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146963,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "init_om(\n    XOM om)\n{\n    XLCd lcd = om->core.lcd;\n    XOMGenericPart *gen = XOM_GENERIC(om);\n    OMData data;\n    XlcCharSet *charset_list;\n    FontData font_data;\n    char **required_list;\n    XOrientation *orientation;\n    char **value, buf[BUFSIZ], *bufptr;\n    int count = 0, num = 0, length = 0;\n\n    _XlcGetResource(lcd, \"XLC_FONTSET\", \"on_demand_loading\", &value, &count);\n    if (count > 0 && _XlcCompareISOLatin1(*value, \"True\") == 0)\n\tgen->on_demand_loading = True;\n\n    _XlcGetResource(lcd, \"XLC_FONTSET\", \"object_name\", &value, &count);\n    if (count > 0) {\n\tgen->object_name = strdup(*value);\n\tif (gen->object_name == NULL)\n\t    return False;\n    }\n\n    for (num = 0; ; num++) {\n\n        snprintf(buf, sizeof(buf), \"fs%d.charset.name\", num);\n        _XlcGetResource(lcd, \"XLC_FONTSET\", buf, &value, &count);\n\n        if( count < 1){\n            snprintf(buf, sizeof(buf), \"fs%d.charset\", num);\n            _XlcGetResource(lcd, \"XLC_FONTSET\", buf, &value, &count);\n            if (count < 1)\n                break;\n        }\n\n\tdata = add_data(om);\n\tif (data == NULL)\n\t    return False;\n\n\tcharset_list = Xmalloc(sizeof(XlcCharSet) * count);\n\tif (charset_list == NULL)\n\t    return False;\n\tdata->charset_list = charset_list;\n\tdata->charset_count = count;\n\n\twhile (count-- > 0){\n\t    *charset_list++ = _XlcGetCharSet(*value++);\n        }\n        snprintf(buf, sizeof(buf), \"fs%d.charset.udc_area\", num);\n        _XlcGetResource(lcd, \"XLC_FONTSET\", buf, &value, &count);\n        if( count > 0){\n            UDCArea udc;\n            int i,flag = 0;\n            udc = Xmalloc(count * sizeof(UDCAreaRec));\n\t    if (udc == NULL)\n\t        return False;\n            for(i=0;i<count;i++){\n                sscanf(value[i],\"\\\\x%lx,\\\\x%lx\", &(udc[i].start),\n\t\t       &(udc[i].end));\n            }\n            for(i=0;i<data->charset_count;i++){\n\t\tif(data->charset_list[i]->udc_area == NULL){\n\t\t    data->charset_list[i]->udc_area     = udc;\n\t\t    data->charset_list[i]->udc_area_num = count;\n\t\t    flag = 1;\n\t\t}\n            }\n\t    if(flag == 0){\n\t\tXfree(udc);\n\t    }\n        }\n\n        snprintf(buf, sizeof(buf), \"fs%d.font.primary\", num);\n        _XlcGetResource(lcd, \"XLC_FONTSET\", buf, &value, &count);\n        if (count < 1){\n            snprintf(buf, sizeof(buf), \"fs%d.font\", num);\n            _XlcGetResource(lcd, \"XLC_FONTSET\", buf, &value, &count);\n            if (count < 1)\n                return False;\n        }\n\n\tfont_data = read_EncodingInfo(count,value);\n\tif (font_data == NULL)\n\t    return False;\n\n\tdata->font_data = font_data;\n\tdata->font_data_count = count;\n\n        snprintf(buf, sizeof(buf), \"fs%d.font.substitute\", num);\n        _XlcGetResource(lcd, \"XLC_FONTSET\", buf, &value, &count);\n        if (count > 0){\n            font_data = read_EncodingInfo(count,value);\n            if (font_data == NULL)\n\t        return False;\n            data->substitute      = font_data;\n            data->substitute_num = count;\n        } else {\n            snprintf(buf, sizeof(buf), \"fs%d.font\", num);\n            _XlcGetResource(lcd, \"XLC_FONTSET\", buf, &value, &count);\n            if (count < 1) {\n                data->substitute      = NULL;\n                data->substitute_num = 0;\n\t    } else {\n                font_data = read_EncodingInfo(count,value);\n                data->substitute      = font_data;\n                data->substitute_num = count;\n\t    }\n\t}\n        read_vw(lcd,data,num);\n\tlength += strlen(data->font_data->name) + 1;\n    }\n\n    /* required charset list */\n    required_list = Xmalloc(sizeof(char *) * gen->data_num);\n    if (required_list == NULL)\n\treturn False;\n\n    om->core.required_charset.charset_list = required_list;\n    om->core.required_charset.charset_count = gen->data_num;\n\n    count = gen->data_num;\n    data = gen->data;\n\n    if (count > 0) {\n\tbufptr = Xmalloc(length);\n\tif (bufptr == NULL) {\n\t    Xfree(required_list);\n\t    return False;\n\t}\n\n\tfor ( ; count-- > 0; data++) {\n\t    strcpy(bufptr, data->font_data->name);\n\t    *required_list++ = bufptr;\n\t    bufptr += strlen(bufptr) + 1;\n\t}\n    }\n\n    /* orientation list */\n    orientation = Xmalloc(sizeof(XOrientation) * 2);\n    if (orientation == NULL)\n\treturn False;\n\n    orientation[0] = XOMOrientation_LTR_TTB;\n    orientation[1] = XOMOrientation_TTB_RTL;\n    om->core.orientation_list.orientation = orientation;\n    om->core.orientation_list.num_orientation = 2;\n\n    /* directional dependent drawing */\n    om->core.directional_dependent = False;\n\n    /* contextual drawing */\n    om->core.contextual_drawing = False;\n\n    /* context dependent */\n    om->core.context_dependent = False;\n\n    return True;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146998,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "init_om(\n    XOM om)\n{\n    XLCd lcd = om->core.lcd;\n    XOMGenericPart *gen = XOM_GENERIC(om);\n    OMData data;\n    XlcCharSet *charset_list;\n    FontData font_data;\n    char **required_list;\n    XOrientation *orientation;\n    char **value, buf[BUFSIZ], *bufptr;\n    int count = 0, num = 0;\n    unsigned int length = 0;\n\n    _XlcGetResource(lcd, \"XLC_FONTSET\", \"on_demand_loading\", &value, &count);\n    if (count > 0 && _XlcCompareISOLatin1(*value, \"True\") == 0)\n\tgen->on_demand_loading = True;\n\n    _XlcGetResource(lcd, \"XLC_FONTSET\", \"object_name\", &value, &count);\n    if (count > 0) {\n\tgen->object_name = strdup(*value);\n\tif (gen->object_name == NULL)\n\t    return False;\n    }\n\n    for (num = 0; ; num++) {\n\n        snprintf(buf, sizeof(buf), \"fs%d.charset.name\", num);\n        _XlcGetResource(lcd, \"XLC_FONTSET\", buf, &value, &count);\n\n        if( count < 1){\n            snprintf(buf, sizeof(buf), \"fs%d.charset\", num);\n            _XlcGetResource(lcd, \"XLC_FONTSET\", buf, &value, &count);\n            if (count < 1)\n                break;\n        }\n\n\tdata = add_data(om);\n\tif (data == NULL)\n\t    return False;\n\n\tcharset_list = Xmalloc(sizeof(XlcCharSet) * count);\n\tif (charset_list == NULL)\n\t    return False;\n\tdata->charset_list = charset_list;\n\tdata->charset_count = count;\n\n\twhile (count-- > 0){\n\t    *charset_list++ = _XlcGetCharSet(*value++);\n        }\n        snprintf(buf, sizeof(buf), \"fs%d.charset.udc_area\", num);\n        _XlcGetResource(lcd, \"XLC_FONTSET\", buf, &value, &count);\n        if( count > 0){\n            UDCArea udc;\n            int i,flag = 0;\n            udc = Xmalloc(count * sizeof(UDCAreaRec));\n\t    if (udc == NULL)\n\t        return False;\n            for(i=0;i<count;i++){\n                sscanf(value[i],\"\\\\x%lx,\\\\x%lx\", &(udc[i].start),\n\t\t       &(udc[i].end));\n            }\n            for(i=0;i<data->charset_count;i++){\n\t\tif(data->charset_list[i]->udc_area == NULL){\n\t\t    data->charset_list[i]->udc_area     = udc;\n\t\t    data->charset_list[i]->udc_area_num = count;\n\t\t    flag = 1;\n\t\t}\n            }\n\t    if(flag == 0){\n\t\tXfree(udc);\n\t    }\n        }\n\n        snprintf(buf, sizeof(buf), \"fs%d.font.primary\", num);\n        _XlcGetResource(lcd, \"XLC_FONTSET\", buf, &value, &count);\n        if (count < 1){\n            snprintf(buf, sizeof(buf), \"fs%d.font\", num);\n            _XlcGetResource(lcd, \"XLC_FONTSET\", buf, &value, &count);\n            if (count < 1)\n                return False;\n        }\n\n\tfont_data = read_EncodingInfo(count,value);\n\tif (font_data == NULL)\n\t    return False;\n\n\tdata->font_data = font_data;\n\tdata->font_data_count = count;\n\n        snprintf(buf, sizeof(buf), \"fs%d.font.substitute\", num);\n        _XlcGetResource(lcd, \"XLC_FONTSET\", buf, &value, &count);\n        if (count > 0){\n            font_data = read_EncodingInfo(count,value);\n            if (font_data == NULL)\n\t        return False;\n            data->substitute      = font_data;\n            data->substitute_num = count;\n        } else {\n            snprintf(buf, sizeof(buf), \"fs%d.font\", num);\n            _XlcGetResource(lcd, \"XLC_FONTSET\", buf, &value, &count);\n            if (count < 1) {\n                data->substitute      = NULL;\n                data->substitute_num = 0;\n\t    } else {\n                font_data = read_EncodingInfo(count,value);\n                data->substitute      = font_data;\n                data->substitute_num = count;\n\t    }\n\t}\n        read_vw(lcd,data,num);\n\tlength += strlen(data->font_data->name) + 1;\n    }\n\n    /* required charset list */\n    required_list = Xmalloc(sizeof(char *) * gen->data_num);\n    if (required_list == NULL)\n\treturn False;\n\n    om->core.required_charset.charset_list = required_list;\n    om->core.required_charset.charset_count = gen->data_num;\n\n    count = gen->data_num;\n    data = gen->data;\n\n    if (count > 0) {\n\tbufptr = Xmalloc(length);\n\tif (bufptr == NULL) {\n\t    Xfree(required_list);\n\t    return False;\n\t}\n\n\tfor ( ; count-- > 0; data++) {\n\t    strcpy(bufptr, data->font_data->name);\n\t    *required_list++ = bufptr;\n\t    bufptr += strlen(bufptr) + 1;\n\t}\n    }\n\n    /* orientation list */\n    orientation = Xmalloc(sizeof(XOrientation) * 2);\n    if (orientation == NULL)\n\treturn False;\n\n    orientation[0] = XOMOrientation_LTR_TTB;\n    orientation[1] = XOMOrientation_TTB_RTL;\n    om->core.orientation_list.orientation = orientation;\n    om->core.orientation_list.num_orientation = 2;\n\n    /* directional dependent drawing */\n    om->core.directional_dependent = False;\n\n    /* contextual drawing */\n    om->core.contextual_drawing = False;\n\n    /* context dependent */\n    om->core.context_dependent = False;\n\n    return True;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146999,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "XML_Parse(XML_Parser parser, const char *s, int len, int isFinal)\n{\n  switch (ps_parsing) {\n  case XML_SUSPENDED:\n    errorCode = XML_ERROR_SUSPENDED;\n    return XML_STATUS_ERROR;\n  case XML_FINISHED:\n    errorCode = XML_ERROR_FINISHED;\n    return XML_STATUS_ERROR;\n  case XML_INITIALIZED:\n    if (parentParser == NULL && !startParsing(parser)) {\n      errorCode = XML_ERROR_NO_MEMORY;\n      return XML_STATUS_ERROR;\n    }\n  default:\n    ps_parsing = XML_PARSING;\n  }\n\n  if (len == 0) {\n    ps_finalBuffer = (XML_Bool)isFinal;\n    if (!isFinal)\n      return XML_STATUS_OK;\n    positionPtr = bufferPtr;\n    parseEndPtr = bufferEnd;\n\n    /* If data are left over from last buffer, and we now know that these\n       data are the final chunk of input, then we have to check them again\n       to detect errors based on that fact.\n    */\n    errorCode = processor(parser, bufferPtr, parseEndPtr, &bufferPtr);\n\n    if (errorCode == XML_ERROR_NONE) {\n      switch (ps_parsing) {\n      case XML_SUSPENDED:\n        XmlUpdatePosition(encoding, positionPtr, bufferPtr, &position);\n        positionPtr = bufferPtr;\n        return XML_STATUS_SUSPENDED;\n      case XML_INITIALIZED:\n      case XML_PARSING:\n        ps_parsing = XML_FINISHED;\n        /* fall through */\n      default:\n        return XML_STATUS_OK;\n      }\n    }\n    eventEndPtr = eventPtr;\n    processor = errorProcessor;\n    return XML_STATUS_ERROR;\n  }\n#ifndef XML_CONTEXT_BYTES\n  else if (bufferPtr == bufferEnd) {\n    const char *end;\n    int nLeftOver;\n    enum XML_Status result;\n    parseEndByteIndex += len;\n    positionPtr = s;\n    ps_finalBuffer = (XML_Bool)isFinal;\n\n    errorCode = processor(parser, s, parseEndPtr = s + len, &end);\n\n    if (errorCode != XML_ERROR_NONE) {\n      eventEndPtr = eventPtr;\n      processor = errorProcessor;\n      return XML_STATUS_ERROR;\n    }\n    else {\n      switch (ps_parsing) {\n      case XML_SUSPENDED:\n        result = XML_STATUS_SUSPENDED;\n        break;\n      case XML_INITIALIZED:\n      case XML_PARSING:\n        if (isFinal) {\n          ps_parsing = XML_FINISHED;\n          return XML_STATUS_OK;\n        }\n      /* fall through */\n      default:\n        result = XML_STATUS_OK;\n      }\n    }\n\n    XmlUpdatePosition(encoding, positionPtr, end, &position);\n    nLeftOver = s + len - end;\n    if (nLeftOver) {\n      if (buffer == NULL || nLeftOver > bufferLim - buffer) {\n        /* FIXME avoid integer overflow */\n        char *temp;\n        temp = (buffer == NULL\n                ? (char *)MALLOC(len * 2)\n                : (char *)REALLOC(buffer, len * 2));\n        if (temp == NULL) {\n          errorCode = XML_ERROR_NO_MEMORY;\n          eventPtr = eventEndPtr = NULL;\n          processor = errorProcessor;\n          return XML_STATUS_ERROR;\n        }\n        buffer = temp;\n        bufferLim = buffer + len * 2;\n      }\n      memcpy(buffer, end, nLeftOver);\n    }\n    bufferPtr = buffer;\n    bufferEnd = buffer + nLeftOver;\n    positionPtr = bufferPtr;\n    parseEndPtr = bufferEnd;\n    eventPtr = bufferPtr;\n    eventEndPtr = bufferPtr;\n    return result;\n  }\n#endif  /* not defined XML_CONTEXT_BYTES */\n  else {\n    void *buff = XML_GetBuffer(parser, len);\n    if (buff == NULL)\n      return XML_STATUS_ERROR;\n    else {\n      memcpy(buff, s, len);\n      return XML_ParseBuffer(parser, len, isFinal);\n    }\n  }\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147000,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "XML_Parse(XML_Parser parser, const char *s, int len, int isFinal)\n{\n  switch (ps_parsing) {\n  case XML_SUSPENDED:\n    errorCode = XML_ERROR_SUSPENDED;\n    return XML_STATUS_ERROR;\n  case XML_FINISHED:\n    errorCode = XML_ERROR_FINISHED;\n    return XML_STATUS_ERROR;\n  case XML_INITIALIZED:\n    if (parentParser == NULL && !startParsing(parser)) {\n      errorCode = XML_ERROR_NO_MEMORY;\n      return XML_STATUS_ERROR;\n    }\n  default:\n    ps_parsing = XML_PARSING;\n  }\n\n  if (len == 0) {\n    ps_finalBuffer = (XML_Bool)isFinal;\n    if (!isFinal)\n      return XML_STATUS_OK;\n    positionPtr = bufferPtr;\n    parseEndPtr = bufferEnd;\n\n    /* If data are left over from last buffer, and we now know that these\n       data are the final chunk of input, then we have to check them again\n       to detect errors based on that fact.\n    */\n    errorCode = processor(parser, bufferPtr, parseEndPtr, &bufferPtr);\n\n    if (errorCode == XML_ERROR_NONE) {\n      switch (ps_parsing) {\n      case XML_SUSPENDED:\n        XmlUpdatePosition(encoding, positionPtr, bufferPtr, &position);\n        positionPtr = bufferPtr;\n        return XML_STATUS_SUSPENDED;\n      case XML_INITIALIZED:\n      case XML_PARSING:\n        ps_parsing = XML_FINISHED;\n        /* fall through */\n      default:\n        return XML_STATUS_OK;\n      }\n    }\n    eventEndPtr = eventPtr;\n    processor = errorProcessor;\n    return XML_STATUS_ERROR;\n  }\n#ifndef XML_CONTEXT_BYTES\n  else if (bufferPtr == bufferEnd) {\n    const char *end;\n    int nLeftOver;\n    enum XML_Status result;\n    parseEndByteIndex += len;\n    positionPtr = s;\n    ps_finalBuffer = (XML_Bool)isFinal;\n\n    errorCode = processor(parser, s, parseEndPtr = s + len, &end);\n\n    if (errorCode != XML_ERROR_NONE) {\n      eventEndPtr = eventPtr;\n      processor = errorProcessor;\n      return XML_STATUS_ERROR;\n    }\n    else {\n      switch (ps_parsing) {\n      case XML_SUSPENDED:\n        result = XML_STATUS_SUSPENDED;\n        break;\n      case XML_INITIALIZED:\n      case XML_PARSING:\n        if (isFinal) {\n          ps_parsing = XML_FINISHED;\n          return XML_STATUS_OK;\n        }\n      /* fall through */\n      default:\n        result = XML_STATUS_OK;\n      }\n    }\n\n    XmlUpdatePosition(encoding, positionPtr, end, &position);\n    nLeftOver = s + len - end;\n    if (nLeftOver) {\n      if (buffer == NULL || nLeftOver > bufferLim - buffer) {\n        /* avoid _signed_ integer overflow */\n        char *temp = NULL;\n        const int bytesToAllocate = (int)((unsigned)len * 2U);\n        if (bytesToAllocate > 0) {\n          temp = (buffer == NULL\n                ? (char *)MALLOC(bytesToAllocate)\n                : (char *)REALLOC(buffer, bytesToAllocate));\n        }\n        if (temp == NULL) {\n          errorCode = XML_ERROR_NO_MEMORY;\n          eventPtr = eventEndPtr = NULL;\n          processor = errorProcessor;\n          return XML_STATUS_ERROR;\n        }\n        buffer = temp;\n        bufferLim = buffer + bytesToAllocate;\n      }\n      memcpy(buffer, end, nLeftOver);\n    }\n    bufferPtr = buffer;\n    bufferEnd = buffer + nLeftOver;\n    positionPtr = bufferPtr;\n    parseEndPtr = bufferEnd;\n    eventPtr = bufferPtr;\n    eventEndPtr = bufferPtr;\n    return result;\n  }\n#endif  /* not defined XML_CONTEXT_BYTES */\n  else {\n    void *buff = XML_GetBuffer(parser, len);\n    if (buff == NULL)\n      return XML_STATUS_ERROR;\n    else {\n      memcpy(buff, s, len);\n      return XML_ParseBuffer(parser, len, isFinal);\n    }\n  }\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147001,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static int IntensityCompare(const void *x,const void *y)\n{\n  PixelPacket\n    *color_1,\n    *color_2;\n\n  ssize_t\n    intensity;\n\n  color_1=(PixelPacket *) x;\n  color_2=(PixelPacket *) y;\n  intensity=(ssize_t) PixelPacketIntensity(color_1)-\n    (ssize_t) PixelPacketIntensity(color_2);\n  return((int) intensity);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147020,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static int IntensityCompare(const void *x,const void *y)\n{\n  PixelPacket\n    *color_1,\n    *color_2;\n\n  ssize_t\n    intensity;\n\n  color_1=(PixelPacket *) x;\n  color_2=(PixelPacket *) y;\n  intensity=(ssize_t) ConstrainPixelIntensity(PixelPacketIntensity(color_1))-\n    (ssize_t) ConstrainPixelIntensity(PixelPacketIntensity(color_2));\n  return((int) intensity);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147021,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static long ioctl_memcpy(struct fsl_hv_ioctl_memcpy __user *p)\n{\n\tstruct fsl_hv_ioctl_memcpy param;\n\n\tstruct page **pages = NULL;\n\tvoid *sg_list_unaligned = NULL;\n\tstruct fh_sg_list *sg_list = NULL;\n\n\tunsigned int num_pages;\n\tunsigned long lb_offset; /* Offset within a page of the local buffer */\n\n\tunsigned int i;\n\tlong ret = 0;\n\tint num_pinned; /* return value from get_user_pages() */\n\tphys_addr_t remote_paddr; /* The next address in the remote buffer */\n\tuint32_t count; /* The number of bytes left to copy */\n\n\t/* Get the parameters from the user */\n\tif (copy_from_user(&param, p, sizeof(struct fsl_hv_ioctl_memcpy)))\n\t\treturn -EFAULT;\n\n\t/*\n\t * One partition must be local, the other must be remote.  In other\n\t * words, if source and target are both -1, or are both not -1, then\n\t * return an error.\n\t */\n\tif ((param.source == -1) == (param.target == -1))\n\t\treturn -EINVAL;\n\n\t/*\n\t * The array of pages returned by get_user_pages() covers only\n\t * page-aligned memory.  Since the user buffer is probably not\n\t * page-aligned, we need to handle the discrepancy.\n\t *\n\t * We calculate the offset within a page of the S/G list, and make\n\t * adjustments accordingly.  This will result in a page list that looks\n\t * like this:\n\t *\n\t *      ----    <-- first page starts before the buffer\n\t *     |    |\n\t *     |////|-> ----\n\t *     |////|  |    |\n\t *      ----   |    |\n\t *             |    |\n\t *      ----   |    |\n\t *     |////|  |    |\n\t *     |////|  |    |\n\t *     |////|  |    |\n\t *      ----   |    |\n\t *             |    |\n\t *      ----   |    |\n\t *     |////|  |    |\n\t *     |////|  |    |\n\t *     |////|  |    |\n\t *      ----   |    |\n\t *             |    |\n\t *      ----   |    |\n\t *     |////|  |    |\n\t *     |////|-> ----\n\t *     |    |   <-- last page ends after the buffer\n\t *      ----\n\t *\n\t * The distance between the start of the first page and the start of the\n\t * buffer is lb_offset.  The hashed (///) areas are the parts of the\n\t * page list that contain the actual buffer.\n\t *\n\t * The advantage of this approach is that the number of pages is\n\t * equal to the number of entries in the S/G list that we give to the\n\t * hypervisor.\n\t */\n\tlb_offset = param.local_vaddr & (PAGE_SIZE - 1);\n\tnum_pages = (param.count + lb_offset + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\n\t/* Allocate the buffers we need */\n\n\t/*\n\t * 'pages' is an array of struct page pointers that's initialized by\n\t * get_user_pages().\n\t */\n\tpages = kcalloc(num_pages, sizeof(struct page *), GFP_KERNEL);\n\tif (!pages) {\n\t\tpr_debug(\"fsl-hv: could not allocate page list\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/*\n\t * sg_list is the list of fh_sg_list objects that we pass to the\n\t * hypervisor.\n\t */\n\tsg_list_unaligned = kmalloc(num_pages * sizeof(struct fh_sg_list) +\n\t\tsizeof(struct fh_sg_list) - 1, GFP_KERNEL);\n\tif (!sg_list_unaligned) {\n\t\tpr_debug(\"fsl-hv: could not allocate S/G list\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto exit;\n\t}\n\tsg_list = PTR_ALIGN(sg_list_unaligned, sizeof(struct fh_sg_list));\n\n\t/* Get the physical addresses of the source buffer */\n\tnum_pinned = get_user_pages_fast(param.local_vaddr - lb_offset,\n\t\tnum_pages, param.source != -1 ? FOLL_WRITE : 0, pages);\n\n\tif (num_pinned != num_pages) {\n\t\t/* get_user_pages() failed */\n\t\tpr_debug(\"fsl-hv: could not lock source buffer\\n\");\n\t\tret = (num_pinned < 0) ? num_pinned : -EFAULT;\n\t\tgoto exit;\n\t}\n\n\t/*\n\t * Build the fh_sg_list[] array.  The first page is special\n\t * because it's misaligned.\n\t */\n\tif (param.source == -1) {\n\t\tsg_list[0].source = page_to_phys(pages[0]) + lb_offset;\n\t\tsg_list[0].target = param.remote_paddr;\n\t} else {\n\t\tsg_list[0].source = param.remote_paddr;\n\t\tsg_list[0].target = page_to_phys(pages[0]) + lb_offset;\n\t}\n\tsg_list[0].size = min_t(uint64_t, param.count, PAGE_SIZE - lb_offset);\n\n\tremote_paddr = param.remote_paddr + sg_list[0].size;\n\tcount = param.count - sg_list[0].size;\n\n\tfor (i = 1; i < num_pages; i++) {\n\t\tif (param.source == -1) {\n\t\t\t/* local to remote */\n\t\t\tsg_list[i].source = page_to_phys(pages[i]);\n\t\t\tsg_list[i].target = remote_paddr;\n\t\t} else {\n\t\t\t/* remote to local */\n\t\t\tsg_list[i].source = remote_paddr;\n\t\t\tsg_list[i].target = page_to_phys(pages[i]);\n\t\t}\n\t\tsg_list[i].size = min_t(uint64_t, count, PAGE_SIZE);\n\n\t\tremote_paddr += sg_list[i].size;\n\t\tcount -= sg_list[i].size;\n\t}\n\n\tparam.ret = fh_partition_memcpy(param.source, param.target,\n\t\tvirt_to_phys(sg_list), num_pages);\n\nexit:\n\tif (pages) {\n\t\tfor (i = 0; i < num_pages; i++)\n\t\t\tif (pages[i])\n\t\t\t\tput_page(pages[i]);\n\t}\n\n\tkfree(sg_list_unaligned);\n\tkfree(pages);\n\n\tif (!ret)\n\t\tif (copy_to_user(&p->ret, &param.ret, sizeof(__u32)))\n\t\t\treturn -EFAULT;\n\n\treturn ret;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147046,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static long ioctl_memcpy(struct fsl_hv_ioctl_memcpy __user *p)\n{\n\tstruct fsl_hv_ioctl_memcpy param;\n\n\tstruct page **pages = NULL;\n\tvoid *sg_list_unaligned = NULL;\n\tstruct fh_sg_list *sg_list = NULL;\n\n\tunsigned int num_pages;\n\tunsigned long lb_offset; /* Offset within a page of the local buffer */\n\n\tunsigned int i;\n\tlong ret = 0;\n\tint num_pinned; /* return value from get_user_pages() */\n\tphys_addr_t remote_paddr; /* The next address in the remote buffer */\n\tuint32_t count; /* The number of bytes left to copy */\n\n\t/* Get the parameters from the user */\n\tif (copy_from_user(&param, p, sizeof(struct fsl_hv_ioctl_memcpy)))\n\t\treturn -EFAULT;\n\n\t/*\n\t * One partition must be local, the other must be remote.  In other\n\t * words, if source and target are both -1, or are both not -1, then\n\t * return an error.\n\t */\n\tif ((param.source == -1) == (param.target == -1))\n\t\treturn -EINVAL;\n\n\t/*\n\t * The array of pages returned by get_user_pages() covers only\n\t * page-aligned memory.  Since the user buffer is probably not\n\t * page-aligned, we need to handle the discrepancy.\n\t *\n\t * We calculate the offset within a page of the S/G list, and make\n\t * adjustments accordingly.  This will result in a page list that looks\n\t * like this:\n\t *\n\t *      ----    <-- first page starts before the buffer\n\t *     |    |\n\t *     |////|-> ----\n\t *     |////|  |    |\n\t *      ----   |    |\n\t *             |    |\n\t *      ----   |    |\n\t *     |////|  |    |\n\t *     |////|  |    |\n\t *     |////|  |    |\n\t *      ----   |    |\n\t *             |    |\n\t *      ----   |    |\n\t *     |////|  |    |\n\t *     |////|  |    |\n\t *     |////|  |    |\n\t *      ----   |    |\n\t *             |    |\n\t *      ----   |    |\n\t *     |////|  |    |\n\t *     |////|-> ----\n\t *     |    |   <-- last page ends after the buffer\n\t *      ----\n\t *\n\t * The distance between the start of the first page and the start of the\n\t * buffer is lb_offset.  The hashed (///) areas are the parts of the\n\t * page list that contain the actual buffer.\n\t *\n\t * The advantage of this approach is that the number of pages is\n\t * equal to the number of entries in the S/G list that we give to the\n\t * hypervisor.\n\t */\n\tlb_offset = param.local_vaddr & (PAGE_SIZE - 1);\n\tif (param.count == 0 ||\n\t    param.count > U64_MAX - lb_offset - PAGE_SIZE + 1)\n\t\treturn -EINVAL;\n\tnum_pages = (param.count + lb_offset + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\n\t/* Allocate the buffers we need */\n\n\t/*\n\t * 'pages' is an array of struct page pointers that's initialized by\n\t * get_user_pages().\n\t */\n\tpages = kcalloc(num_pages, sizeof(struct page *), GFP_KERNEL);\n\tif (!pages) {\n\t\tpr_debug(\"fsl-hv: could not allocate page list\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/*\n\t * sg_list is the list of fh_sg_list objects that we pass to the\n\t * hypervisor.\n\t */\n\tsg_list_unaligned = kmalloc(num_pages * sizeof(struct fh_sg_list) +\n\t\tsizeof(struct fh_sg_list) - 1, GFP_KERNEL);\n\tif (!sg_list_unaligned) {\n\t\tpr_debug(\"fsl-hv: could not allocate S/G list\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto exit;\n\t}\n\tsg_list = PTR_ALIGN(sg_list_unaligned, sizeof(struct fh_sg_list));\n\n\t/* Get the physical addresses of the source buffer */\n\tnum_pinned = get_user_pages_fast(param.local_vaddr - lb_offset,\n\t\tnum_pages, param.source != -1 ? FOLL_WRITE : 0, pages);\n\n\tif (num_pinned != num_pages) {\n\t\t/* get_user_pages() failed */\n\t\tpr_debug(\"fsl-hv: could not lock source buffer\\n\");\n\t\tret = (num_pinned < 0) ? num_pinned : -EFAULT;\n\t\tgoto exit;\n\t}\n\n\t/*\n\t * Build the fh_sg_list[] array.  The first page is special\n\t * because it's misaligned.\n\t */\n\tif (param.source == -1) {\n\t\tsg_list[0].source = page_to_phys(pages[0]) + lb_offset;\n\t\tsg_list[0].target = param.remote_paddr;\n\t} else {\n\t\tsg_list[0].source = param.remote_paddr;\n\t\tsg_list[0].target = page_to_phys(pages[0]) + lb_offset;\n\t}\n\tsg_list[0].size = min_t(uint64_t, param.count, PAGE_SIZE - lb_offset);\n\n\tremote_paddr = param.remote_paddr + sg_list[0].size;\n\tcount = param.count - sg_list[0].size;\n\n\tfor (i = 1; i < num_pages; i++) {\n\t\tif (param.source == -1) {\n\t\t\t/* local to remote */\n\t\t\tsg_list[i].source = page_to_phys(pages[i]);\n\t\t\tsg_list[i].target = remote_paddr;\n\t\t} else {\n\t\t\t/* remote to local */\n\t\t\tsg_list[i].source = remote_paddr;\n\t\t\tsg_list[i].target = page_to_phys(pages[i]);\n\t\t}\n\t\tsg_list[i].size = min_t(uint64_t, count, PAGE_SIZE);\n\n\t\tremote_paddr += sg_list[i].size;\n\t\tcount -= sg_list[i].size;\n\t}\n\n\tparam.ret = fh_partition_memcpy(param.source, param.target,\n\t\tvirt_to_phys(sg_list), num_pages);\n\nexit:\n\tif (pages) {\n\t\tfor (i = 0; i < num_pages; i++)\n\t\t\tif (pages[i])\n\t\t\t\tput_page(pages[i]);\n\t}\n\n\tkfree(sg_list_unaligned);\n\tkfree(pages);\n\n\tif (!ret)\n\t\tif (copy_to_user(&p->ret, &param.ret, sizeof(__u32)))\n\t\t\treturn -EFAULT;\n\n\treturn ret;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147047,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "struct GuestFileRead *qmp_guest_file_read(int64_t handle, bool has_count,\n                                          int64_t count, Error **errp)\n{\n    GuestFileHandle *gfh = guest_file_handle_find(handle, errp);\n    GuestFileRead *read_data = NULL;\n    guchar *buf;\n    FILE *fh;\n    size_t read_count;\n\n    if (!gfh) {\n        return NULL;\n    }\n\n    if (!has_count) {\n        count = QGA_READ_COUNT_DEFAULT;\n    } else if (count < 0) {\n        error_setg(errp, \"value '%\" PRId64 \"' is invalid for argument count\",\n                   count);\n        return NULL;\n    }\n\n    fh = gfh->fh;\n\n    /* explicitly flush when switching from writing to reading */\n    if (gfh->state == RW_STATE_WRITING) {\n        int ret = fflush(fh);\n        if (ret == EOF) {\n            error_setg_errno(errp, errno, \"failed to flush file\");\n            return NULL;\n        }\n        gfh->state = RW_STATE_NEW;\n    }\n\n    buf = g_malloc0(count+1);\n    read_count = fread(buf, 1, count, fh);\n    if (ferror(fh)) {\n        error_setg_errno(errp, errno, \"failed to read file\");\n        slog(\"guest-file-read failed, handle: %\" PRId64, handle);\n    } else {\n        buf[read_count] = 0;\n        read_data = g_new0(GuestFileRead, 1);\n        read_data->count = read_count;\n        read_data->eof = feof(fh);\n        if (read_count) {\n            read_data->buf_b64 = g_base64_encode(buf, read_count);\n        }\n        gfh->state = RW_STATE_READING;\n    }\n    g_free(buf);\n    clearerr(fh);\n\n    return read_data;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147074,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "struct GuestFileRead *qmp_guest_file_read(int64_t handle, bool has_count,\n                                          int64_t count, Error **errp)\n{\n    GuestFileHandle *gfh = guest_file_handle_find(handle, errp);\n    GuestFileRead *read_data = NULL;\n    guchar *buf;\n    FILE *fh;\n    size_t read_count;\n\n    if (!gfh) {\n        return NULL;\n    }\n\n    if (!has_count) {\n        count = QGA_READ_COUNT_DEFAULT;\n    } else if (count < 0 || count >= UINT32_MAX) {\n        error_setg(errp, \"value '%\" PRId64 \"' is invalid for argument count\",\n                   count);\n        return NULL;\n    }\n\n    fh = gfh->fh;\n\n    /* explicitly flush when switching from writing to reading */\n    if (gfh->state == RW_STATE_WRITING) {\n        int ret = fflush(fh);\n        if (ret == EOF) {\n            error_setg_errno(errp, errno, \"failed to flush file\");\n            return NULL;\n        }\n        gfh->state = RW_STATE_NEW;\n    }\n\n    buf = g_malloc0(count+1);\n    read_count = fread(buf, 1, count, fh);\n    if (ferror(fh)) {\n        error_setg_errno(errp, errno, \"failed to read file\");\n        slog(\"guest-file-read failed, handle: %\" PRId64, handle);\n    } else {\n        buf[read_count] = 0;\n        read_data = g_new0(GuestFileRead, 1);\n        read_data->count = read_count;\n        read_data->eof = feof(fh);\n        if (read_count) {\n            read_data->buf_b64 = g_base64_encode(buf, read_count);\n        }\n        gfh->state = RW_STATE_READING;\n    }\n    g_free(buf);\n    clearerr(fh);\n\n    return read_data;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147075,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "GuestFileRead *qmp_guest_file_read(int64_t handle, bool has_count,\n                                   int64_t count, Error **errp)\n{\n    GuestFileRead *read_data = NULL;\n    guchar *buf;\n    HANDLE fh;\n    bool is_ok;\n    DWORD read_count;\n    GuestFileHandle *gfh = guest_file_handle_find(handle, errp);\n\n    if (!gfh) {\n        return NULL;\n    }\n    if (!has_count) {\n        count = QGA_READ_COUNT_DEFAULT;\n    } else if (count < 0) {\n        error_setg(errp, \"value '%\" PRId64\n                   \"' is invalid for argument count\", count);\n        return NULL;\n    }\n\n    fh = gfh->fh;\n    buf = g_malloc0(count+1);\n    is_ok = ReadFile(fh, buf, count, &read_count, NULL);\n    if (!is_ok) {\n        error_setg_win32(errp, GetLastError(), \"failed to read file\");\n        slog(\"guest-file-read failed, handle %\" PRId64, handle);\n    } else {\n        buf[read_count] = 0;\n        read_data = g_new0(GuestFileRead, 1);\n        read_data->count = (size_t)read_count;\n        read_data->eof = read_count == 0;\n\n        if (read_count != 0) {\n            read_data->buf_b64 = g_base64_encode(buf, read_count);\n        }\n    }\n    g_free(buf);\n\n    return read_data;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147076,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "GuestFileRead *qmp_guest_file_read(int64_t handle, bool has_count,\n                                   int64_t count, Error **errp)\n{\n    GuestFileRead *read_data = NULL;\n    guchar *buf;\n    HANDLE fh;\n    bool is_ok;\n    DWORD read_count;\n    GuestFileHandle *gfh = guest_file_handle_find(handle, errp);\n\n    if (!gfh) {\n        return NULL;\n    }\n    if (!has_count) {\n        count = QGA_READ_COUNT_DEFAULT;\n    } else if (count < 0 || count >= UINT32_MAX) {\n        error_setg(errp, \"value '%\" PRId64\n                   \"' is invalid for argument count\", count);\n        return NULL;\n    }\n\n    fh = gfh->fh;\n    buf = g_malloc0(count+1);\n    is_ok = ReadFile(fh, buf, count, &read_count, NULL);\n    if (!is_ok) {\n        error_setg_win32(errp, GetLastError(), \"failed to read file\");\n        slog(\"guest-file-read failed, handle %\" PRId64, handle);\n    } else {\n        buf[read_count] = 0;\n        read_data = g_new0(GuestFileRead, 1);\n        read_data->count = (size_t)read_count;\n        read_data->eof = read_count == 0;\n\n        if (read_count != 0) {\n            read_data->buf_b64 = g_base64_encode(buf, read_count);\n        }\n    }\n    g_free(buf);\n\n    return read_data;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147077,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "regional_create_custom(size_t size)\n{\n\tstruct regional* r = (struct regional*)malloc(size);\n\tlog_assert(sizeof(struct regional) <= size);\n\tif(!r) return NULL;\n\tr->first_size = size;\n\tregional_init(r);\n\treturn r;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147082,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "regional_create_custom(size_t size)\n{\n\tstruct regional* r = (struct regional*)malloc(size);\n\tsize = ALIGN_UP(size, ALIGNMENT);\n\tlog_assert(sizeof(struct regional) <= size);\n\tif(!r) return NULL;\n\tr->first_size = size;\n\tregional_init(r);\n\treturn r;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147083,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "bytesPerDeepLineTable (const Header &header,\n                       int minY, int maxY,\n                       const char* base,\n                       int xStride,\n                       int yStride,\n                       vector<size_t> &bytesPerLine)\n{\n    const Box2i &dataWindow = header.dataWindow();\n    const ChannelList &channels = header.channels();\n\n    for (ChannelList::ConstIterator c = channels.begin();\n         c != channels.end();\n         ++c)\n    {\n        const int ySampling = abs(c.channel().ySampling);\n        const int xSampling = abs(c.channel().xSampling);\n        const int pixelSize = pixelTypeSize (c.channel().type);\n\n        // Here we transform from the domain over all pixels into the domain\n        // of actual samples.  We want to sample points in [minY, maxY] where\n        // (y % ySampling) == 0.  However, doing this by rejecting samples\n        // requires O(height*width) modulo computations, which were a\n        // significant bottleneck in the previous implementation of this\n        // function.  For the low, low price of 4 divisions per channel, we\n        // can tighten the y & x ranges to the least and greatest roots of the\n        // sampling function and then stride by the sampling rate.\n        const int sampleMinY = roundToNextMultiple(minY, ySampling);\n        const int sampleMaxY = roundToPrevMultiple(maxY, ySampling);\n        const int sampleMinX = roundToNextMultiple(dataWindow.min.x, xSampling);\n        const int sampleMaxX = roundToPrevMultiple(dataWindow.max.x, xSampling);\n\n        for (int y = sampleMinY; y <= sampleMaxY; y+=ySampling)\n        {\n            int nBytes = 0;\n            for (int x = sampleMinX; x <= sampleMaxX; x += xSampling)\n            {\n                nBytes += pixelSize *\n                          sampleCount(base, xStride, yStride, x, y);\n            }\n            bytesPerLine[y - dataWindow.min.y] += nBytes;\n        }\n    }\n\n    size_t maxBytesPerLine = 0;\n\n    for (int y = minY; y <= maxY; ++y)\n        if (maxBytesPerLine < bytesPerLine[y - dataWindow.min.y])\n            maxBytesPerLine = bytesPerLine[y - dataWindow.min.y];\n\n    return maxBytesPerLine;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147144,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "bytesPerDeepLineTable (const Header &header,\n                       int minY, int maxY,\n                       const char* base,\n                       int xStride,\n                       int yStride,\n                       vector<size_t> &bytesPerLine)\n{\n    const Box2i &dataWindow = header.dataWindow();\n    const ChannelList &channels = header.channels();\n\n    for (ChannelList::ConstIterator c = channels.begin();\n         c != channels.end();\n         ++c)\n    {\n        const int ySampling = abs(c.channel().ySampling);\n        const int xSampling = abs(c.channel().xSampling);\n        const uint64_t pixelSize = pixelTypeSize (c.channel().type);\n\n        // Here we transform from the domain over all pixels into the domain\n        // of actual samples.  We want to sample points in [minY, maxY] where\n        // (y % ySampling) == 0.  However, doing this by rejecting samples\n        // requires O(height*width) modulo computations, which were a\n        // significant bottleneck in the previous implementation of this\n        // function.  For the low, low price of 4 divisions per channel, we\n        // can tighten the y & x ranges to the least and greatest roots of the\n        // sampling function and then stride by the sampling rate.\n        const int sampleMinY = roundToNextMultiple(minY, ySampling);\n        const int sampleMaxY = roundToPrevMultiple(maxY, ySampling);\n        const int sampleMinX = roundToNextMultiple(dataWindow.min.x, xSampling);\n        const int sampleMaxX = roundToPrevMultiple(dataWindow.max.x, xSampling);\n\n        for (int y = sampleMinY; y <= sampleMaxY; y+=ySampling)\n        {\n            uint64_t nBytes = 0;\n            for (int x = sampleMinX; x <= sampleMaxX; x += xSampling)\n            {\n                nBytes += pixelSize *\n                          static_cast<uint64_t>(sampleCount(base, xStride, yStride, x, y));\n            }\n\n            //\n            // architectures where size_t is smaller than 64 bits may overflow\n            // (scanlines with more than 2^32 bytes are not currently supported so this should not occur with valid files)\n            //\n            if( static_cast<uint64_t>(bytesPerLine[y - dataWindow.min.y]) + nBytes > SIZE_MAX)\n            {\n                throw IEX_NAMESPACE::IoExc(\"Scanline size too large\");\n            }\n\n            bytesPerLine[y - dataWindow.min.y] += nBytes;\n        }\n    }\n\n    size_t maxBytesPerLine = 0;\n\n    for (int y = minY; y <= maxY; ++y)\n    {\n        if (maxBytesPerLine < bytesPerLine[y - dataWindow.min.y])\n        {\n            maxBytesPerLine = bytesPerLine[y - dataWindow.min.y];\n        }\n    }\n\n    return maxBytesPerLine;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147145,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "hufDecode\n    (const Int64 * \thcode,\t// i : encoding table\n     const HufDec * \thdecod,\t// i : decoding table\n     const char* \tin,\t// i : compressed input buffer\n     int\t\tni,\t// i : input size (in bits)\n     int\t\trlc,\t// i : run-length code\n     int\t\tno,\t// i : expected output size (in bytes)\n     unsigned short*\tout)\t//  o: uncompressed output buffer\n{\n    Int64 c = 0;\n    int lc = 0;\n    unsigned short * outb = out;\n    unsigned short * oe = out + no;\n    const char * ie = in + (ni + 7) / 8; // input byte size\n\n    //\n    // Loop on input bytes\n    //\n\n    while (in < ie)\n    {\n\tgetChar (c, lc, in);\n\n\t//\n\t// Access decoding table\n\t//\n\n\twhile (lc >= HUF_DECBITS)\n\t{\n\t    const HufDec pl = hdecod[(c >> (lc-HUF_DECBITS)) & HUF_DECMASK];\n\n\t    if (pl.len)\n\t    {\n\t\t//\n\t\t// Get short code\n\t\t//\n\n\t\tlc -= pl.len;\n\t\tgetCode (pl.lit, rlc, c, lc, in, out, outb, oe);\n\t    }\n\t    else\n\t    {\n\t\tif (!pl.p)\n\t\t    invalidCode(); // wrong code\n\n\t\t//\n\t\t// Search long code\n\t\t//\n\n\t\tint j;\n\n\t\tfor (j = 0; j < pl.lit; j++)\n\t\t{\n\t\t    int\tl = hufLength (hcode[pl.p[j]]);\n\n\t\t    while (lc < l && in < ie)\t// get more bits\n\t\t\tgetChar (c, lc, in);\n\n\t\t    if (lc >= l)\n\t\t    {\n\t\t\tif (hufCode (hcode[pl.p[j]]) ==\n\t\t\t\t((c >> (lc - l)) & ((Int64(1) << l) - 1)))\n\t\t\t{\n\t\t\t    //\n\t\t\t    // Found : get long code\n\t\t\t    //\n\n\t\t\t    lc -= l;\n\t\t\t    getCode (pl.p[j], rlc, c, lc, in, out, outb, oe);\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\n\t\tif (j == pl.lit)\n\t\t    invalidCode(); // Not found\n\t    }\n\t}\n    }\n\n    //\n    // Get remaining (short) codes\n    //\n\n    int i = (8 - ni) & 7;\n    c >>= i;\n    lc -= i;\n\n    while (lc > 0)\n    {\n\tconst HufDec pl = hdecod[(c << (HUF_DECBITS - lc)) & HUF_DECMASK];\n\n\tif (pl.len)\n\t{\n\t    lc -= pl.len;\n\t    getCode (pl.lit, rlc, c, lc, in, out, outb, oe);\n\t}\n\telse\n\t{\n\t    invalidCode(); // wrong (long) code\n\t}\n    }\n\n    if (out - outb != no)\n\tnotEnoughData ();\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147234,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "hufDecode\n    (const Int64 * \thcode,\t// i : encoding table\n     const HufDec * \thdecod,\t// i : decoding table\n     const char* \tin,\t// i : compressed input buffer\n     int\t\tni,\t// i : input size (in bits)\n     int\t\trlc,\t// i : run-length code\n     int\t\tno,\t// i : expected output size (in bytes)\n     unsigned short*\tout)\t//  o: uncompressed output buffer\n{\n    Int64 c = 0;\n    int lc = 0;\n    unsigned short * outb = out;\n    unsigned short * oe = out + no;\n    const char * ie = in + (ni + 7) / 8; // input byte size\n\n    //\n    // Loop on input bytes\n    //\n\n    while (in < ie)\n    {\n\tgetChar (c, lc, in);\n\n\t//\n\t// Access decoding table\n\t//\n\n\twhile (lc >= HUF_DECBITS)\n\t{\n\t    const HufDec pl = hdecod[(c >> (lc-HUF_DECBITS)) & HUF_DECMASK];\n\n\t    if (pl.len)\n\t    {\n\t\t//\n\t\t// Get short code\n\t\t//\n\n\t\tlc -= pl.len;\n\n\t\tif ( lc < 0 )\n\t\t{\n\t\t\tinvalidCode(); // code length too long\n\t\t}\n\t\tgetCode (pl.lit, rlc, c, lc, in, out, outb, oe);\n\t    }\n\t    else\n\t    {\n\t\tif (!pl.p)\n\t\t    invalidCode(); // wrong code\n\n\t\t//\n\t\t// Search long code\n\t\t//\n\n\t\tint j;\n\n\t\tfor (j = 0; j < pl.lit; j++)\n\t\t{\n\t\t    int\tl = hufLength (hcode[pl.p[j]]);\n\n\t\t    while (lc < l && in < ie)\t// get more bits\n\t\t\tgetChar (c, lc, in);\n\n\t\t    if (lc >= l)\n\t\t    {\n\t\t\tif (hufCode (hcode[pl.p[j]]) ==\n\t\t\t\t((c >> (lc - l)) & ((Int64(1) << l) - 1)))\n\t\t\t{\n\t\t\t    //\n\t\t\t    // Found : get long code\n\t\t\t    //\n\n\t\t\t    lc -= l;\n\t\t\t    getCode (pl.p[j], rlc, c, lc, in, out, outb, oe);\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\n\t\tif (j == pl.lit)\n\t\t    invalidCode(); // Not found\n\t    }\n\t}\n    }\n\n    //\n    // Get remaining (short) codes\n    //\n\n    int i = (8 - ni) & 7;\n    c >>= i;\n    lc -= i;\n\n    while (lc > 0)\n    {\n\tconst HufDec pl = hdecod[(c << (HUF_DECBITS - lc)) & HUF_DECMASK];\n\n\tif (pl.len)\n\t{\n\t    lc -= pl.len;\n            if ( lc < 0 )\n            {\n   \t        invalidCode(); // code length too long\n            }\n\t    getCode (pl.lit, rlc, c, lc, in, out, outb, oe);\n\t}\n\telse\n\t{\n\t    invalidCode(); // wrong (long) code\n\t}\n    }\n\n    if (out - outb != no)\n\tnotEnoughData ();\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147235,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static double ApplyEvaluateOperator(RandomInfo *random_info,const Quantum pixel,\n  const MagickEvaluateOperator op,const double value)\n{\n  double\n    result;\n\n  result=0.0;\n  switch (op)\n  {\n    case UndefinedEvaluateOperator:\n      break;\n    case AbsEvaluateOperator:\n    {\n      result=(double) fabs((double) (pixel+value));\n      break;\n    }\n    case AddEvaluateOperator:\n    {\n      result=(double) (pixel+value);\n      break;\n    }\n    case AddModulusEvaluateOperator:\n    {\n      /*\n        This returns a 'floored modulus' of the addition which is a positive\n        result.  It differs from % or fmod() that returns a 'truncated modulus'\n        result, where floor() is replaced by trunc() and could return a\n        negative result (which is clipped).\n      */\n      result=pixel+value;\n      result-=(QuantumRange+1.0)*floor((double) result/(QuantumRange+1.0));\n      break;\n    }\n    case AndEvaluateOperator:\n    {\n      result=(double) ((ssize_t) pixel & (ssize_t) (value+0.5));\n      break;\n    }\n    case CosineEvaluateOperator:\n    {\n      result=(double) (QuantumRange*(0.5*cos((double) (2.0*MagickPI*\n        QuantumScale*pixel*value))+0.5));\n      break;\n    }\n    case DivideEvaluateOperator:\n    {\n      result=pixel/(value == 0.0 ? 1.0 : value);\n      break;\n    }\n    case ExponentialEvaluateOperator:\n    {\n      result=(double) (QuantumRange*exp((double) (value*QuantumScale*pixel)));\n      break;\n    }\n    case GaussianNoiseEvaluateOperator:\n    {\n      result=(double) GenerateDifferentialNoise(random_info,pixel,\n        GaussianNoise,value);\n      break;\n    }\n    case ImpulseNoiseEvaluateOperator:\n    {\n      result=(double) GenerateDifferentialNoise(random_info,pixel,ImpulseNoise,\n        value);\n      break;\n    }\n    case LaplacianNoiseEvaluateOperator:\n    {\n      result=(double) GenerateDifferentialNoise(random_info,pixel,\n        LaplacianNoise,value);\n      break;\n    }\n    case LeftShiftEvaluateOperator:\n    {\n      result=(double) ((ssize_t) pixel << (ssize_t) (value+0.5));\n      break;\n    }\n    case LogEvaluateOperator:\n    {\n      if ((QuantumScale*pixel) >= MagickEpsilon)\n        result=(double) (QuantumRange*log((double) (QuantumScale*value*pixel+\n          1.0))/log((double) (value+1.0)));\n      break;\n    }\n    case MaxEvaluateOperator:\n    {\n      result=(double) EvaluateMax((double) pixel,value);\n      break;\n    }\n    case MeanEvaluateOperator:\n    {\n      result=(double) (pixel+value);\n      break;\n    }\n    case MedianEvaluateOperator:\n    {\n      result=(double) (pixel+value);\n      break;\n    }\n    case MinEvaluateOperator:\n    {\n      result=(double) MagickMin((double) pixel,value);\n      break;\n    }\n    case MultiplicativeNoiseEvaluateOperator:\n    {\n      result=(double) GenerateDifferentialNoise(random_info,pixel,\n        MultiplicativeGaussianNoise,value);\n      break;\n    }\n    case MultiplyEvaluateOperator:\n    {\n      result=(double) (value*pixel);\n      break;\n    }\n    case OrEvaluateOperator:\n    {\n      result=(double) ((ssize_t) pixel | (ssize_t) (value+0.5));\n      break;\n    }\n    case PoissonNoiseEvaluateOperator:\n    {\n      result=(double) GenerateDifferentialNoise(random_info,pixel,PoissonNoise,\n        value);\n      break;\n    }\n    case PowEvaluateOperator:\n    {\n      if (pixel < 0)\n        result=(double) -(QuantumRange*pow((double) -(QuantumScale*pixel),\n          (double) value));\n      else\n        result=(double) (QuantumRange*pow((double) (QuantumScale*pixel),\n          (double) value));\n      break;\n    }\n    case RightShiftEvaluateOperator:\n    {\n      result=(double) ((ssize_t) pixel >> (ssize_t) (value+0.5));\n      break;\n    }\n    case RootMeanSquareEvaluateOperator:\n    {\n      result=(double) (pixel*pixel+value);\n      break;\n    }\n    case SetEvaluateOperator:\n    {\n      result=value;\n      break;\n    }\n    case SineEvaluateOperator:\n    {\n      result=(double) (QuantumRange*(0.5*sin((double) (2.0*MagickPI*\n        QuantumScale*pixel*value))+0.5));\n      break;\n    }\n    case SubtractEvaluateOperator:\n    {\n      result=(double) (pixel-value);\n      break;\n    }\n    case SumEvaluateOperator:\n    {\n      result=(double) (pixel+value);\n      break;\n    }\n    case ThresholdEvaluateOperator:\n    {\n      result=(double) (((double) pixel <= value) ? 0 : QuantumRange);\n      break;\n    }\n    case ThresholdBlackEvaluateOperator:\n    {\n      result=(double) (((double) pixel <= value) ? 0 : pixel);\n      break;\n    }\n    case ThresholdWhiteEvaluateOperator:\n    {\n      result=(double) (((double) pixel > value) ? QuantumRange : pixel);\n      break;\n    }\n    case UniformNoiseEvaluateOperator:\n    {\n      result=(double) GenerateDifferentialNoise(random_info,pixel,UniformNoise,\n        value);\n      break;\n    }\n    case XorEvaluateOperator:\n    {\n      result=(double) ((ssize_t) pixel ^ (ssize_t) (value+0.5));\n      break;\n    }\n  }\n  return(result);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147340,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static double ApplyEvaluateOperator(RandomInfo *random_info,const Quantum pixel,\n  const MagickEvaluateOperator op,const double value)\n{\n  double\n    result;\n\n  register ssize_t\n    i;\n\n  result=0.0;\n  switch (op)\n  {\n    case UndefinedEvaluateOperator:\n      break;\n    case AbsEvaluateOperator:\n    {\n      result=(double) fabs((double) (pixel+value));\n      break;\n    }\n    case AddEvaluateOperator:\n    {\n      result=(double) (pixel+value);\n      break;\n    }\n    case AddModulusEvaluateOperator:\n    {\n      /*\n        This returns a 'floored modulus' of the addition which is a positive\n        result.  It differs from % or fmod() that returns a 'truncated modulus'\n        result, where floor() is replaced by trunc() and could return a\n        negative result (which is clipped).\n      */\n      result=pixel+value;\n      result-=(QuantumRange+1.0)*floor((double) result/(QuantumRange+1.0));\n      break;\n    }\n    case AndEvaluateOperator:\n    {\n      result=(double) ((ssize_t) pixel & (ssize_t) (value+0.5));\n      break;\n    }\n    case CosineEvaluateOperator:\n    {\n      result=(double) (QuantumRange*(0.5*cos((double) (2.0*MagickPI*\n        QuantumScale*pixel*value))+0.5));\n      break;\n    }\n    case DivideEvaluateOperator:\n    {\n      result=pixel/(value == 0.0 ? 1.0 : value);\n      break;\n    }\n    case ExponentialEvaluateOperator:\n    {\n      result=(double) (QuantumRange*exp((double) (value*QuantumScale*pixel)));\n      break;\n    }\n    case GaussianNoiseEvaluateOperator:\n    {\n      result=(double) GenerateDifferentialNoise(random_info,pixel,\n        GaussianNoise,value);\n      break;\n    }\n    case ImpulseNoiseEvaluateOperator:\n    {\n      result=(double) GenerateDifferentialNoise(random_info,pixel,ImpulseNoise,\n        value);\n      break;\n    }\n    case LaplacianNoiseEvaluateOperator:\n    {\n      result=(double) GenerateDifferentialNoise(random_info,pixel,\n        LaplacianNoise,value);\n      break;\n    }\n    case LeftShiftEvaluateOperator:\n    {\n      result=(double) pixel;\n      for (i=0; i < (ssize_t) value; i++)\n        result*=2.0;\n      break;\n    }\n    case LogEvaluateOperator:\n    {\n      if ((QuantumScale*pixel) >= MagickEpsilon)\n        result=(double) (QuantumRange*log((double) (QuantumScale*value*pixel+\n          1.0))/log((double) (value+1.0)));\n      break;\n    }\n    case MaxEvaluateOperator:\n    {\n      result=(double) EvaluateMax((double) pixel,value);\n      break;\n    }\n    case MeanEvaluateOperator:\n    {\n      result=(double) (pixel+value);\n      break;\n    }\n    case MedianEvaluateOperator:\n    {\n      result=(double) (pixel+value);\n      break;\n    }\n    case MinEvaluateOperator:\n    {\n      result=(double) MagickMin((double) pixel,value);\n      break;\n    }\n    case MultiplicativeNoiseEvaluateOperator:\n    {\n      result=(double) GenerateDifferentialNoise(random_info,pixel,\n        MultiplicativeGaussianNoise,value);\n      break;\n    }\n    case MultiplyEvaluateOperator:\n    {\n      result=(double) (value*pixel);\n      break;\n    }\n    case OrEvaluateOperator:\n    {\n      result=(double) ((ssize_t) pixel | (ssize_t) (value+0.5));\n      break;\n    }\n    case PoissonNoiseEvaluateOperator:\n    {\n      result=(double) GenerateDifferentialNoise(random_info,pixel,PoissonNoise,\n        value);\n      break;\n    }\n    case PowEvaluateOperator:\n    {\n      if (pixel < 0)\n        result=(double) -(QuantumRange*pow((double) -(QuantumScale*pixel),\n          (double) value));\n      else\n        result=(double) (QuantumRange*pow((double) (QuantumScale*pixel),\n          (double) value));\n      break;\n    }\n    case RightShiftEvaluateOperator:\n    {\n      result=(double) pixel;\n      for (i=0; i < (ssize_t) value; i++)\n        result/=2.0;\n      break;\n    }\n    case RootMeanSquareEvaluateOperator:\n    {\n      result=(double) (pixel*pixel+value);\n      break;\n    }\n    case SetEvaluateOperator:\n    {\n      result=value;\n      break;\n    }\n    case SineEvaluateOperator:\n    {\n      result=(double) (QuantumRange*(0.5*sin((double) (2.0*MagickPI*\n        QuantumScale*pixel*value))+0.5));\n      break;\n    }\n    case SubtractEvaluateOperator:\n    {\n      result=(double) (pixel-value);\n      break;\n    }\n    case SumEvaluateOperator:\n    {\n      result=(double) (pixel+value);\n      break;\n    }\n    case ThresholdEvaluateOperator:\n    {\n      result=(double) (((double) pixel <= value) ? 0 : QuantumRange);\n      break;\n    }\n    case ThresholdBlackEvaluateOperator:\n    {\n      result=(double) (((double) pixel <= value) ? 0 : pixel);\n      break;\n    }\n    case ThresholdWhiteEvaluateOperator:\n    {\n      result=(double) (((double) pixel > value) ? QuantumRange : pixel);\n      break;\n    }\n    case UniformNoiseEvaluateOperator:\n    {\n      result=(double) GenerateDifferentialNoise(random_info,pixel,UniformNoise,\n        value);\n      break;\n    }\n    case XorEvaluateOperator:\n    {\n      result=(double) ((ssize_t) pixel ^ (ssize_t) (value+0.5));\n      break;\n    }\n  }\n  return(result);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147341,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "UnicodeString DecimalQuantity::toScientificString() const {\n    U_ASSERT(!isApproximate);\n    UnicodeString result;\n    if (isNegative()) {\n        result.append(u'-');\n    }\n    if (precision == 0) {\n        result.append(u\"0E+0\", -1);\n        return result;\n    }\n    // NOTE: It is not safe to add to lOptPos (aka maxInt) or subtract from\n    // rOptPos (aka -maxFrac) due to overflow.\n    int32_t upperPos = std::min(precision + scale, lOptPos) - scale - 1;\n    int32_t lowerPos = std::max(scale, rOptPos) - scale;\n    int32_t p = upperPos;\n    result.append(u'0' + getDigitPos(p));\n    if ((--p) >= lowerPos) {\n        result.append(u'.');\n        for (; p >= lowerPos; p--) {\n            result.append(u'0' + getDigitPos(p));\n        }\n    }\n    result.append(u'E');\n    int32_t _scale = upperPos + scale;\n    if (_scale < 0) {\n        _scale *= -1;\n        result.append(u'-');\n    } else {\n        result.append(u'+');\n    }\n    if (_scale == 0) {\n        result.append(u'0');\n    }\n    int32_t insertIndex = result.length();\n    while (_scale > 0) {\n        std::div_t res = std::div(_scale, 10);\n        result.insert(insertIndex, u'0' + res.rem);\n        _scale = res.quot;\n    }\n    return result;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147364,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "UnicodeString DecimalQuantity::toScientificString() const {\n    U_ASSERT(!isApproximate);\n    UnicodeString result;\n    if (isNegative()) {\n        result.append(u'-');\n    }\n    if (precision == 0) {\n        result.append(u\"0E+0\", -1);\n        return result;\n    }\n    // NOTE: It is not safe to add to lOptPos (aka maxInt) or subtract from\n    // rOptPos (aka -maxFrac) due to overflow.\n    int32_t upperPos = std::min(precision + scale, lOptPos) - scale - 1;\n    int32_t lowerPos = std::max(scale, rOptPos) - scale;\n    int32_t p = upperPos;\n    result.append(u'0' + getDigitPos(p));\n    if ((--p) >= lowerPos) {\n        result.append(u'.');\n        for (; p >= lowerPos; p--) {\n            result.append(u'0' + getDigitPos(p));\n        }\n    }\n    result.append(u'E');\n    int32_t _scale = upperPos + scale;\n    if (_scale == INT32_MIN) {\n        result.append({u\"-2147483648\", -1});\n        return result;\n    } else if (_scale < 0) {\n        _scale *= -1;\n        result.append(u'-');\n    } else {\n        result.append(u'+');\n    }\n    if (_scale == 0) {\n        result.append(u'0');\n    }\n    int32_t insertIndex = result.length();\n    while (_scale > 0) {\n        std::div_t res = std::div(_scale, 10);\n        result.insert(insertIndex, u'0' + res.rem);\n        _scale = res.quot;\n    }\n    return result;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147365,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "void JPXStream::init()\n{\n  Object oLen, cspace, smaskInData;\n  if (getDict()) {\n    oLen = getDict()->lookup(\"Length\");\n    cspace = getDict()->lookup(\"ColorSpace\");\n    smaskInData = getDict()->lookup(\"SMaskInData\");\n  }\n\n  int bufSize = BUFFER_INITIAL_SIZE;\n  if (oLen.isInt()) bufSize = oLen.getInt();\n\n  bool indexed = false;\n  if (cspace.isArray() && cspace.arrayGetLength() > 0) {\n    const Object cstype = cspace.arrayGet(0);\n    if (cstype.isName(\"Indexed\")) indexed = true;\n  }\n\n  priv->smaskInData = 0;\n  if (smaskInData.isInt()) priv->smaskInData = smaskInData.getInt();\n\n  int length = 0;\n  unsigned char *buf = str->toUnsignedChars(&length, bufSize);\n  priv->init2(OPJ_CODEC_JP2, buf, length, indexed);\n  gfree(buf);\n\n  if (priv->image) {\n    int numComps = (priv->image) ? priv->image->numcomps : 1;\n    int alpha = 0;\n    if (priv->image) {\n      if (priv->image->color_space == OPJ_CLRSPC_SRGB && numComps == 4) { numComps = 3; alpha = 1; }\n      else if (priv->image->color_space == OPJ_CLRSPC_SYCC && numComps == 4) { numComps = 3; alpha = 1; }\n      else if (numComps == 2) { numComps = 1; alpha = 1; }\n      else if (numComps > 4) { numComps = 4; alpha = 1; }\n      else { alpha = 0; }\n    }\n    priv->npixels = priv->image->comps[0].w * priv->image->comps[0].h;\n    priv->ncomps = priv->image->numcomps;\n    if (alpha == 1 && priv->smaskInData == 0) priv->ncomps--;\n    for (int component = 0; component < priv->ncomps; component++) {\n      if (priv->image->comps[component].data == nullptr) {\n        close();\n        break;\n      }\n      const int componentPixels = priv->image->comps[component].w * priv->image->comps[component].h;\n      if (componentPixels != priv->npixels) {\n        error(errSyntaxWarning, -1, \"Component {0:d} has different WxH than component 0\", component);\n        close();\n        break;\n      }\n      unsigned char *cdata = (unsigned char *)priv->image->comps[component].data;\n      int adjust = 0;\n      int depth = priv->image->comps[component].prec;\n      if (priv->image->comps[component].prec > 8)\n\tadjust = priv->image->comps[component].prec - 8;\n      int sgndcorr = 0;\n      if (priv->image->comps[component].sgnd)\n\tsgndcorr = 1 << (priv->image->comps[0].prec - 1);\n      for (int i = 0; i < priv->npixels; i++) {\n\tint r = priv->image->comps[component].data[i];\n\t*(cdata++) = adjustComp(r, adjust, depth, sgndcorr, indexed);\n      }\n    }\n  } else {\n    priv->npixels = 0;\n  }\n\n  priv->counter = 0;\n  priv->ccounter = 0;\n  priv->inited = true;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147488,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "void JPXStream::init()\n{\n  Object oLen, cspace, smaskInData;\n  if (getDict()) {\n    oLen = getDict()->lookup(\"Length\");\n    cspace = getDict()->lookup(\"ColorSpace\");\n    smaskInData = getDict()->lookup(\"SMaskInData\");\n  }\n\n  int bufSize = BUFFER_INITIAL_SIZE;\n  if (oLen.isInt() && oLen.getInt() > 0) bufSize = oLen.getInt();\n\n  bool indexed = false;\n  if (cspace.isArray() && cspace.arrayGetLength() > 0) {\n    const Object cstype = cspace.arrayGet(0);\n    if (cstype.isName(\"Indexed\")) indexed = true;\n  }\n\n  priv->smaskInData = 0;\n  if (smaskInData.isInt()) priv->smaskInData = smaskInData.getInt();\n\n  int length = 0;\n  unsigned char *buf = str->toUnsignedChars(&length, bufSize);\n  priv->init2(OPJ_CODEC_JP2, buf, length, indexed);\n  gfree(buf);\n\n  if (priv->image) {\n    int numComps = (priv->image) ? priv->image->numcomps : 1;\n    int alpha = 0;\n    if (priv->image) {\n      if (priv->image->color_space == OPJ_CLRSPC_SRGB && numComps == 4) { numComps = 3; alpha = 1; }\n      else if (priv->image->color_space == OPJ_CLRSPC_SYCC && numComps == 4) { numComps = 3; alpha = 1; }\n      else if (numComps == 2) { numComps = 1; alpha = 1; }\n      else if (numComps > 4) { numComps = 4; alpha = 1; }\n      else { alpha = 0; }\n    }\n    priv->npixels = priv->image->comps[0].w * priv->image->comps[0].h;\n    priv->ncomps = priv->image->numcomps;\n    if (alpha == 1 && priv->smaskInData == 0) priv->ncomps--;\n    for (int component = 0; component < priv->ncomps; component++) {\n      if (priv->image->comps[component].data == nullptr) {\n        close();\n        break;\n      }\n      const int componentPixels = priv->image->comps[component].w * priv->image->comps[component].h;\n      if (componentPixels != priv->npixels) {\n        error(errSyntaxWarning, -1, \"Component {0:d} has different WxH than component 0\", component);\n        close();\n        break;\n      }\n      unsigned char *cdata = (unsigned char *)priv->image->comps[component].data;\n      int adjust = 0;\n      int depth = priv->image->comps[component].prec;\n      if (priv->image->comps[component].prec > 8)\n\tadjust = priv->image->comps[component].prec - 8;\n      int sgndcorr = 0;\n      if (priv->image->comps[component].sgnd)\n\tsgndcorr = 1 << (priv->image->comps[0].prec - 1);\n      for (int i = 0; i < priv->npixels; i++) {\n\tint r = priv->image->comps[component].data[i];\n\t*(cdata++) = adjustComp(r, adjust, depth, sgndcorr, indexed);\n      }\n    }\n  } else {\n    priv->npixels = 0;\n  }\n\n  priv->counter = 0;\n  priv->ccounter = 0;\n  priv->inited = true;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147489,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "_XimAttributeToValue(\n    Xic\t\t\t  ic,\n    XIMResourceList\t  res,\n    CARD16\t\t *data,\n    INT16\t\t  data_len,\n    XPointer\t\t  value,\n    BITMASK32\t\t  mode)\n{\n    switch (res->resource_size) {\n    case XimType_SeparatorOfNestedList:\n    case XimType_NEST:\n\tbreak;\n\n    case XimType_CARD8:\n    case XimType_CARD16:\n    case XimType_CARD32:\n    case XimType_Window:\n    case XimType_XIMHotKeyState:\n\t_XCopyToArg((XPointer)data, (XPointer *)&value, data_len);\n\tbreak;\n\n    case XimType_STRING8:\n\t{\n\t    char\t*str;\n\n\t    if (!(value))\n\t\treturn False;\n\n\t    if (!(str = Xmalloc(data_len + 1)))\n\t\treturn False;\n\n\t    (void)memcpy(str, (char *)data, data_len);\n\t    str[data_len] = '\\0';\n\n\t    *((char **)value) = str;\n\t    break;\n\t}\n\n    case XimType_XIMStyles:\n\t{\n\t    CARD16\t\t num = data[0];\n\t    register CARD32\t*style_list = (CARD32 *)&data[2];\n\t    XIMStyle\t\t*style;\n\t    XIMStyles\t\t*rep;\n\t    register int\t i;\n\t    char\t\t*p;\n\t    unsigned int         alloc_len;\n\n\t    if (!(value))\n\t\treturn False;\n\n\t    if (num > (USHRT_MAX / sizeof(XIMStyle)))\n\t\treturn False;\n\t    if ((sizeof(num) + (num * sizeof(XIMStyle))) > data_len)\n\t\treturn False;\n\t    alloc_len = sizeof(XIMStyles) + sizeof(XIMStyle) * num;\n\t    if (alloc_len < sizeof(XIMStyles))\n\t\treturn False;\n\t    if (!(p = Xmalloc(alloc_len)))\n\t\treturn False;\n\n\t    rep   = (XIMStyles *)p;\n\t    style = (XIMStyle *)(p + sizeof(XIMStyles));\n\n\t    for (i = 0; i < num; i++)\n\t\tstyle[i] = (XIMStyle)style_list[i];\n\n\t    rep->count_styles = (unsigned short)num;\n\t    rep->supported_styles = style;\n\t    *((XIMStyles **)value) = rep;\n\t    break;\n\t}\n\n    case XimType_XRectangle:\n\t{\n\t    XRectangle\t*rep;\n\n\t    if (!(value))\n\t\treturn False;\n\n\t    if (!(rep = Xmalloc(sizeof(XRectangle))))\n\t\treturn False;\n\n\t    rep->x      = data[0];\n\t    rep->y      = data[1];\n\t    rep->width  = data[2];\n\t    rep->height = data[3];\n\t    *((XRectangle **)value) = rep;\n\t    break;\n\t}\n\n    case XimType_XPoint:\n\t{\n\t    XPoint\t*rep;\n\n\t    if (!(value))\n\t\treturn False;\n\n\t    if (!(rep = Xmalloc(sizeof(XPoint))))\n\t\treturn False;\n\n\t    rep->x = data[0];\n\t    rep->y = data[1];\n\t    *((XPoint **)value) = rep;\n\t    break;\n\t}\n\n    case XimType_XFontSet:\n\t{\n\t    CARD16\t len = data[0];\n\t    char\t*base_name;\n\t    XFontSet\t rep = (XFontSet)NULL;\n\t    char\t**missing_list = NULL;\n\t    int\t\t missing_count;\n\t    char\t*def_string;\n\n\t    if (!(value))\n\t\treturn False;\n\t    if (!ic)\n\t\treturn False;\n\t    if (len > data_len)\n\t\treturn False;\n\t    if (!(base_name = Xmalloc(len + 1)))\n\t\treturn False;\n\n\t    (void)strncpy(base_name, (char *)&data[1], (size_t)len);\n\t    base_name[len] = '\\0';\n\n\t    if (mode & XIM_PREEDIT_ATTR) {\n\t\tif (!strcmp(base_name, ic->private.proto.preedit_font)) {\n\t\t    rep = ic->core.preedit_attr.fontset;\n\t\t} else if (!ic->private.proto.preedit_font_length) {\n\t\t    rep = XCreateFontSet(ic->core.im->core.display,\n\t\t\t\t\tbase_name, &missing_list,\n\t\t\t\t\t&missing_count, &def_string);\n\t\t}\n\t    } else if (mode & XIM_STATUS_ATTR) {\n\t\tif (!strcmp(base_name, ic->private.proto.status_font)) {\n\t\t    rep = ic->core.status_attr.fontset;\n\t\t} else if (!ic->private.proto.status_font_length) {\n\t\t    rep = XCreateFontSet(ic->core.im->core.display,\n\t\t\t\t\tbase_name, &missing_list,\n\t\t\t\t\t&missing_count, &def_string);\n\t\t}\n\t    }\n\n\t    Xfree(base_name);\n\t    Xfree(missing_list);\n\t    *((XFontSet *)value) = rep;\n\t    break;\n\t}\n\n    case XimType_XIMHotKeyTriggers:\n\t{\n\t    CARD32\t\t\t num = *((CARD32 *)data);\n\t    register CARD32\t\t*key_list = (CARD32 *)&data[2];\n\t    XIMHotKeyTrigger\t\t*key;\n\t    XIMHotKeyTriggers\t\t*rep;\n\t    register int\t\t i;\n\t    char\t\t\t*p;\n\t    unsigned int\t\t alloc_len;\n\n\t    if (!(value))\n\t\treturn False;\n\n\t    if (num > (UINT_MAX / sizeof(XIMHotKeyTrigger)))\n\t\treturn False;\n\t    if ((sizeof(num) + (num * sizeof(XIMHotKeyTrigger))) > data_len)\n\t\treturn False;\n\t    alloc_len = sizeof(XIMHotKeyTriggers)\n\t\t      + sizeof(XIMHotKeyTrigger) * num;\n\t    if (alloc_len < sizeof(XIMHotKeyTriggers))\n\t\treturn False;\n\t    if (!(p = Xmalloc(alloc_len)))\n\t\treturn False;\n\n\t    rep = (XIMHotKeyTriggers *)p;\n\t    key = (XIMHotKeyTrigger *)(p + sizeof(XIMHotKeyTriggers));\n\n\t    for (i = 0; i < num; i++, key_list += 3) {\n\t\tkey[i].keysym        = (KeySym)key_list[0]; /* keysym */\n\t\tkey[i].modifier      = (int)key_list[1];    /* modifier */\n\t\tkey[i].modifier_mask = (int)key_list[2];    /* modifier_mask */\n\t    }\n\n\t    rep->num_hot_key = (int)num;\n\t    rep->key = key;\n\t    *((XIMHotKeyTriggers **)value) = rep;\n\t    break;\n\t}\n\n    case XimType_XIMStringConversion:\n\t{\n\t    break;\n\t}\n\n    default:\n\treturn False;\n    }\n    return True;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147496,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "_XimAttributeToValue(\n    Xic\t\t\t  ic,\n    XIMResourceList\t  res,\n    CARD16\t\t *data,\n    CARD16\t\t  data_len,\n    XPointer\t\t  value,\n    BITMASK32\t\t  mode)\n{\n    switch (res->resource_size) {\n    case XimType_SeparatorOfNestedList:\n    case XimType_NEST:\n\tbreak;\n\n    case XimType_CARD8:\n    case XimType_CARD16:\n    case XimType_CARD32:\n    case XimType_Window:\n    case XimType_XIMHotKeyState:\n\t_XCopyToArg((XPointer)data, (XPointer *)&value, data_len);\n\tbreak;\n\n    case XimType_STRING8:\n\t{\n\t    char\t*str;\n\n\t    if (!(value))\n\t\treturn False;\n\n\t    if (!(str = Xmalloc(data_len + 1)))\n\t\treturn False;\n\n\t    (void)memcpy(str, (char *)data, data_len);\n\t    str[data_len] = '\\0';\n\n\t    *((char **)value) = str;\n\t    break;\n\t}\n\n    case XimType_XIMStyles:\n\t{\n\t    CARD16\t\t num = data[0];\n\t    register CARD32\t*style_list = (CARD32 *)&data[2];\n\t    XIMStyle\t\t*style;\n\t    XIMStyles\t\t*rep;\n\t    register int\t i;\n\t    char\t\t*p;\n\t    unsigned int         alloc_len;\n\n\t    if (!(value))\n\t\treturn False;\n\n\t    if (num > (USHRT_MAX / sizeof(XIMStyle)))\n\t\treturn False;\n\t    if ((sizeof(num) + (num * sizeof(XIMStyle))) > data_len)\n\t\treturn False;\n\t    alloc_len = sizeof(XIMStyles) + sizeof(XIMStyle) * num;\n\t    if (alloc_len < sizeof(XIMStyles))\n\t\treturn False;\n\t    if (!(p = Xmalloc(alloc_len)))\n\t\treturn False;\n\n\t    rep   = (XIMStyles *)p;\n\t    style = (XIMStyle *)(p + sizeof(XIMStyles));\n\n\t    for (i = 0; i < num; i++)\n\t\tstyle[i] = (XIMStyle)style_list[i];\n\n\t    rep->count_styles = (unsigned short)num;\n\t    rep->supported_styles = style;\n\t    *((XIMStyles **)value) = rep;\n\t    break;\n\t}\n\n    case XimType_XRectangle:\n\t{\n\t    XRectangle\t*rep;\n\n\t    if (!(value))\n\t\treturn False;\n\n\t    if (!(rep = Xmalloc(sizeof(XRectangle))))\n\t\treturn False;\n\n\t    rep->x      = data[0];\n\t    rep->y      = data[1];\n\t    rep->width  = data[2];\n\t    rep->height = data[3];\n\t    *((XRectangle **)value) = rep;\n\t    break;\n\t}\n\n    case XimType_XPoint:\n\t{\n\t    XPoint\t*rep;\n\n\t    if (!(value))\n\t\treturn False;\n\n\t    if (!(rep = Xmalloc(sizeof(XPoint))))\n\t\treturn False;\n\n\t    rep->x = data[0];\n\t    rep->y = data[1];\n\t    *((XPoint **)value) = rep;\n\t    break;\n\t}\n\n    case XimType_XFontSet:\n\t{\n\t    CARD16\t len = data[0];\n\t    char\t*base_name;\n\t    XFontSet\t rep = (XFontSet)NULL;\n\t    char\t**missing_list = NULL;\n\t    int\t\t missing_count;\n\t    char\t*def_string;\n\n\t    if (!(value))\n\t\treturn False;\n\t    if (!ic)\n\t\treturn False;\n\t    if (len > data_len)\n\t\treturn False;\n\t    if (!(base_name = Xmalloc(len + 1)))\n\t\treturn False;\n\n\t    (void)strncpy(base_name, (char *)&data[1], (size_t)len);\n\t    base_name[len] = '\\0';\n\n\t    if (mode & XIM_PREEDIT_ATTR) {\n\t\tif (!strcmp(base_name, ic->private.proto.preedit_font)) {\n\t\t    rep = ic->core.preedit_attr.fontset;\n\t\t} else if (!ic->private.proto.preedit_font_length) {\n\t\t    rep = XCreateFontSet(ic->core.im->core.display,\n\t\t\t\t\tbase_name, &missing_list,\n\t\t\t\t\t&missing_count, &def_string);\n\t\t}\n\t    } else if (mode & XIM_STATUS_ATTR) {\n\t\tif (!strcmp(base_name, ic->private.proto.status_font)) {\n\t\t    rep = ic->core.status_attr.fontset;\n\t\t} else if (!ic->private.proto.status_font_length) {\n\t\t    rep = XCreateFontSet(ic->core.im->core.display,\n\t\t\t\t\tbase_name, &missing_list,\n\t\t\t\t\t&missing_count, &def_string);\n\t\t}\n\t    }\n\n\t    Xfree(base_name);\n\t    Xfree(missing_list);\n\t    *((XFontSet *)value) = rep;\n\t    break;\n\t}\n\n    case XimType_XIMHotKeyTriggers:\n\t{\n\t    CARD32\t\t\t num = *((CARD32 *)data);\n\t    register CARD32\t\t*key_list = (CARD32 *)&data[2];\n\t    XIMHotKeyTrigger\t\t*key;\n\t    XIMHotKeyTriggers\t\t*rep;\n\t    register int\t\t i;\n\t    char\t\t\t*p;\n\t    unsigned int\t\t alloc_len;\n\n\t    if (!(value))\n\t\treturn False;\n\n\t    if (num > (UINT_MAX / sizeof(XIMHotKeyTrigger)))\n\t\treturn False;\n\t    if ((sizeof(num) + (num * sizeof(XIMHotKeyTrigger))) > data_len)\n\t\treturn False;\n\t    alloc_len = sizeof(XIMHotKeyTriggers)\n\t\t      + sizeof(XIMHotKeyTrigger) * num;\n\t    if (alloc_len < sizeof(XIMHotKeyTriggers))\n\t\treturn False;\n\t    if (!(p = Xmalloc(alloc_len)))\n\t\treturn False;\n\n\t    rep = (XIMHotKeyTriggers *)p;\n\t    key = (XIMHotKeyTrigger *)(p + sizeof(XIMHotKeyTriggers));\n\n\t    for (i = 0; i < num; i++, key_list += 3) {\n\t\tkey[i].keysym        = (KeySym)key_list[0]; /* keysym */\n\t\tkey[i].modifier      = (int)key_list[1];    /* modifier */\n\t\tkey[i].modifier_mask = (int)key_list[2];    /* modifier_mask */\n\t    }\n\n\t    rep->num_hot_key = (int)num;\n\t    rep->key = key;\n\t    *((XIMHotKeyTriggers **)value) = rep;\n\t    break;\n\t}\n\n    case XimType_XIMStringConversion:\n\t{\n\t    break;\n\t}\n\n    default:\n\treturn False;\n    }\n    return True;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147497,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static noinline_for_stack int ethtool_get_rxnfc(struct net_device *dev,\n\t\t\t\t\t\tvoid __user *useraddr)\n{\n\tstruct ethtool_rxnfc info;\n\tconst struct ethtool_ops *ops = dev->ethtool_ops;\n\tint ret;\n\tvoid *rule_buf = NULL;\n\n\tif (!ops->get_rxnfc)\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(&info, useraddr, sizeof(info)))\n\t\treturn -EFAULT;\n\n\tif (info.cmd == ETHTOOL_GRXCLSRLALL) {\n\t\tif (info.rule_cnt > 0) {\n\t\t\trule_buf = kmalloc(info.rule_cnt * sizeof(u32),\n\t\t\t\t\t   GFP_USER);\n\t\t\tif (!rule_buf)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tret = ops->get_rxnfc(dev, &info, rule_buf);\n\tif (ret < 0)\n\t\tgoto err_out;\n\n\tret = -EFAULT;\n\tif (copy_to_user(useraddr, &info, sizeof(info)))\n\t\tgoto err_out;\n\n\tif (rule_buf) {\n\t\tuseraddr += offsetof(struct ethtool_rxnfc, rule_locs);\n\t\tif (copy_to_user(useraddr, rule_buf,\n\t\t\t\t info.rule_cnt * sizeof(u32)))\n\t\t\tgoto err_out;\n\t}\n\tret = 0;\n\nerr_out:\n\tkfree(rule_buf);\n\n\treturn ret;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147606,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static noinline_for_stack int ethtool_get_rxnfc(struct net_device *dev,\n\t\t\t\t\t\tvoid __user *useraddr)\n{\n\tstruct ethtool_rxnfc info;\n\tconst struct ethtool_ops *ops = dev->ethtool_ops;\n\tint ret;\n\tvoid *rule_buf = NULL;\n\n\tif (!ops->get_rxnfc)\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(&info, useraddr, sizeof(info)))\n\t\treturn -EFAULT;\n\n\tif (info.cmd == ETHTOOL_GRXCLSRLALL) {\n\t\tif (info.rule_cnt > 0) {\n\t\t\tif (info.rule_cnt <= KMALLOC_MAX_SIZE / sizeof(u32))\n\t\t\t\trule_buf = kmalloc(info.rule_cnt * sizeof(u32),\n\t\t\t\t\t\t   GFP_USER);\n\t\t\tif (!rule_buf)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tret = ops->get_rxnfc(dev, &info, rule_buf);\n\tif (ret < 0)\n\t\tgoto err_out;\n\n\tret = -EFAULT;\n\tif (copy_to_user(useraddr, &info, sizeof(info)))\n\t\tgoto err_out;\n\n\tif (rule_buf) {\n\t\tuseraddr += offsetof(struct ethtool_rxnfc, rule_locs);\n\t\tif (copy_to_user(useraddr, rule_buf,\n\t\t\t\t info.rule_cnt * sizeof(u32)))\n\t\t\tgoto err_out;\n\t}\n\tret = 0;\n\nerr_out:\n\tkfree(rule_buf);\n\n\treturn ret;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147607,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "long do_io_submit(aio_context_t ctx_id, long nr,\n\t\t  struct iocb __user *__user *iocbpp, bool compat)\n{\n\tstruct kioctx *ctx;\n\tlong ret = 0;\n\tint i;\n\tstruct hlist_head batch_hash[AIO_BATCH_HASH_SIZE] = { { 0, }, };\n\n\tif (unlikely(nr < 0))\n\t\treturn -EINVAL;\n\n\tif (unlikely(!access_ok(VERIFY_READ, iocbpp, (nr*sizeof(*iocbpp)))))\n\t\treturn -EFAULT;\n\n\tctx = lookup_ioctx(ctx_id);\n\tif (unlikely(!ctx)) {\n\t\tpr_debug(\"EINVAL: io_submit: invalid context id\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * AKPM: should this return a partial result if some of the IOs were\n\t * successfully submitted?\n\t */\n\tfor (i=0; i<nr; i++) {\n\t\tstruct iocb __user *user_iocb;\n\t\tstruct iocb tmp;\n\n\t\tif (unlikely(__get_user(user_iocb, iocbpp + i))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (unlikely(copy_from_user(&tmp, user_iocb, sizeof(tmp)))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = io_submit_one(ctx, user_iocb, &tmp, batch_hash, compat);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\taio_batch_free(batch_hash);\n\n\tput_ioctx(ctx);\n\treturn i ? i : ret;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147608,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "long do_io_submit(aio_context_t ctx_id, long nr,\n\t\t  struct iocb __user *__user *iocbpp, bool compat)\n{\n\tstruct kioctx *ctx;\n\tlong ret = 0;\n\tint i;\n\tstruct hlist_head batch_hash[AIO_BATCH_HASH_SIZE] = { { 0, }, };\n\n\tif (unlikely(nr < 0))\n\t\treturn -EINVAL;\n\n\tif (unlikely(nr > LONG_MAX/sizeof(*iocbpp)))\n\t\tnr = LONG_MAX/sizeof(*iocbpp);\n\n\tif (unlikely(!access_ok(VERIFY_READ, iocbpp, (nr*sizeof(*iocbpp)))))\n\t\treturn -EFAULT;\n\n\tctx = lookup_ioctx(ctx_id);\n\tif (unlikely(!ctx)) {\n\t\tpr_debug(\"EINVAL: io_submit: invalid context id\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * AKPM: should this return a partial result if some of the IOs were\n\t * successfully submitted?\n\t */\n\tfor (i=0; i<nr; i++) {\n\t\tstruct iocb __user *user_iocb;\n\t\tstruct iocb tmp;\n\n\t\tif (unlikely(__get_user(user_iocb, iocbpp + i))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (unlikely(copy_from_user(&tmp, user_iocb, sizeof(tmp)))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = io_submit_one(ctx, user_iocb, &tmp, batch_hash, compat);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\taio_batch_free(batch_hash);\n\n\tput_ioctx(ctx);\n\treturn i ? i : ret;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147609,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "int agp_generic_insert_memory(struct agp_memory * mem, off_t pg_start, int type)\n{\n\tint num_entries;\n\tsize_t i;\n\toff_t j;\n\tvoid *temp;\n\tstruct agp_bridge_data *bridge;\n\tint mask_type;\n\n\tbridge = mem->bridge;\n\tif (!bridge)\n\t\treturn -EINVAL;\n\n\tif (mem->page_count == 0)\n\t\treturn 0;\n\n\ttemp = bridge->current_size;\n\n\tswitch (bridge->driver->size_type) {\n\tcase U8_APER_SIZE:\n\t\tnum_entries = A_SIZE_8(temp)->num_entries;\n\t\tbreak;\n\tcase U16_APER_SIZE:\n\t\tnum_entries = A_SIZE_16(temp)->num_entries;\n\t\tbreak;\n\tcase U32_APER_SIZE:\n\t\tnum_entries = A_SIZE_32(temp)->num_entries;\n\t\tbreak;\n\tcase FIXED_APER_SIZE:\n\t\tnum_entries = A_SIZE_FIX(temp)->num_entries;\n\t\tbreak;\n\tcase LVL2_APER_SIZE:\n\t\t/* The generic routines can't deal with 2 level gatt's */\n\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\tnum_entries = 0;\n\t\tbreak;\n\t}\n\n\tnum_entries -= agp_memory_reserved/PAGE_SIZE;\n\tif (num_entries < 0) num_entries = 0;\n\n\tif (type != mem->type)\n\t\treturn -EINVAL;\n\n\tmask_type = bridge->driver->agp_type_to_mask_type(bridge, type);\n\tif (mask_type != 0) {\n\t\t/* The generic routines know nothing of memory types */\n\t\treturn -EINVAL;\n\t}\n\n\t/* AK: could wrap */\n\tif ((pg_start + mem->page_count) > num_entries)\n\t\treturn -EINVAL;\n\n\tj = pg_start;\n\n\twhile (j < (pg_start + mem->page_count)) {\n\t\tif (!PGE_EMPTY(bridge, readl(bridge->gatt_table+j)))\n\t\t\treturn -EBUSY;\n\t\tj++;\n\t}\n\n\tif (!mem->is_flushed) {\n\t\tbridge->driver->cache_flush();\n\t\tmem->is_flushed = true;\n\t}\n\n\tfor (i = 0, j = pg_start; i < mem->page_count; i++, j++) {\n\t\twritel(bridge->driver->mask_memory(bridge,\n\t\t\t\t\t\t   page_to_phys(mem->pages[i]),\n\t\t\t\t\t\t   mask_type),\n\t\t       bridge->gatt_table+j);\n\t}\n\treadl(bridge->gatt_table+j-1);\t/* PCI Posting. */\n\n\tbridge->driver->tlb_flush(mem);\n\treturn 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147628,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "int agp_generic_insert_memory(struct agp_memory * mem, off_t pg_start, int type)\n{\n\tint num_entries;\n\tsize_t i;\n\toff_t j;\n\tvoid *temp;\n\tstruct agp_bridge_data *bridge;\n\tint mask_type;\n\n\tbridge = mem->bridge;\n\tif (!bridge)\n\t\treturn -EINVAL;\n\n\tif (mem->page_count == 0)\n\t\treturn 0;\n\n\ttemp = bridge->current_size;\n\n\tswitch (bridge->driver->size_type) {\n\tcase U8_APER_SIZE:\n\t\tnum_entries = A_SIZE_8(temp)->num_entries;\n\t\tbreak;\n\tcase U16_APER_SIZE:\n\t\tnum_entries = A_SIZE_16(temp)->num_entries;\n\t\tbreak;\n\tcase U32_APER_SIZE:\n\t\tnum_entries = A_SIZE_32(temp)->num_entries;\n\t\tbreak;\n\tcase FIXED_APER_SIZE:\n\t\tnum_entries = A_SIZE_FIX(temp)->num_entries;\n\t\tbreak;\n\tcase LVL2_APER_SIZE:\n\t\t/* The generic routines can't deal with 2 level gatt's */\n\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\tnum_entries = 0;\n\t\tbreak;\n\t}\n\n\tnum_entries -= agp_memory_reserved/PAGE_SIZE;\n\tif (num_entries < 0) num_entries = 0;\n\n\tif (type != mem->type)\n\t\treturn -EINVAL;\n\n\tmask_type = bridge->driver->agp_type_to_mask_type(bridge, type);\n\tif (mask_type != 0) {\n\t\t/* The generic routines know nothing of memory types */\n\t\treturn -EINVAL;\n\t}\n\n\tif (((pg_start + mem->page_count) > num_entries) ||\n\t    ((pg_start + mem->page_count) < pg_start))\n\t\treturn -EINVAL;\n\n\tj = pg_start;\n\n\twhile (j < (pg_start + mem->page_count)) {\n\t\tif (!PGE_EMPTY(bridge, readl(bridge->gatt_table+j)))\n\t\t\treturn -EBUSY;\n\t\tj++;\n\t}\n\n\tif (!mem->is_flushed) {\n\t\tbridge->driver->cache_flush();\n\t\tmem->is_flushed = true;\n\t}\n\n\tfor (i = 0, j = pg_start; i < mem->page_count; i++, j++) {\n\t\twritel(bridge->driver->mask_memory(bridge,\n\t\t\t\t\t\t   page_to_phys(mem->pages[i]),\n\t\t\t\t\t\t   mask_type),\n\t\t       bridge->gatt_table+j);\n\t}\n\treadl(bridge->gatt_table+j-1);\t/* PCI Posting. */\n\n\tbridge->driver->tlb_flush(mem);\n\treturn 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147629,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "check_offset(char *memory, int total_size, char *name, void *offset, int size)\n{\n\tptrdiff_t need_size = (char *) offset - memory + size;\n\n\t/*debug(\"check_offset: size=%x vs %x offset=%x size=%x\\n\",\n\t\tneed_size, total_size, (char *) offset - memory, size);*/\n\n\tif (need_size < 0 || need_size > total_size) {\n\t\twarn(_(\"%s: premature end\"), name);\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147654,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "check_offset(char *memory, int total_size, char *name, void *offset, int size)\n{\n\tchar* memory_end = memory + total_size;\n\tchar* block = (char*)offset;\n\tchar* block_end = offset + size;\n\n\t/*debug(\"check_offset: size=%x vs %x offset=%x size=%x\\n\",\n\t\tneed_size, total_size, (char *) offset - memory, size);*/\n\n\tif (((memory <= memory_end) && (block <= block_end))\n\t\t&& ((block < memory) || (block >= memory_end) || (block_end > memory_end))) {\n\t\twarn(_(\"%s: premature end\"), name);\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147655,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "extract_group_icon_cursor_resource(WinLibrary *fi, WinResource *wr, char *lang,\n                                   int *ressize, bool is_icon)\n{\n\tWin32CursorIconDir *icondir;\n\tWin32CursorIconFileDir *fileicondir;\n\tchar *memory;\n\tint c, size, offset, skipped;\n\n\t/* get resource data and size */\n\ticondir = (Win32CursorIconDir *) get_resource_entry(fi, wr, &size);\n\tif (icondir == NULL) {\n\t\t/* get_resource_entry will print error */\n\t\treturn NULL;\n\t}\n\n\t/* calculate total size of output file */\n\tRETURN_IF_BAD_POINTER(NULL, icondir->count);\n\tskipped = 0;\n\tfor (c = 0 ; c < icondir->count ; c++) {\n\t\tint level;\n\t    \tint iconsize;\n\t\tchar name[14];\n\t\tWinResource *fwr;\n\n\t\tRETURN_IF_BAD_POINTER(NULL, icondir->entries[c]);\n\t\t/*printf(\"%d. bytes_in_res=%d width=%d height=%d planes=%d bit_count=%d\\n\", c,\n\t\t\ticondir->entries[c].bytes_in_res,\n\t\t\t(is_icon ? icondir->entries[c].res_info.icon.width : icondir->entries[c].res_info.cursor.width),\n\t\t\t(is_icon ? icondir->entries[c].res_info.icon.height : icondir->entries[c].res_info.cursor.height),\n\t\t\ticondir->entries[c].plane_count,\n\t\t\ticondir->entries[c].bit_count);*/\n\n\t\t/* find the corresponding icon resource */\n\t\tsnprintf(name, sizeof(name)/sizeof(char), \"-%d\", icondir->entries[c].res_id);\n\t\tfwr = find_resource(fi, (is_icon ? \"-3\" : \"-1\"), name, lang, &level);\n\t\tif (fwr == NULL) {\n\t\t\twarn(_(\"%s: could not find `%s' in `%s' resource.\"),\n\t\t\t \tfi->name, &name[1], (is_icon ? \"group_icon\" : \"group_cursor\"));\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (get_resource_entry(fi, fwr, &iconsize) != NULL) {\n\t\t    if (iconsize == 0) {\n\t\t\twarn(_(\"%s: icon resource `%s' is empty, skipping\"), fi->name, name);\n\t\t\tskipped++;\n\t\t\tcontinue;\n\t\t    }\n\t\t    if (iconsize != icondir->entries[c].bytes_in_res) {\n\t\t\twarn(_(\"%s: mismatch of size in icon resource `%s' and group (%d vs %d)\"), fi->name, name, iconsize, icondir->entries[c].bytes_in_res);\n\t\t    }\n\t\t    size += iconsize < icondir->entries[c].bytes_in_res ? icondir->entries[c].bytes_in_res : iconsize;\n\n\t\t    /* cursor resources have two additional WORDs that contain\n\t\t     * hotspot info */\n\t\t    if (!is_icon)\n\t\t\tsize -= sizeof(uint16_t)*2;\n\t\t}\n\t}\n\toffset = sizeof(Win32CursorIconFileDir) + (icondir->count-skipped) * sizeof(Win32CursorIconFileDirEntry);\n\tsize += offset;\n\t*ressize = size;\n\n\t/* allocate that much memory */\n\tmemory = xmalloc(size);\n\tfileicondir = (Win32CursorIconFileDir *) memory;\n\n\t/* transfer Win32CursorIconDir structure members */\n\tfileicondir->reserved = icondir->reserved;\n\tfileicondir->type = icondir->type;\n\tfileicondir->count = icondir->count - skipped;\n\n\t/* transfer each cursor/icon: Win32CursorIconDirEntry and data */\n\tskipped = 0;\n\tfor (c = 0 ; c < icondir->count ; c++) {\n\t\tint level;\n\t\tchar name[14];\n\t\tWinResource *fwr;\n\t\tchar *data;\n\t\n\t\t/* find the corresponding icon resource */\n\t\tsnprintf(name, sizeof(name)/sizeof(char), \"-%d\", icondir->entries[c].res_id);\n\t\tfwr = find_resource(fi, (is_icon ? \"-3\" : \"-1\"), name, lang, &level);\n\t\tif (fwr == NULL) {\n\t\t\twarn(_(\"%s: could not find `%s' in `%s' resource.\"),\n\t\t\t \tfi->name, &name[1], (is_icon ? \"group_icon\" : \"group_cursor\"));\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/* get data and size of that resource */\n\t\tdata = get_resource_entry(fi, fwr, &size);\n\t\tif (data == NULL) {\n\t\t\t/* get_resource_entry has printed error */\n\t\t\treturn NULL;\n\t\t}\n    \t    \tif (size == 0) {\n\t\t    skipped++;\n\t\t    continue;\n\t\t}\n\n\t\t/* copy ICONDIRENTRY (not including last dwImageOffset) */\n\t\tmemcpy(&fileicondir->entries[c-skipped], &icondir->entries[c],\n\t\t\tsizeof(Win32CursorIconFileDirEntry)-sizeof(uint32_t));\n\n\t\t/* special treatment for cursors */\n\t\tif (!is_icon) {\n\t\t\tfileicondir->entries[c-skipped].width = icondir->entries[c].res_info.cursor.width;\n\t\t\tfileicondir->entries[c-skipped].height = icondir->entries[c].res_info.cursor.height / 2;\n\t\t\tfileicondir->entries[c-skipped].color_count = 0;\n\t\t\tfileicondir->entries[c-skipped].reserved = 0;\n\t\t}\n\n\t\t/* set image offset and increase it */\n\t\tfileicondir->entries[c-skipped].dib_offset = offset;\n\n\t\t/* transfer resource into file memory */\n\t\tif (size > icondir->entries[c].bytes_in_res)\n\t\t\tsize = icondir->entries[c].bytes_in_res;\n\t\tif (is_icon) {\n\t\t\tmemcpy(&memory[offset], data, size);\n\t\t} else {\n\t\t\tfileicondir->entries[c-skipped].hotspot_x = ((uint16_t *) data)[0];\n\t\t\tfileicondir->entries[c-skipped].hotspot_y = ((uint16_t *) data)[1];\n\t\t\tmemcpy(&memory[offset], data+sizeof(uint16_t)*2,\n\t\t\t\t   size-sizeof(uint16_t)*2);\n\t\t\toffset -= sizeof(uint16_t)*2;\n\t\t}\n\n\t\t/* increase the offset pointer */\n\t\toffset += icondir->entries[c].bytes_in_res;\n\t}\n\n\treturn (void *) memory;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147656,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "extract_group_icon_cursor_resource(WinLibrary *fi, WinResource *wr, char *lang,\n                                   int *ressize, bool is_icon)\n{\n\tWin32CursorIconDir *icondir;\n\tWin32CursorIconFileDir *fileicondir;\n\tchar *memory;\n\tint c, size, offset, skipped;\n\n\t/* get resource data and size */\n\ticondir = (Win32CursorIconDir *) get_resource_entry(fi, wr, &size);\n\tif (icondir == NULL) {\n\t\t/* get_resource_entry will print error */\n\t\treturn NULL;\n\t}\n\n\t/* calculate total size of output file */\n\tRETURN_IF_BAD_POINTER(NULL, icondir->count);\n\tskipped = 0;\n\tfor (c = 0 ; c < icondir->count ; c++) {\n\t\tint level;\n\t    \tint iconsize;\n\t\tchar name[14];\n\t\tWinResource *fwr;\n\n\t\tRETURN_IF_BAD_POINTER(NULL, icondir->entries[c]);\n\t\t/*printf(\"%d. bytes_in_res=%d width=%d height=%d planes=%d bit_count=%d\\n\", c,\n\t\t\ticondir->entries[c].bytes_in_res,\n\t\t\t(is_icon ? icondir->entries[c].res_info.icon.width : icondir->entries[c].res_info.cursor.width),\n\t\t\t(is_icon ? icondir->entries[c].res_info.icon.height : icondir->entries[c].res_info.cursor.height),\n\t\t\ticondir->entries[c].plane_count,\n\t\t\ticondir->entries[c].bit_count);*/\n\n\t\t/* find the corresponding icon resource */\n\t\tsnprintf(name, sizeof(name)/sizeof(char), \"-%d\", icondir->entries[c].res_id);\n\t\tfwr = find_resource(fi, (is_icon ? \"-3\" : \"-1\"), name, lang, &level);\n\t\tif (fwr == NULL) {\n\t\t\twarn(_(\"%s: could not find `%s' in `%s' resource.\"),\n\t\t\t \tfi->name, &name[1], (is_icon ? \"group_icon\" : \"group_cursor\"));\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (get_resource_entry(fi, fwr, &iconsize) != NULL) {\n\t\t    if (iconsize == 0) {\n\t\t\twarn(_(\"%s: icon resource `%s' is empty, skipping\"), fi->name, name);\n\t\t\tskipped++;\n\t\t\tcontinue;\n\t\t    }\n\t\t    if (iconsize != icondir->entries[c].bytes_in_res) {\n\t\t\twarn(_(\"%s: mismatch of size in icon resource `%s' and group (%d vs %d)\"), fi->name, name, iconsize, icondir->entries[c].bytes_in_res);\n\t\t    }\n\t\t    size += iconsize < icondir->entries[c].bytes_in_res ? icondir->entries[c].bytes_in_res : iconsize;\n\n\t\t    /* cursor resources have two additional WORDs that contain\n\t\t     * hotspot info */\n\t\t    if (!is_icon)\n\t\t\tsize -= sizeof(uint16_t)*2;\n\t\t}\n\t}\n\toffset = sizeof(Win32CursorIconFileDir) + (icondir->count-skipped) * sizeof(Win32CursorIconFileDirEntry);\n\tsize += offset;\n\t*ressize = size;\n\n\t/* allocate that much memory */\n\tmemory = xmalloc(size);\n\tfileicondir = (Win32CursorIconFileDir *) memory;\n\n\t/* transfer Win32CursorIconDir structure members */\n\tfileicondir->reserved = icondir->reserved;\n\tfileicondir->type = icondir->type;\n\tfileicondir->count = icondir->count - skipped;\n\n\t/* transfer each cursor/icon: Win32CursorIconDirEntry and data */\n\tskipped = 0;\n\tfor (c = 0 ; c < icondir->count ; c++) {\n\t\tint level;\n\t\tchar name[14];\n\t\tWinResource *fwr;\n\t\tchar *data;\n\t\n\t\t/* find the corresponding icon resource */\n\t\tsnprintf(name, sizeof(name)/sizeof(char), \"-%d\", icondir->entries[c].res_id);\n\t\tfwr = find_resource(fi, (is_icon ? \"-3\" : \"-1\"), name, lang, &level);\n\t\tif (fwr == NULL) {\n\t\t\twarn(_(\"%s: could not find `%s' in `%s' resource.\"),\n\t\t\t \tfi->name, &name[1], (is_icon ? \"group_icon\" : \"group_cursor\"));\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/* get data and size of that resource */\n\t\tdata = get_resource_entry(fi, fwr, &size);\n\t\tif (data == NULL) {\n\t\t\t/* get_resource_entry has printed error */\n\t\t\treturn NULL;\n\t\t}\n    \t    \tif (size == 0) {\n\t\t    skipped++;\n\t\t    continue;\n\t\t}\n\n\t\t/* copy ICONDIRENTRY (not including last dwImageOffset) */\n\t\tmemcpy(&fileicondir->entries[c-skipped], &icondir->entries[c],\n\t\t\tsizeof(Win32CursorIconFileDirEntry)-sizeof(uint32_t));\n\n\t\t/* special treatment for cursors */\n\t\tif (!is_icon) {\n\t\t\tfileicondir->entries[c-skipped].width = icondir->entries[c].res_info.cursor.width;\n\t\t\tfileicondir->entries[c-skipped].height = icondir->entries[c].res_info.cursor.height / 2;\n\t\t\tfileicondir->entries[c-skipped].color_count = 0;\n\t\t\tfileicondir->entries[c-skipped].reserved = 0;\n\t\t}\n\n\t\t/* set image offset and increase it */\n\t\tfileicondir->entries[c-skipped].dib_offset = offset;\n\n\t\t/* transfer resource into file memory */\n\t\tif (size > icondir->entries[c-skipped].bytes_in_res)\n\t\t\tsize = icondir->entries[c-skipped].bytes_in_res;\n\t\tif (is_icon) {\n\t\t\tmemcpy(&memory[offset], data, size);\n\t\t} else if (size >= sizeof(uint16_t)*2) {\n\t\t\tfileicondir->entries[c-skipped].hotspot_x = ((uint16_t *) data)[0];\n\t\t\tfileicondir->entries[c-skipped].hotspot_y = ((uint16_t *) data)[1];\n\t\t\tmemcpy(&memory[offset], data+sizeof(uint16_t)*2,\n\t\t\t\t   size-sizeof(uint16_t)*2);\n\t\t\toffset -= sizeof(uint16_t)*2;\n\t\t}\n\n\t\t/* increase the offset pointer */\n\t\toffset += icondir->entries[c].bytes_in_res;\n\t}\n\n\treturn (void *) memory;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147657,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "int EVP_DecryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,\n                      const unsigned char *in, int inl)\n{\n    int fix_len, cmpl = inl;\n    unsigned int b;\n\n    /* Prevent accidental use of encryption context when decrypting */\n    if (ctx->encrypt) {\n        EVPerr(EVP_F_EVP_DECRYPTUPDATE, EVP_R_INVALID_OPERATION);\n        return 0;\n    }\n\n    b = ctx->cipher->block_size;\n\n    if (EVP_CIPHER_CTX_test_flags(ctx, EVP_CIPH_FLAG_LENGTH_BITS))\n        cmpl = (cmpl + 7) / 8;\n\n    /*\n     * CCM mode needs to know about the case where inl == 0 - it means the\n     * plaintext/ciphertext length is 0\n     */\n    if (inl < 0\n            || (inl == 0\n                && EVP_CIPHER_mode(ctx->cipher) != EVP_CIPH_CCM_MODE)) {\n        *outl = 0;\n        return inl == 0;\n    }\n\n    if (ctx->cipher->flags & EVP_CIPH_FLAG_CUSTOM_CIPHER) {\n        if (b == 1 && is_partially_overlapping(out, in, cmpl)) {\n            EVPerr(EVP_F_EVP_DECRYPTUPDATE, EVP_R_PARTIALLY_OVERLAPPING);\n            return 0;\n        }\n\n        fix_len = ctx->cipher->do_cipher(ctx, out, in, inl);\n        if (fix_len < 0) {\n            *outl = 0;\n            return 0;\n        } else\n            *outl = fix_len;\n        return 1;\n    }\n\n    if (ctx->flags & EVP_CIPH_NO_PADDING)\n        return evp_EncryptDecryptUpdate(ctx, out, outl, in, inl);\n\n    OPENSSL_assert(b <= sizeof(ctx->final));\n\n    if (ctx->final_used) {\n        /* see comment about PTRDIFF_T comparison above */\n        if (((PTRDIFF_T)out == (PTRDIFF_T)in)\n            || is_partially_overlapping(out, in, b)) {\n            EVPerr(EVP_F_EVP_DECRYPTUPDATE, EVP_R_PARTIALLY_OVERLAPPING);\n            return 0;\n        }\n        memcpy(out, ctx->final, b);\n        out += b;\n        fix_len = 1;\n    } else\n        fix_len = 0;\n\n    if (!evp_EncryptDecryptUpdate(ctx, out, outl, in, inl))\n        return 0;\n\n    /*\n     * if we have 'decrypted' a multiple of block size, make sure we have a\n     * copy of this last block\n     */\n    if (b > 1 && !ctx->buf_len) {\n        *outl -= b;\n        ctx->final_used = 1;\n        memcpy(ctx->final, &out[*outl], b);\n    } else\n        ctx->final_used = 0;\n\n    if (fix_len)\n        *outl += b;\n\n    return 1;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147796,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "int EVP_DecryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,\n                      const unsigned char *in, int inl)\n{\n    int fix_len, cmpl = inl;\n    unsigned int b;\n\n    /* Prevent accidental use of encryption context when decrypting */\n    if (ctx->encrypt) {\n        EVPerr(EVP_F_EVP_DECRYPTUPDATE, EVP_R_INVALID_OPERATION);\n        return 0;\n    }\n\n    b = ctx->cipher->block_size;\n\n    if (EVP_CIPHER_CTX_test_flags(ctx, EVP_CIPH_FLAG_LENGTH_BITS))\n        cmpl = (cmpl + 7) / 8;\n\n    /*\n     * CCM mode needs to know about the case where inl == 0 - it means the\n     * plaintext/ciphertext length is 0\n     */\n    if (inl < 0\n            || (inl == 0\n                && EVP_CIPHER_mode(ctx->cipher) != EVP_CIPH_CCM_MODE)) {\n        *outl = 0;\n        return inl == 0;\n    }\n\n    if (ctx->cipher->flags & EVP_CIPH_FLAG_CUSTOM_CIPHER) {\n        if (b == 1 && is_partially_overlapping(out, in, cmpl)) {\n            EVPerr(EVP_F_EVP_DECRYPTUPDATE, EVP_R_PARTIALLY_OVERLAPPING);\n            return 0;\n        }\n\n        fix_len = ctx->cipher->do_cipher(ctx, out, in, inl);\n        if (fix_len < 0) {\n            *outl = 0;\n            return 0;\n        } else\n            *outl = fix_len;\n        return 1;\n    }\n\n    if (ctx->flags & EVP_CIPH_NO_PADDING)\n        return evp_EncryptDecryptUpdate(ctx, out, outl, in, inl);\n\n    OPENSSL_assert(b <= sizeof(ctx->final));\n\n    if (ctx->final_used) {\n        /* see comment about PTRDIFF_T comparison above */\n        if (((PTRDIFF_T)out == (PTRDIFF_T)in)\n            || is_partially_overlapping(out, in, b)) {\n            EVPerr(EVP_F_EVP_DECRYPTUPDATE, EVP_R_PARTIALLY_OVERLAPPING);\n            return 0;\n        }\n        /*\n         * final_used is only ever set if buf_len is 0. Therefore the maximum\n         * length output we will ever see from evp_EncryptDecryptUpdate is\n         * the maximum multiple of the block length that is <= inl, or just:\n         * inl & ~(b - 1)\n         * Since final_used has been set then the final output length is:\n         * (inl & ~(b - 1)) + b\n         * This must never exceed INT_MAX\n         */\n        if ((inl & ~(b - 1)) > INT_MAX - b) {\n            EVPerr(EVP_F_EVP_DECRYPTUPDATE, EVP_R_OUTPUT_WOULD_OVERFLOW);\n            return 0;\n        }\n        memcpy(out, ctx->final, b);\n        out += b;\n        fix_len = 1;\n    } else\n        fix_len = 0;\n\n    if (!evp_EncryptDecryptUpdate(ctx, out, outl, in, inl))\n        return 0;\n\n    /*\n     * if we have 'decrypted' a multiple of block size, make sure we have a\n     * copy of this last block\n     */\n    if (b > 1 && !ctx->buf_len) {\n        *outl -= b;\n        ctx->final_used = 1;\n        memcpy(ctx->final, &out[*outl], b);\n    } else\n        ctx->final_used = 0;\n\n    if (fix_len)\n        *outl += b;\n\n    return 1;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147797,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "String preg_quote(const String& str,\n                  const String& delimiter /* = null_string */) {\n  const char* in_str = str.data();\n  const char* in_str_end = in_str + str.size();\n\n  /* Nothing to do if we got an empty string */\n  if (in_str == in_str_end) {\n    return str;\n  }\n\n  char delim_char = 0;      /* Delimiter character to be quoted */\n  bool quote_delim = false; /* Whether to quote additional delim char */\n  if (!delimiter.empty()) {\n    delim_char = delimiter.charAt(0);\n    quote_delim = true;\n  }\n\n  /* Allocate enough memory so that even if each character\n     is quoted, we won't run out of room */\n  String ret(4 * str.size() + 1, ReserveString);\n  char* out_str = ret.mutableData();\n\n  /* Go through the string and quote necessary characters */\n  const char* p;\n  char* q;\n  for (p = in_str, q = out_str; p != in_str_end; p++) {\n    char c = *p;\n    switch (c) {\n    case '.': case '\\\\': case '+': case '*': case '?':\n    case '[': case '^':  case ']': case '$': case '(':\n    case ')': case '{':  case '}': case '=': case '!':\n    case '>': case '<':  case '|': case ':': case '-':\n    case '#':\n      *q++ = '\\\\';\n      *q++ = c;\n      break;\n\n    case '\\0':\n      *q++ = '\\\\';\n      *q++ = '0';\n      *q++ = '0';\n      *q++ = '0';\n      break;\n\n    default:\n      if (quote_delim && c == delim_char)\n        *q++ = '\\\\';\n      *q++ = c;\n      break;\n    }\n  }\n  *q = '\\0';\n\n  return ret.setSize(q - out_str);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147882,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "String preg_quote(const String& str,\n                  const String& delimiter /* = null_string */) {\n  const char* in_str = str.data();\n  const char* in_str_end = in_str + str.size();\n\n  /* Nothing to do if we got an empty string */\n  if (in_str == in_str_end) {\n    return str;\n  }\n\n  char delim_char = 0;      /* Delimiter character to be quoted */\n  bool quote_delim = false; /* Whether to quote additional delim char */\n  if (!delimiter.empty()) {\n    delim_char = delimiter.charAt(0);\n    quote_delim = true;\n  }\n\n  /* Allocate enough memory so that even if each character\n     is quoted, we won't run out of room */\n  static_assert(\n    (StringData::MaxSize * 4 + 1) < std::numeric_limits<int64_t>::max()\n  );\n  String ret(4 * str.size() + 1, ReserveString);\n  char* out_str = ret.mutableData();\n\n  /* Go through the string and quote necessary characters */\n  const char* p;\n  char* q;\n  for (p = in_str, q = out_str; p != in_str_end; p++) {\n    char c = *p;\n    switch (c) {\n    case '.': case '\\\\': case '+': case '*': case '?':\n    case '[': case '^':  case ']': case '$': case '(':\n    case ')': case '{':  case '}': case '=': case '!':\n    case '>': case '<':  case '|': case ':': case '-':\n    case '#':\n      *q++ = '\\\\';\n      *q++ = c;\n      break;\n\n    case '\\0':\n      *q++ = '\\\\';\n      *q++ = '0';\n      *q++ = '0';\n      *q++ = '0';\n      break;\n\n    default:\n      if (quote_delim && c == delim_char)\n        *q++ = '\\\\';\n      *q++ = c;\n      break;\n    }\n  }\n  *q = '\\0';\n\n  return ret.setSize(q - out_str);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147883,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static int xbuf_format_converter(char **outbuf, const char *fmt, va_list ap)\n{\n  register char *s = nullptr;\n  char *q;\n  int s_len;\n\n  register int min_width = 0;\n  int precision = 0;\n  enum {\n    LEFT, RIGHT\n  } adjust;\n  char pad_char;\n  char prefix_char;\n\n  double fp_num;\n  wide_int i_num = (wide_int) 0;\n  u_wide_int ui_num;\n\n  char num_buf[NUM_BUF_SIZE];\n  char char_buf[2];      /* for printing %% and %<unknown> */\n\n#ifdef HAVE_LOCALE_H\n  struct lconv *lconv = nullptr;\n#endif\n\n  /*\n   * Flag variables\n   */\n  length_modifier_e modifier;\n  boolean_e alternate_form;\n  boolean_e print_sign;\n  boolean_e print_blank;\n  boolean_e adjust_precision;\n  boolean_e adjust_width;\n  int is_negative;\n\n  int size = 240;\n  char *result = (char *)malloc(size);\n  int outpos = 0;\n\n  while (*fmt) {\n    if (*fmt != '%') {\n      appendchar(&result, &outpos, &size, *fmt);\n    } else {\n      /*\n       * Default variable settings\n       */\n      adjust = RIGHT;\n      alternate_form = print_sign = print_blank = NO;\n      pad_char = ' ';\n      prefix_char = NUL;\n\n      fmt++;\n\n      /*\n       * Try to avoid checking for flags, width or precision\n       */\n      if (isascii((int)*fmt) && !islower((int)*fmt)) {\n        /*\n         * Recognize flags: -, #, BLANK, +\n         */\n        for (;; fmt++) {\n          if (*fmt == '-')\n            adjust = LEFT;\n          else if (*fmt == '+')\n            print_sign = YES;\n          else if (*fmt == '#')\n            alternate_form = YES;\n          else if (*fmt == ' ')\n            print_blank = YES;\n          else if (*fmt == '0')\n            pad_char = '0';\n          else\n            break;\n        }\n\n        /*\n         * Check if a width was specified\n         */\n        if (isdigit((int)*fmt)) {\n          STR_TO_DEC(fmt, min_width);\n          adjust_width = YES;\n        } else if (*fmt == '*') {\n          min_width = va_arg(ap, int);\n          fmt++;\n          adjust_width = YES;\n          if (min_width < 0) {\n            adjust = LEFT;\n            min_width = -min_width;\n          }\n        } else\n          adjust_width = NO;\n\n        /*\n         * Check if a precision was specified\n         *\n         * XXX: an unreasonable amount of precision may be specified\n         * resulting in overflow of num_buf. Currently we\n         * ignore this possibility.\n         */\n        if (*fmt == '.') {\n          adjust_precision = YES;\n          fmt++;\n          if (isdigit((int)*fmt)) {\n            STR_TO_DEC(fmt, precision);\n          } else if (*fmt == '*') {\n            precision = va_arg(ap, int);\n            fmt++;\n            if (precision < 0)\n              precision = 0;\n          } else\n            precision = 0;\n        } else\n          adjust_precision = NO;\n      } else\n        adjust_precision = adjust_width = NO;\n\n      /*\n       * Modifier check\n       */\n      switch (*fmt) {\n        case 'L':\n          fmt++;\n          modifier = LM_LONG_DOUBLE;\n          break;\n        case 'I':\n          fmt++;\n#if SIZEOF_LONG_LONG\n          if (*fmt == '6' && *(fmt+1) == '4') {\n            fmt += 2;\n            modifier = LM_LONG_LONG;\n          } else\n#endif\n            if (*fmt == '3' && *(fmt+1) == '2') {\n              fmt += 2;\n              modifier = LM_LONG;\n            } else {\n#ifdef _WIN64\n              modifier = LM_LONG_LONG;\n#else\n              modifier = LM_LONG;\n#endif\n            }\n          break;\n        case 'l':\n          fmt++;\n#if SIZEOF_LONG_LONG\n          if (*fmt == 'l') {\n            fmt++;\n            modifier = LM_LONG_LONG;\n          } else\n#endif\n            modifier = LM_LONG;\n          break;\n        case 'z':\n          fmt++;\n          modifier = LM_SIZE_T;\n          break;\n        case 'j':\n          fmt++;\n#if SIZEOF_INTMAX_T\n          modifier = LM_INTMAX_T;\n#else\n          modifier = LM_SIZE_T;\n#endif\n          break;\n        case 't':\n          fmt++;\n#if SIZEOF_PTRDIFF_T\n          modifier = LM_PTRDIFF_T;\n#else\n          modifier = LM_SIZE_T;\n#endif\n          break;\n        case 'h':\n          fmt++;\n          if (*fmt == 'h') {\n            fmt++;\n          }\n          /* these are promoted to int, so no break */\n        default:\n          modifier = LM_STD;\n          break;\n      }\n\n      /*\n       * Argument extraction and printing.\n       * First we determine the argument type.\n       * Then, we convert the argument to a string.\n       * On exit from the switch, s points to the string that\n       * must be printed, s_len has the length of the string\n       * The precision requirements, if any, are reflected in s_len.\n       *\n       * NOTE: pad_char may be set to '0' because of the 0 flag.\n       *   It is reset to ' ' by non-numeric formats\n       */\n      switch (*fmt) {\n        case 'u':\n          switch(modifier) {\n            default:\n              i_num = (wide_int) va_arg(ap, unsigned int);\n              break;\n            case LM_LONG_DOUBLE:\n              goto fmt_error;\n            case LM_LONG:\n              i_num = (wide_int) va_arg(ap, unsigned long int);\n              break;\n            case LM_SIZE_T:\n              i_num = (wide_int) va_arg(ap, size_t);\n              break;\n#if SIZEOF_LONG_LONG\n            case LM_LONG_LONG:\n              i_num = (wide_int) va_arg(ap, u_wide_int);\n              break;\n#endif\n#if SIZEOF_INTMAX_T\n            case LM_INTMAX_T:\n              i_num = (wide_int) va_arg(ap, uintmax_t);\n              break;\n#endif\n#if SIZEOF_PTRDIFF_T\n            case LM_PTRDIFF_T:\n              i_num = (wide_int) va_arg(ap, ptrdiff_t);\n              break;\n#endif\n          }\n          /*\n           * The rest also applies to other integer formats, so fall\n           * into that case.\n           */\n        case 'd':\n        case 'i':\n          /*\n           * Get the arg if we haven't already.\n           */\n          if ((*fmt) != 'u') {\n            switch(modifier) {\n              default:\n                i_num = (wide_int) va_arg(ap, int);\n                break;\n              case LM_LONG_DOUBLE:\n                goto fmt_error;\n              case LM_LONG:\n                i_num = (wide_int) va_arg(ap, long int);\n                break;\n              case LM_SIZE_T:\n#if SIZEOF_SSIZE_T\n                i_num = (wide_int) va_arg(ap, ssize_t);\n#else\n                i_num = (wide_int) va_arg(ap, size_t);\n#endif\n                break;\n#if SIZEOF_LONG_LONG\n              case LM_LONG_LONG:\n                i_num = (wide_int) va_arg(ap, wide_int);\n                break;\n#endif\n#if SIZEOF_INTMAX_T\n              case LM_INTMAX_T:\n                i_num = (wide_int) va_arg(ap, intmax_t);\n                break;\n#endif\n#if SIZEOF_PTRDIFF_T\n              case LM_PTRDIFF_T:\n                i_num = (wide_int) va_arg(ap, ptrdiff_t);\n                break;\n#endif\n            }\n          }\n          s = ap_php_conv_10(i_num, (*fmt) == 'u', &is_negative,\n                &num_buf[NUM_BUF_SIZE], &s_len);\n          FIX_PRECISION(adjust_precision, precision, s, s_len);\n\n          if (*fmt != 'u') {\n            if (is_negative)\n              prefix_char = '-';\n            else if (print_sign)\n              prefix_char = '+';\n            else if (print_blank)\n              prefix_char = ' ';\n          }\n          break;\n\n\n        case 'o':\n          switch(modifier) {\n            default:\n              ui_num = (u_wide_int) va_arg(ap, unsigned int);\n              break;\n            case LM_LONG_DOUBLE:\n              goto fmt_error;\n            case LM_LONG:\n              ui_num = (u_wide_int) va_arg(ap, unsigned long int);\n              break;\n            case LM_SIZE_T:\n              ui_num = (u_wide_int) va_arg(ap, size_t);\n              break;\n#if SIZEOF_LONG_LONG\n            case LM_LONG_LONG:\n              ui_num = (u_wide_int) va_arg(ap, u_wide_int);\n              break;\n#endif\n#if SIZEOF_INTMAX_T\n            case LM_INTMAX_T:\n              ui_num = (u_wide_int) va_arg(ap, uintmax_t);\n              break;\n#endif\n#if SIZEOF_PTRDIFF_T\n            case LM_PTRDIFF_T:\n              ui_num = (u_wide_int) va_arg(ap, ptrdiff_t);\n              break;\n#endif\n          }\n          s = ap_php_conv_p2(ui_num, 3, *fmt,\n                &num_buf[NUM_BUF_SIZE], &s_len);\n          FIX_PRECISION(adjust_precision, precision, s, s_len);\n          if (alternate_form && *s != '0') {\n            *--s = '0';\n            s_len++;\n          }\n          break;\n\n\n        case 'x':\n        case 'X':\n          switch(modifier) {\n            default:\n              ui_num = (u_wide_int) va_arg(ap, unsigned int);\n              break;\n            case LM_LONG_DOUBLE:\n              goto fmt_error;\n            case LM_LONG:\n              ui_num = (u_wide_int) va_arg(ap, unsigned long int);\n              break;\n            case LM_SIZE_T:\n              ui_num = (u_wide_int) va_arg(ap, size_t);\n              break;\n#if SIZEOF_LONG_LONG\n            case LM_LONG_LONG:\n              ui_num = (u_wide_int) va_arg(ap, u_wide_int);\n              break;\n#endif\n#if SIZEOF_INTMAX_T\n            case LM_INTMAX_T:\n              ui_num = (u_wide_int) va_arg(ap, uintmax_t);\n              break;\n#endif\n#if SIZEOF_PTRDIFF_T\n            case LM_PTRDIFF_T:\n              ui_num = (u_wide_int) va_arg(ap, ptrdiff_t);\n              break;\n#endif\n          }\n          s = ap_php_conv_p2(ui_num, 4, *fmt,\n                &num_buf[NUM_BUF_SIZE], &s_len);\n          FIX_PRECISION(adjust_precision, precision, s, s_len);\n          if (alternate_form && i_num != 0) {\n            *--s = *fmt;  /* 'x' or 'X' */\n            *--s = '0';\n            s_len += 2;\n          }\n          break;\n\n\n        case 's':\n        case 'v':\n          s = va_arg(ap, char *);\n          if (s != nullptr) {\n            s_len = strlen(s);\n            if (adjust_precision && precision < s_len)\n              s_len = precision;\n          } else {\n            s = const_cast<char*>(s_null);\n            s_len = S_NULL_LEN;\n          }\n          pad_char = ' ';\n          break;\n\n\n        case 'f':\n        case 'F':\n        case 'e':\n        case 'E':\n          switch(modifier) {\n            case LM_LONG_DOUBLE:\n              fp_num = (double) va_arg(ap, long double);\n              break;\n            case LM_STD:\n              fp_num = va_arg(ap, double);\n              break;\n            default:\n              goto fmt_error;\n          }\n\n          if (std::isnan(fp_num)) {\n            s = const_cast<char*>(\"nan\");\n            s_len = 3;\n          } else if (std::isinf(fp_num)) {\n            s = const_cast<char*>(\"inf\");\n            s_len = 3;\n          } else {\n#ifdef HAVE_LOCALE_H\n            if (!lconv) {\n              lconv = localeconv();\n            }\n#endif\n            s = php_conv_fp((*fmt == 'f')?'F':*fmt, fp_num, alternate_form,\n             (adjust_precision == NO) ? FLOAT_DIGITS : precision,\n             (*fmt == 'f')?LCONV_DECIMAL_POINT:'.',\n                  &is_negative, &num_buf[1], &s_len);\n            if (is_negative)\n              prefix_char = '-';\n            else if (print_sign)\n              prefix_char = '+';\n            else if (print_blank)\n              prefix_char = ' ';\n          }\n          break;\n\n\n        case 'g':\n        case 'k':\n        case 'G':\n        case 'H':\n          switch(modifier) {\n            case LM_LONG_DOUBLE:\n              fp_num = (double) va_arg(ap, long double);\n              break;\n            case LM_STD:\n              fp_num = va_arg(ap, double);\n              break;\n            default:\n              goto fmt_error;\n          }\n\n          if (std::isnan(fp_num)) {\n             s = const_cast<char*>(\"NAN\");\n             s_len = 3;\n             break;\n           } else if (std::isinf(fp_num)) {\n             if (fp_num > 0) {\n               s = const_cast<char*>(\"INF\");\n               s_len = 3;\n             } else {\n               s = const_cast<char*>(\"-INF\");\n               s_len = 4;\n             }\n             break;\n           }\n\n          if (adjust_precision == NO)\n            precision = FLOAT_DIGITS;\n          else if (precision == 0)\n            precision = 1;\n          /*\n           * * We use &num_buf[ 1 ], so that we have room for the sign\n           */\n#ifdef HAVE_LOCALE_H\n          if (!lconv) {\n            lconv = localeconv();\n          }\n#endif\n          s = php_gcvt(fp_num, precision,\n                       (*fmt=='H' || *fmt == 'k') ? '.' : LCONV_DECIMAL_POINT,\n                       (*fmt == 'G' || *fmt == 'H')?'E':'e', &num_buf[1]);\n          if (*s == '-')\n            prefix_char = *s++;\n          else if (print_sign)\n            prefix_char = '+';\n          else if (print_blank)\n            prefix_char = ' ';\n\n          s_len = strlen(s);\n\n          if (alternate_form && (q = strchr(s, '.')) == nullptr)\n            s[s_len++] = '.';\n          break;\n\n\n        case 'c':\n          char_buf[0] = (char) (va_arg(ap, int));\n          s = &char_buf[0];\n          s_len = 1;\n          pad_char = ' ';\n          break;\n\n\n        case '%':\n          char_buf[0] = '%';\n          s = &char_buf[0];\n          s_len = 1;\n          pad_char = ' ';\n          break;\n\n\n        case 'n':\n          *(va_arg(ap, int *)) = outpos;\n          goto skip_output;\n\n          /*\n           * Always extract the argument as a \"char *\" pointer. We\n           * should be using \"void *\" but there are still machines\n           * that don't understand it.\n           * If the pointer size is equal to the size of an unsigned\n           * integer we convert the pointer to a hex number, otherwise\n           * we print \"%p\" to indicate that we don't handle \"%p\".\n           */\n        case 'p':\n          if (sizeof(char *) <= sizeof(u_wide_int)) {\n            ui_num = (u_wide_int)((size_t) va_arg(ap, char *));\n            s = ap_php_conv_p2(ui_num, 4, 'x',\n                &num_buf[NUM_BUF_SIZE], &s_len);\n            if (ui_num != 0) {\n              *--s = 'x';\n              *--s = '0';\n              s_len += 2;\n            }\n          } else {\n            s = const_cast<char*>(\"%p\");\n            s_len = 2;\n          }\n          pad_char = ' ';\n          break;\n\n\n        case NUL:\n          /*\n           * The last character of the format string was %.\n           * We ignore it.\n           */\n          continue;\n\n\nfmt_error:\n        throw Exception(\"Illegal length modifier specified '%c'\", *fmt);\n\n          /*\n           * The default case is for unrecognized %'s.\n           * We print %<char> to help the user identify what\n           * option is not understood.\n           * This is also useful in case the user wants to pass\n           * the output of format_converter to another function\n           * that understands some other %<char> (like syslog).\n           * Note that we can't point s inside fmt because the\n           * unknown <char> could be preceded by width etc.\n           */\n        default:\n          char_buf[0] = '%';\n          char_buf[1] = *fmt;\n          s = char_buf;\n          s_len = 2;\n          pad_char = ' ';\n          break;\n      }\n\n      if (prefix_char != NUL) {\n        *--s = prefix_char;\n        s_len++;\n      }\n      if (adjust_width && adjust == RIGHT && min_width > s_len) {\n        if (pad_char == '0' && prefix_char != NUL) {\n          appendchar(&result, &outpos, &size, *s);\n          s++;\n          s_len--;\n          min_width--;\n        }\n        for (int i = 0; i < min_width - s_len; i++) {\n          appendchar(&result, &outpos, &size, pad_char);\n        }\n      }\n      /*\n       * Print the (for now) non-null terminated string s.\n       */\n      appendsimplestring(&result, &outpos, &size, s, s_len);\n\n      if (adjust_width && adjust == LEFT && min_width > s_len) {\n        for (int i = 0; i < min_width - s_len; i++) {\n          appendchar(&result, &outpos, &size, pad_char);\n        }\n      }\n    }\nskip_output:\n    fmt++;\n  }\n  /*\n   * Add the terminating null here since it wasn't added incrementally above\n   * once the whole string has been composed.\n   */\n  result[outpos] = NUL;\n  *outbuf = result;\n  return outpos;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147884,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static int xbuf_format_converter(char **outbuf, const char *fmt, va_list ap)\n{\n  register char *s = nullptr;\n  char *q;\n  int s_len;\n\n  register int min_width = 0;\n  int precision = 0;\n  enum {\n    LEFT, RIGHT\n  } adjust;\n  char pad_char;\n  char prefix_char;\n\n  double fp_num;\n  wide_int i_num = (wide_int) 0;\n  u_wide_int ui_num;\n\n  char num_buf[NUM_BUF_SIZE];\n  char char_buf[2];      /* for printing %% and %<unknown> */\n\n#ifdef HAVE_LOCALE_H\n  struct lconv *lconv = nullptr;\n#endif\n\n  /*\n   * Flag variables\n   */\n  length_modifier_e modifier;\n  boolean_e alternate_form;\n  boolean_e print_sign;\n  boolean_e print_blank;\n  boolean_e adjust_precision;\n  boolean_e adjust_width;\n  int is_negative;\n\n  int size = 240;\n  char *result = (char *)malloc(size);\n  int outpos = 0;\n\n  while (*fmt) {\n    if (*fmt != '%') {\n      appendchar(&result, &outpos, &size, *fmt);\n    } else {\n      /*\n       * Default variable settings\n       */\n      adjust = RIGHT;\n      alternate_form = print_sign = print_blank = NO;\n      pad_char = ' ';\n      prefix_char = NUL;\n\n      fmt++;\n\n      /*\n       * Try to avoid checking for flags, width or precision\n       */\n      if (isascii((int)*fmt) && !islower((int)*fmt)) {\n        /*\n         * Recognize flags: -, #, BLANK, +\n         */\n        for (;; fmt++) {\n          if (*fmt == '-')\n            adjust = LEFT;\n          else if (*fmt == '+')\n            print_sign = YES;\n          else if (*fmt == '#')\n            alternate_form = YES;\n          else if (*fmt == ' ')\n            print_blank = YES;\n          else if (*fmt == '0')\n            pad_char = '0';\n          else\n            break;\n        }\n\n        /*\n         * Check if a width was specified\n         */\n        if (isdigit((int)*fmt)) {\n          STR_TO_DEC(fmt, min_width);\n          adjust_width = YES;\n        } else if (*fmt == '*') {\n          min_width = va_arg(ap, int);\n          fmt++;\n          adjust_width = YES;\n          if (min_width < 0) {\n            adjust = LEFT;\n            min_width = -min_width;\n          }\n        } else\n          adjust_width = NO;\n\n        /*\n         * Check if a precision was specified\n         *\n         * XXX: an unreasonable amount of precision may be specified\n         * resulting in overflow of num_buf. Currently we\n         * ignore this possibility.\n         */\n        if (*fmt == '.') {\n          adjust_precision = YES;\n          fmt++;\n          if (isdigit((int)*fmt)) {\n            STR_TO_DEC(fmt, precision);\n          } else if (*fmt == '*') {\n            precision = va_arg(ap, int);\n            fmt++;\n            if (precision < 0)\n              precision = 0;\n          } else\n            precision = 0;\n        } else\n          adjust_precision = NO;\n      } else\n        adjust_precision = adjust_width = NO;\n\n      /*\n       * Modifier check\n       */\n      switch (*fmt) {\n        case 'L':\n          fmt++;\n          modifier = LM_LONG_DOUBLE;\n          break;\n        case 'I':\n          fmt++;\n#if SIZEOF_LONG_LONG\n          if (*fmt == '6' && *(fmt+1) == '4') {\n            fmt += 2;\n            modifier = LM_LONG_LONG;\n          } else\n#endif\n            if (*fmt == '3' && *(fmt+1) == '2') {\n              fmt += 2;\n              modifier = LM_LONG;\n            } else {\n#ifdef _WIN64\n              modifier = LM_LONG_LONG;\n#else\n              modifier = LM_LONG;\n#endif\n            }\n          break;\n        case 'l':\n          fmt++;\n#if SIZEOF_LONG_LONG\n          if (*fmt == 'l') {\n            fmt++;\n            modifier = LM_LONG_LONG;\n          } else\n#endif\n            modifier = LM_LONG;\n          break;\n        case 'z':\n          fmt++;\n          modifier = LM_SIZE_T;\n          break;\n        case 'j':\n          fmt++;\n#if SIZEOF_INTMAX_T\n          modifier = LM_INTMAX_T;\n#else\n          modifier = LM_SIZE_T;\n#endif\n          break;\n        case 't':\n          fmt++;\n#if SIZEOF_PTRDIFF_T\n          modifier = LM_PTRDIFF_T;\n#else\n          modifier = LM_SIZE_T;\n#endif\n          break;\n        case 'h':\n          fmt++;\n          if (*fmt == 'h') {\n            fmt++;\n          }\n          /* these are promoted to int, so no break */\n        default:\n          modifier = LM_STD;\n          break;\n      }\n\n      /*\n       * Argument extraction and printing.\n       * First we determine the argument type.\n       * Then, we convert the argument to a string.\n       * On exit from the switch, s points to the string that\n       * must be printed, s_len has the length of the string\n       * The precision requirements, if any, are reflected in s_len.\n       *\n       * NOTE: pad_char may be set to '0' because of the 0 flag.\n       *   It is reset to ' ' by non-numeric formats\n       */\n      switch (*fmt) {\n        case 'u':\n          switch(modifier) {\n            default:\n              i_num = (wide_int) va_arg(ap, unsigned int);\n              break;\n            case LM_LONG_DOUBLE:\n              goto fmt_error;\n            case LM_LONG:\n              i_num = (wide_int) va_arg(ap, unsigned long int);\n              break;\n            case LM_SIZE_T:\n              i_num = (wide_int) va_arg(ap, size_t);\n              break;\n#if SIZEOF_LONG_LONG\n            case LM_LONG_LONG:\n              i_num = (wide_int) va_arg(ap, u_wide_int);\n              break;\n#endif\n#if SIZEOF_INTMAX_T\n            case LM_INTMAX_T:\n              i_num = (wide_int) va_arg(ap, uintmax_t);\n              break;\n#endif\n#if SIZEOF_PTRDIFF_T\n            case LM_PTRDIFF_T:\n              i_num = (wide_int) va_arg(ap, ptrdiff_t);\n              break;\n#endif\n          }\n          /*\n           * The rest also applies to other integer formats, so fall\n           * into that case.\n           */\n        case 'd':\n        case 'i':\n          /*\n           * Get the arg if we haven't already.\n           */\n          if ((*fmt) != 'u') {\n            switch(modifier) {\n              default:\n                i_num = (wide_int) va_arg(ap, int);\n                break;\n              case LM_LONG_DOUBLE:\n                goto fmt_error;\n              case LM_LONG:\n                i_num = (wide_int) va_arg(ap, long int);\n                break;\n              case LM_SIZE_T:\n#if SIZEOF_SSIZE_T\n                i_num = (wide_int) va_arg(ap, ssize_t);\n#else\n                i_num = (wide_int) va_arg(ap, size_t);\n#endif\n                break;\n#if SIZEOF_LONG_LONG\n              case LM_LONG_LONG:\n                i_num = (wide_int) va_arg(ap, wide_int);\n                break;\n#endif\n#if SIZEOF_INTMAX_T\n              case LM_INTMAX_T:\n                i_num = (wide_int) va_arg(ap, intmax_t);\n                break;\n#endif\n#if SIZEOF_PTRDIFF_T\n              case LM_PTRDIFF_T:\n                i_num = (wide_int) va_arg(ap, ptrdiff_t);\n                break;\n#endif\n            }\n          }\n          s = ap_php_conv_10(i_num, (*fmt) == 'u', &is_negative,\n                &num_buf[NUM_BUF_SIZE], &s_len);\n          FIX_PRECISION(adjust_precision, precision, s, s_len);\n\n          if (*fmt != 'u') {\n            if (is_negative)\n              prefix_char = '-';\n            else if (print_sign)\n              prefix_char = '+';\n            else if (print_blank)\n              prefix_char = ' ';\n          }\n          break;\n\n\n        case 'o':\n          switch(modifier) {\n            default:\n              ui_num = (u_wide_int) va_arg(ap, unsigned int);\n              break;\n            case LM_LONG_DOUBLE:\n              goto fmt_error;\n            case LM_LONG:\n              ui_num = (u_wide_int) va_arg(ap, unsigned long int);\n              break;\n            case LM_SIZE_T:\n              ui_num = (u_wide_int) va_arg(ap, size_t);\n              break;\n#if SIZEOF_LONG_LONG\n            case LM_LONG_LONG:\n              ui_num = (u_wide_int) va_arg(ap, u_wide_int);\n              break;\n#endif\n#if SIZEOF_INTMAX_T\n            case LM_INTMAX_T:\n              ui_num = (u_wide_int) va_arg(ap, uintmax_t);\n              break;\n#endif\n#if SIZEOF_PTRDIFF_T\n            case LM_PTRDIFF_T:\n              ui_num = (u_wide_int) va_arg(ap, ptrdiff_t);\n              break;\n#endif\n          }\n          s = ap_php_conv_p2(ui_num, 3, *fmt,\n                &num_buf[NUM_BUF_SIZE], &s_len);\n          FIX_PRECISION(adjust_precision, precision, s, s_len);\n          if (alternate_form && *s != '0') {\n            *--s = '0';\n            s_len++;\n          }\n          break;\n\n\n        case 'x':\n        case 'X':\n          switch(modifier) {\n            default:\n              ui_num = (u_wide_int) va_arg(ap, unsigned int);\n              break;\n            case LM_LONG_DOUBLE:\n              goto fmt_error;\n            case LM_LONG:\n              ui_num = (u_wide_int) va_arg(ap, unsigned long int);\n              break;\n            case LM_SIZE_T:\n              ui_num = (u_wide_int) va_arg(ap, size_t);\n              break;\n#if SIZEOF_LONG_LONG\n            case LM_LONG_LONG:\n              ui_num = (u_wide_int) va_arg(ap, u_wide_int);\n              break;\n#endif\n#if SIZEOF_INTMAX_T\n            case LM_INTMAX_T:\n              ui_num = (u_wide_int) va_arg(ap, uintmax_t);\n              break;\n#endif\n#if SIZEOF_PTRDIFF_T\n            case LM_PTRDIFF_T:\n              ui_num = (u_wide_int) va_arg(ap, ptrdiff_t);\n              break;\n#endif\n          }\n          s = ap_php_conv_p2(ui_num, 4, *fmt,\n                &num_buf[NUM_BUF_SIZE], &s_len);\n          FIX_PRECISION(adjust_precision, precision, s, s_len);\n          if (alternate_form && i_num != 0) {\n            *--s = *fmt;  /* 'x' or 'X' */\n            *--s = '0';\n            s_len += 2;\n          }\n          break;\n\n\n        case 's':\n        case 'v':\n          s = va_arg(ap, char *);\n          if (s != nullptr) {\n            s_len = strlen(s);\n            if (adjust_precision && precision < s_len)\n              s_len = precision;\n          } else {\n            s = const_cast<char*>(s_null);\n            s_len = S_NULL_LEN;\n          }\n          pad_char = ' ';\n          break;\n\n\n        case 'f':\n        case 'F':\n        case 'e':\n        case 'E':\n          switch(modifier) {\n            case LM_LONG_DOUBLE:\n              fp_num = (double) va_arg(ap, long double);\n              break;\n            case LM_STD:\n              fp_num = va_arg(ap, double);\n              break;\n            default:\n              goto fmt_error;\n          }\n\n          if (std::isnan(fp_num)) {\n            s = const_cast<char*>(\"nan\");\n            s_len = 3;\n          } else if (std::isinf(fp_num)) {\n            s = const_cast<char*>(\"inf\");\n            s_len = 3;\n          } else {\n#ifdef HAVE_LOCALE_H\n            if (!lconv) {\n              lconv = localeconv();\n            }\n#endif\n            s = php_conv_fp((*fmt == 'f')?'F':*fmt, fp_num, alternate_form,\n             (adjust_precision == NO) ? FLOAT_DIGITS : precision,\n             (*fmt == 'f')?LCONV_DECIMAL_POINT:'.',\n                  &is_negative, &num_buf[1], &s_len);\n            if (is_negative)\n              prefix_char = '-';\n            else if (print_sign)\n              prefix_char = '+';\n            else if (print_blank)\n              prefix_char = ' ';\n          }\n          break;\n\n\n        case 'g':\n        case 'k':\n        case 'G':\n        case 'H':\n          switch(modifier) {\n            case LM_LONG_DOUBLE:\n              fp_num = (double) va_arg(ap, long double);\n              break;\n            case LM_STD:\n              fp_num = va_arg(ap, double);\n              break;\n            default:\n              goto fmt_error;\n          }\n\n          if (std::isnan(fp_num)) {\n             s = const_cast<char*>(\"NAN\");\n             s_len = 3;\n             break;\n           } else if (std::isinf(fp_num)) {\n             if (fp_num > 0) {\n               s = const_cast<char*>(\"INF\");\n               s_len = 3;\n             } else {\n               s = const_cast<char*>(\"-INF\");\n               s_len = 4;\n             }\n             break;\n           }\n\n          if (adjust_precision == NO)\n            precision = FLOAT_DIGITS;\n          else if (precision == 0)\n            precision = 1;\n          /*\n           * * We use &num_buf[ 1 ], so that we have room for the sign\n           */\n#ifdef HAVE_LOCALE_H\n          if (!lconv) {\n            lconv = localeconv();\n          }\n#endif\n          s = php_gcvt(fp_num, precision,\n                       (*fmt=='H' || *fmt == 'k') ? '.' : LCONV_DECIMAL_POINT,\n                       (*fmt == 'G' || *fmt == 'H')?'E':'e', &num_buf[1]);\n          if (*s == '-')\n            prefix_char = *s++;\n          else if (print_sign)\n            prefix_char = '+';\n          else if (print_blank)\n            prefix_char = ' ';\n\n          s_len = strlen(s);\n\n          if (alternate_form && (q = strchr(s, '.')) == nullptr)\n            s[s_len++] = '.';\n          break;\n\n\n        case 'c':\n          char_buf[0] = (char) (va_arg(ap, int));\n          s = &char_buf[0];\n          s_len = 1;\n          pad_char = ' ';\n          break;\n\n\n        case '%':\n          char_buf[0] = '%';\n          s = &char_buf[0];\n          s_len = 1;\n          pad_char = ' ';\n          break;\n\n\n        case 'n':\n          *(va_arg(ap, int *)) = outpos;\n          goto skip_output;\n\n          /*\n           * Always extract the argument as a \"char *\" pointer. We\n           * should be using \"void *\" but there are still machines\n           * that don't understand it.\n           * If the pointer size is equal to the size of an unsigned\n           * integer we convert the pointer to a hex number, otherwise\n           * we print \"%p\" to indicate that we don't handle \"%p\".\n           */\n        case 'p':\n          if (sizeof(char *) <= sizeof(u_wide_int)) {\n            ui_num = (u_wide_int)((size_t) va_arg(ap, char *));\n            s = ap_php_conv_p2(ui_num, 4, 'x',\n                &num_buf[NUM_BUF_SIZE], &s_len);\n            if (ui_num != 0) {\n              *--s = 'x';\n              *--s = '0';\n              s_len += 2;\n            }\n          } else {\n            s = const_cast<char*>(\"%p\");\n            s_len = 2;\n          }\n          pad_char = ' ';\n          break;\n\n\n        case NUL:\n          /*\n           * The last character of the format string was %.\n           * We ignore it.\n           */\n          continue;\n\n\nfmt_error:\n        throw Exception(\"Illegal length modifier specified '%c'\", *fmt);\n\n          /*\n           * The default case is for unrecognized %'s.\n           * We print %<char> to help the user identify what\n           * option is not understood.\n           * This is also useful in case the user wants to pass\n           * the output of format_converter to another function\n           * that understands some other %<char> (like syslog).\n           * Note that we can't point s inside fmt because the\n           * unknown <char> could be preceded by width etc.\n           */\n        default:\n          char_buf[0] = '%';\n          char_buf[1] = *fmt;\n          s = char_buf;\n          s_len = 2;\n          pad_char = ' ';\n          break;\n      }\n\n      if (prefix_char != NUL) {\n        *--s = prefix_char;\n        s_len++;\n      }\n      if (adjust_width && adjust == RIGHT && min_width > s_len) {\n        if (pad_char == '0' && prefix_char != NUL) {\n          appendchar(&result, &outpos, &size, *s);\n          s++;\n          s_len--;\n          min_width--;\n        }\n        for (int i = 0; i < min_width - s_len; i++) {\n          appendchar(&result, &outpos, &size, pad_char);\n        }\n      }\n      /*\n       * Print the (for now) non-null terminated string s.\n       */\n      appendsimplestring(&result, &outpos, &size, s, s_len);\n\n      if (adjust_width && adjust == LEFT && min_width > s_len) {\n        for (int i = 0; i < min_width - s_len; i++) {\n          appendchar(&result, &outpos, &size, pad_char);\n        }\n      }\n    }\nskip_output:\n    fmt++;\n  }\n  /*\n   * Add the terminating null here since it wasn't added incrementally above\n   * once the whole string has been composed.\n   */\n  appendchar(&result, &outpos, &size, NUL);\n  *outbuf = result;\n  return outpos - 1;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147885,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "    StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes,\r\n                                                     size_t xTriggerLevelBytes,\r\n                                                     BaseType_t xIsMessageBuffer )\r\n    {\r\n        uint8_t * pucAllocatedMemory;\r\n        uint8_t ucFlags;\r\n\r\n        /* In case the stream buffer is going to be used as a message buffer\r\n         * (that is, it will hold discrete messages with a little meta data that\r\n         * says how big the next message is) check the buffer will be large enough\r\n         * to hold at least one message. */\r\n        if( xIsMessageBuffer == pdTRUE )\r\n        {\r\n            /* Is a message buffer but not statically allocated. */\r\n            ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;\r\n            configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );\r\n        }\r\n        else\r\n        {\r\n            /* Not a message buffer and not statically allocated. */\r\n            ucFlags = 0;\r\n            configASSERT( xBufferSizeBytes > 0 );\r\n        }\r\n\r\n        configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );\r\n\r\n        /* A trigger level of 0 would cause a waiting task to unblock even when\r\n         * the buffer was empty. */\r\n        if( xTriggerLevelBytes == ( size_t ) 0 )\r\n        {\r\n            xTriggerLevelBytes = ( size_t ) 1;\r\n        }\r\n\r\n        /* A stream buffer requires a StreamBuffer_t structure and a buffer.\r\n         * Both are allocated in a single call to pvPortMalloc().  The\r\n         * StreamBuffer_t structure is placed at the start of the allocated memory\r\n         * and the buffer follows immediately after.  The requested size is\r\n         * incremented so the free space is returned as the user would expect -\r\n         * this is a quirk of the implementation that means otherwise the free\r\n         * space would be reported as one byte smaller than would be logically\r\n         * expected. */\r\n        xBufferSizeBytes++;\r\n        pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */\r\n\r\n        if( pucAllocatedMemory != NULL )\r\n        {\r\n            prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory,       /* Structure at the start of the allocated memory. */ /*lint !e9087 Safe cast as allocated memory is aligned. */ /*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. */\r\n                                          pucAllocatedMemory + sizeof( StreamBuffer_t ), /* Storage area follows. */ /*lint !e9016 Indexing past structure valid for uint8_t pointer, also storage area has no alignment requirement. */\r\n                                          xBufferSizeBytes,\r\n                                          xTriggerLevelBytes,\r\n                                          ucFlags );\r\n\r\n            traceSTREAM_BUFFER_CREATE( ( ( StreamBuffer_t * ) pucAllocatedMemory ), xIsMessageBuffer );\r\n        }\r\n        else\r\n        {\r\n            traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );\r\n        }\r\n\r\n        return ( StreamBufferHandle_t ) pucAllocatedMemory; /*lint !e9087 !e826 Safe cast as allocated memory is aligned. */\r\n    }\r",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147998,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "    StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes,\r\n                                                     size_t xTriggerLevelBytes,\r\n                                                     BaseType_t xIsMessageBuffer )\r\n    {\r\n        uint8_t * pucAllocatedMemory;\r\n        uint8_t ucFlags;\r\n\r\n        /* In case the stream buffer is going to be used as a message buffer\r\n         * (that is, it will hold discrete messages with a little meta data that\r\n         * says how big the next message is) check the buffer will be large enough\r\n         * to hold at least one message. */\r\n        if( xIsMessageBuffer == pdTRUE )\r\n        {\r\n            /* Is a message buffer but not statically allocated. */\r\n            ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;\r\n            configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );\r\n        }\r\n        else\r\n        {\r\n            /* Not a message buffer and not statically allocated. */\r\n            ucFlags = 0;\r\n            configASSERT( xBufferSizeBytes > 0 );\r\n        }\r\n\r\n        configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );\r\n\r\n        /* A trigger level of 0 would cause a waiting task to unblock even when\r\n         * the buffer was empty. */\r\n        if( xTriggerLevelBytes == ( size_t ) 0 )\r\n        {\r\n            xTriggerLevelBytes = ( size_t ) 1;\r\n        }\r\n\r\n        /* A stream buffer requires a StreamBuffer_t structure and a buffer.\r\n         * Both are allocated in a single call to pvPortMalloc().  The\r\n         * StreamBuffer_t structure is placed at the start of the allocated memory\r\n         * and the buffer follows immediately after.  The requested size is\r\n         * incremented so the free space is returned as the user would expect -\r\n         * this is a quirk of the implementation that means otherwise the free\r\n         * space would be reported as one byte smaller than would be logically\r\n         * expected. */\r\n        if( xBufferSizeBytes < ( xBufferSizeBytes + 1 + sizeof( StreamBuffer_t ) ) )\r\n        {\r\n            xBufferSizeBytes++;\r\n            pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */\r\n        }\r\n        else\r\n        {\r\n            pucAllocatedMemory = NULL;\r\n        }\r\n        \r\n\r\n        if( pucAllocatedMemory != NULL )\r\n        {\r\n            prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory,       /* Structure at the start of the allocated memory. */ /*lint !e9087 Safe cast as allocated memory is aligned. */ /*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. */\r\n                                          pucAllocatedMemory + sizeof( StreamBuffer_t ), /* Storage area follows. */ /*lint !e9016 Indexing past structure valid for uint8_t pointer, also storage area has no alignment requirement. */\r\n                                          xBufferSizeBytes,\r\n                                          xTriggerLevelBytes,\r\n                                          ucFlags );\r\n\r\n            traceSTREAM_BUFFER_CREATE( ( ( StreamBuffer_t * ) pucAllocatedMemory ), xIsMessageBuffer );\r\n        }\r\n        else\r\n        {\r\n            traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );\r\n        }\r\n\r\n        return ( StreamBufferHandle_t ) pucAllocatedMemory; /*lint !e9087 !e826 Safe cast as allocated memory is aligned. */\r\n    }\r",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147999,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "calculateNumTiles (int *numTiles,\n\t\t   int numLevels,\n\t\t   int min, int max,\n\t\t   int size,\n\t\t   LevelRoundingMode rmode)\n{\n    for (int i = 0; i < numLevels; i++)\n    {\n        int l = levelSize (min, max, i, rmode);\n        if (l > std::numeric_limits<int>::max() - size + 1)\n            throw IEX_NAMESPACE::ArgExc (\"Invalid size.\");\n\n        numTiles[i] = (l + size - 1) / size;\n    }\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148164,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "calculateNumTiles (int *numTiles,\n\t\t   int numLevels,\n\t\t   int min, int max,\n\t\t   int size,\n\t\t   LevelRoundingMode rmode)\n{\n    for (int i = 0; i < numLevels; i++)\n    {\n        // use 64 bits to avoid int overflow if size is large.\n        Int64 l = levelSize (min, max, i, rmode);\n        numTiles[i] = (l + size - 1) / size;\n    }\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148165,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "size_t intsetBlobLen(intset *is) {\n    return sizeof(intset)+intrev32ifbe(is->length)*intrev32ifbe(is->encoding);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148182,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "size_t intsetBlobLen(intset *is) {\n    return sizeof(intset)+(size_t)intrev32ifbe(is->length)*intrev32ifbe(is->encoding);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148183,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "UINT rdpgfx_read_rect16(wStream* s, RECTANGLE_16* rect16)\n{\n\tif (Stream_GetRemainingLength(s) < 8)\n\t{\n\t\tWLog_ERR(TAG, \"not enough data!\");\n\t\treturn ERROR_INVALID_DATA;\n\t}\n\n\tStream_Read_UINT16(s, rect16->left);   /* left (2 bytes) */\n\tStream_Read_UINT16(s, rect16->top);    /* top (2 bytes) */\n\tStream_Read_UINT16(s, rect16->right);  /* right (2 bytes) */\n\tStream_Read_UINT16(s, rect16->bottom); /* bottom (2 bytes) */\n\treturn CHANNEL_RC_OK;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148188,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "UINT rdpgfx_read_rect16(wStream* s, RECTANGLE_16* rect16)\n{\n\tif (Stream_GetRemainingLength(s) < 8)\n\t{\n\t\tWLog_ERR(TAG, \"not enough data!\");\n\t\treturn ERROR_INVALID_DATA;\n\t}\n\n\tStream_Read_UINT16(s, rect16->left);   /* left (2 bytes) */\n\tStream_Read_UINT16(s, rect16->top);    /* top (2 bytes) */\n\tStream_Read_UINT16(s, rect16->right);  /* right (2 bytes) */\n\tStream_Read_UINT16(s, rect16->bottom); /* bottom (2 bytes) */\n\tif (rect16->left >= rect16->right)\n\t\treturn ERROR_INVALID_DATA;\n\tif (rect16->top >= rect16->bottom)\n\t\treturn ERROR_INVALID_DATA;\n\treturn CHANNEL_RC_OK;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148189,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "unserialize_uep(bufinfo_T *bi, int *error, char_u *file_name)\n{\n    int\t\ti;\n    u_entry_T\t*uep;\n    char_u\t**array;\n    char_u\t*line;\n    int\t\tline_len;\n\n    uep = (u_entry_T *)U_ALLOC_LINE(sizeof(u_entry_T));\n    if (uep == NULL)\n\treturn NULL;\n    vim_memset(uep, 0, sizeof(u_entry_T));\n#ifdef U_DEBUG\n    uep->ue_magic = UE_MAGIC;\n#endif\n    uep->ue_top = undo_read_4c(bi);\n    uep->ue_bot = undo_read_4c(bi);\n    uep->ue_lcount = undo_read_4c(bi);\n    uep->ue_size = undo_read_4c(bi);\n    if (uep->ue_size > 0)\n    {\n\tarray = (char_u **)U_ALLOC_LINE(sizeof(char_u *) * uep->ue_size);\n\tif (array == NULL)\n\t{\n\t    *error = TRUE;\n\t    return uep;\n\t}\n\tvim_memset(array, 0, sizeof(char_u *) * uep->ue_size);\n    }\n    else\n\tarray = NULL;\n    uep->ue_array = array;\n\n    for (i = 0; i < uep->ue_size; ++i)\n    {\n\tline_len = undo_read_4c(bi);\n\tif (line_len >= 0)\n\t    line = read_string_decrypt(bi, line_len);\n\telse\n\t{\n\t    line = NULL;\n\t    corruption_error(\"line length\", file_name);\n\t}\n\tif (line == NULL)\n\t{\n\t    *error = TRUE;\n\t    return uep;\n\t}\n\tarray[i] = line;\n    }\n    return uep;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148226,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "unserialize_uep(bufinfo_T *bi, int *error, char_u *file_name)\n{\n    int\t\ti;\n    u_entry_T\t*uep;\n    char_u\t**array = NULL;\n    char_u\t*line;\n    int\t\tline_len;\n\n    uep = (u_entry_T *)U_ALLOC_LINE(sizeof(u_entry_T));\n    if (uep == NULL)\n\treturn NULL;\n    vim_memset(uep, 0, sizeof(u_entry_T));\n#ifdef U_DEBUG\n    uep->ue_magic = UE_MAGIC;\n#endif\n    uep->ue_top = undo_read_4c(bi);\n    uep->ue_bot = undo_read_4c(bi);\n    uep->ue_lcount = undo_read_4c(bi);\n    uep->ue_size = undo_read_4c(bi);\n    if (uep->ue_size > 0)\n    {\n\tif (uep->ue_size < LONG_MAX / (int)sizeof(char_u *))\n\t    array = (char_u **)U_ALLOC_LINE(sizeof(char_u *) * uep->ue_size);\n\tif (array == NULL)\n\t{\n\t    *error = TRUE;\n\t    return uep;\n\t}\n\tvim_memset(array, 0, sizeof(char_u *) * uep->ue_size);\n    }\n    uep->ue_array = array;\n\n    for (i = 0; i < uep->ue_size; ++i)\n    {\n\tline_len = undo_read_4c(bi);\n\tif (line_len >= 0)\n\t    line = read_string_decrypt(bi, line_len);\n\telse\n\t{\n\t    line = NULL;\n\t    corruption_error(\"line length\", file_name);\n\t}\n\tif (line == NULL)\n\t{\n\t    *error = TRUE;\n\t    return uep;\n\t}\n\tarray[i] = line;\n    }\n    return uep;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148227,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "void stralgoLCS(client *c) {\n    uint32_t i, j;\n    long long minmatchlen = 0;\n    sds a = NULL, b = NULL;\n    int getlen = 0, getidx = 0, withmatchlen = 0;\n    robj *obja = NULL, *objb = NULL;\n\n    for (j = 2; j < (uint32_t)c->argc; j++) {\n        char *opt = c->argv[j]->ptr;\n        int moreargs = (c->argc-1) - j;\n\n        if (!strcasecmp(opt,\"IDX\")) {\n            getidx = 1;\n        } else if (!strcasecmp(opt,\"LEN\")) {\n            getlen = 1;\n        } else if (!strcasecmp(opt,\"WITHMATCHLEN\")) {\n            withmatchlen = 1;\n        } else if (!strcasecmp(opt,\"MINMATCHLEN\") && moreargs) {\n            if (getLongLongFromObjectOrReply(c,c->argv[j+1],&minmatchlen,NULL)\n                != C_OK) goto cleanup;\n            if (minmatchlen < 0) minmatchlen = 0;\n            j++;\n        } else if (!strcasecmp(opt,\"STRINGS\") && moreargs > 1) {\n            if (a != NULL) {\n                addReplyError(c,\"Either use STRINGS or KEYS\");\n                goto cleanup;\n            }\n            a = c->argv[j+1]->ptr;\n            b = c->argv[j+2]->ptr;\n            j += 2;\n        } else if (!strcasecmp(opt,\"KEYS\") && moreargs > 1) {\n            if (a != NULL) {\n                addReplyError(c,\"Either use STRINGS or KEYS\");\n                goto cleanup;\n            }\n            obja = lookupKeyRead(c->db,c->argv[j+1]);\n            objb = lookupKeyRead(c->db,c->argv[j+2]);\n            if ((obja && obja->type != OBJ_STRING) ||\n                (objb && objb->type != OBJ_STRING))\n            {\n                addReplyError(c,\n                    \"The specified keys must contain string values\");\n                /* Don't cleanup the objects, we need to do that\n                 * only after callign getDecodedObject(). */\n                obja = NULL;\n                objb = NULL;\n                goto cleanup;\n            }\n            obja = obja ? getDecodedObject(obja) : createStringObject(\"\",0);\n            objb = objb ? getDecodedObject(objb) : createStringObject(\"\",0);\n            a = obja->ptr;\n            b = objb->ptr;\n            j += 2;\n        } else {\n            addReply(c,shared.syntaxerr);\n            goto cleanup;\n        }\n    }\n\n    /* Complain if the user passed ambiguous parameters. */\n    if (a == NULL) {\n        addReplyError(c,\"Please specify two strings: \"\n                        \"STRINGS or KEYS options are mandatory\");\n        goto cleanup;\n    } else if (getlen && getidx) {\n        addReplyError(c,\n            \"If you want both the length and indexes, please \"\n            \"just use IDX.\");\n        goto cleanup;\n    }\n\n    /* Compute the LCS using the vanilla dynamic programming technique of\n     * building a table of LCS(x,y) substrings. */\n    uint32_t alen = sdslen(a);\n    uint32_t blen = sdslen(b);\n\n    /* Setup an uint32_t array to store at LCS[i,j] the length of the\n     * LCS A0..i-1, B0..j-1. Note that we have a linear array here, so\n     * we index it as LCS[j+(blen+1)*j] */\n    uint32_t *lcs = zmalloc((alen+1)*(blen+1)*sizeof(uint32_t));\n    #define LCS(A,B) lcs[(B)+((A)*(blen+1))]\n\n    /* Start building the LCS table. */\n    for (uint32_t i = 0; i <= alen; i++) {\n        for (uint32_t j = 0; j <= blen; j++) {\n            if (i == 0 || j == 0) {\n                /* If one substring has length of zero, the\n                 * LCS length is zero. */\n                LCS(i,j) = 0;\n            } else if (a[i-1] == b[j-1]) {\n                /* The len LCS (and the LCS itself) of two\n                 * sequences with the same final character, is the\n                 * LCS of the two sequences without the last char\n                 * plus that last char. */\n                LCS(i,j) = LCS(i-1,j-1)+1;\n            } else {\n                /* If the last character is different, take the longest\n                 * between the LCS of the first string and the second\n                 * minus the last char, and the reverse. */\n                uint32_t lcs1 = LCS(i-1,j);\n                uint32_t lcs2 = LCS(i,j-1);\n                LCS(i,j) = lcs1 > lcs2 ? lcs1 : lcs2;\n            }\n        }\n    }\n\n    /* Store the actual LCS string in \"result\" if needed. We create\n     * it backward, but the length is already known, we store it into idx. */\n    uint32_t idx = LCS(alen,blen);\n    sds result = NULL;        /* Resulting LCS string. */\n    void *arraylenptr = NULL; /* Deffered length of the array for IDX. */\n    uint32_t arange_start = alen, /* alen signals that values are not set. */\n             arange_end = 0,\n             brange_start = 0,\n             brange_end = 0;\n\n    /* Do we need to compute the actual LCS string? Allocate it in that case. */\n    int computelcs = getidx || !getlen;\n    if (computelcs) result = sdsnewlen(SDS_NOINIT,idx);\n\n    /* Start with a deferred array if we have to emit the ranges. */\n    uint32_t arraylen = 0;  /* Number of ranges emitted in the array. */\n    if (getidx) {\n        addReplyMapLen(c,2);\n        addReplyBulkCString(c,\"matches\");\n        arraylenptr = addReplyDeferredLen(c);\n    }\n\n    i = alen, j = blen;\n    while (computelcs && i > 0 && j > 0) {\n        int emit_range = 0;\n        if (a[i-1] == b[j-1]) {\n            /* If there is a match, store the character and reduce\n             * the indexes to look for a new match. */\n            result[idx-1] = a[i-1];\n\n            /* Track the current range. */\n            if (arange_start == alen) {\n                arange_start = i-1;\n                arange_end = i-1;\n                brange_start = j-1;\n                brange_end = j-1;\n            } else {\n                /* Let's see if we can extend the range backward since\n                 * it is contiguous. */\n                if (arange_start == i && brange_start == j) {\n                    arange_start--;\n                    brange_start--;\n                } else {\n                    emit_range = 1;\n                }\n            }\n            /* Emit the range if we matched with the first byte of\n             * one of the two strings. We'll exit the loop ASAP. */\n            if (arange_start == 0 || brange_start == 0) emit_range = 1;\n            idx--; i--; j--;\n        } else {\n            /* Otherwise reduce i and j depending on the largest\n             * LCS between, to understand what direction we need to go. */\n            uint32_t lcs1 = LCS(i-1,j);\n            uint32_t lcs2 = LCS(i,j-1);\n            if (lcs1 > lcs2)\n                i--;\n            else\n                j--;\n            if (arange_start != alen) emit_range = 1;\n        }\n\n        /* Emit the current range if needed. */\n        uint32_t match_len = arange_end - arange_start + 1;\n        if (emit_range) {\n            if (minmatchlen == 0 || match_len >= minmatchlen) {\n                if (arraylenptr) {\n                    addReplyArrayLen(c,2+withmatchlen);\n                    addReplyArrayLen(c,2);\n                    addReplyLongLong(c,arange_start);\n                    addReplyLongLong(c,arange_end);\n                    addReplyArrayLen(c,2);\n                    addReplyLongLong(c,brange_start);\n                    addReplyLongLong(c,brange_end);\n                    if (withmatchlen) addReplyLongLong(c,match_len);\n                    arraylen++;\n                }\n            }\n            arange_start = alen; /* Restart at the next match. */\n        }\n    }\n\n    /* Signal modified key, increment dirty, ... */\n\n    /* Reply depending on the given options. */\n    if (arraylenptr) {\n        addReplyBulkCString(c,\"len\");\n        addReplyLongLong(c,LCS(alen,blen));\n        setDeferredArrayLen(c,arraylenptr,arraylen);\n    } else if (getlen) {\n        addReplyLongLong(c,LCS(alen,blen));\n    } else {\n        addReplyBulkSds(c,result);\n        result = NULL;\n    }\n\n    /* Cleanup. */\n    sdsfree(result);\n    zfree(lcs);\n\ncleanup:\n    if (obja) decrRefCount(obja);\n    if (objb) decrRefCount(objb);\n    return;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148312,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "void stralgoLCS(client *c) {\n    uint32_t i, j;\n    long long minmatchlen = 0;\n    sds a = NULL, b = NULL;\n    int getlen = 0, getidx = 0, withmatchlen = 0;\n    robj *obja = NULL, *objb = NULL;\n\n    for (j = 2; j < (uint32_t)c->argc; j++) {\n        char *opt = c->argv[j]->ptr;\n        int moreargs = (c->argc-1) - j;\n\n        if (!strcasecmp(opt,\"IDX\")) {\n            getidx = 1;\n        } else if (!strcasecmp(opt,\"LEN\")) {\n            getlen = 1;\n        } else if (!strcasecmp(opt,\"WITHMATCHLEN\")) {\n            withmatchlen = 1;\n        } else if (!strcasecmp(opt,\"MINMATCHLEN\") && moreargs) {\n            if (getLongLongFromObjectOrReply(c,c->argv[j+1],&minmatchlen,NULL)\n                != C_OK) goto cleanup;\n            if (minmatchlen < 0) minmatchlen = 0;\n            j++;\n        } else if (!strcasecmp(opt,\"STRINGS\") && moreargs > 1) {\n            if (a != NULL) {\n                addReplyError(c,\"Either use STRINGS or KEYS\");\n                goto cleanup;\n            }\n            a = c->argv[j+1]->ptr;\n            b = c->argv[j+2]->ptr;\n            j += 2;\n        } else if (!strcasecmp(opt,\"KEYS\") && moreargs > 1) {\n            if (a != NULL) {\n                addReplyError(c,\"Either use STRINGS or KEYS\");\n                goto cleanup;\n            }\n            obja = lookupKeyRead(c->db,c->argv[j+1]);\n            objb = lookupKeyRead(c->db,c->argv[j+2]);\n            if ((obja && obja->type != OBJ_STRING) ||\n                (objb && objb->type != OBJ_STRING))\n            {\n                addReplyError(c,\n                    \"The specified keys must contain string values\");\n                /* Don't cleanup the objects, we need to do that\n                 * only after callign getDecodedObject(). */\n                obja = NULL;\n                objb = NULL;\n                goto cleanup;\n            }\n            obja = obja ? getDecodedObject(obja) : createStringObject(\"\",0);\n            objb = objb ? getDecodedObject(objb) : createStringObject(\"\",0);\n            a = obja->ptr;\n            b = objb->ptr;\n            j += 2;\n        } else {\n            addReply(c,shared.syntaxerr);\n            goto cleanup;\n        }\n    }\n\n    /* Complain if the user passed ambiguous parameters. */\n    if (a == NULL) {\n        addReplyError(c,\"Please specify two strings: \"\n                        \"STRINGS or KEYS options are mandatory\");\n        goto cleanup;\n    } else if (getlen && getidx) {\n        addReplyError(c,\n            \"If you want both the length and indexes, please \"\n            \"just use IDX.\");\n        goto cleanup;\n    }\n\n    /* Compute the LCS using the vanilla dynamic programming technique of\n     * building a table of LCS(x,y) substrings. */\n    uint32_t alen = sdslen(a);\n    uint32_t blen = sdslen(b);\n\n    /* Setup an uint32_t array to store at LCS[i,j] the length of the\n     * LCS A0..i-1, B0..j-1. Note that we have a linear array here, so\n     * we index it as LCS[j+(blen+1)*j] */\n    uint32_t *lcs = zmalloc((size_t)(alen+1)*(blen+1)*sizeof(uint32_t));\n    #define LCS(A,B) lcs[(B)+((A)*(blen+1))]\n\n    /* Start building the LCS table. */\n    for (uint32_t i = 0; i <= alen; i++) {\n        for (uint32_t j = 0; j <= blen; j++) {\n            if (i == 0 || j == 0) {\n                /* If one substring has length of zero, the\n                 * LCS length is zero. */\n                LCS(i,j) = 0;\n            } else if (a[i-1] == b[j-1]) {\n                /* The len LCS (and the LCS itself) of two\n                 * sequences with the same final character, is the\n                 * LCS of the two sequences without the last char\n                 * plus that last char. */\n                LCS(i,j) = LCS(i-1,j-1)+1;\n            } else {\n                /* If the last character is different, take the longest\n                 * between the LCS of the first string and the second\n                 * minus the last char, and the reverse. */\n                uint32_t lcs1 = LCS(i-1,j);\n                uint32_t lcs2 = LCS(i,j-1);\n                LCS(i,j) = lcs1 > lcs2 ? lcs1 : lcs2;\n            }\n        }\n    }\n\n    /* Store the actual LCS string in \"result\" if needed. We create\n     * it backward, but the length is already known, we store it into idx. */\n    uint32_t idx = LCS(alen,blen);\n    sds result = NULL;        /* Resulting LCS string. */\n    void *arraylenptr = NULL; /* Deffered length of the array for IDX. */\n    uint32_t arange_start = alen, /* alen signals that values are not set. */\n             arange_end = 0,\n             brange_start = 0,\n             brange_end = 0;\n\n    /* Do we need to compute the actual LCS string? Allocate it in that case. */\n    int computelcs = getidx || !getlen;\n    if (computelcs) result = sdsnewlen(SDS_NOINIT,idx);\n\n    /* Start with a deferred array if we have to emit the ranges. */\n    uint32_t arraylen = 0;  /* Number of ranges emitted in the array. */\n    if (getidx) {\n        addReplyMapLen(c,2);\n        addReplyBulkCString(c,\"matches\");\n        arraylenptr = addReplyDeferredLen(c);\n    }\n\n    i = alen, j = blen;\n    while (computelcs && i > 0 && j > 0) {\n        int emit_range = 0;\n        if (a[i-1] == b[j-1]) {\n            /* If there is a match, store the character and reduce\n             * the indexes to look for a new match. */\n            result[idx-1] = a[i-1];\n\n            /* Track the current range. */\n            if (arange_start == alen) {\n                arange_start = i-1;\n                arange_end = i-1;\n                brange_start = j-1;\n                brange_end = j-1;\n            } else {\n                /* Let's see if we can extend the range backward since\n                 * it is contiguous. */\n                if (arange_start == i && brange_start == j) {\n                    arange_start--;\n                    brange_start--;\n                } else {\n                    emit_range = 1;\n                }\n            }\n            /* Emit the range if we matched with the first byte of\n             * one of the two strings. We'll exit the loop ASAP. */\n            if (arange_start == 0 || brange_start == 0) emit_range = 1;\n            idx--; i--; j--;\n        } else {\n            /* Otherwise reduce i and j depending on the largest\n             * LCS between, to understand what direction we need to go. */\n            uint32_t lcs1 = LCS(i-1,j);\n            uint32_t lcs2 = LCS(i,j-1);\n            if (lcs1 > lcs2)\n                i--;\n            else\n                j--;\n            if (arange_start != alen) emit_range = 1;\n        }\n\n        /* Emit the current range if needed. */\n        uint32_t match_len = arange_end - arange_start + 1;\n        if (emit_range) {\n            if (minmatchlen == 0 || match_len >= minmatchlen) {\n                if (arraylenptr) {\n                    addReplyArrayLen(c,2+withmatchlen);\n                    addReplyArrayLen(c,2);\n                    addReplyLongLong(c,arange_start);\n                    addReplyLongLong(c,arange_end);\n                    addReplyArrayLen(c,2);\n                    addReplyLongLong(c,brange_start);\n                    addReplyLongLong(c,brange_end);\n                    if (withmatchlen) addReplyLongLong(c,match_len);\n                    arraylen++;\n                }\n            }\n            arange_start = alen; /* Restart at the next match. */\n        }\n    }\n\n    /* Signal modified key, increment dirty, ... */\n\n    /* Reply depending on the given options. */\n    if (arraylenptr) {\n        addReplyBulkCString(c,\"len\");\n        addReplyLongLong(c,LCS(alen,blen));\n        setDeferredArrayLen(c,arraylenptr,arraylen);\n    } else if (getlen) {\n        addReplyLongLong(c,LCS(alen,blen));\n    } else {\n        addReplyBulkSds(c,result);\n        result = NULL;\n    }\n\n    /* Cleanup. */\n    sdsfree(result);\n    zfree(lcs);\n\ncleanup:\n    if (obja) decrRefCount(obja);\n    if (objb) decrRefCount(objb);\n    return;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148313,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static void sm501_2d_operation(SM501State *s)\n{\n    int cmd = (s->twoD_control >> 16) & 0x1F;\n    int rtl = s->twoD_control & BIT(27);\n    int format = (s->twoD_stretch >> 20) & 0x3;\n    int rop_mode = (s->twoD_control >> 15) & 0x1; /* 1 for rop2, else rop3 */\n    /* 1 if rop2 source is the pattern, otherwise the source is the bitmap */\n    int rop2_source_is_pattern = (s->twoD_control >> 14) & 0x1;\n    int rop = s->twoD_control & 0xFF;\n    int dst_x = (s->twoD_destination >> 16) & 0x01FFF;\n    int dst_y = s->twoD_destination & 0xFFFF;\n    int width = (s->twoD_dimension >> 16) & 0x1FFF;\n    int height = s->twoD_dimension & 0xFFFF;\n    uint32_t dst_base = s->twoD_destination_base & 0x03FFFFFF;\n    uint8_t *dst = s->local_mem + dst_base;\n    int dst_pitch = (s->twoD_pitch >> 16) & 0x1FFF;\n    int crt = (s->dc_crt_control & SM501_DC_CRT_CONTROL_SEL) ? 1 : 0;\n    int fb_len = get_width(s, crt) * get_height(s, crt) * get_bpp(s, crt);\n\n    if ((s->twoD_stretch >> 16) & 0xF) {\n        qemu_log_mask(LOG_UNIMP, \"sm501: only XY addressing is supported.\\n\");\n        return;\n    }\n\n    if (rop_mode == 0) {\n        if (rop != 0xcc) {\n            /* Anything other than plain copies are not supported */\n            qemu_log_mask(LOG_UNIMP, \"sm501: rop3 mode with rop %x is not \"\n                          \"supported.\\n\", rop);\n        }\n    } else {\n        if (rop2_source_is_pattern && rop != 0x5) {\n            /* For pattern source, we support only inverse dest */\n            qemu_log_mask(LOG_UNIMP, \"sm501: rop2 source being the pattern and \"\n                          \"rop %x is not supported.\\n\", rop);\n        } else {\n            if (rop != 0x5 && rop != 0xc) {\n                /* Anything other than plain copies or inverse dest is not\n                 * supported */\n                qemu_log_mask(LOG_UNIMP, \"sm501: rop mode %x is not \"\n                              \"supported.\\n\", rop);\n            }\n        }\n    }\n\n    if (s->twoD_source_base & BIT(27) || s->twoD_destination_base & BIT(27)) {\n        qemu_log_mask(LOG_UNIMP, \"sm501: only local memory is supported.\\n\");\n        return;\n    }\n\n    switch (cmd) {\n    case 0x00: /* copy area */\n    {\n        int src_x = (s->twoD_source >> 16) & 0x01FFF;\n        int src_y = s->twoD_source & 0xFFFF;\n        uint32_t src_base = s->twoD_source_base & 0x03FFFFFF;\n        uint8_t *src = s->local_mem + src_base;\n        int src_pitch = s->twoD_pitch & 0x1FFF;\n\n#define COPY_AREA(_bpp, _pixel_type, rtl) {                                   \\\n        int y, x, index_d, index_s;                                           \\\n        for (y = 0; y < height; y++) {                              \\\n            for (x = 0; x < width; x++) {                           \\\n                _pixel_type val;                                              \\\n                                                                              \\\n                if (rtl) {                                                    \\\n                    index_s = ((src_y - y) * src_pitch + src_x - x) * _bpp;   \\\n                    index_d = ((dst_y - y) * dst_pitch + dst_x - x) * _bpp;   \\\n                } else {                                                      \\\n                    index_s = ((src_y + y) * src_pitch + src_x + x) * _bpp;   \\\n                    index_d = ((dst_y + y) * dst_pitch + dst_x + x) * _bpp;   \\\n                }                                                             \\\n                if (rop_mode == 1 && rop == 5) {                              \\\n                    /* Invert dest */                                         \\\n                    val = ~*(_pixel_type *)&dst[index_d];                     \\\n                } else {                                                      \\\n                    val = *(_pixel_type *)&src[index_s];                      \\\n                }                                                             \\\n                *(_pixel_type *)&dst[index_d] = val;                          \\\n            }                                                                 \\\n        }                                                                     \\\n    }\n        switch (format) {\n        case 0:\n            COPY_AREA(1, uint8_t, rtl);\n            break;\n        case 1:\n            COPY_AREA(2, uint16_t, rtl);\n            break;\n        case 2:\n            COPY_AREA(4, uint32_t, rtl);\n            break;\n        }\n        break;\n    }\n    case 0x01: /* fill rectangle */\n    {\n        uint32_t color = s->twoD_foreground;\n\n#define FILL_RECT(_bpp, _pixel_type) {                                      \\\n        int y, x;                                                           \\\n        for (y = 0; y < height; y++) {                            \\\n            for (x = 0; x < width; x++) {                         \\\n                int index = ((dst_y + y) * dst_pitch + dst_x + x) * _bpp;   \\\n                *(_pixel_type *)&dst[index] = (_pixel_type)color;           \\\n            }                                                               \\\n        }                                                                   \\\n    }\n\n        switch (format) {\n        case 0:\n            FILL_RECT(1, uint8_t);\n            break;\n        case 1:\n            color = cpu_to_le16(color);\n            FILL_RECT(2, uint16_t);\n            break;\n        case 2:\n            color = cpu_to_le32(color);\n            FILL_RECT(4, uint32_t);\n            break;\n        }\n        break;\n    }\n    default:\n        qemu_log_mask(LOG_UNIMP, \"sm501: not implemented 2D operation: %d\\n\",\n                      cmd);\n        return;\n    }\n\n    if (dst_base >= get_fb_addr(s, crt) &&\n        dst_base <= get_fb_addr(s, crt) + fb_len) {\n        int dst_len = MIN(fb_len, ((dst_y + height - 1) * dst_pitch +\n                          dst_x + width) * (1 << format));\n        if (dst_len) {\n            memory_region_set_dirty(&s->local_mem_region, dst_base, dst_len);\n        }\n    }\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148326,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static void sm501_2d_operation(SM501State *s)\n{\n    int cmd = (s->twoD_control >> 16) & 0x1F;\n    int rtl = s->twoD_control & BIT(27);\n    int format = (s->twoD_stretch >> 20) & 0x3;\n    int rop_mode = (s->twoD_control >> 15) & 0x1; /* 1 for rop2, else rop3 */\n    /* 1 if rop2 source is the pattern, otherwise the source is the bitmap */\n    int rop2_source_is_pattern = (s->twoD_control >> 14) & 0x1;\n    int rop = s->twoD_control & 0xFF;\n    unsigned int dst_x = (s->twoD_destination >> 16) & 0x01FFF;\n    unsigned int dst_y = s->twoD_destination & 0xFFFF;\n    unsigned int width = (s->twoD_dimension >> 16) & 0x1FFF;\n    unsigned int height = s->twoD_dimension & 0xFFFF;\n    uint32_t dst_base = s->twoD_destination_base & 0x03FFFFFF;\n    unsigned int dst_pitch = (s->twoD_pitch >> 16) & 0x1FFF;\n    int crt = (s->dc_crt_control & SM501_DC_CRT_CONTROL_SEL) ? 1 : 0;\n    int fb_len = get_width(s, crt) * get_height(s, crt) * get_bpp(s, crt);\n\n    if ((s->twoD_stretch >> 16) & 0xF) {\n        qemu_log_mask(LOG_UNIMP, \"sm501: only XY addressing is supported.\\n\");\n        return;\n    }\n\n    if (s->twoD_source_base & BIT(27) || s->twoD_destination_base & BIT(27)) {\n        qemu_log_mask(LOG_UNIMP, \"sm501: only local memory is supported.\\n\");\n        return;\n    }\n\n    if (!dst_pitch) {\n        qemu_log_mask(LOG_GUEST_ERROR, \"sm501: Zero dest pitch.\\n\");\n        return;\n    }\n\n    if (!width || !height) {\n        qemu_log_mask(LOG_GUEST_ERROR, \"sm501: Zero size 2D op.\\n\");\n        return;\n    }\n\n    if (rtl) {\n        dst_x -= width - 1;\n        dst_y -= height - 1;\n    }\n\n    if (dst_base >= get_local_mem_size(s) || dst_base +\n        (dst_x + width + (dst_y + height) * (dst_pitch + width)) *\n        (1 << format) >= get_local_mem_size(s)) {\n        qemu_log_mask(LOG_GUEST_ERROR, \"sm501: 2D op dest is outside vram.\\n\");\n        return;\n    }\n\n    switch (cmd) {\n    case 0: /* BitBlt */\n    {\n        unsigned int src_x = (s->twoD_source >> 16) & 0x01FFF;\n        unsigned int src_y = s->twoD_source & 0xFFFF;\n        uint32_t src_base = s->twoD_source_base & 0x03FFFFFF;\n        unsigned int src_pitch = s->twoD_pitch & 0x1FFF;\n\n        if (!src_pitch) {\n            qemu_log_mask(LOG_GUEST_ERROR, \"sm501: Zero src pitch.\\n\");\n            return;\n        }\n\n        if (rtl) {\n            src_x -= width - 1;\n            src_y -= height - 1;\n        }\n\n        if (src_base >= get_local_mem_size(s) || src_base +\n            (src_x + width + (src_y + height) * (src_pitch + width)) *\n            (1 << format) >= get_local_mem_size(s)) {\n            qemu_log_mask(LOG_GUEST_ERROR,\n                          \"sm501: 2D op src is outside vram.\\n\");\n            return;\n        }\n\n        if ((rop_mode && rop == 0x5) || (!rop_mode && rop == 0x55)) {\n            /* Invert dest, is there a way to do this with pixman? */\n            unsigned int x, y, i;\n            uint8_t *d = s->local_mem + dst_base;\n\n            for (y = 0; y < height; y++) {\n                i = (dst_x + (dst_y + y) * dst_pitch) * (1 << format);\n                for (x = 0; x < width; x++, i += (1 << format)) {\n                    switch (format) {\n                    case 0:\n                        d[i] = ~d[i];\n                        break;\n                    case 1:\n                        *(uint16_t *)&d[i] = ~*(uint16_t *)&d[i];\n                        break;\n                    case 2:\n                        *(uint32_t *)&d[i] = ~*(uint32_t *)&d[i];\n                        break;\n                    }\n                }\n            }\n        } else {\n            /* Do copy src for unimplemented ops, better than unpainted area */\n            if ((rop_mode && (rop != 0xc || rop2_source_is_pattern)) ||\n                (!rop_mode && rop != 0xcc)) {\n                qemu_log_mask(LOG_UNIMP,\n                              \"sm501: rop%d op %x%s not implemented\\n\",\n                              (rop_mode ? 2 : 3), rop,\n                              (rop2_source_is_pattern ?\n                                  \" with pattern source\" : \"\"));\n            }\n            /* Check for overlaps, this could be made more exact */\n            uint32_t sb, se, db, de;\n            sb = src_base + src_x + src_y * (width + src_pitch);\n            se = sb + width + height * (width + src_pitch);\n            db = dst_base + dst_x + dst_y * (width + dst_pitch);\n            de = db + width + height * (width + dst_pitch);\n            if (rtl && ((db >= sb && db <= se) || (de >= sb && de <= se))) {\n                /* regions may overlap: copy via temporary */\n                int llb = width * (1 << format);\n                int tmp_stride = DIV_ROUND_UP(llb, sizeof(uint32_t));\n                uint32_t *tmp = g_malloc(tmp_stride * sizeof(uint32_t) *\n                                         height);\n                pixman_blt((uint32_t *)&s->local_mem[src_base], tmp,\n                           src_pitch * (1 << format) / sizeof(uint32_t),\n                           tmp_stride, 8 * (1 << format), 8 * (1 << format),\n                           src_x, src_y, 0, 0, width, height);\n                pixman_blt(tmp, (uint32_t *)&s->local_mem[dst_base],\n                           tmp_stride,\n                           dst_pitch * (1 << format) / sizeof(uint32_t),\n                           8 * (1 << format), 8 * (1 << format),\n                           0, 0, dst_x, dst_y, width, height);\n                g_free(tmp);\n            } else {\n                pixman_blt((uint32_t *)&s->local_mem[src_base],\n                           (uint32_t *)&s->local_mem[dst_base],\n                           src_pitch * (1 << format) / sizeof(uint32_t),\n                           dst_pitch * (1 << format) / sizeof(uint32_t),\n                           8 * (1 << format), 8 * (1 << format),\n                           src_x, src_y, dst_x, dst_y, width, height);\n            }\n        }\n        break;\n    }\n    case 1: /* Rectangle Fill */\n    {\n        uint32_t color = s->twoD_foreground;\n\n        if (format == 2) {\n            color = cpu_to_le32(color);\n        } else if (format == 1) {\n            color = cpu_to_le16(color);\n        }\n\n        pixman_fill((uint32_t *)&s->local_mem[dst_base],\n                    dst_pitch * (1 << format) / sizeof(uint32_t),\n                    8 * (1 << format), dst_x, dst_y, width, height, color);\n        break;\n    }\n    default:\n        qemu_log_mask(LOG_UNIMP, \"sm501: not implemented 2D operation: %d\\n\",\n                      cmd);\n        return;\n    }\n\n    if (dst_base >= get_fb_addr(s, crt) &&\n        dst_base <= get_fb_addr(s, crt) + fb_len) {\n        int dst_len = MIN(fb_len, ((dst_y + height - 1) * dst_pitch +\n                          dst_x + width) * (1 << format));\n        if (dst_len) {\n            memory_region_set_dirty(&s->local_mem_region, dst_base, dst_len);\n        }\n    }\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148327,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static MSUSB_PIPE_DESCRIPTOR** msusb_mspipes_read(wStream* s, UINT32 NumberOfPipes)\n{\n\tUINT32 pnum;\n\tMSUSB_PIPE_DESCRIPTOR** MsPipes;\n\n\tif (Stream_GetRemainingCapacity(s) < 12 * NumberOfPipes)\n\t\treturn NULL;\n\n\tMsPipes = (MSUSB_PIPE_DESCRIPTOR**)calloc(NumberOfPipes, sizeof(MSUSB_PIPE_DESCRIPTOR*));\n\n\tif (!MsPipes)\n\t\treturn NULL;\n\n\tfor (pnum = 0; pnum < NumberOfPipes; pnum++)\n\t{\n\t\tMSUSB_PIPE_DESCRIPTOR* MsPipe = msusb_mspipe_new();\n\n\t\tif (!MsPipe)\n\t\t\tgoto out_error;\n\n\t\tStream_Read_UINT16(s, MsPipe->MaximumPacketSize);\n\t\tStream_Seek(s, 2);\n\t\tStream_Read_UINT32(s, MsPipe->MaximumTransferSize);\n\t\tStream_Read_UINT32(s, MsPipe->PipeFlags);\n\t\t/* Already set to zero by memset\n\t\t        MsPipe->PipeHandle\t   = 0;\n\t\t        MsPipe->bEndpointAddress = 0;\n\t\t        MsPipe->bInterval\t\t= 0;\n\t\t        MsPipe->PipeType\t\t = 0;\n\t\t        MsPipe->InitCompleted\t= 0;\n\t\t*/\n\t\tMsPipes[pnum] = MsPipe;\n\t}\n\n\treturn MsPipes;\nout_error:\n\n\tfor (pnum = 0; pnum < NumberOfPipes; pnum++)\n\t\tfree(MsPipes[pnum]);\n\n\tfree(MsPipes);\n\treturn NULL;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148334,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static MSUSB_PIPE_DESCRIPTOR** msusb_mspipes_read(wStream* s, UINT32 NumberOfPipes)\n{\n\tUINT32 pnum;\n\tMSUSB_PIPE_DESCRIPTOR** MsPipes;\n\n\tif (Stream_GetRemainingCapacity(s) / 12 < NumberOfPipes)\n\t\treturn NULL;\n\n\tMsPipes = (MSUSB_PIPE_DESCRIPTOR**)calloc(NumberOfPipes, sizeof(MSUSB_PIPE_DESCRIPTOR*));\n\n\tif (!MsPipes)\n\t\treturn NULL;\n\n\tfor (pnum = 0; pnum < NumberOfPipes; pnum++)\n\t{\n\t\tMSUSB_PIPE_DESCRIPTOR* MsPipe = msusb_mspipe_new();\n\n\t\tif (!MsPipe)\n\t\t\tgoto out_error;\n\n\t\tStream_Read_UINT16(s, MsPipe->MaximumPacketSize);\n\t\tStream_Seek(s, 2);\n\t\tStream_Read_UINT32(s, MsPipe->MaximumTransferSize);\n\t\tStream_Read_UINT32(s, MsPipe->PipeFlags);\n\t\t/* Already set to zero by memset\n\t\t        MsPipe->PipeHandle\t   = 0;\n\t\t        MsPipe->bEndpointAddress = 0;\n\t\t        MsPipe->bInterval\t\t= 0;\n\t\t        MsPipe->PipeType\t\t = 0;\n\t\t        MsPipe->InitCompleted\t= 0;\n\t\t*/\n\t\tMsPipes[pnum] = MsPipe;\n\t}\n\n\treturn MsPipes;\nout_error:\n\n\tfor (pnum = 0; pnum < NumberOfPipes; pnum++)\n\t\tfree(MsPipes[pnum]);\n\n\tfree(MsPipes);\n\treturn NULL;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148335,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "bool do_notify_parent(struct task_struct *tsk, int sig)\n{\n\tstruct kernel_siginfo info;\n\tunsigned long flags;\n\tstruct sighand_struct *psig;\n\tbool autoreap = false;\n\tu64 utime, stime;\n\n\tBUG_ON(sig == -1);\n\n \t/* do_notify_parent_cldstop should have been called instead.  */\n \tBUG_ON(task_is_stopped_or_traced(tsk));\n\n\tBUG_ON(!tsk->ptrace &&\n\t       (tsk->group_leader != tsk || !thread_group_empty(tsk)));\n\n\t/* Wake up all pidfd waiters */\n\tdo_notify_pidfd(tsk);\n\n\tif (sig != SIGCHLD) {\n\t\t/*\n\t\t * This is only possible if parent == real_parent.\n\t\t * Check if it has changed security domain.\n\t\t */\n\t\tif (tsk->parent_exec_id != tsk->parent->self_exec_id)\n\t\t\tsig = SIGCHLD;\n\t}\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\t/*\n\t * We are under tasklist_lock here so our parent is tied to\n\t * us and cannot change.\n\t *\n\t * task_active_pid_ns will always return the same pid namespace\n\t * until a task passes through release_task.\n\t *\n\t * write_lock() currently calls preempt_disable() which is the\n\t * same as rcu_read_lock(), but according to Oleg, this is not\n\t * correct to rely on this\n\t */\n\trcu_read_lock();\n\tinfo.si_pid = task_pid_nr_ns(tsk, task_active_pid_ns(tsk->parent));\n\tinfo.si_uid = from_kuid_munged(task_cred_xxx(tsk->parent, user_ns),\n\t\t\t\t       task_uid(tsk));\n\trcu_read_unlock();\n\n\ttask_cputime(tsk, &utime, &stime);\n\tinfo.si_utime = nsec_to_clock_t(utime + tsk->signal->utime);\n\tinfo.si_stime = nsec_to_clock_t(stime + tsk->signal->stime);\n\n\tinfo.si_status = tsk->exit_code & 0x7f;\n\tif (tsk->exit_code & 0x80)\n\t\tinfo.si_code = CLD_DUMPED;\n\telse if (tsk->exit_code & 0x7f)\n\t\tinfo.si_code = CLD_KILLED;\n\telse {\n\t\tinfo.si_code = CLD_EXITED;\n\t\tinfo.si_status = tsk->exit_code >> 8;\n\t}\n\n\tpsig = tsk->parent->sighand;\n\tspin_lock_irqsave(&psig->siglock, flags);\n\tif (!tsk->ptrace && sig == SIGCHLD &&\n\t    (psig->action[SIGCHLD-1].sa.sa_handler == SIG_IGN ||\n\t     (psig->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDWAIT))) {\n\t\t/*\n\t\t * We are exiting and our parent doesn't care.  POSIX.1\n\t\t * defines special semantics for setting SIGCHLD to SIG_IGN\n\t\t * or setting the SA_NOCLDWAIT flag: we should be reaped\n\t\t * automatically and not left for our parent's wait4 call.\n\t\t * Rather than having the parent do it as a magic kind of\n\t\t * signal handler, we just set this to tell do_exit that we\n\t\t * can be cleaned up without becoming a zombie.  Note that\n\t\t * we still call __wake_up_parent in this case, because a\n\t\t * blocked sys_wait4 might now return -ECHILD.\n\t\t *\n\t\t * Whether we send SIGCHLD or not for SA_NOCLDWAIT\n\t\t * is implementation-defined: we do (if you don't want\n\t\t * it, just use SIG_IGN instead).\n\t\t */\n\t\tautoreap = true;\n\t\tif (psig->action[SIGCHLD-1].sa.sa_handler == SIG_IGN)\n\t\t\tsig = 0;\n\t}\n\tif (valid_signal(sig) && sig)\n\t\t__group_send_sig_info(sig, &info, tsk->parent);\n\t__wake_up_parent(tsk, tsk->parent);\n\tspin_unlock_irqrestore(&psig->siglock, flags);\n\n\treturn autoreap;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148352,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "bool do_notify_parent(struct task_struct *tsk, int sig)\n{\n\tstruct kernel_siginfo info;\n\tunsigned long flags;\n\tstruct sighand_struct *psig;\n\tbool autoreap = false;\n\tu64 utime, stime;\n\n\tBUG_ON(sig == -1);\n\n \t/* do_notify_parent_cldstop should have been called instead.  */\n \tBUG_ON(task_is_stopped_or_traced(tsk));\n\n\tBUG_ON(!tsk->ptrace &&\n\t       (tsk->group_leader != tsk || !thread_group_empty(tsk)));\n\n\t/* Wake up all pidfd waiters */\n\tdo_notify_pidfd(tsk);\n\n\tif (sig != SIGCHLD) {\n\t\t/*\n\t\t * This is only possible if parent == real_parent.\n\t\t * Check if it has changed security domain.\n\t\t */\n\t\tif (tsk->parent_exec_id != READ_ONCE(tsk->parent->self_exec_id))\n\t\t\tsig = SIGCHLD;\n\t}\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\t/*\n\t * We are under tasklist_lock here so our parent is tied to\n\t * us and cannot change.\n\t *\n\t * task_active_pid_ns will always return the same pid namespace\n\t * until a task passes through release_task.\n\t *\n\t * write_lock() currently calls preempt_disable() which is the\n\t * same as rcu_read_lock(), but according to Oleg, this is not\n\t * correct to rely on this\n\t */\n\trcu_read_lock();\n\tinfo.si_pid = task_pid_nr_ns(tsk, task_active_pid_ns(tsk->parent));\n\tinfo.si_uid = from_kuid_munged(task_cred_xxx(tsk->parent, user_ns),\n\t\t\t\t       task_uid(tsk));\n\trcu_read_unlock();\n\n\ttask_cputime(tsk, &utime, &stime);\n\tinfo.si_utime = nsec_to_clock_t(utime + tsk->signal->utime);\n\tinfo.si_stime = nsec_to_clock_t(stime + tsk->signal->stime);\n\n\tinfo.si_status = tsk->exit_code & 0x7f;\n\tif (tsk->exit_code & 0x80)\n\t\tinfo.si_code = CLD_DUMPED;\n\telse if (tsk->exit_code & 0x7f)\n\t\tinfo.si_code = CLD_KILLED;\n\telse {\n\t\tinfo.si_code = CLD_EXITED;\n\t\tinfo.si_status = tsk->exit_code >> 8;\n\t}\n\n\tpsig = tsk->parent->sighand;\n\tspin_lock_irqsave(&psig->siglock, flags);\n\tif (!tsk->ptrace && sig == SIGCHLD &&\n\t    (psig->action[SIGCHLD-1].sa.sa_handler == SIG_IGN ||\n\t     (psig->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDWAIT))) {\n\t\t/*\n\t\t * We are exiting and our parent doesn't care.  POSIX.1\n\t\t * defines special semantics for setting SIGCHLD to SIG_IGN\n\t\t * or setting the SA_NOCLDWAIT flag: we should be reaped\n\t\t * automatically and not left for our parent's wait4 call.\n\t\t * Rather than having the parent do it as a magic kind of\n\t\t * signal handler, we just set this to tell do_exit that we\n\t\t * can be cleaned up without becoming a zombie.  Note that\n\t\t * we still call __wake_up_parent in this case, because a\n\t\t * blocked sys_wait4 might now return -ECHILD.\n\t\t *\n\t\t * Whether we send SIGCHLD or not for SA_NOCLDWAIT\n\t\t * is implementation-defined: we do (if you don't want\n\t\t * it, just use SIG_IGN instead).\n\t\t */\n\t\tautoreap = true;\n\t\tif (psig->action[SIGCHLD-1].sa.sa_handler == SIG_IGN)\n\t\t\tsig = 0;\n\t}\n\tif (valid_signal(sig) && sig)\n\t\t__group_send_sig_info(sig, &info, tsk->parent);\n\t__wake_up_parent(tsk, tsk->parent);\n\tspin_unlock_irqrestore(&psig->siglock, flags);\n\n\treturn autoreap;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148353,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "exif_data_load_data_thumbnail (ExifData *data, const unsigned char *d,\n\t\t\t       unsigned int ds, ExifLong o, ExifLong s)\n{\n\t/* Sanity checks */\n\tif (o >= ds) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\", \"Bogus thumbnail offset (%u).\", o);\n\t\treturn;\n\t}\n\tif (s > ds - o) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\", \"Bogus thumbnail size (%u), max would be %u.\", s, ds-o);\n\t\treturn;\n\t}\n\tif (data->data) \n\t\texif_mem_free (data->priv->mem, data->data);\n\tif (!(data->data = exif_data_alloc (data, s))) {\n\t\tEXIF_LOG_NO_MEMORY (data->priv->log, \"ExifData\", s);\n\t\tdata->size = 0;\n\t\treturn;\n\t}\n\tdata->size = s;\n\tmemcpy (data->data, d + o, s);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148468,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "exif_data_load_data_thumbnail (ExifData *data, const unsigned char *d,\n\t\t\t       unsigned int ds, ExifLong o, ExifLong s)\n{\n\t/* Sanity checks */\n\tif (o >= ds) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\", \"Bogus thumbnail offset (%u).\", o);\n\t\treturn;\n\t}\n\tif (CHECKOVERFLOW(o,ds,s)) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\", \"Bogus thumbnail size (%u), max would be %u.\", s, ds-o);\n\t\treturn;\n\t}\n\tif (data->data) \n\t\texif_mem_free (data->priv->mem, data->data);\n\tif (!(data->data = exif_data_alloc (data, s))) {\n\t\tEXIF_LOG_NO_MEMORY (data->priv->log, \"ExifData\", s);\n\t\tdata->size = 0;\n\t\treturn;\n\t}\n\tdata->size = s;\n\tmemcpy (data->data, d + o, s);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148469,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "FastHufDecoder::FastHufDecoder\n    (const char *&table,\n     int numBytes,\n     int minSymbol,\n     int maxSymbol,\n     int rleSymbol)\n:\n    _rleSymbol (rleSymbol),\n    _numSymbols (0),\n    _minCodeLength (255),\n    _maxCodeLength (0),\n    _idToSymbol (0)\n{\n    //\n    // List of symbols that we find with non-zero code lengths\n    // (listed in the order we find them). Store these in the\n    // same format as the code book stores codes + lengths - \n    // low 6 bits are the length, everything above that is\n    // the symbol.\n    //\n\n    std::vector<Int64> symbols;\n\n    //\n    // The 'base' table is the minimum code at each code length. base[i]\n    // is the smallest code (numerically) of length i.\n    //\n\n    Int64 base[MAX_CODE_LEN + 1];     \n\n    //\n    // The 'offset' table is the position (in sorted order) of the first id\n    // of a given code lenght. Array is indexed by code length, like base.  \n    //\n\n    Int64 offset[MAX_CODE_LEN + 1];   \n\n    //\n    // Count of how many codes at each length there are. Array is \n    // indexed by code length, like base and offset.\n    //\n\n    size_t codeCount[MAX_CODE_LEN + 1];    \n\n    for (int i = 0; i <= MAX_CODE_LEN; ++i)\n    {\n        codeCount[i] = 0;\n        base[i]      = 0xffffffffffffffffULL;\n        offset[i]    = 0;\n    }\n\n    //\n    // Count the number of codes, the min/max code lengths, the number of\n    // codes with each length, and record symbols with non-zero code\n    // length as we find them.\n    //\n\n    const char *currByte     = table;\n    Int64       currBits     = 0;\n    int         currBitCount = 0;\n\n    const int SHORT_ZEROCODE_RUN = 59;\n    const int LONG_ZEROCODE_RUN  = 63;\n    const int SHORTEST_LONG_RUN  = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;\n\n    for (Int64 symbol = static_cast<Int64>(minSymbol); symbol <= static_cast<Int64>(maxSymbol); symbol++)\n    {\n        if (currByte - table > numBytes)\n        {\n            throw IEX_NAMESPACE::InputExc (\"Error decoding Huffman table \"\n                                           \"(Truncated table data).\");\n        }\n\n        //\n        // Next code length - either:\n        //       0-58  (literal code length)\n        //       59-62 (various lengths runs of 0)\n        //       63    (run of n 0's, with n is the next 8 bits)\n        //\n\n        Int64 codeLen = readBits (6, currBits, currBitCount, currByte);\n\n        if (codeLen == (Int64) LONG_ZEROCODE_RUN)\n        {\n            if (currByte - table > numBytes)\n            {\n                throw IEX_NAMESPACE::InputExc (\"Error decoding Huffman table \"\n                                               \"(Truncated table data).\");\n            }\n\n            int runLen = readBits (8, currBits, currBitCount, currByte) +\n                         SHORTEST_LONG_RUN;\n\n            if (symbol + runLen > static_cast<Int64>(maxSymbol + 1))\n            {\n                throw IEX_NAMESPACE::InputExc (\"Error decoding Huffman table \"\n                                               \"(Run beyond end of table).\");\n            }\n            \n            symbol += runLen - 1;\n\n        }\n        else if (codeLen >= static_cast<Int64>(SHORT_ZEROCODE_RUN))\n        {\n            int runLen = codeLen - SHORT_ZEROCODE_RUN + 2;\n\n            if (symbol + runLen > static_cast<Int64>(maxSymbol + 1))\n            {\n                throw IEX_NAMESPACE::InputExc (\"Error decoding Huffman table \"\n                                               \"(Run beyond end of table).\");\n            }\n\n            symbol += runLen - 1;\n\n        }\n        else if (codeLen != 0)\n        {\n            symbols.push_back ((symbol << 6) | (codeLen & 63));\n\n            if (codeLen < _minCodeLength)\n                _minCodeLength = codeLen;\n\n            if (codeLen > _maxCodeLength)\n                _maxCodeLength = codeLen;\n\n            codeCount[codeLen]++;\n        }\n    }\n\n    for (int i = 0; i < MAX_CODE_LEN; ++i)\n        _numSymbols += codeCount[i];\n\n    table = currByte;\n\n    //\n    // Compute base - once we have the code length counts, there\n    //                is a closed form solution for this\n    //\n\n    {\n        double* countTmp = new double[_maxCodeLength+1];\n\n        for (int l = _minCodeLength; l <= _maxCodeLength; ++l)\n        {\n            countTmp[l] = (double)codeCount[l] * \n                          (double)(2 << (_maxCodeLength-l));\n        }\n    \n        for (int l = _minCodeLength; l <= _maxCodeLength; ++l)\n        {\n            double tmp = 0;\n\n            for (int k =l + 1; k <= _maxCodeLength; ++k)\n                tmp += countTmp[k];\n            \n            tmp /= (double)(2 << (_maxCodeLength - l));\n\n            base[l] = (Int64)ceil (tmp);\n        }\n\n        delete [] countTmp;\n    }\n   \n    //\n    // Compute offset - these are the positions of the first\n    //                  id (not symbol) that has length [i]\n    //\n\n    offset[_maxCodeLength] = 0;\n\n    for (int i= _maxCodeLength - 1; i >= _minCodeLength; i--)\n        offset[i] = offset[i + 1] + codeCount[i + 1];\n\n    //\n    // Allocate and fill the symbol-to-id mapping. Smaller Ids should be\n    // mapped to less-frequent symbols (which have longer codes). Use\n    // the offset table to tell us where the id's for a given code \n    // length start off.\n    //\n\n    _idToSymbol = new int[_numSymbols];\n\n    Int64 mapping[MAX_CODE_LEN + 1];\n    for (int i = 0; i < MAX_CODE_LEN + 1; ++i) \n        mapping[i] = -1;\n    for (int i = _minCodeLength; i <= _maxCodeLength; ++i)\n        mapping[i] = offset[i];\n\n    for (std::vector<Int64>::const_iterator i = symbols.begin(); \n         i != symbols.end();\n         ++i)\n    {\n        int codeLen = *i & 63;\n        int symbol  = *i >> 6;\n\n        if (mapping[codeLen] >= static_cast<Int64>(_numSymbols))\n        {\n            delete[] _idToSymbol;\n            _idToSymbol = NULL;\n            throw IEX_NAMESPACE::InputExc (\"Huffman decode error \"\n                                           \"(Invalid symbol in header).\");\n        }\n        _idToSymbol[mapping[codeLen]] = symbol;\n        mapping[codeLen]++;\n    }\n\n    //\n    // exceptions can be thrown whilst building tables. Delete\n    // _idToSynmbol before re-throwing to prevent memory leak\n    //\n    try\n    {\n      buildTables(base, offset);\n    }catch(...)\n    {\n            delete[] _idToSymbol;\n            _idToSymbol = NULL;\n            throw;\n    }\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148516,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "FastHufDecoder::FastHufDecoder\n    (const char *&table,\n     int numBytes,\n     int minSymbol,\n     int maxSymbol,\n     int rleSymbol)\n:\n    _rleSymbol (rleSymbol),\n    _numSymbols (0),\n    _minCodeLength (255),\n    _maxCodeLength (0),\n    _idToSymbol (0)\n{\n    //\n    // List of symbols that we find with non-zero code lengths\n    // (listed in the order we find them). Store these in the\n    // same format as the code book stores codes + lengths - \n    // low 6 bits are the length, everything above that is\n    // the symbol.\n    //\n\n    std::vector<Int64> symbols;\n\n    //\n    // The 'base' table is the minimum code at each code length. base[i]\n    // is the smallest code (numerically) of length i.\n    //\n\n    Int64 base[MAX_CODE_LEN + 1];     \n\n    //\n    // The 'offset' table is the position (in sorted order) of the first id\n    // of a given code lenght. Array is indexed by code length, like base.  \n    //\n\n    Int64 offset[MAX_CODE_LEN + 1];   \n\n    //\n    // Count of how many codes at each length there are. Array is \n    // indexed by code length, like base and offset.\n    //\n\n    size_t codeCount[MAX_CODE_LEN + 1];    \n\n    for (int i = 0; i <= MAX_CODE_LEN; ++i)\n    {\n        codeCount[i] = 0;\n        base[i]      = 0xffffffffffffffffULL;\n        offset[i]    = 0;\n    }\n\n    //\n    // Count the number of codes, the min/max code lengths, the number of\n    // codes with each length, and record symbols with non-zero code\n    // length as we find them.\n    //\n\n    const char *currByte     = table;\n    Int64       currBits     = 0;\n    int         currBitCount = 0;\n\n    const int SHORT_ZEROCODE_RUN = 59;\n    const int LONG_ZEROCODE_RUN  = 63;\n    const int SHORTEST_LONG_RUN  = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;\n\n    for (Int64 symbol = static_cast<Int64>(minSymbol); symbol <= static_cast<Int64>(maxSymbol); symbol++)\n    {\n        if (currByte - table > numBytes)\n        {\n            throw IEX_NAMESPACE::InputExc (\"Error decoding Huffman table \"\n                                           \"(Truncated table data).\");\n        }\n\n        //\n        // Next code length - either:\n        //       0-58  (literal code length)\n        //       59-62 (various lengths runs of 0)\n        //       63    (run of n 0's, with n is the next 8 bits)\n        //\n\n        Int64 codeLen = readBits (6, currBits, currBitCount, currByte);\n\n        if (codeLen == (Int64) LONG_ZEROCODE_RUN)\n        {\n            if (currByte - table > numBytes)\n            {\n                throw IEX_NAMESPACE::InputExc (\"Error decoding Huffman table \"\n                                               \"(Truncated table data).\");\n            }\n\n            int runLen = readBits (8, currBits, currBitCount, currByte) +\n                         SHORTEST_LONG_RUN;\n\n            if (symbol + runLen > static_cast<Int64>(maxSymbol + 1))\n            {\n                throw IEX_NAMESPACE::InputExc (\"Error decoding Huffman table \"\n                                               \"(Run beyond end of table).\");\n            }\n            \n            symbol += runLen - 1;\n\n        }\n        else if (codeLen >= static_cast<Int64>(SHORT_ZEROCODE_RUN))\n        {\n            int runLen = codeLen - SHORT_ZEROCODE_RUN + 2;\n\n            if (symbol + runLen > static_cast<Int64>(maxSymbol + 1))\n            {\n                throw IEX_NAMESPACE::InputExc (\"Error decoding Huffman table \"\n                                               \"(Run beyond end of table).\");\n            }\n\n            symbol += runLen - 1;\n\n        }\n        else if (codeLen != 0)\n        {\n            symbols.push_back ((symbol << 6) | (codeLen & 63));\n\n            if (codeLen < _minCodeLength)\n                _minCodeLength = codeLen;\n\n            if (codeLen > _maxCodeLength)\n                _maxCodeLength = codeLen;\n\n            codeCount[codeLen]++;\n        }\n    }\n\n    for (int i = 0; i < MAX_CODE_LEN; ++i)\n        _numSymbols += codeCount[i];\n\n    table = currByte;\n\n    //\n    // Compute base - once we have the code length counts, there\n    //                is a closed form solution for this\n    //\n\n    {\n        double* countTmp = new double[_maxCodeLength+1];\n\n        for (int l = _minCodeLength; l <= _maxCodeLength; ++l)\n        {\n            countTmp[l] = (double)codeCount[l] * \n                          (double)(2ll << (_maxCodeLength-l));\n        }\n    \n        for (int l = _minCodeLength; l <= _maxCodeLength; ++l)\n        {\n            double tmp = 0;\n\n            for (int k =l + 1; k <= _maxCodeLength; ++k)\n                tmp += countTmp[k];\n            \n            tmp /= (double)(2ll << (_maxCodeLength - l));\n\n            base[l] = (Int64)ceil (tmp);\n        }\n\n        delete [] countTmp;\n    }\n   \n    //\n    // Compute offset - these are the positions of the first\n    //                  id (not symbol) that has length [i]\n    //\n\n    offset[_maxCodeLength] = 0;\n\n    for (int i= _maxCodeLength - 1; i >= _minCodeLength; i--)\n        offset[i] = offset[i + 1] + codeCount[i + 1];\n\n    //\n    // Allocate and fill the symbol-to-id mapping. Smaller Ids should be\n    // mapped to less-frequent symbols (which have longer codes). Use\n    // the offset table to tell us where the id's for a given code \n    // length start off.\n    //\n\n    _idToSymbol = new int[_numSymbols];\n\n    Int64 mapping[MAX_CODE_LEN + 1];\n    for (int i = 0; i < MAX_CODE_LEN + 1; ++i) \n        mapping[i] = -1;\n    for (int i = _minCodeLength; i <= _maxCodeLength; ++i)\n        mapping[i] = offset[i];\n\n    for (std::vector<Int64>::const_iterator i = symbols.begin(); \n         i != symbols.end();\n         ++i)\n    {\n        int codeLen = *i & 63;\n        int symbol  = *i >> 6;\n\n        if (mapping[codeLen] >= static_cast<Int64>(_numSymbols))\n        {\n            delete[] _idToSymbol;\n            _idToSymbol = NULL;\n            throw IEX_NAMESPACE::InputExc (\"Huffman decode error \"\n                                           \"(Invalid symbol in header).\");\n        }\n        _idToSymbol[mapping[codeLen]] = symbol;\n        mapping[codeLen]++;\n    }\n\n    //\n    // exceptions can be thrown whilst building tables. Delete\n    // _idToSynmbol before re-throwing to prevent memory leak\n    //\n    try\n    {\n      buildTables(base, offset);\n    }catch(...)\n    {\n            delete[] _idToSymbol;\n            _idToSymbol = NULL;\n            throw;\n    }\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148517,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "UnicodeString::doAppend(const UChar *srcChars, int32_t srcStart, int32_t srcLength) {\n  if(!isWritable() || srcLength == 0 || srcChars == NULL) {\n    return *this;\n  }\n\n  // Perform all remaining operations relative to srcChars + srcStart.\n  // From this point forward, do not use srcStart.\n  srcChars += srcStart;\n\n  if(srcLength < 0) {\n    // get the srcLength if necessary\n    if((srcLength = u_strlen(srcChars)) == 0) {\n      return *this;\n    }\n  }\n\n  int32_t oldLength = length();\n  int32_t newLength = oldLength + srcLength;\n\n  // Check for append onto ourself\n  const UChar* oldArray = getArrayStart();\n  if (isBufferWritable() &&\n      oldArray < srcChars + srcLength &&\n      srcChars < oldArray + oldLength) {\n    // Copy into a new UnicodeString and start over\n    UnicodeString copy(srcChars, srcLength);\n    if (copy.isBogus()) {\n      setToBogus();\n      return *this;\n    }\n    return doAppend(copy.getArrayStart(), 0, srcLength);\n  }\n\n  // optimize append() onto a large-enough, owned string\n  if((newLength <= getCapacity() && isBufferWritable()) ||\n      cloneArrayIfNeeded(newLength, getGrowCapacity(newLength))) {\n    UChar *newArray = getArrayStart();\n    // Do not copy characters when\n    //   UChar *buffer=str.getAppendBuffer(...);\n    // is followed by\n    //   str.append(buffer, length);\n    // or\n    //   str.appendString(buffer, length)\n    // or similar.\n    if(srcChars != newArray + oldLength) {\n      us_arrayCopy(srcChars, 0, newArray, oldLength, srcLength);\n    }\n    setLength(newLength);\n  }\n  return *this;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148558,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "UnicodeString::doAppend(const UChar *srcChars, int32_t srcStart, int32_t srcLength) {\n  if(!isWritable() || srcLength == 0 || srcChars == NULL) {\n    return *this;\n  }\n\n  // Perform all remaining operations relative to srcChars + srcStart.\n  // From this point forward, do not use srcStart.\n  srcChars += srcStart;\n\n  if(srcLength < 0) {\n    // get the srcLength if necessary\n    if((srcLength = u_strlen(srcChars)) == 0) {\n      return *this;\n    }\n  }\n\n  int32_t oldLength = length();\n  int32_t newLength;\n  if (uprv_add32_overflow(oldLength, srcLength, &newLength)) {\n    setToBogus();\n    return *this;\n  }\n\n  // Check for append onto ourself\n  const UChar* oldArray = getArrayStart();\n  if (isBufferWritable() &&\n      oldArray < srcChars + srcLength &&\n      srcChars < oldArray + oldLength) {\n    // Copy into a new UnicodeString and start over\n    UnicodeString copy(srcChars, srcLength);\n    if (copy.isBogus()) {\n      setToBogus();\n      return *this;\n    }\n    return doAppend(copy.getArrayStart(), 0, srcLength);\n  }\n\n  // optimize append() onto a large-enough, owned string\n  if((newLength <= getCapacity() && isBufferWritable()) ||\n      cloneArrayIfNeeded(newLength, getGrowCapacity(newLength))) {\n    UChar *newArray = getArrayStart();\n    // Do not copy characters when\n    //   UChar *buffer=str.getAppendBuffer(...);\n    // is followed by\n    //   str.append(buffer, length);\n    // or\n    //   str.appendString(buffer, length)\n    // or similar.\n    if(srcChars != newArray + oldLength) {\n      us_arrayCopy(srcChars, 0, newArray, oldLength, srcLength);\n    }\n    setLength(newLength);\n  }\n  return *this;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148559,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "void stralgoLCS(client *c) {\n    uint32_t i, j;\n    long long minmatchlen = 0;\n    sds a = NULL, b = NULL;\n    int getlen = 0, getidx = 0, withmatchlen = 0;\n    robj *obja = NULL, *objb = NULL;\n\n    for (j = 2; j < (uint32_t)c->argc; j++) {\n        char *opt = c->argv[j]->ptr;\n        int moreargs = (c->argc-1) - j;\n\n        if (!strcasecmp(opt,\"IDX\")) {\n            getidx = 1;\n        } else if (!strcasecmp(opt,\"LEN\")) {\n            getlen = 1;\n        } else if (!strcasecmp(opt,\"WITHMATCHLEN\")) {\n            withmatchlen = 1;\n        } else if (!strcasecmp(opt,\"MINMATCHLEN\") && moreargs) {\n            if (getLongLongFromObjectOrReply(c,c->argv[j+1],&minmatchlen,NULL)\n                != C_OK) goto cleanup;\n            if (minmatchlen < 0) minmatchlen = 0;\n            j++;\n        } else if (!strcasecmp(opt,\"STRINGS\") && moreargs > 1) {\n            if (a != NULL) {\n                addReplyError(c,\"Either use STRINGS or KEYS\");\n                goto cleanup;\n            }\n            a = c->argv[j+1]->ptr;\n            b = c->argv[j+2]->ptr;\n            j += 2;\n        } else if (!strcasecmp(opt,\"KEYS\") && moreargs > 1) {\n            if (a != NULL) {\n                addReplyError(c,\"Either use STRINGS or KEYS\");\n                goto cleanup;\n            }\n            obja = lookupKeyRead(c->db,c->argv[j+1]);\n            objb = lookupKeyRead(c->db,c->argv[j+2]);\n            if ((obja && obja->type != OBJ_STRING) ||\n                (objb && objb->type != OBJ_STRING))\n            {\n                addReplyError(c,\n                    \"The specified keys must contain string values\");\n                /* Don't cleanup the objects, we need to do that\n                 * only after calling getDecodedObject(). */\n                obja = NULL;\n                objb = NULL;\n                goto cleanup;\n            }\n            obja = obja ? getDecodedObject(obja) : createStringObject(\"\",0);\n            objb = objb ? getDecodedObject(objb) : createStringObject(\"\",0);\n            a = obja->ptr;\n            b = objb->ptr;\n            j += 2;\n        } else {\n            addReplyErrorObject(c,shared.syntaxerr);\n            goto cleanup;\n        }\n    }\n\n    /* Complain if the user passed ambiguous parameters. */\n    if (a == NULL) {\n        addReplyError(c,\"Please specify two strings: \"\n                        \"STRINGS or KEYS options are mandatory\");\n        goto cleanup;\n    } else if (getlen && getidx) {\n        addReplyError(c,\n            \"If you want both the length and indexes, please \"\n            \"just use IDX.\");\n        goto cleanup;\n    }\n\n    /* Compute the LCS using the vanilla dynamic programming technique of\n     * building a table of LCS(x,y) substrings. */\n    uint32_t alen = sdslen(a);\n    uint32_t blen = sdslen(b);\n\n    /* Setup an uint32_t array to store at LCS[i,j] the length of the\n     * LCS A0..i-1, B0..j-1. Note that we have a linear array here, so\n     * we index it as LCS[j+(blen+1)*j] */\n    uint32_t *lcs = zmalloc((alen+1)*(blen+1)*sizeof(uint32_t));\n    #define LCS(A,B) lcs[(B)+((A)*(blen+1))]\n\n    /* Start building the LCS table. */\n    for (uint32_t i = 0; i <= alen; i++) {\n        for (uint32_t j = 0; j <= blen; j++) {\n            if (i == 0 || j == 0) {\n                /* If one substring has length of zero, the\n                 * LCS length is zero. */\n                LCS(i,j) = 0;\n            } else if (a[i-1] == b[j-1]) {\n                /* The len LCS (and the LCS itself) of two\n                 * sequences with the same final character, is the\n                 * LCS of the two sequences without the last char\n                 * plus that last char. */\n                LCS(i,j) = LCS(i-1,j-1)+1;\n            } else {\n                /* If the last character is different, take the longest\n                 * between the LCS of the first string and the second\n                 * minus the last char, and the reverse. */\n                uint32_t lcs1 = LCS(i-1,j);\n                uint32_t lcs2 = LCS(i,j-1);\n                LCS(i,j) = lcs1 > lcs2 ? lcs1 : lcs2;\n            }\n        }\n    }\n\n    /* Store the actual LCS string in \"result\" if needed. We create\n     * it backward, but the length is already known, we store it into idx. */\n    uint32_t idx = LCS(alen,blen);\n    sds result = NULL;        /* Resulting LCS string. */\n    void *arraylenptr = NULL; /* Deffered length of the array for IDX. */\n    uint32_t arange_start = alen, /* alen signals that values are not set. */\n             arange_end = 0,\n             brange_start = 0,\n             brange_end = 0;\n\n    /* Do we need to compute the actual LCS string? Allocate it in that case. */\n    int computelcs = getidx || !getlen;\n    if (computelcs) result = sdsnewlen(SDS_NOINIT,idx);\n\n    /* Start with a deferred array if we have to emit the ranges. */\n    uint32_t arraylen = 0;  /* Number of ranges emitted in the array. */\n    if (getidx) {\n        addReplyMapLen(c,2);\n        addReplyBulkCString(c,\"matches\");\n        arraylenptr = addReplyDeferredLen(c);\n    }\n\n    i = alen, j = blen;\n    while (computelcs && i > 0 && j > 0) {\n        int emit_range = 0;\n        if (a[i-1] == b[j-1]) {\n            /* If there is a match, store the character and reduce\n             * the indexes to look for a new match. */\n            result[idx-1] = a[i-1];\n\n            /* Track the current range. */\n            if (arange_start == alen) {\n                arange_start = i-1;\n                arange_end = i-1;\n                brange_start = j-1;\n                brange_end = j-1;\n            } else {\n                /* Let's see if we can extend the range backward since\n                 * it is contiguous. */\n                if (arange_start == i && brange_start == j) {\n                    arange_start--;\n                    brange_start--;\n                } else {\n                    emit_range = 1;\n                }\n            }\n            /* Emit the range if we matched with the first byte of\n             * one of the two strings. We'll exit the loop ASAP. */\n            if (arange_start == 0 || brange_start == 0) emit_range = 1;\n            idx--; i--; j--;\n        } else {\n            /* Otherwise reduce i and j depending on the largest\n             * LCS between, to understand what direction we need to go. */\n            uint32_t lcs1 = LCS(i-1,j);\n            uint32_t lcs2 = LCS(i,j-1);\n            if (lcs1 > lcs2)\n                i--;\n            else\n                j--;\n            if (arange_start != alen) emit_range = 1;\n        }\n\n        /* Emit the current range if needed. */\n        uint32_t match_len = arange_end - arange_start + 1;\n        if (emit_range) {\n            if (minmatchlen == 0 || match_len >= minmatchlen) {\n                if (arraylenptr) {\n                    addReplyArrayLen(c,2+withmatchlen);\n                    addReplyArrayLen(c,2);\n                    addReplyLongLong(c,arange_start);\n                    addReplyLongLong(c,arange_end);\n                    addReplyArrayLen(c,2);\n                    addReplyLongLong(c,brange_start);\n                    addReplyLongLong(c,brange_end);\n                    if (withmatchlen) addReplyLongLong(c,match_len);\n                    arraylen++;\n                }\n            }\n            arange_start = alen; /* Restart at the next match. */\n        }\n    }\n\n    /* Signal modified key, increment dirty, ... */\n\n    /* Reply depending on the given options. */\n    if (arraylenptr) {\n        addReplyBulkCString(c,\"len\");\n        addReplyLongLong(c,LCS(alen,blen));\n        setDeferredArrayLen(c,arraylenptr,arraylen);\n    } else if (getlen) {\n        addReplyLongLong(c,LCS(alen,blen));\n    } else {\n        addReplyBulkSds(c,result);\n        result = NULL;\n    }\n\n    /* Cleanup. */\n    sdsfree(result);\n    zfree(lcs);\n\ncleanup:\n    if (obja) decrRefCount(obja);\n    if (objb) decrRefCount(objb);\n    return;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148630,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ],
    "human": "Correct. With CWE-190",
    "reason": "Vulnerable to CWE-190 due to integer overflow in LCS table allocation."
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "void stralgoLCS(client *c) {\n    uint32_t i, j;\n    long long minmatchlen = 0;\n    sds a = NULL, b = NULL;\n    int getlen = 0, getidx = 0, withmatchlen = 0;\n    robj *obja = NULL, *objb = NULL;\n\n    for (j = 2; j < (uint32_t)c->argc; j++) {\n        char *opt = c->argv[j]->ptr;\n        int moreargs = (c->argc-1) - j;\n\n        if (!strcasecmp(opt,\"IDX\")) {\n            getidx = 1;\n        } else if (!strcasecmp(opt,\"LEN\")) {\n            getlen = 1;\n        } else if (!strcasecmp(opt,\"WITHMATCHLEN\")) {\n            withmatchlen = 1;\n        } else if (!strcasecmp(opt,\"MINMATCHLEN\") && moreargs) {\n            if (getLongLongFromObjectOrReply(c,c->argv[j+1],&minmatchlen,NULL)\n                != C_OK) goto cleanup;\n            if (minmatchlen < 0) minmatchlen = 0;\n            j++;\n        } else if (!strcasecmp(opt,\"STRINGS\") && moreargs > 1) {\n            if (a != NULL) {\n                addReplyError(c,\"Either use STRINGS or KEYS\");\n                goto cleanup;\n            }\n            a = c->argv[j+1]->ptr;\n            b = c->argv[j+2]->ptr;\n            j += 2;\n        } else if (!strcasecmp(opt,\"KEYS\") && moreargs > 1) {\n            if (a != NULL) {\n                addReplyError(c,\"Either use STRINGS or KEYS\");\n                goto cleanup;\n            }\n            obja = lookupKeyRead(c->db,c->argv[j+1]);\n            objb = lookupKeyRead(c->db,c->argv[j+2]);\n            if ((obja && obja->type != OBJ_STRING) ||\n                (objb && objb->type != OBJ_STRING))\n            {\n                addReplyError(c,\n                    \"The specified keys must contain string values\");\n                /* Don't cleanup the objects, we need to do that\n                 * only after calling getDecodedObject(). */\n                obja = NULL;\n                objb = NULL;\n                goto cleanup;\n            }\n            obja = obja ? getDecodedObject(obja) : createStringObject(\"\",0);\n            objb = objb ? getDecodedObject(objb) : createStringObject(\"\",0);\n            a = obja->ptr;\n            b = objb->ptr;\n            j += 2;\n        } else {\n            addReplyErrorObject(c,shared.syntaxerr);\n            goto cleanup;\n        }\n    }\n\n    /* Complain if the user passed ambiguous parameters. */\n    if (a == NULL) {\n        addReplyError(c,\"Please specify two strings: \"\n                        \"STRINGS or KEYS options are mandatory\");\n        goto cleanup;\n    } else if (getlen && getidx) {\n        addReplyError(c,\n            \"If you want both the length and indexes, please \"\n            \"just use IDX.\");\n        goto cleanup;\n    }\n\n    /* Compute the LCS using the vanilla dynamic programming technique of\n     * building a table of LCS(x,y) substrings. */\n    uint32_t alen = sdslen(a);\n    uint32_t blen = sdslen(b);\n\n    /* Setup an uint32_t array to store at LCS[i,j] the length of the\n     * LCS A0..i-1, B0..j-1. Note that we have a linear array here, so\n     * we index it as LCS[j+(blen+1)*j] */\n    uint32_t *lcs = zmalloc((size_t)(alen+1)*(blen+1)*sizeof(uint32_t));\n    #define LCS(A,B) lcs[(B)+((A)*(blen+1))]\n\n    /* Start building the LCS table. */\n    for (uint32_t i = 0; i <= alen; i++) {\n        for (uint32_t j = 0; j <= blen; j++) {\n            if (i == 0 || j == 0) {\n                /* If one substring has length of zero, the\n                 * LCS length is zero. */\n                LCS(i,j) = 0;\n            } else if (a[i-1] == b[j-1]) {\n                /* The len LCS (and the LCS itself) of two\n                 * sequences with the same final character, is the\n                 * LCS of the two sequences without the last char\n                 * plus that last char. */\n                LCS(i,j) = LCS(i-1,j-1)+1;\n            } else {\n                /* If the last character is different, take the longest\n                 * between the LCS of the first string and the second\n                 * minus the last char, and the reverse. */\n                uint32_t lcs1 = LCS(i-1,j);\n                uint32_t lcs2 = LCS(i,j-1);\n                LCS(i,j) = lcs1 > lcs2 ? lcs1 : lcs2;\n            }\n        }\n    }\n\n    /* Store the actual LCS string in \"result\" if needed. We create\n     * it backward, but the length is already known, we store it into idx. */\n    uint32_t idx = LCS(alen,blen);\n    sds result = NULL;        /* Resulting LCS string. */\n    void *arraylenptr = NULL; /* Deffered length of the array for IDX. */\n    uint32_t arange_start = alen, /* alen signals that values are not set. */\n             arange_end = 0,\n             brange_start = 0,\n             brange_end = 0;\n\n    /* Do we need to compute the actual LCS string? Allocate it in that case. */\n    int computelcs = getidx || !getlen;\n    if (computelcs) result = sdsnewlen(SDS_NOINIT,idx);\n\n    /* Start with a deferred array if we have to emit the ranges. */\n    uint32_t arraylen = 0;  /* Number of ranges emitted in the array. */\n    if (getidx) {\n        addReplyMapLen(c,2);\n        addReplyBulkCString(c,\"matches\");\n        arraylenptr = addReplyDeferredLen(c);\n    }\n\n    i = alen, j = blen;\n    while (computelcs && i > 0 && j > 0) {\n        int emit_range = 0;\n        if (a[i-1] == b[j-1]) {\n            /* If there is a match, store the character and reduce\n             * the indexes to look for a new match. */\n            result[idx-1] = a[i-1];\n\n            /* Track the current range. */\n            if (arange_start == alen) {\n                arange_start = i-1;\n                arange_end = i-1;\n                brange_start = j-1;\n                brange_end = j-1;\n            } else {\n                /* Let's see if we can extend the range backward since\n                 * it is contiguous. */\n                if (arange_start == i && brange_start == j) {\n                    arange_start--;\n                    brange_start--;\n                } else {\n                    emit_range = 1;\n                }\n            }\n            /* Emit the range if we matched with the first byte of\n             * one of the two strings. We'll exit the loop ASAP. */\n            if (arange_start == 0 || brange_start == 0) emit_range = 1;\n            idx--; i--; j--;\n        } else {\n            /* Otherwise reduce i and j depending on the largest\n             * LCS between, to understand what direction we need to go. */\n            uint32_t lcs1 = LCS(i-1,j);\n            uint32_t lcs2 = LCS(i,j-1);\n            if (lcs1 > lcs2)\n                i--;\n            else\n                j--;\n            if (arange_start != alen) emit_range = 1;\n        }\n\n        /* Emit the current range if needed. */\n        uint32_t match_len = arange_end - arange_start + 1;\n        if (emit_range) {\n            if (minmatchlen == 0 || match_len >= minmatchlen) {\n                if (arraylenptr) {\n                    addReplyArrayLen(c,2+withmatchlen);\n                    addReplyArrayLen(c,2);\n                    addReplyLongLong(c,arange_start);\n                    addReplyLongLong(c,arange_end);\n                    addReplyArrayLen(c,2);\n                    addReplyLongLong(c,brange_start);\n                    addReplyLongLong(c,brange_end);\n                    if (withmatchlen) addReplyLongLong(c,match_len);\n                    arraylen++;\n                }\n            }\n            arange_start = alen; /* Restart at the next match. */\n        }\n    }\n\n    /* Signal modified key, increment dirty, ... */\n\n    /* Reply depending on the given options. */\n    if (arraylenptr) {\n        addReplyBulkCString(c,\"len\");\n        addReplyLongLong(c,LCS(alen,blen));\n        setDeferredArrayLen(c,arraylenptr,arraylen);\n    } else if (getlen) {\n        addReplyLongLong(c,LCS(alen,blen));\n    } else {\n        addReplyBulkSds(c,result);\n        result = NULL;\n    }\n\n    /* Cleanup. */\n    sdsfree(result);\n    zfree(lcs);\n\ncleanup:\n    if (obja) decrRefCount(obja);\n    if (objb) decrRefCount(objb);\n    return;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148631,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ],
    "human": "Correct. Without CWE-190"
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "gtTileContig(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img->tif;\n    tileContigRoutine put = img->put.contig;\n    uint32 col, row, y, rowstoread;\n    tmsize_t pos;\n    uint32 tw, th;\n    unsigned char* buf = NULL;\n    int32 fromskew, toskew;\n    uint32 nrow;\n    int ret = 1, flip;\n    uint32 this_tw, tocol;\n    int32 this_toskew, leftmost_toskew;\n    int32 leftmost_fromskew;\n    uint32 leftmost_tw;\n    tmsize_t bufsize;\n\n    bufsize = TIFFTileSize(tif);\n    if (bufsize == 0) {\n        TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"%s\", \"No space for tile buffer\");\n        return (0);\n    }\n\n    TIFFGetField(tif, TIFFTAG_TILEWIDTH, &tw);\n    TIFFGetField(tif, TIFFTAG_TILELENGTH, &th);\n\n    flip = setorientation(img);\n    if (flip & FLIP_VERTICALLY) {\n\t    y = h - 1;\n\t    toskew = -(int32)(tw + w);\n    }\n    else {\n\t    y = 0;\n\t    toskew = -(int32)(tw - w);\n    }\n     \n    /*\n     *\tLeftmost tile is clipped on left side if col_offset > 0.\n     */\n    leftmost_fromskew = img->col_offset % tw;\n    leftmost_tw = tw - leftmost_fromskew;\n    leftmost_toskew = toskew + leftmost_fromskew;\n    for (row = 0; ret != 0 && row < h; row += nrow)\n    {\n        rowstoread = th - (row + img->row_offset) % th;\n    \tnrow = (row + rowstoread > h ? h - row : rowstoread);\n\tfromskew = leftmost_fromskew;\n\tthis_tw = leftmost_tw;\n\tthis_toskew = leftmost_toskew;\n\ttocol = 0;\n\tcol = img->col_offset;\n\twhile (tocol < w)\n        {\n\t    if (_TIFFReadTileAndAllocBuffer(tif, (void**) &buf, bufsize, col,\n\t\t\t     row+img->row_offset, 0, 0)==(tmsize_t)(-1) &&\n                (buf == NULL || img->stoponerr))\n            {\n                ret = 0;\n                break;\n            }\n            pos = ((row+img->row_offset) % th) * TIFFTileRowSize(tif) + \\\n\t\t   ((tmsize_t) fromskew * img->samplesperpixel);\n\t    if (tocol + this_tw > w) \n\t    {\n\t\t/*\n\t\t * Rightmost tile is clipped on right side.\n\t\t */\n\t\tfromskew = tw - (w - tocol);\n\t\tthis_tw = tw - fromskew;\n\t\tthis_toskew = toskew + fromskew;\n\t    }\n\t    (*put)(img, raster+y*w+tocol, tocol, y, this_tw, nrow, fromskew, this_toskew, buf + pos);\n\t    tocol += this_tw;\n\t    col += this_tw;\n\t    /*\n\t     * After the leftmost tile, tiles are no longer clipped on left side.\n\t     */\n\t    fromskew = 0;\n\t    this_tw = tw;\n\t    this_toskew = toskew;\n\t}\n\n        y += ((flip & FLIP_VERTICALLY) ? -(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n\n    if (flip & FLIP_HORIZONTALLY) {\n\t    uint32 line;\n\n\t    for (line = 0; line < h; line++) {\n\t\t    uint32 *left = raster + (line * w);\n\t\t    uint32 *right = left + w - 1;\n\t\t    \n\t\t    while ( left < right ) {\n\t\t\t    uint32 temp = *left;\n\t\t\t    *left = *right;\n\t\t\t    *right = temp;\n\t\t\t    left++;\n\t\t\t\tright--;\n\t\t    }\n\t    }\n    }\n\n    return (ret);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148634,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "gtTileContig(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img->tif;\n    tileContigRoutine put = img->put.contig;\n    uint32 col, row, y, rowstoread;\n    tmsize_t pos;\n    uint32 tw, th;\n    unsigned char* buf = NULL;\n    int32 fromskew, toskew;\n    uint32 nrow;\n    int ret = 1, flip;\n    uint32 this_tw, tocol;\n    int32 this_toskew, leftmost_toskew;\n    int32 leftmost_fromskew;\n    uint32 leftmost_tw;\n    tmsize_t bufsize;\n\n    bufsize = TIFFTileSize(tif);\n    if (bufsize == 0) {\n        TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"%s\", \"No space for tile buffer\");\n        return (0);\n    }\n\n    TIFFGetField(tif, TIFFTAG_TILEWIDTH, &tw);\n    TIFFGetField(tif, TIFFTAG_TILELENGTH, &th);\n\n    flip = setorientation(img);\n    if (flip & FLIP_VERTICALLY) {\n        if ((tw + w) > INT_MAX) {\n            TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"%s\", \"unsupported tile size (too wide)\");\n            return (0);\n        }\n        y = h - 1;\n        toskew = -(int32)(tw + w);\n    }\n    else {\n        if (tw > (INT_MAX + w)) {\n            TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"%s\", \"unsupported tile size (too wide)\");\n            return (0);\n        }\n        y = 0;\n        toskew = -(int32)(tw - w);\n    }\n     \n    /*\n     *\tLeftmost tile is clipped on left side if col_offset > 0.\n     */\n    leftmost_fromskew = img->col_offset % tw;\n    leftmost_tw = tw - leftmost_fromskew;\n    leftmost_toskew = toskew + leftmost_fromskew;\n    for (row = 0; ret != 0 && row < h; row += nrow)\n    {\n        rowstoread = th - (row + img->row_offset) % th;\n    \tnrow = (row + rowstoread > h ? h - row : rowstoread);\n\tfromskew = leftmost_fromskew;\n\tthis_tw = leftmost_tw;\n\tthis_toskew = leftmost_toskew;\n\ttocol = 0;\n\tcol = img->col_offset;\n\twhile (tocol < w)\n        {\n\t    if (_TIFFReadTileAndAllocBuffer(tif, (void**) &buf, bufsize, col,\n\t\t\t     row+img->row_offset, 0, 0)==(tmsize_t)(-1) &&\n                (buf == NULL || img->stoponerr))\n            {\n                ret = 0;\n                break;\n            }\n            pos = ((row+img->row_offset) % th) * TIFFTileRowSize(tif) + \\\n\t\t   ((tmsize_t) fromskew * img->samplesperpixel);\n\t    if (tocol + this_tw > w) \n\t    {\n\t\t/*\n\t\t * Rightmost tile is clipped on right side.\n\t\t */\n\t\tfromskew = tw - (w - tocol);\n\t\tthis_tw = tw - fromskew;\n\t\tthis_toskew = toskew + fromskew;\n\t    }\n\t    (*put)(img, raster+y*w+tocol, tocol, y, this_tw, nrow, fromskew, this_toskew, buf + pos);\n\t    tocol += this_tw;\n\t    col += this_tw;\n\t    /*\n\t     * After the leftmost tile, tiles are no longer clipped on left side.\n\t     */\n\t    fromskew = 0;\n\t    this_tw = tw;\n\t    this_toskew = toskew;\n\t}\n\n        y += ((flip & FLIP_VERTICALLY) ? -(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n\n    if (flip & FLIP_HORIZONTALLY) {\n\t    uint32 line;\n\n\t    for (line = 0; line < h; line++) {\n\t\t    uint32 *left = raster + (line * w);\n\t\t    uint32 *right = left + w - 1;\n\t\t    \n\t\t    while ( left < right ) {\n\t\t\t    uint32 temp = *left;\n\t\t\t    *left = *right;\n\t\t\t    *right = temp;\n\t\t\t    left++;\n\t\t\t\tright--;\n\t\t    }\n\t    }\n    }\n\n    return (ret);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148635,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ],
    "human": "Incorrect. With CWE-190",
    "reason": "Vertical flip case is fixed, but non-flip case check is ineffective."
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "INLINE void gdi_RectToCRgn(const HGDI_RECT rect, INT32* x, INT32* y, INT32* w, INT32* h)\n{\n\t*x = rect->left;\n\t*y = rect->top;\n\t*w = rect->right - rect->left + 1;\n\t*h = rect->bottom - rect->top + 1;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148672,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "INLINE void gdi_RectToRgn(HGDI_RECT rect, HGDI_RGN rgn)\n{\n\trgn->x = rect->left;\n\trgn->y = rect->top;\n\trgn->w = rect->right - rect->left + 1;\n\trgn->h = rect->bottom - rect->top + 1;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148673,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ],
    "human": "Incorrect. With CWE-190",
    "reason": "The arithmetic logic is the same as the unfixed one. No checks for boundaries."
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "spell_read_tree(\n    FILE\t*fd,\n    char_u\t**bytsp,\n    idx_T\t**idxsp,\n    int\t\tprefixtree,\t/* TRUE for the prefix tree */\n    int\t\tprefixcnt)\t/* when \"prefixtree\" is TRUE: prefix count */\n{\n    int\t\tlen;\n    int\t\tidx;\n    char_u\t*bp;\n    idx_T\t*ip;\n\n    /* The tree size was computed when writing the file, so that we can\n     * allocate it as one long block. <nodecount> */\n    len = get4c(fd);\n    if (len < 0)\n\treturn SP_TRUNCERROR;\n    if (len > 0)\n    {\n\t/* Allocate the byte array. */\n\tbp = lalloc((long_u)len, TRUE);\n\tif (bp == NULL)\n\t    return SP_OTHERERROR;\n\t*bytsp = bp;\n\n\t/* Allocate the index array. */\n\tip = (idx_T *)lalloc_clear((long_u)(len * sizeof(int)), TRUE);\n\tif (ip == NULL)\n\t    return SP_OTHERERROR;\n\t*idxsp = ip;\n\n\t/* Recursively read the tree and store it in the array. */\n\tidx = read_tree_node(fd, bp, ip, len, 0, prefixtree, prefixcnt);\n\tif (idx < 0)\n\t    return idx;\n    }\n    return 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148698,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ],
    "human": "Correct. With CWE-190",
    "reason": "Vulnerable to CWE-190 due to unchecked integer overflow in len * sizeof(int)."
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "spell_read_tree(\n    FILE\t*fd,\n    char_u\t**bytsp,\n    idx_T\t**idxsp,\n    int\t\tprefixtree,\t/* TRUE for the prefix tree */\n    int\t\tprefixcnt)\t/* when \"prefixtree\" is TRUE: prefix count */\n{\n    int\t\tlen;\n    int\t\tidx;\n    char_u\t*bp;\n    idx_T\t*ip;\n\n    /* The tree size was computed when writing the file, so that we can\n     * allocate it as one long block. <nodecount> */\n    len = get4c(fd);\n    if (len < 0)\n\treturn SP_TRUNCERROR;\n    if (len >= 0x3ffffff)\n\t/* Invalid length, multiply with sizeof(int) would overflow. */\n\treturn SP_FORMERROR;\n    if (len > 0)\n    {\n\t/* Allocate the byte array. */\n\tbp = lalloc((long_u)len, TRUE);\n\tif (bp == NULL)\n\t    return SP_OTHERERROR;\n\t*bytsp = bp;\n\n\t/* Allocate the index array. */\n\tip = (idx_T *)lalloc_clear((long_u)(len * sizeof(int)), TRUE);\n\tif (ip == NULL)\n\t    return SP_OTHERERROR;\n\t*idxsp = ip;\n\n\t/* Recursively read the tree and store it in the array. */\n\tidx = read_tree_node(fd, bp, ip, len, 0, prefixtree, prefixcnt);\n\tif (idx < 0)\n\t    return idx;\n    }\n    return 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148699,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ],
    "human": "Correct. Without CWE-190"
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "ds_fgetstr (FILE *f, dynamic_string *s, char eos)\n{\n  int insize;\t\t\t/* Amount needed for line.  */\n  int strsize;\t\t\t/* Amount allocated for S.  */\n  int next_ch;\n\n  /* Initialize.  */\n  insize = 0;\n  strsize = s->ds_length;\n\n  /* Read the input string.  */\n  next_ch = getc (f);\n  while (next_ch != eos && next_ch != EOF)\n    {\n      if (insize >= strsize - 1)\n\t{\n\t  ds_resize (s, strsize * 2 + 2);\n\t  strsize = s->ds_length;\n\t}\n      s->ds_string[insize++] = next_ch;\n      next_ch = getc (f);\n    }\n  s->ds_string[insize++] = '\\0';\n\n  if (insize == 1 && next_ch == EOF)\n    return NULL;\n  else\n    return s->ds_string;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148744,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "ds_fgetstr (FILE *f, dynamic_string *s, char eos)\n{\n  int next_ch;\n\n  /* Initialize.  */\n  s->ds_idx = 0;\n\n  /* Read the input string.  */\n  while ((next_ch = getc (f)) != eos && next_ch != EOF)\n    {\n      ds_resize (s);\n      s->ds_string[s->ds_idx++] = next_ch;\n    }\n  ds_resize (s);\n  s->ds_string[s->ds_idx] = '\\0';\n\n  if (s->ds_idx == 0 && next_ch == EOF)\n    return NULL;\n  else\n    return s->ds_string;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148745,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ],
    "human": "Incorrect. With CWE-190",
    "reason": "It has more resize steps than the former verison. It resizes the buffer on every character read without size validation, making it prone to fast overflows with large files."
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "int Jsi_ObjArraySizer(Jsi_Interp *interp, Jsi_Obj *obj, uint len)\n{\n    int nsiz = len + 1, mod = ALLOC_MOD_SIZE;\n    assert(obj->isarrlist);\n    if (mod>1)\n        nsiz = nsiz + ((mod-1) - (nsiz + mod - 1)%mod);\n    if (nsiz > MAX_ARRAY_LIST) {\n        Jsi_LogError(\"array size too large\");\n        return 0;\n    }\n    if (len >= obj->arrMaxSize) {\n        int oldsz = (nsiz-obj->arrMaxSize);\n        obj->arr = (Jsi_Value**)Jsi_Realloc(obj->arr, nsiz*sizeof(Jsi_Value*));\n        memset(obj->arr+obj->arrMaxSize, 0, oldsz*sizeof(Jsi_Value*));\n        obj->arrMaxSize = nsiz;\n    }\n    if (len>obj->arrCnt)\n        obj->arrCnt = len;\n    return nsiz;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148796,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ],
    "human": "Correct. With CWE-190",
    "reason": "Vulnerable to CWE-190 due to unchecked integer overflow in nsiz and negative oldsz."
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "int Jsi_ObjArraySizer(Jsi_Interp *interp, Jsi_Obj *obj, uint len)\n{\n    uint nsiz = len + 1, mod = ALLOC_MOD_SIZE;\n    assert(obj->isarrlist);\n    if (mod>1)\n        nsiz = nsiz + ((mod-1) - (nsiz + mod - 1)%mod);\n    if (len >= interp->maxArrayList || nsiz > interp->maxArrayList) {\n        Jsi_LogError(\"array size too big: %u >= %u\", len, interp->maxArrayList);\n        return 0;\n    }\n    if (len >= obj->arrMaxSize) {\n        int oldsz = (nsiz-obj->arrMaxSize);\n        obj->arr = (Jsi_Value**)Jsi_Realloc(obj->arr, nsiz*sizeof(Jsi_Value*));\n        memset(obj->arr+obj->arrMaxSize, 0, oldsz*sizeof(Jsi_Value*));\n        obj->arrMaxSize = nsiz;\n    }\n    if (len>obj->arrCnt)\n        obj->arrCnt = len;\n    return nsiz;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148797,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ],
    "human": "Correct. Without CWE-190"
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "int ImagingLibTiffDecode(Imaging im, ImagingCodecState state, UINT8* buffer, Py_ssize_t bytes) {\n    TIFFSTATE *clientstate = (TIFFSTATE *)state->context;\n    char *filename = \"tempfile.tif\";\n    char *mode = \"r\";\n    TIFF *tiff;\n\n    /* buffer is the encoded file, bytes is the length of the encoded file */\n    /*     it all ends up in state->buffer, which is a uint8* from Imaging.h */\n\n    TRACE((\"in decoder: bytes %d\\n\", bytes));\n    TRACE((\"State: count %d, state %d, x %d, y %d, ystep %d\\n\", state->count, state->state,\n           state->x, state->y, state->ystep));\n    TRACE((\"State: xsize %d, ysize %d, xoff %d, yoff %d \\n\", state->xsize, state->ysize,\n           state->xoff, state->yoff));\n    TRACE((\"State: bits %d, bytes %d \\n\", state->bits, state->bytes));\n    TRACE((\"Buffer: %p: %c%c%c%c\\n\", buffer, (char)buffer[0], (char)buffer[1],(char)buffer[2], (char)buffer[3]));\n    TRACE((\"State->Buffer: %c%c%c%c\\n\", (char)state->buffer[0], (char)state->buffer[1],(char)state->buffer[2], (char)state->buffer[3]));\n    TRACE((\"Image: mode %s, type %d, bands: %d, xsize %d, ysize %d \\n\",\n           im->mode, im->type, im->bands, im->xsize, im->ysize));\n    TRACE((\"Image: image8 %p, image32 %p, image %p, block %p \\n\",\n           im->image8, im->image32, im->image, im->block));\n    TRACE((\"Image: pixelsize: %d, linesize %d \\n\",\n           im->pixelsize, im->linesize));\n\n    dump_state(clientstate);\n    clientstate->size = bytes;\n    clientstate->eof = clientstate->size;\n    clientstate->loc = 0;\n    clientstate->data = (tdata_t)buffer;\n    clientstate->flrealloc = 0;\n    dump_state(clientstate);\n\n    TIFFSetWarningHandler(NULL);\n    TIFFSetWarningHandlerExt(NULL);\n\n    if (clientstate->fp) {\n        TRACE((\"Opening using fd: %d\\n\",clientstate->fp));\n        lseek(clientstate->fp,0,SEEK_SET); // Sometimes, I get it set to the end.\n        tiff = TIFFFdOpen(clientstate->fp, filename, mode);\n    } else {\n        TRACE((\"Opening from string\\n\"));\n        tiff = TIFFClientOpen(filename, mode,\n                              (thandle_t) clientstate,\n                              _tiffReadProc, _tiffWriteProc,\n                              _tiffSeekProc, _tiffCloseProc, _tiffSizeProc,\n                              _tiffMapProc, _tiffUnmapProc);\n    }\n\n    if (!tiff){\n        TRACE((\"Error, didn't get the tiff\\n\"));\n        state->errcode = IMAGING_CODEC_BROKEN;\n        return -1;\n    }\n\n    if (clientstate->ifd){\n        int rv;\n        uint32 ifdoffset = clientstate->ifd;\n        TRACE((\"reading tiff ifd %u\\n\", ifdoffset));\n        rv = TIFFSetSubDirectory(tiff, ifdoffset);\n        if (!rv){\n            TRACE((\"error in TIFFSetSubDirectory\"));\n            return -1;\n        }\n    }\n\n    if (TIFFIsTiled(tiff)) {\n        UINT32 x, y, tile_y, row_byte_size;\n        UINT32 tile_width, tile_length, current_tile_width;\n        UINT8 *new_data;\n\n        TIFFGetField(tiff, TIFFTAG_TILEWIDTH, &tile_width);\n        TIFFGetField(tiff, TIFFTAG_TILELENGTH, &tile_length);\n\n        // We could use TIFFTileSize, but for YCbCr data it returns subsampled data size\n        row_byte_size = (tile_width * state->bits + 7) / 8;\n        state->bytes = row_byte_size * tile_length;\n\n        /* overflow check for malloc */\n        if (state->bytes > INT_MAX - 1) {\n            state->errcode = IMAGING_CODEC_MEMORY;\n            TIFFClose(tiff);\n            return -1;\n        }\n\n        /* realloc to fit whole tile */\n        new_data = realloc (state->buffer, state->bytes);\n        if (!new_data) {\n            state->errcode = IMAGING_CODEC_MEMORY;\n            TIFFClose(tiff);\n            return -1;\n        }\n\n        state->buffer = new_data;\n\n        TRACE((\"TIFFTileSize: %d\\n\", state->bytes));\n\n        for (y = state->yoff; y < state->ysize; y += tile_length) {\n            for (x = state->xoff; x < state->xsize; x += tile_width) {\n                if (ReadTile(tiff, x, y, (UINT32*) state->buffer) == -1) {\n                    TRACE((\"Decode Error, Tile at %dx%d\\n\", x, y));\n                    state->errcode = IMAGING_CODEC_BROKEN;\n                    TIFFClose(tiff);\n                    return -1;\n                }\n\n                TRACE((\"Read tile at %dx%d; \\n\\n\", x, y));\n\n                current_tile_width = min(tile_width, state->xsize - x);\n\n                // iterate over each line in the tile and stuff data into image\n                for (tile_y = 0; tile_y < min(tile_length, state->ysize - y); tile_y++) {\n                    TRACE((\"Writing tile data at %dx%d using tile_width: %d; \\n\", tile_y + y, x, current_tile_width));\n\n                    // UINT8 * bbb = state->buffer + tile_y * row_byte_size;\n                    // TRACE((\"chars: %x%x%x%x\\n\", ((UINT8 *)bbb)[0], ((UINT8 *)bbb)[1], ((UINT8 *)bbb)[2], ((UINT8 *)bbb)[3]));\n\n                    state->shuffle((UINT8*) im->image[tile_y + y] + x * im->pixelsize,\n                       state->buffer + tile_y * row_byte_size,\n                       current_tile_width\n                    );\n                }\n            }\n        }\n    } else {\n        UINT32 strip_row, row_byte_size;\n        UINT8 *new_data;\n        UINT32 rows_per_strip;\n        int ret;\n\n        ret = TIFFGetField(tiff, TIFFTAG_ROWSPERSTRIP, &rows_per_strip);\n        if (ret != 1) {\n            rows_per_strip = state->ysize;\n        }\n        TRACE((\"RowsPerStrip: %u \\n\", rows_per_strip));\n\n        // We could use TIFFStripSize, but for YCbCr data it returns subsampled data size\n        row_byte_size = (state->xsize * state->bits + 7) / 8;\n        state->bytes = rows_per_strip * row_byte_size;\n\n        TRACE((\"StripSize: %d \\n\", state->bytes));\n\n        /* realloc to fit whole strip */\n        new_data = realloc (state->buffer, state->bytes);\n        if (!new_data) {\n            state->errcode = IMAGING_CODEC_MEMORY;\n            TIFFClose(tiff);\n            return -1;\n        }\n\n        state->buffer = new_data;\n\n        for (; state->y < state->ysize; state->y += rows_per_strip) {\n            if (ReadStrip(tiff, state->y, (UINT32 *)state->buffer) == -1) {\n                TRACE((\"Decode Error, strip %d\\n\", TIFFComputeStrip(tiff, state->y, 0)));\n                state->errcode = IMAGING_CODEC_BROKEN;\n                TIFFClose(tiff);\n                return -1;\n            }\n\n            TRACE((\"Decoded strip for row %d \\n\", state->y));\n\n            // iterate over each row in the strip and stuff data into image\n            for (strip_row = 0; strip_row < min(rows_per_strip, state->ysize - state->y); strip_row++) {\n                TRACE((\"Writing data into line %d ; \\n\", state->y + strip_row));\n\n                // UINT8 * bbb = state->buffer + strip_row * (state->bytes / rows_per_strip);\n                // TRACE((\"chars: %x %x %x %x\\n\", ((UINT8 *)bbb)[0], ((UINT8 *)bbb)[1], ((UINT8 *)bbb)[2], ((UINT8 *)bbb)[3]));\n\n                state->shuffle((UINT8*) im->image[state->y + state->yoff + strip_row] +\n                               state->xoff * im->pixelsize,\n                               state->buffer + strip_row * row_byte_size,\n                               state->xsize);\n            }\n        }\n    }\n\n    TIFFClose(tiff);\n    TRACE((\"Done Decoding, Returning \\n\"));\n    // Returning -1 here to force ImageFile.load to break, rather than\n    // even think about looping back around.\n    return -1;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149746,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "int ImagingLibTiffDecode(Imaging im, ImagingCodecState state, UINT8* buffer, Py_ssize_t bytes) {\n    TIFFSTATE *clientstate = (TIFFSTATE *)state->context;\n    char *filename = \"tempfile.tif\";\n    char *mode = \"r\";\n    TIFF *tiff;\n\n    /* buffer is the encoded file, bytes is the length of the encoded file */\n    /*     it all ends up in state->buffer, which is a uint8* from Imaging.h */\n\n    TRACE((\"in decoder: bytes %d\\n\", bytes));\n    TRACE((\"State: count %d, state %d, x %d, y %d, ystep %d\\n\", state->count, state->state,\n           state->x, state->y, state->ystep));\n    TRACE((\"State: xsize %d, ysize %d, xoff %d, yoff %d \\n\", state->xsize, state->ysize,\n           state->xoff, state->yoff));\n    TRACE((\"State: bits %d, bytes %d \\n\", state->bits, state->bytes));\n    TRACE((\"Buffer: %p: %c%c%c%c\\n\", buffer, (char)buffer[0], (char)buffer[1],(char)buffer[2], (char)buffer[3]));\n    TRACE((\"State->Buffer: %c%c%c%c\\n\", (char)state->buffer[0], (char)state->buffer[1],(char)state->buffer[2], (char)state->buffer[3]));\n    TRACE((\"Image: mode %s, type %d, bands: %d, xsize %d, ysize %d \\n\",\n           im->mode, im->type, im->bands, im->xsize, im->ysize));\n    TRACE((\"Image: image8 %p, image32 %p, image %p, block %p \\n\",\n           im->image8, im->image32, im->image, im->block));\n    TRACE((\"Image: pixelsize: %d, linesize %d \\n\",\n           im->pixelsize, im->linesize));\n\n    dump_state(clientstate);\n    clientstate->size = bytes;\n    clientstate->eof = clientstate->size;\n    clientstate->loc = 0;\n    clientstate->data = (tdata_t)buffer;\n    clientstate->flrealloc = 0;\n    dump_state(clientstate);\n\n    TIFFSetWarningHandler(NULL);\n    TIFFSetWarningHandlerExt(NULL);\n\n    if (clientstate->fp) {\n        TRACE((\"Opening using fd: %d\\n\",clientstate->fp));\n        lseek(clientstate->fp,0,SEEK_SET); // Sometimes, I get it set to the end.\n        tiff = TIFFFdOpen(clientstate->fp, filename, mode);\n    } else {\n        TRACE((\"Opening from string\\n\"));\n        tiff = TIFFClientOpen(filename, mode,\n                              (thandle_t) clientstate,\n                              _tiffReadProc, _tiffWriteProc,\n                              _tiffSeekProc, _tiffCloseProc, _tiffSizeProc,\n                              _tiffMapProc, _tiffUnmapProc);\n    }\n\n    if (!tiff){\n        TRACE((\"Error, didn't get the tiff\\n\"));\n        state->errcode = IMAGING_CODEC_BROKEN;\n        return -1;\n    }\n\n    if (clientstate->ifd){\n        int rv;\n        uint32 ifdoffset = clientstate->ifd;\n        TRACE((\"reading tiff ifd %u\\n\", ifdoffset));\n        rv = TIFFSetSubDirectory(tiff, ifdoffset);\n        if (!rv){\n            TRACE((\"error in TIFFSetSubDirectory\"));\n            return -1;\n        }\n    }\n\n    if (TIFFIsTiled(tiff)) {\n        UINT32 x, y, tile_y, row_byte_size;\n        UINT32 tile_width, tile_length, current_tile_width;\n        UINT8 *new_data;\n\n        TIFFGetField(tiff, TIFFTAG_TILEWIDTH, &tile_width);\n        TIFFGetField(tiff, TIFFTAG_TILELENGTH, &tile_length);\n\n        // We could use TIFFTileSize, but for YCbCr data it returns subsampled data size\n        row_byte_size = (tile_width * state->bits + 7) / 8;\n\n        /* overflow check for realloc */\n        if (INT_MAX / row_byte_size < tile_length) {\n            state->errcode = IMAGING_CODEC_MEMORY;\n            TIFFClose(tiff);\n            return -1;\n        }\n        \n        state->bytes = row_byte_size * tile_length;\n\n        /* realloc to fit whole tile */\n        /* malloc check above */\n        new_data = realloc (state->buffer, state->bytes);\n        if (!new_data) {\n            state->errcode = IMAGING_CODEC_MEMORY;\n            TIFFClose(tiff);\n            return -1;\n        }\n\n        state->buffer = new_data;\n\n        TRACE((\"TIFFTileSize: %d\\n\", state->bytes));\n\n        for (y = state->yoff; y < state->ysize; y += tile_length) {\n            for (x = state->xoff; x < state->xsize; x += tile_width) {\n                if (ReadTile(tiff, x, y, (UINT32*) state->buffer) == -1) {\n                    TRACE((\"Decode Error, Tile at %dx%d\\n\", x, y));\n                    state->errcode = IMAGING_CODEC_BROKEN;\n                    TIFFClose(tiff);\n                    return -1;\n                }\n\n                TRACE((\"Read tile at %dx%d; \\n\\n\", x, y));\n\n                current_tile_width = min(tile_width, state->xsize - x);\n\n                // iterate over each line in the tile and stuff data into image\n                for (tile_y = 0; tile_y < min(tile_length, state->ysize - y); tile_y++) {\n                    TRACE((\"Writing tile data at %dx%d using tile_width: %d; \\n\", tile_y + y, x, current_tile_width));\n\n                    // UINT8 * bbb = state->buffer + tile_y * row_byte_size;\n                    // TRACE((\"chars: %x%x%x%x\\n\", ((UINT8 *)bbb)[0], ((UINT8 *)bbb)[1], ((UINT8 *)bbb)[2], ((UINT8 *)bbb)[3]));\n\n                    state->shuffle((UINT8*) im->image[tile_y + y] + x * im->pixelsize,\n                       state->buffer + tile_y * row_byte_size,\n                       current_tile_width\n                    );\n                }\n            }\n        }\n    } else {\n        UINT32 strip_row, row_byte_size;\n        UINT8 *new_data;\n        UINT32 rows_per_strip;\n        int ret;\n\n        ret = TIFFGetField(tiff, TIFFTAG_ROWSPERSTRIP, &rows_per_strip);\n        if (ret != 1) {\n            rows_per_strip = state->ysize;\n        }\n        TRACE((\"RowsPerStrip: %u \\n\", rows_per_strip));\n\n        // We could use TIFFStripSize, but for YCbCr data it returns subsampled data size\n        row_byte_size = (state->xsize * state->bits + 7) / 8;\n\n        /* overflow check for realloc */\n        if (INT_MAX / row_byte_size < rows_per_strip) {\n            state->errcode = IMAGING_CODEC_MEMORY;\n            TIFFClose(tiff);\n            return -1;\n        }\n        \n        state->bytes = rows_per_strip * row_byte_size;\n\n        TRACE((\"StripSize: %d \\n\", state->bytes));\n\n        /* realloc to fit whole strip */\n        /* malloc check above */\n        new_data = realloc (state->buffer, state->bytes);\n        if (!new_data) {\n            state->errcode = IMAGING_CODEC_MEMORY;\n            TIFFClose(tiff);\n            return -1;\n        }\n\n        state->buffer = new_data;\n\n        for (; state->y < state->ysize; state->y += rows_per_strip) {\n            if (ReadStrip(tiff, state->y, (UINT32 *)state->buffer) == -1) {\n                TRACE((\"Decode Error, strip %d\\n\", TIFFComputeStrip(tiff, state->y, 0)));\n                state->errcode = IMAGING_CODEC_BROKEN;\n                TIFFClose(tiff);\n                return -1;\n            }\n\n            TRACE((\"Decoded strip for row %d \\n\", state->y));\n\n            // iterate over each row in the strip and stuff data into image\n            for (strip_row = 0; strip_row < min(rows_per_strip, state->ysize - state->y); strip_row++) {\n                TRACE((\"Writing data into line %d ; \\n\", state->y + strip_row));\n\n                // UINT8 * bbb = state->buffer + strip_row * (state->bytes / rows_per_strip);\n                // TRACE((\"chars: %x %x %x %x\\n\", ((UINT8 *)bbb)[0], ((UINT8 *)bbb)[1], ((UINT8 *)bbb)[2], ((UINT8 *)bbb)[3]));\n\n                state->shuffle((UINT8*) im->image[state->y + state->yoff + strip_row] +\n                               state->xoff * im->pixelsize,\n                               state->buffer + strip_row * row_byte_size,\n                               state->xsize);\n            }\n        }\n    }\n\n    TIFFClose(tiff);\n    TRACE((\"Done Decoding, Returning \\n\"));\n    // Returning -1 here to force ImageFile.load to break, rather than\n    // even think about looping back around.\n    return -1;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149747,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static int futex_requeue(u32 __user *uaddr1, unsigned int flags,\n\t\t\t u32 __user *uaddr2, int nr_wake, int nr_requeue,\n\t\t\t u32 *cmpval, int requeue_pi)\n{\n\tunion futex_key key1 = FUTEX_KEY_INIT, key2 = FUTEX_KEY_INIT;\n\tint drop_count = 0, task_count = 0, ret;\n\tstruct futex_pi_state *pi_state = NULL;\n\tstruct futex_hash_bucket *hb1, *hb2;\n\tstruct futex_q *this, *next;\n\tDEFINE_WAKE_Q(wake_q);\n\n\t/*\n\t * When PI not supported: return -ENOSYS if requeue_pi is true,\n\t * consequently the compiler knows requeue_pi is always false past\n\t * this point which will optimize away all the conditional code\n\t * further down.\n\t */\n\tif (!IS_ENABLED(CONFIG_FUTEX_PI) && requeue_pi)\n\t\treturn -ENOSYS;\n\n\tif (requeue_pi) {\n\t\t/*\n\t\t * Requeue PI only works on two distinct uaddrs. This\n\t\t * check is only valid for private futexes. See below.\n\t\t */\n\t\tif (uaddr1 == uaddr2)\n\t\t\treturn -EINVAL;\n\n\t\t/*\n\t\t * requeue_pi requires a pi_state, try to allocate it now\n\t\t * without any locks in case it fails.\n\t\t */\n\t\tif (refill_pi_state_cache())\n\t\t\treturn -ENOMEM;\n\t\t/*\n\t\t * requeue_pi must wake as many tasks as it can, up to nr_wake\n\t\t * + nr_requeue, since it acquires the rt_mutex prior to\n\t\t * returning to userspace, so as to not leave the rt_mutex with\n\t\t * waiters and no owner.  However, second and third wake-ups\n\t\t * cannot be predicted as they involve race conditions with the\n\t\t * first wake and a fault while looking up the pi_state.  Both\n\t\t * pthread_cond_signal() and pthread_cond_broadcast() should\n\t\t * use nr_wake=1.\n\t\t */\n\t\tif (nr_wake != 1)\n\t\t\treturn -EINVAL;\n\t}\n\nretry:\n\tret = get_futex_key(uaddr1, flags & FLAGS_SHARED, &key1, VERIFY_READ);\n\tif (unlikely(ret != 0))\n\t\tgoto out;\n\tret = get_futex_key(uaddr2, flags & FLAGS_SHARED, &key2,\n\t\t\t    requeue_pi ? VERIFY_WRITE : VERIFY_READ);\n\tif (unlikely(ret != 0))\n\t\tgoto out_put_key1;\n\n\t/*\n\t * The check above which compares uaddrs is not sufficient for\n\t * shared futexes. We need to compare the keys:\n\t */\n\tif (requeue_pi && match_futex(&key1, &key2)) {\n\t\tret = -EINVAL;\n\t\tgoto out_put_keys;\n\t}\n\n\thb1 = hash_futex(&key1);\n\thb2 = hash_futex(&key2);\n\nretry_private:\n\thb_waiters_inc(hb2);\n\tdouble_lock_hb(hb1, hb2);\n\n\tif (likely(cmpval != NULL)) {\n\t\tu32 curval;\n\n\t\tret = get_futex_value_locked(&curval, uaddr1);\n\n\t\tif (unlikely(ret)) {\n\t\t\tdouble_unlock_hb(hb1, hb2);\n\t\t\thb_waiters_dec(hb2);\n\n\t\t\tret = get_user(curval, uaddr1);\n\t\t\tif (ret)\n\t\t\t\tgoto out_put_keys;\n\n\t\t\tif (!(flags & FLAGS_SHARED))\n\t\t\t\tgoto retry_private;\n\n\t\t\tput_futex_key(&key2);\n\t\t\tput_futex_key(&key1);\n\t\t\tgoto retry;\n\t\t}\n\t\tif (curval != *cmpval) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tif (requeue_pi && (task_count - nr_wake < nr_requeue)) {\n\t\t/*\n\t\t * Attempt to acquire uaddr2 and wake the top waiter. If we\n\t\t * intend to requeue waiters, force setting the FUTEX_WAITERS\n\t\t * bit.  We force this here where we are able to easily handle\n\t\t * faults rather in the requeue loop below.\n\t\t */\n\t\tret = futex_proxy_trylock_atomic(uaddr2, hb1, hb2, &key1,\n\t\t\t\t\t\t &key2, &pi_state, nr_requeue);\n\n\t\t/*\n\t\t * At this point the top_waiter has either taken uaddr2 or is\n\t\t * waiting on it.  If the former, then the pi_state will not\n\t\t * exist yet, look it up one more time to ensure we have a\n\t\t * reference to it. If the lock was taken, ret contains the\n\t\t * vpid of the top waiter task.\n\t\t * If the lock was not taken, we have pi_state and an initial\n\t\t * refcount on it. In case of an error we have nothing.\n\t\t */\n\t\tif (ret > 0) {\n\t\t\tWARN_ON(pi_state);\n\t\t\tdrop_count++;\n\t\t\ttask_count++;\n\t\t\t/*\n\t\t\t * If we acquired the lock, then the user space value\n\t\t\t * of uaddr2 should be vpid. It cannot be changed by\n\t\t\t * the top waiter as it is blocked on hb2 lock if it\n\t\t\t * tries to do so. If something fiddled with it behind\n\t\t\t * our back the pi state lookup might unearth it. So\n\t\t\t * we rather use the known value than rereading and\n\t\t\t * handing potential crap to lookup_pi_state.\n\t\t\t *\n\t\t\t * If that call succeeds then we have pi_state and an\n\t\t\t * initial refcount on it.\n\t\t\t */\n\t\t\tret = lookup_pi_state(uaddr2, ret, hb2, &key2, &pi_state);\n\t\t}\n\n\t\tswitch (ret) {\n\t\tcase 0:\n\t\t\t/* We hold a reference on the pi state. */\n\t\t\tbreak;\n\n\t\t\t/* If the above failed, then pi_state is NULL */\n\t\tcase -EFAULT:\n\t\t\tdouble_unlock_hb(hb1, hb2);\n\t\t\thb_waiters_dec(hb2);\n\t\t\tput_futex_key(&key2);\n\t\t\tput_futex_key(&key1);\n\t\t\tret = fault_in_user_writeable(uaddr2);\n\t\t\tif (!ret)\n\t\t\t\tgoto retry;\n\t\t\tgoto out;\n\t\tcase -EAGAIN:\n\t\t\t/*\n\t\t\t * Two reasons for this:\n\t\t\t * - Owner is exiting and we just wait for the\n\t\t\t *   exit to complete.\n\t\t\t * - The user space value changed.\n\t\t\t */\n\t\t\tdouble_unlock_hb(hb1, hb2);\n\t\t\thb_waiters_dec(hb2);\n\t\t\tput_futex_key(&key2);\n\t\t\tput_futex_key(&key1);\n\t\t\tcond_resched();\n\t\t\tgoto retry;\n\t\tdefault:\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tplist_for_each_entry_safe(this, next, &hb1->chain, list) {\n\t\tif (task_count - nr_wake >= nr_requeue)\n\t\t\tbreak;\n\n\t\tif (!match_futex(&this->key, &key1))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * FUTEX_WAIT_REQEUE_PI and FUTEX_CMP_REQUEUE_PI should always\n\t\t * be paired with each other and no other futex ops.\n\t\t *\n\t\t * We should never be requeueing a futex_q with a pi_state,\n\t\t * which is awaiting a futex_unlock_pi().\n\t\t */\n\t\tif ((requeue_pi && !this->rt_waiter) ||\n\t\t    (!requeue_pi && this->rt_waiter) ||\n\t\t    this->pi_state) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Wake nr_wake waiters.  For requeue_pi, if we acquired the\n\t\t * lock, we already woke the top_waiter.  If not, it will be\n\t\t * woken by futex_unlock_pi().\n\t\t */\n\t\tif (++task_count <= nr_wake && !requeue_pi) {\n\t\t\tmark_wake_futex(&wake_q, this);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Ensure we requeue to the expected futex for requeue_pi. */\n\t\tif (requeue_pi && !match_futex(this->requeue_pi_key, &key2)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Requeue nr_requeue waiters and possibly one more in the case\n\t\t * of requeue_pi if we couldn't acquire the lock atomically.\n\t\t */\n\t\tif (requeue_pi) {\n\t\t\t/*\n\t\t\t * Prepare the waiter to take the rt_mutex. Take a\n\t\t\t * refcount on the pi_state and store the pointer in\n\t\t\t * the futex_q object of the waiter.\n\t\t\t */\n\t\t\tget_pi_state(pi_state);\n\t\t\tthis->pi_state = pi_state;\n\t\t\tret = rt_mutex_start_proxy_lock(&pi_state->pi_mutex,\n\t\t\t\t\t\t\tthis->rt_waiter,\n\t\t\t\t\t\t\tthis->task);\n\t\t\tif (ret == 1) {\n\t\t\t\t/*\n\t\t\t\t * We got the lock. We do neither drop the\n\t\t\t\t * refcount on pi_state nor clear\n\t\t\t\t * this->pi_state because the waiter needs the\n\t\t\t\t * pi_state for cleaning up the user space\n\t\t\t\t * value. It will drop the refcount after\n\t\t\t\t * doing so.\n\t\t\t\t */\n\t\t\t\trequeue_pi_wake_futex(this, &key2, hb2);\n\t\t\t\tdrop_count++;\n\t\t\t\tcontinue;\n\t\t\t} else if (ret) {\n\t\t\t\t/*\n\t\t\t\t * rt_mutex_start_proxy_lock() detected a\n\t\t\t\t * potential deadlock when we tried to queue\n\t\t\t\t * that waiter. Drop the pi_state reference\n\t\t\t\t * which we took above and remove the pointer\n\t\t\t\t * to the state from the waiters futex_q\n\t\t\t\t * object.\n\t\t\t\t */\n\t\t\t\tthis->pi_state = NULL;\n\t\t\t\tput_pi_state(pi_state);\n\t\t\t\t/*\n\t\t\t\t * We stop queueing more waiters and let user\n\t\t\t\t * space deal with the mess.\n\t\t\t\t */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trequeue_futex(this, hb1, hb2, &key2);\n\t\tdrop_count++;\n\t}\n\n\t/*\n\t * We took an extra initial reference to the pi_state either\n\t * in futex_proxy_trylock_atomic() or in lookup_pi_state(). We\n\t * need to drop it here again.\n\t */\n\tput_pi_state(pi_state);\n\nout_unlock:\n\tdouble_unlock_hb(hb1, hb2);\n\twake_up_q(&wake_q);\n\thb_waiters_dec(hb2);\n\n\t/*\n\t * drop_futex_key_refs() must be called outside the spinlocks. During\n\t * the requeue we moved futex_q's from the hash bucket at key1 to the\n\t * one at key2 and updated their key pointer.  We no longer need to\n\t * hold the references to key1.\n\t */\n\twhile (--drop_count >= 0)\n\t\tdrop_futex_key_refs(&key1);\n\nout_put_keys:\n\tput_futex_key(&key2);\nout_put_key1:\n\tput_futex_key(&key1);\nout:\n\treturn ret ? ret : task_count;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149748,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static int futex_requeue(u32 __user *uaddr1, unsigned int flags,\n\t\t\t u32 __user *uaddr2, int nr_wake, int nr_requeue,\n\t\t\t u32 *cmpval, int requeue_pi)\n{\n\tunion futex_key key1 = FUTEX_KEY_INIT, key2 = FUTEX_KEY_INIT;\n\tint drop_count = 0, task_count = 0, ret;\n\tstruct futex_pi_state *pi_state = NULL;\n\tstruct futex_hash_bucket *hb1, *hb2;\n\tstruct futex_q *this, *next;\n\tDEFINE_WAKE_Q(wake_q);\n\n\tif (nr_wake < 0 || nr_requeue < 0)\n\t\treturn -EINVAL;\n\n\t/*\n\t * When PI not supported: return -ENOSYS if requeue_pi is true,\n\t * consequently the compiler knows requeue_pi is always false past\n\t * this point which will optimize away all the conditional code\n\t * further down.\n\t */\n\tif (!IS_ENABLED(CONFIG_FUTEX_PI) && requeue_pi)\n\t\treturn -ENOSYS;\n\n\tif (requeue_pi) {\n\t\t/*\n\t\t * Requeue PI only works on two distinct uaddrs. This\n\t\t * check is only valid for private futexes. See below.\n\t\t */\n\t\tif (uaddr1 == uaddr2)\n\t\t\treturn -EINVAL;\n\n\t\t/*\n\t\t * requeue_pi requires a pi_state, try to allocate it now\n\t\t * without any locks in case it fails.\n\t\t */\n\t\tif (refill_pi_state_cache())\n\t\t\treturn -ENOMEM;\n\t\t/*\n\t\t * requeue_pi must wake as many tasks as it can, up to nr_wake\n\t\t * + nr_requeue, since it acquires the rt_mutex prior to\n\t\t * returning to userspace, so as to not leave the rt_mutex with\n\t\t * waiters and no owner.  However, second and third wake-ups\n\t\t * cannot be predicted as they involve race conditions with the\n\t\t * first wake and a fault while looking up the pi_state.  Both\n\t\t * pthread_cond_signal() and pthread_cond_broadcast() should\n\t\t * use nr_wake=1.\n\t\t */\n\t\tif (nr_wake != 1)\n\t\t\treturn -EINVAL;\n\t}\n\nretry:\n\tret = get_futex_key(uaddr1, flags & FLAGS_SHARED, &key1, VERIFY_READ);\n\tif (unlikely(ret != 0))\n\t\tgoto out;\n\tret = get_futex_key(uaddr2, flags & FLAGS_SHARED, &key2,\n\t\t\t    requeue_pi ? VERIFY_WRITE : VERIFY_READ);\n\tif (unlikely(ret != 0))\n\t\tgoto out_put_key1;\n\n\t/*\n\t * The check above which compares uaddrs is not sufficient for\n\t * shared futexes. We need to compare the keys:\n\t */\n\tif (requeue_pi && match_futex(&key1, &key2)) {\n\t\tret = -EINVAL;\n\t\tgoto out_put_keys;\n\t}\n\n\thb1 = hash_futex(&key1);\n\thb2 = hash_futex(&key2);\n\nretry_private:\n\thb_waiters_inc(hb2);\n\tdouble_lock_hb(hb1, hb2);\n\n\tif (likely(cmpval != NULL)) {\n\t\tu32 curval;\n\n\t\tret = get_futex_value_locked(&curval, uaddr1);\n\n\t\tif (unlikely(ret)) {\n\t\t\tdouble_unlock_hb(hb1, hb2);\n\t\t\thb_waiters_dec(hb2);\n\n\t\t\tret = get_user(curval, uaddr1);\n\t\t\tif (ret)\n\t\t\t\tgoto out_put_keys;\n\n\t\t\tif (!(flags & FLAGS_SHARED))\n\t\t\t\tgoto retry_private;\n\n\t\t\tput_futex_key(&key2);\n\t\t\tput_futex_key(&key1);\n\t\t\tgoto retry;\n\t\t}\n\t\tif (curval != *cmpval) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tif (requeue_pi && (task_count - nr_wake < nr_requeue)) {\n\t\t/*\n\t\t * Attempt to acquire uaddr2 and wake the top waiter. If we\n\t\t * intend to requeue waiters, force setting the FUTEX_WAITERS\n\t\t * bit.  We force this here where we are able to easily handle\n\t\t * faults rather in the requeue loop below.\n\t\t */\n\t\tret = futex_proxy_trylock_atomic(uaddr2, hb1, hb2, &key1,\n\t\t\t\t\t\t &key2, &pi_state, nr_requeue);\n\n\t\t/*\n\t\t * At this point the top_waiter has either taken uaddr2 or is\n\t\t * waiting on it.  If the former, then the pi_state will not\n\t\t * exist yet, look it up one more time to ensure we have a\n\t\t * reference to it. If the lock was taken, ret contains the\n\t\t * vpid of the top waiter task.\n\t\t * If the lock was not taken, we have pi_state and an initial\n\t\t * refcount on it. In case of an error we have nothing.\n\t\t */\n\t\tif (ret > 0) {\n\t\t\tWARN_ON(pi_state);\n\t\t\tdrop_count++;\n\t\t\ttask_count++;\n\t\t\t/*\n\t\t\t * If we acquired the lock, then the user space value\n\t\t\t * of uaddr2 should be vpid. It cannot be changed by\n\t\t\t * the top waiter as it is blocked on hb2 lock if it\n\t\t\t * tries to do so. If something fiddled with it behind\n\t\t\t * our back the pi state lookup might unearth it. So\n\t\t\t * we rather use the known value than rereading and\n\t\t\t * handing potential crap to lookup_pi_state.\n\t\t\t *\n\t\t\t * If that call succeeds then we have pi_state and an\n\t\t\t * initial refcount on it.\n\t\t\t */\n\t\t\tret = lookup_pi_state(uaddr2, ret, hb2, &key2, &pi_state);\n\t\t}\n\n\t\tswitch (ret) {\n\t\tcase 0:\n\t\t\t/* We hold a reference on the pi state. */\n\t\t\tbreak;\n\n\t\t\t/* If the above failed, then pi_state is NULL */\n\t\tcase -EFAULT:\n\t\t\tdouble_unlock_hb(hb1, hb2);\n\t\t\thb_waiters_dec(hb2);\n\t\t\tput_futex_key(&key2);\n\t\t\tput_futex_key(&key1);\n\t\t\tret = fault_in_user_writeable(uaddr2);\n\t\t\tif (!ret)\n\t\t\t\tgoto retry;\n\t\t\tgoto out;\n\t\tcase -EAGAIN:\n\t\t\t/*\n\t\t\t * Two reasons for this:\n\t\t\t * - Owner is exiting and we just wait for the\n\t\t\t *   exit to complete.\n\t\t\t * - The user space value changed.\n\t\t\t */\n\t\t\tdouble_unlock_hb(hb1, hb2);\n\t\t\thb_waiters_dec(hb2);\n\t\t\tput_futex_key(&key2);\n\t\t\tput_futex_key(&key1);\n\t\t\tcond_resched();\n\t\t\tgoto retry;\n\t\tdefault:\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tplist_for_each_entry_safe(this, next, &hb1->chain, list) {\n\t\tif (task_count - nr_wake >= nr_requeue)\n\t\t\tbreak;\n\n\t\tif (!match_futex(&this->key, &key1))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * FUTEX_WAIT_REQEUE_PI and FUTEX_CMP_REQUEUE_PI should always\n\t\t * be paired with each other and no other futex ops.\n\t\t *\n\t\t * We should never be requeueing a futex_q with a pi_state,\n\t\t * which is awaiting a futex_unlock_pi().\n\t\t */\n\t\tif ((requeue_pi && !this->rt_waiter) ||\n\t\t    (!requeue_pi && this->rt_waiter) ||\n\t\t    this->pi_state) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Wake nr_wake waiters.  For requeue_pi, if we acquired the\n\t\t * lock, we already woke the top_waiter.  If not, it will be\n\t\t * woken by futex_unlock_pi().\n\t\t */\n\t\tif (++task_count <= nr_wake && !requeue_pi) {\n\t\t\tmark_wake_futex(&wake_q, this);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Ensure we requeue to the expected futex for requeue_pi. */\n\t\tif (requeue_pi && !match_futex(this->requeue_pi_key, &key2)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Requeue nr_requeue waiters and possibly one more in the case\n\t\t * of requeue_pi if we couldn't acquire the lock atomically.\n\t\t */\n\t\tif (requeue_pi) {\n\t\t\t/*\n\t\t\t * Prepare the waiter to take the rt_mutex. Take a\n\t\t\t * refcount on the pi_state and store the pointer in\n\t\t\t * the futex_q object of the waiter.\n\t\t\t */\n\t\t\tget_pi_state(pi_state);\n\t\t\tthis->pi_state = pi_state;\n\t\t\tret = rt_mutex_start_proxy_lock(&pi_state->pi_mutex,\n\t\t\t\t\t\t\tthis->rt_waiter,\n\t\t\t\t\t\t\tthis->task);\n\t\t\tif (ret == 1) {\n\t\t\t\t/*\n\t\t\t\t * We got the lock. We do neither drop the\n\t\t\t\t * refcount on pi_state nor clear\n\t\t\t\t * this->pi_state because the waiter needs the\n\t\t\t\t * pi_state for cleaning up the user space\n\t\t\t\t * value. It will drop the refcount after\n\t\t\t\t * doing so.\n\t\t\t\t */\n\t\t\t\trequeue_pi_wake_futex(this, &key2, hb2);\n\t\t\t\tdrop_count++;\n\t\t\t\tcontinue;\n\t\t\t} else if (ret) {\n\t\t\t\t/*\n\t\t\t\t * rt_mutex_start_proxy_lock() detected a\n\t\t\t\t * potential deadlock when we tried to queue\n\t\t\t\t * that waiter. Drop the pi_state reference\n\t\t\t\t * which we took above and remove the pointer\n\t\t\t\t * to the state from the waiters futex_q\n\t\t\t\t * object.\n\t\t\t\t */\n\t\t\t\tthis->pi_state = NULL;\n\t\t\t\tput_pi_state(pi_state);\n\t\t\t\t/*\n\t\t\t\t * We stop queueing more waiters and let user\n\t\t\t\t * space deal with the mess.\n\t\t\t\t */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trequeue_futex(this, hb1, hb2, &key2);\n\t\tdrop_count++;\n\t}\n\n\t/*\n\t * We took an extra initial reference to the pi_state either\n\t * in futex_proxy_trylock_atomic() or in lookup_pi_state(). We\n\t * need to drop it here again.\n\t */\n\tput_pi_state(pi_state);\n\nout_unlock:\n\tdouble_unlock_hb(hb1, hb2);\n\twake_up_q(&wake_q);\n\thb_waiters_dec(hb2);\n\n\t/*\n\t * drop_futex_key_refs() must be called outside the spinlocks. During\n\t * the requeue we moved futex_q's from the hash bucket at key1 to the\n\t * one at key2 and updated their key pointer.  We no longer need to\n\t * hold the references to key1.\n\t */\n\twhile (--drop_count >= 0)\n\t\tdrop_futex_key_refs(&key1);\n\nout_put_keys:\n\tput_futex_key(&key2);\nout_put_key1:\n\tput_futex_key(&key1);\nout:\n\treturn ret ? ret : task_count;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149749,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static int _gd2GetHeader(gdIOCtxPtr in, int *sx, int *sy, int *cs, int *vers, int *fmt, int *ncx, int *ncy, t_chunk_info ** chunkIdx)\n{\n\tint i;\n\tint ch;\n\tchar id[5];\n\tt_chunk_info *cidx;\n\tint sidx;\n\tint nc;\n\n\tGD2_DBG(php_gd_error(\"Reading gd2 header info\"));\n\n\tfor (i = 0; i < 4; i++) {\n\t\tch = gdGetC(in);\n\t\tif (ch == EOF) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tid[i] = ch;\n\t}\n\tid[4] = 0;\n\n\tGD2_DBG(php_gd_error(\"Got file code: %s\", id));\n\n\t/* Equiv. of 'magick'.  */\n\tif (strcmp(id, GD2_ID) != 0) {\n\t\tGD2_DBG(php_gd_error(\"Not a valid gd2 file\"));\n\t\tgoto fail1;\n\t}\n\n\t/* Version */\n\tif (gdGetWord(vers, in) != 1) {\n\t\tgoto fail1;\n\t}\n\tGD2_DBG(php_gd_error(\"Version: %d\", *vers));\n\n\tif ((*vers != 1) && (*vers != 2)) {\n\t\tGD2_DBG(php_gd_error(\"Bad version: %d\", *vers));\n\t\tgoto fail1;\n\t}\n\n\t/* Image Size */\n\tif (!gdGetWord(sx, in)) {\n\t\tGD2_DBG(php_gd_error(\"Could not get x-size\"));\n\t\tgoto fail1;\n\t}\n\tif (!gdGetWord(sy, in)) {\n\t\tGD2_DBG(php_gd_error(\"Could not get y-size\"));\n\t\tgoto fail1;\n\t}\n\tGD2_DBG(php_gd_error(\"Image is %dx%d\", *sx, *sy));\n\n\t/* Chunk Size (pixels, not bytes!) */\n\tif (gdGetWord(cs, in) != 1) {\n\t\tgoto fail1;\n\t}\n\tGD2_DBG(php_gd_error(\"ChunkSize: %d\", *cs));\n\n\tif ((*cs < GD2_CHUNKSIZE_MIN) || (*cs > GD2_CHUNKSIZE_MAX)) {\n\t\tGD2_DBG(php_gd_error(\"Bad chunk size: %d\", *cs));\n\t\tgoto fail1;\n\t}\n\n\t/* Data Format */\n\tif (gdGetWord(fmt, in) != 1) {\n\t\tgoto fail1;\n\t}\n\tGD2_DBG(php_gd_error(\"Format: %d\", *fmt));\n\n\tif ((*fmt != GD2_FMT_RAW) && (*fmt != GD2_FMT_COMPRESSED) && (*fmt != GD2_FMT_TRUECOLOR_RAW) && (*fmt != GD2_FMT_TRUECOLOR_COMPRESSED)) {\n\t\tGD2_DBG(php_gd_error(\"Bad data format: %d\", *fmt));\n\t\tgoto fail1;\n\t}\n\n\t/* # of chunks wide */\n\tif (gdGetWord(ncx, in) != 1) {\n\t\tgoto fail1;\n\t}\n\tGD2_DBG(php_gd_error(\"%d Chunks Wide\", *ncx));\n\n\t/* # of chunks high */\n\tif (gdGetWord(ncy, in) != 1) {\n\t\tgoto fail1;\n\t}\n\tGD2_DBG(php_gd_error(\"%d Chunks vertically\", *ncy));\n\n\tif (gd2_compressed(*fmt)) {\n\t\tnc = (*ncx) * (*ncy);\n\t\tGD2_DBG(php_gd_error(\"Reading %d chunk index entries\", nc));\n\t\tsidx = sizeof(t_chunk_info) * nc;\n\t\tif (sidx <= 0) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tcidx = gdCalloc(sidx, 1);\n\t\tfor (i = 0; i < nc; i++) {\n\t\t\tif (gdGetInt(&cidx[i].offset, in) != 1) {\n\t\t\t\tgdFree(cidx);\n\t\t\t\tgoto fail1;\n\t\t\t}\n\t\t\tif (gdGetInt(&cidx[i].size, in) != 1) {\n\t\t\t\tgdFree(cidx);\n\t\t\t\tgoto fail1;\n\t\t\t}\n\t\t\tif (cidx[i].offset < 0 || cidx[i].size < 0) {\n\t\t\t\tgdFree(cidx);\n\t\t\t\tgoto fail1;\n\t\t\t}\n\t\t}\n\t\t*chunkIdx = cidx;\n\t}\n\n\tGD2_DBG(php_gd_error(\"gd2 header complete\"));\n\n\treturn 1;\n\nfail1:\n\treturn 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149750,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static int _gd2GetHeader(gdIOCtxPtr in, int *sx, int *sy, int *cs, int *vers, int *fmt, int *ncx, int *ncy, t_chunk_info ** chunkIdx)\n{\n\tint i;\n\tint ch;\n\tchar id[5];\n\tt_chunk_info *cidx;\n\tint sidx;\n\tint nc;\n\n\tGD2_DBG(php_gd_error(\"Reading gd2 header info\"));\n\n\tfor (i = 0; i < 4; i++) {\n\t\tch = gdGetC(in);\n\t\tif (ch == EOF) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tid[i] = ch;\n\t}\n\tid[4] = 0;\n\n\tGD2_DBG(php_gd_error(\"Got file code: %s\", id));\n\n\t/* Equiv. of 'magick'.  */\n\tif (strcmp(id, GD2_ID) != 0) {\n\t\tGD2_DBG(php_gd_error(\"Not a valid gd2 file\"));\n\t\tgoto fail1;\n\t}\n\n\t/* Version */\n\tif (gdGetWord(vers, in) != 1) {\n\t\tgoto fail1;\n\t}\n\tGD2_DBG(php_gd_error(\"Version: %d\", *vers));\n\n\tif ((*vers != 1) && (*vers != 2)) {\n\t\tGD2_DBG(php_gd_error(\"Bad version: %d\", *vers));\n\t\tgoto fail1;\n\t}\n\n\t/* Image Size */\n\tif (!gdGetWord(sx, in)) {\n\t\tGD2_DBG(php_gd_error(\"Could not get x-size\"));\n\t\tgoto fail1;\n\t}\n\tif (!gdGetWord(sy, in)) {\n\t\tGD2_DBG(php_gd_error(\"Could not get y-size\"));\n\t\tgoto fail1;\n\t}\n\tGD2_DBG(php_gd_error(\"Image is %dx%d\", *sx, *sy));\n\n\t/* Chunk Size (pixels, not bytes!) */\n\tif (gdGetWord(cs, in) != 1) {\n\t\tgoto fail1;\n\t}\n\tGD2_DBG(php_gd_error(\"ChunkSize: %d\", *cs));\n\n\tif ((*cs < GD2_CHUNKSIZE_MIN) || (*cs > GD2_CHUNKSIZE_MAX)) {\n\t\tGD2_DBG(php_gd_error(\"Bad chunk size: %d\", *cs));\n\t\tgoto fail1;\n\t}\n\n\t/* Data Format */\n\tif (gdGetWord(fmt, in) != 1) {\n\t\tgoto fail1;\n\t}\n\tGD2_DBG(php_gd_error(\"Format: %d\", *fmt));\n\n\tif ((*fmt != GD2_FMT_RAW) && (*fmt != GD2_FMT_COMPRESSED) && (*fmt != GD2_FMT_TRUECOLOR_RAW) && (*fmt != GD2_FMT_TRUECOLOR_COMPRESSED)) {\n\t\tGD2_DBG(php_gd_error(\"Bad data format: %d\", *fmt));\n\t\tgoto fail1;\n\t}\n\n\t/* # of chunks wide */\n\tif (gdGetWord(ncx, in) != 1) {\n\t\tgoto fail1;\n\t}\n\tGD2_DBG(php_gd_error(\"%d Chunks Wide\", *ncx));\n\n\t/* # of chunks high */\n\tif (gdGetWord(ncy, in) != 1) {\n\t\tgoto fail1;\n\t}\n\tGD2_DBG(php_gd_error(\"%d Chunks vertically\", *ncy));\n\n\tif (gd2_compressed(*fmt)) {\n\t\tnc = (*ncx) * (*ncy);\n\t\tGD2_DBG(php_gd_error(\"Reading %d chunk index entries\", nc));\n\t\tif (overflow2(sidx, nc)) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tsidx = sizeof(t_chunk_info) * nc;\n\t\tif (sidx <= 0) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tcidx = gdCalloc(sidx, 1);\n\t\tif (cidx == NULL) {\n\t\t\tgoto fail1;\n\t\t}\n\n\t\tfor (i = 0; i < nc; i++) {\n\t\t\tif (gdGetInt(&cidx[i].offset, in) != 1) {\n\t\t\t\tgdFree(cidx);\n\t\t\t\tgoto fail1;\n\t\t\t}\n\t\t\tif (gdGetInt(&cidx[i].size, in) != 1) {\n\t\t\t\tgdFree(cidx);\n\t\t\t\tgoto fail1;\n\t\t\t}\n\t\t\tif (cidx[i].offset < 0 || cidx[i].size < 0) {\n\t\t\t\tgdFree(cidx);\n\t\t\t\tgoto fail1;\n\t\t\t}\n\t\t}\n\t\t*chunkIdx = cidx;\n\t}\n\n\tGD2_DBG(php_gd_error(\"gd2 header complete\"));\n\n\treturn 1;\n\nfail1:\n\treturn 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149751,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static int jpc_pi_nextcprl(register jpc_pi_t *pi)\n{\n\tint rlvlno;\n\tjpc_pirlvl_t *pirlvl;\n\tjpc_pchg_t *pchg;\n\tint prchind;\n\tint prcvind;\n\tint *prclyrno;\n\tuint_fast32_t trx0;\n\tuint_fast32_t try0;\n\tuint_fast32_t r;\n\tuint_fast32_t rpx;\n\tuint_fast32_t rpy;\n\n\tpchg = pi->pchg;\n\tif (!pi->prgvolfirst) {\n\t\tgoto skip;\n\t} else {\n\t\tpi->prgvolfirst = 0;\n\t}\n\n\tfor (pi->compno = pchg->compnostart, pi->picomp =\n\t  &pi->picomps[pi->compno]; pi->compno < JAS_CAST(int, pchg->compnoend) && pi->compno < pi->numcomps; ++pi->compno,\n\t  ++pi->picomp) {\n\t\tpirlvl = pi->picomp->pirlvls;\n\t\tpi->xstep = pi->picomp->hsamp * (1 << (pirlvl->prcwidthexpn +\n\t\t  pi->picomp->numrlvls - 1));\n\t\tpi->ystep = pi->picomp->vsamp * (1 << (pirlvl->prcheightexpn +\n\t\t  pi->picomp->numrlvls - 1));\n\t\tfor (rlvlno = 1, pirlvl = &pi->picomp->pirlvls[1];\n\t\t  rlvlno < pi->picomp->numrlvls; ++rlvlno, ++pirlvl) {\n\t\t\tpi->xstep = JAS_MIN(pi->xstep, pi->picomp->hsamp * (1 <<\n\t\t\t  (pirlvl->prcwidthexpn + pi->picomp->numrlvls -\n\t\t\t  rlvlno - 1)));\n\t\t\tpi->ystep = JAS_MIN(pi->ystep, pi->picomp->vsamp * (1 <<\n\t\t\t  (pirlvl->prcheightexpn + pi->picomp->numrlvls -\n\t\t\t  rlvlno - 1)));\n\t\t}\n\t\tfor (pi->y = pi->ystart; pi->y < pi->yend;\n\t\t  pi->y += pi->ystep - (pi->y % pi->ystep)) {\n\t\t\tfor (pi->x = pi->xstart; pi->x < pi->xend;\n\t\t\t  pi->x += pi->xstep - (pi->x % pi->xstep)) {\n\t\t\t\tfor (pi->rlvlno = pchg->rlvlnostart,\n\t\t\t\t  pi->pirlvl = &pi->picomp->pirlvls[pi->rlvlno];\n\t\t\t\t  pi->rlvlno < pi->picomp->numrlvls && pi->rlvlno <\n\t\t\t\t  pchg->rlvlnoend; ++pi->rlvlno, ++pi->pirlvl) {\n\t\t\t\t\tif (pi->pirlvl->numprcs == 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tr = pi->picomp->numrlvls - 1 - pi->rlvlno;\n\t\t\t\t\ttrx0 = JPC_CEILDIV(pi->xstart, pi->picomp->hsamp << r);\n\t\t\t\t\ttry0 = JPC_CEILDIV(pi->ystart, pi->picomp->vsamp << r);\n\t\t\t\t\trpx = r + pi->pirlvl->prcwidthexpn;\n\t\t\t\t\trpy = r + pi->pirlvl->prcheightexpn;\n\t\t\t\t\tif (((pi->x == pi->xstart && ((trx0 << r) % (1 << rpx))) ||\n\t\t\t\t\t  !(pi->x % (pi->picomp->hsamp << rpx))) &&\n\t\t\t\t\t  ((pi->y == pi->ystart && ((try0 << r) % (1 << rpy))) ||\n\t\t\t\t\t  !(pi->y % (pi->picomp->vsamp << rpy)))) {\n\t\t\t\t\t\tprchind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->x, pi->picomp->hsamp\n\t\t\t\t\t\t  << r), pi->pirlvl->prcwidthexpn) - JPC_FLOORDIVPOW2(trx0,\n\t\t\t\t\t\t  pi->pirlvl->prcwidthexpn);\n\t\t\t\t\t\tprcvind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->y, pi->picomp->vsamp\n\t\t\t\t\t\t  << r), pi->pirlvl->prcheightexpn) - JPC_FLOORDIVPOW2(try0,\n\t\t\t\t\t\t  pi->pirlvl->prcheightexpn);\n\t\t\t\t\t\tpi->prcno = prcvind *\n\t\t\t\t\t\t  pi->pirlvl->numhprcs +\n\t\t\t\t\t\t  prchind;\n\t\t\t\t\t\tassert(pi->prcno <\n\t\t\t\t\t\t  pi->pirlvl->numprcs);\n\t\t\t\t\t\tfor (pi->lyrno = 0; pi->lyrno <\n\t\t\t\t\t\t  pi->numlyrs && pi->lyrno < JAS_CAST(int, pchg->lyrnoend); ++pi->lyrno) {\n\t\t\t\t\t\t\tprclyrno = &pi->pirlvl->prclyrnos[pi->prcno];\n\t\t\t\t\t\t\tif (pi->lyrno >= *prclyrno) {\n\t\t\t\t\t\t\t\t++(*prclyrno);\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t}\nskip:\n\t\t\t\t\t\t\t;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149752,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static int jpc_pi_nextcprl(register jpc_pi_t *pi)\n{\n\tint rlvlno;\n\tjpc_pirlvl_t *pirlvl;\n\tjpc_pchg_t *pchg;\n\tint prchind;\n\tint prcvind;\n\tint *prclyrno;\n\tuint_fast32_t trx0;\n\tuint_fast32_t try0;\n\tuint_fast32_t r;\n\tuint_fast32_t rpx;\n\tuint_fast32_t rpy;\n\n\tpchg = pi->pchg;\n\tif (!pi->prgvolfirst) {\n\t\tgoto skip;\n\t} else {\n\t\tpi->prgvolfirst = 0;\n\t}\n\n\tfor (pi->compno = pchg->compnostart, pi->picomp =\n\t  &pi->picomps[pi->compno]; pi->compno < JAS_CAST(int, pchg->compnoend) && pi->compno < pi->numcomps; ++pi->compno,\n\t  ++pi->picomp) {\n\t\tpirlvl = pi->picomp->pirlvls;\n\t\tpi->xstep = pi->picomp->hsamp * (JAS_CAST(uint_fast32_t, 1) <<\n\t\t  (pirlvl->prcwidthexpn + pi->picomp->numrlvls - 1));\n\t\tpi->ystep = pi->picomp->vsamp * (JAS_CAST(uint_fast32_t, 1) <<\n\t\t  (pirlvl->prcheightexpn + pi->picomp->numrlvls - 1));\n\t\tfor (rlvlno = 1, pirlvl = &pi->picomp->pirlvls[1];\n\t\t  rlvlno < pi->picomp->numrlvls; ++rlvlno, ++pirlvl) {\n\t\t\tpi->xstep = JAS_MIN(pi->xstep, pi->picomp->hsamp *\n\t\t\t  (JAS_CAST(uint_fast32_t, 1) << (pirlvl->prcwidthexpn +\n\t\t\t  pi->picomp->numrlvls - rlvlno - 1)));\n\t\t\tpi->ystep = JAS_MIN(pi->ystep, pi->picomp->vsamp *\n\t\t\t  (JAS_CAST(uint_fast32_t, 1) << (pirlvl->prcheightexpn +\n\t\t\t  pi->picomp->numrlvls - rlvlno - 1)));\n\t\t}\n\t\tfor (pi->y = pi->ystart; pi->y < pi->yend;\n\t\t  pi->y += pi->ystep - (pi->y % pi->ystep)) {\n\t\t\tfor (pi->x = pi->xstart; pi->x < pi->xend;\n\t\t\t  pi->x += pi->xstep - (pi->x % pi->xstep)) {\n\t\t\t\tfor (pi->rlvlno = pchg->rlvlnostart,\n\t\t\t\t  pi->pirlvl = &pi->picomp->pirlvls[pi->rlvlno];\n\t\t\t\t  pi->rlvlno < pi->picomp->numrlvls && pi->rlvlno <\n\t\t\t\t  pchg->rlvlnoend; ++pi->rlvlno, ++pi->pirlvl) {\n\t\t\t\t\tif (pi->pirlvl->numprcs == 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tr = pi->picomp->numrlvls - 1 - pi->rlvlno;\n\t\t\t\t\ttrx0 = JPC_CEILDIV(pi->xstart, pi->picomp->hsamp << r);\n\t\t\t\t\ttry0 = JPC_CEILDIV(pi->ystart, pi->picomp->vsamp << r);\n\t\t\t\t\trpx = r + pi->pirlvl->prcwidthexpn;\n\t\t\t\t\trpy = r + pi->pirlvl->prcheightexpn;\n\t\t\t\t\tif (((pi->x == pi->xstart && ((trx0 << r) % (1 << rpx))) ||\n\t\t\t\t\t  !(pi->x % (pi->picomp->hsamp << rpx))) &&\n\t\t\t\t\t  ((pi->y == pi->ystart && ((try0 << r) % (1 << rpy))) ||\n\t\t\t\t\t  !(pi->y % (pi->picomp->vsamp << rpy)))) {\n\t\t\t\t\t\tprchind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->x, pi->picomp->hsamp\n\t\t\t\t\t\t  << r), pi->pirlvl->prcwidthexpn) - JPC_FLOORDIVPOW2(trx0,\n\t\t\t\t\t\t  pi->pirlvl->prcwidthexpn);\n\t\t\t\t\t\tprcvind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->y, pi->picomp->vsamp\n\t\t\t\t\t\t  << r), pi->pirlvl->prcheightexpn) - JPC_FLOORDIVPOW2(try0,\n\t\t\t\t\t\t  pi->pirlvl->prcheightexpn);\n\t\t\t\t\t\tpi->prcno = prcvind *\n\t\t\t\t\t\t  pi->pirlvl->numhprcs +\n\t\t\t\t\t\t  prchind;\n\t\t\t\t\t\tassert(pi->prcno <\n\t\t\t\t\t\t  pi->pirlvl->numprcs);\n\t\t\t\t\t\tfor (pi->lyrno = 0; pi->lyrno <\n\t\t\t\t\t\t  pi->numlyrs && pi->lyrno < JAS_CAST(int, pchg->lyrnoend); ++pi->lyrno) {\n\t\t\t\t\t\t\tprclyrno = &pi->pirlvl->prclyrnos[pi->prcno];\n\t\t\t\t\t\t\tif (pi->lyrno >= *prclyrno) {\n\t\t\t\t\t\t\t\t++(*prclyrno);\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t}\nskip:\n\t\t\t\t\t\t\t;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149753,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static inline void process_get_command(conn *c, token_t *tokens, size_t ntokens, bool return_cas) {\n    char *key;\n    size_t nkey;\n    int i = 0;\n    item *it;\n    token_t *key_token = &tokens[KEY_TOKEN];\n    char *suffix;\n    assert(c != NULL);\n\n    do {\n        while(key_token->length != 0) {\n\n            key = key_token->value;\n            nkey = key_token->length;\n\n            if(nkey > KEY_MAX_LENGTH) {\n                out_string(c, \"CLIENT_ERROR bad command line format\");\n                while (i-- > 0) {\n                    item_remove(*(c->ilist + i));\n                }\n                return;\n            }\n\n            it = item_get(key, nkey, c, DO_UPDATE);\n            if (settings.detail_enabled) {\n                stats_prefix_record_get(key, nkey, NULL != it);\n            }\n            if (it) {\n                if (i >= c->isize) {\n                    item **new_list = realloc(c->ilist, sizeof(item *) * c->isize * 2);\n                    if (new_list) {\n                        c->isize *= 2;\n                        c->ilist = new_list;\n                    } else {\n                        STATS_LOCK();\n                        stats.malloc_fails++;\n                        STATS_UNLOCK();\n                        item_remove(it);\n                        break;\n                    }\n                }\n\n                /*\n                 * Construct the response. Each hit adds three elements to the\n                 * outgoing data list:\n                 *   \"VALUE \"\n                 *   key\n                 *   \" \" + flags + \" \" + data length + \"\\r\\n\" + data (with \\r\\n)\n                 */\n\n                if (return_cas || !settings.inline_ascii_response)\n                {\n                  MEMCACHED_COMMAND_GET(c->sfd, ITEM_key(it), it->nkey,\n                                        it->nbytes, ITEM_get_cas(it));\n                  /* Goofy mid-flight realloc. */\n                  if (i >= c->suffixsize) {\n                    char **new_suffix_list = realloc(c->suffixlist,\n                                           sizeof(char *) * c->suffixsize * 2);\n                    if (new_suffix_list) {\n                        c->suffixsize *= 2;\n                        c->suffixlist  = new_suffix_list;\n                    } else {\n                        STATS_LOCK();\n                        stats.malloc_fails++;\n                        STATS_UNLOCK();\n                        item_remove(it);\n                        break;\n                    }\n                  }\n\n                  suffix = do_cache_alloc(c->thread->suffix_cache);\n                  if (suffix == NULL) {\n                      STATS_LOCK();\n                      stats.malloc_fails++;\n                      STATS_UNLOCK();\n                      out_of_memory(c, \"SERVER_ERROR out of memory making CAS suffix\");\n                      item_remove(it);\n                      while (i-- > 0) {\n                          item_remove(*(c->ilist + i));\n                      }\n                      return;\n                  }\n                  *(c->suffixlist + i) = suffix;\n                  int suffix_len = make_ascii_get_suffix(suffix, it, return_cas);\n                  if (add_iov(c, \"VALUE \", 6) != 0 ||\n                      add_iov(c, ITEM_key(it), it->nkey) != 0 ||\n                      (settings.inline_ascii_response && add_iov(c, ITEM_suffix(it), it->nsuffix - 2) != 0) ||\n                      add_iov(c, suffix, suffix_len) != 0)\n                      {\n                          item_remove(it);\n                          break;\n                      }\n                  if ((it->it_flags & ITEM_CHUNKED) == 0) {\n                      add_iov(c, ITEM_data(it), it->nbytes);\n                  } else if (add_chunked_item_iovs(c, it, it->nbytes) != 0) {\n                      item_remove(it);\n                      break;\n                  }\n                }\n                else\n                {\n                  MEMCACHED_COMMAND_GET(c->sfd, ITEM_key(it), it->nkey,\n                                        it->nbytes, ITEM_get_cas(it));\n                  if (add_iov(c, \"VALUE \", 6) != 0 ||\n                      add_iov(c, ITEM_key(it), it->nkey) != 0)\n                      {\n                          item_remove(it);\n                          break;\n                      }\n                  if ((it->it_flags & ITEM_CHUNKED) == 0)\n                      {\n                          if (add_iov(c, ITEM_suffix(it), it->nsuffix + it->nbytes) != 0)\n                          {\n                              item_remove(it);\n                              break;\n                          }\n                      } else if (add_iov(c, ITEM_suffix(it), it->nsuffix) != 0 ||\n                                 add_chunked_item_iovs(c, it, it->nbytes) != 0) {\n                          item_remove(it);\n                          break;\n                      }\n                }\n\n\n                if (settings.verbose > 1) {\n                    int ii;\n                    fprintf(stderr, \">%d sending key \", c->sfd);\n                    for (ii = 0; ii < it->nkey; ++ii) {\n                        fprintf(stderr, \"%c\", key[ii]);\n                    }\n                    fprintf(stderr, \"\\n\");\n                }\n\n                /* item_get() has incremented it->refcount for us */\n                pthread_mutex_lock(&c->thread->stats.mutex);\n                c->thread->stats.slab_stats[ITEM_clsid(it)].get_hits++;\n                c->thread->stats.get_cmds++;\n                pthread_mutex_unlock(&c->thread->stats.mutex);\n                *(c->ilist + i) = it;\n                i++;\n\n            } else {\n                pthread_mutex_lock(&c->thread->stats.mutex);\n                c->thread->stats.get_misses++;\n                c->thread->stats.get_cmds++;\n                pthread_mutex_unlock(&c->thread->stats.mutex);\n                MEMCACHED_COMMAND_GET(c->sfd, key, nkey, -1, 0);\n            }\n\n            key_token++;\n        }\n\n        /*\n         * If the command string hasn't been fully processed, get the next set\n         * of tokens.\n         */\n        if(key_token->value != NULL) {\n            ntokens = tokenize_command(key_token->value, tokens, MAX_TOKENS);\n            key_token = tokens;\n        }\n\n    } while(key_token->value != NULL);\n\n    c->icurr = c->ilist;\n    c->ileft = i;\n    if (return_cas || !settings.inline_ascii_response) {\n        c->suffixcurr = c->suffixlist;\n        c->suffixleft = i;\n    }\n\n    if (settings.verbose > 1)\n        fprintf(stderr, \">%d END\\n\", c->sfd);\n\n    /*\n        If the loop was terminated because of out-of-memory, it is not\n        reliable to add END\\r\\n to the buffer, because it might not end\n        in \\r\\n. So we send SERVER_ERROR instead.\n    */\n    if (key_token->value != NULL || add_iov(c, \"END\\r\\n\", 5) != 0\n        || (IS_UDP(c->transport) && build_udp_headers(c) != 0)) {\n        out_of_memory(c, \"SERVER_ERROR out of memory writing get response\");\n    }\n    else {\n        conn_set_state(c, conn_mwrite);\n        c->msgcurr = 0;\n    }\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149754,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static inline void process_get_command(conn *c, token_t *tokens, size_t ntokens, bool return_cas) {\n    char *key;\n    size_t nkey;\n    int i = 0;\n    item *it;\n    token_t *key_token = &tokens[KEY_TOKEN];\n    char *suffix;\n    assert(c != NULL);\n\n    do {\n        while(key_token->length != 0) {\n\n            key = key_token->value;\n            nkey = key_token->length;\n\n            if(nkey > KEY_MAX_LENGTH) {\n                out_string(c, \"CLIENT_ERROR bad command line format\");\n                while (i-- > 0) {\n                    item_remove(*(c->ilist + i));\n                }\n                return;\n            }\n\n            it = limited_get(key, nkey, c);\n            if (settings.detail_enabled) {\n                stats_prefix_record_get(key, nkey, NULL != it);\n            }\n            if (it) {\n                if (i >= c->isize) {\n                    item **new_list = realloc(c->ilist, sizeof(item *) * c->isize * 2);\n                    if (new_list) {\n                        c->isize *= 2;\n                        c->ilist = new_list;\n                    } else {\n                        STATS_LOCK();\n                        stats.malloc_fails++;\n                        STATS_UNLOCK();\n                        item_remove(it);\n                        break;\n                    }\n                }\n\n                /*\n                 * Construct the response. Each hit adds three elements to the\n                 * outgoing data list:\n                 *   \"VALUE \"\n                 *   key\n                 *   \" \" + flags + \" \" + data length + \"\\r\\n\" + data (with \\r\\n)\n                 */\n\n                if (return_cas || !settings.inline_ascii_response)\n                {\n                  MEMCACHED_COMMAND_GET(c->sfd, ITEM_key(it), it->nkey,\n                                        it->nbytes, ITEM_get_cas(it));\n                  /* Goofy mid-flight realloc. */\n                  if (i >= c->suffixsize) {\n                    char **new_suffix_list = realloc(c->suffixlist,\n                                           sizeof(char *) * c->suffixsize * 2);\n                    if (new_suffix_list) {\n                        c->suffixsize *= 2;\n                        c->suffixlist  = new_suffix_list;\n                    } else {\n                        STATS_LOCK();\n                        stats.malloc_fails++;\n                        STATS_UNLOCK();\n                        item_remove(it);\n                        break;\n                    }\n                  }\n\n                  suffix = do_cache_alloc(c->thread->suffix_cache);\n                  if (suffix == NULL) {\n                      STATS_LOCK();\n                      stats.malloc_fails++;\n                      STATS_UNLOCK();\n                      out_of_memory(c, \"SERVER_ERROR out of memory making CAS suffix\");\n                      item_remove(it);\n                      while (i-- > 0) {\n                          item_remove(*(c->ilist + i));\n                      }\n                      return;\n                  }\n                  *(c->suffixlist + i) = suffix;\n                  int suffix_len = make_ascii_get_suffix(suffix, it, return_cas);\n                  if (add_iov(c, \"VALUE \", 6) != 0 ||\n                      add_iov(c, ITEM_key(it), it->nkey) != 0 ||\n                      (settings.inline_ascii_response && add_iov(c, ITEM_suffix(it), it->nsuffix - 2) != 0) ||\n                      add_iov(c, suffix, suffix_len) != 0)\n                      {\n                          item_remove(it);\n                          break;\n                      }\n                  if ((it->it_flags & ITEM_CHUNKED) == 0) {\n                      add_iov(c, ITEM_data(it), it->nbytes);\n                  } else if (add_chunked_item_iovs(c, it, it->nbytes) != 0) {\n                      item_remove(it);\n                      break;\n                  }\n                }\n                else\n                {\n                  MEMCACHED_COMMAND_GET(c->sfd, ITEM_key(it), it->nkey,\n                                        it->nbytes, ITEM_get_cas(it));\n                  if (add_iov(c, \"VALUE \", 6) != 0 ||\n                      add_iov(c, ITEM_key(it), it->nkey) != 0)\n                      {\n                          item_remove(it);\n                          break;\n                      }\n                  if ((it->it_flags & ITEM_CHUNKED) == 0)\n                      {\n                          if (add_iov(c, ITEM_suffix(it), it->nsuffix + it->nbytes) != 0)\n                          {\n                              item_remove(it);\n                              break;\n                          }\n                      } else if (add_iov(c, ITEM_suffix(it), it->nsuffix) != 0 ||\n                                 add_chunked_item_iovs(c, it, it->nbytes) != 0) {\n                          item_remove(it);\n                          break;\n                      }\n                }\n\n\n                if (settings.verbose > 1) {\n                    int ii;\n                    fprintf(stderr, \">%d sending key \", c->sfd);\n                    for (ii = 0; ii < it->nkey; ++ii) {\n                        fprintf(stderr, \"%c\", key[ii]);\n                    }\n                    fprintf(stderr, \"\\n\");\n                }\n\n                /* item_get() has incremented it->refcount for us */\n                pthread_mutex_lock(&c->thread->stats.mutex);\n                c->thread->stats.slab_stats[ITEM_clsid(it)].get_hits++;\n                c->thread->stats.get_cmds++;\n                pthread_mutex_unlock(&c->thread->stats.mutex);\n                *(c->ilist + i) = it;\n                i++;\n\n            } else {\n                pthread_mutex_lock(&c->thread->stats.mutex);\n                c->thread->stats.get_misses++;\n                c->thread->stats.get_cmds++;\n                pthread_mutex_unlock(&c->thread->stats.mutex);\n                MEMCACHED_COMMAND_GET(c->sfd, key, nkey, -1, 0);\n            }\n\n            key_token++;\n        }\n\n        /*\n         * If the command string hasn't been fully processed, get the next set\n         * of tokens.\n         */\n        if(key_token->value != NULL) {\n            ntokens = tokenize_command(key_token->value, tokens, MAX_TOKENS);\n            key_token = tokens;\n        }\n\n    } while(key_token->value != NULL);\n\n    c->icurr = c->ilist;\n    c->ileft = i;\n    if (return_cas || !settings.inline_ascii_response) {\n        c->suffixcurr = c->suffixlist;\n        c->suffixleft = i;\n    }\n\n    if (settings.verbose > 1)\n        fprintf(stderr, \">%d END\\n\", c->sfd);\n\n    /*\n        If the loop was terminated because of out-of-memory, it is not\n        reliable to add END\\r\\n to the buffer, because it might not end\n        in \\r\\n. So we send SERVER_ERROR instead.\n    */\n    if (key_token->value != NULL || add_iov(c, \"END\\r\\n\", 5) != 0\n        || (IS_UDP(c->transport) && build_udp_headers(c) != 0)) {\n        out_of_memory(c, \"SERVER_ERROR out of memory writing get response\");\n    }\n    else {\n        conn_set_state(c, conn_mwrite);\n        c->msgcurr = 0;\n    }\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149755,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static MagickBooleanType ReadPSDChannelPixels(Image *image,\n  const size_t channels,const ssize_t row,const ssize_t type,\n  const unsigned char *pixels,ExceptionInfo *exception)\n{\n  Quantum\n    pixel;\n\n  const unsigned char\n    *p;\n\n  IndexPacket\n    *indexes;\n\n  PixelPacket\n    *q;\n\n  ssize_t\n    x;\n\n  size_t\n    packet_size;\n\n  unsigned short\n    nibble;\n\n  p=pixels;\n  q=GetAuthenticPixels(image,0,row,image->columns,1,exception);\n  if (q == (PixelPacket *) NULL)\n    return MagickFalse;\n  indexes=GetAuthenticIndexQueue(image);\n  packet_size=GetPSDPacketSize(image);\n  for (x=0; x < (ssize_t) image->columns; x++)\n  {\n    if (packet_size == 1)\n      pixel=ScaleCharToQuantum(*p++);\n    else\n      if (packet_size == 2)\n        {\n          p=PushShortPixel(MSBEndian,p,&nibble);\n          pixel=ScaleShortToQuantum(nibble);\n        }\n      else\n        {\n          MagickFloatType\n            nibble;\n\n          p=PushFloatPixel(MSBEndian,p,&nibble);\n          pixel=ClampToQuantum((MagickRealType)QuantumRange*nibble);\n        }\n    if (image->depth > 1)\n      {\n        SetPSDPixel(image,channels,type,packet_size,pixel,q,indexes,x);\n        q++;\n      }\n    else\n      {\n        ssize_t\n          bit,\n          number_bits;\n\n        number_bits=(ssize_t) image->columns-x;\n        if (number_bits > 8)\n          number_bits=8;\n        for (bit=0; bit < number_bits; bit++)\n        {\n          SetPSDPixel(image,channels,type,packet_size,\n            (((unsigned char) ((ssize_t) pixel)) & (0x01 << (7-bit))) != 0 ? 0 :\n            QuantumRange,q++,indexes,x++);\n        }\n        if (x != (ssize_t) image->columns)\n          x--;\n        continue;\n      }\n  }\n  return(SyncAuthenticPixels(image,exception));\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 3,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "  void Compute(OpKernelContext* context) override {\n    const Tensor* input_indices;\n    const Tensor* input_values;\n    const Tensor* input_shape;\n    SparseTensorsMap* map;\n\n    OP_REQUIRES_OK(context, context->input(\"sparse_indices\", &input_indices));\n    OP_REQUIRES_OK(context, context->input(\"sparse_values\", &input_values));\n    OP_REQUIRES_OK(context, context->input(\"sparse_shape\", &input_shape));\n    OP_REQUIRES_OK(context, GetMap(context, true /* is_writing */, &map));\n\n    OP_REQUIRES(context, TensorShapeUtils::IsMatrix(input_indices->shape()),\n                errors::InvalidArgument(\n                    \"Input indices should be a matrix but received shape \",\n                    input_indices->shape().DebugString()));\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(input_values->shape()),\n                errors::InvalidArgument(\n                    \"Input values should be a vector but received shape \",\n                    input_values->shape().DebugString()));\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(input_shape->shape()),\n                errors::InvalidArgument(\n                    \"Input shape should be a vector but received shape \",\n                    input_shape->shape().DebugString()));\n    OP_REQUIRES(\n        context,\n        input_values->shape().dim_size(0) == input_indices->shape().dim_size(0),\n        errors::InvalidArgument(\n            \"Number of values must match first dimension of indices. \", \"Got \",\n            input_values->shape().dim_size(0),\n            \" values, indices shape: \", input_indices->shape().DebugString()));\n    OP_REQUIRES(\n        context,\n        input_shape->shape().dim_size(0) == input_indices->shape().dim_size(1),\n        errors::InvalidArgument(\n            \"Number of dimensions must match second dimension of indices. \",\n            \"Got \", input_shape->shape().dim_size(0),\n            \" dimensions, indices shape: \",\n            input_indices->shape().DebugString()));\n\n    int rank = input_shape->NumElements();\n\n    OP_REQUIRES(\n        context, rank > 1,\n        errors::InvalidArgument(\n            \"Rank of input SparseTensor should be > 1, but saw rank: \", rank));\n\n    auto input_shape_vec = input_shape->vec<int64_t>();\n\n    TensorShape tensor_input_shape;\n    OP_REQUIRES_OK(context, TensorShape::BuildTensorShape(input_shape_vec,\n                                                          &tensor_input_shape));\n    gtl::InlinedVector<int64_t, 8> std_order(rank);\n    std::iota(std_order.begin(), std_order.end(), 0);\n    SparseTensor input_st;\n    OP_REQUIRES_OK(context, SparseTensor::Create(*input_indices, *input_values,\n                                                 tensor_input_shape, std_order,\n                                                 &input_st));\n\n    const int64_t N = input_shape_vec(0);\n\n    Tensor sparse_handles(DT_INT64, TensorShape({N}));\n    auto sparse_handles_t = sparse_handles.vec<int64_t>();\n\n    OP_REQUIRES_OK(context, input_st.IndicesValid());\n\n    // We can generate the output shape proto string now, for all\n    // minibatch entries.\n    TensorShape output_shape;\n    OP_REQUIRES_OK(context, TensorShapeUtils::MakeShape(\n                                input_shape_vec.data() + 1,\n                                input_shape->NumElements() - 1, &output_shape));\n\n    // Get groups by minibatch dimension\n    std::unordered_set<int64_t> visited;\n    sparse::GroupIterable minibatch = input_st.group({0});\n    for (const auto& subset : minibatch) {\n      const int64_t b = subset.group()[0];\n      visited.insert(b);\n      OP_REQUIRES(\n          context, b > -1 && b < N,\n          errors::InvalidArgument(\n              \"Received unexpected column 0 value in input SparseTensor: \", b,\n              \" < 0 or >= N (= \", N, \")\"));\n\n      const auto indices = subset.indices();\n      const auto values = subset.values<T>();\n      const int64_t num_entries = values.size();\n\n      Tensor output_indices = Tensor(DT_INT64, {num_entries, rank - 1});\n      Tensor output_values = Tensor(DataTypeToEnum<T>::value, {num_entries});\n\n      auto output_indices_t = output_indices.matrix<int64_t>();\n      auto output_values_t = output_values.vec<T>();\n\n      for (int i = 0; i < num_entries; ++i) {\n        for (int d = 1; d < rank; ++d) {\n          output_indices_t(i, d - 1) = indices(i, d);\n        }\n        output_values_t(i) = values(i);\n      }\n\n      SparseTensor st_i;\n      OP_REQUIRES_OK(context,\n                     SparseTensor::Create(output_indices, output_values,\n                                          output_shape, &st_i));\n      int64_t handle;\n      OP_REQUIRES_OK(context, map->AddSparseTensor(context, st_i, &handle));\n      sparse_handles_t(b) = handle;\n    }\n\n    // Fill in any gaps; we must provide an empty ST for batch entries\n    // the grouper didn't find.\n    if (visited.size() < N) {\n      Tensor empty_indices(DT_INT64, {0, rank - 1});\n      Tensor empty_values(DataTypeToEnum<T>::value, {0});\n      SparseTensor empty_st;\n      OP_REQUIRES_OK(context, SparseTensor::Create(empty_indices, empty_values,\n                                                   output_shape, &empty_st));\n\n      for (int64_t b = 0; b < N; ++b) {\n        // We skipped this batch entry.\n        if (visited.find(b) == visited.end()) {\n          int64_t handle;\n          OP_REQUIRES_OK(context,\n                         map->AddSparseTensor(context, empty_st, &handle));\n          sparse_handles_t(b) = handle;\n        }\n      }\n    }\n\n    context->set_output(0, sparse_handles);\n  }",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 17,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static Image *ReadPCLImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define CropBox  \"CropBox\"\n#define DeviceCMYK  \"DeviceCMYK\"\n#define MediaBox  \"MediaBox\"\n#define RenderPCLText  \"  Rendering PCL...  \"\n\n  char\n    command[MagickPathExtent],\n    *density,\n    filename[MagickPathExtent],\n    geometry[MagickPathExtent],\n    *options,\n    input_filename[MagickPathExtent];\n\n  const DelegateInfo\n    *delegate_info;\n\n  Image\n    *image,\n    *next_image;\n\n  ImageInfo\n    *read_info;\n\n  MagickBooleanType\n    cmyk,\n    status;\n\n  PointInfo\n    delta;\n\n  RectangleInfo\n    bounding_box,\n    page;\n\n  char\n    *p;\n\n  ssize_t\n    c;\n\n  SegmentInfo\n    bounds;\n\n  size_t\n    height,\n    width;\n\n  ssize_t\n    count;\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  /*\n    Open image file.\n  */\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  status=AcquireUniqueSymbolicLink(image_info->filename,input_filename);\n  if (status == MagickFalse)\n    {\n      ThrowFileException(exception,FileOpenError,\"UnableToCreateTemporaryFile\",\n        image_info->filename);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Set the page density.\n  */\n  delta.x=DefaultResolution;\n  delta.y=DefaultResolution;\n  if ((image->resolution.x == 0.0) || (image->resolution.y == 0.0))\n    {\n      GeometryInfo\n        geometry_info;\n\n      MagickStatusType\n        flags;\n\n      flags=ParseGeometry(PSDensityGeometry,&geometry_info);\n      if ((flags & RhoValue) != 0)\n        image->resolution.x=geometry_info.rho;\n      image->resolution.y=image->resolution.x;\n      if ((flags & SigmaValue) != 0)\n        image->resolution.y=geometry_info.sigma;\n    }\n  /*\n    Determine page geometry from the PCL media box.\n  */\n  cmyk=image->colorspace == CMYKColorspace ? MagickTrue : MagickFalse;\n  count=0;\n  (void) memset(&bounding_box,0,sizeof(bounding_box));\n  (void) memset(&bounds,0,sizeof(bounds));\n  (void) memset(&page,0,sizeof(page));\n  (void) memset(command,0,sizeof(command));\n  p=command;\n  for (c=ReadBlobByte(image); c != EOF; c=ReadBlobByte(image))\n  {\n    if (image_info->page != (char *) NULL)\n      continue;\n    /*\n      Note PCL elements.\n    */\n    *p++=(char) c;\n    if ((c != (int) '/') && (c != '\\n') &&\n        ((size_t) (p-command) < (MagickPathExtent-1)))\n      continue;\n    *p='\\0';\n    p=command;\n    /*\n      Is this a CMYK document?\n    */\n    if (LocaleNCompare(DeviceCMYK,command,strlen(DeviceCMYK)) == 0)\n      cmyk=MagickTrue;\n    if (LocaleNCompare(CropBox,command,strlen(CropBox)) == 0)\n      {\n        /*\n          Note region defined by crop box.\n        */\n        count=(ssize_t) sscanf(command,\"CropBox [%lf %lf %lf %lf\",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        if (count != 4)\n          count=(ssize_t) sscanf(command,\"CropBox[%lf %lf %lf %lf\",\n            &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n      }\n    if (LocaleNCompare(MediaBox,command,strlen(MediaBox)) == 0)\n      {\n        /*\n          Note region defined by media box.\n        */\n        count=(ssize_t) sscanf(command,\"MediaBox [%lf %lf %lf %lf\",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        if (count != 4)\n          count=(ssize_t) sscanf(command,\"MediaBox[%lf %lf %lf %lf\",\n            &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n      }\n    if (count != 4)\n      continue;\n    /*\n      Set PCL render geometry.\n    */\n    width=(size_t)CastDoubleToLong(floor(bounds.x2-bounds.x1+0.5));\n    height=(size_t)CastDoubleToLong(floor(bounds.y2-bounds.y1+0.5));\n    if (width > page.width)\n      page.width=width;\n    if (height > page.height)\n      page.height=height;\n  }\n  (void) CloseBlob(image);\n  /*\n    Render PCL with the GhostPCL delegate.\n  */\n  if ((page.width == 0) || (page.height == 0))\n    (void) ParseAbsoluteGeometry(PSPageGeometry,&page);\n  if (image_info->page != (char *) NULL)\n    (void) ParseAbsoluteGeometry(image_info->page,&page);\n  (void) FormatLocaleString(geometry,MagickPathExtent,\"%.20gx%.20g\",(double)\n    page.width,(double) page.height);\n  if (image_info->monochrome != MagickFalse)\n    delegate_info=GetDelegateInfo(\"pcl:mono\",(char *) NULL,exception);\n  else\n     if (cmyk != MagickFalse)\n       delegate_info=GetDelegateInfo(\"pcl:cmyk\",(char *) NULL,exception);\n     else\n       delegate_info=GetDelegateInfo(\"pcl:color\",(char *) NULL,exception);\n  if (delegate_info == (const DelegateInfo *) NULL)\n    {\n      image=DestroyImage(image);\n      return((Image *) NULL);\n    }\n  if ((page.width == 0) || (page.height == 0))\n    (void) ParseAbsoluteGeometry(PSPageGeometry,&page);\n  if (image_info->page != (char *) NULL)\n    (void) ParseAbsoluteGeometry(image_info->page,&page);\n  density=AcquireString(\"\");\n  options=AcquireString(\"\");\n  (void) FormatLocaleString(density,MagickPathExtent,\"%gx%g\",\n    image->resolution.x,image->resolution.y);\n  if (image_info->ping != MagickFalse)\n    (void) FormatLocaleString(density,MagickPathExtent,\"2.0x2.0\");\n  page.width=(size_t) floor(page.width*image->resolution.x/delta.x+0.5);\n  page.height=(size_t) floor(page.height*image->resolution.y/delta.y+0.5);\n  (void) FormatLocaleString(options,MagickPathExtent,\"-g%.20gx%.20g \",(double)\n    page.width,(double) page.height);\n  image=DestroyImage(image);\n  read_info=CloneImageInfo(image_info);\n  *read_info->magick='\\0';\n  if (read_info->number_scenes != 0)\n    {\n      if (read_info->number_scenes != 1)\n        (void) FormatLocaleString(options,MagickPathExtent,\"-dLastPage=%.20g\",\n          (double) (read_info->scene+read_info->number_scenes));\n      else\n        (void) FormatLocaleString(options,MagickPathExtent,\n          \"-dFirstPage=%.20g -dLastPage=%.20g\",(double) read_info->scene+1,\n          (double) (read_info->scene+read_info->number_scenes));\n      read_info->number_scenes=0;\n      if (read_info->scenes != (char *) NULL)\n        *read_info->scenes='\\0';\n    }\n  (void) CopyMagickString(filename,read_info->filename,MagickPathExtent);\n  (void) AcquireUniqueFilename(read_info->filename);\n  (void) FormatLocaleString(command,MagickPathExtent,\n    GetDelegateCommands(delegate_info),\n    read_info->antialias != MagickFalse ? 4 : 1,\n    read_info->antialias != MagickFalse ? 4 : 1,density,options,\n    read_info->filename,input_filename);\n  options=DestroyString(options);\n  density=DestroyString(density);\n  status=ExternalDelegateCommand(MagickFalse,read_info->verbose,command,\n    (char *) NULL,exception) != 0 ? MagickTrue : MagickFalse;\n  image=ReadImage(read_info,exception);\n  (void) RelinquishUniqueFileResource(read_info->filename);\n  (void) RelinquishUniqueFileResource(input_filename);\n  read_info=DestroyImageInfo(read_info);\n  if (image == (Image *) NULL)\n    ThrowReaderException(DelegateError,\"PCLDelegateFailed\");\n  if (LocaleCompare(image->magick,\"BMP\") == 0)\n    {\n      Image\n        *cmyk_image;\n\n      cmyk_image=ConsolidateCMYKImages(image,exception);\n      if (cmyk_image != (Image *) NULL)\n        {\n          image=DestroyImageList(image);\n          image=cmyk_image;\n        }\n    }\n  do\n  {\n    (void) CopyMagickString(image->filename,filename,MagickPathExtent);\n    image->page=page;\n    if (image_info->ping != MagickFalse)\n      {\n        image->magick_columns*=image->resolution.x/2.0;\n        image->magick_rows*=image->resolution.y/2.0;\n        image->columns*=image->resolution.x/2.0;\n        image->rows*=image->resolution.y/2.0;\n      }\n    next_image=SyncNextImageInList(image);\n    if (next_image != (Image *) NULL)\n      image=next_image;\n  } while (next_image != (Image *) NULL);\n  return(GetFirstImageInList(image));\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 65,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "  void Compute(OpKernelContext *ctx) override {\n    const Tensor *indices_t, *values_t, *shape_t, *dense_t;\n    OP_REQUIRES_OK(ctx, ctx->input(\"sp_indices\", &indices_t));\n    OP_REQUIRES_OK(ctx, ctx->input(\"sp_values\", &values_t));\n    OP_REQUIRES_OK(ctx, ctx->input(\"sp_shape\", &shape_t));\n    OP_REQUIRES_OK(ctx, ctx->input(\"dense\", &dense_t));\n\n    // Validations.\n    OP_REQUIRES(ctx, TensorShapeUtils::IsMatrix(indices_t->shape()),\n                errors::InvalidArgument(\n                    \"Input sp_indices should be a matrix but received shape: \",\n                    indices_t->shape().DebugString()));\n    OP_REQUIRES(ctx,\n                TensorShapeUtils::IsVector(values_t->shape()) &&\n                    TensorShapeUtils::IsVector(shape_t->shape()),\n                errors::InvalidArgument(\n                    \"Inputs sp_values and sp_shape should be vectors \"\n                    \"but received shapes: \",\n                    values_t->shape().DebugString(), \" and \",\n                    shape_t->shape().DebugString()));\n    OP_REQUIRES(\n        ctx, TensorShapeUtils::IsVector(shape_t->shape()),\n        errors::InvalidArgument(\"Input sp_shape must be a vector. Got: \",\n                                shape_t->shape().DebugString()));\n    OP_REQUIRES(\n        ctx, values_t->dim_size(0) == indices_t->dim_size(0),\n        errors::InvalidArgument(\n            \"The first dimension of values and indices should match. (\",\n            values_t->dim_size(0), \" vs. \", indices_t->dim_size(0), \")\"));\n    OP_REQUIRES(\n        ctx, shape_t->shape().dim_size(0) == indices_t->shape().dim_size(1),\n        errors::InvalidArgument(\n            \"Number of dimensions must match second dimension of indices. \",\n            \"Got \", shape_t->shape().dim_size(0),\n            \" dimensions, indices shape: \", indices_t->shape().DebugString()));\n    OP_REQUIRES(ctx, shape_t->NumElements() > 0,\n                errors::InvalidArgument(\n                    \"The shape argument requires at least one element.\"));\n\n    const auto indices_mat = indices_t->matrix<int64_t>();\n    const auto shape_vec = shape_t->vec<int64_t>();\n    TensorShape lhs_shape;\n    OP_REQUIRES_OK(ctx, TensorShape::BuildTensorShape(shape_vec, &lhs_shape));\n    const auto lhs_dims = BCast::FromShape(lhs_shape);\n    const auto rhs_dims = BCast::FromShape(dense_t->shape());\n    BCast b(lhs_dims, rhs_dims, false);  // false for keeping the same num dims.\n\n    // True iff (size(lhs) >= size(rhs)) and all dims in lhs is greater or equal\n    // to dims in rhs (from right to left).\n    auto VecGreaterEq = [](ArraySlice<int64_t> lhs, ArraySlice<int64_t> rhs) {\n      if (lhs.size() < rhs.size()) return false;\n      for (size_t i = 0; i < rhs.size(); ++i) {\n        if (lhs[lhs.size() - 1 - i] < rhs[rhs.size() - 1 - i]) return false;\n      }\n      return true;\n    };\n    OP_REQUIRES(ctx, VecGreaterEq(lhs_dims, rhs_dims) && b.IsValid(),\n                errors::InvalidArgument(\n                    \"SparseDenseBinaryOpShared broadcasts dense to sparse \"\n                    \"only; got incompatible shapes: [\",\n                    absl::StrJoin(lhs_dims, \",\"), \"] vs. [\",\n                    absl::StrJoin(rhs_dims, \",\"), \"]\"));\n\n    Tensor *output_values = nullptr;\n    Tensor dense_gathered;\n    const int64_t nnz = indices_t->dim_size(0);\n    OP_REQUIRES_OK(ctx,\n                   ctx->allocate_output(0, TensorShape({nnz}), &output_values));\n    OP_REQUIRES_OK(\n        ctx, ctx->allocate_temp(DataTypeToEnum<T>::value, TensorShape({nnz}),\n                                &dense_gathered));\n    bool op_is_div = false;\n    if (absl::StrContains(ctx->op_kernel().type_string_view(), \"Div\")) {\n      op_is_div = true;\n    }\n    // Pulls relevant entries from the dense side, with reshape and broadcasting\n    // *of the dense side* taken into account.  Use a TensorRef to avoid blowing\n    // up memory.\n    //\n    // We can directly use the sparse indices to look up dense side, because\n    // \"b.y_reshape()\" and \"b.y_bcast()\" are guaranteed to have rank \"ndims\".\n    auto dense_gathered_flat = dense_gathered.flat<T>();\n    const int ndims = lhs_dims.size();\n    switch (ndims) {\n#define CASE(NDIM)                                                             \\\n  case NDIM: {                                                                 \\\n    TensorRef<Eigen::Tensor<const T, NDIM, Eigen::RowMajor>> rhs_ref =         \\\n        dense_t->shaped<T, NDIM>(b.y_reshape())                                \\\n            .broadcast(BCast::ToIndexArray<NDIM>(b.y_bcast()));                \\\n    Eigen::array<Eigen::DenseIndex, NDIM> idx;                                 \\\n    bool indices_valid = true;                                                 \\\n    for (int i = 0; i < nnz; ++i) {                                            \\\n      for (int d = 0; d < NDIM; ++d) {                                         \\\n        idx[d] = internal::SubtleMustCopy(indices_mat(i, d));                  \\\n        if (!FastBoundsCheck(idx[d], rhs_ref.dimension(d))) {                  \\\n          indices_valid = false;                                               \\\n        }                                                                      \\\n      }                                                                        \\\n      OP_REQUIRES(                                                             \\\n          ctx, indices_valid,                                                  \\\n          errors::InvalidArgument(\"Provided indices are out-of-bounds w.r.t. \" \\\n                                  \"dense side with broadcasted shape\"));       \\\n      dense_gathered_flat(i) = rhs_ref.coeff(idx);                             \\\n      if (op_is_div) {                                                         \\\n        OP_REQUIRES(ctx, dense_gathered_flat(i) != 0,                          \\\n                    errors::InvalidArgument(                                   \\\n                        \"SparseDenseCwiseDiv cannot divide by zero,\"           \\\n                        \"but input dense tensor contains zero \"));             \\\n      }                                                                        \\\n    }                                                                          \\\n    break;                                                                     \\\n  }\n\n      CASE(1);\n      CASE(2);\n      CASE(3);\n      CASE(4);\n      CASE(5);\n      default:\n        OP_REQUIRES(\n            ctx, false,\n            errors::InvalidArgument(\"Only tensors with ranks between 1 and 5 \"\n                                    \"are currently supported.  Tensor rank: \",\n                                    ndims));\n#undef CASE\n    }\n\n    output_values->flat<T>().device(ctx->eigen_device<Device>()) =\n        values_t->flat<T>().binaryExpr(dense_gathered_flat,\n                                       typename Functor::func());\n  }",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 91,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "dnsc_load_local_data(struct dnsc_env* dnscenv, struct config_file *cfg)\n{\n    size_t i, j;\n\t// Insert 'local-zone: \"2.dnscrypt-cert.example.com\" deny'\n    if(!cfg_str2list_insert(&cfg->local_zones,\n                            strdup(dnscenv->provider_name),\n                            strdup(\"deny\"))) {\n        log_err(\"Could not load dnscrypt local-zone: %s deny\",\n                dnscenv->provider_name);\n        return -1;\n    }\n\n    // Add local data entry of type:\n    // 2.dnscrypt-cert.example.com 86400 IN TXT \"DNSC......\"\n    for(i=0; i<dnscenv->signed_certs_count; i++) {\n        const char *ttl_class_type = \" 86400 IN TXT \\\"\";\n        int rotated_cert = 0;\n\tuint32_t serial;\n\tuint16_t rrlen;\n\tchar* rr;\n        struct SignedCert *cert = dnscenv->signed_certs + i;\n\t\t// Check if the certificate is being rotated and should not be published\n        for(j=0; j<dnscenv->rotated_certs_count; j++){\n            if(cert == dnscenv->rotated_certs[j]) {\n                rotated_cert = 1;\n                break;\n            }\n        }\n\t\tmemcpy(&serial, cert->serial, sizeof serial);\n\t\tserial = htonl(serial);\n        if(rotated_cert) {\n            verbose(VERB_OPS,\n                \"DNSCrypt: not adding cert with serial #%\"\n                PRIu32\n                \" to local-data as it is rotated\",\n                serial\n            );\n            continue;\n        }\n\tif((unsigned)strlen(dnscenv->provider_name) >= (unsigned)0xffff0000) {\n\t\t/* guard against integer overflow in rrlen calculation */\n\t\tverbose(VERB_OPS, \"cert #%\" PRIu32 \" is too long\", serial);\n\t\tcontinue\n\t}\n        rrlen = strlen(dnscenv->provider_name) +\n                         strlen(ttl_class_type) +\n                         4 * sizeof(struct SignedCert) + // worst case scenario\n                         1 + // trailing double quote\n                         1;\n        rr = malloc(rrlen);\n        if(!rr) {\n            log_err(\"Could not allocate memory\");\n            return -2;\n        }\n        snprintf(rr, rrlen - 1, \"%s 86400 IN TXT \\\"\", dnscenv->provider_name);\n        for(j=0; j<sizeof(struct SignedCert); j++) {\n\t\t\tint c = (int)*((const uint8_t *) cert + j);\n            if (isprint(c) && c != '\"' && c != '\\\\') {\n                snprintf(rr + strlen(rr), rrlen - 1 - strlen(rr), \"%c\", c);\n            } else {\n                snprintf(rr + strlen(rr), rrlen - 1 - strlen(rr), \"\\\\%03d\", c);\n            }\n        }\n        verbose(VERB_OPS,\n\t\t\t\"DNSCrypt: adding cert with serial #%\"\n\t\t\tPRIu32\n\t\t\t\" to local-data to config: %s\",\n\t\t\tserial, rr\n\t\t);\n        snprintf(rr + strlen(rr), rrlen - 1 - strlen(rr), \"\\\"\");\n        cfg_strlist_insert(&cfg->local_data, strdup(rr));\n        free(rr);\n    }\n    return dnscenv->signed_certs_count;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 570,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "static PresentationContext* PresentationContext_new(VideoClientContext* video, BYTE PresentationId,\n                                                    UINT32 x, UINT32 y, UINT32 width, UINT32 height)\n{\n\tsize_t s;\n\tVideoClientContextPriv* priv = video->priv;\n\tPresentationContext* ret;\n\ts = width * height * 4ULL;\n\tif (s > INT32_MAX)\n\t\treturn NULL;\n\n\tret = calloc(1, sizeof(*ret));\n\tif (!ret)\n\t\treturn NULL;\n\n\tret->video = video;\n\tret->PresentationId = PresentationId;\n\n\tret->h264 = h264_context_new(FALSE);\n\tif (!ret->h264)\n\t{\n\t\tWLog_ERR(TAG, \"unable to create a h264 context\");\n\t\tgoto error_h264;\n\t}\n\th264_context_reset(ret->h264, width, height);\n\n\tret->currentSample = Stream_New(NULL, 4096);\n\tif (!ret->currentSample)\n\t{\n\t\tWLog_ERR(TAG, \"unable to create current packet stream\");\n\t\tgoto error_currentSample;\n\t}\n\n\tret->surfaceData = BufferPool_Take(priv->surfacePool, s);\n\tif (!ret->surfaceData)\n\t{\n\t\tWLog_ERR(TAG, \"unable to allocate surfaceData\");\n\t\tgoto error_surfaceData;\n\t}\n\n\tret->surface = video->createSurface(video, ret->surfaceData, x, y, width, height);\n\tif (!ret->surface)\n\t{\n\t\tWLog_ERR(TAG, \"unable to create surface\");\n\t\tgoto error_surface;\n\t}\n\n\tret->yuv = yuv_context_new(FALSE);\n\tif (!ret->yuv)\n\t{\n\t\tWLog_ERR(TAG, \"unable to create YUV decoder\");\n\t\tgoto error_yuv;\n\t}\n\n\tyuv_context_reset(ret->yuv, width, height);\n\tret->refCounter = 1;\n\treturn ret;\n\nerror_yuv:\n\tvideo->deleteSurface(video, ret->surface);\nerror_surface:\n\tBufferPool_Return(priv->surfacePool, ret->surfaceData);\nerror_surfaceData:\n\tStream_Free(ret->currentSample, TRUE);\nerror_currentSample:\n\th264_context_free(ret->h264);\nerror_h264:\n\tfree(ret);\n\treturn NULL;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 590,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  },
  {
    "CWE_ID": [
      "CWE-190"
    ],
    "code": "processDataRcvd(ptcpsess_t *const __restrict__ pThis,\n\tchar **buff,\n\tconst int buffLen,\n\tstruct syslogTime *stTime,\n\tconst time_t ttGenTime,\n\tmulti_submit_t *pMultiSub,\n\tunsigned *const __restrict__ pnMsgs)\n{\n\tDEFiRet;\n\tchar c = **buff;\n\tint octatesToCopy, octatesToDiscard;\n\n\tif(pThis->inputState == eAtStrtFram) {\n\t\tif(pThis->bSuppOctetFram && isdigit((int) c)) {\n\t\t\tpThis->inputState = eInOctetCnt;\n\t\t\tpThis->iOctetsRemain = 0;\n\t\t\tpThis->eFraming = TCP_FRAMING_OCTET_COUNTING;\n\t\t} else if(pThis->bSPFramingFix && c == ' ') {\n\t\t\t/* Cisco very occasionally sends a SP after a LF, which\n\t\t\t * thrashes framing if not taken special care of. Here,\n\t\t\t * we permit space *in front of the next frame* and\n\t\t\t * ignore it.\n\t\t\t */\n\t\t\t FINALIZE;\n\t\t} else {\n\t\t\tpThis->inputState = eInMsg;\n\t\t\tpThis->eFraming = TCP_FRAMING_OCTET_STUFFING;\n\t\t}\n\t}\n\n\tif(pThis->inputState == eInOctetCnt) {\n\t\tif(isdigit(c)) {\n\t\t\tif(pThis->iOctetsRemain <= 200000000) {\n\t\t\t\tpThis->iOctetsRemain = pThis->iOctetsRemain * 10 + c - '0';\n\t\t\t} else {\n\t\t\t\terrmsg.LogError(0, NO_ERRCODE, \"Framing Error in received TCP message: \"\n\t\t\t\t\t\t\"frame too large (at least %d%c), change to octet stuffing\",\n\t\t\t\t\t\tpThis->iOctetsRemain, c);\n\t\t\t\tpThis->eFraming = TCP_FRAMING_OCTET_STUFFING;\n\t\t\t\tpThis->inputState = eInMsg;\n\t\t\t}\n\t\t\t*(pThis->pMsg + pThis->iMsg++) = c;\n\t\t} else { /* done with the octet count, so this must be the SP terminator */\n\t\t\tDBGPRINTF(\"TCP Message with octet-counter, size %d.\\n\", pThis->iOctetsRemain);\n\t\t\tif(c != ' ') {\n\t\t\t\terrmsg.LogError(0, NO_ERRCODE, \"Framing Error in received TCP message: \"\n\t\t\t\t\t    \"delimiter is not SP but has ASCII value %d.\", c);\n\t\t\t}\n\t\t\tif(pThis->iOctetsRemain < 1) {\n\t\t\t\t/* TODO: handle the case where the octet count is 0! */\n\t\t\t\terrmsg.LogError(0, NO_ERRCODE, \"Framing Error in received TCP message: \"\n\t\t\t\t\t    \"invalid octet count %d.\", pThis->iOctetsRemain);\n\t\t\t\tpThis->eFraming = TCP_FRAMING_OCTET_STUFFING;\n\t\t\t} else if(pThis->iOctetsRemain > iMaxLine) {\n\t\t\t\t/* while we can not do anything against it, we can at least log an indication\n\t\t\t\t * that something went wrong) -- rgerhards, 2008-03-14\n\t\t\t\t */\n\t\t\t\tDBGPRINTF(\"truncating message with %d octets - max msg size is %d\\n\",\n\t\t\t\t\t  pThis->iOctetsRemain, iMaxLine);\n\t\t\t\terrmsg.LogError(0, NO_ERRCODE, \"received oversize message: size is %d bytes, \"\n\t\t\t\t\t        \"max msg size is %d, truncating...\", pThis->iOctetsRemain, iMaxLine);\n\t\t\t}\n\t\t\tpThis->inputState = eInMsg;\n\t\t\tpThis->iMsg = 0;\n\t\t}\n\t} else {\n\t\tassert(pThis->inputState == eInMsg);\n\n\t\tif (pThis->eFraming == TCP_FRAMING_OCTET_STUFFING) {\n\t\t\tif(pThis->iMsg >= iMaxLine) {\n\t\t\t\t/* emergency, we now need to flush, no matter if we are at end of message or not... */\n\t\t\t\tint i = 1;\n\t\t\t\tchar currBuffChar;\n\t\t\t\twhile(i < buffLen && ((currBuffChar = (*buff)[i]) != '\\n'\n\t\t\t\t\t&& (pThis->pLstn->pSrv->iAddtlFrameDelim == TCPSRV_NO_ADDTL_DELIMITER\n\t\t\t\t\t\t|| currBuffChar != pThis->pLstn->pSrv->iAddtlFrameDelim))) {\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\tLogError(0, NO_ERRCODE, \"error: message received is at least %d byte larger than max msg\"\n\t\t\t\t\t\" size; message will be split starting at: \\\"%.*s\\\"\\n\", i, (i < 32) ? i : 32, *buff);\n\t\t\t\tdoSubmitMsg(pThis, stTime, ttGenTime, pMultiSub);\n\t\t\t\t++(*pnMsgs);\n\t\t\t\t/* we might think if it is better to ignore the rest of the\n\t\t\t\t * message than to treat it as a new one. Maybe this is a good\n\t\t\t\t * candidate for a configuration parameter...\n\t\t\t\t * rgerhards, 2006-12-04\n\t\t\t\t */\n\t\t\t}\n\n\t\t\tif ((c == '\\n')\n\t\t\t\t   || ((pThis->pLstn->pSrv->iAddtlFrameDelim != TCPSRV_NO_ADDTL_DELIMITER)\n\t\t\t\t\t   && (c == pThis->pLstn->pSrv->iAddtlFrameDelim))\n\t\t\t\t   ) { /* record delimiter? */\n\t\t\t\tdoSubmitMsg(pThis, stTime, ttGenTime, pMultiSub);\n\t\t\t\t++(*pnMsgs);\n\t\t\t\tpThis->inputState = eAtStrtFram;\n\t\t\t} else {\n\t\t\t\t/* IMPORTANT: here we copy the actual frame content to the message - for BOTH framing modes!\n\t\t\t\t * If we have a message that is larger than the max msg size, we truncate it. This is the best\n\t\t\t\t * we can do in light of what the engine supports. -- rgerhards, 2008-03-14\n\t\t\t\t */\n\t\t\t\tif(pThis->iMsg < iMaxLine) {\n\t\t\t\t\t*(pThis->pMsg + pThis->iMsg++) = c;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tassert(pThis->eFraming == TCP_FRAMING_OCTET_COUNTING);\n\t\t\toctatesToCopy = pThis->iOctetsRemain;\n\t\t\toctatesToDiscard = 0;\n\t\t\tif (buffLen < octatesToCopy) {\n\t\t\t\toctatesToCopy = buffLen;\n\t\t\t}\n\t\t\tif (octatesToCopy + pThis->iMsg > iMaxLine) {\n\t\t\t\toctatesToDiscard = octatesToCopy - (iMaxLine - pThis->iMsg);\n\t\t\t\toctatesToCopy = iMaxLine - pThis->iMsg;\n\t\t\t}\n\n\t\t\tmemcpy(pThis->pMsg + pThis->iMsg, *buff, octatesToCopy);\n\t\t\tpThis->iMsg += octatesToCopy;\n\t\t\tpThis->iOctetsRemain -= (octatesToCopy + octatesToDiscard);\n\t\t\t*buff += (octatesToCopy + octatesToDiscard - 1);\n\t\t\tif (pThis->iOctetsRemain == 0) {\n\t\t\t\t/* we have end of frame! */\n\t\t\t\tdoSubmitMsg(pThis, stTime, ttGenTime, pMultiSub);\n\t\t\t\t++(*pnMsgs);\n\t\t\t\tpThis->inputState = eAtStrtFram;\n\t\t\t}\n\t\t}\n\n\t}\n\nfinalize_it:\n\tRETiRet;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 730,
    "RELATED_CWE": [
      "CWE-191",
      "CWE-192",
      "CWE-122"
    ]
  }
]